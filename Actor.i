#line 1 "C:\\Users\\serpentiem\\source\\repos\\ddmk\\Mary\\Actor.ixx"
// @Todo: Add Air Raid to IsActive.
// @Todo: Disable Doppelganger on death.
// @Todo: Merge Reset Permissions.
// @Todo: Cleanup.
// @Todo: Color Toggle.
// @Todo: Air Stinger, Air Lunar Phase and Nevan instant Vortex.
// @Todo: Quick Drive.

module;
#line 1 "C:\\Users\\serpentiem\\source\\repos\\ddmk\\Core\\Core.h"
#line 1 "C:\\Users\\serpentiem\\source\\repos\\ddmk\\Core\\Includes.h"
#pragma once


#line 1 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt\\stdio.h"
//
// stdio.h
//
//      Copyright (c) Microsoft Corporation. All rights reserved.
//
// The C Standard Library <stdio.h> header.
//
#pragma once



#line 1 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt\\corecrt.h"
//
// corecrt.h
//
//      Copyright (c) Microsoft Corporation. All rights reserved.
//
// Declarations used throughout the CoreCRT library.
//
#pragma once

#line 1 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.28.29333\\include\\vcruntime.h"
//
// vcruntime.h
//
//      Copyright (c) Microsoft Corporation. All rights reserved.
//
// Declarations used throughout the VCRuntime library.
//
#pragma once
//
// Note on use of "deprecate":
//
// Various places in this header and other headers use
// __declspec(deprecate) or macros that have the term DEPRECATE in them.
// We use "deprecate" here ONLY to signal the compiler to emit a warning
// about these items. The use of "deprecate" should NOT be taken to imply
// that any standard committee has deprecated these functions from the
// relevant standards.  In fact, these functions are NOT deprecated from
// the standard.
//
// Full details can be found in our documentation by searching for
// "Security Enhancements in the CRT".
//




// Many VCRuntime headers avoid exposing their contents to non-compilers like
// the Windows resource compiler and Qt's meta-object compiler (moc).


#line 32 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.28.29333\\include\\vcruntime.h"

#line 34 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.28.29333\\include\\vcruntime.h"
#line 35 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.28.29333\\include\\vcruntime.h"


    
#line 39 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.28.29333\\include\\vcruntime.h"

// The _CRTIMP macro is not used in the VCRuntime or the CoreCRT anymore, but
// there is a lot of existing code that declares CRT functions using this macro,
// and if we remove its definition, we break that existing code.  It is thus
// defined here only for compatibility.

    
    

#line 49 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.28.29333\\include\\vcruntime.h"
        
            
        

#line 54 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.28.29333\\include\\vcruntime.h"
    #line 55 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.28.29333\\include\\vcruntime.h"
#line 56 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.28.29333\\include\\vcruntime.h"

#line 1 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\shared\\sal.h"
/***
*sal.h - markers for documenting the semantics of APIs
*
*       Copyright (c) Microsoft Corporation. All rights reserved.
*
*Purpose:
*       sal.h provides a set of annotations to describe how a function uses its
*       parameters - the assumptions it makes about them, and the guarantees it makes
*       upon finishing.
*
*       [Public]
*
****/
#pragma once

/*==========================================================================

   The comments in this file are intended to give basic understanding of
   the usage of SAL, the Microsoft Source Code Annotation Language.
   For more details, please see https://go.microsoft.com/fwlink/?LinkID=242134

   The macros are defined in 3 layers, plus the structural set:

   _In_/_Out_/_Ret_ Layer:
   ----------------------
   This layer provides the highest abstraction and its macros should be used
   in most cases. These macros typically start with:
      _In_     : input parameter to a function, unmodified by called function
      _Out_    : output parameter, written to by called function, pointed-to
                 location not expected to be initialized prior to call
      _Outptr_ : like _Out_ when returned variable is a pointer type
                 (so param is pointer-to-pointer type). Called function
                 provides/allocated space.
      _Outref_ : like _Outptr_, except param is reference-to-pointer type.
      _Inout_  : inout parameter, read from and potentially modified by
                 called function.
      _Ret_    : for return values
      _Field_  : class/struct field invariants
   For common usage, this class of SAL provides the most concise annotations.
   Note that _In_/_Out_/_Inout_/_Outptr_ annotations are designed to be used
   with a parameter target. Using them with _At_ to specify non-parameter
   targets may yield unexpected results.

   This layer also includes a number of other properties that can be specified
   to extend the ability of code analysis, most notably:
      -- Designating parameters as format strings for printf/scanf/scanf_s
      -- Requesting stricter type checking for C enum parameters

   _Pre_/_Post_ Layer:
   ------------------
   The macros of this layer only should be used when there is no suitable macro
   in the _In_/_Out_ layer. Its macros start with _Pre_ or _Post_.
   This layer provides the most flexibility for annotations.

   Implementation Abstraction Layer:
   --------------------------------
   Macros from this layer should never be used directly. The layer only exists
   to hide the implementation of the annotation macros.

   Structural Layer:
   ----------------
   These annotations, like _At_ and _When_, are used with annotations from
   any of the other layers as modifiers, indicating exactly when and where
   the annotations apply.


   Common syntactic conventions:
   ----------------------------

   Usage:
   -----
   _In_, _Out_, _Inout_, _Pre_, _Post_, are for formal parameters.
   _Ret_, _Deref_ret_ must be used for return values.

   Nullness:
   --------
   If the parameter can be NULL as a precondition to the function, the
   annotation contains _opt. If the macro does not contain '_opt' the
   parameter cannot be NULL.

   If an out/inout parameter returns a null pointer as a postcondition, this is
   indicated by _Ret_maybenull_ or _result_maybenull_. If the macro is not
   of this form, then the result will not be NULL as a postcondition.
     _Outptr_ - output value is not NULL
     _Outptr_result_maybenull_ - output value might be NULL

   String Type:
   -----------
   _z: NullTerminated string
   for _In_ parameters the buffer must have the specified stringtype before the call
   for _Out_ parameters the buffer must have the specified stringtype after the call
   for _Inout_ parameters both conditions apply

   Extent Syntax:
   -------------
   Buffer sizes are expressed as element counts, unless the macro explicitly
   contains _byte_ or _bytes_. Some annotations specify two buffer sizes, in
   which case the second is used to indicate how much of the buffer is valid
   as a postcondition. This table outlines the precondition buffer allocation
   size, precondition number of valid elements, postcondition allocation size,
   and postcondition number of valid elements for representative buffer size
   annotations:
                                     Pre    |  Pre    |  Post   |  Post
                                     alloc  |  valid  |  alloc  |  valid
      Annotation                     elems  |  elems  |  elems  |  elems
      ----------                     ------------------------------------
      _In_reads_(s)                    s    |   s     |   s     |   s
      _Inout_updates_(s)               s    |   s     |   s     |   s
      _Inout_updates_to_(s,c)          s    |   s     |   s     |   c
      _Out_writes_(s)                  s    |   0     |   s     |   s
      _Out_writes_to_(s,c)             s    |   0     |   s     |   c
      _Outptr_result_buffer_(s)        ?    |   ?     |   s     |   s
      _Outptr_result_buffer_to_(s,c)   ?    |   ?     |   s     |   c

   For the _Outptr_ annotations, the buffer in question is at one level of
   dereference. The called function is responsible for supplying the buffer.

   Success and failure:
   -------------------
   The SAL concept of success allows functions to define expressions that can
   be tested by the caller, which if it evaluates to non-zero, indicates the
   function succeeded, which means that its postconditions are guaranteed to
   hold.  Otherwise, if the expression evaluates to zero, the function is
   considered to have failed, and the postconditions are not guaranteed.

   The success criteria can be specified with the _Success_(expr) annotation:
     _Success_(return != FALSE) BOOL
     PathCanonicalizeA(_Out_writes_(MAX_PATH) LPSTR pszBuf, LPCSTR pszPath) :
        pszBuf is only guaranteed to be NULL-terminated when TRUE is returned,
        and FALSE indiates failure. In common practice, callers check for zero
        vs. non-zero returns, so it is preferable to express the success
        criteria in terms of zero/non-zero, not checked for exactly TRUE.

   Functions can specify that some postconditions will still hold, even when
   the function fails, using _On_failure_(anno-list), or postconditions that
   hold regardless of success or failure using _Always_(anno-list).

   The annotation _Return_type_success_(expr) may be used with a typedef to
   give a default _Success_ criteria to all functions returning that type.
   This is the case for common Windows API status types, including
   HRESULT and NTSTATUS.  This may be overridden on a per-function basis by
   specifying a _Success_ annotation locally.

============================================================================*/





#line 151 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\shared\\sal.h"



#line 155 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\shared\\sal.h"

























// Disable expansion of SAL macros in non-Prefast mode to
// improve compiler throughput.


#line 185 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\shared\\sal.h"


#line 188 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\shared\\sal.h"

#line 190 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\shared\\sal.h"

// safeguard for MIDL and RC builds



#line 196 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\shared\\sal.h"



#line 200 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\shared\\sal.h"






#line 207 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\shared\\sal.h"











#line 219 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\shared\\sal.h"






// Some annotations aren't officially SAL2 yet.

#line 228 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\shared\\sal.h"
#line 229 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\shared\\sal.h"


//============================================================================
//   Structural SAL:
//     These annotations modify the use of other annotations.  They may
//     express the annotation target (i.e. what parameter/field the annotation
//     applies to) or the condition under which the annotation is applicable.
//============================================================================

// _At_(target, annos) specifies that the annotations listed in 'annos' is to
// be applied to 'target' rather than to the identifier which is the current
// lexical target.


// _At_buffer_(target, iter, bound, annos) is similar to _At_, except that
// target names a buffer, and each annotation in annos is applied to each
// element of target up to bound, with the variable named in iter usable
// by the annotations to refer to relevant offsets within target.


// _When_(expr, annos) specifies that the annotations listed in 'annos' only
// apply when 'expr' evaluates to non-zero.




// <expr> indicates whether normal post conditions apply to a function


// <expr> indicates whether post conditions apply to a function returning
// the type that this annotation is applied to


// Establish postconditions that apply only if the function does not succeed


// Establish postconditions that apply in both success and failure cases.
// Only applicable with functions that have  _Success_ or _Return_type_succss_.


// Usable on a function defintion. Asserts that a function declaration is
// in scope, and its annotations are to be used. There are no other annotations
// allowed on the function definition.


// _Notref_ may precede a _Deref_ or "real" annotation, and removes one
// level of dereference if the parameter is a C++ reference (&).  If the
// net deref on a "real" annotation is negative, it is simply discarded.


// Annotations for defensive programming styles.







//============================================================================
//   _In_/_Out_ Layer:
//============================================================================

// Reserved pointer parameters, must always be NULL.


// _Const_ allows specification that any namable memory location is considered
// readonly for a given call.



// Input parameters --------------------------

//   _In_ - Annotations for parameters where data is passed into the function, but not modified.
//          _In_ by itself can be used with non-pointer types (although it is redundant).

// e.g. void SetPoint( _In_ const POINT* pPT );



// nullterminated 'in' parameters.
// e.g. void CopyStr( _In_z_ const char* szFrom, _Out_z_cap_(cchTo) char* szTo, size_t cchTo );




// 'input' buffers with given size











// 'input' buffers valid to the given end pointer








// Output parameters --------------------------

//   _Out_ - Annotations for pointer or reference parameters where data passed back to the caller.
//           These are mostly used where the pointer/reference is to a non-pointer type.
//           _Outptr_/_Outref) (see below) are typically used to return pointers via parameters.

// e.g. void GetPoint( _Out_ POINT* pPT );


























// Inout parameters ----------------------------

//   _Inout_ - Annotations for pointer or reference parameters where data is passed in and
//        potentially modified.
//          void ModifyPoint( _Inout_ POINT* pPT );
//          void ModifyPointByRef( _Inout_ POINT& pPT );




// For modifying string buffers
//   void toupper( _Inout_z_ char* sz );



// For modifying buffers with explicit element size











// For modifying buffers with explicit byte size










// Pointer to pointer parameters -------------------------

//   _Outptr_ - Annotations for output params returning pointers
//      These describe parameters where the called function provides the buffer:
//        HRESULT SHStrDupW(_In_ LPCWSTR psz, _Outptr_ LPWSTR *ppwsz);
//      The caller passes the address of an LPWSTR variable as ppwsz, and SHStrDupW allocates
//      and initializes memory and returns the pointer to the new LPWSTR in *ppwsz.
//
//    _Outptr_opt_ - describes parameters that are allowed to be NULL.
//    _Outptr_*_result_maybenull_ - describes parameters where the called function might return NULL to the caller.
//
//    Example:
//       void MyFunc(_Outptr_opt_ int **ppData1, _Outptr_result_maybenull_ int **ppData2);
//    Callers:
//       MyFunc(NULL, NULL);           // error: parameter 2, ppData2, should not be NULL
//       MyFunc(&pData1, &pData2);     // ok: both non-NULL
//       if (*pData1 == *pData2) ...   // error: pData2 might be NULL after call






// Annotations for _Outptr_ parameters returning pointers to null terminated strings.






// Annotations for _Outptr_ parameters where the output pointer is set to NULL if the function fails.




// Annotations for _Outptr_ parameters which return a pointer to a ref-counted COM object,
// following the COM convention of setting the output to NULL on failure.
// The current implementation is identical to _Outptr_result_nullonfailure_.
// For pointers to types that are not COM objects, _Outptr_result_nullonfailure_ is preferred.






// Annotations for _Outptr_ parameters returning a pointer to buffer with a specified number of elements/bytes

































// Annotations for output reference to pointer parameters.


















// Annotations for output reference to pointer parameters that guarantee
// that the pointer is set to NULL on failure.


// Generic annotations to set output value of a by-pointer or by-reference parameter to null/zero on failure.




// return values -------------------------------

//
// _Ret_ annotations
//
// describing conditions that hold for return values after the call

// e.g. _Ret_z_ CString::operator const wchar_t*() const noexcept;



// used with allocated but not yet initialized objects




// used with allocated and initialized objects
//    returns single valid object


//    returns pointer to initialized buffer of specified size







//    returns pointer to partially initialized buffer, with total size 'size' and initialized size 'count'






// Annotations for strict type checking




// Check the return value of a function e.g. _Check_return_ ErrorCode Foo();



// e.g. MyPrintF( _Printf_format_string_ const wchar_t* wzFormat, ... );









// annotations to express value of integral or pointer parameter









// annotation to express that a value (usually a field of a mutable class)
// is not changed by a function call


// Annotations to allow expressing generalized pre and post conditions.
// 'cond' may be any valid SAL expression that is considered to be true as a precondition
// or postcondition (respsectively).



// Annotations to express struct, class and field invariants




















//============================================================================
//   _Pre_/_Post_ Layer:
//============================================================================

//
// Raw Pre/Post for declaring custom pre/post conditions
//




//
// Validity property
//





//
// Buffer size properties
//

// Expressing buffer sizes without specifying pre or post condition








// Expressing buffer size as pre or post condition










//
// Pointer null-ness properties
//




//
// _Pre_ annotations ---
//
// describing conditions that must be met before the call of the function

// e.g. int strlen( _Pre_z_ const char* sz );
// buffer is a zero terminated string


// valid size unknown or indicated by type (e.g.:LPSTR)





// Overrides recursive valid when some field is not yet initialized when using _Inout_


// used with allocated but not yet initialized objects




//
// _Post_ annotations ---
//
// describing conditions that hold after the function call

// void CopyStr( _In_z_ const char* szFrom, _Pre_cap_(cch) _Post_z_ char* szFrom, size_t cchFrom );
// buffer will be a zero-terminated string after the call


// e.g. HRESULT InitStruct( _Post_valid_ Struct* pobj );



// e.g. void free( _Post_ptr_invalid_ void* pv );


// e.g. void ThrowExceptionIfNull( _Post_notnull_ const void* pv );


// e.g. HRESULT GetObject(_Outptr_ _On_failure_(_At_(*p, _Post_null_)) T **p);







#pragma region Input Buffer SAL 1 compatibility macros

/*==========================================================================

   This section contains definitions for macros defined for VS2010 and earlier.
   Usage of these macros is still supported, but the SAL 2 macros defined above
   are recommended instead.  This comment block is retained to assist in
   understanding SAL that still uses the older syntax.

   The macros are defined in 3 layers:

   _In_/_Out_ Layer:
   ----------------
   This layer provides the highest abstraction and its macros should be used
   in most cases. Its macros start with _In_, _Out_ or _Inout_. For the
   typical case they provide the most concise annotations.

   _Pre_/_Post_ Layer:
   ------------------
   The macros of this layer only should be used when there is no suitable macro
   in the _In_/_Out_ layer. Its macros start with _Pre_, _Post_, _Ret_,
   _Deref_pre_ _Deref_post_ and _Deref_ret_. This layer provides the most
   flexibility for annotations.

   Implementation Abstraction Layer:
   --------------------------------
   Macros from this layer should never be used directly. The layer only exists
   to hide the implementation of the annotation macros.


   Annotation Syntax:
   |--------------|----------|----------------|-----------------------------|
   |   Usage      | Nullness | ZeroTerminated |  Extent                     |
   |--------------|----------|----------------|-----------------------------|
   | _In_         | <>       | <>             | <>                          |
   | _Out_        | opt_     | z_             | [byte]cap_[c_|x_]( size )   |
   | _Inout_      |          |                | [byte]count_[c_|x_]( size ) |
   | _Deref_out_  |          |                | ptrdiff_cap_( ptr )         |
   |--------------|          |                | ptrdiff_count_( ptr )       |
   | _Ret_        |          |                |                             |
   | _Deref_ret_  |          |                |                             |
   |--------------|          |                |                             |
   | _Pre_        |          |                |                             |
   | _Post_       |          |                |                             |
   | _Deref_pre_  |          |                |                             |
   | _Deref_post_ |          |                |                             |
   |--------------|----------|----------------|-----------------------------|

   Usage:
   -----
   _In_, _Out_, _Inout_, _Pre_, _Post_, _Deref_pre_, _Deref_post_ are for
   formal parameters.
   _Ret_, _Deref_ret_ must be used for return values.

   Nullness:
   --------
   If the pointer can be NULL the annotation contains _opt. If the macro
   does not contain '_opt' the pointer may not be NULL.

   String Type:
   -----------
   _z: NullTerminated string
   for _In_ parameters the buffer must have the specified stringtype before the call
   for _Out_ parameters the buffer must have the specified stringtype after the call
   for _Inout_ parameters both conditions apply

   Extent Syntax:
   |------|---------------|---------------|
   | Unit | Writ/Readable | Argument Type |
   |------|---------------|---------------|
   |  <>  | cap_          | <>            |
   | byte | count_        | c_            |
   |      |               | x_            |
   |------|---------------|---------------|

   'cap' (capacity) describes the writable size of the buffer and is typically used
   with _Out_. The default unit is elements. Use 'bytecap' if the size is given in bytes
   'count' describes the readable size of the buffer and is typically used with _In_.
   The default unit is elements. Use 'bytecount' if the size is given in bytes.

   Argument syntax for cap_, bytecap_, count_, bytecount_:
   (<parameter>|return)[+n]  e.g. cch, return, cb+2

   If the buffer size is a constant expression use the c_ postfix.
   E.g. cap_c_(20), count_c_(MAX_PATH), bytecount_c_(16)

   If the buffer size is given by a limiting pointer use the ptrdiff_ versions
   of the macros.

   If the buffer size is neither a parameter nor a constant expression use the x_
   postfix. e.g. bytecount_x_(num*size) x_ annotations accept any arbitrary string.
   No analysis can be done for x_ annotations but they at least tell the tool that
   the buffer has some sort of extent description. x_ annotations might be supported
   by future compiler versions.

============================================================================*/

// e.g. void SetCharRange( _In_count_(cch) const char* rgch, size_t cch )
// valid buffer extent described by another parameter





// valid buffer extent described by a constant extression





// nullterminated  'input' buffers with given size

// e.g. void SetCharRange( _In_count_(cch) const char* rgch, size_t cch )
// nullterminated valid buffer extent described by another parameter





// nullterminated valid buffer extent described by a constant extression





// buffer capacity is described by another pointer
// e.g. void Foo( _In_ptrdiff_count_(pchMax) const char* pch, const char* pchMax ) { while pch < pchMax ) pch++; }



// 'x' version for complex expressions that are not supported by the current compiler version
// e.g. void Set3ColMatrix( _In_count_x_(3*cRows) const Elem* matrix, int cRows );






// 'out' with buffer size
// e.g. void GetIndeces( _Out_cap_(cIndeces) int* rgIndeces, size_t cIndices );
// buffer capacity is described by another parameter





// buffer capacity is described by a constant expression





// buffer capacity is described by another parameter multiplied by a constant expression





// buffer capacity is described by another pointer
// e.g. void Foo( _Out_ptrdiff_cap_(pchMax) char* pch, const char* pchMax ) { while pch < pchMax ) pch++; }



// buffer capacity is described by a complex expression





// a zero terminated string is filled into a buffer of given capacity
// e.g. void CopyStr( _In_z_ const char* szFrom, _Out_z_cap_(cchTo) char* szTo, size_t cchTo );
// buffer capacity is described by another parameter





// buffer capacity is described by a constant expression





// buffer capacity is described by a complex expression





// a zero terminated string is filled into a buffer of given capacity
// e.g. size_t CopyCharRange( _In_count_(cchFrom) const char* rgchFrom, size_t cchFrom, _Out_cap_post_count_(cchTo,return)) char* rgchTo, size_t cchTo );





// a zero terminated string is filled into a buffer of given capacity
// e.g. size_t CopyStr( _In_z_ const char* szFrom, _Out_z_cap_post_count_(cchTo,return+1) char* szTo, size_t cchTo );





// only use with dereferenced arguments e.g. '*pcch'










// e.g. GetString( _Out_z_capcount_(*pLen+1) char* sz, size_t* pLen );






// 'inout' buffers with initialized elements before and after the call
// e.g. void ModifyIndices( _Inout_count_(cIndices) int* rgIndeces, size_t cIndices );










// nullterminated 'inout' buffers with initialized elements before and after the call
// e.g. void ModifyIndices( _Inout_count_(cIndices) int* rgIndeces, size_t cIndices );


















// e.g. void AppendToLPSTR( _In_ LPCSTR szFrom, _Inout_cap_(cchTo) LPSTR* szTo, size_t cchTo );















// inout string buffers with writable size
// e.g. void AppendStr( _In_z_ const char* szFrom, _Inout_z_cap_(cchTo) char* szTo, size_t cchTo );
















// returning pointers to valid objects



// annotations to express 'boundedness' of integral value parameter








// e.g.  HRESULT HrCreatePoint( _Deref_out_opt_ POINT** ppPT );





// e.g.  void CloneString( _In_z_ const wchar_t* wzFrom, _Deref_out_z_ wchar_t** pWzTo );





//
// _Deref_pre_ ---
//
// describing conditions for array elements of dereferenced pointer parameters that must be met before the call

// e.g. void SaveStringArray( _In_count_(cStrings) _Deref_pre_z_ const wchar_t* const rgpwch[] );



// e.g. void FillInArrayOfStr32( _In_count_(cStrings) _Deref_pre_cap_c_(32) _Deref_post_z_ wchar_t* const rgpwch[] );
// buffer capacity is described by another parameter





// buffer capacity is described by a constant expression





// buffer capacity is described by a complex condition





// convenience macros for nullterminated buffers with given capacity















// known capacity and valid but unknown readable extent















// e.g. void SaveMatrix( _In_count_(n) _Deref_pre_count_(n) const Elem** matrix, size_t n );
// valid buffer extent is described by another parameter





// valid buffer extent is described by a constant expression





// valid buffer extent is described by a complex expression





// e.g. void PrintStringArray( _In_count_(cElems) _Deref_pre_valid_ LPCSTR rgStr[], size_t cElems );








// restrict access rights



//
// _Deref_post_ ---
//
// describing conditions for array elements or dereferenced pointer parameters that hold after the call

// e.g. void CloneString( _In_z_ const Wchar_t* wzIn _Out_ _Deref_post_z_ wchar_t** pWzOut );



// e.g. HRESULT HrAllocateMemory( size_t cb, _Out_ _Deref_post_bytecap_(cb) void** ppv );
// buffer capacity is described by another parameter





// buffer capacity is described by a constant expression





// buffer capacity is described by a complex expression





// convenience macros for nullterminated buffers with given capacity















// known capacity and valid but unknown readable extent















// e.g. HRESULT HrAllocateZeroInitializedMemory( size_t cb, _Out_ _Deref_post_bytecount_(cb) void** ppv );
// valid buffer extent is described by another parameter





// buffer capacity is described by a constant expression





// buffer capacity is described by a complex expression





// e.g. void GetStrings( _Out_count_(cElems) _Deref_post_valid_ LPSTR const rgStr[], size_t cElems );







//
// _Deref_ret_ ---
//




//
// special _Deref_ ---
//


//
// _Ret_ ---
//

// e.g. _Ret_opt_valid_ LPSTR void* CloneSTR( _Pre_valid_ LPSTR src );



// e.g. _Ret_opt_bytecap_(cb) void* AllocateMemory( size_t cb );
// Buffer capacity is described by another parameter





// Buffer capacity is described by a constant expression





// Buffer capacity is described by a complex condition





// return value is nullterminated and capacity is given by another parameter





// e.g. _Ret_opt_bytecount_(cb) void* AllocateZeroInitializedMemory( size_t cb );
// Valid Buffer extent is described by another parameter





// Valid Buffer extent is described by a constant expression





// Valid Buffer extent is described by a complex expression





// return value is nullterminated and length is given by another parameter






// _Pre_ annotations ---


// restrict access rights



// e.g. void FreeMemory( _Pre_bytecap_(cb) _Post_ptr_invalid_ void* pv, size_t cb );
// buffer capacity described by another parameter





// buffer capacity described by a constant expression







// buffer capacity is described by another parameter multiplied by a constant expression



// buffer capacity described by size of other buffer, only used by dangerous legacy APIs
// e.g. int strcpy(_Pre_cap_for_(src) char* dst, const char* src);



// buffer capacity described by a complex condition





// buffer capacity described by the difference to another pointer parameter



// e.g. void AppendStr( _Pre_z_ const char* szFrom, _Pre_z_cap_(cchTo) _Post_z_ char* szTo, size_t cchTo );















// known capacity and valid but unknown readable extent















// e.g. void AppendCharRange( _Pre_count_(cchFrom) const char* rgFrom, size_t cchFrom, _Out_z_cap_(cchTo) char* szTo, size_t cchTo );
// Valid buffer extent described by another parameter





// Valid buffer extent described by a constant expression





// Valid buffer extent described by a complex expression





// Valid buffer extent described by the difference to another pointer parameter




// char * strncpy(_Out_cap_(_Count) _Post_maybez_ char * _Dest, _In_z_ const char * _Source, _In_ size_t _Count)
// buffer maybe zero-terminated after the call


// e.g. SIZE_T HeapSize( _In_ HANDLE hHeap, DWORD dwFlags, _Pre_notnull_ _Post_bytecap_(return) LPCVOID lpMem );



// e.g. int strlen( _In_z_ _Post_count_(return+1) const char* sz );







// e.g. size_t CopyStr( _In_z_ const char* szFrom, _Pre_cap_(cch) _Post_z_count_(return+1) char* szFrom, size_t cchFrom );







//
// _Prepost_ ---
//
// describing conditions that hold before and after the function call



















//
// _Deref_<both> ---
//
// short version for _Deref_pre_<ann> _Deref_post_<ann>
// describing conditions for array elements or dereferenced pointer parameters that hold before and after the call










































//
// _Deref_<miscellaneous>
//
// used with references to arrays







#pragma endregion Input Buffer SAL 1 compatibility macros


//============================================================================
//   Implementation Layer:
//============================================================================


// Naming conventions:
// A symbol the begins with _SA_ is for the machinery of creating any
// annotations; many of those come from sourceannotations.h in the case
// of attributes.

// A symbol that ends with _impl is the very lowest level macro.  It is
// not required to be a legal standalone annotation, and in the case
// of attribute annotations, usually is not.  (In the case of some declspec
// annotations, it might be, but it should not be assumed so.)  Those
// symols will be used in the _PreN..., _PostN... and _RetN... annotations
// to build up more complete annotations.

// A symbol ending in _impl_ is reserved to the implementation as well,
// but it does form a complete annotation; usually they are used to build
// up even higher level annotations.



























































#line 1555 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\shared\\sal.h"






























#line 1586 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\shared\\sal.h"
























#line 1611 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\shared\\sal.h"

// Using "nothing" for sal










#line 1624 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\shared\\sal.h"






































#line 1663 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\shared\\sal.h"















































































































#line 1775 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\shared\\sal.h"






































































































#line 1878 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\shared\\sal.h"








































































































































































#line 2047 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\shared\\sal.h"

































































































// Obsolete -- may be needed for transition to attributes.



#line 2149 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\shared\\sal.h"

// This section contains the deprecated annotations

/*
 -------------------------------------------------------------------------------
 Introduction

 sal.h provides a set of annotations to describe how a function uses its
 parameters - the assumptions it makes about them, and the guarantees it makes
 upon finishing.

 Annotations may be placed before either a function parameter's type or its return
 type, and describe the function's behavior regarding the parameter or return value.
 There are two classes of annotations: buffer annotations and advanced annotations.
 Buffer annotations describe how functions use their pointer parameters, and
 advanced annotations either describe complex/unusual buffer behavior, or provide
 additional information about a parameter that is not otherwise expressible.

 -------------------------------------------------------------------------------
 Buffer Annotations

 The most important annotations in sal.h provide a consistent way to annotate
 buffer parameters or return values for a function. Each of these annotations describes
 a single buffer (which could be a string, a fixed-length or variable-length array,
 or just a pointer) that the function interacts with: where it is, how large it is,
 how much is initialized, and what the function does with it.

 The appropriate macro for a given buffer can be constructed using the table below.
 Just pick the appropriate values from each category, and combine them together
 with a leading underscore. Some combinations of values do not make sense as buffer
 annotations. Only meaningful annotations can be added to your code; for a list of
 these, see the buffer annotation definitions section.

 Only a single buffer annotation should be used for each parameter.

 |------------|------------|---------|--------|----------|----------|---------------|
 |   Level    |   Usage    |  Size   | Output | NullTerm | Optional |  Parameters   |
 |------------|------------|---------|--------|----------|----------|---------------|
 | <>         | <>         | <>      | <>     | _z       | <>       | <>            |
 | _deref     | _in        | _ecount | _full  | _nz      | _opt     | (size)        |
 | _deref_opt | _out       | _bcount | _part  |          |          | (size,length) |
 |            | _inout     |         |        |          |          |               |
 |            |            |         |        |          |          |               |
 |------------|------------|---------|--------|----------|----------|---------------|

 Level: Describes the buffer pointer's level of indirection from the parameter or
          return value 'p'.

 <>         : p is the buffer pointer.
 _deref     : *p is the buffer pointer. p must not be NULL.
 _deref_opt : *p may be the buffer pointer. p may be NULL, in which case the rest of
                the annotation is ignored.

 Usage: Describes how the function uses the buffer.

 <>     : The buffer is not accessed. If used on the return value or with _deref, the
            function will provide the buffer, and it will be uninitialized at exit.
            Otherwise, the caller must provide the buffer. This should only be used
            for alloc and free functions.
 _in    : The function will only read from the buffer. The caller must provide the
            buffer and initialize it. Cannot be used with _deref.
 _out   : The function will only write to the buffer. If used on the return value or
            with _deref, the function will provide the buffer and initialize it.
            Otherwise, the caller must provide the buffer, and the function will
            initialize it.
 _inout : The function may freely read from and write to the buffer. The caller must
            provide the buffer and initialize it. If used with _deref, the buffer may
            be reallocated by the function.

 Size: Describes the total size of the buffer. This may be less than the space actually
         allocated for the buffer, in which case it describes the accessible amount.

 <>      : No buffer size is given. If the type specifies the buffer size (such as
             with LPSTR and LPWSTR), that amount is used. Otherwise, the buffer is one
             element long. Must be used with _in, _out, or _inout.
 _ecount : The buffer size is an explicit element count.
 _bcount : The buffer size is an explicit byte count.

 Output: Describes how much of the buffer will be initialized by the function. For
           _inout buffers, this also describes how much is initialized at entry. Omit this
           category for _in buffers; they must be fully initialized by the caller.

 <>    : The type specifies how much is initialized. For instance, a function initializing
           an LPWSTR must NULL-terminate the string.
 _full : The function initializes the entire buffer.
 _part : The function initializes part of the buffer, and explicitly indicates how much.

 NullTerm: States if the present of a '\0' marks the end of valid elements in the buffer.
 _z    : A '\0' indicated the end of the buffer
 _nz     : The buffer may not be null terminated and a '\0' does not indicate the end of the
          buffer.
 Optional: Describes if the buffer itself is optional.

 <>   : The pointer to the buffer must not be NULL.
 _opt : The pointer to the buffer might be NULL. It will be checked before being dereferenced.

 Parameters: Gives explicit counts for the size and length of the buffer.

 <>            : There is no explicit count. Use when neither _ecount nor _bcount is used.
 (size)        : Only the buffer's total size is given. Use with _ecount or _bcount but not _part.
 (size,length) : The buffer's total size and initialized length are given. Use with _ecount_part
                   and _bcount_part.

 -------------------------------------------------------------------------------
 Buffer Annotation Examples

 LWSTDAPI_(BOOL) StrToIntExA(
     __in LPCSTR pszString,
     DWORD dwFlags,
     __out int *piRet                     -- A pointer whose dereference will be filled in.
 );

 void MyPaintingFunction(
     __in HWND hwndControl,               -- An initialized read-only parameter.
     __in_opt HDC hdcOptional,            -- An initialized read-only parameter that might be NULL.
     __inout IPropertyStore *ppsStore     -- An initialized parameter that may be freely used
                                          --   and modified.
 );

 LWSTDAPI_(BOOL) PathCompactPathExA(
     __out_ecount(cchMax) LPSTR pszOut,   -- A string buffer with cch elements that will
                                          --   be NULL terminated on exit.
     __in LPCSTR pszSrc,
     UINT cchMax,
     DWORD dwFlags
 );

 HRESULT SHLocalAllocBytes(
     size_t cb,
     __deref_bcount(cb) T **ppv           -- A pointer whose dereference will be set to an
                                          --   uninitialized buffer with cb bytes.
 );

 __inout_bcount_full(cb) : A buffer with cb elements that is fully initialized at
     entry and exit, and may be written to by this function.

 __out_ecount_part(count, *countOut) : A buffer with count elements that will be
     partially initialized by this function. The function indicates how much it
     initialized by setting *countOut.

 -------------------------------------------------------------------------------
 Advanced Annotations

 Advanced annotations describe behavior that is not expressible with the regular
 buffer macros. These may be used either to annotate buffer parameters that involve
 complex or conditional behavior, or to enrich existing annotations with additional
 information.

 __success(expr) f :
     <expr> indicates whether function f succeeded or not. If <expr> is true at exit,
     all the function's guarantees (as given by other annotations) must hold. If <expr>
     is false at exit, the caller should not expect any of the function's guarantees
     to hold. If not used, the function must always satisfy its guarantees. Added
     automatically to functions that indicate success in standard ways, such as by
     returning an HRESULT.

 __nullterminated p :
     Pointer p is a buffer that may be read or written up to and including the first
     NULL character or pointer. May be used on typedefs, which marks valid (properly
     initialized) instances of that type as being NULL-terminated.

 __nullnullterminated p :
     Pointer p is a buffer that may be read or written up to and including the first
     sequence of two NULL characters or pointers. May be used on typedefs, which marks
     valid instances of that type as being double-NULL terminated.

 __reserved v :
     Value v must be 0/NULL, reserved for future use.

 __checkReturn v :
     Return value v must not be ignored by callers of this function.

 __typefix(ctype) v :
     Value v should be treated as an instance of ctype, rather than its declared type.

 __override f :
     Specify C#-style 'override' behaviour for overriding virtual methods.

 __callback f :
     Function f can be used as a function pointer.

 __format_string p :
     Pointer p is a string that contains % markers in the style of printf.

 __blocksOn(resource) f :
     Function f blocks on the resource 'resource'.

 __fallthrough :
     Annotates switch statement labels where fall-through is desired, to distinguish
     from forgotten break statements.

 -------------------------------------------------------------------------------
 Advanced Annotation Examples

 __success(return != FALSE) LWSTDAPI_(BOOL)
 PathCanonicalizeA(__out_ecount(MAX_PATH) LPSTR pszBuf, LPCSTR pszPath) :
    pszBuf is only guaranteed to be NULL-terminated when TRUE is returned.

 typedef __nullterminated WCHAR* LPWSTR : Initialized LPWSTRs are NULL-terminated strings.

 __out_ecount(cch) __typefix(LPWSTR) void *psz : psz is a buffer parameter which will be
     a NULL-terminated WCHAR string at exit, and which initially contains cch WCHARs.

 -------------------------------------------------------------------------------
*/






#line 2361 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\shared\\sal.h"
extern "C" {




#line 2367 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\shared\\sal.h"


/*
 -------------------------------------------------------------------------------
 Helper Macro Definitions

 These express behavior common to many of the high-level annotations.
 DO NOT USE THESE IN YOUR CODE.
 -------------------------------------------------------------------------------
*/

/*
    The helper annotations are only understood by the compiler version used by
    various defect detection tools. When the regular compiler is running, they
    are defined into nothing, and do not affect the compiled code.
*/



















































































































































































































#line 2595 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\shared\\sal.h"
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    

    
    
    
    

    
    

#line 2634 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\shared\\sal.h"

/*
-------------------------------------------------------------------------------
Buffer Annotation Definitions

Any of these may be used to directly annotate functions, but only one should
be used for each parameter. To determine which annotation to use for a given
buffer, use the table in the buffer annotations section.
-------------------------------------------------------------------------------
*/
































































































































































































/*
-------------------------------------------------------------------------------
Advanced Annotation Definitions

Any of these may be used to directly annotate functions, and may be used in
combination with each other or with regular buffer macros. For an explanation
of each annotation, see the advanced annotations section.
-------------------------------------------------------------------------------
*/






















#line 2868 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\shared\\sal.h"









#line 2878 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\shared\\sal.h"


    
    
#line 2883 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\shared\\sal.h"






#line 2890 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\shared\\sal.h"
#line 2891 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\shared\\sal.h"






#line 2898 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\shared\\sal.h"
#line 2899 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\shared\\sal.h"











#line 2911 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\shared\\sal.h"

//
// Set the analysis mode (global flags to analysis).
// They take effect at the point of declaration; use at global scope
// as a declaration.
//

// Synthesize a unique symbol.








//
// Floating point warnings are only meaningful in kernel-mode on x86
// so avoid reporting them on other platforms.
//













#line 2945 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\shared\\sal.h"

// The following are predefined:
//  _Analysis_operator_new_throw_   (operator new throws)
//  _Analysis_operator_new_null_        (operator new returns null)
//  _Analysis_operator_new_never_fails_ (operator new never fails)
//

// Function class annotations.














}
#line 2969 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\shared\\sal.h"

#line 1 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\shared\\concurrencysal.h"
/***
*concurrencysal.h - markers for documenting the concurrent semantics of APIs
*
*       Copyright (c) Microsoft Corporation. All rights reserved.
*
*Purpose:
*       This file contains macros for Concurrency SAL annotations. Definitions
*       starting with _Internal are low level macros that are subject to change.
*       Users should not use those low level macros directly.
*       [ANSI]
*
*       [Public]
*
****/




#pragma once


extern "C" {
#line 24 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\shared\\concurrencysal.h"
















































































































































































































































#line 265 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\shared\\concurrencysal.h"



#line 269 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\shared\\concurrencysal.h"













































/*
 * Old spelling: will be deprecated
 */


































#line 352 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\shared\\concurrencysal.h"


}
#line 356 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\shared\\concurrencysal.h"

#line 358 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\shared\\concurrencysal.h"
#line 2971 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\shared\\sal.h"

#line 58 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.28.29333\\include\\vcruntime.h"
#line 1 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.28.29333\\include\\vadefs.h"
//
// vadefs.h
//
//      Copyright (c) Microsoft Corporation. All rights reserved.
//
// Definitions of macro helpers used by <stdarg.h>.  This is the topmost header
// in the CRT header lattice, and is always the first CRT header to be included,
// explicitly or implicitly.  Therefore, this header also has several definitions
// that are used throughout the CRT.
//
#pragma once



#pragma pack(push, 8 )

// C4339: '__type_info_node': use of undefined type detected in CLR meta-data (/Wall)

    


        
    #line 24 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.28.29333\\include\\vadefs.h"
#line 25 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.28.29333\\include\\vadefs.h"

// C4412: function signature contains type '<typename>';
//        C++ objects are unsafe to pass between pure code and mixed or native. (/Wall)

    


        
    #line 34 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.28.29333\\include\\vadefs.h"
#line 35 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.28.29333\\include\\vadefs.h"

// Use _VCRUNTIME_EXTRA_DISABLED_WARNINGS to add additional warning suppressions to VCRuntime headers.

    
#line 40 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.28.29333\\include\\vadefs.h"

// C4514: unreferenced inline function has been removed (/Wall)
// C4820: '<typename>' : 'N' bytes padding added after data member (/Wall)

    
#line 46 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.28.29333\\include\\vadefs.h"

#pragma warning(push)
#pragma warning(disable: 4514 4820 )


extern "C" {
#line 53 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.28.29333\\include\\vadefs.h"



#line 57 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.28.29333\\include\\vadefs.h"


    
    
        typedef unsigned __int64  uintptr_t;
    

#line 65 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.28.29333\\include\\vadefs.h"
#line 66 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.28.29333\\include\\vadefs.h"


    
    


        typedef char* va_list;
    #line 74 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.28.29333\\include\\vadefs.h"
#line 75 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.28.29333\\include\\vadefs.h"


    


#line 81 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.28.29333\\include\\vadefs.h"





#line 87 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.28.29333\\include\\vadefs.h"



#line 91 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.28.29333\\include\\vadefs.h"
    
    
#line 94 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.28.29333\\include\\vadefs.h"











#line 106 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.28.29333\\include\\vadefs.h"







#line 114 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.28.29333\\include\\vadefs.h"











#line 126 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.28.29333\\include\\vadefs.h"





#line 132 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.28.29333\\include\\vadefs.h"










#line 143 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.28.29333\\include\\vadefs.h"










#line 154 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.28.29333\\include\\vadefs.h"

    void __cdecl __va_start(va_list* , ...);

    
    



    

#line 165 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.28.29333\\include\\vadefs.h"


} // extern "C"
#line 169 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.28.29333\\include\\vadefs.h"


    extern "C++"
    {
        template <typename _Ty>
        struct __vcrt_va_list_is_reference
        {
            enum : bool { __the_value = false };
        };

        template <typename _Ty>
        struct __vcrt_va_list_is_reference<_Ty&>
        {
            enum : bool { __the_value = true };
        };

        template <typename _Ty>
        struct __vcrt_va_list_is_reference<_Ty&&>
        {
            enum : bool { __the_value = true };
        };

        template <typename _Ty>
        struct __vcrt_assert_va_start_is_not_reference
        {
            static_assert(!__vcrt_va_list_is_reference<_Ty>::__the_value,
                "va_start argument must not have reference type and must not be parenthesized");
        };
    } // extern "C++"

    





#line 206 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.28.29333\\include\\vadefs.h"

#pragma warning(pop) 
#pragma pack(pop)
#line 59 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.28.29333\\include\\vcruntime.h"

#pragma warning(push)
#pragma warning(disable: 4514 4820 )

// All C headers have a common prologue and epilogue, to enclose the header in
// an extern "C" declaration when the header is #included in a C++ translation
// unit and to push/pop the packing.


    



    





















#line 95 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.28.29333\\include\\vcruntime.h"

__pragma(pack(push, 8)) extern "C" {




    


        
    #line 106 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.28.29333\\include\\vcruntime.h"
#line 107 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.28.29333\\include\\vcruntime.h"
















    

#line 126 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.28.29333\\include\\vcruntime.h"

#line 128 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.28.29333\\include\\vcruntime.h"
        
    #line 130 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.28.29333\\include\\vcruntime.h"
#line 131 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.28.29333\\include\\vcruntime.h"


    

#line 136 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.28.29333\\include\\vcruntime.h"
        
    #line 138 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.28.29333\\include\\vcruntime.h"
#line 139 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.28.29333\\include\\vcruntime.h"

// Definitions of calling conventions used code sometimes compiled as managed



#line 145 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.28.29333\\include\\vcruntime.h"
    
    
#line 148 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.28.29333\\include\\vcruntime.h"




    
#line 154 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.28.29333\\include\\vcruntime.h"



// Definitions of common __declspecs




    


#line 166 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.28.29333\\include\\vcruntime.h"



#line 170 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.28.29333\\include\\vcruntime.h"
    
#line 172 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.28.29333\\include\\vcruntime.h"




    
#line 178 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.28.29333\\include\\vcruntime.h"


    
        
        
    

#line 186 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.28.29333\\include\\vcruntime.h"
#line 187 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.28.29333\\include\\vcruntime.h"

// For backwards compatibility


// Definitions of common types

    typedef unsigned __int64 size_t;
    typedef __int64          ptrdiff_t;
    typedef __int64          intptr_t;




#line 201 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.28.29333\\include\\vcruntime.h"


    typedef bool  __vcrt_bool;






#line 211 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.28.29333\\include\\vcruntime.h"

// Indicate that these common types are defined

    
#line 216 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.28.29333\\include\\vcruntime.h"


    
#line 220 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.28.29333\\include\\vcruntime.h"


    
#line 224 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.28.29333\\include\\vcruntime.h"

// Provide a typedef for wchar_t for use under /Zc:wchar_t-






    
        
    

#line 237 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.28.29333\\include\\vcruntime.h"
#line 238 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.28.29333\\include\\vcruntime.h"


    


#line 244 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.28.29333\\include\\vcruntime.h"


    extern "C++"
    {
        template <typename _CountofType, size_t _SizeOfArray>
        char (*__countof_helper(__unaligned _CountofType (&_Array)[_SizeOfArray]))[_SizeOfArray];

        
    }


#line 256 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.28.29333\\include\\vcruntime.h"



#line 260 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.28.29333\\include\\vcruntime.h"


    
        
    



#line 269 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.28.29333\\include\\vcruntime.h"

    
        
        
    





#line 280 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.28.29333\\include\\vcruntime.h"

    
#line 283 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.28.29333\\include\\vcruntime.h"



#line 287 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.28.29333\\include\\vcruntime.h"

// [[nodiscard]] attributes on STL functions

    


        
    

#line 297 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.28.29333\\include\\vcruntime.h"
#line 298 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.28.29333\\include\\vcruntime.h"


    


#line 304 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.28.29333\\include\\vcruntime.h"

// See note on use of "deprecate" at the top of this file




#line 311 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.28.29333\\include\\vcruntime.h"


    
        
    





#line 322 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.28.29333\\include\\vcruntime.h"
#line 323 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.28.29333\\include\\vcruntime.h"



#line 327 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.28.29333\\include\\vcruntime.h"


    
        
    


#line 335 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.28.29333\\include\\vcruntime.h"
#line 336 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.28.29333\\include\\vcruntime.h"


    void __cdecl __security_init_cookie(void);

    



        void __cdecl __security_check_cookie( uintptr_t _StackCookie);
        __declspec(noreturn) void __cdecl __report_gsfailure( uintptr_t _StackCookie);
    #line 347 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.28.29333\\include\\vcruntime.h"
#line 348 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.28.29333\\include\\vcruntime.h"

extern uintptr_t __security_cookie;


    
    
    
#line 356 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.28.29333\\include\\vcruntime.h"

} __pragma(pack(pop))

#pragma warning(pop) 

#line 362 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.28.29333\\include\\vcruntime.h"
#line 11 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt\\corecrt.h"

__pragma(pack(push, 8)) extern "C" {



//-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
//
// Annotation Macros
//
//-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

    

#line 25 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt\\corecrt.h"
        
    

#line 29 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt\\corecrt.h"
#line 30 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt\\corecrt.h"

// If you need the ability to remove __declspec(import) from an API, to support static replacement,
// declare the API using _ACRTIMP_ALT instead of _ACRTIMP.

    
#line 36 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt\\corecrt.h"


    

#line 41 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt\\corecrt.h"
        
    

#line 45 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt\\corecrt.h"
#line 46 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt\\corecrt.h"



#line 50 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt\\corecrt.h"
    
#line 52 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt\\corecrt.h"


    


#line 58 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt\\corecrt.h"





#line 64 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt\\corecrt.h"
    
#line 66 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt\\corecrt.h"

// __declspec(guard(overflow)) enabled by /sdl compiler switch for CRT allocators

    


#line 73 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt\\corecrt.h"



#line 77 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt\\corecrt.h"
    
#line 79 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt\\corecrt.h"

// The CLR requires code calling other SecurityCritical code or using SecurityCritical types
// to be marked as SecurityCritical.
// _CRT_SECURITYCRITICAL_ATTRIBUTE covers this for internal function definitions.
// _CRT_INLINE_PURE_SECURITYCRITICAL_ATTRIBUTE is for inline pure functions defined in the header.
// This is clr:pure-only because for mixed mode we compile inline functions as native.



    
#line 90 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt\\corecrt.h"













    


        
    #line 108 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt\\corecrt.h"
#line 109 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt\\corecrt.h"



#line 113 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt\\corecrt.h"
    
#line 115 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt\\corecrt.h"



#line 119 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt\\corecrt.h"
    
#line 121 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt\\corecrt.h"



#line 125 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt\\corecrt.h"
    
#line 127 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt\\corecrt.h"



//-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
//
// Miscellaneous Stuff
//
//-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

extern "C++"
{
    template<bool _Enable, typename _Ty>
    struct _CrtEnableIf;

    template<typename _Ty>
    struct _CrtEnableIf<true, _Ty>
    {
        typedef _Ty _Type;
    };
}
#line 148 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt\\corecrt.h"


    typedef bool  __crt_bool;






#line 158 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt\\corecrt.h"










    
#line 170 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt\\corecrt.h"









// CRT headers are included into some kinds of source files where only data type
// definitions and macro definitions are required but function declarations and
// inline function definitions are not.  These files include assembly files, IDL
// files, and resource files.  The tools that process these files often have a
// limited ability to process C and C++ code.  The _CRT_FUNCTIONS_REQUIRED macro
// is defined to 1 when we are compiling a file that actually needs functions to
// be declared (and defined, where applicable), and to 0 when we are compiling a
// file that does not.  This allows us to suppress declarations and definitions
// that are not compilable with the aforementioned tools.

    

#line 192 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt\\corecrt.h"
        
    #line 194 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt\\corecrt.h"
#line 195 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt\\corecrt.h"



#line 199 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt\\corecrt.h"


    
#line 203 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt\\corecrt.h"


 
  
   
  

#line 211 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt\\corecrt.h"
 





#line 218 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt\\corecrt.h"
#line 219 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt\\corecrt.h"

//-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
//
// Windows API Partitioning and ARM Desktop Support
//
//-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

    











        
    #line 240 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt\\corecrt.h"
#line 241 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt\\corecrt.h"


    
#line 245 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt\\corecrt.h"


    
        
    

#line 252 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt\\corecrt.h"
#line 253 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt\\corecrt.h"

// Verify that the ARM Desktop SDK is available when building an ARM Desktop app








//-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
//
// Invalid Parameter Handler
//
//-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+










__declspec(dllimport) void __cdecl _invalid_parameter_noinfo(void);
__declspec(dllimport) __declspec(noreturn) void __cdecl _invalid_parameter_noinfo_noreturn(void);

__declspec(noreturn)
__declspec(dllimport) void __cdecl _invoke_watson(
     wchar_t const* _Expression,
     wchar_t const* _FunctionName,
     wchar_t const* _FileName,
           unsigned int _LineNo,
           uintptr_t _Reserved);


    



        // By default, _CRT_SECURE_INVALID_PARAMETER in retail invokes
        // _invalid_parameter_noinfo_noreturn(), which is marked
        // __declspec(noreturn) and does not return control to the application.
        // Even if _set_invalid_parameter_handler() is used to set a new invalid
        // parameter handler which does return control to the application,
        // _invalid_parameter_noinfo_noreturn() will terminate the application
        // and invoke Watson. You can overwrite the definition of
        // _CRT_SECURE_INVALID_PARAMETER if you need.
        //
        // _CRT_SECURE_INVALID_PARAMETER is used in the Standard C++ Libraries
        // and the SafeInt library.
        

    #line 308 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt\\corecrt.h"
#line 309 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt\\corecrt.h"



//-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
//
// Deprecation and Warnings
//
//-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+




    


#line 326 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt\\corecrt.h"



#line 330 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt\\corecrt.h"


    


        


    #line 339 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt\\corecrt.h"
#line 340 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt\\corecrt.h"



//-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
//
// Managed CRT Support
//
//-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

    






        
    #line 358 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt\\corecrt.h"
#line 359 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt\\corecrt.h"


    


        
    #line 366 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt\\corecrt.h"
#line 367 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt\\corecrt.h"



#line 371 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt\\corecrt.h"



//-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
//
// SecureCRT Configuration
//
//-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+





#line 385 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt\\corecrt.h"















#line 401 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt\\corecrt.h"





    
#line 408 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt\\corecrt.h"



#line 412 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt\\corecrt.h"


    

#line 417 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt\\corecrt.h"
#line 418 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt\\corecrt.h"


    


        


            
        #line 428 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt\\corecrt.h"
    #line 429 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt\\corecrt.h"
#line 430 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt\\corecrt.h"



#line 434 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt\\corecrt.h"





#line 440 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt\\corecrt.h"


    


        



    #line 450 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt\\corecrt.h"
#line 451 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt\\corecrt.h"


    
        
    



#line 460 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt\\corecrt.h"

    
        // _CRT_SECURE_CPP_OVERLOAD_STANDARD_NAMES_COUNT is ignored if
        // _CRT_SECURE_CPP_OVERLOAD_STANDARD_NAMES is set to 0
        
    



#line 470 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt\\corecrt.h"

    
        
              
        

#line 477 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt\\corecrt.h"
    



#line 482 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt\\corecrt.h"

    
        
    



#line 490 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt\\corecrt.h"

    
        
    



#line 498 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt\\corecrt.h"
#line 499 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt\\corecrt.h"


    
#line 503 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt\\corecrt.h"



//-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
//
// Basic Types
//
//-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
typedef int                           errno_t;
typedef unsigned short                wint_t;
typedef unsigned short                wctype_t;
typedef long                          __time32_t;
typedef __int64                       __time64_t;

typedef struct __crt_locale_data_public
{
      unsigned short const* _locale_pctype;
     int _locale_mb_cur_max;
               unsigned int _locale_lc_codepage;
} __crt_locale_data_public;

typedef struct __crt_locale_pointers
{
    struct __crt_locale_data*    locinfo;
    struct __crt_multibyte_data* mbcinfo;
} __crt_locale_pointers;

typedef __crt_locale_pointers* _locale_t;

typedef struct _Mbstatet
{ // state of a multibyte translation
    unsigned long _Wchar;
    unsigned short _Byte, _State;
} _Mbstatet;

typedef _Mbstatet mbstate_t;



#line 543 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt\\corecrt.h"



#line 547 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt\\corecrt.h"


    


        typedef __time64_t time_t;
    #line 554 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt\\corecrt.h"
#line 555 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt\\corecrt.h"

// Indicate that these common types are defined

    
#line 560 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt\\corecrt.h"


    typedef size_t rsize_t;
#line 564 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt\\corecrt.h"




//-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
//
// C++ Secure Overload Generation Macros
//
//-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

    

        










        










        










        










        










        










        










        










        










        















        















        
















    














#line 740 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt\\corecrt.h"
#line 741 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt\\corecrt.h"






































































//-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
//
// C++ Standard Overload Generation Macros
//
//-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

    





































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































#line 1816 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt\\corecrt.h"

        
        
        
        

        

            


            


            


            


            


            


            


            


            



            



            


            


            


            


            


            


            


            


            


            


            



            



            



            


            



            




            

            




            

            




            

            




            

            




            

            




            

            




            

            




            

        











































#line 2006 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt\\corecrt.h"
    #line 2007 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt\\corecrt.h"
#line 2008 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt\\corecrt.h"



} __pragma(pack(pop))
#line 13 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt\\stdio.h"
#line 1 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt\\corecrt_wstdio.h"
//
// corecrt_wstdio.h
//
//      Copyright (c) Microsoft Corporation. All rights reserved.
//
// This file declares the wide character (wchar_t) I/O functionality, shared by
// <stdio.h> and <wchar.h>.  It also defines several core I/O types, which are
// also shared by those two headers.
//
#pragma once


#line 1 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt\\corecrt_stdio_config.h"
//
// corecrt_stdio_config.h
//
//      Copyright (c) Microsoft Corporation. All rights reserved.
//
// Per-module <stdio.h> configuration.
//
#pragma once



__pragma(pack(push, 8)) extern "C" {



#line 17 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt\\corecrt_stdio_config.h"




#line 22 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt\\corecrt_stdio_config.h"
    
#line 24 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt\\corecrt_stdio_config.h"


    

#line 29 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt\\corecrt_stdio_config.h"
        
    

#line 33 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt\\corecrt_stdio_config.h"
#line 34 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt\\corecrt_stdio_config.h"



// Predefine _CRT_STDIO_ISO_WIDE_SPECIFIERS to use ISO-conforming behavior for
// the wide string printf and scanf functions (%s, %c, and %[] specifiers).
//
// Predefine _CRT_STDIO_LEGACY_WIDE_SPECIFIERS to use VC++ 2013 and earlier behavior for
// the wide string printf and scanf functions (%s, %c, and %[] specifiers).
//
// Predefine _CRT_STDIO_ARBITRARY_WIDE_SPECIFIERS when building code that does
// not use these format specifiers without a length modifier and thus can be
// used with either the legacy (default) or the conforming mode.  (This option
// is intended for use by static libraries).

    








#line 58 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt\\corecrt_stdio_config.h"




#line 63 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt\\corecrt_stdio_config.h"

    
        


            #pragma detect_mismatch("_CRT_STDIO_ISO_WIDE_SPECIFIERS", "0")
        #line 70 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt\\corecrt_stdio_config.h"
    #line 71 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt\\corecrt_stdio_config.h"
#line 72 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt\\corecrt_stdio_config.h"

// If we're compiling mixed managed code, make sure these inline functions are
// compiled as native to ensure that there is only one instance of each of the
// function-local static variables.


#line 79 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt\\corecrt_stdio_config.h"


    // This function must not be inlined into callers to avoid ODR violations.  The
    // static local variable has different names in C and in C++ translation units.
     
    
    __declspec(noinline) __inline unsigned __int64* __cdecl __local_stdio_printf_options(void)
    {
        static unsigned __int64 _OptionsStorage;
        return &_OptionsStorage;
    }

    // This function must not be inlined into callers to avoid ODR violations.  The
    // static local variable has different names in C and in C++ translation units.
     
    
    __declspec(noinline) __inline unsigned __int64* __cdecl __local_stdio_scanf_options(void)
    {
        static unsigned __int64 _OptionsStorage;
        return &_OptionsStorage;
    }
#line 101 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt\\corecrt_stdio_config.h"



#line 105 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt\\corecrt_stdio_config.h"



















} __pragma(pack(pop))
#line 14 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt\\corecrt_wstdio.h"

__pragma(pack(push, 8)) extern "C" {


//-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
//
// Stream I/O Declarations Required by this Header
//
//-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

    
    typedef struct _iobuf
    {
        void* _Placeholder;
    } FILE;
#line 30 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt\\corecrt_wstdio.h"

__declspec(dllimport) FILE* __cdecl __acrt_iob_func(unsigned _Ix);










    //-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    //
    // Wide Character Stream I/O Functions
    //
    //-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    
    __declspec(dllimport) wint_t __cdecl fgetwc(
         FILE* _Stream
        );

    
    __declspec(dllimport) wint_t __cdecl _fgetwchar(void);

    
    __declspec(dllimport) wint_t __cdecl fputwc(
            wchar_t _Character,
         FILE*   _Stream);

    
    __declspec(dllimport) wint_t __cdecl _fputwchar(
         wchar_t _Character
        );

    
    __declspec(dllimport) wint_t __cdecl getwc(
         FILE* _Stream
        );

    
    __declspec(dllimport) wint_t __cdecl getwchar(void);


    
    
    __declspec(dllimport) wchar_t* __cdecl fgetws(
         wchar_t* _Buffer,
                                 int      _BufferCount,
                              FILE*    _Stream
        );

    
    __declspec(dllimport) int __cdecl fputws(
          wchar_t const* _Buffer,
         FILE*          _Stream
        );

    
    
    __declspec(dllimport) wchar_t* __cdecl _getws_s(
         wchar_t* _Buffer,
                                 size_t   _BufferCount
        );

    extern "C++" { template <size_t _Size> inline wchar_t* __cdecl _getws_s(wchar_t (&_Buffer)[_Size]) throw() { return _getws_s(_Buffer, _Size); } }





    
    __declspec(dllimport) wint_t __cdecl putwc(
            wchar_t _Character,
         FILE*   _Stream
        );

    
    __declspec(dllimport) wint_t __cdecl putwchar(
         wchar_t _Character
        );

    
    __declspec(dllimport) int __cdecl _putws(
         wchar_t const* _Buffer
        );

    
    __declspec(dllimport) wint_t __cdecl ungetwc(
            wint_t _Character,
         FILE*  _Stream
        );

    
    __declspec(dllimport) FILE * __cdecl _wfdopen(
           int            _FileHandle,
         wchar_t const* _Mode
        );

     
    __declspec(dllimport) FILE* __cdecl _wfopen(
         wchar_t const* _FileName,
         wchar_t const* _Mode
        );

    
    __declspec(dllimport) errno_t __cdecl _wfopen_s(
         FILE**         _Stream,
                            wchar_t const* _FileName,
                            wchar_t const* _Mode
        );

    
    
    __declspec(dllimport) FILE* __cdecl _wfreopen(
          wchar_t const* _FileName,
          wchar_t const* _Mode,
         FILE*          _OldStream
        );

    
    __declspec(dllimport) errno_t __cdecl _wfreopen_s(
         FILE**         _Stream,
                            wchar_t const* _FileName,
                            wchar_t const* _Mode,
                           FILE*          _OldStream
        );

    
    __declspec(dllimport) FILE* __cdecl _wfsopen(
         wchar_t const* _FileName,
         wchar_t const* _Mode,
           int            _ShFlag
        );

    __declspec(dllimport) void __cdecl _wperror(
         wchar_t const* _ErrorMessage
        );

    

        
        __declspec(dllimport) FILE* __cdecl _wpopen(
             wchar_t const* _Command,
             wchar_t const* _Mode
            );

    #line 178 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt\\corecrt_wstdio.h"

    __declspec(dllimport) int __cdecl _wremove(
         wchar_t const* _FileName
        );

    
    

    
    __declspec(dllimport) __declspec(allocator) wchar_t* __cdecl _wtempnam(
         wchar_t const* _Directory,
         wchar_t const* _FilePrefix
        );

    

    
    
    __declspec(dllimport) errno_t __cdecl _wtmpnam_s(
         wchar_t* _Buffer,
                                 size_t   _BufferCount
        );

    extern "C++" { template <size_t _Size> inline errno_t __cdecl _wtmpnam_s(wchar_t (&_Buffer)[_Size]) throw() { return _wtmpnam_s(_Buffer, _Size); } }





    __declspec(dllimport) wchar_t* __cdecl _wtmpnam( wchar_t *_Buffer);







    //-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    //
    // I/O Synchronization and _nolock family of I/O functions
    //
    //-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    
    __declspec(dllimport) wint_t __cdecl _fgetwc_nolock(
         FILE* _Stream
        );

    
    __declspec(dllimport) wint_t __cdecl _fputwc_nolock(
            wchar_t _Character,
         FILE*   _Stream
        );

    
    __declspec(dllimport) wint_t __cdecl _getwc_nolock(
         FILE* _Stream
        );

    
    __declspec(dllimport) wint_t __cdecl _putwc_nolock(
            wchar_t _Character,
         FILE*   _Stream
        );

    
    __declspec(dllimport) wint_t __cdecl _ungetwc_nolock(
            wint_t _Character,
         FILE*  _Stream
        );

    



#line 253 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt\\corecrt_wstdio.h"



    // Variadic functions are not supported in managed code under /clr
    





    //-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    //
    // Wide Character Formatted Output Functions (Stream)
    //
    //-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    
    __declspec(dllimport) int __cdecl __stdio_common_vfwprintf(
                                            unsigned __int64 _Options,
                                         FILE*            _Stream,
          wchar_t const*   _Format,
                                        _locale_t        _Locale,
                                                va_list          _ArgList
        );

    
    __declspec(dllimport) int __cdecl __stdio_common_vfwprintf_s(
                                            unsigned __int64 _Options,
                                         FILE*            _Stream,
          wchar_t const*   _Format,
                                        _locale_t        _Locale,
                                                va_list          _ArgList
        );

    
    __declspec(dllimport) int __cdecl __stdio_common_vfwprintf_p(
                                            unsigned __int64 _Options,
                                         FILE*            _Stream,
          wchar_t const*   _Format,
                                        _locale_t        _Locale,
                                                va_list          _ArgList
        );

    
    __inline int __cdecl _vfwprintf_l(
                                         FILE*          const _Stream,
          wchar_t const* const _Format,
                                        _locale_t      const _Locale,
                                                va_list              _ArgList
        )
    

#line 305 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt\\corecrt_wstdio.h"
    {
        return __stdio_common_vfwprintf((*__local_stdio_printf_options()) , _Stream, _Format, _Locale, _ArgList);
    }
    #line 309 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt\\corecrt_wstdio.h"

    
    __inline int __cdecl vfwprintf(
                               FILE*          const _Stream,
          wchar_t const* const _Format,
                                      va_list              _ArgList
        )
    

#line 319 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt\\corecrt_wstdio.h"
    {
        return _vfwprintf_l(_Stream, _Format, 0 , _ArgList);
    }
    #line 323 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt\\corecrt_wstdio.h"

    
    __inline int __cdecl _vfwprintf_s_l(
                                         FILE*          const _Stream,
          wchar_t const* const _Format,
                                        _locale_t      const _Locale,
                                                va_list              _ArgList
        )
    

#line 334 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt\\corecrt_wstdio.h"
    {
        return __stdio_common_vfwprintf_s((*__local_stdio_printf_options()) , _Stream, _Format, _Locale, _ArgList);
    }
    #line 338 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt\\corecrt_wstdio.h"

    

        
        __inline int __cdecl vfwprintf_s(
                                   FILE*          const _Stream,
              wchar_t const* const _Format,
                                          va_list              _ArgList
            )
    

#line 350 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt\\corecrt_wstdio.h"
        {
            return _vfwprintf_s_l(_Stream, _Format, 0 , _ArgList);
        }
    #line 354 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt\\corecrt_wstdio.h"

    #line 356 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt\\corecrt_wstdio.h"

    
    __inline int __cdecl _vfwprintf_p_l(
                                         FILE*          const _Stream,
          wchar_t const* const _Format,
                                        _locale_t      const _Locale,
                                                va_list              _ArgList
        )
    

#line 367 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt\\corecrt_wstdio.h"
    {
        return __stdio_common_vfwprintf_p((*__local_stdio_printf_options()) , _Stream, _Format, _Locale, _ArgList);
    }
    #line 371 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt\\corecrt_wstdio.h"

    
    __inline int __cdecl _vfwprintf_p(
                               FILE*          const _Stream,
          wchar_t const* const _Format,
                                      va_list              _ArgList
        )
    

#line 381 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt\\corecrt_wstdio.h"
    {
        return _vfwprintf_p_l(_Stream, _Format, 0 , _ArgList);
    }
    #line 385 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt\\corecrt_wstdio.h"

    
    __inline int __cdecl _vwprintf_l(
          wchar_t const* const _Format,
                                        _locale_t      const _Locale,
                                                va_list              _ArgList
        )
    

#line 395 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt\\corecrt_wstdio.h"
    {
        return _vfwprintf_l((__acrt_iob_func(1)) , _Format, _Locale, _ArgList);
    }
    #line 399 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt\\corecrt_wstdio.h"

    
    __inline int __cdecl vwprintf(
          wchar_t const* const _Format,
                                      va_list              _ArgList
        )
    

#line 408 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt\\corecrt_wstdio.h"
    {
        return _vfwprintf_l((__acrt_iob_func(1)) , _Format, 0 , _ArgList);
    }
    #line 412 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt\\corecrt_wstdio.h"

    
    __inline int __cdecl _vwprintf_s_l(
          wchar_t const* const _Format,
                                        _locale_t      const _Locale,
                                                va_list              _ArgList
        )
    

#line 422 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt\\corecrt_wstdio.h"
    {
        return _vfwprintf_s_l((__acrt_iob_func(1)) , _Format, _Locale, _ArgList);
    }
    #line 426 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt\\corecrt_wstdio.h"

    

        
        __inline int __cdecl vwprintf_s(
              wchar_t const* const _Format,
                                          va_list              _ArgList
            )
    

#line 437 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt\\corecrt_wstdio.h"
        {
            return _vfwprintf_s_l((__acrt_iob_func(1)) , _Format, 0 , _ArgList);
        }
    #line 441 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt\\corecrt_wstdio.h"

    #line 443 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt\\corecrt_wstdio.h"

    
    __inline int __cdecl _vwprintf_p_l(
          wchar_t const* const _Format,
                                        _locale_t      const _Locale,
                                                va_list              _ArgList
        )
    

#line 453 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt\\corecrt_wstdio.h"
    {
        return _vfwprintf_p_l((__acrt_iob_func(1)) , _Format, _Locale, _ArgList);
    }
    #line 457 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt\\corecrt_wstdio.h"

    
    __inline int __cdecl _vwprintf_p(
          wchar_t const* const _Format,
                                      va_list              _ArgList
        )
    

#line 466 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt\\corecrt_wstdio.h"
    {
        return _vfwprintf_p_l((__acrt_iob_func(1)) , _Format, 0 , _ArgList);
    }
    #line 470 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt\\corecrt_wstdio.h"

    
    __inline int __cdecl _fwprintf_l(
                                         FILE*          const _Stream,
          wchar_t const* const _Format,
                                        _locale_t      const _Locale,
        ...)
    

#line 480 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt\\corecrt_wstdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Locale)>(), ((void)(__va_start(&_ArgList, _Locale))))) ;
        _Result = _vfwprintf_l(_Stream, _Format, _Locale, _ArgList);
        ((void)(_ArgList = (va_list)0)) ;
        return _Result;
    }
    #line 489 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt\\corecrt_wstdio.h"

    
    __inline int __cdecl fwprintf(
                               FILE*          const _Stream,
          wchar_t const* const _Format,
        ...)
    

#line 498 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt\\corecrt_wstdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Format)>(), ((void)(__va_start(&_ArgList, _Format))))) ;
        _Result = _vfwprintf_l(_Stream, _Format, 0 , _ArgList);
        ((void)(_ArgList = (va_list)0)) ;
        return _Result;
    }
    #line 507 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt\\corecrt_wstdio.h"

    
    __inline int __cdecl _fwprintf_s_l(
                                         FILE*          const _Stream,
          wchar_t const* const _Format,
                                        _locale_t      const _Locale,
        ...)
    

#line 517 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt\\corecrt_wstdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Locale)>(), ((void)(__va_start(&_ArgList, _Locale))))) ;
        _Result = _vfwprintf_s_l(_Stream, _Format, _Locale, _ArgList);
        ((void)(_ArgList = (va_list)0)) ;
        return _Result;
    }
    #line 526 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt\\corecrt_wstdio.h"

    

        
        __inline int __cdecl fwprintf_s(
                                   FILE*          const _Stream,
              wchar_t const* const _Format,
            ...)
    

#line 537 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt\\corecrt_wstdio.h"
        {
            int _Result;
            va_list _ArgList;
            ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Format)>(), ((void)(__va_start(&_ArgList, _Format))))) ;
            _Result = _vfwprintf_s_l(_Stream, _Format, 0 , _ArgList);
            ((void)(_ArgList = (va_list)0)) ;
            return _Result;
        }
    #line 546 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt\\corecrt_wstdio.h"

    #line 548 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt\\corecrt_wstdio.h"

    
    __inline int __cdecl _fwprintf_p_l(
                                         FILE*          const _Stream,
          wchar_t const* const _Format,
                                        _locale_t      const _Locale,
        ...)
    

#line 558 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt\\corecrt_wstdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Locale)>(), ((void)(__va_start(&_ArgList, _Locale))))) ;
        _Result = _vfwprintf_p_l(_Stream, _Format, _Locale, _ArgList);
        ((void)(_ArgList = (va_list)0)) ;
        return _Result;
    }
    #line 567 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt\\corecrt_wstdio.h"

    
    __inline int __cdecl _fwprintf_p(
                               FILE*          const _Stream,
          wchar_t const* const _Format,
        ...)
    

#line 576 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt\\corecrt_wstdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Format)>(), ((void)(__va_start(&_ArgList, _Format))))) ;
        _Result = _vfwprintf_p_l(_Stream, _Format, 0 , _ArgList);
        ((void)(_ArgList = (va_list)0)) ;
        return _Result;
    }
    #line 585 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt\\corecrt_wstdio.h"

    
    __inline int __cdecl _wprintf_l(
          wchar_t const* const _Format,
                                        _locale_t      const _Locale,
        ...)
    

#line 594 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt\\corecrt_wstdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Locale)>(), ((void)(__va_start(&_ArgList, _Locale))))) ;
        _Result = _vfwprintf_l((__acrt_iob_func(1)) , _Format, _Locale, _ArgList);
        ((void)(_ArgList = (va_list)0)) ;
        return _Result;
    }
    #line 603 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt\\corecrt_wstdio.h"

    
    __inline int __cdecl wprintf(
          wchar_t const* const _Format,
        ...)
    

#line 611 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt\\corecrt_wstdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Format)>(), ((void)(__va_start(&_ArgList, _Format))))) ;
        _Result = _vfwprintf_l((__acrt_iob_func(1)) , _Format, 0 , _ArgList);
        ((void)(_ArgList = (va_list)0)) ;
        return _Result;
    }
    #line 620 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt\\corecrt_wstdio.h"

    
    __inline int __cdecl _wprintf_s_l(
          wchar_t const* const _Format,
                                        _locale_t      const _Locale,
        ...)
    

#line 629 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt\\corecrt_wstdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Locale)>(), ((void)(__va_start(&_ArgList, _Locale))))) ;
        _Result = _vfwprintf_s_l((__acrt_iob_func(1)) , _Format, _Locale, _ArgList);
        ((void)(_ArgList = (va_list)0)) ;
        return _Result;
    }
    #line 638 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt\\corecrt_wstdio.h"

    

        
        __inline int __cdecl wprintf_s(
              wchar_t const* const _Format,
            ...)
    

#line 648 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt\\corecrt_wstdio.h"
        {
            int _Result;
            va_list _ArgList;
            ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Format)>(), ((void)(__va_start(&_ArgList, _Format))))) ;
            _Result = _vfwprintf_s_l((__acrt_iob_func(1)) , _Format, 0 , _ArgList);
            ((void)(_ArgList = (va_list)0)) ;
            return _Result;
        }
    #line 657 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt\\corecrt_wstdio.h"

    #line 659 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt\\corecrt_wstdio.h"

    
    __inline int __cdecl _wprintf_p_l(
          wchar_t const* const _Format,
                                        _locale_t      const _Locale,
        ...)
    

#line 668 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt\\corecrt_wstdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Locale)>(), ((void)(__va_start(&_ArgList, _Locale))))) ;
        _Result = _vfwprintf_p_l((__acrt_iob_func(1)) , _Format, _Locale, _ArgList);
        ((void)(_ArgList = (va_list)0)) ;
        return _Result;
    }
    #line 677 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt\\corecrt_wstdio.h"

    
    __inline int __cdecl _wprintf_p(
          wchar_t const* const _Format,
        ...)
    

#line 685 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt\\corecrt_wstdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Format)>(), ((void)(__va_start(&_ArgList, _Format))))) ;
        _Result = _vfwprintf_p_l((__acrt_iob_func(1)) , _Format, 0 , _ArgList);
        ((void)(_ArgList = (va_list)0)) ;
        return _Result;
    }
    #line 694 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt\\corecrt_wstdio.h"


    //-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    //
    // Wide Character Formatted Input Functions (Stream)
    //
    //-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    
    __declspec(dllimport) int __cdecl __stdio_common_vfwscanf(
                                           unsigned __int64 _Options,
                                        FILE*            _Stream,
          wchar_t const*   _Format,
                                       _locale_t        _Locale,
                                               va_list          _ArgList
        );

    
    __inline int __cdecl _vfwscanf_l(
         FILE*                                const _Stream,
          wchar_t const* const _Format,
                              _locale_t      const _Locale,
                                      va_list              _ArgList
        )
    

#line 720 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt\\corecrt_wstdio.h"
    {
        return __stdio_common_vfwscanf(
            (*__local_stdio_scanf_options ()) ,
            _Stream, _Format, _Locale, _ArgList);
    }
    #line 726 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt\\corecrt_wstdio.h"

    
    __inline int __cdecl vfwscanf(
         FILE*                                const _Stream,
          wchar_t const* const _Format,
                                      va_list              _ArgList
        )
    

#line 736 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt\\corecrt_wstdio.h"
    {
        return _vfwscanf_l(_Stream, _Format, 0 , _ArgList);
    }
    #line 740 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt\\corecrt_wstdio.h"

    
    __inline int __cdecl _vfwscanf_s_l(
                               FILE*          const _Stream,
          wchar_t const* const _Format,
                              _locale_t      const _Locale,
                                      va_list              _ArgList
        )
    

#line 751 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt\\corecrt_wstdio.h"
    {
        return __stdio_common_vfwscanf(
            (*__local_stdio_scanf_options ()) | (1ULL << 0) ,
            _Stream, _Format, _Locale, _ArgList);
    }
    #line 757 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt\\corecrt_wstdio.h"

    

        
        __inline int __cdecl vfwscanf_s(
                                   FILE*          const _Stream,
              wchar_t const* const _Format,
                                          va_list              _ArgList
            )
    

#line 769 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt\\corecrt_wstdio.h"
        {
            return _vfwscanf_s_l(_Stream, _Format, 0 , _ArgList);
        }
    #line 773 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt\\corecrt_wstdio.h"

    #line 775 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt\\corecrt_wstdio.h"

    __inline int __cdecl _vwscanf_l(
          wchar_t const* const _Format,
                              _locale_t      const _Locale,
                                      va_list              _ArgList
        )
    

#line 784 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt\\corecrt_wstdio.h"
    {
        return _vfwscanf_l((__acrt_iob_func(0)) , _Format, _Locale, _ArgList);
    }
    #line 788 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt\\corecrt_wstdio.h"

    
    __inline int __cdecl vwscanf(
          wchar_t const* const _Format,
                                      va_list              _ArgList
        )
    

#line 797 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt\\corecrt_wstdio.h"
    {
        return _vfwscanf_l((__acrt_iob_func(0)) , _Format, 0 , _ArgList);
    }
    #line 801 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt\\corecrt_wstdio.h"

    
    __inline int __cdecl _vwscanf_s_l(
          wchar_t const* const _Format,
                              _locale_t      const _Locale,
                                      va_list              _ArgList
        )
    

#line 811 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt\\corecrt_wstdio.h"
    {
        return _vfwscanf_s_l((__acrt_iob_func(0)) , _Format, _Locale, _ArgList);
    }
    #line 815 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt\\corecrt_wstdio.h"

    

        
        __inline int __cdecl vwscanf_s(
              wchar_t const* const _Format,
                                          va_list              _ArgList
            )
    

#line 826 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt\\corecrt_wstdio.h"
        {
            return _vfwscanf_s_l((__acrt_iob_func(0)) , _Format, 0 , _ArgList);
        }
    #line 830 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt\\corecrt_wstdio.h"

    #line 832 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt\\corecrt_wstdio.h"

     
    __inline int __cdecl _fwscanf_l(
                                        FILE*          const _Stream,
          wchar_t const* const _Format,
                                       _locale_t      const _Locale,
        ...)
    

#line 842 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt\\corecrt_wstdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Locale)>(), ((void)(__va_start(&_ArgList, _Locale))))) ;
        _Result = _vfwscanf_l(_Stream, _Format, _Locale, _ArgList);
        ((void)(_ArgList = (va_list)0)) ;
        return _Result;
    }
    #line 851 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt\\corecrt_wstdio.h"

     
    __inline int __cdecl fwscanf(
                              FILE*          const _Stream,
          wchar_t const* const _Format,
        ...)
    

#line 860 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt\\corecrt_wstdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Format)>(), ((void)(__va_start(&_ArgList, _Format))))) ;
        _Result = _vfwscanf_l(_Stream, _Format, 0 , _ArgList);
        ((void)(_ArgList = (va_list)0)) ;
        return _Result;
    }
    #line 869 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt\\corecrt_wstdio.h"

    
    __inline int __cdecl _fwscanf_s_l(
                                          FILE*          const _Stream,
          wchar_t const* const _Format,
                                         _locale_t      const _Locale,
        ...)
    

#line 879 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt\\corecrt_wstdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Locale)>(), ((void)(__va_start(&_ArgList, _Locale))))) ;
        _Result = _vfwscanf_s_l(_Stream, _Format, _Locale, _ArgList);
        ((void)(_ArgList = (va_list)0)) ;
        return _Result;
    }
    #line 888 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt\\corecrt_wstdio.h"

    

        
        __inline int __cdecl fwscanf_s(
                                    FILE*          const _Stream,
              wchar_t const* const _Format,
            ...)
    

#line 899 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt\\corecrt_wstdio.h"
        {
            int _Result;
            va_list _ArgList;
            ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Format)>(), ((void)(__va_start(&_ArgList, _Format))))) ;
            _Result = _vfwscanf_s_l(_Stream, _Format, 0 , _ArgList);
            ((void)(_ArgList = (va_list)0)) ;
            return _Result;
        }
    #line 908 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt\\corecrt_wstdio.h"

    #line 910 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt\\corecrt_wstdio.h"

     
    __inline int __cdecl _wscanf_l(
          wchar_t const* const _Format,
                                       _locale_t      const _Locale,
        ...)
    

#line 919 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt\\corecrt_wstdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Locale)>(), ((void)(__va_start(&_ArgList, _Locale))))) ;
        _Result = _vfwscanf_l((__acrt_iob_func(0)) , _Format, _Locale, _ArgList);
        ((void)(_ArgList = (va_list)0)) ;
        return _Result;
    }
    #line 928 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt\\corecrt_wstdio.h"

     
    __inline int __cdecl wscanf(
          wchar_t const* const _Format,
        ...)
    

#line 936 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt\\corecrt_wstdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Format)>(), ((void)(__va_start(&_ArgList, _Format))))) ;
        _Result = _vfwscanf_l((__acrt_iob_func(0)) , _Format, 0 , _ArgList);
        ((void)(_ArgList = (va_list)0)) ;
        return _Result;
    }
    #line 945 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt\\corecrt_wstdio.h"

    
    __inline int __cdecl _wscanf_s_l(
          wchar_t const* const _Format,
                                         _locale_t      const _Locale,
        ...)
    

#line 954 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt\\corecrt_wstdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Locale)>(), ((void)(__va_start(&_ArgList, _Locale))))) ;
        _Result = _vfwscanf_s_l((__acrt_iob_func(0)) , _Format, _Locale, _ArgList);
        ((void)(_ArgList = (va_list)0)) ;
        return _Result;
    }
    #line 963 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt\\corecrt_wstdio.h"

    

        
        __inline int __cdecl wscanf_s(
              wchar_t const* const _Format,
            ...)
    

#line 973 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt\\corecrt_wstdio.h"
        {
            int _Result;
            va_list _ArgList;
            ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Format)>(), ((void)(__va_start(&_ArgList, _Format))))) ;
            _Result = _vfwscanf_s_l((__acrt_iob_func(0)) , _Format, 0 , _ArgList);
            ((void)(_ArgList = (va_list)0)) ;
            return _Result;
        }
    #line 982 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt\\corecrt_wstdio.h"

    #line 984 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt\\corecrt_wstdio.h"



    //-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    //
    // Wide Character Formatted Output Functions (String)
    //
    //-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    
        



    

#line 1000 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt\\corecrt_wstdio.h"

    
    
    __declspec(dllimport) int __cdecl __stdio_common_vswprintf(
                                            unsigned __int64 _Options,
                wchar_t*         _Buffer,
                                            size_t           _BufferCount,
          wchar_t const*   _Format,
                                        _locale_t        _Locale,
                                                va_list          _ArgList
        );

    
    
    __declspec(dllimport) int __cdecl __stdio_common_vswprintf_s(
                                            unsigned __int64 _Options,
                    wchar_t*         _Buffer,
                                            size_t           _BufferCount,
          wchar_t const*   _Format,
                                        _locale_t        _Locale,
                                                va_list          _ArgList
        );

    
    
    __declspec(dllimport) int __cdecl __stdio_common_vsnwprintf_s(
                                            unsigned __int64 _Options,
                wchar_t*         _Buffer,
                                            size_t           _BufferCount,
                                            size_t           _MaxCount,
          wchar_t const*   _Format,
                                        _locale_t        _Locale,
                                                va_list          _ArgList
        );

    
    
    __declspec(dllimport) int __cdecl __stdio_common_vswprintf_p(
                                            unsigned __int64 _Options,
                    wchar_t*         _Buffer,
                                            size_t           _BufferCount,
          wchar_t const*   _Format,
                                        _locale_t        _Locale,
                                                va_list          _ArgList
        );

    
     
    __inline int __cdecl _vsnwprintf_l(
          wchar_t*       const _Buffer,
                                                 size_t         const _BufferCount,
               wchar_t const* const _Format,
                                             _locale_t      const _Locale,
                                                     va_list              _ArgList
        )
    

#line 1058 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt\\corecrt_wstdio.h"
    {
        int const _Result = __stdio_common_vswprintf(
            (*__local_stdio_printf_options()) | (1ULL << 0) ,
            _Buffer, _BufferCount, _Format, _Locale, _ArgList);

        return _Result < 0 ? -1 : _Result;
    }
    #line 1066 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt\\corecrt_wstdio.h"

    #pragma warning(push)
    #pragma warning(disable: 4793)

    
    
    __inline int __cdecl _vsnwprintf_s_l(
          wchar_t*       const _Buffer,
                                                      size_t         const _BufferCount,
                                                      size_t         const _MaxCount,
                    wchar_t const* const _Format,
                                                  _locale_t      const _Locale,
                                                          va_list              _ArgList
        )
    

#line 1083 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt\\corecrt_wstdio.h"
    {
        int const _Result = __stdio_common_vsnwprintf_s(
            (*__local_stdio_printf_options()) ,
            _Buffer, _BufferCount, _MaxCount, _Format, _Locale, _ArgList);

        return _Result < 0 ? -1 : _Result;
    }
    #line 1091 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt\\corecrt_wstdio.h"

    
    
    __inline int __cdecl _vsnwprintf_s(
          wchar_t*       const _Buffer,
                                                      size_t         const _BufferCount,
                                                      size_t         const _MaxCount,
                              wchar_t const* const _Format,
                                                          va_list              _ArgList
        )
    

#line 1104 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt\\corecrt_wstdio.h"
    {
        return _vsnwprintf_s_l(_Buffer, _BufferCount, _MaxCount, _Format, 0 , _ArgList);
    }
    #line 1108 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt\\corecrt_wstdio.h"

    __inline int __cdecl _snwprintf( wchar_t *_Buffer, size_t _BufferCount, wchar_t const* _Format, ...); __inline int __cdecl _vsnwprintf( wchar_t *_Buffer, size_t _BufferCount, wchar_t const* _Format, va_list _Args);








    #pragma warning(pop)

    
     
    __inline int __cdecl _vsnwprintf(
          wchar_t*       _Buffer,
                                                 size_t         _BufferCount,
                         wchar_t const* _Format,
                                                     va_list        _ArgList
        )
    

#line 1131 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt\\corecrt_wstdio.h"
    {
        #pragma warning(push)
        #pragma warning(disable: 4996) 
        return _vsnwprintf_l(_Buffer, _BufferCount, _Format, 0 , _ArgList);
        #pragma warning(pop)
    }
    #line 1138 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt\\corecrt_wstdio.h"

    extern "C++" { template <size_t _Size> inline int __cdecl _vsnwprintf_s(wchar_t (&_Buffer)[_Size], size_t _BufferCount, wchar_t const* _Format, va_list _ArgList) throw() { return _vsnwprintf_s(_Buffer, _Size, _BufferCount, _Format, _ArgList); } }








    
    
    __inline int __cdecl _vswprintf_c_l(
          wchar_t*       const _Buffer,
                                                      size_t         const _BufferCount,
                    wchar_t const* const _Format,
                                                  _locale_t      const _Locale,
                                                          va_list              _ArgList
        )
    

#line 1160 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt\\corecrt_wstdio.h"
    {
        int const _Result = __stdio_common_vswprintf(
            (*__local_stdio_printf_options()) ,
            _Buffer, _BufferCount, _Format, _Locale, _ArgList);

        return _Result < 0 ? -1 : _Result;
    }
    #line 1168 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt\\corecrt_wstdio.h"

    
    
    __inline int __cdecl _vswprintf_c(
          wchar_t*       const _Buffer,
                                                      size_t         const _BufferCount,
                              wchar_t const* const _Format,
                                                          va_list              _ArgList
        )
    

#line 1180 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt\\corecrt_wstdio.h"
    {
        return _vswprintf_c_l(_Buffer, _BufferCount, _Format, 0 , _ArgList);
    }
    #line 1184 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt\\corecrt_wstdio.h"

    
    
    __inline int __cdecl _vswprintf_l(
          wchar_t*       const _Buffer,
                                                      size_t         const _BufferCount,
                    wchar_t const* const _Format,
                                                  _locale_t      const _Locale,
                                                          va_list              _ArgList
        )
    

#line 1197 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt\\corecrt_wstdio.h"
    {
        #pragma warning(push)
        #pragma warning(disable: 4996) 
        return _vswprintf_c_l(_Buffer, _BufferCount, _Format, _Locale, _ArgList);
        #pragma warning(pop)
    }
    #line 1204 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt\\corecrt_wstdio.h"

    
    
    __inline int __cdecl __vswprintf_l(
                 wchar_t*       const _Buffer,
          wchar_t const* const _Format,
                                        _locale_t      const _Locale,
                                                va_list              _ArgList
        )
    

#line 1216 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt\\corecrt_wstdio.h"
    {
        return _vswprintf_l(_Buffer, (size_t)-1, _Format, _Locale, _ArgList);
    }
    #line 1220 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt\\corecrt_wstdio.h"

    
    
    __inline int __cdecl _vswprintf(
          wchar_t*       const _Buffer,
             wchar_t const* const _Format,
                                         va_list              _ArgList
        )
    

#line 1231 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt\\corecrt_wstdio.h"
    {
        return _vswprintf_l(_Buffer, (size_t)-1, _Format, 0 , _ArgList);
    }
    #line 1235 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt\\corecrt_wstdio.h"

    
    
    __inline int __cdecl vswprintf(
          wchar_t*       const _Buffer,
                                                      size_t         const _BufferCount,
                    wchar_t const* const _Format,
                                                          va_list              _ArgList
        )
    

#line 1247 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt\\corecrt_wstdio.h"
    {
        return _vswprintf_c_l(_Buffer, _BufferCount, _Format, 0 , _ArgList);
    }
    #line 1251 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt\\corecrt_wstdio.h"

    
    
    __inline int __cdecl _vswprintf_s_l(
          wchar_t*       const _Buffer,
                                                  size_t         const _BufferCount,
                wchar_t const* const _Format,
                                              _locale_t      const _Locale,
                                                      va_list              _ArgList
        )
    

#line 1264 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt\\corecrt_wstdio.h"
    {
        int const _Result = __stdio_common_vswprintf_s(
            (*__local_stdio_printf_options()) ,
            _Buffer, _BufferCount, _Format, _Locale, _ArgList);

        return _Result < 0 ? -1 : _Result;
    }
    #line 1272 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt\\corecrt_wstdio.h"

    

        
        __inline int __cdecl vswprintf_s(
              wchar_t*       const _Buffer,
                                                      size_t         const _BufferCount,
                              wchar_t const* const _Format,
                                                          va_list              _ArgList
            )
    

#line 1285 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt\\corecrt_wstdio.h"
        {
            return _vswprintf_s_l(_Buffer, _BufferCount, _Format, 0 , _ArgList);
        }
    #line 1289 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt\\corecrt_wstdio.h"

    #line 1291 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt\\corecrt_wstdio.h"

    extern "C++" { template <size_t _Size> inline int __cdecl vswprintf_s(wchar_t (&_Buffer)[_Size], wchar_t const* _Format, va_list _ArgList) throw() { return vswprintf_s(_Buffer, _Size, _Format, _ArgList); } }







    
    
    __inline int __cdecl _vswprintf_p_l(
          wchar_t*       const _Buffer,
                                                  size_t         const _BufferCount,
                wchar_t const* const _Format,
                                              _locale_t      const _Locale,
                                                      va_list              _ArgList
        )
    

#line 1312 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt\\corecrt_wstdio.h"
    {
        int const _Result = __stdio_common_vswprintf_p(
            (*__local_stdio_printf_options()) ,
            _Buffer, _BufferCount, _Format, _Locale, _ArgList);

        return _Result < 0 ? -1 : _Result;
    }
    #line 1320 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt\\corecrt_wstdio.h"

    
    
    __inline int __cdecl _vswprintf_p(
          wchar_t*       const _Buffer,
                                                  size_t         const _BufferCount,
                          wchar_t const* const _Format,
                                                      va_list              _ArgList
        )
    

#line 1332 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt\\corecrt_wstdio.h"
    {
        return _vswprintf_p_l(_Buffer, _BufferCount, _Format, 0 , _ArgList);
    }
    #line 1336 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt\\corecrt_wstdio.h"

    
    
    __inline int __cdecl _vscwprintf_l(
          wchar_t const* const _Format,
                                        _locale_t      const _Locale,
                                                va_list              _ArgList
        )
    

#line 1347 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt\\corecrt_wstdio.h"
    {
        int const _Result = __stdio_common_vswprintf(
            (*__local_stdio_printf_options()) | (1ULL << 1) ,
            0 , 0, _Format, _Locale, _ArgList);

        return _Result < 0 ? -1 : _Result;
    }
    #line 1355 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt\\corecrt_wstdio.h"

    
    
    __inline int __cdecl _vscwprintf(
          wchar_t const* const _Format,
                                      va_list              _ArgList
        )
    

#line 1365 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt\\corecrt_wstdio.h"
    {
        return _vscwprintf_l(_Format, 0 , _ArgList);
    }
    #line 1369 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt\\corecrt_wstdio.h"

    
    
    __inline int __cdecl _vscwprintf_p_l(
          wchar_t const* const _Format,
                                        _locale_t      const _Locale,
                                                va_list              _ArgList
        )
    

#line 1380 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt\\corecrt_wstdio.h"
    {
        int const _Result = __stdio_common_vswprintf_p(
            (*__local_stdio_printf_options()) | (1ULL << 1) ,
            0 , 0, _Format, _Locale, _ArgList);

        return _Result < 0 ? -1 : _Result;
    }
    #line 1388 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt\\corecrt_wstdio.h"

    
    
    __inline int __cdecl _vscwprintf_p(
          wchar_t const* const _Format,
                                      va_list              _ArgList
        )
    

#line 1398 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt\\corecrt_wstdio.h"
    {
        return _vscwprintf_p_l(_Format, 0 , _ArgList);
    }
    #line 1402 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt\\corecrt_wstdio.h"

    
    
    __inline int __cdecl __swprintf_l(
                 wchar_t*       const _Buffer,
          wchar_t const* const _Format,
                                        _locale_t      const _Locale,
        ...)
    

#line 1413 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt\\corecrt_wstdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Locale)>(), ((void)(__va_start(&_ArgList, _Locale))))) ;
        _Result = __vswprintf_l(_Buffer, _Format, _Locale, _ArgList);
        ((void)(_ArgList = (va_list)0)) ;
        return _Result;
    }
    #line 1422 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt\\corecrt_wstdio.h"

    
    
    __inline int __cdecl _swprintf_l(
          wchar_t*       const _Buffer,
                                                      size_t         const _BufferCount,
                    wchar_t const* const _Format,
                                                  _locale_t      const _Locale,
        ...)
    

#line 1434 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt\\corecrt_wstdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Locale)>(), ((void)(__va_start(&_ArgList, _Locale))))) ;
        _Result = _vswprintf_c_l(_Buffer, _BufferCount, _Format, _Locale, _ArgList);
        ((void)(_ArgList = (va_list)0)) ;
        return _Result;
    }
    #line 1443 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt\\corecrt_wstdio.h"

    
    
    __inline int __cdecl _swprintf(
          wchar_t*       const _Buffer,
             wchar_t const* const _Format,
        ...)
    

#line 1453 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt\\corecrt_wstdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Format)>(), ((void)(__va_start(&_ArgList, _Format))))) ;
        _Result = __vswprintf_l(_Buffer, _Format, 0 , _ArgList);
        ((void)(_ArgList = (va_list)0)) ;
        return _Result;
    }
    #line 1462 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt\\corecrt_wstdio.h"

    
    
    __inline int __cdecl swprintf(
          wchar_t*       const _Buffer,
                                                      size_t         const _BufferCount,
                              wchar_t const* const _Format,
        ...)
    

#line 1473 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt\\corecrt_wstdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Format)>(), ((void)(__va_start(&_ArgList, _Format))))) ;
        _Result = _vswprintf_c_l(_Buffer, _BufferCount, _Format, 0 , _ArgList);
        ((void)(_ArgList = (va_list)0)) ;
        return _Result;
    }
    #line 1482 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt\\corecrt_wstdio.h"

    #pragma warning(push)
    // Warning 4793: The compiler cannot compile function into managed code, even though the /clr compiler option is specified.
    // Warning 4996: 'function': was declared deprecated
    #pragma warning(disable:4793 4996)

    __inline int __cdecl __swprintf_l( wchar_t *_Buffer, wchar_t const* _Format, _locale_t _Locale, ...); __inline int __cdecl __vswprintf_l( wchar_t *_Buffer, wchar_t const* _Format, _locale_t _Locale, va_list _Args);








    __inline int __cdecl _swprintf( wchar_t *_Buffer, wchar_t const* _Format, ...); __inline int __cdecl _vswprintf( wchar_t *_Buffer, wchar_t const* _Format, va_list _Args);






    #pragma warning(pop)

    
    
    __inline int __cdecl _swprintf_s_l(
          wchar_t*       const _Buffer,
                                                  size_t         const _BufferCount,
                wchar_t const* const _Format,
                                              _locale_t      const _Locale,
        ...)
    

#line 1517 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt\\corecrt_wstdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Locale)>(), ((void)(__va_start(&_ArgList, _Locale))))) ;
        _Result = _vswprintf_s_l(_Buffer, _BufferCount, _Format, _Locale, _ArgList);
        ((void)(_ArgList = (va_list)0)) ;
        return _Result;
    }
    #line 1526 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt\\corecrt_wstdio.h"

    

        
        __inline int __cdecl swprintf_s(
              wchar_t*       const _Buffer,
                                                      size_t         const _BufferCount,
                              wchar_t const* const _Format,
            ...)
    

#line 1538 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt\\corecrt_wstdio.h"
        {
            int _Result;
            va_list _ArgList;
            ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Format)>(), ((void)(__va_start(&_ArgList, _Format))))) ;
            _Result = _vswprintf_s_l(_Buffer, _BufferCount, _Format, 0 , _ArgList);
            ((void)(_ArgList = (va_list)0)) ;
            return _Result;
        }
    #line 1547 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt\\corecrt_wstdio.h"

    #line 1549 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt\\corecrt_wstdio.h"

    extern "C++" { __pragma(warning(push)); __pragma(warning(disable: 4793)); template <size_t _Size> inline int __cdecl swprintf_s(wchar_t (&_Buffer)[_Size], wchar_t const* _Format, ...) throw() { va_list _ArgList; ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Format)>(), ((void)(__va_start(&_ArgList, _Format))))); return vswprintf_s(_Buffer, _Size, _Format, _ArgList); } __pragma(warning(pop)); }






    
    
    __inline int __cdecl _swprintf_p_l(
          wchar_t*       const _Buffer,
                                                  size_t         const _BufferCount,
                wchar_t const* const _Format,
                                              _locale_t      const _Locale,
        ...)
    

#line 1568 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt\\corecrt_wstdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Locale)>(), ((void)(__va_start(&_ArgList, _Locale))))) ;
        _Result = _vswprintf_p_l(_Buffer, _BufferCount, _Format, _Locale, _ArgList);
        ((void)(_ArgList = (va_list)0)) ;
        return _Result;
    }
    #line 1577 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt\\corecrt_wstdio.h"

    
    
    __inline int __cdecl _swprintf_p(
          wchar_t*       const _Buffer,
                                                  size_t         const _BufferCount,
                          wchar_t const* const _Format,
        ...)
    

#line 1588 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt\\corecrt_wstdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Format)>(), ((void)(__va_start(&_ArgList, _Format))))) ;
        _Result = _vswprintf_p_l(_Buffer, _BufferCount, _Format, 0 , _ArgList);
        ((void)(_ArgList = (va_list)0)) ;
        return _Result;
    }
    #line 1597 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt\\corecrt_wstdio.h"

    
    
    __inline int __cdecl _swprintf_c_l(
          wchar_t*       const _Buffer,
                                                      size_t         const _BufferCount,
                    wchar_t const* const _Format,
                                                  _locale_t      const _Locale,
        ...)
    

#line 1609 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt\\corecrt_wstdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Locale)>(), ((void)(__va_start(&_ArgList, _Locale))))) ;
        _Result = _vswprintf_c_l(_Buffer, _BufferCount, _Format, _Locale, _ArgList);
        ((void)(_ArgList = (va_list)0)) ;
        return _Result;
    }
    #line 1618 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt\\corecrt_wstdio.h"

    
    
    __inline int __cdecl _swprintf_c(
          wchar_t*       const _Buffer,
                                                      size_t         const _BufferCount,
                              wchar_t const* const _Format,
        ...)
    

#line 1629 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt\\corecrt_wstdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Format)>(), ((void)(__va_start(&_ArgList, _Format))))) ;
        _Result = _vswprintf_c_l(_Buffer, _BufferCount, _Format, 0 , _ArgList);
        ((void)(_ArgList = (va_list)0)) ;
        return _Result;
    }
    #line 1638 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt\\corecrt_wstdio.h"

    
     
    __inline int __cdecl _snwprintf_l(
          wchar_t*       const _Buffer,
                                                 size_t         const _BufferCount,
               wchar_t const* const _Format,
                                             _locale_t      const _Locale,
        ...)
    

#line 1650 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt\\corecrt_wstdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Locale)>(), ((void)(__va_start(&_ArgList, _Locale))))) ;

        #pragma warning(push)
        #pragma warning(disable: 4996) 
        _Result = _vsnwprintf_l(_Buffer, _BufferCount, _Format, _Locale, _ArgList);
        #pragma warning(pop)

        ((void)(_ArgList = (va_list)0)) ;
        return _Result;
    }
    #line 1664 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt\\corecrt_wstdio.h"

    
    
    __inline int __cdecl _snwprintf(
          wchar_t*       _Buffer,
                                                 size_t         _BufferCount,
                         wchar_t const* _Format,
        ...)
    

#line 1675 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt\\corecrt_wstdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Format)>(), ((void)(__va_start(&_ArgList, _Format))))) ;

        #pragma warning(push)
        #pragma warning(disable: 4996) 
        _Result = _vsnwprintf_l(_Buffer, _BufferCount, _Format, 0 , _ArgList);
        #pragma warning(pop)

        ((void)(_ArgList = (va_list)0)) ;
        return _Result;
    }
    #line 1689 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt\\corecrt_wstdio.h"

    
    
    __inline int __cdecl _snwprintf_s_l(
          wchar_t*       const _Buffer,
                                                      size_t         const _BufferCount,
                                                      size_t         const _MaxCount,
                    wchar_t const* const _Format,
                                                  _locale_t      const _Locale,
        ...)
    

#line 1702 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt\\corecrt_wstdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Locale)>(), ((void)(__va_start(&_ArgList, _Locale))))) ;
        _Result = _vsnwprintf_s_l(_Buffer, _BufferCount, _MaxCount, _Format, _Locale, _ArgList);
        ((void)(_ArgList = (va_list)0)) ;
        return _Result;
    }
    #line 1711 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt\\corecrt_wstdio.h"

    
    
    __inline int __cdecl _snwprintf_s(
          wchar_t*       const _Buffer,
                                                      size_t         const _BufferCount,
                                                      size_t         const _MaxCount,
                              wchar_t const* const _Format,
        ...)
    

#line 1723 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt\\corecrt_wstdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Format)>(), ((void)(__va_start(&_ArgList, _Format))))) ;
        _Result = _vsnwprintf_s_l(_Buffer, _BufferCount, _MaxCount, _Format, 0 , _ArgList);
        ((void)(_ArgList = (va_list)0)) ;
        return _Result;
    }
    #line 1732 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt\\corecrt_wstdio.h"

    extern "C++" { __pragma(warning(push)); __pragma(warning(disable: 4793)); template <size_t _Size> inline int __cdecl _snwprintf_s(wchar_t (&_Buffer)[_Size], size_t _BufferCount, wchar_t const* _Format, ...) throw() { va_list _ArgList; ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Format)>(), ((void)(__va_start(&_ArgList, _Format))))); return _vsnwprintf_s(_Buffer, _Size, _BufferCount, _Format, _ArgList); } __pragma(warning(pop)); }







    
    __inline int __cdecl _scwprintf_l(
          wchar_t const* const _Format,
                                        _locale_t      const _Locale,
        ...)
    

#line 1749 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt\\corecrt_wstdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Locale)>(), ((void)(__va_start(&_ArgList, _Locale))))) ;
        _Result = _vscwprintf_l(_Format, _Locale, _ArgList);
        ((void)(_ArgList = (va_list)0)) ;
        return _Result;
    }
    #line 1758 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt\\corecrt_wstdio.h"

    
    
    __inline int __cdecl _scwprintf(
          wchar_t const* const _Format,
        ...)
    

#line 1767 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt\\corecrt_wstdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Format)>(), ((void)(__va_start(&_ArgList, _Format))))) ;
        _Result = _vscwprintf_l(_Format, 0 , _ArgList);
        ((void)(_ArgList = (va_list)0)) ;
        return _Result;
    }
    #line 1776 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt\\corecrt_wstdio.h"

    
    
    __inline int __cdecl _scwprintf_p_l(
          wchar_t const* const _Format,
                                        _locale_t      const _Locale,
        ...)
    

#line 1786 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt\\corecrt_wstdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Locale)>(), ((void)(__va_start(&_ArgList, _Locale))))) ;
        _Result = _vscwprintf_p_l(_Format, _Locale, _ArgList);
        ((void)(_ArgList = (va_list)0)) ;
        return _Result;
    }
    #line 1795 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt\\corecrt_wstdio.h"

    
    
    __inline int __cdecl _scwprintf_p(
          wchar_t const* const _Format,
        ...)
    

#line 1804 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt\\corecrt_wstdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Format)>(), ((void)(__va_start(&_ArgList, _Format))))) ;
        _Result = _vscwprintf_p_l(_Format, 0 , _ArgList);
        ((void)(_ArgList = (va_list)0)) ;
        return _Result;
    }
    #line 1813 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt\\corecrt_wstdio.h"


    
        #pragma warning(push)
        #pragma warning(disable: 4141 4412 4793 4996 6054)

        

            extern "C++" __declspec(deprecated("function has been changed to conform with the ISO C standard, " "adding an extra character count parameter. To use the traditional " "Microsoft version, set _CRT_NON_CONFORMING_SWPRINTFS.")) 
            inline int swprintf(
                         wchar_t*       const _Buffer,
                  wchar_t const* const _Format,
                ...) throw()
            {
                int _Result;
                va_list _ArgList;
                ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Format)>(), ((void)(__va_start(&_ArgList, _Format))))) ;
                #pragma warning(suppress: 28719)
                _Result = vswprintf(_Buffer, 2147483647 , _Format, _ArgList);
                ((void)(_ArgList = (va_list)0)) ;
                return _Result;
            }

            extern "C++" __declspec(deprecated("function has been changed to conform with the ISO C standard, " "adding an extra character count parameter. To use the traditional " "Microsoft version, set _CRT_NON_CONFORMING_SWPRINTFS.")) 
            inline int __cdecl vswprintf(
                         wchar_t*       const _Buffer,
                  wchar_t const* const _Format,
                                              va_list              _ArgList
                ) throw()
            {
                #pragma warning(suppress: 28719)
                return vswprintf(_Buffer, 2147483647 , _Format, _ArgList);
            }

            extern "C++" __declspec(deprecated("function has been changed to conform with the ISO C standard, " "adding an extra character count parameter. To use the traditional " "Microsoft version, set _CRT_NON_CONFORMING_SWPRINTFS.")) 
            inline int _swprintf_l(
                                   wchar_t*       const _Buffer,
                  wchar_t const* const _Format,
                                                _locale_t      const _Locale,
                ...) throw()
            {
                int _Result;
                va_list _ArgList;
                ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Locale)>(), ((void)(__va_start(&_ArgList, _Locale))))) ;
                _Result = _vswprintf_l(_Buffer, (size_t)-1, _Format, _Locale, _ArgList);
                ((void)(_ArgList = (va_list)0)) ;
                return _Result;
            }

            extern "C++" __declspec(deprecated("function has been changed to conform with the ISO C standard, " "adding an extra character count parameter. To use the traditional " "Microsoft version, set _CRT_NON_CONFORMING_SWPRINTFS.")) 
            inline int __cdecl _vswprintf_l(
                                   wchar_t*       const _Buffer,
                  wchar_t const* const _Format,
                                                _locale_t      const _Locale,
                                                        va_list              _ArgList
                ) throw()
            {
                return _vswprintf_l(_Buffer, (size_t)-1, _Format, _Locale, _ArgList);
            }

        #line 1874 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt\\corecrt_wstdio.h"

        #pragma warning(pop)
    #line 1877 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt\\corecrt_wstdio.h"

    




#line 1884 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt\\corecrt_wstdio.h"


    //-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    //
    // Wide Character Formatted Input Functions (String)
    //
    //-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    
    __declspec(dllimport) int __cdecl __stdio_common_vswscanf(
                                           unsigned __int64 _Options,
                wchar_t const*   _Buffer,
                                           size_t           _BufferCount,
          wchar_t const*   _Format,
                                       _locale_t        _Locale,
                                               va_list          _ArgList
        );

    
    
    __inline int __cdecl _vswscanf_l(
                                wchar_t const* const _Buffer,
          wchar_t const* const _Format,
                              _locale_t      const _Locale,
                                      va_list              _ArgList
        )
    

#line 1912 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt\\corecrt_wstdio.h"
    {
        return __stdio_common_vswscanf(
            (*__local_stdio_scanf_options ()) ,
            _Buffer, (size_t)-1, _Format, _Locale, _ArgList);
    }
    #line 1918 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt\\corecrt_wstdio.h"

    
    
    __inline int __cdecl vswscanf(
                                wchar_t const* _Buffer,
          wchar_t const* _Format,
                                      va_list        _ArgList
        )
    

#line 1929 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt\\corecrt_wstdio.h"
    {
        return _vswscanf_l(_Buffer, _Format, 0 , _ArgList);
    }
    #line 1933 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt\\corecrt_wstdio.h"

    
    
    __inline int __cdecl _vswscanf_s_l(
                                wchar_t const* const _Buffer,
          wchar_t const* const _Format,
                              _locale_t      const _Locale,
                                      va_list              _ArgList
        )
    

#line 1945 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt\\corecrt_wstdio.h"
    {
        return __stdio_common_vswscanf(
            (*__local_stdio_scanf_options ()) | (1ULL << 0) ,
            _Buffer, (size_t)-1, _Format, _Locale, _ArgList);
    }
    #line 1951 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt\\corecrt_wstdio.h"

    

        
        
        __inline int __cdecl vswscanf_s(
                                    wchar_t const* const _Buffer,
              wchar_t const* const _Format,
                                          va_list              _ArgList
            )
    

#line 1964 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt\\corecrt_wstdio.h"
        {
            return _vswscanf_s_l(_Buffer, _Format, 0 , _ArgList);
        }
    #line 1968 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt\\corecrt_wstdio.h"

    #line 1970 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt\\corecrt_wstdio.h"

    extern "C++" { template <size_t _Size> inline int __cdecl vswscanf_s(wchar_t (&_Buffer)[_Size], wchar_t const* _Format, va_list _ArgList) throw() { return vswscanf_s(_Buffer, _Size, _Format, _ArgList); } }







    
     
    __inline int __cdecl _vsnwscanf_l(
                wchar_t const* const _Buffer,
                                           size_t         const _BufferCount,
          wchar_t const* const _Format,
                                       _locale_t      const _Locale,
                                               va_list              _ArgList
        )
    

#line 1991 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt\\corecrt_wstdio.h"
    {
        return __stdio_common_vswscanf(
            (*__local_stdio_scanf_options ()) ,
            _Buffer, _BufferCount, _Format, _Locale, _ArgList);
    }
    #line 1997 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt\\corecrt_wstdio.h"

    
    
    __inline int __cdecl _vsnwscanf_s_l(
                  wchar_t const* const _Buffer,
                                             size_t         const _BufferCount,
          wchar_t const* const _Format,
                                         _locale_t      const _Locale,
                                                 va_list              _ArgList
        )
    

#line 2010 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt\\corecrt_wstdio.h"
    {
        return __stdio_common_vswscanf(
            (*__local_stdio_scanf_options ()) | (1ULL << 0) ,
            _Buffer, _BufferCount, _Format, _Locale, _ArgList);
    }
    #line 2016 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt\\corecrt_wstdio.h"

    
     
    __inline int __cdecl _swscanf_l(
                                         wchar_t const* const _Buffer,
          wchar_t const* const _Format,
                                       _locale_t            _Locale,
        ...)
    

#line 2027 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt\\corecrt_wstdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Locale)>(), ((void)(__va_start(&_ArgList, _Locale))))) ;
        _Result = _vswscanf_l(_Buffer, _Format, _Locale, _ArgList);
        ((void)(_ArgList = (va_list)0)) ;
        return _Result;
    }
    #line 2036 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt\\corecrt_wstdio.h"

    
     
    __inline int __cdecl swscanf(
                               wchar_t const* const _Buffer,
          wchar_t const* const _Format,
        ...)
    

#line 2046 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt\\corecrt_wstdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Format)>(), ((void)(__va_start(&_ArgList, _Format))))) ;
        _Result = _vswscanf_l(_Buffer, _Format, 0 , _ArgList);
        ((void)(_ArgList = (va_list)0)) ;
        return _Result;
    }
    #line 2055 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt\\corecrt_wstdio.h"

    
    
    __inline int __cdecl _swscanf_s_l(
                                           wchar_t const* const _Buffer,
          wchar_t const* const _Format,
                                         _locale_t      const _Locale,
        ...)
    

#line 2066 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt\\corecrt_wstdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Locale)>(), ((void)(__va_start(&_ArgList, _Locale))))) ;
        _Result = _vswscanf_s_l(_Buffer, _Format, _Locale, _ArgList);
        ((void)(_ArgList = (va_list)0)) ;
        return _Result;
    }
    #line 2075 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt\\corecrt_wstdio.h"

    

        
        
        __inline int __cdecl swscanf_s(
                                     wchar_t const* const _Buffer,
              wchar_t const* const _Format,
            ...)
    

#line 2087 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt\\corecrt_wstdio.h"
        {
            int _Result;
            va_list _ArgList;
            ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Format)>(), ((void)(__va_start(&_ArgList, _Format))))) ;
            _Result = _vswscanf_s_l(_Buffer, _Format, 0 , _ArgList);
            ((void)(_ArgList = (va_list)0)) ;
            return _Result;
        }
    #line 2096 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt\\corecrt_wstdio.h"

    #line 2098 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt\\corecrt_wstdio.h"

    
     
    __inline int __cdecl _snwscanf_l(
                wchar_t const* const _Buffer,
                                           size_t         const _BufferCount,
          wchar_t const* const _Format,
                                       _locale_t      const _Locale,
        ...)
    

#line 2110 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt\\corecrt_wstdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Locale)>(), ((void)(__va_start(&_ArgList, _Locale))))) ;

        #pragma warning(push)
        #pragma warning(disable: 4996) 
        _Result = _vsnwscanf_l(_Buffer, _BufferCount, _Format, _Locale, _ArgList);
        #pragma warning(pop)

        ((void)(_ArgList = (va_list)0)) ;
        return _Result;
    }
    #line 2124 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt\\corecrt_wstdio.h"

    
     
    __inline int __cdecl _snwscanf(
          wchar_t const* const _Buffer,
                                     size_t         const _BufferCount,
              wchar_t const* const _Format,
        ...)
    

#line 2135 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt\\corecrt_wstdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Format)>(), ((void)(__va_start(&_ArgList, _Format))))) ;

        #pragma warning(push)
        #pragma warning(disable: 4996) 
        _Result = _vsnwscanf_l(_Buffer, _BufferCount, _Format, 0 , _ArgList);
        #pragma warning(pop)

        ((void)(_ArgList = (va_list)0)) ;
        return _Result;
    }
    #line 2149 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt\\corecrt_wstdio.h"

    
    
    __inline int __cdecl _snwscanf_s_l(
                  wchar_t const* const _Buffer,
                                             size_t         const _BufferCount,
          wchar_t const* const _Format,
                                         _locale_t      const _Locale,
        ...)
    

#line 2161 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt\\corecrt_wstdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Locale)>(), ((void)(__va_start(&_ArgList, _Locale))))) ;
        _Result = _vsnwscanf_s_l(_Buffer, _BufferCount, _Format, _Locale, _ArgList);
        ((void)(_ArgList = (va_list)0)) ;
        return _Result;
    }
    #line 2170 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt\\corecrt_wstdio.h"

    
    
    __inline int __cdecl _snwscanf_s(
           wchar_t const* const _Buffer,
                                      size_t         const _BufferCount,
             wchar_t const* const _Format,
        ...)
    

#line 2181 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt\\corecrt_wstdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Format)>(), ((void)(__va_start(&_ArgList, _Format))))) ;
        _Result = _vsnwscanf_s_l(_Buffer, _BufferCount, _Format, 0 , _ArgList);
        ((void)(_ArgList = (va_list)0)) ;
        return _Result;
    }
    #line 2190 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt\\corecrt_wstdio.h"

    


#line 2195 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt\\corecrt_wstdio.h"



} __pragma(pack(pop))
#line 14 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt\\stdio.h"

__pragma(pack(push, 8)) extern "C" {

/* Buffered I/O macros */





/*
 * Default number of supported streams. _NFILE is confusing and obsolete, but
 * supported anyway for backwards compatibility.
 */




/*
 * Number of entries in _iob[] (declared below). Note that _NSTREAM_ must be
 * greater than or equal to _IOB_ENTRIES.
 */












    
#line 49 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt\\stdio.h"



/* Seek method constants */











    
    
#line 67 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt\\stdio.h"


typedef __int64 fpos_t;





    
    __declspec(dllimport) errno_t __cdecl _get_stream_buffer_pointers(
              FILE*   _Stream,
         char*** _Base,
         char*** _Pointer,
         int**   _Count
        );


    //-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    //
    // Narrow Character Stream I/O Functions
    //
    //-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    

        
        __declspec(dllimport) errno_t __cdecl clearerr_s(
             FILE* _Stream
            );

        
        __declspec(dllimport) errno_t __cdecl fopen_s(
             FILE**      _Stream,
                                char const* _FileName,
                                char const* _Mode
            );

        
        
        __declspec(dllimport) size_t __cdecl fread_s(
               void*  _Buffer,
                                   size_t _BufferSize,
                                                                           size_t _ElementSize,
                                                                           size_t _ElementCount,
                                                                        FILE*  _Stream
            );

        
        __declspec(dllimport) errno_t __cdecl freopen_s(
             FILE**      _Stream,
                                char const* _FileName,
                                char const* _Mode,
                               FILE*       _OldStream
            );

        
        __declspec(dllimport) char* __cdecl gets_s(
             char*   _Buffer,
                              rsize_t _Size
            );

        
        __declspec(dllimport) errno_t __cdecl tmpfile_s(
              FILE** _Stream
            );

        
        
        __declspec(dllimport) errno_t __cdecl tmpnam_s(
             char*   _Buffer,
                              rsize_t _Size
            );

    #line 140 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt\\stdio.h"

    __declspec(dllimport) void __cdecl clearerr(
         FILE* _Stream
        );

    
    
    __declspec(dllimport) int __cdecl fclose(
         FILE* _Stream
        );

    
    __declspec(dllimport) int __cdecl _fcloseall(void);

    
    __declspec(dllimport) FILE* __cdecl _fdopen(
           int         _FileHandle,
         char const* _Mode
        );

    
    __declspec(dllimport) int __cdecl feof(
         FILE* _Stream
        );

    
    __declspec(dllimport) int __cdecl ferror(
         FILE* _Stream
        );

    
    __declspec(dllimport) int __cdecl fflush(
         FILE* _Stream
        );

    
    
    __declspec(dllimport) int __cdecl fgetc(
         FILE* _Stream
        );

    
    __declspec(dllimport) int __cdecl _fgetchar(void);

    
    
    __declspec(dllimport) int __cdecl fgetpos(
         FILE*   _Stream,
           fpos_t* _Position
        );

    
    
    __declspec(dllimport) char* __cdecl fgets(
         char* _Buffer,
                              int   _MaxCount,
                           FILE* _Stream
        );

    
    __declspec(dllimport) int __cdecl _fileno(
         FILE* _Stream
        );

    
    __declspec(dllimport) int __cdecl _flushall(void);

     
    __declspec(dllimport) FILE* __cdecl fopen(
         char const* _FileName,
         char const* _Mode
        );


    
    
    __declspec(dllimport) int __cdecl fputc(
            int   _Character,
         FILE* _Stream
        );

    
    __declspec(dllimport) int __cdecl _fputchar(
         int _Character
        );

    
    
    __declspec(dllimport) int __cdecl fputs(
          char const* _Buffer,
         FILE*       _Stream
        );

    
    __declspec(dllimport) size_t __cdecl fread(
         void*  _Buffer,
                                                     size_t _ElementSize,
                                                     size_t _ElementCount,
                                                  FILE*  _Stream
        );

    
     
    __declspec(dllimport) FILE* __cdecl freopen(
          char const* _FileName,
          char const* _Mode,
         FILE*       _Stream
        );

    
    __declspec(dllimport) FILE* __cdecl _fsopen(
         char const* _FileName,
         char const* _Mode,
           int         _ShFlag
        );

    
    
    __declspec(dllimport) int __cdecl fsetpos(
         FILE*         _Stream,
            fpos_t const* _Position
        );

    
    
    __declspec(dllimport) int __cdecl fseek(
         FILE* _Stream,
            long  _Offset,
            int   _Origin
        );

    
    
    __declspec(dllimport) int __cdecl _fseeki64(
         FILE*   _Stream,
            __int64 _Offset,
            int     _Origin
        );

    
    
    __declspec(dllimport) long __cdecl ftell(
         FILE* _Stream
        );

    
    
    __declspec(dllimport) __int64 __cdecl _ftelli64(
         FILE* _Stream
        );

    
    __declspec(dllimport) size_t __cdecl fwrite(
         void const* _Buffer,
                                                   size_t      _ElementSize,
                                                   size_t      _ElementCount,
                                                FILE*       _Stream
        );

    
    
    __declspec(dllimport) int __cdecl getc(
         FILE* _Stream
        );

    
    __declspec(dllimport) int __cdecl getchar(void);

    
    __declspec(dllimport) int __cdecl _getmaxstdio(void);

    extern "C++" { template <size_t _Size> inline char* __cdecl gets_s(char (&_Buffer)[_Size]) throw() { return gets_s(_Buffer, _Size); } }



    
    __declspec(dllimport) int __cdecl _getw(
         FILE* _Stream
        );

    __declspec(dllimport) void __cdecl perror(
         char const* _ErrorMessage
        );

    

        
        
        __declspec(dllimport) int __cdecl _pclose(
             FILE* _Stream
            );

        
        __declspec(dllimport) FILE* __cdecl _popen(
             char const* _Command,
             char const* _Mode
            );

    #line 339 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt\\stdio.h"

    
    
    __declspec(dllimport) int __cdecl putc(
            int   _Character,
         FILE* _Stream
        );

    
    __declspec(dllimport) int __cdecl putchar(
         int _Character
        );

    
    __declspec(dllimport) int __cdecl puts(
         char const* _Buffer
        );

    
    
    __declspec(dllimport) int __cdecl _putw(
            int   _Word,
         FILE* _Stream
        );

    __declspec(dllimport) int __cdecl remove(
         char const* _FileName
        );

    
    __declspec(dllimport) int __cdecl rename(
         char const* _OldFileName,
         char const* _NewFileName
        );

    __declspec(dllimport) int __cdecl _unlink(
         char const* _FileName
        );

    

        __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_unlink" ". See online help for details."))
        __declspec(dllimport) int __cdecl unlink(
             char const* _FileName
            );

    #line 386 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt\\stdio.h"

    __declspec(dllimport) void __cdecl rewind(
         FILE* _Stream
        );

    
    __declspec(dllimport) int __cdecl _rmtmp(void);

    
    __declspec(dllimport) void __cdecl setbuf(
                                                     FILE* _Stream,
          char* _Buffer
        );

    
    __declspec(dllimport) int __cdecl _setmaxstdio(
         int _Maximum
        );

    
    
    __declspec(dllimport) int __cdecl setvbuf(
                              FILE*  _Stream,
           char*  _Buffer,
                                 int    _Mode,
                                 size_t _Size
        );

    


#line 418 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt\\stdio.h"

    
    __declspec(dllimport) __declspec(allocator) char* __cdecl _tempnam(
         char const* _DirectoryName,
         char const* _FilePrefix
        );

    

#line 428 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt\\stdio.h"

     
    __declspec(dllimport) FILE* __cdecl tmpfile(void);

    extern "C++" { template <size_t _Size> inline errno_t __cdecl tmpnam_s(char (&_Buffer)[_Size]) throw() { return tmpnam_s(_Buffer, _Size); } }





#pragma warning(push)
#pragma warning(disable: 28726) 
__declspec(dllimport) char* __cdecl tmpnam( char *_Buffer);




#pragma warning(pop)

    
    
    __declspec(dllimport) int __cdecl ungetc(
            int   _Character,
         FILE* _Stream
        );



    //-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    //
    // I/O Synchronization and _nolock family of I/O functions
    //
    //-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    __declspec(dllimport) void __cdecl _lock_file(
         FILE* _Stream
        );

    __declspec(dllimport) void __cdecl _unlock_file(
         FILE* _Stream
        );

    
    
    __declspec(dllimport) int __cdecl _fclose_nolock(
         FILE* _Stream
        );

    
    
    __declspec(dllimport) int __cdecl _fflush_nolock(
         FILE* _Stream
        );

    
    
    __declspec(dllimport) int __cdecl _fgetc_nolock(
         FILE* _Stream
        );

    
    
    __declspec(dllimport) int __cdecl _fputc_nolock(
            int   _Character,
         FILE* _Stream
        );

    
    __declspec(dllimport) size_t __cdecl _fread_nolock(
         void*  _Buffer,
                                                     size_t _ElementSize,
                                                     size_t _ElementCount,
                                                  FILE*  _Stream
        );

    
    
    __declspec(dllimport) size_t __cdecl _fread_nolock_s(
         void*  _Buffer,
                             size_t _BufferSize,
                                                                     size_t _ElementSize,
                                                                     size_t _ElementCount,
                                                                  FILE*  _Stream
        );

    
    __declspec(dllimport) int __cdecl _fseek_nolock(
         FILE* _Stream,
            long  _Offset,
            int   _Origin
        );

    
    __declspec(dllimport) int __cdecl _fseeki64_nolock(
         FILE*   _Stream,
            __int64 _Offset,
            int     _Origin
        );

    
    __declspec(dllimport) long __cdecl _ftell_nolock(
         FILE* _Stream
        );

    
    __declspec(dllimport) __int64 __cdecl _ftelli64_nolock(
         FILE* _Stream
        );

    
    __declspec(dllimport) size_t __cdecl _fwrite_nolock(
         void const* _Buffer,
                                                   size_t      _ElementSize,
                                                   size_t      _ElementCount,
                                                FILE*       _Stream
        );

    
    __declspec(dllimport) int __cdecl _getc_nolock(
         FILE* _Stream
        );

    
    __declspec(dllimport) int __cdecl _putc_nolock(
            int   _Character,
         FILE* _Stream
        );

    
    __declspec(dllimport) int __cdecl _ungetc_nolock(
            int   _Character,
         FILE* _Stream
        );

    
    
    
    



    














#line 584 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt\\stdio.h"



    __declspec(dllimport) int* __cdecl __p__commode(void);

    


        
    #line 594 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt\\stdio.h"



    // Variadic functions are not supported in managed code under /clr
    

#line 601 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt\\stdio.h"

    //-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    //
    // Narrow Character Formatted Output Functions (Stream)
    //
    //-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    __declspec(dllimport) int __cdecl __stdio_common_vfprintf(
                                            unsigned __int64 _Options,
                                         FILE*            _Stream,
          char const*      _Format,
                                        _locale_t        _Locale,
                                                va_list          _ArgList
        );

    __declspec(dllimport) int __cdecl __stdio_common_vfprintf_s(
                                            unsigned __int64 _Options,
                                         FILE*            _Stream,
          char const*      _Format,
                                        _locale_t        _Locale,
                                                va_list          _ArgList
        );

    
    __declspec(dllimport) int __cdecl __stdio_common_vfprintf_p(
                                            unsigned __int64 _Options,
                                         FILE*            _Stream,
          char const*      _Format,
                                        _locale_t        _Locale,
                                                va_list          _ArgList
        );

    
    __inline int __cdecl _vfprintf_l(
          FILE*       const _Stream,
           char const* const _Format,
         _locale_t   const _Locale,
                 va_list           _ArgList
        )
    

#line 642 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt\\stdio.h"
    {
        return __stdio_common_vfprintf((*__local_stdio_printf_options()) , _Stream, _Format, _Locale, _ArgList);
    }
    #line 646 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt\\stdio.h"

    
    __inline int __cdecl vfprintf(
                               FILE*       const _Stream,
          char const* const _Format,
                                      va_list           _ArgList
        )
    

#line 656 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt\\stdio.h"
    {
        return _vfprintf_l(_Stream, _Format, 0 , _ArgList);
    }
    #line 660 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt\\stdio.h"

    
    __inline int __cdecl _vfprintf_s_l(
          FILE*       const _Stream,
           char const* const _Format,
         _locale_t   const _Locale,
                 va_list           _ArgList
        )
    

#line 671 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt\\stdio.h"
    {
        return __stdio_common_vfprintf_s((*__local_stdio_printf_options()) , _Stream, _Format, _Locale, _ArgList);
    }
    #line 675 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt\\stdio.h"

    

        
        __inline int __cdecl vfprintf_s(
                                   FILE*       const _Stream,
              char const* const _Format,
                                          va_list           _ArgList
            )
    

#line 687 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt\\stdio.h"
        {
            return _vfprintf_s_l(_Stream, _Format, 0 , _ArgList);
        }
    #line 691 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt\\stdio.h"

    #line 693 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt\\stdio.h"

    
    __inline int __cdecl _vfprintf_p_l(
          FILE*       const _Stream,
           char const* const _Format,
         _locale_t   const _Locale,
                 va_list           _ArgList
        )
    

#line 704 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt\\stdio.h"
    {
        return __stdio_common_vfprintf_p((*__local_stdio_printf_options()) , _Stream, _Format, _Locale, _ArgList);
    }
    #line 708 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt\\stdio.h"

    
    __inline int __cdecl _vfprintf_p(
                               FILE*       const _Stream,
          char const* const _Format,
                                      va_list           _ArgList
        )
    

#line 718 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt\\stdio.h"
    {
        return _vfprintf_p_l(_Stream, _Format, 0 , _ArgList);
    }
    #line 722 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt\\stdio.h"

    
    __inline int __cdecl _vprintf_l(
          char const* const _Format,
                                        _locale_t   const _Locale,
                                                va_list           _ArgList
        )
    

#line 732 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt\\stdio.h"
    {
        return _vfprintf_l((__acrt_iob_func(1)) , _Format, _Locale, _ArgList);
    }
    #line 736 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt\\stdio.h"

    
    __inline int __cdecl vprintf(
          char const* const _Format,
                                      va_list           _ArgList
        )
    

#line 745 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt\\stdio.h"
    {
        return _vfprintf_l((__acrt_iob_func(1)) , _Format, 0 , _ArgList);
    }
    #line 749 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt\\stdio.h"

    
    __inline int __cdecl _vprintf_s_l(
          char const* const _Format,
                                        _locale_t   const _Locale,
                                                va_list           _ArgList
        )
    

#line 759 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt\\stdio.h"
    {
        return _vfprintf_s_l((__acrt_iob_func(1)) , _Format, _Locale, _ArgList);
    }
    #line 763 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt\\stdio.h"

    

        
        __inline int __cdecl vprintf_s(
              char const* const _Format,
                                          va_list           _ArgList
            )
    

#line 774 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt\\stdio.h"
        {
            return _vfprintf_s_l((__acrt_iob_func(1)) , _Format, 0 , _ArgList);
        }
    #line 778 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt\\stdio.h"

    #line 780 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt\\stdio.h"

    
    __inline int __cdecl _vprintf_p_l(
          char const* const _Format,
                                        _locale_t   const _Locale,
                                                va_list           _ArgList
        )
    

#line 790 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt\\stdio.h"
    {
        return _vfprintf_p_l((__acrt_iob_func(1)) , _Format, _Locale, _ArgList);
    }
    #line 794 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt\\stdio.h"

    
    __inline int __cdecl _vprintf_p(
          char const* const _Format,
                                      va_list           _ArgList
        )
    

#line 803 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt\\stdio.h"
    {
        return _vfprintf_p_l((__acrt_iob_func(1)) , _Format, 0 , _ArgList);
    }
    #line 807 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt\\stdio.h"

    
    __inline int __cdecl _fprintf_l(
                                         FILE*       const _Stream,
          char const* const _Format,
                                        _locale_t   const _Locale,
        ...)
    

#line 817 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt\\stdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Locale)>(), ((void)(__va_start(&_ArgList, _Locale))))) ;
        _Result = _vfprintf_l(_Stream, _Format, _Locale, _ArgList);
        ((void)(_ArgList = (va_list)0)) ;
        return _Result;
    }
    #line 826 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt\\stdio.h"

    
    __inline int __cdecl fprintf(
                               FILE*       const _Stream,
          char const* const _Format,
        ...)
    

#line 835 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt\\stdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Format)>(), ((void)(__va_start(&_ArgList, _Format))))) ;
        _Result = _vfprintf_l(_Stream, _Format, 0 , _ArgList);
        ((void)(_ArgList = (va_list)0)) ;
        return _Result;
    }
    #line 844 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt\\stdio.h"

    __declspec(dllimport) int __cdecl _set_printf_count_output(
         int _Value
        );

    __declspec(dllimport) int __cdecl _get_printf_count_output(void);

    
    __inline int __cdecl _fprintf_s_l(
                                         FILE*       const _Stream,
          char const* const _Format,
                                        _locale_t   const _Locale,
        ...)
    

#line 860 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt\\stdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Locale)>(), ((void)(__va_start(&_ArgList, _Locale))))) ;
        _Result = _vfprintf_s_l(_Stream, _Format, _Locale, _ArgList);
        ((void)(_ArgList = (va_list)0)) ;
        return _Result;
    }
    #line 869 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt\\stdio.h"

    

        
        __inline int __cdecl fprintf_s(
                                   FILE*       const _Stream,
              char const* const _Format,
            ...)
    

#line 880 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt\\stdio.h"
        {
            int _Result;
            va_list _ArgList;
            ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Format)>(), ((void)(__va_start(&_ArgList, _Format))))) ;
            _Result = _vfprintf_s_l(_Stream, _Format, 0 , _ArgList);
            ((void)(_ArgList = (va_list)0)) ;
            return _Result;
        }
    #line 889 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt\\stdio.h"

    #line 891 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt\\stdio.h"

    
    __inline int __cdecl _fprintf_p_l(
                                         FILE*       const _Stream,
          char const* const _Format,
                                        _locale_t   const _Locale,
        ...)
    

#line 901 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt\\stdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Locale)>(), ((void)(__va_start(&_ArgList, _Locale))))) ;
        _Result = _vfprintf_p_l(_Stream, _Format, _Locale, _ArgList);
        ((void)(_ArgList = (va_list)0)) ;
        return _Result;
    }
    #line 910 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt\\stdio.h"

    
    __inline int __cdecl _fprintf_p(
                               FILE*       const _Stream,
          char const* const _Format,
        ...)
    

#line 919 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt\\stdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Format)>(), ((void)(__va_start(&_ArgList, _Format))))) ;
        _Result = _vfprintf_p_l(_Stream, _Format, 0 , _ArgList);
        ((void)(_ArgList = (va_list)0)) ;
        return _Result;
    }
    #line 928 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt\\stdio.h"

    
    __inline int __cdecl _printf_l(
          char const* const _Format,
                                        _locale_t   const _Locale,
        ...)
    

#line 937 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt\\stdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Locale)>(), ((void)(__va_start(&_ArgList, _Locale))))) ;
        _Result = _vfprintf_l((__acrt_iob_func(1)) , _Format, _Locale, _ArgList);
        ((void)(_ArgList = (va_list)0)) ;
        return _Result;
    }
    #line 946 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt\\stdio.h"

    
    __inline int __cdecl printf(
          char const* const _Format,
        ...)
    

#line 954 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt\\stdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Format)>(), ((void)(__va_start(&_ArgList, _Format))))) ;
        _Result = _vfprintf_l((__acrt_iob_func(1)) , _Format, 0 , _ArgList);
        ((void)(_ArgList = (va_list)0)) ;
        return _Result;
    }
    #line 963 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt\\stdio.h"

    
    __inline int __cdecl _printf_s_l(
          char const* const _Format,
                                        _locale_t   const _Locale,
        ...)
    

#line 972 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt\\stdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Locale)>(), ((void)(__va_start(&_ArgList, _Locale))))) ;
        _Result = _vfprintf_s_l((__acrt_iob_func(1)) , _Format, _Locale, _ArgList);
        ((void)(_ArgList = (va_list)0)) ;
        return _Result;
    }
    #line 981 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt\\stdio.h"

    

        
        __inline int __cdecl printf_s(
              char const* const _Format,
            ...)
    

#line 991 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt\\stdio.h"
        {
            int _Result;
            va_list _ArgList;
            ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Format)>(), ((void)(__va_start(&_ArgList, _Format))))) ;
            _Result = _vfprintf_s_l((__acrt_iob_func(1)) , _Format, 0 , _ArgList);
            ((void)(_ArgList = (va_list)0)) ;
            return _Result;
        }
    #line 1000 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt\\stdio.h"

    #line 1002 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt\\stdio.h"

    
    __inline int __cdecl _printf_p_l(
          char const* const _Format,
                                        _locale_t   const _Locale,
        ...)
    

#line 1011 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt\\stdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Locale)>(), ((void)(__va_start(&_ArgList, _Locale))))) ;
        _Result = _vfprintf_p_l((__acrt_iob_func(1)) , _Format, _Locale, _ArgList);
        ((void)(_ArgList = (va_list)0)) ;
        return _Result;
    }
    #line 1020 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt\\stdio.h"

    
    __inline int __cdecl _printf_p(
          char const* const _Format,
        ...)
    

#line 1028 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt\\stdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Format)>(), ((void)(__va_start(&_ArgList, _Format))))) ;
        _Result = _vfprintf_p_l((__acrt_iob_func(1)) , _Format, 0 , _ArgList);
        ((void)(_ArgList = (va_list)0)) ;
        return _Result;
    }
    #line 1037 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt\\stdio.h"


    //-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    //
    // Narrow Character Formatted Input Functions (Stream)
    //
    //-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    __declspec(dllimport) int __cdecl __stdio_common_vfscanf(
                                           unsigned __int64 _Options,
                                        FILE*            _Stream,
          char const*      _Format,
                                       _locale_t        _Locale,
                                               va_list          _Arglist
        );

    
    __inline int __cdecl _vfscanf_l(
                               FILE*       const _Stream,
          char const* const _Format,
                              _locale_t   const _Locale,
                                      va_list           _ArgList
        )
    

#line 1062 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt\\stdio.h"
    {
        return __stdio_common_vfscanf(
            (*__local_stdio_scanf_options ()) ,
            _Stream, _Format, _Locale, _ArgList);
    }
    #line 1068 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt\\stdio.h"

    
    __inline int __cdecl vfscanf(
                               FILE*       const _Stream,
          char const* const _Format,
                                      va_list           _ArgList
        )
    

#line 1078 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt\\stdio.h"
    {
        return _vfscanf_l(_Stream, _Format, 0 , _ArgList);
    }
    #line 1082 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt\\stdio.h"

    
    __inline int __cdecl _vfscanf_s_l(
                               FILE*       const _Stream,
          char const* const _Format,
                              _locale_t   const _Locale,
                                      va_list           _ArgList
        )
    

#line 1093 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt\\stdio.h"
    {
        return __stdio_common_vfscanf(
            (*__local_stdio_scanf_options ()) | (1ULL << 0) ,
            _Stream, _Format, _Locale, _ArgList);
    }
    #line 1099 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt\\stdio.h"


    

        
        __inline int __cdecl vfscanf_s(
                                   FILE*       const _Stream,
              char const* const _Format,
                                          va_list           _ArgList
            )
    

#line 1112 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt\\stdio.h"
        {
            return _vfscanf_s_l(_Stream, _Format, 0 , _ArgList);
        }
    #line 1116 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt\\stdio.h"

    #line 1118 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt\\stdio.h"

    
    __inline int __cdecl _vscanf_l(
          char const* const _Format,
                              _locale_t   const _Locale,
                                      va_list           _ArgList
        )
    

#line 1128 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt\\stdio.h"
    {
        return _vfscanf_l((__acrt_iob_func(0)) , _Format, _Locale, _ArgList);
    }
    #line 1132 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt\\stdio.h"

    
    __inline int __cdecl vscanf(
          char const* const _Format,
                                      va_list           _ArgList
        )
    

#line 1141 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt\\stdio.h"
    {
        return _vfscanf_l((__acrt_iob_func(0)) , _Format, 0 , _ArgList);
    }
    #line 1145 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt\\stdio.h"

    
    __inline int __cdecl _vscanf_s_l(
          char const* const _Format,
                              _locale_t   const _Locale,
                                      va_list           _ArgList
        )
    

#line 1155 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt\\stdio.h"
    {
        return _vfscanf_s_l((__acrt_iob_func(0)) , _Format, _Locale, _ArgList);
    }
    #line 1159 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt\\stdio.h"

    

        
        __inline int __cdecl vscanf_s(
              char const* const _Format,
                                          va_list           _ArgList
            )
    

#line 1170 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt\\stdio.h"
        {
            return _vfscanf_s_l((__acrt_iob_func(0)) , _Format, 0 , _ArgList);
        }
    #line 1174 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt\\stdio.h"

    #line 1176 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt\\stdio.h"

     
    __inline int __cdecl _fscanf_l(
                                        FILE*       const _Stream,
          char const* const _Format,
                                       _locale_t   const _Locale,
        ...)
    

#line 1186 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt\\stdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Locale)>(), ((void)(__va_start(&_ArgList, _Locale))))) ;
        _Result = _vfscanf_l(_Stream, _Format, _Locale, _ArgList);
        ((void)(_ArgList = (va_list)0)) ;
        return _Result;
    }
    #line 1195 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt\\stdio.h"

     
    __inline int __cdecl fscanf(
                              FILE*       const _Stream,
          char const* const _Format,
        ...)
    

#line 1204 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt\\stdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Format)>(), ((void)(__va_start(&_ArgList, _Format))))) ;
        _Result = _vfscanf_l(_Stream, _Format, 0 , _ArgList);
        ((void)(_ArgList = (va_list)0)) ;
        return _Result;
    }
    #line 1213 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt\\stdio.h"

    
    __inline int __cdecl _fscanf_s_l(
                                          FILE*       const _Stream,
          char const* const _Format,
                                         _locale_t   const _Locale,
        ...)
    

#line 1223 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt\\stdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Locale)>(), ((void)(__va_start(&_ArgList, _Locale))))) ;
        _Result = _vfscanf_s_l(_Stream, _Format, _Locale, _ArgList);
        ((void)(_ArgList = (va_list)0)) ;
        return _Result;
    }
    #line 1232 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt\\stdio.h"

    

        
        __inline int __cdecl fscanf_s(
                                    FILE*       const _Stream,
              char const* const _Format,
            ...)
    

#line 1243 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt\\stdio.h"
        {
            int _Result;
            va_list _ArgList;
            ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Format)>(), ((void)(__va_start(&_ArgList, _Format))))) ;
            _Result = _vfscanf_s_l(_Stream, _Format, 0 , _ArgList);
            ((void)(_ArgList = (va_list)0)) ;
            return _Result;
        }
    #line 1252 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt\\stdio.h"

    #line 1254 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt\\stdio.h"

     
    __inline int __cdecl _scanf_l(
          char const* const _Format,
                                       _locale_t   const _Locale,
        ...)
    

#line 1263 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt\\stdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Locale)>(), ((void)(__va_start(&_ArgList, _Locale))))) ;
        _Result = _vfscanf_l((__acrt_iob_func(0)) , _Format, _Locale, _ArgList);
        ((void)(_ArgList = (va_list)0)) ;
        return _Result;
    }
    #line 1272 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt\\stdio.h"

     
    __inline int __cdecl scanf(
          char const* const _Format,
        ...)
    

#line 1280 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt\\stdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Format)>(), ((void)(__va_start(&_ArgList, _Format))))) ;
        _Result = _vfscanf_l((__acrt_iob_func(0)) , _Format, 0 , _ArgList);
        ((void)(_ArgList = (va_list)0)) ;
        return _Result;
    }
    #line 1289 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt\\stdio.h"

    
    __inline int __cdecl _scanf_s_l(
          char const* const _Format,
                                         _locale_t   const _Locale,
        ...)
    

#line 1298 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt\\stdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Locale)>(), ((void)(__va_start(&_ArgList, _Locale))))) ;
        _Result = _vfscanf_s_l((__acrt_iob_func(0)) , _Format, _Locale, _ArgList);
        ((void)(_ArgList = (va_list)0)) ;
        return _Result;
    }
    #line 1307 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt\\stdio.h"

    

        
        __inline int __cdecl scanf_s(
              char const* const _Format,
            ...)
    

#line 1317 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt\\stdio.h"
        {
            int _Result;
            va_list _ArgList;
            ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Format)>(), ((void)(__va_start(&_ArgList, _Format))))) ;
            _Result = _vfscanf_s_l((__acrt_iob_func(0)) , _Format, 0 , _ArgList);
            ((void)(_ArgList = (va_list)0)) ;
            return _Result;
        }
    #line 1326 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt\\stdio.h"

    #line 1328 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt\\stdio.h"



    //-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    //
    // Narrow Character Formatted Output Functions (String)
    //
    //-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    
    __declspec(dllimport) int __cdecl __stdio_common_vsprintf(
                                            unsigned __int64 _Options,
                char*            _Buffer,
                                            size_t           _BufferCount,
          char const*      _Format,
                                        _locale_t        _Locale,
                                                va_list          _ArgList
        );

    
    __declspec(dllimport) int __cdecl __stdio_common_vsprintf_s(
                                            unsigned __int64 _Options,
                    char*            _Buffer,
                                            size_t           _BufferCount,
          char const*      _Format,
                                        _locale_t        _Locale,
                                                va_list          _ArgList
        );

    
    __declspec(dllimport) int __cdecl __stdio_common_vsnprintf_s(
                                            unsigned __int64 _Options,
                char*            _Buffer,
                                            size_t           _BufferCount,
                                            size_t           _MaxCount,
          char const*      _Format,
                                        _locale_t        _Locale,
                                                va_list          _ArgList
        );

    
    __declspec(dllimport) int __cdecl __stdio_common_vsprintf_p(
                                            unsigned __int64 _Options,
                    char*            _Buffer,
                                            size_t           _BufferCount,
          char const*      _Format,
                                        _locale_t        _Locale,
                                                va_list          _ArgList
        );

    
     
    __inline int __cdecl _vsnprintf_l(
          char*       const _Buffer,
                                                 size_t      const _BufferCount,
               char const* const _Format,
                                             _locale_t   const _Locale,
                                                     va_list           _ArgList
        )
    

#line 1389 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt\\stdio.h"
    {
        int const _Result = __stdio_common_vsprintf(
            (*__local_stdio_printf_options()) | (1ULL << 0) ,
            _Buffer, _BufferCount, _Format, _Locale, _ArgList);

        return _Result < 0 ? -1 : _Result;
    }
    #line 1397 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt\\stdio.h"

    
    
    __inline int __cdecl _vsnprintf(
          char*       const _Buffer,
                                                size_t      const _BufferCount,
                        char const* const _Format,
                                                    va_list           _ArgList
        )
    

#line 1409 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt\\stdio.h"
    {
        #pragma warning(push)
        #pragma warning(disable: 4996) 
        return _vsnprintf_l(_Buffer, _BufferCount, _Format, 0 , _ArgList);
        #pragma warning(pop)
    }
    #line 1416 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt\\stdio.h"

    








#line 1427 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt\\stdio.h"

    
    
    __inline int __cdecl vsnprintf(
          char*       const _Buffer,
                                                      size_t      const _BufferCount,
                              char const* const _Format,
                                                          va_list           _ArgList
        )
    

#line 1439 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt\\stdio.h"
    {
        int const _Result = __stdio_common_vsprintf(
            (*__local_stdio_printf_options()) | (1ULL << 1) ,
            _Buffer, _BufferCount, _Format, 0 , _ArgList);

        return _Result < 0 ? -1 : _Result;
    }
    #line 1447 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt\\stdio.h"

    
     
    __inline int __cdecl _vsprintf_l(
          char*       const _Buffer,
                                   char const* const _Format,
                                 _locale_t   const _Locale,
                                         va_list           _ArgList
        )
    

#line 1459 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt\\stdio.h"
    {
        #pragma warning(push)
        #pragma warning(disable: 4996) 
        return _vsnprintf_l(_Buffer, (size_t)-1, _Format, _Locale, _ArgList);
        #pragma warning(pop)
    }
    #line 1466 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt\\stdio.h"

    
     
    __inline int __cdecl vsprintf(
          char*       const _Buffer,
             char const* const _Format,
                                         va_list           _ArgList
        )
    

#line 1477 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt\\stdio.h"
    {
        #pragma warning(push)
        #pragma warning(disable: 4996) 
        return _vsnprintf_l(_Buffer, (size_t)-1, _Format, 0 , _ArgList);
        #pragma warning(pop)
    }
    #line 1484 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt\\stdio.h"

    
    
    __inline int __cdecl _vsprintf_s_l(
          char*       const _Buffer,
                                                  size_t      const _BufferCount,
                char const* const _Format,
                                              _locale_t   const _Locale,
                                                      va_list           _ArgList
        )
    

#line 1497 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt\\stdio.h"
    {
        int const _Result = __stdio_common_vsprintf_s(
            (*__local_stdio_printf_options()) ,
            _Buffer, _BufferCount, _Format, _Locale, _ArgList);

        return _Result < 0 ? -1 : _Result;
    }
    #line 1505 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt\\stdio.h"

    

        
        
        __inline int __cdecl vsprintf_s(
              char*       const _Buffer,
                                                      size_t      const _BufferCount,
                              char const* const _Format,
                                                          va_list           _ArgList
            )
    

#line 1519 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt\\stdio.h"
        {
            return _vsprintf_s_l(_Buffer, _BufferCount, _Format, 0 , _ArgList);
        }
    #line 1523 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt\\stdio.h"

        extern "C++" { template <size_t _Size> inline int __cdecl vsprintf_s(char (&_Buffer)[_Size], char const* _Format, va_list _ArgList) throw() { return vsprintf_s(_Buffer, _Size, _Format, _ArgList); } }







    #line 1533 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt\\stdio.h"

    
    
    __inline int __cdecl _vsprintf_p_l(
          char*       const _Buffer,
                                                  size_t      const _BufferCount,
                char const* const _Format,
                                              _locale_t   const _Locale,
                                                      va_list           _ArgList
        )
    

#line 1546 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt\\stdio.h"
    {
        int const _Result = __stdio_common_vsprintf_p(
            (*__local_stdio_printf_options()) ,
            _Buffer, _BufferCount, _Format, _Locale, _ArgList);

        return _Result < 0 ? -1 : _Result;
    }
    #line 1554 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt\\stdio.h"

    
    
    __inline int __cdecl _vsprintf_p(
          char*       const _Buffer,
                                                  size_t      const _BufferCount,
                          char const* const _Format,
                                                      va_list           _ArgList
        )
    

#line 1566 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt\\stdio.h"
    {
        return _vsprintf_p_l(_Buffer, _BufferCount, _Format, 0 , _ArgList);
    }
    #line 1570 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt\\stdio.h"

    
    
    __inline int __cdecl _vsnprintf_s_l(
          char*       const _Buffer,
                                                      size_t      const _BufferCount,
                                                      size_t      const _MaxCount,
                    char const* const _Format,
                                                  _locale_t   const _Locale,
                                                          va_list          _ArgList
        )
    

#line 1584 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt\\stdio.h"
    {
        int const _Result = __stdio_common_vsnprintf_s(
            (*__local_stdio_printf_options()) ,
            _Buffer, _BufferCount, _MaxCount, _Format, _Locale, _ArgList);

        return _Result < 0 ? -1 : _Result;
    }
    #line 1592 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt\\stdio.h"

    
    
    __inline int __cdecl _vsnprintf_s(
          char*       const _Buffer,
                                                      size_t      const _BufferCount,
                                                      size_t      const _MaxCount,
                              char const* const _Format,
                                                          va_list           _ArgList
        )
    

#line 1605 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt\\stdio.h"
    {
        return _vsnprintf_s_l(_Buffer, _BufferCount, _MaxCount, _Format, 0 , _ArgList);
    }
    #line 1609 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt\\stdio.h"

    extern "C++" { template <size_t _Size> inline int __cdecl _vsnprintf_s(char (&_Buffer)[_Size], size_t _BufferCount, char const* _Format, va_list _ArgList) throw() { return _vsnprintf_s(_Buffer, _Size, _BufferCount, _Format, _ArgList); } }








    

        
        
        __inline int __cdecl vsnprintf_s(
              char*       const _Buffer,
                                                          size_t      const _BufferCount,
                                                          size_t      const _MaxCount,
                                  char const* const _Format,
                                                              va_list           _ArgList
            )
    

#line 1633 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt\\stdio.h"
        {
            return _vsnprintf_s_l(_Buffer, _BufferCount, _MaxCount, _Format, 0 , _ArgList);
        }
    #line 1637 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt\\stdio.h"

        extern "C++" { template <size_t _Size> inline int __cdecl vsnprintf_s(char (&_Buffer)[_Size], size_t _BufferCount, char const* _Format, va_list _ArgList) throw() { return vsnprintf_s(_Buffer, _Size, _BufferCount, _Format, _ArgList); } }








    #line 1648 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt\\stdio.h"

    
    __inline int __cdecl _vscprintf_l(
          char const* const _Format,
                                        _locale_t   const _Locale,
                                                va_list           _ArgList
        )
    

#line 1658 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt\\stdio.h"
    {
        int const _Result = __stdio_common_vsprintf(
            (*__local_stdio_printf_options()) | (1ULL << 1) ,
            0 , 0, _Format, _Locale, _ArgList);

        return _Result < 0 ? -1 : _Result;
    }
    #line 1666 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt\\stdio.h"

    
    __inline int __cdecl _vscprintf(
          char const* const _Format,
                                      va_list           _ArgList
        )
    

#line 1675 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt\\stdio.h"
    {
        return _vscprintf_l(_Format, 0 , _ArgList);
    }
    #line 1679 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt\\stdio.h"

    
    __inline int __cdecl _vscprintf_p_l(
          char const* const _Format,
                                        _locale_t   const _Locale,
                                                va_list           _ArgList
        )
    

#line 1689 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt\\stdio.h"
    {
        int const _Result = __stdio_common_vsprintf_p(
            (*__local_stdio_printf_options()) | (1ULL << 1) ,
            0 , 0, _Format, _Locale, _ArgList);

        return _Result < 0 ? -1 : _Result;
    }
    #line 1697 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt\\stdio.h"

    
    __inline int __cdecl _vscprintf_p(
          char const* const _Format,
                                      va_list           _ArgList
        )
    

#line 1706 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt\\stdio.h"
    {
        return _vscprintf_p_l(_Format, 0 , _ArgList);
    }
    #line 1710 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt\\stdio.h"

    
    __inline int __cdecl _vsnprintf_c_l(
                  char*       const _Buffer,
                                            size_t      const _BufferCount,
          char const* const _Format,
                                        _locale_t   const _Locale,
                                                va_list           _ArgList
        )
    

#line 1722 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt\\stdio.h"
    {
        int const _Result = __stdio_common_vsprintf(
            (*__local_stdio_printf_options()) ,
            _Buffer, _BufferCount, _Format, _Locale, _ArgList);

        return _Result < 0 ? -1 : _Result;
    }
    #line 1730 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt\\stdio.h"

    
    
    __inline int __cdecl _vsnprintf_c(
         char*       const _Buffer,
                                   size_t      const _BufferCount,
           char const* const _Format,
                                       va_list           _ArgList
        )
    

#line 1742 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt\\stdio.h"
    {
        return _vsnprintf_c_l(_Buffer, _BufferCount, _Format, 0 , _ArgList);
    }
    #line 1746 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt\\stdio.h"

    
     
    __inline int __cdecl _sprintf_l(
                 char*       const _Buffer,
          char const* const _Format,
                                        _locale_t   const _Locale,
        ...)
    

#line 1757 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt\\stdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Locale)>(), ((void)(__va_start(&_ArgList, _Locale))))) ;

        #pragma warning(push)
        #pragma warning(disable: 4996) 
        _Result = _vsprintf_l(_Buffer, _Format, _Locale, _ArgList);
        #pragma warning(pop)

        ((void)(_ArgList = (va_list)0)) ;
        return _Result;
    }
    #line 1771 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt\\stdio.h"

    
    
    __inline int __cdecl sprintf(
          char*       const _Buffer,
             char const* const _Format,
        ...)
    

#line 1781 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt\\stdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Format)>(), ((void)(__va_start(&_ArgList, _Format))))) ;

        #pragma warning(push)
        #pragma warning(disable: 4996) 
        _Result = _vsprintf_l(_Buffer, _Format, 0 , _ArgList);
        #pragma warning(pop)

        ((void)(_ArgList = (va_list)0)) ;
        return _Result;
    }
    #line 1795 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt\\stdio.h"

    #pragma warning(push)
    #pragma warning(disable: 4996)
    #pragma warning(disable: 28719) 
    #pragma warning(disable: 28726) 
    int __cdecl sprintf( char *_Buffer, char const* _Format, ...); int __cdecl vsprintf( char *_Buffer, char const* _Format, va_list _Args);





    #pragma warning(pop)

    
    
    __inline int __cdecl _sprintf_s_l(
          char*       const _Buffer,
                                                  size_t      const _BufferCount,
                char const* const _Format,
                                              _locale_t   const _Locale,
        ...)
    

#line 1819 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt\\stdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Locale)>(), ((void)(__va_start(&_ArgList, _Locale))))) ;
        _Result = _vsprintf_s_l(_Buffer, _BufferCount, _Format, _Locale, _ArgList);
        ((void)(_ArgList = (va_list)0)) ;
        return _Result;
    }
    #line 1828 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt\\stdio.h"

    

        
        
        __inline int __cdecl sprintf_s(
              char*       const _Buffer,
                                                      size_t      const _BufferCount,
                              char const* const _Format,
            ...)
    

#line 1841 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt\\stdio.h"
        {
            int _Result;
            va_list _ArgList;
            ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Format)>(), ((void)(__va_start(&_ArgList, _Format))))) ;
            _Result = _vsprintf_s_l(_Buffer, _BufferCount, _Format, 0 , _ArgList);
            ((void)(_ArgList = (va_list)0)) ;
            return _Result;
        }
    #line 1850 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt\\stdio.h"

    #line 1852 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt\\stdio.h"

    extern "C++" { __pragma(warning(push)); __pragma(warning(disable: 4793)); template <size_t _Size> inline int __cdecl sprintf_s(char (&_Buffer)[_Size], char const* _Format, ...) throw() { va_list _ArgList; ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Format)>(), ((void)(__va_start(&_ArgList, _Format))))); return vsprintf_s(_Buffer, _Size, _Format, _ArgList); } __pragma(warning(pop)); }






    
    
    __inline int __cdecl _sprintf_p_l(
          char*       const _Buffer,
                                                  size_t      const _BufferCount,
                char const* const _Format,
                                              _locale_t   const _Locale,
        ...)
    

#line 1871 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt\\stdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Locale)>(), ((void)(__va_start(&_ArgList, _Locale))))) ;
        _Result = _vsprintf_p_l(_Buffer, _BufferCount, _Format, _Locale, _ArgList);
        ((void)(_ArgList = (va_list)0)) ;
        return _Result;
    }
    #line 1880 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt\\stdio.h"

    
    
    __inline int __cdecl _sprintf_p(
          char*       const _Buffer,
                                                  size_t      const _BufferCount,
                          char const* const _Format,
        ...)
    

#line 1891 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt\\stdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Format)>(), ((void)(__va_start(&_ArgList, _Format))))) ;
        _Result = _vsprintf_p_l(_Buffer, _BufferCount, _Format, 0 , _ArgList);
        ((void)(_ArgList = (va_list)0)) ;
        return _Result;
    }
    #line 1900 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt\\stdio.h"

    
     
    __inline int __cdecl _snprintf_l(
          char*       const _Buffer,
                                                 size_t      const _BufferCount,
               char const* const _Format,
                                             _locale_t   const _Locale,
        ...)
    

#line 1912 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt\\stdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Locale)>(), ((void)(__va_start(&_ArgList, _Locale))))) ;

        #pragma warning(push)
        #pragma warning(disable: 4996) 
        _Result = _vsnprintf_l(_Buffer, _BufferCount, _Format, _Locale, _ArgList);
        #pragma warning(pop)

        ((void)(_ArgList = (va_list)0)) ;
        return _Result;
    }
    #line 1926 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt\\stdio.h"

    








#line 1937 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt\\stdio.h"

    
    
    __inline int __cdecl snprintf(
          char*       const _Buffer,
                                                      size_t      const _BufferCount,
                              char const* const _Format,
        ...)
    

#line 1948 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt\\stdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Format)>(), ((void)(__va_start(&_ArgList, _Format))))) ;
    #pragma warning(suppress:28719)    
        _Result = vsnprintf(_Buffer, _BufferCount, _Format, _ArgList);
        ((void)(_ArgList = (va_list)0)) ;
        return _Result;
    }
    #line 1958 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt\\stdio.h"

    
    
    __inline int __cdecl _snprintf(
          char*       const _Buffer,
                                                 size_t      const _BufferCount,
                         char const* const _Format,
        ...)
    

#line 1969 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt\\stdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Format)>(), ((void)(__va_start(&_ArgList, _Format))))) ;
    #pragma warning(suppress:28719)    
        _Result = _vsnprintf(_Buffer, _BufferCount, _Format, _ArgList);
        ((void)(_ArgList = (va_list)0)) ;
        return _Result;
    }
    #line 1979 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt\\stdio.h"

    int __cdecl _snprintf( char *_Buffer, size_t _BufferCount, char const* _Format, ...); int __cdecl _vsnprintf( char *_Buffer, size_t _BufferCount, char const* _Format, va_list _Args);








    
    
    __inline int __cdecl _snprintf_c_l(
                  char*       const _Buffer,
                                            size_t      const _BufferCount,
          char const* const _Format,
                                        _locale_t   const _Locale,
        ...)
    

#line 2000 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt\\stdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Locale)>(), ((void)(__va_start(&_ArgList, _Locale))))) ;
        _Result = _vsnprintf_c_l(_Buffer, _BufferCount, _Format, _Locale, _ArgList);
        ((void)(_ArgList = (va_list)0)) ;
        return _Result;
    }
    #line 2009 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt\\stdio.h"

    
    
    __inline int __cdecl _snprintf_c(
         char*       const _Buffer,
                                   size_t      const _BufferCount,
           char const* const _Format,
        ...)
    

#line 2020 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt\\stdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Format)>(), ((void)(__va_start(&_ArgList, _Format))))) ;
        _Result = _vsnprintf_c_l(_Buffer, _BufferCount, _Format, 0 , _ArgList);
        ((void)(_ArgList = (va_list)0)) ;
        return _Result;
    }
    #line 2029 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt\\stdio.h"

    
    
    __inline int __cdecl _snprintf_s_l(
          char*       const _Buffer,
                                                      size_t      const _BufferCount,
                                                      size_t      const _MaxCount,
                    char const* const _Format,
                                                  _locale_t   const _Locale,
        ...)
    

#line 2042 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt\\stdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Locale)>(), ((void)(__va_start(&_ArgList, _Locale))))) ;
        _Result = _vsnprintf_s_l(_Buffer, _BufferCount, _MaxCount, _Format, _Locale, _ArgList);
        ((void)(_ArgList = (va_list)0)) ;
        return _Result;
    }
    #line 2051 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt\\stdio.h"

    
    
    __inline int __cdecl _snprintf_s(
          char*       const _Buffer,
                                                      size_t      const _BufferCount,
                                                      size_t      const _MaxCount,
                              char const* const _Format,
        ...)
    

#line 2063 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt\\stdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Format)>(), ((void)(__va_start(&_ArgList, _Format))))) ;
        _Result = _vsnprintf_s_l(_Buffer, _BufferCount, _MaxCount, _Format, 0 , _ArgList);
        ((void)(_ArgList = (va_list)0)) ;
        return _Result;
    }
    #line 2072 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt\\stdio.h"

    extern "C++" { __pragma(warning(push)); __pragma(warning(disable: 4793)); template <size_t _Size> inline int __cdecl _snprintf_s(char (&_Buffer)[_Size], size_t _BufferCount, char const* _Format, ...) throw() { va_list _ArgList; ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Format)>(), ((void)(__va_start(&_ArgList, _Format))))); return _vsnprintf_s(_Buffer, _Size, _BufferCount, _Format, _ArgList); } __pragma(warning(pop)); }







    
    __inline int __cdecl _scprintf_l(
          char const* const _Format,
                                        _locale_t   const _Locale,
        ...)
    

#line 2089 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt\\stdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Locale)>(), ((void)(__va_start(&_ArgList, _Locale))))) ;
        _Result = _vscprintf_l(_Format, _Locale, _ArgList);
        ((void)(_ArgList = (va_list)0)) ;
        return _Result;
    }
    #line 2098 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt\\stdio.h"

    
    __inline int __cdecl _scprintf(
          char const* const _Format,
        ...)
    

#line 2106 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt\\stdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Format)>(), ((void)(__va_start(&_ArgList, _Format))))) ;
        _Result = _vscprintf_l(_Format, 0 , _ArgList);
        ((void)(_ArgList = (va_list)0)) ;
        return _Result;
    }
    #line 2115 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt\\stdio.h"

    
    __inline int __cdecl _scprintf_p_l(
          char const* const _Format,
                                        _locale_t   const _Locale,
        ...)
    

#line 2124 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt\\stdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Locale)>(), ((void)(__va_start(&_ArgList, _Locale))))) ;
        _Result = _vscprintf_p_l(_Format, _Locale, _ArgList);
        ((void)(_ArgList = (va_list)0)) ;
        return _Result;
    }
    #line 2133 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt\\stdio.h"

    
    __inline int __cdecl _scprintf_p(
          char const* const _Format,
        ...)
    

#line 2141 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt\\stdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Format)>(), ((void)(__va_start(&_ArgList, _Format))))) ;
        _Result = _vscprintf_p(_Format, _ArgList);
        ((void)(_ArgList = (va_list)0)) ;
        return _Result;
    }
    #line 2150 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt\\stdio.h"

    //-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    //
    // Narrow Character Formatted Input Functions (String)
    //
    //-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    __declspec(dllimport) int __cdecl __stdio_common_vsscanf(
                                           unsigned __int64 _Options,
                char const*      _Buffer,
                                           size_t           _BufferCount,
          char const*      _Format,
                                       _locale_t        _Locale,
                                               va_list          _ArgList
        );

    
    __inline int __cdecl _vsscanf_l(
                                char const* const _Buffer,
          char const* const _Format,
                              _locale_t   const _Locale,
                                      va_list           _ArgList
        )
    

#line 2175 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt\\stdio.h"
    {
        return __stdio_common_vsscanf(
            (*__local_stdio_scanf_options ()) ,
            _Buffer, (size_t)-1, _Format, _Locale, _ArgList);
    }
    #line 2181 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt\\stdio.h"

    
    __inline int __cdecl vsscanf(
                                char const* const _Buffer,
          char const* const _Format,
                                      va_list           _ArgList
        )
    

#line 2191 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt\\stdio.h"
    {
        return _vsscanf_l(_Buffer, _Format, 0 , _ArgList);
    }
    #line 2195 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt\\stdio.h"

    
    __inline int __cdecl _vsscanf_s_l(
                                char const* const _Buffer,
          char const* const _Format,
                              _locale_t   const _Locale,
                                      va_list           _ArgList
        )
    

#line 2206 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt\\stdio.h"
    {
        return __stdio_common_vsscanf(
            (*__local_stdio_scanf_options ()) | (1ULL << 0) ,
            _Buffer, (size_t)-1, _Format, _Locale, _ArgList);
    }
    #line 2212 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt\\stdio.h"

    

        #pragma warning(push)
        #pragma warning(disable:6530)

        
        __inline int __cdecl vsscanf_s(
                                    char const* const _Buffer,
              char const* const _Format,
                                          va_list           _ArgList
            )
    

#line 2227 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt\\stdio.h"
        {
            return _vsscanf_s_l(_Buffer, _Format, 0 , _ArgList);
        }
    #line 2231 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt\\stdio.h"

        extern "C++" { template <size_t _Size> inline int __cdecl vsscanf_s(char const (&_Buffer)[_Size], char const* _Format, va_list _ArgList) throw() { return vsscanf_s(_Buffer, _Size, _Format, _ArgList); } }






        #pragma warning(pop)

    #line 2242 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt\\stdio.h"

     
    __inline int __cdecl _sscanf_l(
                                         char const* const _Buffer,
          char const* const _Format,
                                       _locale_t   const _Locale,
        ...)
    

#line 2252 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt\\stdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Locale)>(), ((void)(__va_start(&_ArgList, _Locale))))) ;
        _Result = _vsscanf_l(_Buffer, _Format, _Locale, _ArgList);
        ((void)(_ArgList = (va_list)0)) ;
        return _Result;
    }
    #line 2261 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt\\stdio.h"

     
    __inline int __cdecl sscanf(
                               char const* const _Buffer,
          char const* const _Format,
        ...)
    

#line 2270 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt\\stdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Format)>(), ((void)(__va_start(&_ArgList, _Format))))) ;
        _Result = _vsscanf_l(_Buffer, _Format, 0 , _ArgList);
        ((void)(_ArgList = (va_list)0)) ;
        return _Result;
    }
    #line 2279 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt\\stdio.h"

    
    __inline int __cdecl _sscanf_s_l(
                                           char const* const _Buffer,
          char const* const _Format,
                                         _locale_t   const _Locale,
        ...)
    

#line 2289 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt\\stdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Locale)>(), ((void)(__va_start(&_ArgList, _Locale))))) ;
        _Result = _vsscanf_s_l(_Buffer, _Format, _Locale, _ArgList);
        ((void)(_ArgList = (va_list)0)) ;
        return _Result;
    }
    #line 2298 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt\\stdio.h"

    

        
        __inline int __cdecl sscanf_s(
                                     char const* const _Buffer,
              char const* const _Format,
            ...)
    

#line 2309 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt\\stdio.h"
        {
            int _Result;
            va_list _ArgList;
            ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Format)>(), ((void)(__va_start(&_ArgList, _Format))))) ;

            #pragma warning(push)
            #pragma warning(disable: 4996) 
            _Result = vsscanf_s(_Buffer, _Format, _ArgList);
            #pragma warning(pop)

            ((void)(_ArgList = (va_list)0)) ;
            return _Result;
        }
    #line 2323 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt\\stdio.h"

    #line 2325 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt\\stdio.h"

    #pragma warning(push)
    #pragma warning(disable:6530)

     
    __inline int __cdecl _snscanf_l(
          char const* const _Buffer,
                                           size_t      const _BufferCount,
          char const* const _Format,
                                       _locale_t   const _Locale,
        ...)
    

#line 2339 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt\\stdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Locale)>(), ((void)(__va_start(&_ArgList, _Locale))))) ;

        _Result = __stdio_common_vsscanf(
            (*__local_stdio_scanf_options ()) ,
            _Buffer, _BufferCount, _Format, _Locale, _ArgList);

        ((void)(_ArgList = (va_list)0)) ;
        return _Result;
    }
    #line 2352 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt\\stdio.h"

     
    __inline int __cdecl _snscanf(
          char const* const _Buffer,
                                           size_t      const _BufferCount,
                    char const* const _Format,
        ...)
    

#line 2362 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt\\stdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Format)>(), ((void)(__va_start(&_ArgList, _Format))))) ;

        _Result = __stdio_common_vsscanf(
            (*__local_stdio_scanf_options ()) ,
            _Buffer, _BufferCount, _Format, 0 , _ArgList);

        ((void)(_ArgList = (va_list)0)) ;
        return _Result;
    }
    #line 2375 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt\\stdio.h"


    
    __inline int __cdecl _snscanf_s_l(
            char const* const _Buffer,
                                             size_t      const _BufferCount,
          char const* const _Format,
                                         _locale_t   const _Locale,
        ...)
    

#line 2387 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt\\stdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Locale)>(), ((void)(__va_start(&_ArgList, _Locale))))) ;

        _Result = __stdio_common_vsscanf(
            (*__local_stdio_scanf_options ()) | (1ULL << 0) ,
            _Buffer, _BufferCount, _Format, _Locale, _ArgList);

        ((void)(_ArgList = (va_list)0)) ;
        return _Result;
    }
    #line 2400 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt\\stdio.h"

    
    __inline int __cdecl _snscanf_s(
          char const* const _Buffer,
                                           size_t      const _BufferCount,
                  char const* const _Format,
        ...)
    

#line 2410 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt\\stdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Format)>(), ((void)(__va_start(&_ArgList, _Format))))) ;

        _Result = __stdio_common_vsscanf(
            (*__local_stdio_scanf_options ()) | (1ULL << 0) ,
            _Buffer, _BufferCount, _Format, 0 , _ArgList);

        ((void)(_ArgList = (va_list)0)) ;
        return _Result;
    }
    #line 2423 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt\\stdio.h"

    #pragma warning(pop)

    

#line 2429 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt\\stdio.h"



    //-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    //
    // Non-ANSI Names for Compatibility
    //
    //-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    

        

        


#line 2445 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt\\stdio.h"

        __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_tempnam" ". See online help for details."))
        __declspec(dllimport) char* __cdecl tempnam(
             char const* _Directory,
             char const* _FilePrefix
            );

        

#line 2455 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt\\stdio.h"

         __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_fcloseall" ". See online help for details.")) __declspec(dllimport) int   __cdecl fcloseall(void);
             __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_fdopen" ". See online help for details."))    __declspec(dllimport) FILE* __cdecl fdopen( int _FileHandle,  char const* _Format);
         __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_fgetchar" ". See online help for details."))  __declspec(dllimport) int   __cdecl fgetchar(void);
             __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_fileno" ". See online help for details."))    __declspec(dllimport) int   __cdecl fileno( FILE* _Stream);
         __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_flushall" ". See online help for details."))  __declspec(dllimport) int   __cdecl flushall(void);
         __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_fputchar" ". See online help for details."))  __declspec(dllimport) int   __cdecl fputchar( int _Ch);
             __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_getw" ". See online help for details."))      __declspec(dllimport) int   __cdecl getw( FILE* _Stream);
         __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_putw" ". See online help for details."))      __declspec(dllimport) int   __cdecl putw( int _Ch,  FILE* _Stream);
             __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_rmtmp" ". See online help for details."))     __declspec(dllimport) int   __cdecl rmtmp(void);

    #line 2467 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt\\stdio.h"
#line 2468 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt\\stdio.h"



} __pragma(pack(pop))
#line 2473 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt\\stdio.h"
#line 5 "C:\\Users\\serpentiem\\source\\repos\\ddmk\\Core\\Includes.h"
#line 1 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt\\stdlib.h"
//
// stdlib.h
//
//      Copyright (c) Microsoft Corporation. All rights reserved.
//
// The C Standard Library <stdlib.h> header.
//
#pragma once




#line 1 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt\\corecrt_malloc.h"
//
// corecrt_malloc.h
//
//      Copyright (c) Microsoft Corporation. All rights reserved.
//
// The memory allocation library.  These pieces of the allocation library are
// shared by both <stdlib.h> and <malloc.h>.
//
#pragma once



__pragma(pack(push, 8)) extern "C" {





































#line 52 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt\\corecrt_malloc.h"

  
__declspec(dllimport) __declspec(allocator) __declspec(restrict)
void* __cdecl _calloc_base(
     size_t _Count,
     size_t _Size
    );

  
__declspec(dllimport)  __declspec(allocator) __declspec(restrict) 
void* __cdecl calloc(
     __declspec(guard(overflow)) size_t _Count,
     __declspec(guard(overflow)) size_t _Size
    );


__declspec(dllimport) int __cdecl _callnewh(
     size_t _Size
    );

  
__declspec(dllimport) __declspec(allocator) 
void* __cdecl _expand(
               void*  _Block,
     __declspec(guard(overflow)) size_t _Size
    );

__declspec(dllimport)
void __cdecl _free_base(
      void* _Block
    );

__declspec(dllimport) 
void __cdecl free(
      void* _Block
    );

  
__declspec(dllimport) __declspec(allocator) __declspec(restrict)
void* __cdecl _malloc_base(
     size_t _Size
    );

  
__declspec(dllimport) __declspec(allocator)  __declspec(restrict) 
void* __cdecl malloc(
     __declspec(guard(overflow)) size_t _Size
    );


__declspec(dllimport)
size_t __cdecl _msize_base(
     void* _Block
    );


__declspec(dllimport) 
size_t __cdecl _msize(
     void* _Block
    );

   
__declspec(dllimport) __declspec(allocator) __declspec(restrict)
void* __cdecl _realloc_base(
       void*  _Block,
                                size_t _Size
    );

   
__declspec(dllimport) __declspec(allocator) __declspec(restrict) 
void* __cdecl realloc(
      void*  _Block,
     __declspec(guard(overflow))        size_t _Size
    );

   
__declspec(dllimport) __declspec(allocator) __declspec(restrict)
void* __cdecl _recalloc_base(
      void*  _Block,
                               size_t _Count,
                               size_t _Size
    );

   
__declspec(dllimport) __declspec(allocator) __declspec(restrict)
void* __cdecl _recalloc(
      void*  _Block,
     __declspec(guard(overflow))        size_t _Count,
     __declspec(guard(overflow))        size_t _Size
    );

__declspec(dllimport)
void __cdecl _aligned_free(
      void* _Block
    );

  
__declspec(dllimport) __declspec(allocator) __declspec(restrict)
void* __cdecl _aligned_malloc(
     __declspec(guard(overflow)) size_t _Size,
                        size_t _Alignment
    );

  
__declspec(dllimport) __declspec(allocator) __declspec(restrict)
void* __cdecl _aligned_offset_malloc(
     __declspec(guard(overflow)) size_t _Size,
                        size_t _Alignment,
                        size_t _Offset
    );


__declspec(dllimport)
size_t __cdecl _aligned_msize(
     void*  _Block,
              size_t _Alignment,
              size_t _Offset
    );

   
__declspec(dllimport) __declspec(allocator) __declspec(restrict)
void* __cdecl _aligned_offset_realloc(
      void*  _Block,
     __declspec(guard(overflow))        size_t _Size,
                               size_t _Alignment,
                               size_t _Offset
    );

   
__declspec(dllimport) __declspec(allocator) __declspec(restrict)
void* __cdecl _aligned_offset_recalloc(
      void*  _Block,
     __declspec(guard(overflow))        size_t _Count,
     __declspec(guard(overflow))        size_t _Size,
                               size_t _Alignment,
                               size_t _Offset
    );

   
__declspec(dllimport) __declspec(allocator) __declspec(restrict)
void* __cdecl _aligned_realloc(
      void*  _Block,
     __declspec(guard(overflow))        size_t _Size,
                               size_t _Alignment
    );

   
__declspec(dllimport) __declspec(allocator) __declspec(restrict)
void* __cdecl _aligned_recalloc(
      void*  _Block,
     __declspec(guard(overflow))        size_t _Count,
     __declspec(guard(overflow))        size_t _Size,
                               size_t _Alignment
    );


















#line 225 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt\\corecrt_malloc.h"



} __pragma(pack(pop))
#line 14 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt\\stdlib.h"
#line 1 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt\\corecrt_search.h"
//
// corecrt_search.h
//
//      Copyright (c) Microsoft Corporation. All rights reserved.
//
// Declarations of functions for sorting and searching.  These declarations are
// split out so that they may be included by both <stdlib.h> and <search.h>.
// <stdlib.h> does not include <search.h> to avoid introducing conflicts with
// other user headers named <search.h>.
//
#pragma once


#line 1 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt\\stddef.h"
//
// stddef.h
//
//      Copyright (c) Microsoft Corporation. All rights reserved.
//
// The C <stddef.h> Standard Library header.
//
#pragma once





__pragma(pack(push, 8)) extern "C" {




    namespace std
    {
        typedef decltype(__nullptr) nullptr_t;
    }

    using ::std::nullptr_t;
#line 26 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt\\stddef.h"





    __declspec(dllimport) int* __cdecl _errno(void);
    

    __declspec(dllimport) errno_t __cdecl _set_errno( int _Value);
    __declspec(dllimport) errno_t __cdecl _get_errno( int* _Value);

#line 38 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt\\stddef.h"









#line 48 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt\\stddef.h"
    
#line 50 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt\\stddef.h"

__declspec(dllimport) extern unsigned long  __cdecl __threadid(void);

__declspec(dllimport) extern uintptr_t __cdecl __threadhandle(void);



} __pragma(pack(pop))
#line 59 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt\\stddef.h"
#line 15 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt\\corecrt_search.h"

__pragma(pack(push, 8)) extern "C" {


    typedef int (__cdecl* _CoreCrtSecureSearchSortCompareFunction)(void*, void const*, void const*);
    typedef int (__cdecl* _CoreCrtNonSecureSearchSortCompareFunction)(void const*, void const*);




    
    __declspec(dllimport) void* __cdecl bsearch_s(
                                                       void const* _Key,
         void const* _Base,
                                                       rsize_t     _NumOfElements,
                                                       rsize_t     _SizeOfElements,
                           _CoreCrtSecureSearchSortCompareFunction _CompareFunction,
                                                   void*       _Context
        );

    __declspec(dllimport) void __cdecl qsort_s(
         void*   _Base,
                                                            rsize_t _NumOfElements,
                                                            rsize_t _SizeOfElements,
                            _CoreCrtSecureSearchSortCompareFunction _CompareFunction,
                                                        void*   _Context
        );

#line 44 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt\\corecrt_search.h"




__declspec(dllimport) void* __cdecl bsearch(
                                                   void const* _Key,
     void const* _Base,
                                                   size_t      _NumOfElements,
                                                   size_t      _SizeOfElements,
                    _CoreCrtNonSecureSearchSortCompareFunction _CompareFunction
    );

__declspec(dllimport) void __cdecl qsort(
     void*  _Base,
                                                        size_t _NumOfElements,
                                                        size_t _SizeOfElements,
                    _CoreCrtNonSecureSearchSortCompareFunction _CompareFunction
    );


__declspec(dllimport) void* __cdecl _lfind_s(
                                                      void const*   _Key,
     void const*   _Base,
                                                   unsigned int* _NumOfElements,
                                                      size_t        _SizeOfElements,
                            _CoreCrtSecureSearchSortCompareFunction _CompareFunction,
                                                      void*         _Context
    );


__declspec(dllimport) void* __cdecl _lfind(
                                                      void const*   _Key,
     void const*   _Base,
                                                   unsigned int* _NumOfElements,
                                                      unsigned int  _SizeOfElements,
                         _CoreCrtNonSecureSearchSortCompareFunction _CompareFunction
    );


__declspec(dllimport) void* __cdecl _lsearch_s(
                                                            void const*   _Key,
     void*         _Base,
                                                         unsigned int* _NumOfElements,
                                                            size_t        _SizeOfElements,
                                  _CoreCrtSecureSearchSortCompareFunction _CompareFunction,
                                                            void*         _Context
    );


__declspec(dllimport) void* __cdecl _lsearch(
                                                            void const*   _Key,
     void*         _Base,
                                                         unsigned int* _NumOfElements,
                                                            unsigned int  _SizeOfElements,
                               _CoreCrtNonSecureSearchSortCompareFunction _CompareFunction
    );



// Managed search routines
















































































#line 185 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt\\corecrt_search.h"





     __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_lfind" ". See online help for details."))
    __declspec(dllimport) void* __cdecl lfind(
                                                          void const*   _Key,
         void const*   _Base,
                                                       unsigned int* _NumOfElements,
                                                          unsigned int  _SizeOfElements,
                             _CoreCrtNonSecureSearchSortCompareFunction _CompareFunction
        );

     __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_lsearch" ". See online help for details."))
    __declspec(dllimport) void* __cdecl lsearch(
                                                               void const*   _Key,
         void*         _Base,
                                                            unsigned int* _NumOfElements,
                                                               unsigned int  _SizeOfElements,
                                  _CoreCrtNonSecureSearchSortCompareFunction _CompareFunction
        );

#line 209 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt\\corecrt_search.h"



} __pragma(pack(pop))
#line 15 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt\\stdlib.h"
#line 1 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt\\corecrt_wstdlib.h"
//
// corecrt_wstdlib.h
//
//      Copyright (c) Microsoft Corporation. All rights reserved.
//
// This file declares the wide character (wchar_t) C Standard Library functions
// that are declared by both <stdlib.h> and <wchar.h>.
//
#pragma once



__pragma(pack(push, 8)) extern "C" {



// Maximum number of elements, including null terminator (and negative sign
// where appropriate), needed for integer-to-string conversions for several
// bases and integer types.




























    
    
    __declspec(dllimport) errno_t __cdecl _itow_s(
                                 int      _Value,
         wchar_t* _Buffer,
                                 size_t   _BufferCount,
                                 int      _Radix
        );

    extern "C++" { template <size_t _Size> inline errno_t __cdecl _itow_s(int _Value, wchar_t (&_Buffer)[_Size], int _Radix) throw() { return _itow_s(_Value, _Buffer, _Size, _Radix); } }






    __declspec(dllimport) wchar_t* __cdecl _itow(int _Value, wchar_t *_Buffer, int _Radix);






    
    
    __declspec(dllimport) errno_t __cdecl _ltow_s(
                                 long     _Value,
         wchar_t* _Buffer,
                                 size_t   _BufferCount,
                                 int      _Radix
        );

    extern "C++" { template <size_t _Size> inline errno_t __cdecl _ltow_s(long _Value, wchar_t (&_Buffer)[_Size], int _Radix) throw() { return _ltow_s(_Value, _Buffer, _Size, _Radix); } }






    __declspec(dllimport) wchar_t* __cdecl _ltow(long _Value, wchar_t *_Buffer, int _Radix);






    
    __declspec(dllimport) errno_t __cdecl _ultow_s(
                                 unsigned long _Value,
         wchar_t*      _Buffer,
                                 size_t        _BufferCount,
                                 int           _Radix
        );

    extern "C++" { template <size_t _Size> inline errno_t __cdecl _ultow_s(unsigned long _Value, wchar_t (&_Buffer)[_Size], int _Radix) throw() { return _ultow_s(_Value, _Buffer, _Size, _Radix); } }






    __declspec(dllimport) wchar_t* __cdecl _ultow(unsigned long _Value, wchar_t *_Buffer, int _Radix);






    
    __declspec(dllimport) double __cdecl wcstod(
                           wchar_t const* _String,
          wchar_t**      _EndPtr
        );

    
    __declspec(dllimport) double __cdecl _wcstod_l(
                           wchar_t const* _String,
          wchar_t**      _EndPtr,
                         _locale_t      _Locale
        );

    
    __declspec(dllimport) long __cdecl wcstol(
                           wchar_t const* _String,
          wchar_t**      _EndPtr,
                             int            _Radix
        );

    
    __declspec(dllimport) long __cdecl _wcstol_l(
                           wchar_t const* _String,
          wchar_t**      _EndPtr,
                             int            _Radix,
                         _locale_t      _Locale
        );

    
    __declspec(dllimport) long long __cdecl wcstoll(
                           wchar_t const* _String,
          wchar_t**      _EndPtr,
                             int            _Radix
        );

    
    __declspec(dllimport) long long __cdecl _wcstoll_l(
                           wchar_t const* _String,
          wchar_t**      _EndPtr,
                             int            _Radix,
                         _locale_t      _Locale
        );

    
    __declspec(dllimport) unsigned long __cdecl wcstoul(
                           wchar_t const* _String,
          wchar_t**      _EndPtr,
                             int            _Radix
        );

    
    __declspec(dllimport) unsigned long __cdecl _wcstoul_l(
                           wchar_t const* _String,
          wchar_t**      _EndPtr,
                             int            _Radix,
                         _locale_t      _Locale
        );

    
    __declspec(dllimport) unsigned long long __cdecl wcstoull(
                           wchar_t const* _String,
          wchar_t**      _EndPtr,
                             int            _Radix
        );

    
    __declspec(dllimport) unsigned long long __cdecl _wcstoull_l(
                           wchar_t const* _String,
          wchar_t**      _EndPtr,
                             int            _Radix,
                         _locale_t      _Locale
        );

    
    __declspec(dllimport) long double __cdecl wcstold(
                           wchar_t const* _String,
          wchar_t**      _EndPtr
        );

    
    __declspec(dllimport) long double __cdecl _wcstold_l(
                           wchar_t const* _String,
          wchar_t**      _EndPtr,
                         _locale_t      _Locale
        );

    
    __declspec(dllimport) float __cdecl wcstof(
                           wchar_t const* _String,
          wchar_t**      _EndPtr
        );

    
    __declspec(dllimport) float __cdecl _wcstof_l(
                           wchar_t const* _String,
          wchar_t**      _EndPtr,
                         _locale_t      _Locale
        );

    
    __declspec(dllimport) double __cdecl _wtof(
         wchar_t const* _String
        );

    
    __declspec(dllimport) double __cdecl _wtof_l(
           wchar_t const* _String,
         _locale_t      _Locale
        );

    
    __declspec(dllimport) int __cdecl _wtoi(
         wchar_t const* _String
        );

    
    __declspec(dllimport) int __cdecl _wtoi_l(
           wchar_t const* _String,
         _locale_t      _Locale
        );

    
    __declspec(dllimport) long __cdecl _wtol(
         wchar_t const* _String
        );

    
    __declspec(dllimport) long __cdecl _wtol_l(
           wchar_t const* _String,
         _locale_t      _Locale
        );

    
    __declspec(dllimport) long long __cdecl _wtoll(
         wchar_t const* _String
        );

    
    __declspec(dllimport) long long __cdecl _wtoll_l(
           wchar_t const* _String,
         _locale_t      _Locale
        );

    
    __declspec(dllimport) errno_t __cdecl _i64tow_s(
                                 __int64  _Value,
         wchar_t* _Buffer,
                                 size_t   _BufferCount,
                                 int      _Radix
        );

    
    __declspec(dllimport) wchar_t* __cdecl _i64tow(
                           __int64  _Value,
          wchar_t* _Buffer,
                           int      _Radix
        );

    
    __declspec(dllimport) errno_t __cdecl _ui64tow_s(
                                 unsigned __int64 _Value,
         wchar_t*         _Buffer,
                                 size_t           _BufferCount,
                                 int              _Radix
        );

    
    __declspec(dllimport) wchar_t* __cdecl _ui64tow(
                           unsigned __int64 _Value,
          wchar_t*         _Buffer,
                           int              _Radix
        );

    
    __declspec(dllimport) __int64 __cdecl _wtoi64(
         wchar_t const* _String
        );

    
    __declspec(dllimport) __int64 __cdecl _wtoi64_l(
           wchar_t const* _String,
         _locale_t      _Locale
        );

    
    __declspec(dllimport) __int64 __cdecl _wcstoi64(
                           wchar_t const* _String,
          wchar_t**      _EndPtr,
                             int            _Radix
        );

    
    __declspec(dllimport) __int64 __cdecl _wcstoi64_l(
                           wchar_t const* _String,
          wchar_t**      _EndPtr,
                             int            _Radix,
                         _locale_t      _Locale
        );

    
    __declspec(dllimport) unsigned __int64 __cdecl _wcstoui64(
                           wchar_t const* _String,
          wchar_t**      _EndPtr,
                             int            _Radix
        );

    
    __declspec(dllimport) unsigned __int64 __cdecl _wcstoui64_l(
                           wchar_t const* _String,
          wchar_t**      _EndPtr,
                             int            _Radix,
                         _locale_t      _Locale
        );

    
    

    
    
    __declspec(dllimport) __declspec(allocator) wchar_t* __cdecl _wfullpath(
         wchar_t*       _Buffer,
                                   wchar_t const* _Path,
                                     size_t         _BufferCount
        );

    

    
    __declspec(dllimport) errno_t __cdecl _wmakepath_s(
         wchar_t*       _Buffer,
                                 size_t         _BufferCount,
                           wchar_t const* _Drive,
                           wchar_t const* _Dir,
                           wchar_t const* _Filename,
                           wchar_t const* _Ext
        );

    extern "C++" { template <size_t _Size> inline errno_t __cdecl _wmakepath_s(wchar_t (&_Buffer)[_Size], wchar_t const* _Drive, wchar_t const* _Dir, wchar_t const* _Filename, wchar_t const* _Ext) throw() { return _wmakepath_s(_Buffer, _Size, _Drive, _Dir, _Filename, _Ext); } }








#pragma warning(push)
#pragma warning(disable: 28719) 
#pragma warning(disable: 28726) 
__declspec(dllimport) void __cdecl _wmakepath( wchar_t *_Buffer, wchar_t const* _Drive, wchar_t const* _Dir, wchar_t const* _Filename, wchar_t const* _Ext);







#pragma warning(pop)

    __declspec(dllimport) void __cdecl _wperror(
         wchar_t const* _ErrorMessage
        );

    
    __declspec(dllimport) void __cdecl _wsplitpath(
                           wchar_t const* _FullPath,
          wchar_t*       _Drive,
          wchar_t*       _Dir,
          wchar_t*       _Filename,
          wchar_t*       _Ext
        );

    __declspec(dllimport) errno_t __cdecl _wsplitpath_s(
                                     wchar_t const* _FullPath,
            wchar_t*       _Drive,
                                       size_t         _DriveCount,
              wchar_t*       _Dir,
                                       size_t         _DirCount,
         wchar_t*       _Filename,
                                       size_t         _FilenameCount,
              wchar_t*       _Ext,
                                       size_t         _ExtCount
        );

    extern "C++" { template <size_t _DriveSize, size_t _DirSize, size_t _NameSize, size_t _ExtSize> inline errno_t __cdecl _wsplitpath_s( wchar_t const* _Path, wchar_t (&_Drive)[_DriveSize], wchar_t (&_Dir)[_DirSize], wchar_t (&_Name)[_NameSize], wchar_t (&_Ext)[_ExtSize] ) throw() { return _wsplitpath_s(_Path, _Drive, _DriveSize, _Dir, _DirSize, _Name, _NameSize, _Ext, _ExtSize); } }




        
        

        
        __declspec(dllimport) errno_t __cdecl _wdupenv_s(
              wchar_t**      _Buffer,
                                                                               size_t*        _BufferCount,
                                                                                  wchar_t const* _VarName
            );

        

         
        __declspec(dllimport) wchar_t* __cdecl _wgetenv(
             wchar_t const* _VarName
            );

        
        
        __declspec(dllimport) errno_t __cdecl _wgetenv_s(
                                        size_t*        _RequiredCount,
             wchar_t*       _Buffer,
                                         size_t         _BufferCount,
                                       wchar_t const* _VarName
            );

        extern "C++" { template <size_t _Size> inline errno_t __cdecl _wgetenv_s(size_t* _RequiredCount, wchar_t (&_Buffer)[_Size], wchar_t const* _VarName) throw() { return _wgetenv_s(_RequiredCount, _Buffer, _Size, _VarName); } }







        
        __declspec(dllimport) int __cdecl _wputenv(
             wchar_t const* _EnvString
            );

        
        __declspec(dllimport) errno_t __cdecl _wputenv_s(
             wchar_t const* _Name,
             wchar_t const* _Value
            );

        __declspec(dllimport) errno_t __cdecl _wsearchenv_s(
                                   wchar_t const* _Filename,
                                   wchar_t const* _VarName,
             wchar_t*       _Buffer,
                                     size_t         _BufferCount
            );

        extern "C++" { template <size_t _Size> inline errno_t __cdecl _wsearchenv_s(wchar_t const* _Filename, wchar_t const* _VarName, wchar_t (&_ResultPath)[_Size]) throw() { return _wsearchenv_s(_Filename, _VarName, _ResultPath, _Size); } }






        __declspec(dllimport) void __cdecl _wsearchenv(wchar_t const* _Filename, wchar_t const* _VarName, wchar_t *_ResultPath);






        __declspec(dllimport) int __cdecl _wsystem(
             wchar_t const* _Command
            );

#line 476 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt\\corecrt_wstdlib.h"



} __pragma(pack(pop))
#line 16 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt\\stdlib.h"
#line 1 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.28.29333\\include\\limits.h"
//
// limits.h
//
//      Copyright (c) Microsoft Corporation. All rights reserved.
//
// The C Standard Library <limits.h> header.
//
#pragma once




#pragma warning(push)
#pragma warning(disable: 4514 4820 )

__pragma(pack(push, 8)) extern "C" {







    
    



#line 30 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.28.29333\\include\\limits.h"
































    // SIZE_MAX definition must match exactly with stdint.h for modules support.
    
        
    

#line 68 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.28.29333\\include\\limits.h"
#line 69 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.28.29333\\include\\limits.h"


    
        
    #line 74 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.28.29333\\include\\limits.h"
#line 75 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.28.29333\\include\\limits.h"

} __pragma(pack(pop))

#pragma warning(pop) 
#line 17 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt\\stdlib.h"

__pragma(pack(push, 8)) extern "C" {




    
#line 25 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt\\stdlib.h"



// Minimum and maximum macros





__declspec(dllimport) void __cdecl _swab(
      char* _Buf1,
      char* _Buf2,
                                                                 int   _SizeInBytes
    );



//-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
//
// Exit and Abort
//
//-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
// Argument values for exit()




    __declspec(dllimport) __declspec(noreturn) void __cdecl exit( int _Code);
    __declspec(dllimport) __declspec(noreturn) void __cdecl _exit( int _Code);
    __declspec(dllimport) __declspec(noreturn) void __cdecl _Exit( int _Code);
    __declspec(dllimport) __declspec(noreturn) void __cdecl quick_exit( int _Code);
    __declspec(dllimport) __declspec(noreturn) void __cdecl abort(void);
#line 58 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt\\stdlib.h"

// Argument values for _set_abort_behavior().



__declspec(dllimport) unsigned int __cdecl _set_abort_behavior(
     unsigned int _Flags,
     unsigned int _Mask
    );




    

    typedef int (__cdecl * _onexit_t)(void);
    


#line 78 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt\\stdlib.h"


    // Non-ANSI name for compatibility
    
#line 83 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt\\stdlib.h"

























































    int       __cdecl atexit(void (__cdecl*)(void));
    _onexit_t __cdecl _onexit( _onexit_t _Func);
#line 143 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt\\stdlib.h"

int __cdecl at_quick_exit(void (__cdecl*)(void));



//-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
//
// Global State (errno, global handlers, etc.)
//
//-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

    // a purecall handler procedure. Never returns normally
    typedef void (__cdecl* _purecall_handler)(void);

    // Invalid parameter handler function pointer type
    typedef void (__cdecl* _invalid_parameter_handler)(
        wchar_t const*,
        wchar_t const*,
        wchar_t const*,
        unsigned int,
        uintptr_t
        );

    // Establishes a purecall handler
     _purecall_handler __cdecl _set_purecall_handler(
         _purecall_handler _Handler
        );

     _purecall_handler __cdecl _get_purecall_handler(void);

    // Establishes an invalid parameter handler
    __declspec(dllimport) _invalid_parameter_handler __cdecl _set_invalid_parameter_handler(
         _invalid_parameter_handler _Handler
        );

    __declspec(dllimport) _invalid_parameter_handler __cdecl _get_invalid_parameter_handler(void);

    __declspec(dllimport) _invalid_parameter_handler __cdecl _set_thread_local_invalid_parameter_handler(
         _invalid_parameter_handler _Handler
        );

    __declspec(dllimport) _invalid_parameter_handler __cdecl _get_thread_local_invalid_parameter_handler(void);
#line 186 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt\\stdlib.h"












#line 199 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt\\stdlib.h"



// Argument values for _set_error_mode().





 __declspec(dllimport) int __cdecl _set_error_mode( int _Mode);




    __declspec(dllimport) int* __cdecl _errno(void);
    

    __declspec(dllimport) errno_t __cdecl _set_errno( int _Value);
    __declspec(dllimport) errno_t __cdecl _get_errno( int* _Value);

    __declspec(dllimport) unsigned long* __cdecl __doserrno(void);
    

    __declspec(dllimport) errno_t __cdecl _set_doserrno( unsigned long _Value);
    __declspec(dllimport) errno_t __cdecl _get_doserrno( unsigned long * _Value);

    // This is non-const for backwards compatibility; do not modify it.
    __declspec(dllimport)  char** __cdecl __sys_errlist(void);
    

    __declspec(dllimport)  int * __cdecl __sys_nerr(void);
    

    __declspec(dllimport) void __cdecl perror( char const* _ErrMsg);
#line 234 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt\\stdlib.h"



// These point to the executable module name.
 __declspec(dllimport) char**    __cdecl __p__pgmptr (void);
 __declspec(dllimport) wchar_t** __cdecl __p__wpgmptr(void);
 __declspec(dllimport) int*      __cdecl __p__fmode  (void);








    
    
    
#line 253 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt\\stdlib.h"


__declspec(dllimport) errno_t __cdecl _get_pgmptr ( char**    _Value);


__declspec(dllimport) errno_t __cdecl _get_wpgmptr( wchar_t** _Value);

__declspec(dllimport) errno_t __cdecl _set_fmode  (              int       _Mode );

__declspec(dllimport) errno_t __cdecl _get_fmode  (             int*      _PMode);



//-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
//
// Math
//
//-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
typedef struct _div_t
{
    int quot;
    int rem;
} div_t;

typedef struct _ldiv_t
{
    long quot;
    long rem;
} ldiv_t;

typedef struct _lldiv_t
{
    long long quot;
    long long rem;
} lldiv_t;

 int       __cdecl abs   ( int       _Number);
 long      __cdecl labs  ( long      _Number);
 long long __cdecl llabs ( long long _Number);
 __int64   __cdecl _abs64( __int64   _Number);

 unsigned short   __cdecl _byteswap_ushort( unsigned short   _Number);
 unsigned long    __cdecl _byteswap_ulong ( unsigned long    _Number);
 unsigned __int64 __cdecl _byteswap_uint64( unsigned __int64 _Number);

 __declspec(dllimport) div_t   __cdecl div  ( int       _Numerator,  int       _Denominator);
 __declspec(dllimport) ldiv_t  __cdecl ldiv ( long      _Numerator,  long      _Denominator);
 __declspec(dllimport) lldiv_t __cdecl lldiv( long long _Numerator,  long long _Denominator);

// These functions have declspecs in their declarations in the Windows headers,
// which cause PREfast to fire 6540.
#pragma warning (push)
#pragma warning (disable:6540)

unsigned int __cdecl _rotl(
     unsigned int _Value,
     int          _Shift
    );


unsigned long __cdecl _lrotl(
     unsigned long _Value,
     int           _Shift
    );

unsigned __int64 __cdecl _rotl64(
     unsigned __int64 _Value,
     int              _Shift
    );

unsigned int __cdecl _rotr(
     unsigned int _Value,
     int          _Shift
    );


unsigned long __cdecl _lrotr(
     unsigned long _Value,
     int           _Shift
    );

unsigned __int64 __cdecl _rotr64(
     unsigned __int64 _Value,
     int              _Shift
    );

#pragma warning (pop)



// Maximum value that can be returned by the rand function:


__declspec(dllimport) void __cdecl srand( unsigned int _Seed);

 __declspec(dllimport) int __cdecl rand(void);



#line 353 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt\\stdlib.h"




extern "C++"
{
    inline long abs(long const _X) throw()
    {
        return labs(_X);
    }

    inline long long abs(long long const _X) throw()
    {
        return llabs(_X);
    }

    inline ldiv_t div(long const _A1, long const _A2) throw()
    {
        return ldiv(_A1, _A2);
    }

    inline lldiv_t div(long long const _A1, long long const _A2) throw()
    {
        return lldiv(_A1, _A2);
    }
}
#line 380 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt\\stdlib.h"




// Structs used to fool the compiler into not generating floating point
// instructions when copying and pushing [long] double values




    #pragma pack(push, 4)
    typedef struct
    {
        unsigned char ld[10];
    } _LDOUBLE;
    #pragma pack(pop)

    











#line 410 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt\\stdlib.h"

typedef struct
{
    double x;
} _CRT_DOUBLE;

typedef struct
{
    float f;
} _CRT_FLOAT;

// push and pop long, which is #defined as __int64 by a spec2k test



typedef struct
{
    long double x;
} _LONGDOUBLE;



#pragma pack(push, 4)
typedef struct
{
    unsigned char ld12[12];
} _LDBL12;
#pragma pack(pop)



//-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
//
// Narrow String to Number Conversions
//
//-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
                    __declspec(dllimport) double    __cdecl atof   ( char const* _String);
  __declspec(dllimport) int       __cdecl atoi   ( char const* _String);
                    __declspec(dllimport) long      __cdecl atol   ( char const* _String);
                    __declspec(dllimport) long long __cdecl atoll  ( char const* _String);
                    __declspec(dllimport) __int64   __cdecl _atoi64( char const* _String);

 __declspec(dllimport) double    __cdecl _atof_l  ( char const* _String,  _locale_t _Locale);
 __declspec(dllimport) int       __cdecl _atoi_l  ( char const* _String,  _locale_t _Locale);
 __declspec(dllimport) long      __cdecl _atol_l  ( char const* _String,  _locale_t _Locale);
 __declspec(dllimport) long long __cdecl _atoll_l ( char const* _String,  _locale_t _Locale);
 __declspec(dllimport) __int64   __cdecl _atoi64_l( char const* _String,  _locale_t _Locale);

 __declspec(dllimport) int __cdecl _atoflt ( _CRT_FLOAT*  _Result,  char const* _String);
 __declspec(dllimport) int __cdecl _atodbl ( _CRT_DOUBLE* _Result,  char*       _String);
 __declspec(dllimport) int __cdecl _atoldbl( _LDOUBLE*    _Result,  char*       _String);


__declspec(dllimport) int __cdecl _atoflt_l(
        _CRT_FLOAT* _Result,
       char const* _String,
     _locale_t   _Locale
    );


__declspec(dllimport) int __cdecl _atodbl_l(
        _CRT_DOUBLE* _Result,
       char*        _String,
     _locale_t    _Locale
    );



__declspec(dllimport) int __cdecl _atoldbl_l(
        _LDOUBLE* _Result,
       char*     _String,
     _locale_t _Locale
    );


__declspec(dllimport) float __cdecl strtof(
                       char const* _String,
      char**      _EndPtr
    );


__declspec(dllimport) float __cdecl _strtof_l(
                       char const* _String,
      char**      _EndPtr,
                     _locale_t   _Locale
    );


__declspec(dllimport) double __cdecl strtod(
                       char const* _String,
      char**      _EndPtr
    );


__declspec(dllimport) double __cdecl _strtod_l(
                       char const* _String,
      char**      _EndPtr,
                     _locale_t   _Locale
    );


__declspec(dllimport) long double __cdecl strtold(
                       char const* _String,
      char**      _EndPtr
    );


__declspec(dllimport) long double __cdecl _strtold_l(
                       char const* _String,
      char**      _EndPtr,
                     _locale_t   _Locale
    );


__declspec(dllimport) long __cdecl strtol(
                       char const* _String,
      char**      _EndPtr,
                         int         _Radix
    );


__declspec(dllimport) long __cdecl _strtol_l(
                       char const* _String,
      char**      _EndPtr,
                         int         _Radix,
                     _locale_t   _Locale
    );


__declspec(dllimport) long long __cdecl strtoll(
                       char const* _String,
      char**      _EndPtr,
                         int         _Radix
    );


__declspec(dllimport) long long __cdecl _strtoll_l(
                       char const* _String,
      char**      _EndPtr,
                         int         _Radix,
                     _locale_t   _Locale
    );


__declspec(dllimport) unsigned long __cdecl strtoul(
                       char const* _String,
      char**      _EndPtr,
                         int         _Radix
    );


__declspec(dllimport) unsigned long __cdecl _strtoul_l(
                       char const* _String,
      char**      _EndPtr,
                         int         _Radix,
                     _locale_t   _Locale
    );


__declspec(dllimport) unsigned long long __cdecl strtoull(
                       char const* _String,
      char**      _EndPtr,
                         int         _Radix
    );


__declspec(dllimport) unsigned long long __cdecl _strtoull_l(
                       char const* _String,
      char**      _EndPtr,
                         int         _Radix,
                     _locale_t   _Locale
    );


__declspec(dllimport) __int64 __cdecl _strtoi64(
                       char const* _String,
      char**      _EndPtr,
                         int         _Radix
    );


__declspec(dllimport) __int64 __cdecl _strtoi64_l(
                       char const* _String,
      char**      _EndPtr,
                         int         _Radix,
                     _locale_t   _Locale
    );


__declspec(dllimport) unsigned __int64 __cdecl _strtoui64(
                       char const* _String,
      char**      _EndPtr,
                         int         _Radix
    );


__declspec(dllimport) unsigned __int64 __cdecl _strtoui64_l(
                       char const* _String,
      char**      _EndPtr,
                         int         _Radix,
                     _locale_t   _Locale
    );



//-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
//
// Number to Narrow String Conversions
//
//-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+


__declspec(dllimport) errno_t __cdecl _itoa_s(
                             int    _Value,
     char*  _Buffer,
                             size_t _BufferCount,
                             int    _Radix
    );

extern "C++" { template <size_t _Size> inline errno_t __cdecl _itoa_s(int _Value, char (&_Buffer)[_Size], int _Radix) throw() { return _itoa_s(_Value, _Buffer, _Size, _Radix); } }







#pragma warning(push)
#pragma warning(disable: 28719) 
#pragma warning(disable: 28726) 
__declspec(dllimport) char* __cdecl _itoa(int _Value, char *_Buffer, int _Radix);





#pragma warning(pop)



__declspec(dllimport) errno_t __cdecl _ltoa_s(
                             long   _Value,
     char*  _Buffer,
                             size_t _BufferCount,
                             int    _Radix
    );

extern "C++" { template <size_t _Size> inline errno_t __cdecl _ltoa_s(long _Value, char (&_Buffer)[_Size], int _Radix) throw() { return _ltoa_s(_Value, _Buffer, _Size, _Radix); } }






__declspec(dllimport) char* __cdecl _ltoa(long _Value, char *_Buffer, int _Radix);








__declspec(dllimport) errno_t __cdecl _ultoa_s(
                             unsigned long _Value,
     char*         _Buffer,
                             size_t        _BufferCount,
                             int           _Radix
    );

extern "C++" { template <size_t _Size> inline errno_t __cdecl _ultoa_s(unsigned long _Value, char (&_Buffer)[_Size], int _Radix) throw() { return _ultoa_s(_Value, _Buffer, _Size, _Radix); } }






#pragma warning(push)
#pragma warning(disable: 28726) 
__declspec(dllimport) char* __cdecl _ultoa(unsigned long _Value, char *_Buffer, int _Radix);





#pragma warning(pop)



__declspec(dllimport) errno_t __cdecl _i64toa_s(
                             __int64 _Value,
     char*   _Buffer,
                             size_t  _BufferCount,
                             int     _Radix
    );



__declspec(dllimport) char* __cdecl _i64toa(
                       __int64 _Value,
      char*   _Buffer,
                       int     _Radix
    );



__declspec(dllimport) errno_t __cdecl _ui64toa_s(
                             unsigned __int64 _Value,
     char*            _Buffer,
                             size_t           _BufferCount,
                             int              _Radix
    );


__declspec(dllimport) char* __cdecl _ui64toa(
                       unsigned __int64 _Value,
      char*            _Buffer,
                       int              _Radix
    );



// _CVTBUFSIZE is the maximum size for the per-thread conversion buffer.  It
// should be at least as long as the number of digits in the largest double
// precision value (?.?e308 in IEEE arithmetic).  We will use the same size
// buffer as is used in the printf support routines.
//
// (This value actually allows 40 additional decimal places; even though there
// are only 16 digits of accuracy in a double precision IEEE number, the user may
// ask for more to effect zero padding.)




__declspec(dllimport) errno_t __cdecl _ecvt_s(
     char* _Buffer,
      size_t                       _BufferCount,
      double                       _Value,
      int                          _DigitCount,
     int*                         _PtDec,
     int*                         _PtSign
    );

extern "C++" { template <size_t _Size> inline errno_t __cdecl _ecvt_s(char (&_Buffer)[_Size], double _Value, int _DigitCount, int* _PtDec, int* _PtSign) throw() { return _ecvt_s(_Buffer, _Size, _Value, _DigitCount, _PtDec, _PtSign); } }








 
__declspec(dllimport) char* __cdecl _ecvt(
      double _Value,
      int    _DigitCount,
     int*   _PtDec,
     int*   _PtSign
    );



__declspec(dllimport) errno_t __cdecl _fcvt_s(
     char*  _Buffer,
                             size_t _BufferCount,
                             double _Value,
                             int    _FractionalDigitCount,
                            int*   _PtDec,
                            int*   _PtSign
    );

extern "C++" { template <size_t _Size> inline errno_t __cdecl _fcvt_s(char (&_Buffer)[_Size], double _Value, int _FractionalDigitCount, int* _PtDec, int* _PtSign) throw() { return _fcvt_s(_Buffer, _Size, _Value, _FractionalDigitCount, _PtDec, _PtSign); } }










 
__declspec(dllimport) char* __cdecl _fcvt(
      double _Value,
      int    _FractionalDigitCount,
     int*   _PtDec,
     int*   _PtSign
    );


__declspec(dllimport) errno_t __cdecl _gcvt_s(
     char*  _Buffer,
                             size_t _BufferCount,
                             double _Value,
                             int    _DigitCount
    );

extern "C++" { template <size_t _Size> inline errno_t __cdecl _gcvt_s(char (&_Buffer)[_Size], double _Value, int _DigitCount) throw() { return _gcvt_s(_Buffer, _Size, _Value, _DigitCount); } }








__declspec(dllimport) char* __cdecl _gcvt(
                       double _Value,
                       int    _DigitCount,
      char*  _Buffer
    );



//-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
//
// Multibyte String Operations and Conversions
//
//-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
// Maximum number of bytes in multi-byte character in the current locale
// (also defined in ctype.h).

    

#line 836 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt\\stdlib.h"
        
    #line 838 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt\\stdlib.h"

    


        
    #line 844 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt\\stdlib.h"

    
    __declspec(dllimport) int __cdecl ___mb_cur_max_func(void);

    
    __declspec(dllimport) int __cdecl ___mb_cur_max_l_func(_locale_t _Locale);
#line 851 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt\\stdlib.h"




__declspec(dllimport) int __cdecl mblen(
      char const* _Ch,
                                            size_t      _MaxCount
    );


__declspec(dllimport) int __cdecl _mblen_l(
      char const* _Ch,
                                            size_t      _MaxCount,
                                        _locale_t   _Locale
    );



__declspec(dllimport) size_t __cdecl _mbstrlen(
     char const* _String
    );



__declspec(dllimport) size_t __cdecl _mbstrlen_l(
       char const* _String,
     _locale_t   _Locale
    );



__declspec(dllimport) size_t __cdecl _mbstrnlen(
     char const* _String,
       size_t      _MaxCount
    );



__declspec(dllimport) size_t __cdecl _mbstrnlen_l(
       char const* _String,
         size_t      _MaxCount,
     _locale_t   _Locale
    );


__declspec(dllimport) int __cdecl mbtowc(
                    wchar_t*    _DstCh,
     char const* _SrcCh,
                                     size_t      _SrcSizeInBytes
    );


__declspec(dllimport) int __cdecl _mbtowc_l(
                    wchar_t*    _DstCh,
     char const* _SrcCh,
                                     size_t      _SrcSizeInBytes,
                                 _locale_t   _Locale
    );


__declspec(dllimport) errno_t __cdecl mbstowcs_s(
                                                     size_t*     _PtNumOfCharConverted,
     wchar_t*    _DstBuf,
                                                          size_t      _SizeInWords,
                                    char const* _SrcBuf,
                                                          size_t      _MaxCount
    );

extern "C++" { template <size_t _Size> inline errno_t __cdecl mbstowcs_s(size_t* _PtNumOfCharConverted, wchar_t (&_Dest)[_Size], char const* _Source, size_t _MaxCount) throw() { return mbstowcs_s(_PtNumOfCharConverted, _Dest, _Size, _Source, _MaxCount); } }







__declspec(dllimport) size_t __cdecl mbstowcs( wchar_t *_Dest, char const* _Source, size_t _MaxCount);







__declspec(dllimport) errno_t __cdecl _mbstowcs_s_l(
                                                     size_t*     _PtNumOfCharConverted,
     wchar_t*    _DstBuf,
                                                          size_t      _SizeInWords,
                                    char const* _SrcBuf,
                                                          size_t      _MaxCount,
                                                      _locale_t   _Locale
    );

extern "C++" { template <size_t _Size> inline errno_t __cdecl _mbstowcs_s_l(size_t* _PtNumOfCharConverted, wchar_t (&_Dest)[_Size], char const* _Source, size_t _MaxCount, _locale_t _Locale) throw() { return _mbstowcs_s_l(_PtNumOfCharConverted, _Dest, _Size, _Source, _MaxCount, _Locale); } }








__declspec(dllimport) size_t __cdecl _mbstowcs_l( wchar_t *_Dest, char const* _Source, size_t _MaxCount, _locale_t _Locale);












__declspec(dllimport) int __cdecl wctomb(
     char*   _MbCh,
                               wchar_t _WCh
    );


__declspec(dllimport) int __cdecl _wctomb_l(
      char*     _MbCh,
                         wchar_t   _WCh,
                     _locale_t _Locale
    );



    
    __declspec(dllimport) errno_t __cdecl wctomb_s(
                                                        int*    _SizeConverted,
         char*   _MbCh,
                                                             rsize_t _SizeInBytes,
                                                             wchar_t _WCh
        );

#line 989 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt\\stdlib.h"


__declspec(dllimport) errno_t __cdecl _wctomb_s_l(
                            int*     _SizeConverted,
     char*     _MbCh,
                                 size_t    _SizeInBytes,
                                 wchar_t   _WCh,
                             _locale_t _Locale);


__declspec(dllimport) errno_t __cdecl wcstombs_s(
                                                              size_t*        _PtNumOfCharConverted,
     char*          _Dst,
                                                                   size_t         _DstSizeInBytes,
                                                                 wchar_t const* _Src,
                                                                   size_t         _MaxCountInBytes
    );

extern "C++" { template <size_t _Size> inline errno_t __cdecl wcstombs_s(size_t* _PtNumOfCharConverted, char (&_Dest)[_Size], wchar_t const* _Source, size_t _MaxCount) throw() { return wcstombs_s(_PtNumOfCharConverted, _Dest, _Size, _Source, _MaxCount); } }







__declspec(dllimport) size_t __cdecl wcstombs( char *_Dest, wchar_t const* _Source, size_t _MaxCount);







__declspec(dllimport) errno_t __cdecl _wcstombs_s_l(
                                                              size_t*        _PtNumOfCharConverted,
     char*          _Dst,
                                                                   size_t         _DstSizeInBytes,
                                                                 wchar_t const* _Src,
                                                                   size_t         _MaxCountInBytes,
                                                               _locale_t      _Locale
    );

extern "C++" { template <size_t _Size> inline errno_t __cdecl _wcstombs_s_l(size_t* _PtNumOfCharConverted, char (&_Dest)[_Size], wchar_t const* _Source, size_t _MaxCount, _locale_t _Locale) throw() { return _wcstombs_s_l(_PtNumOfCharConverted, _Dest, _Size, _Source, _MaxCount, _Locale); } }








__declspec(dllimport) size_t __cdecl _wcstombs_l( char *_Dest, wchar_t const* _Source, size_t _MaxCount, _locale_t _Locale);










//-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
//
// Path Manipulation
//
//-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
// Sizes for buffers used by the _makepath() and _splitpath() functions.
// note that the sizes include space for 0-terminator












__declspec(dllimport) __declspec(allocator) char* __cdecl _fullpath(
     char*       _Buffer,
                               char const* _Path,
                                 size_t      _BufferCount
    );




__declspec(dllimport) errno_t __cdecl _makepath_s(
     char*       _Buffer,
                             size_t      _BufferCount,
                       char const* _Drive,
                       char const* _Dir,
                       char const* _Filename,
                       char const* _Ext
    );

extern "C++" { template <size_t _Size> inline errno_t __cdecl _makepath_s(char (&_Buffer)[_Size], char const* _Drive, char const* _Dir, char const* _Filename, char const* _Ext) throw() { return _makepath_s(_Buffer, _Size, _Drive, _Dir, _Filename, _Ext); } }








#pragma warning(push)
#pragma warning(disable: 28719) 
#pragma warning(disable: 28726) 
__declspec(dllimport) void __cdecl _makepath( char *_Buffer, char const* _Drive, char const* _Dir, char const* _Filename, char const* _Ext);







#pragma warning(pop)


__declspec(dllimport) void __cdecl _splitpath(
                       char const* _FullPath,
      char*       _Drive,
      char*       _Dir,
      char*       _Filename,
      char*       _Ext
    );


__declspec(dllimport) errno_t __cdecl _splitpath_s(
                                 char const* _FullPath,
        char*       _Drive,
                                   size_t      _DriveCount,
          char*       _Dir,
                                   size_t      _DirCount,
     char*       _Filename,
                                   size_t      _FilenameCount,
          char*       _Ext,
                                   size_t      _ExtCount
    );

extern "C++" { template <size_t _DriveSize, size_t _DirSize, size_t _NameSize, size_t _ExtSize> inline errno_t __cdecl _splitpath_s( char const* _Dest, char (&_Drive)[_DriveSize], char (&_Dir)[_DirSize], char (&_Name)[_NameSize], char (&_Ext)[_ExtSize] ) throw() { return _splitpath_s(_Dest, _Drive, _DriveSize, _Dir, _DirSize, _Name, _NameSize, _Ext, _ExtSize); } }





__declspec(dllimport) errno_t __cdecl getenv_s(
                                size_t*     _RequiredCount,
     char*       _Buffer,
                                 rsize_t     _BufferCount,
                               char const* _VarName
    );

#line 1147 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt\\stdlib.h"




__declspec(dllimport) int*       __cdecl __p___argc (void);
__declspec(dllimport) char***    __cdecl __p___argv (void);
__declspec(dllimport) wchar_t*** __cdecl __p___wargv(void);






    
    
    
#line 1164 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt\\stdlib.h"

__declspec(dllimport) char***    __cdecl __p__environ (void);
__declspec(dllimport) wchar_t*** __cdecl __p__wenviron(void);


    
#line 1171 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt\\stdlib.h"







    
    
#line 1181 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt\\stdlib.h"



// Sizes for buffers used by the getenv/putenv family of functions.





     
    __declspec(dllimport) char* __cdecl getenv(
         char const* _VarName
        );

    extern "C++" { template <size_t _Size> inline errno_t __cdecl getenv_s(size_t* _RequiredCount, char (&_Buffer)[_Size], char const* _VarName) throw() { return getenv_s(_RequiredCount, _Buffer, _Size, _VarName); } }






    


#line 1206 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt\\stdlib.h"

    
    __declspec(dllimport) errno_t __cdecl _dupenv_s(
          char**      _Buffer,
                                                                           size_t*     _BufferCount,
                                                                              char const* _VarName
        );

    

#line 1217 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt\\stdlib.h"

    __declspec(dllimport) int __cdecl system(
         char const* _Command
        );

    // The functions below have declspecs in their declarations in the Windows
    // headers, causing PREfast to fire 6540 here
    #pragma warning (push)
    #pragma warning (disable:6540)

    
    __declspec(dllimport) int __cdecl _putenv(
         char const* _EnvString
        );

    
    __declspec(dllimport) errno_t __cdecl _putenv_s(
         char const* _Name,
         char const* _Value
        );

    #pragma warning (pop)

    __declspec(dllimport) errno_t __cdecl _searchenv_s(
                               char const* _Filename,
                               char const* _VarName,
         char*       _Buffer,
                                 size_t      _BufferCount
        );

    extern "C++" { template <size_t _Size> inline errno_t __cdecl _searchenv_s(char const* _Filename, char const* _VarName, char (&_Buffer)[_Size]) throw() { return _searchenv_s(_Filename, _VarName, _Buffer, _Size); } }






    __declspec(dllimport) void __cdecl _searchenv(char const* _Filename, char const* _VarName, char *_Buffer);






    // The Win32 API SetErrorMode, Beep and Sleep should be used instead.
    __declspec(deprecated("This function or variable has been superceded by newer library " "or operating system functionality. Consider using " "SetErrorMode" " " "instead. See online help for details."))
    __declspec(dllimport) void __cdecl _seterrormode(
         int _Mode
        );

    __declspec(deprecated("This function or variable has been superceded by newer library " "or operating system functionality. Consider using " "Beep" " " "instead. See online help for details."))
    __declspec(dllimport) void __cdecl _beep(
         unsigned _Frequency,
         unsigned _Duration
        );

    __declspec(deprecated("This function or variable has been superceded by newer library " "or operating system functionality. Consider using " "Sleep" " " "instead. See online help for details."))
    __declspec(dllimport) void __cdecl _sleep(
         unsigned long _Duration
        );

#line 1279 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt\\stdlib.h"


//-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
//
// Non-ANSI Names for Compatibility
//
//-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+


    




    
    

    #pragma warning(push)
    #pragma warning(disable: 4141) 

     __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_ecvt" ". See online help for details.")) 
    __declspec(dllimport) char* __cdecl ecvt(
          double _Value,
          int    _DigitCount,
         int*   _PtDec,
         int*   _PtSign
        );

     __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_fcvt" ". See online help for details.")) 
    __declspec(dllimport) char* __cdecl fcvt(
          double _Value,
          int    _FractionalDigitCount,
         int*   _PtDec,
         int*   _PtSign
        );

    __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_gcvt" ". See online help for details.")) 
    __declspec(dllimport) char* __cdecl gcvt(
                           double _Value,
                           int    _DigitCount,
          char*  _DstBuf
        );

    __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_itoa" ". See online help for details.")) 
    __declspec(dllimport) char* __cdecl itoa(
                           int   _Value,
          char* _Buffer,
                           int   _Radix
        );

    __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_ltoa" ". See online help for details.")) 
    __declspec(dllimport) char* __cdecl ltoa(
                           long  _Value,
          char* _Buffer,
                           int   _Radix
        );


    __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_swab" ". See online help for details."))
    __declspec(dllimport) void __cdecl swab(
         char* _Buf1,
         char* _Buf2,
                                    int   _SizeInBytes
        );

    __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_ultoa" ". See online help for details.")) 
    __declspec(dllimport) char* __cdecl ultoa(
                           unsigned long _Value,
          char*         _Buffer,
                           int           _Radix
        );

    

     __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_putenv" ". See online help for details."))
    __declspec(dllimport) int __cdecl putenv(
         char const* _EnvString
        );

    #pragma warning(pop)

    _onexit_t __cdecl onexit( _onexit_t _Func);

#line 1363 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt\\stdlib.h"



} __pragma(pack(pop))
#line 1368 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt\\stdlib.h"
#line 6 "C:\\Users\\serpentiem\\source\\repos\\ddmk\\Core\\Includes.h"
#line 1 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt\\string.h"
//
// string.h
//
//      Copyright (c) Microsoft Corporation. All rights reserved.
//
// The C Standard Library <string.h> header.
//
#pragma once




#line 1 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt\\corecrt_memory.h"
//
// corecrt_memory.h
//
//      Copyright (c) Microsoft Corporation. All rights reserved.
//
// The buffer (memory) manipulation library.  These declarations are split out
// so that they may be included by both <string.h> and <memory.h>.  <string.h>
// does not include <memory.h> to avoid introducing conflicts with other user
// headers named <memory.h>.
//
#pragma once


#line 1 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt\\corecrt_memcpy_s.h"
//
// corecrt_memcpy_s.h
//
//      Copyright (c) Microsoft Corporation. All rights reserved.
//
// Inline definitions of memcpy_s and memmove_s
//
#pragma once


#line 1 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt\\errno.h"
//
// errno.h
//
//      Copyright (c) Microsoft Corporation. All rights reserved.
//
// System error numbers for use with errno and errno_t.
//
#pragma once





__pragma(pack(push, 8)) extern "C" {




    __declspec(dllimport) int* __cdecl _errno(void);
    

    __declspec(dllimport) errno_t __cdecl _set_errno( int _Value);
    __declspec(dllimport) errno_t __cdecl _get_errno( int* _Value);

    __declspec(dllimport) unsigned long* __cdecl __doserrno(void);
    

    __declspec(dllimport) errno_t __cdecl _set_doserrno( unsigned long _Value);
    __declspec(dllimport) errno_t __cdecl _get_doserrno( unsigned long * _Value);
#line 31 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt\\errno.h"



// Error codes




































// Error codes used in the Secure CRT functions

    
    
    
    
    
#line 79 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt\\errno.h"

// Support EDEADLOCK for compatibility with older Microsoft C versions


// POSIX Supplement

    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
#line 127 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt\\errno.h"



} __pragma(pack(pop))
#line 132 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt\\errno.h"
#line 12 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt\\corecrt_memcpy_s.h"
#line 1 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.28.29333\\include\\vcruntime_string.h"
//
// vcruntime_string.h
//
//      Copyright (c) Microsoft Corporation. All rights reserved.
//
// <string.h> functionality that is implemented in the VCRuntime.
//
#pragma once



#pragma warning(push)
#pragma warning(disable: 4514 4820 )



__pragma(pack(push, 8)) extern "C" {



[[nodiscard]] 
 void const * __cdecl memchr(
     void const* _Buf,
                                int         _Val,
                                size_t      _MaxCount
    );

[[nodiscard]] 
int __cdecl memcmp(
     void const* _Buf1,
     void const* _Buf2,
                        size_t      _Size
    );









void* __cdecl memcpy(
     void* _Dst,
           void const* _Src,
                              size_t      _Size
    );


 void* __cdecl memmove(
     void*       _Dst,
           void const* _Src,
                                  size_t      _Size
    );








void* __cdecl memset(
     void*  _Dst,
                              int    _Val,
                              size_t _Size
    );

[[nodiscard]] 
 char const * __cdecl strchr(
     char const* _Str,
       int         _Val
    );

[[nodiscard]] 
 char const * __cdecl strrchr(
     char const* _Str,
       int         _Ch
    );

[[nodiscard]]  
 char const * __cdecl strstr(
     char const* _Str,
     char const* _SubStr
    );

[[nodiscard]] 

 wchar_t const * __cdecl wcschr(
     wchar_t const* _Str,
       wchar_t        _Ch
    );

[[nodiscard]] 
 wchar_t const * __cdecl wcsrchr(
     wchar_t const* _Str,
       wchar_t        _Ch
    );

[[nodiscard]]  

 wchar_t const * __cdecl wcsstr(
     wchar_t const* _Str,
     wchar_t const* _SubStr
    );



} __pragma(pack(pop))

#line 112 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.28.29333\\include\\vcruntime_string.h"

#pragma warning(pop) 
#line 13 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt\\corecrt_memcpy_s.h"

__pragma(pack(push, 8)) extern "C" {


    
#line 19 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt\\corecrt_memcpy_s.h"














    
    
    static __inline errno_t __cdecl memcpy_s(
         void*       const _Destination,
                                                             rsize_t     const _DestinationSize,
                                void const* const _Source,
                                                             rsize_t     const _SourceSize
        )
    {
        if (_SourceSize == 0)
        {
            return 0;
        }

        { int _Expr_val=!!(_Destination != 0); if (!(_Expr_val)) { (*_errno()) = 22; _invalid_parameter_noinfo(); return 22; } } ;
        if (_Source == 0 || _DestinationSize < _SourceSize)
        {
            memset(_Destination, 0, _DestinationSize);

            { int _Expr_val=!!(_Source != 0); if (!(_Expr_val)) { (*_errno()) = 22; _invalid_parameter_noinfo(); return 22; } } ;
            { int _Expr_val=!!(_DestinationSize >= _SourceSize); if (!(_Expr_val)) { (*_errno()) = 34; _invalid_parameter_noinfo(); return 34; } } ;

            // Unreachable, but required to suppress /analyze warnings:
            return 22 ;
        }
#pragma warning(suppress:4996) 
        memcpy(_Destination, _Source, _SourceSize);
        return 0;
    }

    
    static __inline errno_t __cdecl memmove_s(
         void*       const _Destination,
                                                             rsize_t     const _DestinationSize,
                                void const* const _Source,
                                                             rsize_t     const _SourceSize
        )
    {
        if (_SourceSize == 0)
        {
            return 0;
        }

        { int _Expr_val=!!(_Destination != 0); if (!(_Expr_val)) { (*_errno()) = 22; _invalid_parameter_noinfo(); return 22; } } ;
        { int _Expr_val=!!(_Source != 0); if (!(_Expr_val)) { (*_errno()) = 22; _invalid_parameter_noinfo(); return 22; } } ;
        { int _Expr_val=!!(_DestinationSize >= _SourceSize); if (!(_Expr_val)) { (*_errno()) = 34; _invalid_parameter_noinfo(); return 34; } } ;

#pragma warning(suppress:4996) 
        memmove(_Destination, _Source, _SourceSize);
        return 0;
    }

#line 86 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt\\corecrt_memcpy_s.h"



} __pragma(pack(pop))
#line 15 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt\\corecrt_memory.h"




__pragma(pack(push, 8)) extern "C" {




__declspec(dllimport) int __cdecl _memicmp(
     void const* _Buf1,
     void const* _Buf2,
                            size_t      _Size
    );


__declspec(dllimport) int __cdecl _memicmp_l(
     void const* _Buf1,
     void const* _Buf2,
                            size_t      _Size,
                        _locale_t   _Locale
    );





    












#line 56 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt\\corecrt_memory.h"

    












#line 71 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt\\corecrt_memory.h"

#line 73 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt\\corecrt_memory.h"





    __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_memccpy" ". See online help for details."))
    __declspec(dllimport) void* __cdecl memccpy(
         void*       _Dst,
           void const* _Src,
                                  int         _Val,
                                  size_t      _Size
        );

     __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_memicmp" ". See online help for details."))
    __declspec(dllimport) int __cdecl memicmp(
         void const* _Buf1,
         void const* _Buf2,
                                size_t      _Size
        );

#line 94 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt\\corecrt_memory.h"





    extern "C++" 
    inline void* __cdecl memchr(
         void*  _Pv,
                             int    _C,
                             size_t _N
        )
    {
        void const* const _Pvc = _Pv;
        return const_cast<void*>(memchr(_Pvc, _C, _N));
    }

#line 111 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt\\corecrt_memory.h"



} __pragma(pack(pop))

#line 117 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt\\corecrt_memory.h"
#line 14 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt\\string.h"
#line 1 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt\\corecrt_wstring.h"
//
// corecrt_wstring.h
//
//      Copyright (c) Microsoft Corporation. All rights reserved.
//
// This file declares the wide character (wchar_t) string functionality, shared
// by <string.h> and <wchar.h>.
//
#pragma once






__pragma(pack(push, 8)) extern "C" {



//-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
//
// Secure Alternatives
//
//-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+


    
    __declspec(dllimport) errno_t __cdecl wcscat_s(
         wchar_t* _Destination,
         rsize_t _SizeInWords,
         wchar_t const* _Source
        );

    
    __declspec(dllimport) errno_t __cdecl wcscpy_s(
         wchar_t* _Destination,
         rsize_t _SizeInWords,
         wchar_t const* _Source
        );

    
    __declspec(dllimport) errno_t __cdecl wcsncat_s(
         wchar_t*       _Destination,
                                    rsize_t        _SizeInWords,
              wchar_t const* _Source,
                                    rsize_t        _MaxCount
        );

    
    __declspec(dllimport) errno_t __cdecl wcsncpy_s(
         wchar_t*       _Destination,
                                 rsize_t        _SizeInWords,
           wchar_t const* _Source,
                                 rsize_t        _MaxCount
        );

    
    __declspec(dllimport) wchar_t* __cdecl wcstok_s(
                         wchar_t*       _String,
                                wchar_t const* _Delimiter,
          wchar_t**      _Context
        );

#line 65 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt\\corecrt_wstring.h"



//-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
//
// Wide-Character <string.h> Functions
//
//-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+



#line 77 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt\\corecrt_wstring.h"


__declspec(dllimport) __declspec(allocator) wchar_t* __cdecl _wcsdup(
     wchar_t const* _String
    );



#line 86 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt\\corecrt_wstring.h"



extern "C++" { template <size_t _Size> inline errno_t __cdecl wcscat_s(wchar_t (&_Destination)[_Size], wchar_t const* _Source) throw() { return wcscat_s(_Destination, _Size, _Source); } }







#pragma warning(push)
#pragma warning(disable: 28719) 
#pragma warning(disable: 28726) 
    __declspec(dllimport) wchar_t* __cdecl wcscat( wchar_t *_Destination, wchar_t const* _Source);




#pragma warning(pop)
#line 107 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt\\corecrt_wstring.h"


__declspec(dllimport) int __cdecl wcscmp(
     wchar_t const* _String1,
     wchar_t const* _String2
    );

extern "C++" { template <size_t _Size> inline errno_t __cdecl wcscpy_s(wchar_t (&_Destination)[_Size], wchar_t const* _Source) throw() { return wcscpy_s(_Destination, _Size, _Source); } }





#pragma warning(push)
#pragma warning(disable: 28719) 
#pragma warning(disable: 28726) 
__declspec(dllimport) wchar_t* __cdecl wcscpy( wchar_t *_Destination, wchar_t const* _Source);




#pragma warning(pop)


__declspec(dllimport) size_t __cdecl wcscspn(
     wchar_t const* _String,
     wchar_t const* _Control
    );


__declspec(dllimport) size_t __cdecl wcslen(
     wchar_t const* _String
    );










__declspec(dllimport) size_t __cdecl wcsnlen(
     wchar_t const* _Source,
                           size_t         _MaxCount
    );



    
    



    



    static __inline size_t __cdecl wcsnlen_s(
         wchar_t const* _Source,
                               size_t         _MaxCount
        )
    {
        return (_Source == 0) ? 0 : wcsnlen(_Source, _MaxCount);
    }

#line 175 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt\\corecrt_wstring.h"

extern "C++" { template <size_t _Size> inline errno_t __cdecl wcsncat_s(wchar_t (&_Destination)[_Size], wchar_t const* _Source, size_t _Count) throw() { return wcsncat_s(_Destination, _Size, _Source, _Count); } }






__declspec(dllimport) wchar_t* __cdecl wcsncat( wchar_t *_Destination, wchar_t const* _Source, size_t _Count);








__declspec(dllimport) int __cdecl wcsncmp(
     wchar_t const* _String1,
     wchar_t const* _String2,
                           size_t         _MaxCount
    );

extern "C++" { template <size_t _Size> inline errno_t __cdecl wcsncpy_s(wchar_t (&_Destination)[_Size], wchar_t const* _Source, size_t _Count) throw() { return wcsncpy_s(_Destination, _Size, _Source, _Count); } }






__declspec(dllimport) wchar_t* __cdecl wcsncpy( wchar_t *_Destination, wchar_t const* _Source, size_t _Count);








__declspec(dllimport) wchar_t const * __cdecl wcspbrk(
     wchar_t const* _String,
     wchar_t const* _Control
    );


__declspec(dllimport) size_t __cdecl wcsspn(
     wchar_t const* _String,
     wchar_t const* _Control
    );

 
__declspec(dllimport) wchar_t* __cdecl wcstok(
                         wchar_t*       _String,
                                wchar_t const* _Delimiter,
      wchar_t**      _Context
    );



    

#line 237 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt\\corecrt_wstring.h"
        



    #line 242 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt\\corecrt_wstring.h"

    #pragma warning(push)
    #pragma warning(disable: 4141 4996) 
    #pragma warning(disable: 28719 28726 28727) 
     
    static __inline wchar_t* __cdecl _wcstok(
         wchar_t*       const _String,
                wchar_t const* const _Delimiter
        )
    {
        return wcstok(_String, _Delimiter, 0);
    }

    

#line 258 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt\\corecrt_wstring.h"

    
        extern "C++"  __declspec(deprecated("wcstok has been changed to conform with the ISO C standard, " "adding an extra context parameter. To use the legacy Microsoft " "wcstok, define _CRT_NON_CONFORMING_WCSTOK."))
        inline wchar_t* __cdecl wcstok(
             wchar_t*       _String,
                    wchar_t const* _Delimiter
            ) throw()
        {
            return wcstok(_String, _Delimiter, 0);
        }
    #line 269 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt\\corecrt_wstring.h"

    #pragma warning(pop)

#line 273 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt\\corecrt_wstring.h"




 
__declspec(dllimport) wchar_t* __cdecl _wcserror(
     int _ErrorNumber
    );


__declspec(dllimport) errno_t __cdecl _wcserror_s(
     wchar_t* _Buffer,
                                 size_t   _SizeInWords,
                                 int      _ErrorNumber
    );

extern "C++" { template <size_t _Size> inline errno_t __cdecl _wcserror_s(wchar_t (&_Buffer)[_Size], int _Error) throw() { return _wcserror_s(_Buffer, _Size, _Error); } }







 
__declspec(dllimport) wchar_t* __cdecl __wcserror(
     wchar_t const* _String
    );

 __declspec(dllimport) errno_t __cdecl __wcserror_s(
     wchar_t*       _Buffer,
                                 size_t         _SizeInWords,
                               wchar_t const* _ErrorMessage
    );

extern "C++" { template <size_t _Size> inline errno_t __cdecl __wcserror_s(wchar_t (&_Buffer)[_Size], wchar_t const* _ErrorMessage) throw() { return __wcserror_s(_Buffer, _Size, _ErrorMessage); } }





 __declspec(dllimport) int __cdecl _wcsicmp(
     wchar_t const* _String1,
     wchar_t const* _String2
    );

 __declspec(dllimport) int __cdecl _wcsicmp_l(
       wchar_t const* _String1,
       wchar_t const* _String2,
     _locale_t      _Locale
    );

 __declspec(dllimport) int __cdecl _wcsnicmp(
     wchar_t const* _String1,
     wchar_t const* _String2,
                           size_t         _MaxCount
    );

 __declspec(dllimport) int __cdecl _wcsnicmp_l(
     wchar_t const* _String1,
     wchar_t const* _String2,
                           size_t         _MaxCount,
                       _locale_t      _Locale
    );

 __declspec(dllimport) errno_t __cdecl _wcsnset_s(
     wchar_t* _Destination,
                                size_t   _SizeInWords,
                                wchar_t  _Value,
                                size_t   _MaxCount
    );

extern "C++" { template <size_t _Size> inline errno_t __cdecl _wcsnset_s(wchar_t (&_Destination)[_Size], wchar_t _Value, size_t _MaxCount) throw() { return _wcsnset_s(_Destination, _Size, _Value, _MaxCount); } }






__declspec(dllimport) wchar_t* __cdecl _wcsnset( wchar_t *_String, wchar_t _Value, size_t _MaxCount);







__declspec(dllimport) wchar_t* __cdecl _wcsrev(
     wchar_t* _String
    );

 __declspec(dllimport) errno_t __cdecl _wcsset_s(
     wchar_t* _Destination,
                                size_t   _SizeInWords,
                                wchar_t  _Value
    );

extern "C++" { template <size_t _Size> inline errno_t __cdecl _wcsset_s(wchar_t (&_String)[_Size], wchar_t _Value) throw() { return _wcsset_s(_String, _Size, _Value); } }





__declspec(dllimport) wchar_t* __cdecl _wcsset( wchar_t *_String, wchar_t _Value);






 __declspec(dllimport) errno_t __cdecl _wcslwr_s(
     wchar_t* _String,
                                size_t   _SizeInWords
    );

extern "C++" { template <size_t _Size> inline errno_t __cdecl _wcslwr_s(wchar_t (&_String)[_Size]) throw() { return _wcslwr_s(_String, _Size); } }




__declspec(dllimport) wchar_t* __cdecl _wcslwr( wchar_t *_String);





__declspec(dllimport) errno_t __cdecl _wcslwr_s_l(
     wchar_t*  _String,
                                size_t    _SizeInWords,
                            _locale_t _Locale
    );

extern "C++" { template <size_t _Size> inline errno_t __cdecl _wcslwr_s_l(wchar_t (&_String)[_Size], _locale_t _Locale) throw() { return _wcslwr_s_l(_String, _Size, _Locale); } }





__declspec(dllimport) wchar_t* __cdecl _wcslwr_l( wchar_t *_String, _locale_t _Locale);







__declspec(dllimport) errno_t __cdecl _wcsupr_s(
     wchar_t* _String,
                         size_t   _Size
    );

extern "C++" { template <size_t _Size> inline errno_t __cdecl _wcsupr_s(wchar_t (&_String)[_Size]) throw() { return _wcsupr_s(_String, _Size); } }




__declspec(dllimport) wchar_t* __cdecl _wcsupr( wchar_t *_String);





__declspec(dllimport) errno_t __cdecl _wcsupr_s_l(
     wchar_t*  _String,
                         size_t    _Size,
                     _locale_t _Locale
    );

extern "C++" { template <size_t _Size> inline errno_t __cdecl _wcsupr_s_l(wchar_t (&_String)[_Size], _locale_t _Locale) throw() { return _wcsupr_s_l(_String, _Size, _Locale); } }





__declspec(dllimport) wchar_t* __cdecl _wcsupr_l( wchar_t *_String, _locale_t _Locale);








__declspec(dllimport) size_t __cdecl wcsxfrm(
      wchar_t*       _Destination,
                                        wchar_t const* _Source,
              size_t         _MaxCount
    );



__declspec(dllimport) size_t __cdecl _wcsxfrm_l(
      wchar_t*       _Destination,
                                        wchar_t const* _Source,
              size_t         _MaxCount,
                                      _locale_t      _Locale
    );


__declspec(dllimport) int __cdecl wcscoll(
     wchar_t const* _String1,
     wchar_t const* _String2
    );


__declspec(dllimport) int __cdecl _wcscoll_l(
       wchar_t const* _String1,
       wchar_t const* _String2,
     _locale_t      _Locale
    );


__declspec(dllimport) int __cdecl _wcsicoll(
     wchar_t const* _String1,
     wchar_t const* _String2
    );


__declspec(dllimport) int __cdecl _wcsicoll_l(
       wchar_t const* _String1,
       wchar_t const* _String2,
     _locale_t      _Locale
    );


__declspec(dllimport) int __cdecl _wcsncoll(
     wchar_t const* _String1,
     wchar_t const* _String2,
                           size_t         _MaxCount
    );


__declspec(dllimport) int __cdecl _wcsncoll_l(
     wchar_t const* _String1,
     wchar_t const* _String2,
                           size_t         _MaxCount,
                       _locale_t      _Locale
    );


__declspec(dllimport) int __cdecl _wcsnicoll(
     wchar_t const* _String1,
     wchar_t const* _String2,
                           size_t         _MaxCount
    );


__declspec(dllimport) int __cdecl _wcsnicoll_l(
     wchar_t const* _String1,
     wchar_t const* _String2,
                           size_t         _MaxCount,
                       _locale_t      _Locale
    );



//-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
//
// Inline C++ Overloads
//
//-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

extern "C++" {

    
    
    inline wchar_t* __cdecl wcschr( wchar_t* _String, wchar_t _C)
    {
        return const_cast<wchar_t*>(wcschr(static_cast<wchar_t const*>(_String), _C));
    }

    
    inline wchar_t* __cdecl wcspbrk( wchar_t* _String,  wchar_t const* _Control)
    {
        return const_cast<wchar_t*>(wcspbrk(static_cast<wchar_t const*>(_String), _Control));
    }

    
    inline wchar_t* __cdecl wcsrchr( wchar_t* _String,  wchar_t _C)
    {
        return const_cast<wchar_t*>(wcsrchr(static_cast<wchar_t const*>(_String), _C));
    }

     
    
    inline wchar_t* __cdecl wcsstr( wchar_t* _String,  wchar_t const*_SubStr)
    {
        return const_cast<wchar_t*>(wcsstr(static_cast<wchar_t const*>(_String), _SubStr));
    }

}
#line 565 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt\\corecrt_wstring.h"



//-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
//
// Non-Standard Names
//
//-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

    


#line 578 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt\\corecrt_wstring.h"

     __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_wcsdup" ". See online help for details."))
    __declspec(dllimport) wchar_t* __cdecl wcsdup(
         wchar_t const* _String
        );

    

#line 587 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt\\corecrt_wstring.h"

    // Declarations of functions defined in oldnames.lib:
    

     __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_wcsicmp" ". See online help for details."))
    __declspec(dllimport) int __cdecl wcsicmp(
         wchar_t const* _String1,
         wchar_t const* _String2
        );

     __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_wcsnicmp" ". See online help for details."))
    __declspec(dllimport) int __cdecl wcsnicmp(
         wchar_t const* _String1,
         wchar_t const* _String2,
                               size_t         _MaxCount
        );

    __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_wcsnset" ". See online help for details."))
    
    __declspec(dllimport) wchar_t* __cdecl wcsnset(
         wchar_t* _String,
                                 wchar_t  _Value,
                                 size_t   _MaxCount
        );

    __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_wcsrev" ". See online help for details."))
    
    __declspec(dllimport) wchar_t* __cdecl wcsrev(
         wchar_t* _String
        );

    __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_wcsset" ". See online help for details."))
    
    __declspec(dllimport) wchar_t* __cdecl wcsset(
         wchar_t* _String,
              wchar_t  _Value
        );

    __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_wcslwr" ". See online help for details."))
    
    __declspec(dllimport) wchar_t* __cdecl wcslwr(
         wchar_t* _String
        );

    __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_wcsupr" ". See online help for details."))
    
    __declspec(dllimport) wchar_t* __cdecl wcsupr(
         wchar_t* _String
        );

     __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_wcsicoll" ". See online help for details."))
    __declspec(dllimport) int __cdecl wcsicoll(
         wchar_t const* _String1,
         wchar_t const* _String2
        );

#line 644 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt\\corecrt_wstring.h"



} __pragma(pack(pop))

#line 650 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt\\corecrt_wstring.h"
#line 15 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt\\string.h"




__pragma(pack(push, 8)) extern "C" {







    
    __declspec(dllimport) errno_t __cdecl strcpy_s(
         char*       _Destination,
                                 rsize_t     _SizeInBytes,
                               char const* _Source
        );

    
    __declspec(dllimport) errno_t __cdecl strcat_s(
         char*       _Destination,
                                    rsize_t     _SizeInBytes,
                                  char const* _Source
        );

    
    __declspec(dllimport) errno_t __cdecl strerror_s(
         char*  _Buffer,
                                 size_t _SizeInBytes,
                                 int    _ErrorNumber);

    
    __declspec(dllimport) errno_t __cdecl strncat_s(
         char*       _Destination,
                                    rsize_t     _SizeInBytes,
              char const* _Source,
                                    rsize_t     _MaxCount
        );

    
    __declspec(dllimport) errno_t __cdecl strncpy_s(
         char*       _Destination,
                                 rsize_t     _SizeInBytes,
           char const* _Source,
                                 rsize_t     _MaxCount
        );

    
    __declspec(dllimport) char*  __cdecl strtok_s(
                         char*       _String,
                                char const* _Delimiter,
          char**      _Context
        );

#line 71 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt\\string.h"

__declspec(dllimport) void* __cdecl _memccpy(
     void*       _Dst,
                                  void const* _Src,
                                  int         _Val,
                                  size_t      _MaxCount
    );

extern "C++" { template <size_t _Size> inline errno_t __cdecl strcat_s(char (&_Destination)[_Size], char const* _Source) throw() { return strcat_s(_Destination, _Size, _Source); } }







#pragma warning(push)
#pragma warning(disable: 28719) 
#pragma warning(disable: 28726) 
    char* __cdecl strcat( char *_Destination, char const* _Source);




#pragma warning(pop)

#line 98 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt\\string.h"


int __cdecl strcmp(
     char const* _Str1,
     char const* _Str2
    );


__declspec(dllimport) int __cdecl _strcmpi(
     char const* _String1,
     char const* _String2
    );


__declspec(dllimport) int __cdecl strcoll(
     char const* _String1,
     char const* _String2
    );


__declspec(dllimport) int __cdecl _strcoll_l(
       char const* _String1,
       char const* _String2,
     _locale_t   _Locale
    );

extern "C++" { template <size_t _Size> inline errno_t __cdecl strcpy_s(char (&_Destination)[_Size], char const* _Source) throw() { return strcpy_s(_Destination, _Size, _Source); } }





#pragma warning(push)
#pragma warning(disable: 28719) 
#pragma warning(disable: 28726) 
char* __cdecl strcpy( char *_Destination, char const* _Source);




#pragma warning(pop)


__declspec(dllimport) size_t __cdecl strcspn(
     char const* _Str,
     char const* _Control
    );




#line 150 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt\\string.h"


__declspec(dllimport) __declspec(allocator) char* __cdecl _strdup(
     char const* _Source
    );



#line 159 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt\\string.h"



 
__declspec(dllimport) char*  __cdecl _strerror(
     char const* _ErrorMessage
    );


__declspec(dllimport) errno_t __cdecl _strerror_s(
     char*       _Buffer,
                             size_t      _SizeInBytes,
                       char const* _ErrorMessage
    );

extern "C++" { template <size_t _Size> inline errno_t __cdecl _strerror_s(char (&_Buffer)[_Size], char const* _ErrorMessage) throw() { return _strerror_s(_Buffer, _Size, _ErrorMessage); } }






 
__declspec(dllimport) char* __cdecl strerror(
     int _ErrorMessage
    );

extern "C++" { template <size_t _Size> inline errno_t __cdecl strerror_s(char (&_Buffer)[_Size], int _ErrorMessage) throw() { return strerror_s(_Buffer, _Size, _ErrorMessage); } }






__declspec(dllimport) int __cdecl _stricmp(
     char const* _String1,
     char const* _String2
    );


__declspec(dllimport) int __cdecl _stricoll(
     char const* _String1,
     char const* _String2
    );


__declspec(dllimport) int __cdecl _stricoll_l(
       char const* _String1,
       char const* _String2,
     _locale_t   _Locale
    );


__declspec(dllimport) int __cdecl _stricmp_l(
       char const* _String1,
       char const* _String2,
     _locale_t   _Locale
    );


size_t __cdecl strlen(
     char const* _Str
    );


__declspec(dllimport) errno_t __cdecl _strlwr_s(
     char*  _String,
                         size_t _Size
    );

extern "C++" { template <size_t _Size> inline errno_t __cdecl _strlwr_s(char (&_String)[_Size]) throw() { return _strlwr_s(_String, _Size); } }




__declspec(dllimport) char* __cdecl _strlwr( char *_String);





__declspec(dllimport) errno_t __cdecl _strlwr_s_l(
     char*     _String,
                         size_t    _Size,
                     _locale_t _Locale
    );

extern "C++" { template <size_t _Size> inline errno_t __cdecl _strlwr_s_l(char (&_String)[_Size], _locale_t _Locale) throw() { return _strlwr_s_l(_String, _Size, _Locale); } }





__declspec(dllimport) char* __cdecl _strlwr_l( char *_String, _locale_t _Locale);






extern "C++" { template <size_t _Size> inline errno_t __cdecl strncat_s(char (&_Destination)[_Size], char const* _Source, size_t _Count) throw() { return strncat_s(_Destination, _Size, _Source, _Count); } }






__declspec(dllimport) char* __cdecl strncat( char *_Destination, char const* _Source, size_t _Count);








__declspec(dllimport) int __cdecl strncmp(
     char const* _Str1,
     char const* _Str2,
                           size_t      _MaxCount
    );


__declspec(dllimport) int __cdecl _strnicmp(
     char const* _String1,
     char const* _String2,
                           size_t      _MaxCount
    );


__declspec(dllimport) int __cdecl _strnicmp_l(
     char const* _String1,
     char const* _String2,
                           size_t      _MaxCount,
                       _locale_t   _Locale
    );


__declspec(dllimport) int __cdecl _strnicoll(
     char const* _String1,
     char const* _String2,
                           size_t      _MaxCount
    );


__declspec(dllimport) int __cdecl _strnicoll_l(
     char const* _String1,
     char const* _String2,
                           size_t      _MaxCount,
                       _locale_t   _Locale
    );


__declspec(dllimport) int __cdecl _strncoll(
     char const* _String1,
     char const* _String2,
                           size_t      _MaxCount
    );


__declspec(dllimport) int __cdecl _strncoll_l(
     char const* _String1,
     char const* _String2,
                           size_t      _MaxCount,
                       _locale_t   _Locale
    );

__declspec(dllimport) size_t __cdecl __strncnt(
     char const* _String,
                        size_t      _Count
    );

extern "C++" { template <size_t _Size> inline errno_t __cdecl strncpy_s(char (&_Destination)[_Size], char const* _Source, size_t _Count) throw() { return strncpy_s(_Destination, _Size, _Source, _Count); } }






__declspec(dllimport) char* __cdecl strncpy( char *_Destination, char const* _Source, size_t _Count);
















__declspec(dllimport) size_t __cdecl strnlen(
     char const* _String,
                           size_t      _MaxCount
    );



    
    



    



    static __inline size_t __cdecl strnlen_s(
         char const* _String,
                               size_t      _MaxCount
        )
    {
        return _String == 0 ? 0 : strnlen(_String, _MaxCount);
    }

#line 380 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt\\string.h"


__declspec(dllimport) errno_t __cdecl _strnset_s(
     char*  _String,
                                size_t _SizeInBytes,
                                int    _Value,
                                size_t _MaxCount
    );

extern "C++" { template <size_t _Size> inline errno_t __cdecl _strnset_s(char (&_Destination)[_Size], int _Value, size_t _Count) throw() { return _strnset_s(_Destination, _Size, _Value, _Count); } }






__declspec(dllimport) char* __cdecl _strnset( char *_Destination, int _Value, size_t _Count);








__declspec(dllimport) char const * __cdecl strpbrk(
     char const* _Str,
     char const* _Control
    );

__declspec(dllimport) char* __cdecl _strrev(
     char* _Str
    );


__declspec(dllimport) errno_t __cdecl _strset_s(
     char*  _Destination,
                                    size_t _DestinationSize,
                                    int    _Value
    );

extern "C++" { template <size_t _Size> inline errno_t __cdecl _strset_s(char (&_Destination)[_Size], int _Value) throw() { return _strset_s(_Destination, _Size, _Value); } }





char* __cdecl _strset( char *_Destination, int _Value);






__declspec(dllimport) size_t __cdecl strspn(
     char const* _Str,
     char const* _Control
    );

 
__declspec(dllimport) char* __cdecl strtok(
     char*       _String,
            char const* _Delimiter
    );


__declspec(dllimport) errno_t __cdecl _strupr_s(
     char*  _String,
                         size_t _Size
    );

extern "C++" { template <size_t _Size> inline errno_t __cdecl _strupr_s(char (&_String)[_Size]) throw() { return _strupr_s(_String, _Size); } }




__declspec(dllimport) char* __cdecl _strupr( char *_String);





__declspec(dllimport) errno_t __cdecl _strupr_s_l(
     char*     _String,
                         size_t    _Size,
                     _locale_t _Locale
    );

extern "C++" { template <size_t _Size> inline errno_t __cdecl _strupr_s_l(char (&_String)[_Size], _locale_t _Locale) throw() { return _strupr_s_l(_String, _Size, _Locale); } }





__declspec(dllimport) char* __cdecl _strupr_l( char *_String, _locale_t _Locale);








__declspec(dllimport) size_t __cdecl strxfrm(
      char*       _Destination,
                                        char const* _Source,
               size_t      _MaxCount
    );



__declspec(dllimport) size_t __cdecl _strxfrm_l(
      char*       _Destination,
                                        char const* _Source,
               size_t      _MaxCount,
                                      _locale_t   _Locale
    );




extern "C++"
{
    
    inline char* __cdecl strchr( char* const _String,  int const _Ch)
    {
        return const_cast<char*>(strchr(static_cast<char const*>(_String), _Ch));
    }

    
    inline char* __cdecl strpbrk( char* const _String,  char const* const _Control)
    {
        return const_cast<char*>(strpbrk(static_cast<char const*>(_String), _Control));
    }

    
    inline char* __cdecl strrchr( char* const _String,  int const _Ch)
    {
        return const_cast<char*>(strrchr(static_cast<char const*>(_String), _Ch));
    }

     
    inline char* __cdecl strstr( char* const _String,  char const* const _SubString)
    {
        return const_cast<char*>(strstr(static_cast<char const*>(_String), _SubString));
    }
}
#line 528 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt\\string.h"





    
    
     __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_strdup" ". See online help for details."))
    __declspec(dllimport) char* __cdecl strdup(
         char const* _String
        );
    

    // Declarations of functions defined in oldnames.lib:
     __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_strcmpi" ". See online help for details."))
    __declspec(dllimport) int __cdecl strcmpi(
         char const* _String1,
         char const* _String2
        );

     __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_stricmp" ". See online help for details."))
    __declspec(dllimport) int __cdecl stricmp(
         char const* _String1,
         char const* _String2
        );

    __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_strlwr" ". See online help for details."))
    __declspec(dllimport) char* __cdecl strlwr(
         char* _String
        );

     __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_strnicmp" ". See online help for details."))
    __declspec(dllimport) int __cdecl strnicmp(
         char const* _String1,
         char const* _String2,
                               size_t      _MaxCount
        );

    __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_strnset" ". See online help for details."))
    __declspec(dllimport) char* __cdecl strnset(
         char*  _String,
                                 int    _Value,
                                 size_t _MaxCount
        );

    __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_strrev" ". See online help for details."))
    __declspec(dllimport) char* __cdecl strrev(
         char* _String
        );

    __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_strset" ". See online help for details."))
    char* __cdecl strset(
         char* _String,
              int   _Value);

    __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_strupr" ". See online help for details."))
    __declspec(dllimport) char* __cdecl strupr(
         char* _String
        );

#line 589 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt\\string.h"



} __pragma(pack(pop))

#line 595 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt\\string.h"
#line 596 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt\\string.h"
#line 7 "C:\\Users\\serpentiem\\source\\repos\\ddmk\\Core\\Includes.h"




#line 1 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\Windows.h"
#line 1 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\shared\\winapifamily.h"
/*

Copyright (c) Microsoft Corporation. All rights reserved.

Module Name:

    winapifamily.h

Abstract:

    Master include file for API family partitioning.

*/






#pragma warning(push)
#pragma warning(disable:4001) 
#line 23 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\shared\\winapifamily.h"
#pragma once
#line 25 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\shared\\winapifamily.h"

#line 1 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\shared\\winpackagefamily.h"
/*

Copyright (c) Microsoft Corporation. All rights reserved.

Module Name:

    winpackagefamily.h

Abstract:

    API family partitioning based on packages.

*/






#pragma warning(push)
#pragma warning(disable:4001) 
#line 23 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\shared\\winpackagefamily.h"
#pragma once
#line 25 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\shared\\winpackagefamily.h"



#line 29 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\shared\\winpackagefamily.h"

/*
 * PARTITIONS based on packages are each #undef'ed below, and then will be #define-ed
 * to be either 1 or 0 or depending on the active WINAPI_FAMILY.
 */
























/* 
 * PARTITIONS for feature packages. Each package might be active for one or more editions
 */


























#pragma warning(pop)
#line 89 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\shared\\winpackagefamily.h"
#line 90 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\shared\\winpackagefamily.h"

#line 92 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\shared\\winpackagefamily.h"
#line 27 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\shared\\winapifamily.h"

/*
 * When compiling C and C++ code using SDK header files, the development
 * environment can specify a target platform by #define-ing the
 * pre-processor symbol WINAPI_FAMILY to one of the following values.
 * Each FAMILY value denotes an application family for which a different
 * subset of the total set of header-file-defined APIs are available.
 * Setting the WINAPI_FAMILY value will effectively hide from the
 * editing and compilation environments the existence of APIs that
 * are not applicable to the family of applications targeting a
 * specific platform.
 */

/* In Windows 10, WINAPI_PARTITIONs will be used to add additional  
 * device specific APIs to a particular WINAPI_FAMILY.  
 * For example, when writing Windows Universal apps, specifying 
 * WINAPI_FAMILY_APP will hide phone APIs from compilation.  
 * However, specifying WINAPI_PARTITION_PHONE_APP=1 additionally, will         
 * unhide any API hidden behind the partition, to the compiler.

 * The following partitions are currently defined:
 * WINAPI_PARTITION_DESKTOP            // usable for Desktop Win32 apps (but not store apps)
 * WINAPI_PARTITION_APP                // usable for Windows Universal store apps
 * WINAPI_PARTITION_PC_APP             // specific to Desktop-only store apps
 * WINAPI_PARTITION_PHONE_APP          // specific to Phone-only store apps
 * WINAPI_PARTITION_SYSTEM             // specific to System applications
 * WINAPI_PARTITION_GAMES              // specific to games and apps

 * The following partitions are indirect partitions and defined in 
 * winpackagefamily.h. These partitions are related to package based 
 * partitions. For example, specifying WINAPI_PARTITION_SERVER=1 will light up
 * any API hidden behind the package based partitions that are bound to 
 * WINAPI_PARTITION_SERVER, to the compiler.
 * WINAPI_PARTITION_SERVER             // specific to Server applications
*/

/*
 * The WINAPI_FAMILY values of 0 and 1 are reserved to ensure that
 * an error will occur if WINAPI_FAMILY is set to any
 * WINAPI_PARTITION value (which must be 0 or 1, see below).
 */






/* The value of WINAPI_FAMILY_DESKTOP_APP may change in future SDKs. */
/* Additional WINAPI_FAMILY values may be defined in future SDKs. */

/*
 * For compatibility with Windows 8 header files, the following
 * synonym for WINAPI_FAMILY_PC_APP is temporarily #define'd.
 * Use of this symbol should be considered deprecated.
 */


/*
 * If no WINAPI_FAMILY value is specified, then all APIs available to
 * Windows desktop applications are exposed.
 */


#line 91 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\shared\\winapifamily.h"

/*
 * API PARTITONs are part of an indirection mechanism for mapping between
 * individual APIs and the FAMILYs to which they apply.
 * Each PARTITION is a category or subset of named APIs.  PARTITIONs
 * are permitted to have overlapping membership -- some single API
 * might be part of more than one PARTITION.  PARTITIONS are each #define-ed 
 * to be either 1 or 0 or depending on the platform at which the app is targeted.
 */

/*
 * The mapping between families and partitions is summarized here.
 * An X indicates that the given partition is active for the given
 * platform/family.
 *
 *                                +---------------------------+
 *                                |      *Partition*          |
 *                                +---+---+---+---+---+---+---+
 *                                |   |   |   |   |   |   |   |
 *                                |   |   |   |   |   |   |   |
 *                                |   |   |   | P |   |   |   |
 *                                |   |   |   | H |   |   |   |
 *                                | D |   |   | O |   |   |   |
 *                                | E |   | P | N | S | S |   |
 *                                | S |   | C | E | Y | E | G |
 *                                | K |   | _ | _ | S | R | A |
 *                                | T | A | A | A | T | V | M |
 * +-------------------------+----+ O | P | P | P | E | E | E |
 * |     *Platform/Family*       \| P | P | P | P | M | R | S |
 * +------------------------------+---+---+---+---+---+---+---+
 * | WINAPI_FAMILY_DESKTOP_APP    | X | X | X |   |   |   |   |
 * +------------------------------+---+---+---+---+---+---+---+
 * |      WINAPI_FAMILY_PC_APP    |   | X | X |   |   |   |   |
 * +------------------------------+---+---+---+---+---+---+---+
 * |   WINAPI_FAMILY_PHONE_APP    |   | X |   | X |   |   |   |
 * +----------------------------- +---+---+---+---+---+---+---+
 * |      WINAPI_FAMILY_SYSTEM    |   |   |   |   | X |   |   |
 * +----------------------------- +---+---+---+---+---+---+---+
 * |      WINAPI_FAMILY_SERVER    |   |   |   |   | X | X |   |
 * +------------------------------+---+---+---+---+---+---+---+
 * |       WINAPI_FAMILY_GAMES    |   |   |   |   |   |   | X |
 * +------------------------------+---+---+---+---+---+---+---+
 *
 * The table above is encoded in the following expressions,
 * each of which evaluates to 1 or 0.
 *
 * Whenever a new family is added, all of these expressions
 * need to be reconsidered.
 */


#line 148 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\shared\\winapifamily.h"



#line 152 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\shared\\winapifamily.h"






#line 159 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\shared\\winapifamily.h"





#line 165 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\shared\\winapifamily.h"



#line 169 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\shared\\winapifamily.h"





#line 175 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\shared\\winapifamily.h"

/*
 * SYSTEM is the only partition defined here.
 * All other System based editions are defined as packages
 * on top of the System partition.
 * See winpackagefamily.h for packages level partitions
 */





#line 188 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\shared\\winapifamily.h"

/*
 * For compatibility with Windows Phone 8 header files, the following
 * synonym for WINAPI_PARTITION_PHONE_APP is temporarily #define'd.
 * Use of this symbol should be regarded as deprecated.
 */


/*
 * Header files use the WINAPI_FAMILY_PARTITION macro to assign one or
 * more declarations to some group of partitions.  The macro chooses
 * whether the preprocessor will emit or omit a sequence of declarations
 * bracketed by an #if/#endif pair.  All header file references to the
 * WINAPI_PARTITION_* values should be in the form of occurrences of
 * WINAPI_FAMILY_PARTITION(...).
 *
 * For example, the following usage of WINAPI_FAMILY_PARTITION identifies
 * a sequence of declarations that are part of both the Windows Desktop
 * Partition and the Windows-Phone-Specific Store Partition:
 *
 *     #if WINAPI_FAMILY_PARTITION(WINAPI_PARTITION_DESKTOP | WINAPI_PARTITION_PHONE_APP)
 *     ...
 *     #endif // WINAPI_FAMILY_PARTITION(WINAPI_PARTITION_DESKTOP | WINAPI_PARTITION_PHONE_APP)
 *
 * The comment on the closing #endif allow tools as well as people to find the
 * matching #ifdef properly.
 *
 * Usages of WINAPI_FAMILY_PARTITION may be combined, when the partitition definitions are
 * related.  In particular one might use declarations like
 * 
 *     #if WINAPI_FAMILY_PARTITION(WINAPI_PARTITION_APP) && !WINAPI_FAMILY_PARTITION(WINAPI_PARTITION_DESKTOP)
 *
 * or
 *
 *     #if WINAPI_FAMILY_PARTITION(WINAPI_PARTITION_APP) && !WINAPI_FAMILY_PARTITION(WINAPI_PARTITION_PHONE_APP)
 *
 * Direct references to WINAPI_PARTITION_ values (eg #if !WINAPI_FAMILY_PARTITION_...)
 * should not be used.
 */ 


/*
 * Macro used to #define or typedef a symbol used for selective deprecation
 * of individual methods of a COM interfaces that are otherwise available
 * for a given set of partitions.
 */


/*
 * For compatibility with Windows 8 header files, the following
 * symbol is temporarily conditionally #define'd.  Additional symbols
 * like this should be not defined in winapifamily.h, but rather should be
 * introduced locally to the header files of the component that needs them.
 */


#line 245 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\shared\\winapifamily.h"



#pragma warning(pop)
#line 250 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\shared\\winapifamily.h"
#line 251 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\shared\\winapifamily.h"

#line 253 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\shared\\winapifamily.h"
#line 2 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\Windows.h"

/*++ BUILD Version: 0001    Increment this if a change has global effects

Copyright (c) Microsoft Corporation. All rights reserved.

Module Name:


    windows.h

Abstract:

    Master include file for Windows applications.

--*/





#line 1 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\shared\\sdkddkver.h"
/*

Copyright (c) Microsoft Corporation. All rights reserved.

Module Name:

    sdkddkver.h

Abstract:

    Master include file for versioning windows SDK/DDK.

*/






#pragma warning(push)
#pragma warning(disable:4668) 
#line 23 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\shared\\sdkddkver.h"
#pragma warning(disable:4001) 
#line 25 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\shared\\sdkddkver.h"

#pragma once

//
// _WIN32_WINNT version constants
//














//
// _WIN32_IE_ version constants
//

















//
// IE <-> OS version mapping
//
// NT4 supports IE versions 2.0 -> 6.0 SP1







// Win98 supports IE versions 4.01 -> 6.0 SP1

// Win98SE supports IE versions 5.0 -> 6.0 SP1

// WinME supports IE versions 5.5 -> 6.0 SP1

// Win2k supports IE versions 5.01 -> 6.0 SP1



















//
// NTDDI version constants
//





















































//
// masks for version macros
//





//
// macros to extract various version fields from the NTDDI version
//





































#line 207 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\shared\\sdkddkver.h"


//
// if versions aren't already defined, default to most current
//






#line 219 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\shared\\sdkddkver.h"




// set NTDDI_VERSION based on _WIN32_WINNT




#line 229 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\shared\\sdkddkver.h"



#line 233 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\shared\\sdkddkver.h"
#line 234 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\shared\\sdkddkver.h"












// set _WIN32_IE based on _WIN32_WINNT


#line 250 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\shared\\sdkddkver.h"

#line 252 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\shared\\sdkddkver.h"

#line 254 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\shared\\sdkddkver.h"

#line 256 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\shared\\sdkddkver.h"

#line 258 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\shared\\sdkddkver.h"





#line 264 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\shared\\sdkddkver.h"


#line 267 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\shared\\sdkddkver.h"
#line 268 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\shared\\sdkddkver.h"

//
// Sanity check for compatible versions
//




#line 277 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\shared\\sdkddkver.h"



#line 281 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\shared\\sdkddkver.h"



#line 285 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\shared\\sdkddkver.h"



#line 289 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\shared\\sdkddkver.h"



#line 293 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\shared\\sdkddkver.h"



#line 297 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\shared\\sdkddkver.h"

#line 299 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\shared\\sdkddkver.h"



#pragma warning(pop)


#line 306 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\shared\\sdkddkver.h"
#line 307 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\shared\\sdkddkver.h"

#line 309 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\shared\\sdkddkver.h"

#line 23 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\Windows.h"





#pragma once
#line 30 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\Windows.h"

#pragma region Application Family or OneCore Family



/*  If defined, the following flags inhibit definition
 *     of the indicated items.
 *
 *  NOGDICAPMASKS     - CC_*, LC_*, PC_*, CP_*, TC_*, RC_
 *  NOVIRTUALKEYCODES - VK_*
 *  NOWINMESSAGES     - WM_*, EM_*, LB_*, CB_*
 *  NOWINSTYLES       - WS_*, CS_*, ES_*, LBS_*, SBS_*, CBS_*
 *  NOSYSMETRICS      - SM_*
 *  NOMENUS           - MF_*
 *  NOICONS           - IDI_*
 *  NOKEYSTATES       - MK_*
 *  NOSYSCOMMANDS     - SC_*
 *  NORASTEROPS       - Binary and Tertiary raster ops
 *  NOSHOWWINDOW      - SW_*
 *  OEMRESOURCE       - OEM Resource values
 *  NOATOM            - Atom Manager routines
 *  NOCLIPBOARD       - Clipboard routines
 *  NOCOLOR           - Screen colors
 *  NOCTLMGR          - Control and Dialog routines
 *  NODRAWTEXT        - DrawText() and DT_*
 *  NOGDI             - All GDI defines and routines
 *  NOKERNEL          - All KERNEL defines and routines
 *  NOUSER            - All USER defines and routines
 *  NONLS             - All NLS defines and routines
 *  NOMB              - MB_* and MessageBox()
 *  NOMEMMGR          - GMEM_*, LMEM_*, GHND, LHND, associated routines
 *  NOMETAFILE        - typedef METAFILEPICT
 *  NOMINMAX          - Macros min(a,b) and max(a,b)
 *  NOMSG             - typedef MSG and associated routines
 *  NOOPENFILE        - OpenFile(), OemToAnsi, AnsiToOem, and OF_*
 *  NOSCROLL          - SB_* and scrolling routines
 *  NOSERVICE         - All Service Controller routines, SERVICE_ equates, etc.
 *  NOSOUND           - Sound driver routines
 *  NOTEXTMETRIC      - typedef TEXTMETRIC and associated routines
 *  NOWH              - SetWindowsHook and WH_*
 *  NOWINOFFSETS      - GWL_*, GCL_*, associated routines
 *  NOCOMM            - COMM driver routines
 *  NOKANJI           - Kanji support stuff.
 *  NOHELP            - Help engine interface.
 *  NOPROFILER        - Profiler interface.
 *  NODEFERWINDOWPOS  - DeferWindowPos routines
 *  NOMCX             - Modem Configuration Extensions
 */





#line 84 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\Windows.h"




















#line 105 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\Windows.h"






#line 112 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\Windows.h"



#line 116 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\Windows.h"



#line 120 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\Windows.h"



#line 124 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\Windows.h"



#line 128 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\Windows.h"



#line 132 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\Windows.h"





#line 138 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\Windows.h"




#line 143 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\Windows.h"
#line 144 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\Windows.h"







#line 152 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\Windows.h"
#line 153 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\Windows.h"



#pragma warning(disable:4514)

#pragma warning(disable:4103)
#line 160 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\Windows.h"

#pragma warning(push)
#line 163 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\Windows.h"
#pragma warning(disable:4001)
#pragma warning(disable:4201)
#pragma warning(disable:4214)
#line 167 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\Windows.h"
#line 1 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.28.29333\\include\\excpt.h"
//
// excpt.h
//
//      Copyright (c) Microsoft Corporation. All rights reserved.
//
// The declarations of the compiler-dependent intrinsics, support functions, and
// keywords which implement the structured exception handling extensions.
//
#pragma once




#pragma warning(push)
#pragma warning(disable: 4514 4820 )

__pragma(pack(push, 8)) extern "C" {



// Exception disposition return values
typedef enum _EXCEPTION_DISPOSITION
{
    ExceptionContinueExecution,
    ExceptionContinueSearch,
    ExceptionNestedException,
    ExceptionCollidedUnwind
} EXCEPTION_DISPOSITION;



// SEH handler












#line 46 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.28.29333\\include\\excpt.h"
    

        struct _EXCEPTION_RECORD;
        struct _CONTEXT;
        struct _DISPATCHER_CONTEXT;

         EXCEPTION_DISPOSITION __cdecl __C_specific_handler(
                struct _EXCEPTION_RECORD*   ExceptionRecord,
                void*                       EstablisherFrame,
             struct _CONTEXT*            ContextRecord,
             struct _DISPATCHER_CONTEXT* DispatcherContext
            );

    #line 60 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.28.29333\\include\\excpt.h"
#line 61 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.28.29333\\include\\excpt.h"



// SEH intrinsics







unsigned long __cdecl _exception_code(void);
void *        __cdecl _exception_info(void);
int           __cdecl _abnormal_termination(void);



// Defined values for the exception filter expression






} __pragma(pack(pop))

#pragma warning(pop) 
#line 168 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\Windows.h"
#line 1 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.28.29333\\include\\stdarg.h"
//
// stdarg.h
//
//      Copyright (c) Microsoft Corporation. All rights reserved.
//
// The C Standard Library <stdarg.h> header.
//
#pragma once




#pragma warning(push)
#pragma warning(disable: 4514 4820 )

__pragma(pack(push, 8)) extern "C" {










} __pragma(pack(pop))

#pragma warning(pop) 
#line 169 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\Windows.h"
#line 170 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\Windows.h"

#line 1 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\shared\\windef.h"


/****************************************************************************
*                                                                           *
* windef.h -- Basic Windows Type Definitions                                *
*                                                                           *
* Copyright (c) Microsoft Corporation. All rights reserved.                 *
*                                                                           *
****************************************************************************/




#pragma once


extern "C" {
#line 19 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\shared\\windef.h"





#line 1 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\shared\\minwindef.h"
/****************************************************************************
*                                                                           *
* minwindef.h -- Basic Windows Type Definitions for minwin partition        *
*                                                                           *
* Copyright (c) Microsoft Corporation. All rights reserved.                 *
*                                                                           *
****************************************************************************/




#pragma once

#line 1 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\shared\\specstrings.h"



/***
*specstrings.h - support for markers for documenting the semantics of APIs
*
*       Copyright (c) Microsoft Corporation. All rights reserved.
*
*       [Public]
****/

/*************************************************************************
* See specstrings_strict.h for documentation of all user visible macros.
*************************************************************************/


#pragma once
#line 19 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\shared\\specstrings.h"


#pragma warning(push)
#pragma warning(disable:4668) 
#line 24 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\shared\\specstrings.h"



 

#line 30 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\shared\\specstrings.h"
  
 #line 32 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\shared\\specstrings.h"

 



  
 #line 39 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\shared\\specstrings.h"

 
  
  
 #line 44 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\shared\\specstrings.h"

#line 46 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\shared\\specstrings.h"

/* Begin compatibility fixes required for Win8/VS2012 RTM sal.h */











/* End compatibility fixes required for Win8/VS2012 RTM sal.h */



/* This version symbol is deprecated in favor of __SAL_H_VER */


#line 67 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\shared\\specstrings.h"


extern "C" {
#line 71 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\shared\\specstrings.h"

/* version specific fixes to bring sal.h upto date */


























#line 100 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\shared\\specstrings.h"












#line 113 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\shared\\specstrings.h"



















































































/* __in_ecount_or_z(c) specifies semantics like strncmp, where a string
 * parameter is either null terminated, or valid up to c elements.
 */




/* Provide default definition to be overridden when needed */


/* Must protect redfinitions of macros to workaround rc.exe issues. */








#line 216 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\shared\\specstrings.h"
#line 217 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\shared\\specstrings.h"

/************************************************************************
 New extensions to sal.h follow here.
*************************************************************************/


































































































#line 320 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\shared\\specstrings.h"









/* Internal defintions */

















///////////////////////////////////////////////////////////////////////////////
//
// Low Level Memory Correctness annotations
// 
// These are the implementation details for the Memory Correctness annotations
// that support checking of kernel/user memory handling within kernel mode code.
//
///////////////////////////////////////////////////////////////////////////////








///////////////////////////////////////////////////////////////////////////////
//
// High Level Memory Correctness annotations
//
// These annotations form the expected interface for users to the Memory Correctness
// annotations that support checking of kernel/user memory handling within
// kernel mode code.
// 
///////////////////////////////////////////////////////////////////////////////







#line 380 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\shared\\specstrings.h"





































/* integer related macros */




















/* Penetration review macros */




















/* useful PFD related macros */


/* Windows Internal */




#line 468 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\shared\\specstrings.h"



/* declare stub functions for macros */







/**************************************************************************
* SAL 2 extensions for Windows-specific APIs.
***************************************************************************/

// Annotation for parameters that are not used in any way by the function.
// Unlike _Reserved_, an _Unreferenced_parameter_ pointer need not be NULL.


#line 488 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\shared\\specstrings.h"

// Pointer parameters that are freed by the function, and thus the pointed-to
// memory should not be used after return.


#line 494 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\shared\\specstrings.h"


#line 497 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\shared\\specstrings.h"


// Functions which behave like realloc in that they may succeed by
// freeing one block of memory and allocating another, or may fail, in
// which case the original block is still valid, or may be used to
// free memory directly by requesting that the new block is of size
// zero.  We do not say here whether the before may be null, we leave
// that to the annotation on the argument










// NLS APIs allow strings to be specified either by an element count or
// null termination. Unlike _In_reads_or_z_, this is not whichever comes
// first, but based on whether the size is negative or not.




// Minifilter CompletionContext parameters on the pre-operation callback
// default to NULL.  For return type FLT_PREOP_SUCCESS_WITH_CALLBACK or
// FLT_PREOP_SYNCHRONIZE, it may be set to NULL or a valid pointer.  For all
// other returns, it must be NULL.





// Minifilter ConnectionCookie parameters on the port connect notify callback
// default to NULL.  On successful return, it may be set to NULL or non-NULL,
// but it must be NULL on failure.





//
// A common pattern is to pass an "_Inout_ PCHAR* ppBuf" of size "_Inout_ DWORD* pSize"
// to a function that writes to **pBuf, incrementing *ppBuf to point to one
// past the last written byte. Thus the length of the write is
// (*ppBuf - Old(*ppBuf)). The size of the remaining unwritten capacity
// is written to *pSize.
//
// This pattern is frequently used when progressively filling a
// large buffer in chunks
// (e.g. when reading from a network interface in a driver).
//
// It is expected that these supplementary annotations would be used inside an
// _At_, like so:
//
// _At_(*ppBuf, _Writes_and_advances_ptr_(*pBufSize))
// HRESULT WriteChunkOfData(_Inout_ PCHAR* ppBuf, _Inout_ DWORD* pBufSize);
//









#line 566 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\shared\\specstrings.h"










#line 577 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\shared\\specstrings.h"

//
// Gets the current error code (as returned by GetLastError()), and stores
// in _Curr_ as a postcondition. This is currently approximated by assuming
// that GetLastError() always returns a failed error code. This is not a
// completely accurate approximation, but reasonable.
//


//
// Indicates the function simply translates the given Win32 error code into an HRESULT
// with broadly the same semantics as HRESULT_FROM_WIN32().
//
// This convenience macro allows analyzers to understand the many bespoke error-translation
// functions as simple translators that can be treated as equivalent to HRESULT_FROM_WIN32().
// This results in fewer false positives and unnecessary path explorations. This is because
// for analysis, the specific translations rarely matter, it is more important to know the
// that function cannot fail and the conditions under which it will return an error-range
// HRESULT and when a success-range HRESULT.
//










#line 608 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\shared\\specstrings.h"

//
// Indicates the function just directly translates the given NTSTATUS error code into an HRESULT.
//
// This convenience macro allows analyzers to understand the many bespoke error-translation
// functions as simple translators that can be treated as equivalent to HRESULT_FROM_NT().
// This results in fewer false positives and unnecessary path explorations. This is because
// for analysis, the specific translations rarely matter.
//







#line 625 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\shared\\specstrings.h"

//
// Indicates the funtion just translates the result of GetLastError() into an HRESULT.
//
// This convenience macro allows analyzers to understand the many bespoke GetLastError-translation
// functions as simple translators that will always return a failure-value HRESULT (these functions
// are almost never meant to be called when GetLastError() could return 0).
// This results in fewer false positives and unnecessary path explorations. This is because
// for analysis, the specific translations rarely matter.
//







#line 643 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\shared\\specstrings.h"


}
#line 647 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\shared\\specstrings.h"






















/**************************************************************************
* This include should always be the last thing in this file.
* Must avoid redfinitions of macros to workaround rc.exe issues.
***************************************************************************/

#line 1 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\shared\\specstrings_strict.h"
//
//    Copyright (C) Microsoft.  All rights reserved.
//
/************************************************************************* 
*  This file documents all the macros approved for use in windows source
*  code. It includes some experimental macros which should only be used by
*  experts.
*
*  DO NOT include this file directly.  This file is include after
*  specstrings.h. So we can undefine every possible old definition including
*  private internal macros people should not be using, as well as macros from
*  sal.h.  Macros are redefined here in a way to cause syntax errors when used
*  incorrectly during a normal build when specstrings.h is included and
*  __SPECSTRINGS_STRICT_LEVEL is defined.
*
*  There are several levels of strictness, each level includes the behavior of
*  all previous levels.
*
*  0 - Disable strict checking 
*  1 - Break on unapproved macros and misuse of statement 
*      macros such as __fallthrough (default)
*  2 - Deprecated some old macros that should not be used
*  3 - Use VS 2005 Source Annotation to make sure every macro 
*      is used in the right context. For example placing __in on a return 
*      parameter will result in an error.
************************************************************************/


#line 30 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\shared\\specstrings_strict.h"
/************************************************************************
*  Introduction
*
*  specstrings.h provides a set of annotations to describe how a function uses
*  its parameters - the assumptions it makes about them, and the guarantees it
*  makes upon finishing.
* 
*  Annotations must be placed before a function parameter's type or its return
*  type. There are two basic classes of common annotations buffer annotations
*  and advanced annotations.  Buffer annotations describe how functions use
*  their pointer parameters, and advanced annotations either describe
*  complex/unusual buffer behavior, or provide additional information about a
*  parameter that is not otherwise expressible.
* 
*  Buffer Annotations
* 
*  The most important annotations in SpecStrings.h provide a consistent way to
*  annotate buffer parameters or return values for a function. Each of these
*  annotations describes a single buffer (which could be a string, a
*  fixed-length or variable-length array, or just a pointer) that the function
*  interacts with: where it is, how large it is, how much is initialized, and
*  what the function does with it.
* 
*  The appropriate macro for a given buffer can be constructed using the table
*  below.  Just pick the appropriate values from each category, and combine
*  them together with a leading underscore. Some combinations of values do not
*  make sense as buffer annotations. Only meaningful annotations can be added
*  to your code; for a list of these, see the buffer annotation definitions
*  section.
* 
*  Only a single buffer annotation should be used for each parameter.
* 
*  |------------|------------|---------|--------|----------|---------------|
*  |   Level    |   Usage    |  Size   | Output | Optional |  Parameters   |
*  |------------|------------|---------|--------|----------|---------------|
*  | <>         | <>         | <>      | <>     | <>       | <>            |
*  | _deref     | _in        | _ecount | _full  | _opt     | (size)        |
*  | _deref_opt | _out       | _bcount | _part  |          | (size,length) |
*  |            | _inout     |         |        |          |               |
*  |            |            |         |        |          |               |
*  |------------|------------|---------|--------|----------|---------------|
*
*  Note: "<>" represents the empty string.
* 
*  Level: Describes the buffer pointer's level of indirection from the
*  parameter or return value 'p'.
* 
*  <>         : p is the buffer pointer.
*  _deref     : *p is the buffer pointer. p must not be NULL.
*  _deref_opt : *p may be the buffer pointer. p may be NULL, in which case the 
*               rest of the annotation is ignored.
* 
*  Usage: Describes how the function uses the buffer.
* 
*  <> : The buffer is not accessed. If used on the return value or with
*  _deref, the function will provide the buffer, and it will be uninitialized
*  at exit.  Otherwise, the caller must provide the buffer. This should only
*  be used for alloc and free functions.
*
*  _in : The function will only read from the buffer. The caller must provide
*  the buffer and initialize it.
*
*  _out : The function will only write to the buffer. If used on the return
*  value or with _deref, the function will provide the buffer and initialize
*  it.  Otherwise, the caller must provide the buffer, and the function will
*  initialize it.
*
*  _inout : The function may freely read from and write to the buffer. The
*  caller must provide the buffer and initialize it. If used with _deref, the
*  buffer may be reallocated by the function.
*
*  Size: Describes the total size of the buffer. This may be less than the
*  space actually allocated for the buffer, in which case it describes the
*  accessible amount.
* 
*  <> : No buffer size is given. If the type specifies the buffer size (such
*  as with LPSTR and LPWSTR), that amount is used. Otherwise, the buffer is
*  one element long. Must be used with _in, _out, or _inout.
*
*  _ecount : The buffer size is an explicit element count.
*
*  _bcount : The buffer size is an explicit byte count.
* 
*  Output: Describes how much of the buffer will be initialized by the
*  function. For _inout buffers, this also describes how much is initialized
*  at entry. Omit this category for _in buffers; they must be fully
*  initialized by the caller.
* 
*  <> : The type specifies how much is initialized. For instance, a function
*  initializing an LPWSTR must NULL-terminate the string.
*
*  _full : The function initializes the entire buffer.
*
*  _part : The function initializes part of the buffer, and explicitly
*  indicates how much.
* 
*  Optional: Describes if the buffer itself is optional.
* 
*  <>   : The pointer to the buffer must not be NULL.
*
*  _opt : The pointer to the buffer might be NULL. It will be checked before
*  being dereferenced.
* 
*  Parameters: Gives explicit counts for the size and length of the buffer.
* 
*  <> : There is no explicit count. Use when neither _ecount nor _bcount is
*  used.
*
*  (size) : Only the buffer's total size is given. Use with _ecount or _bcount
*  but not _part.
*
*  (size,length) : The buffer's total size and initialized length are
*  given. Use with _ecount_part and _bcount_part.
* 
*  ----------------------------------------------------------------------------
*  Buffer Annotation Examples
* 
*  LWSTDAPI_(BOOL) StrToIntExA(
*      LPCSTR pszString,  //  No annotation required, const implies __in.
*      DWORD dwFlags,
*      __out int *piRet   // A pointer whose dereference will be filled in.
*  );
* 
*  void MyPaintingFunction(
*      __in HWND hwndControl,     //  An initialized read-only parameter.
*      __in_opt HDC hdcOptional,  //  An initialized read-only parameter that 
*                                 //  might be NULL.
*      __inout IPropertyStore *ppsStore // An initialized parameter that 
*                                       // may be freely used and modified.
*  );
* 
*  LWSTDAPI_(BOOL) PathCompactPathExA(
*      __out_ecount(cchMax) LPSTR pszOut, //  A string buffer with cch elements
*                                         //  that will be '\0' terminated 
*                                         //  on exit.
*      LPCSTR pszSrc,                     //  No annotation required, 
*                                         //  const implies __in.
*      UINT cchMax,                              
*      DWORD dwFlags
*  );
* 
*  HRESULT SHLocalAllocBytes(
*      size_t cb,
*      __deref_bcount(cb) T **ppv //  A pointer whose dereference will be set
*                                 //  to an uninitialized buffer with cb bytes.
*  );
* 
*  __inout_bcount_full(cb) : A buffer with cb elements that is fully
*  initialized at entry and exit, and may be written to by this function.
* 
*  __out_ecount_part(count, *countOut) : A buffer with count elements that
*  will be partially initialized by this function. The function indicates how
*  much it initialized by setting *countOut.
* 
************************************************************************/


#pragma once
#line 1 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\shared\\specstrings_undef.h"
//
//    Copyright (C) Microsoft.  All rights reserved.
//





































































































































































































































































































































































































































































#line 189 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\shared\\specstrings_strict.h"















































































































































































































/************************************************************************
*  SAL 2 _Ouptr_ family of annotations
************************************************************************/








































/************************************************************************
*  Orcas SAL
************************************************************************/





















/************************************************************************
*  Advanced Annotations
* 
*  Advanced annotations describe behavior that is not expressible with the
*  regular buffer macros. These may be used either to annotate buffer
*  parameters that involve complex or conditional behavior, or to enrich
*  existing annotations with additional information.
* 
*  _At_(expr, annotes) : annotation list annotes applies to target 'expr'
*
*  _When_(expr, annotes) : annotation list annotes applies when 'expr' is true
*
*  __success(expr) T f() : <expr> indicates whether function f succeeded or
*  not. If <expr> is true at exit, all the function's guarantees (as given
*  by other annotations) must hold. If <expr> is false at exit, the caller
*  should not expect any of the function's guarantees to hold. If not used,
*  the function must always satisfy its guarantees. Added automatically to
*  functions that indicate success in standard ways, such as by returning an
*  HRESULT.
* 
*  __out_awcount(expr, size) T *p : Pointer p is a buffer whose size may be
*  given in either bytes or elements. If <expr> is true, this acts like
*  __out_bcount. If <expr> is false, this acts like __out_ecount. This
*  should only be used to annotate old APIs.
* 
*  __in_awcount(expr, size) T* p : Pointer p is a buffer whose size may be given
*  in either bytes or elements. If <expr> is true, this acts like
*  __in_bcount. If <expr> is false, this acts like __in_ecount. This should
*  only be used to annotate old APIs.
* 
*  __nullterminated T* p : Pointer p is a buffer that may be read or written
*  up to and including the first '\0' character or pointer. May be used on
*  typedefs, which marks valid (properly initialized) instances of that type
*  as being null-terminated.
* 
*  __nullnullterminated T* p : Pointer p is a buffer that may be read or
*  written up to and including the first sequence of two '\0' characters or
*  pointers. May be used on typedefs, which marks valid instances of that
*  type as being double-null terminated.
* 
*  __reserved T v : Value v must be 0/NULL, reserved for future use.
* 
*  __checkReturn T f(); : Return value of f must not be ignored by callers
*  of this function.
* 
*  __typefix(ctype) T v : Value v should be treated as an instance of ctype,
*  rather than its declared type when considering validity.
* 
*  __override T f(); : Specify C#-style 'override' behaviour for overriding
*  virtual methods.
* 
*  __callback T f(); : Function f can be used as a function pointer.
* 
*  __format_string T p : Pointer p is a string that contains % markers in
*  the style of printf.
* 
*  __blocksOn(resource) f(); : Function f blocks on the resource 'resource'.
* 
*  __fallthrough : Annotates switch statement labels where fall-through is
*  desired, to distinguish from forgotten break statements.
* 
*  __range(low_bnd, up_bnd) int f(): The return from the function "f" must
*  be in the inclusive numeric range [low_bnd, up_bnd].
*
*  __in_range(low_bnd, up_bnd) int i : Precondition that integer i must be
*  in the inclusive numeric range [low_bnd, up_bnd].
* 
*  __out_range(low_bnd, up_bnd) int i : Postcondition that integer i must be
*  in the inclusive numeric range [low_bnd, up_bnd].
* 
*  __deref_in_range(low_bnd, up_bnd) int* pi : Precondition that integer *pi
*  must be in the inclusive numeric range [low_bnd, up_bnd].
*
*  __deref_out_range(low_bnd, up_bnd) int* pi : Postcondition that integer
*  *pi must be in the inclusive numeric range [low_bnd, up_bnd].
*
*  __deref_inout_range(low_bnd, up_bnd) int* pi : Invariant that the integer
*  *pi must be in the inclusive numeric range [low_bnd, up_bnd].
*
*  The first argument of a range macro may also be a C relational operator
*  (<,>,!=, ==, <=, >=).
*  
*  __range(rel_op, j) int f(): Postcondition that "f() rel_op j" must be
*  true.  Note that j may be a expression known only at runtime.
*
*  __in_range(rel_op, j) int i : Precondition that "i rel_op j" must be
*  true.  Note that j may be a expression known only at runtime.
* 
*  __out_range(rel_op, j) int i : Postcondition that integer "i rel_op j"
*  must be true.  Note that j may be a expression known only at runtime.
* 
*  __deref_in_range(rel_op, j) int *pi : Precondition that "*pi rel_op j"
*  must be true.  Note that j may be a expression known only at runtime.
*
*  __deref_out_range(rel_op, j) int *pi : Postcondition that "*pi rel_op j"
*  must be true.  Note that j may be a expression known only at runtime.
*
*  __deref_inout_range(rel_op, j) int *pi : Invariant that "*pi rel_op j"
*  must be true.  Note that j may be a expression known only at runtime.
*
*  __range_max(a, b) int f(): Postcondition f acts as 'max', returns larger
*  of a and b.  Note that a and b may be expressions known only at runtime.
*
*  __range_min(a, b) int f(): Postcondition f acts as 'min', returns smaller
*  of a and b.  Note that a and b may be expressions known only at runtime.
*
*  __in_bound int i : Precondition that integer i must be bound, but the
*  exact range can't be specified at compile time.  __in_range should be
*  used if the range can be explicitly stated.
*
*  __out_bound int i : Postcondition that integer i must be bound, but the
*  exact range can't be specified at compile time.  __out_range should be
*  used if the range can be explicitly stated.
* 
*  __deref_out_bound int pi : Postcondition that integer *pi must be bound,
*  but the exact range can't be specified at compile time.
*  __deref_out_range should be used if the range can be explicitly stated.
* 
*  __assume_bound(expr); : Assume that the expression is bound to some known
*  range. This can be used to suppress integer overflow warnings on integral
*  expressions that are known to be bound due to reasons not explicit in the
*  code. Use as a statement in the body of a function.
*
*  __analysis_assume_nulltermianted(expr); : Assume that the expression is
*  a null terminated buffer. Use this to suppress tool noise specific to
*  nulltermination warnings, and capture deeper invariants tools can not
*  discover. 
* 
*  __allocator void f(): Function allocates memory using an integral size
*  argument
*
*  void myfree(__deallocate(Mem) void *p) : Memory is freed, no longer usable
*  upon return, and p may not be null.
*
*  void myfree(__deallocate_opt(Mem) void *p) : Memory is freed, no longer
*  usable upon return, and p may be null.
*
*  void free(__post_invalid void* x): Mark memory as untouchable when 
*  function returns.
*
*  ----------------------------------------------------------------------------
*  Advanced Annotation Examples
* 
*  __success(return == TRUE) LWSTDAPI_(BOOL) 
*  PathCanonicalizeA(__out_ecount(MAX_PATH) LPSTR pszBuf, LPCSTR pszPath);
*  //  pszBuf is only guaranteed to be null-terminated when TRUE is returned.
* 
*  // Initialized LPWSTRs are null-terminated strings.
*  typedef __nullterminated WCHAR* LPWSTR;
* 
*  __out_ecount(cch) __typefix(LPWSTR) void *psz;
*  // psz is a buffer parameter which will be a null-terminated WCHAR string 
*  // at exit, and which initially contains cch WCHARs.
* 
************************************************************************/





































/*************************************************************************** 
* Expert Macros
***************************************************************************/




/*************************************************************************** 
* Macros to classify fields of structures.
*                          Structure Annotations
*
*   The buffer annotations are a convenient way of describing
*   relationships between buffers and their size on a function by
*   function basis. Very often struct or class data members have similar
*   invariants, which can be expressed directly on the type.
*
*   Similar to our buffer annotations we can summarize all the various
*   structure annotations by one choosing an element from each column of
*   this table to build a composite annotation.
*
*           +--------------------------------------------------+
*           | Selector |  Units  |    Size/Init     | Optional |
*           |----------+---------+------------------+----------|
*           | __field  | _ecount | (size)           | empty    |
*           |----------+---------+------------------+----------|
*           | __struct | _bcount | _full(size)      | _opt     |
*           |----------+---------+------------------+----------|
*           |          | _xcount | _part(size,init) |          |
*           +--------------------------------------------------+
*
*   Note that empty represents the empty string. Sometime arguments need
*   to be "floated" to the left to give us a valid annotation name. For
*   example the naive combination __field_ecount(size)_opt is actually
*   written as __field_ecount_opt(size). Not all possible combinations
*   are currently supported or sensible. See specstrings_strict.h for
*   the currently supported set. Those that are supported are documented
*   below.
*
*Summary of Elements
*
*   Selector
*
*                __field
*                        The annotation should only be placed in front
*                        of data members of structures and classes. The
*                        data members are pointers to a block of data.
*                        The annotations describe properties about the
*                        size of the block of data. This can be used for
*
*                __struct
*                        The annotation should only be placed at the
*                        beginning of the definition of a structure or
*                        class. These annotations are used when a struct
*                        or class is used as a "header" that is
*                        allocated inline with a block of data and there
*                        is no apparent field that represents the tail
*                        end of the structure.
*
*   Units
*
*                _ecount
*                        All size and initialization values are in terms
*                        of elements of the appropriate type
*
*                _bcount
*                        All size and initialization values are in terms
*                        of raw byte sizes.
*
*                _xcount
*                        The size or initialization values cannot be
*                        properly expressed as a simple byte or element
*                        count, and instead a place holder is used to
*                        document the relationship.
*
*   Size/Init
*           All the size/init expressions can contain references to
*           other fields in the struct or class.
*
*                (size)
*                        The size of the buffer is determined by the
*                        expression size. Unless, the type of the buffer
*                        provides more information nothing is know about
*                        how much of this data is initialized. For
*                        example, if the data member happens to be a
*                        string type such as LPSTR. It is assumed that
*                        the data is initialized to the first '\0'.
*
*                _full(size)
*                        The size of the buffer is determined by the
*                        expression size and all the data in the buffer
*                        is guaranteed to be initialized.
*
*                _part(size,init)
*                        The size of the buffer is determined by the
*                        expression size and all the data in the buffer
*                        is guaranteed to be initialized up to init
*                        elements or bytes.
*
*   Optional
*
*                empty
*                        The pointer to the block of memory is never
*                        NULL
*
*                _opt
*                        The pointer to the block of memory is may be
*                        NULL
*
*     
*   // Basic Usage of Struct Annotations                         
*   #include <stdio.h>                                           
*   #include <stdlib.h>                                          
*   struct buf_s {                                               
*    int sz;                                                     
*    __field_bcount_full(sz)                                     
*    char *buf;                                                  
*   };                                                           
*   void InitBuf(__out struct *buf_s b,int sz) {                 
*        b->buf = calloc(sz,sizeof(char));                       
*        b->sz = sz;                                             
*   }                                                            
*   void WriteBuf(__in FILE *fp,__in struct *buf_s b) {          
*     fwrite(b->buf,b->sz,sizeof(char),fp);                      
*   }                                                            
*   void ReadBuf(__in FILE *fp,__inout struct *buf_s b) {        
*     fread(b->buf,b->sz,sizeof(char),fp);                       
*   }                                                            
*                                                                 
*                                                                 
*                                                                 
*   // Inline Allocated Buffer                                   
*   struct buf_s {                                               
*    int sz;                                                     
*    __field_bcount(sz)                                          
*    char buf[1];                                                
*   };                                                           
*   void WriteBuf(__in FILE *fp,__in struct *buf_s b) {          
*     fwrite(&(b->buf),b->sz,sizeof(char),fp);                   
*   }                                                            
*   void ReadBuf(__in FILE *fp,__inout struct *buf_s b) {        
*     fread(&(b->buf),b->sz,sizeof(char),fp);                    
*   }                                                            
*                                                                 
*                                                                 
*                                                                 
*   // Embedded Header Structure                                 
*   __struct_bcount(sz)                                          
*   struct buf_s {                                               
*    int sz;                                                     
*   };                                                           
*   void WriteBuf(__in FILE *fp,__in struct *buf_s b) {          
*     fwrite(&b,b->sz,sizeof(char),fp);                          
*   }                                                            
*   void ReadBuf(__in FILE *fp,__inout struct *buf_s b) {        
*     fread(&b,b->sz,sizeof(char),fp);                           
*   }                                                            
*
*
****************************************************************************/






















/*************************************************************************** 
* Macros to classify the entrypoints and indicate their category.
*
* Pre-defined control point categories include: RPC, KERNEL, GDI.
*
* Pre-defined control point macros include:
*  __rpc_entry, __kernel_entry, __gdi_entry.
***************************************************************************/





/*************************************************************************** 
* Macros to track untrusted data and their validation. The list of untrusted
* sources include:
*
* FILE                     - File reading stream or API
* NETWORK                  - Socket readers
* INTERNET                 - WinInet and WinHttp readers
* USER_REGISTRY            - HKCU portions of the registry
* USER_MODE                - Parameters to kernel entry points
* RPC                      - Parameters to RPC entry points 
* DRIVER                   - Device driver 
***************************************************************************/





/************************************************************************** 
* Macros to tag file parsing code. Predefined formats include:
*  PNG                     - Portable Network Graphics
*  JPEG                    - Joint Photographic Experts Group
*  BMP                     - Bitmap
*  RC_BMP                  - Resource bitmap
*  WMF                     - Windows Metafile
*  EMF                     - Windows Enhanced Metafile
*  GIF                     - Graphics Interchange Format
*  MIME_TYPE               - MIME type from header tokens
*  MAIL_MONIKER            - MAIL information refered by URL moniker
*  HTML                    - HyperText Markup Language
*  WMPHOTO                 - Windows media photo
*  OE_VCARD                - Outlook Express virtual card
*  OE_CONTACT              - Outlook Express contact
*  MIDI                    - Musical Instrument Digital Interface
*  LDIF                    - LDAP Data Interchange Format
*  AVI                     - Audio Visual Interchange
*  ACM                     - Audio Compression Manager
**************************************************************************/






/*************************************************************************** 
* Macros to track the code content in the file. The type of code
* contents currently tracked:
*
* NDIS_DRIVER                   - NDIS Device driver 
***************************************************************************/


/*************************************************************************** 
* Macros to track the code content in the class. The type of code
* contents currently tracked:
*
* DCOM                          - Class implementing DCOM
***************************************************************************/


/*************************************************************************
* Macros to tag encoded function pointers
**************************************************************************/








/************************************************************************* 
* __analysis_assume(expr) : Expert macro use only when directed. Use this to
* tell static analysis tools like PREfix and PREfast about a non-coded
* assumption that you wish the tools to assume. The assumption will be
* understood by those tools. By default there is no dynamic checking or
* static checking of the assumption in any build.
*
* To obtain dynamic checking wrap this macro in your local version of a debug
* assert.
* Please do not put function calls in the expression because this is not
* supported by all tools:
*  __analysis_assume(GetObject () != NULL); // DO NOT DO THIS
*
*************************************************************************/



/************************************************************************* 
* __analysis_hint(hint_sym) : Expert macro use only when
* directed. Use this to influence certain analysis heuristics
* used by the tools. These hints do not describe the semantics
* of functions but simply direct the tools to act in a certain
* way.
*
* Current hints that are supported are:
*
* INLINE   - inline this function during analysis overrides any
*            default heuristics 
* NOINLINE - do not inline this function during analysis overrides 
*            and default heuristics
*************************************************************************/


/************************************************************************* 
* Macros to encode abstract properties of values. Used by SALadt.h
*************************************************************************/






/************************************************************************* 
* Macros used by Prefast for Drivers 
* 
*  __possibly_notnullterminated :
*
*  Used for return values of parameters or functions that do not
*  guarantee nulltermination in all cases.
*
*************************************************************************/


/************************************************************************* 
* Advanced macros
* 
*  __volatile 
* The __volatile annotation identifies a global variable or
* structure field that: 
*   1) is not declared volatile; 
*   2) is accessed concurrently by multiple threads.
*
* The __deref_volatile annotation identifies a global variable
* or structure field that stores a pointer to some data that:
*   1) is not declared volatile; 
*   2) is accessed concurrently by multiple threads.
*
* Prefast uses these annotations to find patterns of code that
* may result in unexpected re-fetching of the global variable
* into a local variable.
*
* We also provide two complimentary annotations __nonvolatile
* and __deref_nonvolatile that could be used to suppress Prefast
*
* re-fetching warnings on variables that are known either:
*   1) not to be in danger of being re-fetched or,
*   2) not to lead to incorrect results if they are re-fetched
*
*************************************************************************/





/************************************************************************* 
* Macros deprecated with strict level greater then 1.
**************************************************************************/


























































#line 1065 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\shared\\specstrings_strict.h"
/* Define soon to be deprecated macros to nops. */

























































/************************************************************************* 
* Definitions to force a compile error when macros are used improperly.
* Relies on VS 2005 source annotations.
*************************************************************************/


#line 1130 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\shared\\specstrings_strict.h"







/**************************************************************************
*  This should go away. It's only for __success which we should split into.
*  __success and __typdecl_sucess
***************************************************************************/











































#line 1185 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\shared\\specstrings_strict.h"
#line 1186 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\shared\\specstrings_strict.h"
#line 1187 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\shared\\specstrings_strict.h"
#line 675 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\shared\\specstrings.h"
#line 676 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\shared\\specstrings.h"

/*
 If no SAL 2 appears to have been defined (_Outptr_ is a representative choice)
 then we must be operating in a downlevel build environment (such as VS10).
 We also test against the compiler version to identify a downlevel environment,
 as VS11 is the minimum required for SAL 2 support.

 If we are operating in a downlevel build environment (such as VS10)
 we need to undefine the following symbols before including driverspecs.h
 or we will end up referencing SAL 2 implementation symbols and cause
 build failures.
*/





#line 694 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\shared\\specstrings.h"

#line 1 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\shared\\driverspecs.h"
/****************************************************************************
**                                                                             *
* DriverSpecs.h - markers for documenting the semantics of driver APIs        *
*                 See also <SpecStrings.h>                                    *
*                                                                             *
* Version 1.2.10                                                              *
*                                                                             *
* Copyright (c) Microsoft Corporation. All rights reserved.                   *
*                                                                             *
\*****************************************************************************/

/****************************************************************************
** NOTE                                                                        *
* NOTE                                                                        *
* NOTE                                                                        *
*   The macro bodies in this file are subject to change without notice.       *
*   Attempting to use the annotations in the macro bodies directly is not     *
*   supported.                                                                *
* NOTE                                                                        *
* NOTE                                                                        *
* NOTE                                                                        *
\*****************************************************************************/

/****************************************************************************
** The annotations described by KernelSpecs.h and DriverSpecs.h, taken together,
* are used to annotate drivers.  Many of the annotations are applicable to
* user space code (including subsystems) as well as to drivers.
*
* DriverSpecs.h contains those annotations which are appropriate to userspace
* code, or which might appear in headers that are shared between user space
* and kernel space.  In the case of annotations which might appear in such a
* shared header, but which are meaningless in user space, the annotations are
* #defined to nothing in DriverSpecs.h.
*
* KernelSpecs.h contains those annotations which either will only appear in
* kernel code or headers; or which might appear in shared headers.  In the
* latter case, it is assumed that DriverSpecs.h has been #included, and
* the anntoations are re-defined (using #undef) to give them a meaningful
* value.  In general, documentation for the shared-header annotations appears
* in DriverSpecs.h.
*
* Many annotations are context dependent.  They only apply to certain versions
* of Windows, or only to certain classes of driver.  These rules can be written
* using something like _When_(NTDDI_VERSION >= NTDDI_WINXP, ...)
* which causes the rule only to apply to Windows XP and later.  Many of these
* symbols are already defined in various Windows headers.
*
* To facilitate using this sort of conditional rule, we collect here the
* various known symbols that are (or reasonably might) be used in such
* a conditional annotation.  Some are speculative in that the symbol has
* not yet been defined because there are no known uses of it yet.
*
* Where the symbol already exists its relevant header is
* noted below (excluding the "really well known" ones).
*
* Each symbol is listed with the currently known possible values.
*
* Some symbols are marked as #define symbols -- they are used with #ifdef
* operators only.  To use them in _When_, use something like
* _When_(__drv_defined(NT), ...).
*
* WDK Version (copied for convenience from sdkddkver.h)
*     NTDDI_VERSION: NTDDI_WIN2K NTDDI_WIN2KSP1 NTDDI_WIN2KSP2 NTDDI_WIN2KSP3
*                    NTDDI_WIN2KSP4 NTDDI_WINXP NTDDI_WINXPSP1 NTDDI_WINXPSP2
*                    NTDDI_WS03 NTDDI_WS03SP1 NTDDI_VISTA
*     The WDK version is taken as the WDM version as well.
*
* OS Version: (copied for convenience from sdkddkver.h)
*     _WIN32_WINNT: _WIN32_WINNT_NT4 _WIN32_WINNT_WIN2K _WIN32_WINNT_WINXP
*                   _WIN32_WINNT_WS03 _WIN32_WINNT_LONGHORN
*     WINVER: 0x030B 0x0400 0x0500 0x0600
*     NT (#define symbol)
* (sdkddkver.h also defines symbols for IE versions should they be needed.)
*
* Compiler Version:
*     _MSC_VER: too many to list.
*     _MSC_FULL_VER: too many to list.
*
* KMDF Version:  (Currently defined/used only in makefiles.)
*     KMDF_VERSION_MAJOR: 1
*
* UMDF Version:  (Currently defined/used only in makefiles.)
*     UMDF_VERSION_MAJOR: 1
*
* Architecture kinds:
*     __WIN64 (#define symbols)
*     _X86_
*     _AMD64_
*     _IA64_
*
* Machine Architectures:
*     _M_IX86
*     _M_AMD64
*     _M_IA64
*
* Driver Kind (NYI: "not yet implemented")
*   Typically these will be defined in the most-common header for a
*   particular driver (or in individual source files if appropriate).
*   These are not intended to necessarily be orthogonal: more than one might
*   apply to a particular driver.
*     _DRIVER_TYPE_BUS: 1                // NYI
*     _DRIVER_TYPE_FUNCTIONAL: 1         // NYI
*     _DRIVER_TYPE_MINIPORT: 1           // NYI
*     _DRIVER_TYPE_STORAGE: 1            // NYI
*     _DRIVER_TYPE_DISPLAY: 1            // NYI
*     _DRIVER_TYPE_FILESYSTEM: 1
*     _DRIVER_TYPE_FILESYSTEM_FILTER: 1
*
* NDIS driver version: (see ndis.h for much more detail.)
*   These can be used to both identify an NDIS driver and to check the version.
*     NDIS40 NDIS50 NDIS51 NDIS60 (#defined symbols)
*     NDIS_PROTOCOL_MAJOR_VERSION.NDIS_PROTOCOL_MINOR_VERSION: 4.0 5.0 5.1 6.0
*     And many others in ndis.h (including MINIPORT)
*
\*****************************************************************************/




// In case driverspecs.h is included directly (and w/o specstrings.h)




#line 1 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\shared\\sdv_driverspecs.h"

// general purpose save 
//-----------------------

// general purpose retrieve 
//-----------------------


// NDIS AdapterContext save 
//-----------------------











#line 23 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\shared\\sdv_driverspecs.h"
#line 126 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\shared\\driverspecs.h"



#pragma once
#line 131 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\shared\\driverspecs.h"


extern "C" {
#line 135 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\shared\\driverspecs.h"























































































































#line 255 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\shared\\driverspecs.h"

    
    
    
    
    
    
    
    
    
    
    

    
    

#line 272 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\shared\\driverspecs.h"

    // Callback with high IRQL level will never actually be called above 
    // 'level'
    



    // core macros: these provide syntatic wrappers to make other uses
    // simpler.
    //
    // For example:
    //   __drv_in(__drv_nonconstant __setsIRQL)

    
    
    
    
    
    
    

    
    
    
    



    // Internal macros for convenience
    


    //
    // __drv_unit
    //
    // Flags for compilation units that indicated specifically what kind of
    // code it is.
    // These should be coded as early as possible in any compilation unit
    // (.c/.cpp file) that doesn't get the correct default.     Whether before
    // or after __internal_kernel_driver is immaterial as long as it will
    // successfully parse.
    //
    // Indicate that the code is kernel, but not driver, code.
    


    // Indicate that the code is kernel, driver, code.
    


    // Indicate that the code is a user mode driver.
    


    // Indicate that the code is ordinary user mode code.
    



    // These are needed for backwards compatability.
    









    // ---------------------------------------------------------------------
    // Syntatic utilities:
    //
    // Needed to make the annotations convenient to use.
    //
    // So we can use a macro name that might be used in #ifdef context,
    // where it's defined with no value.
    // This should only be used inside a _When_ condition.
    //
    

    // ---------------------------------------------------------------------
    // Callback properties:
    //
    // __drv_functionClass(x)
    //
    // Flag that the the annotated function
    // is a member of that function class. Some class names are recognized
    // by PREfast itself for special treatment.
    // This can be tested by the condition function _In_function_class_()
    //
    

    // ---------------------------------------------------------------------
    // Resources:
    //
    // __drv_acquiresResource(kind)
    // __drv_releasesResource(kind)
    // __drv_acquiresResourceGlobal(kind,param)
    // __drv_releasesResourceGlobal(kind,param)
    // __drv_mustHold(kind)
    // __drv_neverHold(kind)
    // __drv_mustHoldGlobal(kind,param)
    // __drv_neverHoldGlobal(kind,param)
    //
    // Flag that the annotated parameter acquires a resource of type kind.
    //

    
    


    


    //
    // Flag that the annotated parameter releases a resource of type kind.
    //
    
    

    


    //
    // Flag that the annotated object acquires a global resource named by param
    //
    
    

    


    //
    // Flag that the annotated object releases a global resource named by param
    //
    
    

    


    //
    // Flag that the annotated parameter must hold a resource of type kind
    //
    
    


    




    //
    // Flag that the annotated object must hold a global resource named by param
    //
    
    

    


    //
    // Flag that the annotated parameter must never hold a resource of type kind
    //
    
    


    


    //
    // Flag that the annotated object must never hold a global resource
    // of type kind named by param.
    //
    
    

    


    // Predicates to determine if a resource is held
    
    

    //
    // ---------------------------------------------------------------------
    // IRQL annotations:
    //
    // _IRQL_raises_(irql)
    // _IRQL_requires_(irql)
    // _IRQL_requires_max_(irql)
    // _IRQL_requires_min_(irql)
    // _IRQL_saves_
    // _IRQL_saves_global_(kind,param)
    // _IRQL_restores_
    // _IRQL_restores_global_(kind,param)
    // _IRQL_always_function_min_(irql)
    // _IRQL_always_function_max_(irql)
    // _IRQL_requires_same_
    // _IRQL_uses_cancel_
    // 
    // Legacy IRQL annotations:
    //   Legacy annotation:        Use instead:
    //   __drv_setsIRQL            (Obsolete, use _IRQL_raises_)
    //   __drv_raisesIRQL          _IRQL_raises_
    //   __drv_requiresIRQL        _IRQL_requires_
    //   __drv_maxIRQL             _IRQL_requires_max_
    //   __drv_minIRQL             _IRQL_requires_min_
    //   __drv_savesIRQL           _IRQL_saves_
    //   __drv_savesIRQLGlobal     _IRQL_saves_global_
    //   __drv_restoresIRQL        _IRQL_restores_
    //   __drv_restoresIRQLGlobal  _IRQL_restores_global_
    //   __drv_minFunctionIRQL     _IRQL_always_function_min_
    //   __drv_maxFunctionIRQL     _IRQL_always_function_max_
    //   __drv_sameIRQL            _IRQL_requires_same_
    //   __drv_useCancelIRQL       _IRQL_uses_cancel_
    //

    //
    // The function exits at IRQL irql (obsolete, use _IRQL_raises_)
    //
    

    //
    // The function exits at IRQL irql, but this may only raise the irql.
    //
    
    

    //
    // The called function must be entered at IRQL level
    //
    
    

    //
    // The maximum IRQL at which the function may be called.
    //
    
    

    //
    // The minimum IRQL at which the function may be called.
    //
    
    

    //
    // The current IRQL is saved in the annotated parameter
    //
    
    

    //
    // The current IRQL is saved in the (otherwise anonymous) global object
    // identified by kind and further refined by param.
    //
    
    

    //
    // The current IRQL is restored from the annotated parameter
    //
    
    

    //
    // The current IRQL is restored from the (otherwise anonymous) global
    // object identified by kind and further refined by param.
    //
    
    

    //
    // The minimum IRQL to which the function can lower itself.  The IRQL
    // at entry is assumed to be that value unless overridden.
    //
    
    

    //
    // The maximum IRQL to which the function can raise itself.
    //
    
    

    //
    // The function must exit with the same IRQL it was entered with.
    // (It may change it but it must restore it.)
    //
    
    

    //
    // The annotated parameter contains the cancelIRQL, which will be restored
    // by the called function.
    //
    
    

    //
    // The annotated parameter is an IRQL that will be restored and a new (probably the same)
    // value will be inserted.  (Use this in preference to directly coding it.)
    
    


    // ---------------------------------------------------------------------
    // Specific function behaviors

    // The annotated function clears the requirement that DoInitializeing
    // is cleared (or not).
    
    

    

    // This is (or is like) IoGetDmaAdapter: look for misuse of DMA pointers
    
    

    

    // ---------------------------------------------------------------------
    // Function and out parameter return values.
    //
    // __drv_valueIs(<list>)
    //
    // The function being annotated will return each of the specified values
    // during simulation.  The items in the list are <relational op><constant>,
    // e.g. ==0 or <0.
    // This is a ; separated list of values.  The internal parser will accept
    // a comma-separated list.  In the future __VA_ARGS__ could be used.
    // See the documentation for use of this.
    //

    
    


    // ---------------------------------------------------------------------
    // Additional parameter checking.
    //
    // __drv_constant
    // __drv_nonConstant
    // __drv_strictTypeMatch(mode)
    // __drv_strictType(type,mode)
    //
    // The actual parameter must evaluate to a constant (not a const).
    //
    

    //
    // The actual parameter may never evaluate to a numeric constant
    // (exclusive of a const symbol).
    //
    

    //
    // The actual parameter must match the type of the annotated formal
    // within the specifications set by mode.
    //
    
    


    //
    // The actual parameter must match the type of typename (below)
    // within the specifications set by mode.
    //
     // currently 1/2 args
    

    //
    //    The following modes are defined:
        
        
        
        
    //
    // The actual parameter must be data (not a pointer).  Used to
    // prevent passing pointers to pointers when pointers to structures
    // are needed (because &pXXX is a common error when pXXX is
    // intended).
    

    //
    // Convenience for the most common form of the above.
    

    // ---------------------------------------------------------------------
    // Memory management
    //
    // __drv_aliasesMem
    // __drv_allocatesMem
    // __drv_freesMem
    //
    // The annotated parameter is "kept" by the function, creating an
    // alias, and relieving any obligation to free the object.
    //
    
    

    //
    // Allocate/release memory-like objects.
    // Kind is unused, but should be "mem" for malloc/free
    // and "object" for new/delete.
    
    

    

    // ---------------------------------------------------------------------
    // Additional diagnostics
    //
    // __drv_preferredFunction
    // __drv_reportError
    //
    //
    // Function 'func' should be used for reason 'why'.  Often used
    // conditionally.
    //
    

    

    


    //
    // The error given by 'why' was detected.  Used conditionally.
    //
    
    
    


    // ---------------------------------------------------------------------
    // Floating point save/restore:
    //
    // _Kernel_float_saved_
    // _Kernel_float_restored_
    // _Kernel_float_used_
    // __drv_floatSaved        (legacy, replaced by _Kernel_float_saved_)
    // __drv_floatRestored     (legacy, replaced by _Kernel_float_restored_)
    // __drv_floatUsed         (legacy, replaced by _Kernel_float_used_)
    //
    // The floating point hardware was saved (available to kernel)
    
    
    

    //
    // The floating point hardware was restored (no longer available)
    
    
    

    //
    // The function uses floating point.  Functions with floating point
    // in their type signature get this automatically.
    
    
    

    // ---------------------------------------------------------------------
    // Usage:
    //
    // __drv_interlocked
    // __drv_inTry
    // __drv_notInTry
    //
    // The parameter is used for interlocked instructions.
    

    // The function must be called inside a try block
    

    // The function must not be called inside a try block
    

    // ---------------------------------------------------------------------
    // FormatString:
    //
    // kind can be "printf", "scanf", "strftime" or "FormatMessage".
    
    


    // ---------------------------------------------------------------------
    // Function classes for drivers:
    //

    // Function class for driver dispatch functions:
	

    // Legacy function class for driver dispatch functions:
    


    // Legacy function class for driver dispatch functions - special case:
    


    // Legacy function class for driver completion functions:
    
    


    // Legacy function class for driver callback functions (FDO or PDO):
    
    


    // ---------------------------------------------------------------------
    // Composite:











































































    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    

#line 887 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\shared\\driverspecs.h"

    // Passing the cancel Irql to a utility function
    
    

    // Check if this is kernel or driver code
    
    


}
#line 899 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\shared\\driverspecs.h"

#line 901 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\shared\\driverspecs.h"

#line 696 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\shared\\specstrings.h"

/*
 If no SAL 2 appears to have been defined (_Outptr_ is a representative choice)
 then we must be operating in a downlevel build environment (such as VS10).
 We also test against the compiler version to identify a downlevel environment,
 as VS11 is the minimum required for SAL 2 support.

 If we are in a downlevel environment, we can go ahead and include no_sal2.h
 to make all of SAL 2 no-ops to ensure no build failures.
*/


#line 709 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\shared\\specstrings.h"


#pragma warning(pop)
#line 713 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\shared\\specstrings.h"

#line 715 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\shared\\specstrings.h"
#line 15 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\shared\\minwindef.h"



#pragma region Application Family or OneCore Family or Games Family





#line 25 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\shared\\minwindef.h"
#line 26 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\shared\\minwindef.h"

// Win32 defines _WIN32 automatically,
// but Macintosh doesn't, so if we are using
// Win32 Functions, we must do it here









#line 40 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\shared\\minwindef.h"


extern "C" {
#line 44 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\shared\\minwindef.h"

/*
 * BASETYPES is defined in ntdef.h if these types are already defined
 */



typedef unsigned long ULONG;
typedef ULONG *PULONG;
typedef unsigned short USHORT;
typedef USHORT *PUSHORT;
typedef unsigned char UCHAR;
typedef UCHAR *PUCHAR;
typedef  char *PSZ;
#line 59 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\shared\\minwindef.h"













#line 73 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\shared\\minwindef.h"



#line 77 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\shared\\minwindef.h"



#line 81 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\shared\\minwindef.h"



#line 85 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\shared\\minwindef.h"



#line 89 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\shared\\minwindef.h"












#line 102 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\shared\\minwindef.h"






#line 109 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\shared\\minwindef.h"



#line 113 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\shared\\minwindef.h"
#line 114 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\shared\\minwindef.h"


























#line 141 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\shared\\minwindef.h"




#line 146 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\shared\\minwindef.h"
#line 147 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\shared\\minwindef.h"







#line 155 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\shared\\minwindef.h"

typedef unsigned long       DWORD;
typedef int                 BOOL;
typedef unsigned char       BYTE;
typedef unsigned short      WORD;
typedef float               FLOAT;
typedef FLOAT               *PFLOAT;
typedef BOOL            *PBOOL;
typedef BOOL             *LPBOOL;
typedef BYTE            *PBYTE;
typedef BYTE             *LPBYTE;
typedef int             *PINT;
typedef int              *LPINT;
typedef WORD            *PWORD;
typedef WORD             *LPWORD;
typedef long             *LPLONG;
typedef DWORD           *PDWORD;
typedef DWORD            *LPDWORD;
typedef void             *LPVOID;
typedef const void       *LPCVOID;

typedef int                 INT;
typedef unsigned int        UINT;
typedef unsigned int        *PUINT;



#line 1 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winnt.h"
/*++ BUILD Version: 0073     Increment this if a change has global effects

Copyright (c) Microsoft Corporation. All rights reserved.

Module Name:

    winnt.h

Abstract:

    This module defines the 32-Bit Windows types and constants that are
    defined by NT, but exposed through the Win32 API.

Revision History:

--*/





#pragma warning(push)
#pragma warning(disable:4668) 
#pragma warning(disable:4820) 
#line 26 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winnt.h"
#pragma warning(disable:4200) 
#pragma warning(disable:4201) 
#pragma warning(disable:4214) 


extern "C" {
#line 33 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winnt.h"

#line 1 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt\\ctype.h"
//
// ctype.h
//
//      Copyright (c) Microsoft Corporation. All rights reserved.
//
// This file declares the narrow character (char) classification functionality.
//
#pragma once




#line 1 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt\\corecrt_wctype.h"
//
// corecrt_wctype.h
//
//      Copyright (c) Microsoft Corporation. All rights reserved.
//
// This file declares the wide character (wchar_t) classification functionality,
// shared by <ctype.h>, <wchar.h>, and <wctype.h>.
//
#pragma once



__pragma(pack(push, 8)) extern "C" {







// This declaration allows the user access to the ctype look-up
// array _ctype defined in ctype.obj by simply including ctype.h


    

#line 28 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt\\corecrt_wctype.h"
        
    #line 30 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt\\corecrt_wctype.h"

    __declspec(dllimport) const unsigned short* __cdecl __pctype_func(void);
    __declspec(dllimport) const wctype_t*       __cdecl __pwctype_func(void);

    



        
        
    #line 41 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt\\corecrt_wctype.h"
#line 42 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt\\corecrt_wctype.h"

// Bit masks for the possible character types














//-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
//
// Wide Character Classification and Conversion Functions
//
//-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 __declspec(dllimport) int __cdecl iswalnum  ( wint_t _C);
 __declspec(dllimport) int __cdecl iswalpha  ( wint_t _C);
 __declspec(dllimport) int __cdecl iswascii  ( wint_t _C);
 __declspec(dllimport) int __cdecl iswblank  ( wint_t _C);
 __declspec(dllimport) int __cdecl iswcntrl  ( wint_t _C);


 __declspec(dllimport) int __cdecl iswdigit  ( wint_t _C);

 __declspec(dllimport) int __cdecl iswgraph  ( wint_t _C);
 __declspec(dllimport) int __cdecl iswlower  ( wint_t _C);
 __declspec(dllimport) int __cdecl iswprint  ( wint_t _C);
 __declspec(dllimport) int __cdecl iswpunct  ( wint_t _C);
 __declspec(dllimport) int __cdecl iswspace  ( wint_t _C);
 __declspec(dllimport) int __cdecl iswupper  ( wint_t _C);
 __declspec(dllimport) int __cdecl iswxdigit ( wint_t _C);
 __declspec(dllimport) int __cdecl __iswcsymf( wint_t _C);
 __declspec(dllimport) int __cdecl __iswcsym ( wint_t _C);

 __declspec(dllimport) int __cdecl _iswalnum_l ( wint_t _C,  _locale_t _Locale);
 __declspec(dllimport) int __cdecl _iswalpha_l ( wint_t _C,  _locale_t _Locale);
 __declspec(dllimport) int __cdecl _iswblank_l ( wint_t _C,  _locale_t _Locale);
 __declspec(dllimport) int __cdecl _iswcntrl_l ( wint_t _C,  _locale_t _Locale);
 __declspec(dllimport) int __cdecl _iswdigit_l ( wint_t _C,  _locale_t _Locale);
 __declspec(dllimport) int __cdecl _iswgraph_l ( wint_t _C,  _locale_t _Locale);
 __declspec(dllimport) int __cdecl _iswlower_l ( wint_t _C,  _locale_t _Locale);
 __declspec(dllimport) int __cdecl _iswprint_l ( wint_t _C,  _locale_t _Locale);
 __declspec(dllimport) int __cdecl _iswpunct_l ( wint_t _C,  _locale_t _Locale);
 __declspec(dllimport) int __cdecl _iswspace_l ( wint_t _C,  _locale_t _Locale);
 __declspec(dllimport) int __cdecl _iswupper_l ( wint_t _C,  _locale_t _Locale);
 __declspec(dllimport) int __cdecl _iswxdigit_l( wint_t _C,  _locale_t _Locale);
 __declspec(dllimport) int __cdecl _iswcsymf_l ( wint_t _C,  _locale_t _Locale);
 __declspec(dllimport) int __cdecl _iswcsym_l  ( wint_t _C,  _locale_t _Locale);


 __declspec(dllimport) wint_t __cdecl towupper( wint_t _C);
 __declspec(dllimport) wint_t __cdecl towlower( wint_t _C);
 __declspec(dllimport) int    __cdecl iswctype( wint_t _C,  wctype_t _Type);

 __declspec(dllimport) wint_t __cdecl _towupper_l( wint_t _C,  _locale_t _Locale);
 __declspec(dllimport) wint_t __cdecl _towlower_l( wint_t _C,  _locale_t _Locale);
 __declspec(dllimport) int    __cdecl _iswctype_l( wint_t _C,  wctype_t _Type,  _locale_t _Locale);



     __declspec(dllimport) int __cdecl isleadbyte( int _C);
     __declspec(dllimport) int __cdecl _isleadbyte_l( int _C,  _locale_t _Locale);

    __declspec(deprecated("This function or variable has been superceded by newer library " "or operating system functionality. Consider using " "iswctype" " " "instead. See online help for details.")) __declspec(dllimport) int __cdecl is_wctype( wint_t _C,  wctype_t _Type);
#line 113 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt\\corecrt_wctype.h"



//-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
//
// Macro and Inline Definitions
//
//-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+










































































#line 196 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt\\corecrt_wctype.h"



} __pragma(pack(pop))
#line 14 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt\\ctype.h"

__pragma(pack(push, 8)) extern "C" {




//-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
//
// Character Classification Function Declarations
//
//-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 __declspec(dllimport) int __cdecl _isctype( int _C,  int _Type);
 __declspec(dllimport) int __cdecl _isctype_l( int _C,  int _Type,  _locale_t _Locale);
  __declspec(dllimport) int __cdecl isalpha( int _C);
 __declspec(dllimport) int __cdecl _isalpha_l( int _C,  _locale_t _Locale);
  __declspec(dllimport) int __cdecl isupper( int _C);
 __declspec(dllimport) int __cdecl _isupper_l( int _C,  _locale_t _Locale);
  __declspec(dllimport) int __cdecl islower( int _C);
 __declspec(dllimport) int __cdecl _islower_l( int _C,  _locale_t _Locale);


  __declspec(dllimport) int __cdecl isdigit( int _C);

 __declspec(dllimport) int __cdecl _isdigit_l( int _C,  _locale_t _Locale);
 __declspec(dllimport) int __cdecl isxdigit( int _C);
 __declspec(dllimport) int __cdecl _isxdigit_l( int _C,  _locale_t _Locale);


  __declspec(dllimport) int __cdecl isspace( int _C);

 __declspec(dllimport) int __cdecl _isspace_l( int _C,  _locale_t _Locale);
 __declspec(dllimport) int __cdecl ispunct( int _C);
 __declspec(dllimport) int __cdecl _ispunct_l( int _C,  _locale_t _Locale);
 __declspec(dllimport) int __cdecl isblank( int _C);
 __declspec(dllimport) int __cdecl _isblank_l( int _C,  _locale_t _Locale);
  __declspec(dllimport) int __cdecl isalnum( int _C);
 __declspec(dllimport) int __cdecl _isalnum_l( int _C,  _locale_t _Locale);
 __declspec(dllimport) int __cdecl isprint( int _C);
 __declspec(dllimport) int __cdecl _isprint_l( int _C,  _locale_t _Locale);
 __declspec(dllimport) int __cdecl isgraph( int _C);
 __declspec(dllimport) int __cdecl _isgraph_l( int _C,  _locale_t _Locale);
 __declspec(dllimport) int __cdecl iscntrl( int _C);
 __declspec(dllimport) int __cdecl _iscntrl_l( int _C,  _locale_t _Locale);


  __declspec(dllimport) int __cdecl toupper( int _C);


  __declspec(dllimport) int __cdecl tolower( int _C);

  __declspec(dllimport) int __cdecl _tolower( int _C);
 __declspec(dllimport) int __cdecl _tolower_l( int _C,  _locale_t _Locale);
  __declspec(dllimport) int __cdecl _toupper( int _C);
 __declspec(dllimport) int __cdecl _toupper_l( int _C,  _locale_t _Locale);

 __declspec(dllimport) int __cdecl __isascii( int _C);
 __declspec(dllimport) int __cdecl __toascii( int _C);
 __declspec(dllimport) int __cdecl __iscsymf( int _C);
 __declspec(dllimport) int __cdecl __iscsym( int _C);



//-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
//
// Character Classification Macro Definitions
//
//-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
__inline int __cdecl __acrt_locale_get_ctype_array_value(
     unsigned short const * const _Locale_pctype_array,
             int                    const _Char_value,
                            int                    const _Mask
    )
{
    // The C Standard specifies valid input to a ctype function ranges from -1 to 255.
    // To avoid undefined behavior, we should check this range for all accesses.
    // Note _locale_pctype array does extend to -127 to support accessing
    // _pctype directly with signed chars.
    if (_Char_value >= -1 && _Char_value <= 255)
    {
        return _Locale_pctype_array[_Char_value] & _Mask;
    }

    return 0;
}



    // Maximum number of bytes in multi-byte character in the current locale
    // (also defined in stdlib.h).
    




















    // In the debug CRT, we make all calls through the validation function to catch
    // invalid integer inputs that yield undefined behavior.
    




        
    #line 133 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt\\ctype.h"



    
    
    
    







        __forceinline int __cdecl __ascii_tolower(int const _C)
        {
            if (_C >= 'A' && _C <= 'Z')
            {
                return _C - ('A' - 'a');
            }
            return _C;
        }

        __forceinline int __cdecl __ascii_toupper(int const _C)
        {
            if (_C >= 'a' && _C <= 'z')
            {
                return _C - ('a' - 'A');
            }
            return _C;
        }

        __forceinline int __cdecl __ascii_iswalpha(int const _C)
        {
            return (_C >= 'A' && _C <= 'Z') || (_C >= 'a' && _C <= 'z');
        }

        __forceinline int __cdecl __ascii_iswdigit(int const _C)
        {
            return _C >= '0' && _C <= '9';
        }

        __forceinline int __cdecl __ascii_towlower(int const _C)
        {
            return __ascii_tolower(_C);
        }

        __forceinline int __cdecl __ascii_towupper(int const _C)
        {
            return __ascii_toupper(_C);
        }
    #line 185 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt\\ctype.h"



    












#line 202 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt\\ctype.h"

    __inline __crt_locale_data_public* __cdecl __acrt_get_locale_data_prefix(void const volatile* const _LocalePointers)
    {
        _locale_t const _TypedLocalePointers = (_locale_t)_LocalePointers;
        return (__crt_locale_data_public*)_TypedLocalePointers->locinfo;
    }

    



    __inline int __cdecl _chvalidchk_l(
             int       const _C,
             int       const _Mask,
         _locale_t const _Locale
        )
    {
        


        if (_Locale)
        {
            return __acrt_locale_get_ctype_array_value(__acrt_get_locale_data_prefix(_Locale)->_locale_pctype, _C, _Mask);
        }

        return (__acrt_locale_get_ctype_array_value(__pctype_func(), (_C), (_Mask))) ;
        #line 229 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt\\ctype.h"
    }

    
    

    __inline int __cdecl _ischartype_l(
             int       const _C,
             int       const _Mask,
         _locale_t const _Locale
        )
    {
        if (_Locale) {
            if (_C >= -1 && _C <= 255)
            {
                return __acrt_get_locale_data_prefix(_Locale)->_locale_pctype[_C] & _Mask;
            }

            if (__acrt_get_locale_data_prefix(_Locale)->_locale_mb_cur_max > 1)
            {
                return _isctype_l(_C, _Mask, _Locale);
            }

            return 0; // >0xFF and SBCS locale
        }

        return _chvalidchk_l(_C, _Mask, 0);
    }

    
    
    
    
    
    
    
    
    
    
    
    

    
    

    
    


    // Microsoft C version 2.0 extended ctype macros
    
    
    
    

    
    
    
    

#line 289 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt\\ctype.h"



    
    
    
    
#line 297 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt\\ctype.h"



#line 301 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt\\ctype.h"
} __pragma(pack(pop))
#line 303 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt\\ctype.h"
#line 35 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winnt.h"


//
// Anywhere that NOINITALL is defined, warning 4845 should be disabled. This warning
// fires whenever __declspec(no_init_all) is found but /d1initall isn't set. This isn't
// helpful since this will be done intentionally (not all components opt-in).
//


#pragma warning(disable:4845)   
#line 46 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winnt.h"






#line 53 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winnt.h"
#line 54 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winnt.h"



//
// For compilers that don't support nameless unions/structs
//











#line 72 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winnt.h"









#line 82 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winnt.h"
#line 83 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winnt.h"









#line 93 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winnt.h"






#line 100 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winnt.h"
#line 101 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winnt.h"

// end_ntoshvp


#line 1 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\shared\\kernelspecs.h"
/****************************************************************************
**                                                                             *
* KernelSpecs.h - markers for documenting the semantics of driver APIs        *
*                 See DriverSpecs.h for detailed comments                     *
*                 See also <SpecStrings.h>                                    *
*                                                                             *
* Version 1.2.00                                                              *
*                                                                             *
* Copyright (c) Microsoft Corporation. All rights reserved.                   *
*                                                                             *
\*****************************************************************************/

/****************************************************************************
** NOTE                                                                        *
* NOTE                                                                        *
* NOTE                                                                        *
*   The macro bodies in this file are subject to change without notice.       *
*   Attempting to use the annotations in the macro bodies directly is not     *
*   supported.                                                                *
* NOTE                                                                        *
* NOTE                                                                        *
* NOTE                                                                        *
\*****************************************************************************/

/****************************************************************************
** As noted in DriverSpecs.h, this header contains "real" definitions for
* annotations that either never appear in user space, or which are meaningles
* in user space and are #defined to nothing by DriverSpecs.h.
*
* Further commentary appears in DriverSpecs.h.
\*****************************************************************************/







#pragma once
#line 41 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\shared\\kernelspecs.h"


extern "C" {
#line 45 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\shared\\kernelspecs.h"

    // ---------------------------------------------------------------------
    // The symbolic IRQL values can sometimes end up undefined, so define
    // the usual ones here, for PREfast purposes only.

    
    
    

    

#line 57 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\shared\\kernelspecs.h"
    
    
    #line 60 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\shared\\kernelspecs.h"
    

#line 63 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\shared\\kernelspecs.h"
    

#line 66 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\shared\\kernelspecs.h"
    

#line 69 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\shared\\kernelspecs.h"

    //
    // ---------------------------------------------------------------------
    // IRQL annotations:
    //
    // _IRQL_raises_(irql)
    // _IRQL_requires_(irql)
    // _IRQL_requires_max_(irql)
    // _IRQL_requires_min_(irql)
    // _IRQL_saves_
    // _IRQL_saves_global_(kind,param)
    // _IRQL_restores_
    // _IRQL_restores_global_(kind,param)
    // _IRQL_always_function_min_(irql)
    // _IRQL_always_function_max_(irql)
    // _IRQL_requires_same_
    // _IRQL_uses_cancel_
    // 
    // Legacy IRQL annotations:
    //   Legacy annotation:        Use instead:
    //   __drv_setsIRQL            (Obsolete, use _IRQL_raises_)
    //   __drv_raisesIRQL          _IRQL_raises_
    //   __drv_requiresIRQL        _IRQL_requires_
    //   __drv_maxIRQL             _IRQL_requires_max_
    //   __drv_minIRQL             _IRQL_requires_min_
    //   __drv_savesIRQL           _IRQL_saves_
    //   __drv_savesIRQLGlobal     _IRQL_saves_global_
    //   __drv_restoresIRQL        _IRQL_restores_
    //   __drv_restoresIRQLGlobal  _IRQL_restores_global_
    //   __drv_minFunctionIRQL     _IRQL_always_function_min_
    //   __drv_maxFunctionIRQL     _IRQL_always_function_max_
    //   __drv_sameIRQL            _IRQL_requires_same_
    //   __drv_useCancelIRQL       _IRQL_uses_cancel_
    //

    //
    // The function exits at IRQL irql (obsolete, use _IRQL_raises_)
    //
    // ';' inside the parens to keep MIDL happy
    
    
    


    //
    // The function exits at IRQL irql, but this may only raise the irql.
    //
    
    
    

    
    

    //
    // The called function must be entered at IRQL level
    //
    
    
    

    
    

    //
    // The maximum IRQL at which the function may be called.
    //
    
    
    

    
    

    //
    // The minimum IRQL at which the function may be called.
    //
    
    
    

    
    

    //
    // The current IRQL is saved in the annotated parameter
    //
    
    
    

    
    

    //
    // The current IRQL is saved in the (otherwise anonymous) global object
    // identified by kind and further refined by param.
    //
    
    
    

    
    

    //
    // The current IRQL is restored from the annotated parameter
    //
    
    
    

    
    

    //
    // The current IRQL is restored from the (otherwise anonymous) global
    // object identified by kind and further refined by param.
    //
    
    
    

    
    

    //
    // The minimum IRQL to which the function can lower itself. The IRQL
    // at entry is assumed to be that value unless overridden.
    //
    
    
    

    
    

    //
    // The maximum IRQL to which the function can raise itself.
    //
    
    
    

    
    

    //
    // The function must exit with the same IRQL it was entered with.
    // (It may change it but it must restore it.)
    //
    
    
    

    
    

    //
    // The annotated parameter contains the cancelIRQL, which will be restored
    // by the called function.
    //
    
    
    

    
    

    //
    // The annotated parameter is an IRQL that will be restored and a new (probably the same)
    // value will be inserted.  (Use this in preference to directly coding it.)
    
    
















}
#line 261 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\shared\\kernelspecs.h"

#line 263 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\shared\\kernelspecs.h"
#line 106 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winnt.h"



#line 110 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winnt.h"

// begin_ntoshvp



#line 116 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winnt.h"

#line 118 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winnt.h"








#line 127 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winnt.h"




#line 132 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winnt.h"

// end_ntoshvp








#line 143 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winnt.h"

//
// TYPE_ALIGNMENT will return the alignment requirements of a given type for
// the current platform.
//




#line 153 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winnt.h"



#line 157 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winnt.h"

//
// Note: RC_INVOKED is checked in PROBE_ALIGNMENT to maintain compatibility with previous
//       versions of the SDK which did not block inclusion in an .RC file.
//












#line 175 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winnt.h"

//
// Define PROBE_ALIGNMENT32 to be the same as PROBE_ALIGNMENT on x86, so that
// code hosting x86 under WoW can handle x86's maximum guaranteed alignment.
//



// begin_ntoshvp

//
// C_ASSERT() can be used to perform many compile-time assertions:
//            type sizes, field offsets, etc.
//
// An assertion failure results in error C2118: negative subscript.
//





#line 197 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winnt.h"

#line 1 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\shared\\basetsd.h"
/*++

Copyright (c) Microsoft Corporation.  All rights reserved.

Module Name:

    basetsd.h

Abstract:

    Type definitions for the basic sized types.

Author:

Revision History:

--*/





#pragma warning(push)
#pragma warning(disable:4668) 
#line 26 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\shared\\basetsd.h"


 
 typedef unsigned __int64 POINTER_64_INT;
 
  
 

#line 35 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\shared\\basetsd.h"













#line 49 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\shared\\basetsd.h"





#line 55 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\shared\\basetsd.h"







#line 63 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\shared\\basetsd.h"





#pragma once
#line 70 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\shared\\basetsd.h"


extern "C" {
#line 74 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\shared\\basetsd.h"

typedef signed char         INT8, *PINT8;
typedef signed short        INT16, *PINT16;
typedef signed int          INT32, *PINT32;
typedef signed __int64      INT64, *PINT64;
typedef unsigned char       UINT8, *PUINT8;
typedef unsigned short      UINT16, *PUINT16;
typedef unsigned int        UINT32, *PUINT32;
typedef unsigned __int64    UINT64, *PUINT64;

//
// The following types are guaranteed to be signed and 32 bits wide.
//

typedef signed int LONG32, *PLONG32;

//
// The following types are guaranteed to be unsigned and 32 bits wide.
//

typedef unsigned int ULONG32, *PULONG32;
typedef unsigned int DWORD32, *PDWORD32;







#line 104 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\shared\\basetsd.h"

//
// The INT_PTR is guaranteed to be the same size as a pointer.  Its
// size with change with pointer size (32/64).  It should be used
// anywhere that a pointer is cast to an integer type. UINT_PTR is
// the unsigned variation.
//
// __int3264 is intrinsic to 64b MIDL but not to old MIDL or to C compiler.
//








#line 122 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\shared\\basetsd.h"
// old midl and C++ compiler


    typedef __int64 INT_PTR, *PINT_PTR;
    typedef unsigned __int64 UINT_PTR, *PUINT_PTR;

    typedef __int64 LONG_PTR, *PLONG_PTR;
    typedef unsigned __int64 ULONG_PTR, *PULONG_PTR;

    










#line 143 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\shared\\basetsd.h"
#line 144 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\shared\\basetsd.h"

//
// HALF_PTR is half the size of a pointer it intended for use with
// within structures which contain a pointer and two small fields.
// UHALF_PTR is the unsigned variation.
//





typedef __int64 SHANDLE_PTR;
typedef unsigned __int64 HANDLE_PTR;
typedef unsigned int UHALF_PTR, *PUHALF_PTR;
typedef int HALF_PTR, *PHALF_PTR;


__inline
unsigned long
HandleToULong(
    const void *h
    )
{
    return((unsigned long) (ULONG_PTR) h );
}

__inline
long
HandleToLong(
    const void *h
    )
{
    return((long) (LONG_PTR) h );
}

__inline
void *
ULongToHandle(
    const unsigned long h
    )
{
    return((void *) (UINT_PTR) h );
}


__inline
void *
LongToHandle(
    const long h
    )
{
    return((void *) (INT_PTR) h );
}


__inline
unsigned long
PtrToUlong(
    const void  *p
    )
{
    return((unsigned long) (ULONG_PTR) p );
}

__inline
unsigned int
PtrToUint(
    const void  *p
    )
{
    return((unsigned int) (UINT_PTR) p );
}

__inline
unsigned short
PtrToUshort(
    const void  *p
    )
{
    return((unsigned short) (unsigned long) (ULONG_PTR) p );
}

__inline
long
PtrToLong(
    const void  *p
    )
{
    return((long) (LONG_PTR) p );
}

__inline
int
PtrToInt(
    const void  *p
    )
{
    return((int) (INT_PTR) p );
}

__inline
short
PtrToShort(
    const void  *p
    )
{
    return((short) (long) (LONG_PTR) p );
}

__inline
void *
IntToPtr(
    const int i
    )
// Caution: IntToPtr() sign-extends the int value.
{
    return( (void *)(INT_PTR)i );
}

__inline
void *
UIntToPtr(
    const unsigned int ui
    )
// Caution: UIntToPtr() zero-extends the unsigned int value.
{
    return( (void *)(UINT_PTR)ui );
}

__inline
void *
LongToPtr(
    const long l
    )
// Caution: LongToPtr() sign-extends the long value.
{
    return( (void *)(LONG_PTR)l );
}

__inline
void *
ULongToPtr(
    const unsigned long ul
    )
// Caution: ULongToPtr() zero-extends the unsigned long value.
{
    return( (void *)(ULONG_PTR)ul );
}






__inline
void *
Ptr32ToPtr(
    const void * __ptr32 p
    )
{
    return((void *) (ULONG_PTR) (unsigned long) p);
}

__inline
void *
Handle32ToHandle(
    const void * __ptr32 h
    )
{
    return((void *) (LONG_PTR) (long) h);
}

__inline
void * __ptr32
PtrToPtr32(
    const void *p
    )
{
    return((void * __ptr32 ) (unsigned long) (ULONG_PTR) p);
}



#line 328 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\shared\\basetsd.h"




































































#line 397 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\shared\\basetsd.h"


















//
// SIZE_T used for counts or ranges which need to span the range of
// of a pointer.  SSIZE_T is the signed variation.
//

typedef ULONG_PTR SIZE_T, *PSIZE_T;
typedef LONG_PTR SSIZE_T, *PSSIZE_T;









































#line 464 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\shared\\basetsd.h"

//
// Add Windows flavor DWORD_PTR types
//

typedef ULONG_PTR DWORD_PTR, *PDWORD_PTR;

//
// The following types are guaranteed to be signed and 64 bits wide.
//

typedef __int64 LONG64, *PLONG64;


//
// The following types are guaranteed to be unsigned and 64 bits wide.
//

typedef unsigned __int64 ULONG64, *PULONG64;
typedef unsigned __int64 DWORD64, *PDWORD64;

// begin_wudfpwdm

//
// Legacy thread affinity.
//

typedef ULONG_PTR KAFFINITY;
typedef KAFFINITY *PKAFFINITY;

// end_wudfpwdm


}
#line 499 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\shared\\basetsd.h"


#pragma warning(pop)
#line 503 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\shared\\basetsd.h"

#line 505 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\shared\\basetsd.h"
#line 199 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winnt.h"







#line 207 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winnt.h"
#line 208 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winnt.h"






#line 215 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winnt.h"
#line 216 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winnt.h"






#line 223 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winnt.h"
#line 224 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winnt.h"






#line 231 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winnt.h"
#line 232 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winnt.h"

// end_ntoshvp






#line 241 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winnt.h"
#line 242 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winnt.h"



#line 246 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winnt.h"






#line 253 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winnt.h"
#line 254 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winnt.h"






#line 261 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winnt.h"
#line 262 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winnt.h"






#line 269 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winnt.h"
#line 270 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winnt.h"






#line 277 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winnt.h"
#line 278 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winnt.h"




#line 283 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winnt.h"

#line 285 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winnt.h"
#line 286 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winnt.h"






#line 293 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winnt.h"
#line 294 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winnt.h"






#line 301 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winnt.h"
#line 302 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winnt.h"















#line 318 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winnt.h"
#line 319 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winnt.h"






#line 326 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winnt.h"
#line 327 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winnt.h"




#line 332 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winnt.h"

#line 334 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winnt.h"
#line 335 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winnt.h"




#line 340 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winnt.h"

#line 342 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winnt.h"
#line 343 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winnt.h"

// begin_ntoshvp






#line 352 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winnt.h"
#line 353 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winnt.h"

//
// CFORCEINLINE: __forceinline required for correctness.
//



//
// STKFORCEINLINE: __forceinline required for correctness due to counting stack
//                 frames for a stack trace being captured.
//



//
// PFORCEINLINE: __forceinline required for performance.
//



#line 374 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winnt.h"

// end_ntoshvp








#line 385 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winnt.h"
#line 386 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winnt.h"














#line 401 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winnt.h"

// begin_ntoshvp

//
// Void
//

typedef void *PVOID;
typedef void * __ptr64 PVOID64;








#line 419 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winnt.h"





#line 425 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winnt.h"

//
// Define API decoration for direct importing system DLL references.
//












#line 442 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winnt.h"


//
// Basics
//



typedef char CHAR;
typedef short SHORT;
typedef long LONG;

typedef int INT;
#line 456 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winnt.h"
#line 457 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winnt.h"

//
// UNICODE (Wide Character) types
//


typedef wchar_t WCHAR;    // wc,   16-bit UNICODE character



#line 468 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winnt.h"

typedef WCHAR *PWCHAR, *LPWCH, *PWCH;
typedef const WCHAR *LPCWCH, *PCWCH;

typedef  WCHAR *NWPSTR, *LPWSTR, *PWSTR;
typedef  PWSTR *PZPWSTR;
typedef  const PWSTR *PCZPWSTR;
typedef  WCHAR __unaligned *LPUWSTR, *PUWSTR;
typedef  const WCHAR *LPCWSTR, *PCWSTR;
typedef  PCWSTR *PZPCWSTR;
typedef  const PCWSTR *PCZPCWSTR;
typedef  const WCHAR __unaligned *LPCUWSTR, *PCUWSTR;

typedef  WCHAR *PZZWSTR;
typedef  const WCHAR *PCZZWSTR;
typedef  WCHAR __unaligned *PUZZWSTR;
typedef  const WCHAR __unaligned *PCUZZWSTR;

typedef  WCHAR *PNZWCH;
typedef  const WCHAR *PCNZWCH;
typedef  WCHAR __unaligned *PUNZWCH;
typedef  const WCHAR __unaligned *PCUNZWCH;



typedef const WCHAR *LPCWCHAR, *PCWCHAR;
typedef const WCHAR __unaligned *LPCUWCHAR, *PCUWCHAR;

//
//  UCS (Universal Character Set) types
//

typedef unsigned long UCSCHAR;

//
//  Even pre-Unicode agreement, UCS values are always in the
//  range U+00000000 to U+7FFFFFFF, so we'll pick an obvious
//  value.





//
//  We'll assume here that the ISO-10646 / Unicode agreement
//  not to assign code points after U+0010FFFF holds so that
//  we do not have to have separate "UCSCHAR" and "UNICODECHAR"
//  types.
//



typedef UCSCHAR *PUCSCHAR;
typedef const UCSCHAR *PCUCSCHAR;

typedef UCSCHAR *PUCSSTR;
typedef UCSCHAR __unaligned *PUUCSSTR;

typedef const UCSCHAR *PCUCSSTR;
typedef const UCSCHAR __unaligned *PCUUCSSTR;

typedef UCSCHAR __unaligned *PUUCSCHAR;
typedef const UCSCHAR __unaligned *PCUUCSCHAR;

#line 533 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winnt.h"


//
// ANSI (Multi-byte Character) types
//
typedef CHAR *PCHAR, *LPCH, *PCH;
typedef const CHAR *LPCCH, *PCCH;

typedef  CHAR *NPSTR, *LPSTR, *PSTR;
typedef  PSTR *PZPSTR;
typedef  const PSTR *PCZPSTR;
typedef  const CHAR *LPCSTR, *PCSTR;
typedef  PCSTR *PZPCSTR;
typedef  const PCSTR *PCZPCSTR;

typedef  CHAR *PZZSTR;
typedef  const CHAR *PCZZSTR;

typedef  CHAR *PNZCH;
typedef  const CHAR *PCNZCH;

//
// Neutral ANSI/UNICODE types and macros
//





























typedef char TCHAR, *PTCHAR;
typedef unsigned char TBYTE , *PTBYTE ;

#line 590 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winnt.h"

typedef LPCH LPTCH, PTCH;
typedef LPCCH LPCTCH, PCTCH;
typedef LPSTR PTSTR, LPTSTR, PUTSTR, LPUTSTR;
typedef LPCSTR PCTSTR, LPCTSTR, PCUTSTR, LPCUTSTR;
typedef PZZSTR PZZTSTR, PUZZTSTR;
typedef PCZZSTR PCZZTSTR, PCUZZTSTR;
typedef PZPSTR PZPTSTR;
typedef PNZCH PNZTCH, PUNZTCH;
typedef PCNZCH PCNZTCH, PCUNZTCH;


#line 603 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winnt.h"



typedef SHORT *PSHORT;  
typedef LONG *PLONG;    



//
// Structure to represent a system wide processor number. It contains a
// group number and relative processor number within the group.
//

typedef struct _PROCESSOR_NUMBER {
    WORD   Group;
    BYTE  Number;
    BYTE  Reserved;
} PROCESSOR_NUMBER, *PPROCESSOR_NUMBER;

//
// Structure to represent a group-specific affinity, such as that of a
// thread.  Specifies the group number and the affinity within that group.
//

typedef struct _GROUP_AFFINITY {
    KAFFINITY Mask;
    WORD   Group;
    WORD   Reserved[3];
} GROUP_AFFINITY, *PGROUP_AFFINITY;









#line 642 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winnt.h"



// begin_ntoshvp

//
// Handle to an Object
//


typedef void *HANDLE;


#line 656 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winnt.h"

#line 658 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winnt.h"



#line 662 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winnt.h"
typedef HANDLE *PHANDLE;

// end_ntoshvp

//
// Flag (bit) fields
//

typedef BYTE   FCHAR;
typedef WORD   FSHORT;
typedef DWORD  FLONG;

// begin_ntoshvp

// Component Object Model defines, and macros






typedef  long HRESULT;
#line 685 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winnt.h"
#line 686 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winnt.h"

// end_ntoshvp


    
    
    




#line 698 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winnt.h"



// Win32 doesn't support __export





#line 708 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winnt.h"













#line 722 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winnt.h"














// The 'V' versions allow Variable Argument lists.













typedef char CCHAR;          
typedef DWORD LCID;         
typedef PDWORD PLCID;       
typedef WORD   LANGID;      




//
// Compartment identifier
//

typedef enum {
    UNSPECIFIED_COMPARTMENT_ID = 0,
    DEFAULT_COMPARTMENT_ID
} COMPARTMENT_ID, *PCOMPARTMENT_ID;

#line 768 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winnt.h"






// begin_ntoshvp

//
// _M_IX86 included so that EM CONTEXT structure compiles with
// x86 programs. *** TBD should this be for all architectures?
//

//
// 16 byte aligned type for 128 bit floats
//

//
// For we define a 128 bit structure and use __declspec(align(16)) pragma to
// align to 128 bits.
//



#line 793 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winnt.h"
typedef struct _FLOAT128 {
    __int64 LowPart;
    __int64 HighPart;
} FLOAT128;

typedef FLOAT128 *PFLOAT128;


//
// __int64 is only supported by 2.0 and later midl.
// __midl is set by the 2.0 midl and not by 1.0 midl.
//



typedef __int64 LONGLONG;
typedef unsigned __int64 ULONGLONG;


















#line 829 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winnt.h"

typedef LONGLONG *PLONGLONG;
typedef ULONGLONG *PULONGLONG;

// Update Sequence Number

typedef LONGLONG USN;





#line 842 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winnt.h"
typedef union _LARGE_INTEGER {
    struct {
        DWORD LowPart;
        LONG HighPart;
    }  ;
    struct {
        DWORD LowPart;
        LONG HighPart;
    } u;
    LONGLONG QuadPart;
} LARGE_INTEGER;
#line 854 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winnt.h"

typedef LARGE_INTEGER *PLARGE_INTEGER;





#line 862 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winnt.h"
typedef union _ULARGE_INTEGER {
    struct {
        DWORD LowPart;
        DWORD HighPart;
    }  ;
    struct {
        DWORD LowPart;
        DWORD HighPart;
    } u;
    ULONGLONG QuadPart;
} ULARGE_INTEGER;
#line 874 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winnt.h"

typedef ULARGE_INTEGER *PULARGE_INTEGER;

//
// Reference count.
//

typedef LONG_PTR RTL_REFERENCE_COUNT, *PRTL_REFERENCE_COUNT;
typedef LONG RTL_REFERENCE_COUNT32, *PRTL_REFERENCE_COUNT32;

// end_ntminiport end_ntndis end_ntminitape
// end_ntoshvp


//
// Locally Unique Identifier
//

typedef struct _LUID {
    DWORD LowPart;
    LONG HighPart;
} LUID, *PLUID;


typedef ULONGLONG  DWORDLONG;
typedef DWORDLONG *PDWORDLONG;


//
// Define operations to logically shift an int64 by 0..31 bits and to multiply
// 32-bits by 32-bits to form a 64-bit product.
//



//
// Midl does not understand inline assembler. Therefore, the Rtl functions
// are used for shifts by 0..31 and multiplies of 32-bits times 32-bits to
// form a 64-bit product.
//
//
// IA64 and AMD64 have native 64-bit operations that are just as fast as their
// 32-bit counter parts. Therefore, the int64 data type is used directly to form
// shifts of 0..31 and multiplies of 32-bits times 32-bits to form a 64-bit
// product.
//










































































































#line 1030 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winnt.h"

//
// Define rotate intrinsics.
//


extern "C" {
#line 1038 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winnt.h"








unsigned char
__cdecl
_rotl8 (
     unsigned char Value,
     unsigned char Shift
    );

unsigned short
__cdecl
_rotl16 (
     unsigned short Value,
     unsigned char Shift
    );

unsigned char
__cdecl
_rotr8 (
     unsigned char Value,
     unsigned char Shift
    );

unsigned short
__cdecl
_rotr16 (
     unsigned short Value,
     unsigned char Shift
    );

#pragma intrinsic(_rotl8)
#pragma intrinsic(_rotl16)
#pragma intrinsic(_rotr8)
#pragma intrinsic(_rotr16)

#line 1080 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winnt.h"








unsigned int
__cdecl
_rotl (
     unsigned int Value,
     int Shift
    );

unsigned __int64
__cdecl
_rotl64 (
     unsigned __int64 Value,
     int Shift
    );

unsigned int
__cdecl
_rotr (
     unsigned int Value,
     int Shift
    );

unsigned __int64
__cdecl
_rotr64 (
     unsigned __int64 Value,
     int Shift
    );

#pragma intrinsic(_rotl)
#pragma intrinsic(_rotl64)
#pragma intrinsic(_rotr)
#pragma intrinsic(_rotr64)

#line 1122 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winnt.h"


}
#line 1126 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winnt.h"





typedef BYTE  BOOLEAN;           
typedef BOOLEAN *PBOOLEAN;       
//
//  Doubly linked list structure.  Can be used as either a list head, or
//  as link words.
//

typedef struct _LIST_ENTRY {
   struct _LIST_ENTRY *Flink;
   struct _LIST_ENTRY *Blink;
} LIST_ENTRY, *PLIST_ENTRY, * PRLIST_ENTRY;

//
//  Singly linked list structure. Can be used as either a list head, or
//  as link words.
//

typedef struct _SINGLE_LIST_ENTRY {
    struct _SINGLE_LIST_ENTRY *Next;
} SINGLE_LIST_ENTRY, *PSINGLE_LIST_ENTRY;

// end_ntoshvp
// begin_ntoshvp

//
// These are needed for portable debugger support.
//

typedef struct LIST_ENTRY32 {
    DWORD Flink;
    DWORD Blink;
} LIST_ENTRY32;
typedef LIST_ENTRY32 *PLIST_ENTRY32;

typedef struct LIST_ENTRY64 {
    ULONGLONG Flink;
    ULONGLONG Blink;
} LIST_ENTRY64;
typedef LIST_ENTRY64 *PLIST_ENTRY64;


#line 1 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\shared\\guiddef.h"
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (c) Microsoft Corporation.  All rights reserved.
//
//  File:       guiddef.h
//
//  Contents:   GUID definition
//
//----------------------------------------------------------------------------










#line 22 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\shared\\guiddef.h"
typedef struct _GUID {
    unsigned long  Data1;
    unsigned short Data2;
    unsigned short Data3;
    unsigned char  Data4[ 8 ];
} GUID;
#line 29 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\shared\\guiddef.h"
#line 30 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\shared\\guiddef.h"




































#line 67 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\shared\\guiddef.h"








typedef GUID *LPGUID;
#line 77 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\shared\\guiddef.h"



typedef const GUID *LPCGUID;
#line 82 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\shared\\guiddef.h"




typedef GUID IID;
typedef IID *LPIID;


typedef GUID CLSID;
typedef CLSID *LPCLSID;


typedef GUID FMTID;
typedef FMTID *LPFMTID;







#line 104 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\shared\\guiddef.h"







#line 112 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\shared\\guiddef.h"
#line 113 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\shared\\guiddef.h"







#line 121 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\shared\\guiddef.h"
#line 122 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\shared\\guiddef.h"







#line 130 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\shared\\guiddef.h"
#line 131 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\shared\\guiddef.h"







#line 139 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\shared\\guiddef.h"
#line 140 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\shared\\guiddef.h"

#line 142 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\shared\\guiddef.h"






// Faster (but makes code fatter) inline version...use sparingly

__inline int InlineIsEqualGUID(const GUID & rguid1, const GUID & rguid2)
{
   return (
      ((unsigned long *) &rguid1)[0] == ((unsigned long *) &rguid2)[0] &&
      ((unsigned long *) &rguid1)[1] == ((unsigned long *) &rguid2)[1] &&
      ((unsigned long *) &rguid1)[2] == ((unsigned long *) &rguid2)[2] &&
      ((unsigned long *) &rguid1)[3] == ((unsigned long *) &rguid2)[3]);
}

__inline int IsEqualGUID(const GUID & rguid1, const GUID & rguid2)
{
    return !memcmp(&rguid1, &rguid2, sizeof(GUID));
}











#line 175 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\shared\\guiddef.h"






// Same type, different name







// A couple of C++ helpers


__inline bool operator==(const GUID & guidOne, const GUID & guidOther)
{
    return !!IsEqualGUID(guidOne,guidOther);
}

__inline bool operator!=(const GUID & guidOne, const GUID & guidOther)
{
    return !(guidOne == guidOther);
}
#line 202 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\shared\\guiddef.h"
#line 203 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\shared\\guiddef.h"
#line 204 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\shared\\guiddef.h"
#line 205 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\shared\\guiddef.h"
#line 206 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\shared\\guiddef.h"
#line 1173 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winnt.h"




typedef struct  _OBJECTID {     // size is 20
    GUID Lineage;
    DWORD Uniquifier;
} OBJECTID;
#line 1182 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winnt.h"










// begin_ntoshvp
//
// Calculate the byte offset of a field in a structure of type type.
//




//
// Calculate the size of a field in a structure of type type, without
// knowing or stating the type of the field.
//


//
// Calculate the size of a structure of type type up through and
// including a field.
//



// end_ntoshvp

//
//  RTL_CONTAINS_FIELD usage:
//
//      if (RTL_CONTAINS_FIELD(pBlock, pBlock->cbSize, dwMumble))
//          // safe to use pBlock->dwMumble
//



//
// Return the number of elements in a statically sized array.
//   DWORD Buffer[100];
//   RTL_NUMBER_OF(Buffer) == 100
// This is also popularly known as: NUMBER_OF, ARRSIZE, _countof, NELEM, etc.
//



//
// RtlpNumberOf is a function that takes a reference to an array of N Ts.
//
// typedef T array_of_T[N];
// typedef array_of_T &reference_to_array_of_T;
//
// RtlpNumberOf returns a pointer to an array of N chars.
// We could return a reference instead of a pointer but older compilers do not accept that.
//
// typedef char array_of_char[N];
// typedef array_of_char *pointer_to_array_of_char;
//
// sizeof(array_of_char) == N
// sizeof(*pointer_to_array_of_char) == N
//
// pointer_to_array_of_char RtlpNumberOf(reference_to_array_of_T);
//
// We never even call RtlpNumberOf, we just take the size of dereferencing its return type.
// We do not even implement RtlpNumberOf, we just declare it.
//
// Attempts to pass pointers instead of arrays to this macro result in compile time errors.
// That is the point.
//

// end_ntndis end_ntminiport

#pragma region Application Family or OneCore Family Or Game Family


// begin_ntndis begin_ntminiport

extern "C++" // templates cannot be declared to have 'C' linkage
template <typename T, size_t N>
char (*RtlpNumberOf( __unaligned T (&)[N] ))[N];

// end_ntndis end_ntminiport

#line 1276 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winnt.h"
#pragma endregion

// begin_ntndis begin_ntminiport



//
// This does not work with:
//
// void Foo()
// {
//    struct { int x; } y[2];
//    RTL_NUMBER_OF_V2(y); // illegal use of anonymous local type in template instantiation
// }
//
// You must instead do:
//
// struct Foo1 { int x; };
//
// void Foo()
// {
//    Foo1 y[2];
//    RTL_NUMBER_OF_V2(y); // ok
// }
//
// OR
//
// void Foo()
// {
//    struct { int x; } y[2];
//    RTL_NUMBER_OF_V1(y); // ok
// }
//
// OR
//
// void Foo()
// {
//    struct { int x; } y[2];
//    _ARRAYSIZE(y); // ok
// }
//



#line 1321 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winnt.h"





#line 1327 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winnt.h"

//
// ARRAYSIZE is more readable version of RTL_NUMBER_OF_V2, and uses
// it regardless of ENABLE_RTL_NUMBER_OF_V2
//
// _ARRAYSIZE is a version useful for anonymous types
//



//
// An expression that yields the type of a field in a struct.
//


// RTL_ to avoid collisions in the global namespace.
//
// Given typedef struct _FOO { BYTE Bar[123]; } FOO;
// RTL_NUMBER_OF_FIELD(FOO, Bar) == 123
//


//
// eg:
// typedef struct FOO {
//   DWORD Integer;
//   PVOID Pointer;
// } FOO;
//
// RTL_PADDING_BETWEEN_FIELDS(FOO, Integer, Pointer) == 0 for Win32, 4 for Win64
//





// RTL_ to avoid collisions in the global namespace.




#line 1369 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winnt.h"


// like sizeof
// usually this would be * CHAR_BIT, but we don't necessarily have #include <limits.h>




// begin_ntoshvp

//
// Calculate the address of the base of the structure given its type, and an
// address of a field within the structure.
//





// end_ntoshvp
// end_ntminiport end_ntndis

//
// Exception handler routine definition.
//



typedef


EXCEPTION_DISPOSITION
__stdcall
EXCEPTION_ROUTINE (
     struct _EXCEPTION_RECORD *ExceptionRecord,
     PVOID EstablisherFrame,
     struct _CONTEXT *ContextRecord,
     PVOID DispatcherContext
    );

typedef EXCEPTION_ROUTINE *PEXCEPTION_ROUTINE;


//
// Enclave ID definitions
//


























//
// Product types
// This list grows with each OS release.
//
// There is no ordering of values to ensure callers
// do an equality test i.e. greater-than and less-than
// comparisons are not useful.
//
// NOTE: Values in this list should never be deleted.
//       When a product-type 'X' gets dropped from a
//       OS release onwards, the value of 'X' continues
//       to be used in the mapping table of GetProductInfo.
//



































































































































































//
// ** DEPRECATED ** DEPRECATED ** DEPRECATED ** DEPRECATED ** DEPRECATED **
//
//  DEPRECATED: The Language ID  concept is deprecated, please use
//  Locale Names instead, eg: "en" instead of a LANGID like 0x09.
//  See the documentation for GetLocaleInfoEx.
//
//  Note that the named locale APIs (eg GetLocaleInfoEx) are preferred.
//
//  WARNING: Not all locales/languages have unique Language IDs
//
//  The following two combinations of primary language ID and
//  sublanguage ID have special semantics:
//
//    Primary Language ID   Sublanguage ID      Result
//    -------------------   ---------------     ------------------------
//    LANG_NEUTRAL          SUBLANG_NEUTRAL     Language neutral
//    LANG_NEUTRAL          SUBLANG_DEFAULT     User default language
//    LANG_NEUTRAL          SUBLANG_SYS_DEFAULT System default language
//    LANG_INVARIANT        SUBLANG_NEUTRAL     Invariant locale
//
//  This concept is deprecated.  It is strongly recommended that
//  applications test for locale names instead of Language IDs / LCIDs.
//
//  Primary language IDs.
//
//  WARNING: This pattern is broken and not followed for all languages.
//           Serbian, Bosnian & Croatian are a few examples.
//
//  WARNING: There are > 6000 human languages.  The PRIMARYLANGID construct
//           cannot support all languages your application may encounter.
//           Please use Language Names, such as "en".
//
//  WARNING: Some languages may have more than one PRIMARYLANGID.  Please
//           use Locale Names, such as "en-FJ".
//
//  WARNING: Some languages do not have assigned LANGIDs.  Please use
//           Locale Names, such as "tlh-Piqd".
//
//  It is recommended that applications test for locale names or actual LCIDs.
//
//  Note that the LANG, SUBLANG construction is not always consistent.
//  The named locale APIs (eg GetLocaleInfoEx) are recommended.
//
// ** DEPRECATED ** DEPRECATED ** DEPRECATED ** DEPRECATED ** DEPRECATED **
//














































































































































//
// ** DEPRECATED ** DEPRECATED ** DEPRECATED ** DEPRECATED ** DEPRECATED **
//
//  DEPRECATED: The Sublanguage ID concept is deprecated, please use
//  Locale Names instead, eg: "en-US" instead of an LCID like 0x0409.
//  See the documentation for GetLocaleInfoEx.
//
//  The name immediately following SUBLANG_ dictates which primary
//  language ID that sublanguage ID can be combined with to form a
//  valid language ID.
//
//  Note that the LANG, SUBLANG construction is not always consistent.
//  The named locale APIs (eg GetLocaleInfoEx) are recommended.
//
//  WARNING: The pattern is broken and not followed for all languages.
//           Serbian, Bosnian & Croatian are a few examples.
//
//  WARNING: The "SUBLANG" depends on the primary language and is inconsistent.
//           SUBLANG_ENGLISH_US is 0x1 and SUBLANG_SPANISH_US is 0x15, so
//           it is impossible to determine region merely by inspecting the
//           SUBLANG.  Please use Locale Names such as "en-US" instead.
//
//  WARNING: Numerous SUBLANGS are assigned the same value, so 0x01 could be
//           US, French, or many other variations.  Please use Locale Names
//           such as "en-US" instead.  If that is not possible, consider
//           testing the entire LCID, eg: 0x0409.
//
//  WARNING: There are > 6000 human languages.  The PRIMARYLANGID construct
//           cannot support all languages your application may encounter.
//           Please use Language Names, such as "en".
//
//  WARNING: There are > 200 country-regions.  The SUBLANGID construct cannot
//           represent all valid dialects of languages such as English.
//           Please use Locale Names, such as "en-US".
//
//  WARNING: Some languages may have more than one PRIMARYLANGID.  Please
//           use Locale Names, such as "en-FJ".
//
//  WARNING: Some languages do not have assigned LANGIDs.  Please use
//           Locale Names, such as "tlh-Piqd".
//
// ** DEPRECATED ** DEPRECATED ** DEPRECATED ** DEPRECATED ** DEPRECATED **
//


























































































































































































































































//
//  Sorting IDs.
//
//  Note that the named locale APIs (eg CompareStringExEx) are recommended.
//



























// end_r_winnt

//
// ** DEPRECATED ** DEPRECATED ** DEPRECATED ** DEPRECATED ** DEPRECATED **
//
//  DEPRECATED: The LCID/LANGID/SORTID concept is deprecated, please use
//  Locale Names instead, eg: "en-US" instead of an LCID like 0x0409.
//  See the documentation for GetLocaleInfoEx.
//
//  A language ID is a 16 bit value which is the combination of a
//  primary language ID and a secondary language ID.  The bits are
//  allocated as follows:
//
//       +-----------------------+-------------------------+
//       |     Sublanguage ID    |   Primary Language ID   |
//       +-----------------------+-------------------------+
//        15                   10 9                       0   bit
//
//  WARNING:  This pattern is broken and not followed for all languages.
//            Serbian, Bosnian & Croatian are a few examples.
//
//  WARNING:  There are > 6000 human languages.  The PRIMARYLANGID construct
//            cannot support all languages your application may encounter.
//            Please use Language Names, such as "en".
//
//  WARNING:  There are > 200 country-regions.  The SUBLANGID construct cannot
//            represent all valid dialects of languages such as English.
//            Please use Locale Names, such as "en-US".
//
//  WARNING:  Some languages may have more than one PRIMARYLANGID.  Please
//            use Locale Names, such as "en-FJ".
//
//  WARNING:  Some languages do not have assigned LANGIDs.  Please use
//            Locale Names, such as "tlh-Piqd".
//
//  It is recommended that applications test for locale names rather than
//  attempting to construct/deconstruct LANGID/PRIMARYLANGID/SUBLANGID
//
//  Language ID creation/extraction macros:
//
//    MAKELANGID    - construct language id from a primary language id and
//                    a sublanguage id.
//    PRIMARYLANGID - extract primary language id from a language id.
//    SUBLANGID     - extract sublanguage id from a language id.
//
//  Note that the LANG, SUBLANG construction is not always consistent.
//  The named locale APIs (eg GetLocaleInfoEx) are recommended.
//
//  DEPRECATED: Language IDs do not exist for all locales
//
// ** DEPRECATED ** DEPRECATED ** DEPRECATED ** DEPRECATED ** DEPRECATED **
//




//
// ** DEPRECATED ** DEPRECATED ** DEPRECATED ** DEPRECATED ** DEPRECATED **
//
//  DEPRECATED: The LCID/LANGID/SORTID concept is deprecated, please use
//  Locale Names instead, eg: en-US instead of an LCID like 0x0409.
//  See the documentation for GetLocaleInfoEx.
//
//  A locale ID is a 32 bit value which is the combination of a
//  language ID, a sort ID, and a reserved area.  The bits are
//  allocated as follows:
//
//       +-------------+---------+-------------------------+
//       |   Reserved  | Sort ID |      Language ID        |
//       +-------------+---------+-------------------------+
//        31         20 19     16 15                      0   bit
//
//  WARNING: This pattern isn't always followed (es-ES_tradnl vs es-ES for example)
//
//  WARNING: Some locales do not have assigned LCIDs.  Please use
//           Locale Names, such as "tlh-Piqd".
//
//  It is recommended that applications test for locale names rather than
//  attempting to rely on LCID or LANGID behavior.
//
//  DEPRECATED: Locale ID creation/extraction macros:
//
//    MAKELCID            - construct the locale id from a language id and a sort id.
//    MAKESORTLCID        - construct the locale id from a language id, sort id, and sort version.
//    LANGIDFROMLCID      - extract the language id from a locale id.
//    SORTIDFROMLCID      - extract the sort id from a locale id.
//    SORTVERSIONFROMLCID - extract the sort version from a locale id.
//
//  Note that the LANG, SUBLANG construction is not always consistent.
//  The named locale APIs (eg GetLocaleInfoEx) are recommended.
//
//  DEPRECATED: LCIDs do not exist for all locales.
//
// ** DEPRECATED ** DEPRECATED ** DEPRECATED ** DEPRECATED ** DEPRECATED **
//











// Maximum Locale Name Length in Windows
// Locale names are preferred to the deprecated LCID/LANGID concepts.
//
// Locale names should follow the BCP47 recommendations and typically
// include language, script, regional variant, and perhaps additional specifiers.
// BCP47 allows some variation, eg: en-US is preferred to en-Latn-US.


//
// ** DEPRECATED ** DEPRECATED ** DEPRECATED ** DEPRECATED ** DEPRECATED **
//
//  Deprecated default System and User IDs for language and locale.
//
//  Locale names such as LOCALE_NAME_SYSTEM_DEFAULT, LOCALE_NAME_USER_DEFAULT,
//  and LOCALE_NAME_INVARIANT are preferred.  See documentation for GetLocaleInfoEx.
//







//
//  Other special IDs for language and locale.
//
//  DEPRECATED: These identifiers are all underspecified and lose information.
//              Please use Locale Names such as "en-FJ".
//              See documentation for GetLocaleInfoEx.
//















//
// Transient keyboard Locale IDs (LCIDs)
// Should only be used for keyboard layout identification
//
//  DEPRECATED: These identifiers are all transient and will change, even at
//              different times on the same system.
//              Please use Locale Names such as "en-FJ".
//              See documentation for GetLocaleInfoEx.
//





//
// Locale with an unassigned LCID
// These locales cannot be queried by LCID
// Currently same as LOCALE_CUSTOM_UNSPECIFIED
//
// DEPRECATED: Please use Locale Names; see documentation for GetLocaleInfoEx.
//


// begin_ntminiport begin_ntndis begin_ntminitape

//
// Macros used to eliminate compiler warning generated when formal
// parameters or local variables are not declared.
//
// Use DBG_UNREFERENCED_PARAMETER() when a parameter is not yet
// referenced but will be once the module is completely developed.
//
// Use DBG_UNREFERENCED_LOCAL_VARIABLE() when a local variable is not yet
// referenced but will be once the module is completely developed.
//
// Use UNREFERENCED_PARAMETER() if a parameter will never be referenced.
//
// DBG_UNREFERENCED_PARAMETER and DBG_UNREFERENCED_LOCAL_VARIABLE will
// eventually be made into a null macro to help determine whether there
// is unfinished work.
//

// begin_ntoshvp
















#line 2341 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winnt.h"


























#line 2368 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winnt.h"

// end_ntoshvp

//
// Macro used to eliminate compiler warning 4715 within a switch statement
// when all possible cases have already been accounted for.
//
// switch (a & 3) {
//     case 0: return 1;
//     case 1: return Foo();
//     case 2: return Bar();
//     case 3: return 1;
//     DEFAULT_UNREACHABLE;
//












#line 2395 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winnt.h"



// Define operator overloads to enable bit operations on enum values that are
// used to define flags. Use DEFINE_ENUM_FLAG_OPERATORS(YOUR_TYPE) to enable these
// operators on YOUR_TYPE.

// Moved here from objbase.w.

// Templates are defined here in order to avoid a dependency on C++ <type_traits> header file,
// or on compiler-specific constructs.
extern "C++" {

    template <size_t S>
    struct _ENUM_FLAG_INTEGER_FOR_SIZE;

    template <>
    struct _ENUM_FLAG_INTEGER_FOR_SIZE<1>
    {
        typedef INT8 type;
    };

    template <>
    struct _ENUM_FLAG_INTEGER_FOR_SIZE<2>
    {
        typedef INT16 type;
    };

    template <>
    struct _ENUM_FLAG_INTEGER_FOR_SIZE<4>
    {
        typedef INT32 type;
    };

    template <>
    struct _ENUM_FLAG_INTEGER_FOR_SIZE<8>
    {
        typedef INT64 type;
    };

    // used as an approximation of std::underlying_type<T>
    template <class T>
    struct _ENUM_FLAG_SIZED_INTEGER
    {
        typedef typename _ENUM_FLAG_INTEGER_FOR_SIZE<sizeof(T)>::type type;
    };

}





#line 2449 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winnt.h"













#line 2463 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winnt.h"

// Compile-time macros for initializing flag values in const data.
//
// When using DEFINE_ENUM_FLAG_OPERATORS for enum values you should use the macros below
// when you need to initialize global const data.  Without these macros the inline operators
// from DEFINE_ENUM_FLAG_OPERATORS force a runtime initialization rather than a
// compile time initialization.  This applies even if you have declared the data as const.
//
// This is no longer necessary for compilers that support constexpr.







// Much of the Windows SDK assumes the default packing of structs.


static_assert(__alignof(LARGE_INTEGER) == 8, "Windows headers require the default packing option. Changing this can lead to memory corruption."
    " This diagnostic can be disabled by building with WINDOWS_IGNORE_PACKING_MISMATCH defined.");





#line 2490 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winnt.h"
#line 2491 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winnt.h"




/*lint -save -e767 */  
































































#line 2561 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winnt.h"
/*lint -restore */  
#line 2563 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winnt.h"
#line 2564 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winnt.h"





typedef ULONG_PTR KSPIN_LOCK;
typedef KSPIN_LOCK *PKSPIN_LOCK;

// begin_ntoshvp

//
// Define 128-bit 16-byte aligned xmm register type.
//

typedef struct __declspec(align(16)) _M128A {
    ULONGLONG Low;
    LONGLONG High;
} M128A, *PM128A;

//
// Format of data for (F)XSAVE/(F)XRSTOR instruction
//

typedef struct __declspec(align(16)) _XSAVE_FORMAT {
    WORD   ControlWord;
    WORD   StatusWord;
    BYTE  TagWord;
    BYTE  Reserved1;
    WORD   ErrorOpcode;
    DWORD ErrorOffset;
    WORD   ErrorSelector;
    WORD   Reserved2;
    DWORD DataOffset;
    WORD   DataSelector;
    WORD   Reserved3;
    DWORD MxCsr;
    DWORD MxCsr_Mask;
    M128A FloatRegisters[8];



    M128A XmmRegisters[16];
    BYTE  Reserved4[96];






#line 2614 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winnt.h"

} XSAVE_FORMAT, *PXSAVE_FORMAT;

// end_ntoshvp

//
// Format for CET_U XSTATE component.
//

typedef struct _XSAVE_CET_U_FORMAT {
    DWORD64 Ia32CetUMsr;
    DWORD64 Ia32Pl3SspMsr;
} XSAVE_CET_U_FORMAT, *PXSAVE_CET_U_FORMAT;

typedef struct __declspec(align(8)) _XSAVE_AREA_HEADER {
    DWORD64 Mask;
    DWORD64 CompactionMask;
    DWORD64 Reserved2[6];
} XSAVE_AREA_HEADER, *PXSAVE_AREA_HEADER;

typedef struct __declspec(align(16)) _XSAVE_AREA {
    XSAVE_FORMAT LegacyState;
    XSAVE_AREA_HEADER Header;
} XSAVE_AREA, *PXSAVE_AREA;

typedef struct _XSTATE_CONTEXT {
    DWORD64 Mask;
    DWORD Length;
    DWORD Reserved1;
     PXSAVE_AREA Area;



#line 2648 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winnt.h"

    PVOID Buffer;



#line 2654 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winnt.h"

} XSTATE_CONTEXT, *PXSTATE_CONTEXT;

//
// Scope table structure definition.
//

typedef struct _SCOPE_TABLE_AMD64 {
    DWORD Count;
    struct {
        DWORD BeginAddress;
        DWORD EndAddress;
        DWORD HandlerAddress;
        DWORD JumpTarget;
    } ScopeRecord[1];
} SCOPE_TABLE_AMD64, *PSCOPE_TABLE_AMD64;

// begin_ntoshvp






//
// Define bit test intrinsics.
//


extern "C" {
#line 2685 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winnt.h"




























BOOLEAN
_bittest (
     LONG const *Base,
     LONG Offset
    );

BOOLEAN
_bittestandcomplement (
     LONG *Base,
     LONG Offset
    );

BOOLEAN
_bittestandset (
     LONG *Base,
     LONG Offset
    );

BOOLEAN
_bittestandreset (
     LONG *Base,
     LONG Offset
    );

BOOLEAN
_interlockedbittestandset (
      LONG volatile *Base,
     LONG Offset
    );

BOOLEAN
_interlockedbittestandreset (
      LONG volatile *Base,
     LONG Offset
    );

BOOLEAN
_bittest64 (
     LONG64 const *Base,
     LONG64 Offset
    );

BOOLEAN
_bittestandcomplement64 (
     LONG64 *Base,
     LONG64 Offset
    );

BOOLEAN
_bittestandset64 (
     LONG64 *Base,
     LONG64 Offset
    );

BOOLEAN
_bittestandreset64 (
     LONG64 *Base,
     LONG64 Offset
    );

BOOLEAN
_interlockedbittestandset64 (
      LONG64 volatile *Base,
     LONG64 Offset
    );

BOOLEAN
_interlockedbittestandreset64 (
      LONG64 volatile *Base,
     LONG64 Offset
    );

#pragma intrinsic(_bittest)
#pragma intrinsic(_bittestandcomplement)
#pragma intrinsic(_bittestandset)
#pragma intrinsic(_bittestandreset)
#pragma intrinsic(_interlockedbittestandset)
#pragma intrinsic(_interlockedbittestandreset)

#pragma intrinsic(_bittest64)
#pragma intrinsic(_bittestandcomplement64)
#pragma intrinsic(_bittestandset64)
#pragma intrinsic(_bittestandreset64)
#pragma intrinsic(_interlockedbittestandset64)
#pragma intrinsic(_interlockedbittestandreset64)

//
// Define bit scan intrinsics.
//







BOOLEAN
_BitScanForward (
     DWORD *Index,
     DWORD Mask
    );


BOOLEAN
_BitScanReverse (
     DWORD *Index,
     DWORD Mask
    );


BOOLEAN
_BitScanForward64 (
     DWORD *Index,
     DWORD64 Mask
    );


BOOLEAN
_BitScanReverse64 (
     DWORD *Index,
     DWORD64 Mask
    );

#pragma intrinsic(_BitScanForward)
#pragma intrinsic(_BitScanReverse)
#pragma intrinsic(_BitScanForward64)
#pragma intrinsic(_BitScanReverse64)

//
// Interlocked intrinsic functions.
//









































































































SHORT
_InterlockedIncrement16 (
      SHORT volatile *Addend
    );

SHORT
_InterlockedDecrement16 (
      SHORT volatile *Addend
    );

SHORT
_InterlockedCompareExchange16 (
      SHORT volatile *Destination,
     SHORT ExChange,
     SHORT Comperand
    );

LONG
_InterlockedAnd (
      LONG volatile *Destination,
     LONG Value
    );

LONG
_InterlockedOr (
      LONG volatile *Destination,
     LONG Value
    );

LONG
_InterlockedXor (
      LONG volatile *Destination,
     LONG Value
    );

LONG64
_InterlockedAnd64 (
      LONG64 volatile *Destination,
     LONG64 Value
    );

LONG64
_InterlockedOr64 (
      LONG64 volatile *Destination,
     LONG64 Value
    );

LONG64
_InterlockedXor64 (
      LONG64 volatile *Destination,
     LONG64 Value
    );

LONG
_InterlockedIncrement (
      LONG volatile *Addend
    );

LONG
_InterlockedDecrement (
      LONG volatile *Addend
    );

LONG
_InterlockedExchange (
      LONG volatile *Target,
     LONG Value
    );

LONG
_InterlockedExchangeAdd (
      LONG volatile *Addend,
     LONG Value
    );



__forceinline
LONG
_InlineInterlockedAdd (
      LONG volatile *Addend,
     LONG Value
    )

{
    return _InterlockedExchangeAdd (Addend, Value) + Value;
}

#line 3038 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winnt.h"

LONG
_InterlockedCompareExchange (
      LONG volatile *Destination,
     LONG ExChange,
     LONG Comperand
    );

LONG64
_InterlockedIncrement64 (
      LONG64 volatile *Addend
    );

LONG64
_InterlockedDecrement64 (
      LONG64 volatile *Addend
    );

LONG64
_InterlockedExchange64 (
      LONG64 volatile *Target,
     LONG64 Value
    );

LONG64
_InterlockedExchangeAdd64 (
      LONG64 volatile *Addend,
     LONG64 Value
    );



__forceinline
LONG64
_InlineInterlockedAdd64 (
      LONG64 volatile *Addend,
     LONG64 Value
    )

{
    return _InterlockedExchangeAdd64 (Addend, Value) + Value;
}

#line 3082 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winnt.h"

LONG64
_InterlockedCompareExchange64 (
      LONG64 volatile *Destination,
     LONG64 ExChange,
     LONG64 Comperand
    );

BOOLEAN
_InterlockedCompareExchange128 (
      LONG64 volatile *Destination,
     LONG64 ExchangeHigh,
     LONG64 ExchangeLow,
     LONG64 *ComparandResult
    );

 PVOID
_InterlockedCompareExchangePointer (
     


     PVOID volatile *Destination,
     PVOID Exchange,
     PVOID Comperand
    );

 PVOID
_InterlockedExchangePointer (
     


     PVOID volatile *Target,
     PVOID Value
    );

#pragma intrinsic(_InterlockedIncrement16)
#pragma intrinsic(_InterlockedDecrement16)
#pragma intrinsic(_InterlockedCompareExchange16)
#pragma intrinsic(_InterlockedAnd)
#pragma intrinsic(_InterlockedOr)
#pragma intrinsic(_InterlockedXor)
#pragma intrinsic(_InterlockedIncrement)
#pragma intrinsic(_InterlockedDecrement)
#pragma intrinsic(_InterlockedExchange)
#pragma intrinsic(_InterlockedExchangeAdd)
#pragma intrinsic(_InterlockedCompareExchange)
#pragma intrinsic(_InterlockedAnd64)
#pragma intrinsic(_InterlockedOr64)
#pragma intrinsic(_InterlockedXor64)
#pragma intrinsic(_InterlockedIncrement64)
#pragma intrinsic(_InterlockedDecrement64)
#pragma intrinsic(_InterlockedExchange64)
#pragma intrinsic(_InterlockedExchangeAdd64)
#pragma intrinsic(_InterlockedCompareExchange64)



#pragma intrinsic(_InterlockedCompareExchange128)

#line 3142 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winnt.h"

#pragma intrinsic(_InterlockedExchangePointer)
#pragma intrinsic(_InterlockedCompareExchangePointer)






CHAR
_InterlockedExchange8 (
      CHAR volatile *Target,
     CHAR Value
    );

SHORT
_InterlockedExchange16 (
      SHORT volatile *Destination,
     SHORT ExChange
    );

#pragma intrinsic(_InterlockedExchange8)
#pragma intrinsic(_InterlockedExchange16)

#line 3167 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winnt.h"











char
_InterlockedExchangeAdd8 (
      char volatile * _Addend,
     char _Value
    );

char
_InterlockedAnd8 (
      char volatile *Destination,
     char Value
    );

char
_InterlockedOr8 (
      char volatile *Destination,
     char Value
    );

char
_InterlockedXor8 (
      char volatile *Destination,
     char Value
    );

SHORT
_InterlockedAnd16 (
      SHORT volatile *Destination,
     SHORT Value
    );

SHORT
_InterlockedOr16 (
      SHORT volatile *Destination,
     SHORT Value
    );

SHORT
_InterlockedXor16 (
      SHORT volatile *Destination,
     SHORT Value
    );

#pragma intrinsic (_InterlockedExchangeAdd8)
#pragma intrinsic (_InterlockedAnd8)
#pragma intrinsic (_InterlockedOr8)
#pragma intrinsic (_InterlockedXor8)
#pragma intrinsic (_InterlockedAnd16)
#pragma intrinsic (_InterlockedOr16)
#pragma intrinsic (_InterlockedXor16)

#line 3229 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winnt.h"

// end_ntoshvp

//
// Define extended CPUID intrinsic.
//



void
__cpuidex (
    int CPUInfo[4],
    int Function,
    int SubLeaf
    );

#pragma intrinsic(__cpuidex)

// begin_ntoshvp

//
// Define function to flush a cache line.
//



void
_mm_clflush (
     void const *Address
    );

#pragma intrinsic(_mm_clflush)

// begin_sdfwdm
// begin_wudfpwdm

void
_ReadWriteBarrier (
    void
    );

#pragma intrinsic(_ReadWriteBarrier)

//
// Define memory fence intrinsics
//



// end_wudfpwdm
// end_sdfwdm






// begin_sdfwdm
// begin_wudfpwdm

void
__faststorefence (
    void
    );

// end_wudfpwdm
// end_sdfwdm

void
_mm_lfence (
    void
    );

void
_mm_mfence (
    void
    );

void
_mm_sfence (
    void
    );

void
_mm_pause (
    void
    );

void
_mm_prefetch (
     CHAR const *a,
     int sel
    );

void
_m_prefetchw (
     volatile const void *Source
    );

//
// Define constants for use with _mm_prefetch.
//






// begin_sdfwdm
// begin_wudfpwdm

#pragma intrinsic(__faststorefence)

// end_wudfpwdm
// end_sdfwdm

#pragma intrinsic(_mm_pause)
#pragma intrinsic(_mm_prefetch)
#pragma intrinsic(_mm_lfence)
#pragma intrinsic(_mm_mfence)
#pragma intrinsic(_mm_sfence)
#pragma intrinsic(_m_prefetchw)







//
// PreFetchCacheLine level defines.
//






//
// Define get/set MXCSR intrinsics.
//




unsigned int
_mm_getcsr (
    void
    );

void
_mm_setcsr (
     unsigned int MxCsr
    );

#pragma intrinsic(_mm_getcsr)
#pragma intrinsic(_mm_setcsr)

//
// Define function to get the caller's EFLAGs value.
//



unsigned __int32
__getcallerseflags (
    void
    );

#pragma intrinsic(__getcallerseflags)

//
// Define function to get segment limit.
//



DWORD
__segmentlimit (
     DWORD Selector
    );

#pragma intrinsic(__segmentlimit)

//
// Define function to read the value of a performance counter.
//



DWORD64
__readpmc (
     DWORD Counter
    );

#pragma intrinsic(__readpmc)

//
// Define function to read the value of the time stamp counter
//



DWORD64
__rdtsc (
    void
    );

#pragma intrinsic(__rdtsc)

//
// Define functions to move strings as bytes, words, dwords, and qwords.
//

void
__movsb (
     PBYTE  Destination,
     BYTE  const *Source,
     SIZE_T Count
    );

void
__movsw (
     PWORD   Destination,
     WORD   const *Source,
     SIZE_T Count
    );

void
__movsd (
     PDWORD Destination,
     DWORD const *Source,
     SIZE_T Count
    );

void
__movsq (
     PDWORD64 Destination,
     DWORD64 const *Source,
     SIZE_T Count
    );

#pragma intrinsic(__movsb)
#pragma intrinsic(__movsw)
#pragma intrinsic(__movsd)
#pragma intrinsic(__movsq)

//
// Define functions to store strings as bytes, words, dwords, and qwords.
//

void
__stosb (
     PBYTE  Destination,
     BYTE  Value,
     SIZE_T Count
    );

void
__stosw (
     PWORD   Destination,
     WORD   Value,
     SIZE_T Count
    );

void
__stosd (
     PDWORD Destination,
     DWORD Value,
     SIZE_T Count
    );

void
__stosq (
     PDWORD64 Destination,
     DWORD64 Value,
     SIZE_T Count
    );

#pragma intrinsic(__stosb)
#pragma intrinsic(__stosw)
#pragma intrinsic(__stosd)
#pragma intrinsic(__stosq)

//
// Define functions to capture the high 64-bits of a 128-bit multiply.
//




LONGLONG
__mulh (
     LONG64 Multiplier,
     LONG64 Multiplicand
    );

ULONGLONG
__umulh (
     DWORD64 Multiplier,
     DWORD64 Multiplicand
    );

#pragma intrinsic(__mulh)
#pragma intrinsic(__umulh)

//
// Define population count intrinsic.
//



DWORD64
__popcnt64 (
     DWORD64 operand
    );



#pragma intrinsic(__popcnt64)

#line 3551 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winnt.h"

//
// Define functions to perform 128-bit shifts
//




DWORD64
__shiftleft128 (
     DWORD64 LowPart,
     DWORD64 HighPart,
     BYTE  Shift
    );

DWORD64
__shiftright128 (
     DWORD64 LowPart,
     DWORD64 HighPart,
     BYTE  Shift
    );

#pragma intrinsic(__shiftleft128)
#pragma intrinsic(__shiftright128)

//
// Define functions to perform 128-bit multiplies.
//



LONG64
_mul128 (
     LONG64 Multiplier,
     LONG64 Multiplicand,
     LONG64 *HighProduct
    );

#pragma intrinsic(_mul128)





DWORD64
_umul128 (
     DWORD64 Multiplier,
     DWORD64 Multiplicand,
     DWORD64 *HighProduct
    );

#pragma intrinsic(_umul128)

#line 3605 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winnt.h"

__forceinline
LONG64
MultiplyExtract128 (
     LONG64 Multiplier,
     LONG64 Multiplicand,
     BYTE  Shift
    )

{

    LONG64 extractedProduct;
    LONG64 highProduct;
    LONG64 lowProduct;
    BOOLEAN negate;
    DWORD64 uhighProduct;
    DWORD64 ulowProduct;

    lowProduct = _mul128 (Multiplier, Multiplicand, &highProduct);
    negate = 0 ;
    uhighProduct = (DWORD64)highProduct;
    ulowProduct = (DWORD64)lowProduct;
    if (highProduct < 0) {
        negate = 1 ;
        uhighProduct = (DWORD64)(-highProduct);
        ulowProduct = (DWORD64)(-lowProduct);
        if (ulowProduct != 0) {
            uhighProduct -= 1;
        }
    }

    extractedProduct = (LONG64)__shiftright128 (ulowProduct, uhighProduct, Shift);
    if (negate != 0 ) {
        extractedProduct = -extractedProduct;
    }

    return extractedProduct;
}

__forceinline
DWORD64
UnsignedMultiplyExtract128 (
     DWORD64 Multiplier,
     DWORD64 Multiplicand,
     BYTE  Shift
    )

{

    DWORD64 extractedProduct;
    DWORD64 highProduct;
    DWORD64 lowProduct;

    lowProduct = _umul128 (Multiplier, Multiplicand, &highProduct);
    extractedProduct = __shiftright128 (lowProduct, highProduct, Shift);
    return extractedProduct;
}

//
// Define functions to read and write the uer TEB and the system PCR/PRCB.
//

BYTE 
__readgsbyte (
     DWORD Offset
    );

WORD  
__readgsword (
     DWORD Offset
    );

DWORD
__readgsdword (
     DWORD Offset
    );

DWORD64
__readgsqword (
     DWORD Offset
    );

void
__writegsbyte (
     DWORD Offset,
     BYTE  Data
    );

void
__writegsword (
     DWORD Offset,
     WORD   Data
    );

void
__writegsdword (
     DWORD Offset,
     DWORD Data
    );

void
__writegsqword (
     DWORD Offset,
     DWORD64 Data
    );

#pragma intrinsic(__readgsbyte)
#pragma intrinsic(__readgsword)
#pragma intrinsic(__readgsdword)
#pragma intrinsic(__readgsqword)
#pragma intrinsic(__writegsbyte)
#pragma intrinsic(__writegsword)
#pragma intrinsic(__writegsdword)
#pragma intrinsic(__writegsqword)



void
__incgsbyte (
     DWORD Offset
    );

void
__addgsbyte (
     DWORD Offset,
     BYTE  Value
    );

void
__incgsword (
     DWORD Offset
    );

void
__addgsword (
     DWORD Offset,
     WORD   Value
    );

void
__incgsdword (
     DWORD Offset
    );

void
__addgsdword (
     DWORD Offset,
     DWORD Value
    );

void
__incgsqword (
     DWORD Offset
    );

void
__addgsqword (
     DWORD Offset,
     DWORD64 Value
    );










#line 3776 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winnt.h"

#line 3778 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winnt.h"



}
#line 3783 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winnt.h"

#line 3785 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winnt.h"

// end_ntoshvp
//
// The following values specify the type of access in the first parameter
// of the exception record whan the exception code specifies an access
// violation.
//





// begin_wx86
//
// The following flags control the contents of the CONTEXT structure.
//





// end_wx86




















#line 3828 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winnt.h"






// begin_wx86

#line 3837 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winnt.h"

//
// Define initial MxCsr and FpCsr control.
//




// end_ntddk
// begin_wdm begin_ntosp
// begin_ntoshvp

typedef XSAVE_FORMAT XMM_SAVE_AREA32, *PXMM_SAVE_AREA32;

// end_wdm end_ntosp
// begin_ntddk

//
// Context Frame
//
//  This frame has a several purposes: 1) it is used as an argument to
//  NtContinue, 2) it is used to constuct a call frame for APC delivery,
//  and 3) it is used in the user level thread creation routines.
//
//
// The flags field within this record controls the contents of a CONTEXT
// record.
//
// If the context record is used as an input parameter, then for each
// portion of the context record controlled by a flag whose value is
// set, it is assumed that that portion of the context record contains
// valid context. If the context record is being used to modify a threads
// context, then only that portion of the threads context is modified.
//
// If the context record is used as an output parameter to capture the
// context of a thread, then only those portions of the thread's context
// corresponding to set flags will be returned.
//
// CONTEXT_CONTROL specifies SegSs, Rsp, SegCs, Rip, and EFlags.
//
// CONTEXT_INTEGER specifies Rax, Rcx, Rdx, Rbx, Rbp, Rsi, Rdi, and R8-R15.
//
// CONTEXT_SEGMENTS specifies SegDs, SegEs, SegFs, and SegGs.
//
// CONTEXT_FLOATING_POINT specifies Xmm0-Xmm15.
//
// CONTEXT_DEBUG_REGISTERS specifies Dr0-Dr3 and Dr6-Dr7.
//

typedef struct __declspec(align(16)) __declspec(no_init_all) _CONTEXT {

    //
    // Register parameter home addresses.
    //
    // N.B. These fields are for convience - they could be used to extend the
    //      context record in the future.
    //

    DWORD64 P1Home;
    DWORD64 P2Home;
    DWORD64 P3Home;
    DWORD64 P4Home;
    DWORD64 P5Home;
    DWORD64 P6Home;

    //
    // Control flags.
    //

    DWORD ContextFlags;
    DWORD MxCsr;

    //
    // Segment Registers and processor flags.
    //

    WORD   SegCs;
    WORD   SegDs;
    WORD   SegEs;
    WORD   SegFs;
    WORD   SegGs;
    WORD   SegSs;
    DWORD EFlags;

    //
    // Debug registers
    //

    DWORD64 Dr0;
    DWORD64 Dr1;
    DWORD64 Dr2;
    DWORD64 Dr3;
    DWORD64 Dr6;
    DWORD64 Dr7;

    //
    // Integer registers.
    //

    DWORD64 Rax;
    DWORD64 Rcx;
    DWORD64 Rdx;
    DWORD64 Rbx;
    DWORD64 Rsp;
    DWORD64 Rbp;
    DWORD64 Rsi;
    DWORD64 Rdi;
    DWORD64 R8;
    DWORD64 R9;
    DWORD64 R10;
    DWORD64 R11;
    DWORD64 R12;
    DWORD64 R13;
    DWORD64 R14;
    DWORD64 R15;

    //
    // Program counter.
    //

    DWORD64 Rip;

    //
    // Floating point state.
    //

    union {
        XMM_SAVE_AREA32 FltSave;
        struct {
            M128A Header[2];
            M128A Legacy[8];
            M128A Xmm0;
            M128A Xmm1;
            M128A Xmm2;
            M128A Xmm3;
            M128A Xmm4;
            M128A Xmm5;
            M128A Xmm6;
            M128A Xmm7;
            M128A Xmm8;
            M128A Xmm9;
            M128A Xmm10;
            M128A Xmm11;
            M128A Xmm12;
            M128A Xmm13;
            M128A Xmm14;
            M128A Xmm15;
        }  ;
    }  ;

    //
    // Vector registers.
    //

    M128A VectorRegister[26];
    DWORD64 VectorControl;

    //
    // Special debug control registers.
    //

    DWORD64 DebugControl;
    DWORD64 LastBranchToRip;
    DWORD64 LastBranchFromRip;
    DWORD64 LastExceptionToRip;
    DWORD64 LastExceptionFromRip;
} CONTEXT, *PCONTEXT;

// end_ntoshvp
//
// Select platform-specific definitions
//

typedef struct _IMAGE_RUNTIME_FUNCTION_ENTRY RUNTIME_FUNCTION, *PRUNTIME_FUNCTION;
typedef SCOPE_TABLE_AMD64 SCOPE_TABLE, *PSCOPE_TABLE;



//
// Define unwind information flags.
//








//
// Define unwind history table structure.
//



typedef struct _UNWIND_HISTORY_TABLE_ENTRY {
    DWORD64 ImageBase;
    PRUNTIME_FUNCTION FunctionEntry;
} UNWIND_HISTORY_TABLE_ENTRY, *PUNWIND_HISTORY_TABLE_ENTRY;

typedef struct _UNWIND_HISTORY_TABLE {
    DWORD Count;
    BYTE  LocalHint;
    BYTE  GlobalHint;
    BYTE  Search;
    BYTE  Once;
    DWORD64 LowAddress;
    DWORD64 HighAddress;
    UNWIND_HISTORY_TABLE_ENTRY Entry[12 ];
} UNWIND_HISTORY_TABLE, *PUNWIND_HISTORY_TABLE;

//
// Define dynamic function table entry.
//

typedef

PRUNTIME_FUNCTION
GET_RUNTIME_FUNCTION_CALLBACK (
     DWORD64 ControlPc,
     PVOID Context
    );
typedef GET_RUNTIME_FUNCTION_CALLBACK *PGET_RUNTIME_FUNCTION_CALLBACK;

typedef

DWORD   
OUT_OF_PROCESS_FUNCTION_TABLE_CALLBACK (
     HANDLE Process,
     PVOID TableAddress,
     PDWORD Entries,
     PRUNTIME_FUNCTION* Functions
    );
typedef OUT_OF_PROCESS_FUNCTION_TABLE_CALLBACK *POUT_OF_PROCESS_FUNCTION_TABLE_CALLBACK;




//
// Define exception dispatch context structure.
//

typedef struct _DISPATCHER_CONTEXT {
    DWORD64 ControlPc;
    DWORD64 ImageBase;
    PRUNTIME_FUNCTION FunctionEntry;
    DWORD64 EstablisherFrame;
    DWORD64 TargetIp;
    PCONTEXT ContextRecord;
    PEXCEPTION_ROUTINE LanguageHandler;
    PVOID HandlerData;
    PUNWIND_HISTORY_TABLE HistoryTable;
    DWORD ScopeIndex;
    DWORD Fill0;
} DISPATCHER_CONTEXT, *PDISPATCHER_CONTEXT;

//
// Define exception filter and termination handler function types.
//

struct _EXCEPTION_POINTERS;
typedef
LONG
(*PEXCEPTION_FILTER) (
    struct _EXCEPTION_POINTERS *ExceptionPointers,
    PVOID EstablisherFrame
    );

typedef
void
(*PTERMINATION_HANDLER) (
    BOOLEAN _abnormal_termination ,
    PVOID EstablisherFrame
    );


//
// Nonvolatile context pointer record.
//

typedef struct _KNONVOLATILE_CONTEXT_POINTERS {
    union {
        PM128A FloatingContext[16];
        struct {
            PM128A Xmm0;
            PM128A Xmm1;
            PM128A Xmm2;
            PM128A Xmm3;
            PM128A Xmm4;
            PM128A Xmm5;
            PM128A Xmm6;
            PM128A Xmm7;
            PM128A Xmm8;
            PM128A Xmm9;
            PM128A Xmm10;
            PM128A Xmm11;
            PM128A Xmm12;
            PM128A Xmm13;
            PM128A Xmm14;
            PM128A Xmm15;
        }  ;
    }  ;

    union {
        PDWORD64 IntegerContext[16];
        struct {
            PDWORD64 Rax;
            PDWORD64 Rcx;
            PDWORD64 Rdx;
            PDWORD64 Rbx;
            PDWORD64 Rsp;
            PDWORD64 Rbp;
            PDWORD64 Rsi;
            PDWORD64 Rdi;
            PDWORD64 R8;
            PDWORD64 R9;
            PDWORD64 R10;
            PDWORD64 R11;
            PDWORD64 R12;
            PDWORD64 R13;
            PDWORD64 R14;
            PDWORD64 R15;
        }  ;
    }  ;

} KNONVOLATILE_CONTEXT_POINTERS, *PKNONVOLATILE_CONTEXT_POINTERS;

#line 4165 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winnt.h"

//
// Scope table structure definition.
//

typedef struct _SCOPE_TABLE_ARM {
    DWORD Count;
    struct
    {
        DWORD BeginAddress;
        DWORD EndAddress;
        DWORD HandlerAddress;
        DWORD JumpTarget;
    } ScopeRecord[1];
} SCOPE_TABLE_ARM, *PSCOPE_TABLE_ARM;






























































































































































































































































































































































































































































































































































































































































































































































































































































































































































































//
// Scope table structure definition.
//

typedef struct _SCOPE_TABLE_ARM64 {
    DWORD Count;
    struct
    {
        DWORD BeginAddress;
        DWORD EndAddress;
        DWORD HandlerAddress;
        DWORD JumpTarget;
    } ScopeRecord[1];
} SCOPE_TABLE_ARM64, *PSCOPE_TABLE_ARM64;

// begin_ntddk begin_wdm begin_nthal begin_ntminiport begin_wx86















































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































#line 6322 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winnt.h"

// end_ntoshvp

//
// Nonvolatile context pointer record.
//

typedef struct _KNONVOLATILE_CONTEXT_POINTERS_ARM64 {

    PDWORD64 X19;
    PDWORD64 X20;
    PDWORD64 X21;
    PDWORD64 X22;
    PDWORD64 X23;
    PDWORD64 X24;
    PDWORD64 X25;
    PDWORD64 X26;
    PDWORD64 X27;
    PDWORD64 X28;
    PDWORD64 Fp;
    PDWORD64 Lr;

    PDWORD64 D8;
    PDWORD64 D9;
    PDWORD64 D10;
    PDWORD64 D11;
    PDWORD64 D12;
    PDWORD64 D13;
    PDWORD64 D14;
    PDWORD64 D15;

} KNONVOLATILE_CONTEXT_POINTERS_ARM64, *PKNONVOLATILE_CONTEXT_POINTERS_ARM64;





#line 6360 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winnt.h"












#line 6373 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winnt.h"

// begin_wudfwdm


extern "C" {
#line 6379 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winnt.h"

//
// Assert exception.
//














#line 6398 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winnt.h"





void
__int2c (
    void
    );

#pragma intrinsic(__int2c)





#line 6415 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winnt.h"

#line 6417 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winnt.h"










































































































#line 6524 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winnt.h"
#line 6525 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winnt.h"


}
#line 6529 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winnt.h"

// begin_ntoshvp












































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































typedef struct _LDT_ENTRY {
    WORD    LimitLow;
    WORD    BaseLow;
    union {
        struct {
            BYTE    BaseMid;
            BYTE    Flags1;     // Declare as bytes to avoid alignment
            BYTE    Flags2;     // Problems.
            BYTE    BaseHi;
        } Bytes;
        struct {
            DWORD   BaseMid : 8;
            DWORD   Type : 5;
            DWORD   Dpl : 2;
            DWORD   Pres : 1;
            DWORD   LimitHi : 4;
            DWORD   Sys : 1;
            DWORD   Reserved_0 : 1;
            DWORD   Default_Big : 1;
            DWORD   Granularity : 1;
            DWORD   BaseHi : 8;
        } Bits;
    } HighWord;
} LDT_ENTRY, *PLDT_ENTRY;

#line 7721 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winnt.h"


// begin_wdm begin_ntminiport





extern "C" {
#line 7731 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winnt.h"

__forceinline
CHAR
ReadAcquire8 (
      CHAR const volatile *Source
    )

{

    CHAR Value;

    Value = *Source;
    return Value;
}

__forceinline
CHAR
ReadNoFence8 (
      CHAR const volatile *Source
    )

{

    CHAR Value;

    Value = *Source;
    return Value;
}

__forceinline
void
WriteRelease8 (
      CHAR volatile *Destination,
     CHAR Value
    )

{

    *Destination = Value;
    return;
}

__forceinline
void
WriteNoFence8 (
      CHAR volatile *Destination,
     CHAR Value
    )

{

    *Destination = Value;
    return;
}

__forceinline
SHORT
ReadAcquire16 (
      SHORT const volatile *Source
    )

{

    SHORT Value;

    Value = *Source;
    return Value;
}

__forceinline
SHORT
ReadNoFence16 (
      SHORT const volatile *Source
    )

{

    SHORT Value;

    Value = *Source;
    return Value;
}

__forceinline
void
WriteRelease16 (
      SHORT volatile *Destination,
     SHORT Value
    )

{

    *Destination = Value;
    return;
}

__forceinline
void
WriteNoFence16 (
      SHORT volatile *Destination,
     SHORT Value
    )

{

    *Destination = Value;
    return;
}

__forceinline
LONG
ReadAcquire (
      LONG const volatile *Source
    )

{

    LONG Value;

    Value = *Source;
    return Value;
}

__forceinline
LONG
ReadNoFence (
      LONG const volatile *Source
    )

{

    LONG Value;

    Value = *Source;
    return Value;
}

__forceinline
void
WriteRelease (
      LONG volatile *Destination,
     LONG Value
    )

{

    *Destination = Value;
    return;
}

__forceinline
void
WriteNoFence (
      LONG volatile *Destination,
     LONG Value
    )

{

    *Destination = Value;
    return;
}

__forceinline
LONG64
ReadAcquire64 (
      LONG64 const volatile *Source
    )

{

    LONG64 Value;

    Value = *Source;
    return Value;
}

__forceinline
LONG64
ReadNoFence64 (
      LONG64 const volatile *Source
    )

{

    LONG64 Value;

    Value = *Source;
    return Value;
}

__forceinline
void
WriteRelease64 (
      LONG64 volatile *Destination,
     LONG64 Value
    )

{

    *Destination = Value;
    return;
}

__forceinline
void
WriteNoFence64 (
      LONG64 volatile *Destination,
     LONG64 Value
    )

{

    *Destination = Value;
    return;
}


}
#line 7951 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winnt.h"

#line 7953 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winnt.h"

//
// Define "raw" operations which have no ordering or atomicity semantics.
//

__forceinline
CHAR
ReadRaw8 (
      CHAR const volatile *Source
    )

{

    CHAR Value;

    Value = *(CHAR *)Source;
    return Value;
}

__forceinline
void
WriteRaw8 (
      CHAR volatile *Destination,
     CHAR Value
    )

{

    *(CHAR *)Destination = Value;
    return;
}

__forceinline
SHORT
ReadRaw16 (
      SHORT const volatile *Source
    )

{

    SHORT Value;

    Value = *(SHORT *)Source;
    return Value;
}

__forceinline
void
WriteRaw16 (
      SHORT volatile *Destination,
     SHORT Value
    )

{

    *(SHORT *)Destination = Value;
    return;
}

__forceinline
LONG
ReadRaw (
      LONG const volatile *Source
    )

{

    LONG Value;

    Value = *(LONG *)Source;
    return Value;
}

__forceinline
void
WriteRaw (
      LONG volatile *Destination,
     LONG Value
    )

{

    *(LONG *)Destination = Value;
    return;
}

__forceinline
LONG64
ReadRaw64 (
      LONG64 const volatile *Source
    )

{

    LONG64 Value;

    Value = *(LONG64 *)Source;
    return Value;
}

__forceinline
void
WriteRaw64 (
      LONG64 volatile *Destination,
     LONG64 Value
    )

{

    *(LONG64 *)Destination = Value;
    return;
}

//
// Define explicit read and write operations for derived types.
//

__forceinline
BYTE 
ReadUCharAcquire (
      BYTE  const volatile *Source
    )

{

    return (BYTE )ReadAcquire8((PCHAR)Source);
}

__forceinline
BYTE 
ReadUCharNoFence (
      BYTE  const volatile *Source
    )

{

    return (BYTE )ReadNoFence8((PCHAR)Source);
}

__forceinline
BYTE 
ReadBooleanAcquire (
      BOOLEAN const volatile *Source
    )

{

    return (BOOLEAN)ReadAcquire8((PCHAR)Source);
}

__forceinline
BYTE 
ReadBooleanNoFence (
      BOOLEAN const volatile *Source
    )

{

    return (BOOLEAN)ReadNoFence8((PCHAR)Source);
}

__forceinline
BYTE 
ReadUCharRaw (
      BYTE  const volatile *Source
    )

{

    return (BYTE )ReadRaw8((PCHAR)Source);
}

__forceinline
void
WriteUCharRelease (
      BYTE  volatile *Destination,
     BYTE  Value
    )

{

    WriteRelease8((PCHAR)Destination, (CHAR)Value);
    return;
}

__forceinline
void
WriteUCharNoFence (
      BYTE  volatile *Destination,
     BYTE  Value
    )

{

    WriteNoFence8((PCHAR)Destination, (CHAR)Value);
    return;
}

__forceinline
void
WriteBooleanRelease (
      BOOLEAN volatile *Destination,
     BOOLEAN Value
    )

{

    WriteRelease8((PCHAR)Destination, (CHAR)Value);
    return;
}

__forceinline
void
WriteBooleanNoFence (
      BOOLEAN volatile *Destination,
     BOOLEAN Value
    )

{

    WriteNoFence8((PCHAR)Destination, (CHAR)Value);
    return;
}

__forceinline
void
WriteUCharRaw (
      BYTE  volatile *Destination,
     BYTE  Value
    )

{

    WriteRaw8((PCHAR)Destination, (CHAR)Value);
    return;
}

__forceinline
WORD  
ReadUShortAcquire (
      WORD   const volatile *Source
    )

{

    return (WORD  )ReadAcquire16((PSHORT)Source);
}

__forceinline
WORD  
ReadUShortNoFence (
      WORD   const volatile *Source
    )

{

    return (WORD  )ReadNoFence16((PSHORT)Source);
}

__forceinline
WORD  
ReadUShortRaw (
      WORD   const volatile *Source
    )

{

    return (WORD  )ReadRaw16((PSHORT)Source);
}

__forceinline
void
WriteUShortRelease (
      WORD   volatile *Destination,
     WORD   Value
    )

{

    WriteRelease16((PSHORT)Destination, (SHORT)Value);
    return;
}

__forceinline
void
WriteUShortNoFence (
      WORD   volatile *Destination,
     WORD   Value
    )

{

    WriteNoFence16((PSHORT)Destination, (SHORT)Value);
    return;
}

__forceinline
void
WriteUShortRaw (
      WORD   volatile *Destination,
     WORD   Value
    )

{

    WriteRaw16((PSHORT)Destination, (SHORT)Value);
    return;
}

__forceinline
DWORD
ReadULongAcquire (
      DWORD const volatile *Source
    )

{

    return (DWORD)ReadAcquire((PLONG)Source);
}

__forceinline
DWORD
ReadULongNoFence (
      DWORD const volatile *Source
    )

{

    return (DWORD)ReadNoFence((PLONG)Source);
}

__forceinline
DWORD
ReadULongRaw (
      DWORD const volatile *Source
    )

{

    return (DWORD)ReadRaw((PLONG)Source);
}

__forceinline
void
WriteULongRelease (
      DWORD volatile *Destination,
     DWORD Value
    )

{

    WriteRelease((PLONG)Destination, (LONG)Value);
    return;
}

__forceinline
void
WriteULongNoFence (
      DWORD volatile *Destination,
     DWORD Value
    )

{

    WriteNoFence((PLONG)Destination, (LONG)Value);
    return;
}

__forceinline
void
WriteULongRaw (
      DWORD volatile *Destination,
     DWORD Value
    )

{

    WriteRaw((PLONG)Destination, (LONG)Value);
    return;
}

__forceinline
DWORD64
ReadULong64Acquire (
      DWORD64 const volatile *Source
    )

{

    return (DWORD64)ReadAcquire64((PLONG64)Source);
}

__forceinline
DWORD64
ReadULong64NoFence (
      DWORD64 const volatile *Source
    )

{

    return (DWORD64)ReadNoFence64((PLONG64)Source);
}

__forceinline
DWORD64
ReadULong64Raw (
      DWORD64 const volatile *Source
    )

{

    return (DWORD64)ReadRaw64((PLONG64)Source);
}

__forceinline
void
WriteULong64Release (
      DWORD64 volatile *Destination,
     DWORD64 Value
    )

{

    WriteRelease64((PLONG64)Destination, (LONG64)Value);
    return;
}

__forceinline
void
WriteULong64NoFence (
      DWORD64 volatile *Destination,
     DWORD64 Value
    )

{

    WriteNoFence64((PLONG64)Destination, (LONG64)Value);
    return;
}

__forceinline
void
WriteULong64Raw (
      DWORD64 volatile *Destination,
     DWORD64 Value
    )

{

    WriteRaw64((PLONG64)Destination, (LONG64)Value);
    return;
}















































































































#line 8517 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winnt.h"

__forceinline
PVOID
ReadPointerAcquire (
      PVOID const volatile *Source
    )

{

    return (PVOID)ReadAcquire64((PLONG64)Source);
}

__forceinline
PVOID
ReadPointerNoFence (
      PVOID const volatile *Source
    )

{

    return (PVOID)ReadNoFence64((PLONG64)Source);
}

__forceinline
PVOID
ReadPointerRaw (
      PVOID const volatile *Source
    )

{

    return (PVOID)ReadRaw64((PLONG64)Source);
}

__forceinline
void
WritePointerRelease (
      PVOID volatile *Destination,
     PVOID Value
    )

{

    WriteRelease64((PLONG64)Destination, (LONG64)Value);
    return;
}

__forceinline
void
WritePointerNoFence (
      PVOID volatile *Destination,
     PVOID Value
    )

{

    WriteNoFence64((PLONG64)Destination, (LONG64)Value);
    return;
}

__forceinline
void
WritePointerRaw (
      PVOID volatile *Destination,
     PVOID Value
    )

{

    WriteRaw64((PLONG64)Destination, (LONG64)Value);
    return;
}

























#line 8615 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winnt.h"

#line 8617 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winnt.h"

// end_ntddk end_wdm end_ntminiport
#line 8620 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winnt.h"


























#line 8647 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winnt.h"

//
//  Define the size of the 80387 save area, which is in the context frame.
//





typedef struct _WOW64_FLOATING_SAVE_AREA {
    DWORD   ControlWord;
    DWORD   StatusWord;
    DWORD   TagWord;
    DWORD   ErrorOffset;
    DWORD   ErrorSelector;
    DWORD   DataOffset;
    DWORD   DataSelector;
    BYTE    RegisterArea[80 ];
    DWORD   Cr0NpxState;
} WOW64_FLOATING_SAVE_AREA;

typedef WOW64_FLOATING_SAVE_AREA *PWOW64_FLOATING_SAVE_AREA;

#line 1 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\shared\\pshpack4.h"
/*++

Copyright (c) Microsoft Corporation.  All rights reserved.

Module Name:

    pshpack4.h

Abstract:

    This file turns 4 byte packing of structures on.  (That is, it disables
    automatic alignment of structure fields.)  An include file is needed
    because various compilers do this in different ways.  For Microsoft
    compatible compilers, this files uses the push option to the pack pragma
    so that the poppack.h include file can restore the previous packing
    reliably.

    The file poppack.h is the complement to this file.

--*/



#pragma warning(disable:4103)

#pragma pack(push,4)


#line 30 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\shared\\pshpack4.h"


#line 33 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\shared\\pshpack4.h"
#line 34 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\shared\\pshpack4.h"
#line 8671 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winnt.h"

//
// Context Frame
//
//  This frame has a several purposes: 1) it is used as an argument to
//  NtContinue, 2) is is used to constuct a call frame for APC delivery,
//  and 3) it is used in the user level thread creation routines.
//
//  The layout of the record conforms to a standard call frame.
//

typedef struct _WOW64_CONTEXT {

    //
    // The flags values within this flag control the contents of
    // a CONTEXT record.
    //
    // If the context record is used as an input parameter, then
    // for each portion of the context record controlled by a flag
    // whose value is set, it is assumed that that portion of the
    // context record contains valid context. If the context record
    // is being used to modify a threads context, then only that
    // portion of the threads context will be modified.
    //
    // If the context record is used as an IN OUT parameter to capture
    // the context of a thread, then only those portions of the thread's
    // context corresponding to set flags will be returned.
    //
    // The context record is never used as an OUT only parameter.
    //

    DWORD ContextFlags;

    //
    // This section is specified/returned if CONTEXT_DEBUG_REGISTERS is
    // set in ContextFlags.  Note that CONTEXT_DEBUG_REGISTERS is NOT
    // included in CONTEXT_FULL.
    //

    DWORD   Dr0;
    DWORD   Dr1;
    DWORD   Dr2;
    DWORD   Dr3;
    DWORD   Dr6;
    DWORD   Dr7;

    //
    // This section is specified/returned if the
    // ContextFlags word contians the flag CONTEXT_FLOATING_POINT.
    //

    WOW64_FLOATING_SAVE_AREA FloatSave;

    //
    // This section is specified/returned if the
    // ContextFlags word contians the flag CONTEXT_SEGMENTS.
    //

    DWORD   SegGs;
    DWORD   SegFs;
    DWORD   SegEs;
    DWORD   SegDs;

    //
    // This section is specified/returned if the
    // ContextFlags word contians the flag CONTEXT_INTEGER.
    //

    DWORD   Edi;
    DWORD   Esi;
    DWORD   Ebx;
    DWORD   Edx;
    DWORD   Ecx;
    DWORD   Eax;

    //
    // This section is specified/returned if the
    // ContextFlags word contians the flag CONTEXT_CONTROL.
    //

    DWORD   Ebp;
    DWORD   Eip;
    DWORD   SegCs;              // MUST BE SANITIZED
    DWORD   EFlags;             // MUST BE SANITIZED
    DWORD   Esp;
    DWORD   SegSs;

    //
    // This section is specified/returned if the ContextFlags word
    // contains the flag CONTEXT_EXTENDED_REGISTERS.
    // The format and contexts are processor specific
    //

    BYTE    ExtendedRegisters[512 ];

} WOW64_CONTEXT;

typedef WOW64_CONTEXT *PWOW64_CONTEXT;

#line 1 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\shared\\poppack.h"
/*++

Copyright (c) Microsoft Corporation.  All rights reserved.

Module Name:

    poppack.h

Abstract:

    This file turns packing of structures off.  (That is, it enables
    automatic alignment of structure fields.)  An include file is needed
    because various compilers do this in different ways.

    poppack.h is the complement to pshpack?.h.  An inclusion of poppack.h
    MUST ALWAYS be preceded by an inclusion of one of pshpack?.h, in one-to-one
    correspondence.

    For Microsoft compatible compilers, this file uses the pop option
    to the pack pragma so that it can restore the previous saved by the
    pshpack?.h include file.

--*/



#pragma warning(disable:4103)

#pragma pack(pop)


#line 33 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\shared\\poppack.h"


#line 36 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\shared\\poppack.h"
#line 37 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\shared\\poppack.h"
#line 8771 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winnt.h"


typedef struct _WOW64_LDT_ENTRY {
    WORD    LimitLow;
    WORD    BaseLow;
    union {
        struct {
            BYTE    BaseMid;
            BYTE    Flags1;     // Declare as bytes to avoid alignment
            BYTE    Flags2;     // Problems.
            BYTE    BaseHi;
        } Bytes;
        struct {
            DWORD   BaseMid : 8;
            DWORD   Type : 5;
            DWORD   Dpl : 2;
            DWORD   Pres : 1;
            DWORD   LimitHi : 4;
            DWORD   Sys : 1;
            DWORD   Reserved_0 : 1;
            DWORD   Default_Big : 1;
            DWORD   Granularity : 1;
            DWORD   BaseHi : 8;
        } Bits;
    } HighWord;
} WOW64_LDT_ENTRY, *PWOW64_LDT_ENTRY;

typedef struct _WOW64_DESCRIPTOR_TABLE_ENTRY {
    DWORD Selector;
    WOW64_LDT_ENTRY Descriptor;
} WOW64_DESCRIPTOR_TABLE_ENTRY, *PWOW64_DESCRIPTOR_TABLE_ENTRY;


















//
// Exception record definition.
//

typedef struct _EXCEPTION_RECORD {
    DWORD    ExceptionCode;
    DWORD ExceptionFlags;
    struct _EXCEPTION_RECORD *ExceptionRecord;
    PVOID ExceptionAddress;
    DWORD NumberParameters;
    ULONG_PTR ExceptionInformation[15 ];
    } EXCEPTION_RECORD;

typedef EXCEPTION_RECORD *PEXCEPTION_RECORD;

typedef struct _EXCEPTION_RECORD32 {
    DWORD    ExceptionCode;
    DWORD ExceptionFlags;
    DWORD ExceptionRecord;
    DWORD ExceptionAddress;
    DWORD NumberParameters;
    DWORD ExceptionInformation[15 ];
} EXCEPTION_RECORD32, *PEXCEPTION_RECORD32;

typedef struct _EXCEPTION_RECORD64 {
    DWORD    ExceptionCode;
    DWORD ExceptionFlags;
    DWORD64 ExceptionRecord;
    DWORD64 ExceptionAddress;
    DWORD NumberParameters;
    DWORD __unusedAlignment;
    DWORD64 ExceptionInformation[15 ];
} EXCEPTION_RECORD64, *PEXCEPTION_RECORD64;

//
// Typedef for pointer returned by exception_info()
//

typedef struct _EXCEPTION_POINTERS {
    PEXCEPTION_RECORD ExceptionRecord;
    PCONTEXT ContextRecord;
} EXCEPTION_POINTERS, *PEXCEPTION_POINTERS;

// end_ntoshvp
// end_wdm















#line 8881 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winnt.h"

typedef PVOID PACCESS_TOKEN;            
typedef PVOID PSECURITY_DESCRIPTOR;     
typedef PVOID PSID;     
typedef PVOID PCLAIMS_BLOB;     
////////////////////////////////////////////////////////////////////////
//                                                                    //
//                             ACCESS MASK                            //
//                                                                    //
////////////////////////////////////////////////////////////////////////

//
//  Define the access mask as a longword sized structure divided up as
//  follows:
//
//       3 3 2 2 2 2 2 2 2 2 2 2 1 1 1 1 1 1 1 1 1 1
//       1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0
//      +---------------+---------------+-------------------------------+
//      |G|G|G|G|Res'd|A| StandardRights|         SpecificRights        |
//      |R|W|E|A|     |S|               |                               |
//      +-+-------------+---------------+-------------------------------+
//
//      typedef struct _ACCESS_MASK {
//          WORD   SpecificRights;
//          BYTE  StandardRights;
//          BYTE  AccessSystemAcl : 1;
//          BYTE  Reserved : 3;
//          BYTE  GenericAll : 1;
//          BYTE  GenericExecute : 1;
//          BYTE  GenericWrite : 1;
//          BYTE  GenericRead : 1;
//      } ACCESS_MASK;
//      typedef ACCESS_MASK *PACCESS_MASK;
//
//  but to make life simple for programmer's we'll allow them to specify
//  a desired access mask by simply OR'ing together mulitple single rights
//  and treat an access mask as a DWORD.  For example
//
//      DesiredAccess = DELETE | READ_CONTROL
//
//  So we'll declare ACCESS_MASK as DWORD
//

// begin_wdm
// begin_ntoshvp
typedef DWORD ACCESS_MASK;
typedef ACCESS_MASK *PACCESS_MASK;

// end_ntoshvp
// begin_access
////////////////////////////////////////////////////////////////////////
//                                                                    //
//                             ACCESS TYPES                           //
//                                                                    //
////////////////////////////////////////////////////////////////////////


// begin_wdm
//
//  The following are masks for the predefined standard access types
//

















//
// AccessSystemAcl access type
//



//
// MaximumAllowed access type
//



//
//  These are the generic rights.
//






//
//  Define the generic mapping array.  This is used to denote the
//  mapping of each generic access right to a specific access mask.
//

typedef struct _GENERIC_MAPPING {
    ACCESS_MASK GenericRead;
    ACCESS_MASK GenericWrite;
    ACCESS_MASK GenericExecute;
    ACCESS_MASK GenericAll;
} GENERIC_MAPPING;
typedef GENERIC_MAPPING *PGENERIC_MAPPING;



////////////////////////////////////////////////////////////////////////
//                                                                    //
//                        LUID_AND_ATTRIBUTES                         //
//                                                                    //
////////////////////////////////////////////////////////////////////////
//
//


#line 1 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\shared\\pshpack4.h"
/*++

Copyright (c) Microsoft Corporation.  All rights reserved.

Module Name:

    pshpack4.h

Abstract:

    This file turns 4 byte packing of structures on.  (That is, it disables
    automatic alignment of structure fields.)  An include file is needed
    because various compilers do this in different ways.  For Microsoft
    compatible compilers, this files uses the push option to the pack pragma
    so that the poppack.h include file can restore the previous packing
    reliably.

    The file poppack.h is the complement to this file.

--*/



#pragma warning(disable:4103)

#pragma pack(push,4)


#line 30 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\shared\\pshpack4.h"


#line 33 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\shared\\pshpack4.h"
#line 34 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\shared\\pshpack4.h"
#line 9005 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winnt.h"

typedef struct _LUID_AND_ATTRIBUTES {
    LUID Luid;
    DWORD Attributes;
    } LUID_AND_ATTRIBUTES, * PLUID_AND_ATTRIBUTES;
typedef LUID_AND_ATTRIBUTES LUID_AND_ATTRIBUTES_ARRAY[1 ];
typedef LUID_AND_ATTRIBUTES_ARRAY *PLUID_AND_ATTRIBUTES_ARRAY;

#line 1 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\shared\\poppack.h"
/*++

Copyright (c) Microsoft Corporation.  All rights reserved.

Module Name:

    poppack.h

Abstract:

    This file turns packing of structures off.  (That is, it enables
    automatic alignment of structure fields.)  An include file is needed
    because various compilers do this in different ways.

    poppack.h is the complement to pshpack?.h.  An inclusion of poppack.h
    MUST ALWAYS be preceded by an inclusion of one of pshpack?.h, in one-to-one
    correspondence.

    For Microsoft compatible compilers, this file uses the pop option
    to the pack pragma so that it can restore the previous saved by the
    pshpack?.h include file.

--*/



#pragma warning(disable:4103)

#pragma pack(pop)


#line 33 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\shared\\poppack.h"


#line 36 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\shared\\poppack.h"
#line 37 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\shared\\poppack.h"
#line 9014 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winnt.h"


////////////////////////////////////////////////////////////////////////
//                                                                    //
//              Security Id     (SID)                                 //
//                                                                    //
////////////////////////////////////////////////////////////////////////
//
//
// Pictorially the structure of an SID is as follows:
//
//         1   1   1   1   1   1
//         5   4   3   2   1   0   9   8   7   6   5   4   3   2   1   0
//      +---------------------------------------------------------------+
//      |      SubAuthorityCount        |Reserved1 (SBZ)|   Revision    |
//      +---------------------------------------------------------------+
//      |                   IdentifierAuthority[0]                      |
//      +---------------------------------------------------------------+
//      |                   IdentifierAuthority[1]                      |
//      +---------------------------------------------------------------+
//      |                   IdentifierAuthority[2]                      |
//      +---------------------------------------------------------------+
//      |                                                               |
//      +- -  -  -  -  -  -  -  SubAuthority[]  -  -  -  -  -  -  -  - -+
//      |                                                               |
//      +---------------------------------------------------------------+
//
//


// begin_ntifs



typedef struct _SID_IDENTIFIER_AUTHORITY {
    BYTE  Value[6];
} SID_IDENTIFIER_AUTHORITY, *PSID_IDENTIFIER_AUTHORITY;
#line 9052 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winnt.h"




typedef struct _SID {
   BYTE  Revision;
   BYTE  SubAuthorityCount;
   SID_IDENTIFIER_AUTHORITY IdentifierAuthority;



   DWORD SubAuthority[1 ];
#line 9065 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winnt.h"
} SID, *PISID;
#line 9067 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winnt.h"





                                                // in a future release.







// 2 (S-)
// 4 (Rev(max: 255)-)
// 15 (
//      If (Auth < 2^32): Auth(max:4294967295)-
//      Else:             0xAuth(max:FFFFFFFFFFFF)-
//    )
// (11 * SID_MAX_SUB_AUTHORITIES) (SubN(max:4294967295)-)
// 1 (NULL character)
// = 187 (assuming SID_MAX_SUB_AUTHORITIES = 15)



//
// Union which can hold any valid sid.
//

typedef union _SE_SID {
    SID Sid;
    BYTE  Buffer[(sizeof(SID) - sizeof(DWORD) + ((15) * sizeof(DWORD))) ];
} SE_SID, *PSE_SID;

#line 9102 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winnt.h"


typedef enum _SID_NAME_USE {
    SidTypeUser = 1,
    SidTypeGroup,
    SidTypeDomain,
    SidTypeAlias,
    SidTypeWellKnownGroup,
    SidTypeDeletedAccount,
    SidTypeInvalid,
    SidTypeUnknown,
    SidTypeComputer,
    SidTypeLabel,
    SidTypeLogonSession
} SID_NAME_USE, *PSID_NAME_USE;

typedef struct _SID_AND_ATTRIBUTES {



    PSID Sid;
#line 9124 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winnt.h"
    DWORD Attributes;
    } SID_AND_ATTRIBUTES, * PSID_AND_ATTRIBUTES;

typedef SID_AND_ATTRIBUTES SID_AND_ATTRIBUTES_ARRAY[1 ];
typedef SID_AND_ATTRIBUTES_ARRAY *PSID_AND_ATTRIBUTES_ARRAY;


typedef ULONG_PTR SID_HASH_ENTRY, *PSID_HASH_ENTRY;

typedef struct _SID_AND_ATTRIBUTES_HASH {
    DWORD SidCount;
    PSID_AND_ATTRIBUTES SidAttr;
    SID_HASH_ENTRY Hash[32 ];
} SID_AND_ATTRIBUTES_HASH, *PSID_AND_ATTRIBUTES_HASH;


/////////////////////////////////////////////////////////////////////////////
//                                                                         //
// Universal well-known SIDs                                               //
//                                                                         //
//     Null SID                     S-1-0-0                                //
//     World                        S-1-1-0                                //
//     Local                        S-1-2-0                                //
//     Creator Owner ID             S-1-3-0                                //
//     Creator Group ID             S-1-3-1                                //
//     Creator Owner Server ID      S-1-3-2                                //
//     Creator Group Server ID      S-1-3-3                                //
//                                                                         //
//     (Non-unique IDs)             S-1-4                                  //
//                                                                         //
/////////////////////////////////////////////////////////////////////////////






















///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// NT well-known SIDs                                                        //
//                                                                           //
//     NT Authority            S-1-5                                         //
//     Dialup                  S-1-5-1                                       //
//                                                                           //
//     Network                 S-1-5-2                                       //
//     Batch                   S-1-5-3                                       //
//     Interactive             S-1-5-4                                       //
//     (Logon IDs)             S-1-5-5-X-Y                                   //
//     Service                 S-1-5-6                                       //
//     AnonymousLogon          S-1-5-7       (aka null logon session)        //
//     Proxy                   S-1-5-8                                       //
//     Enterprise DC (EDC)     S-1-5-9       (aka domain controller account) //
//     Self                    S-1-5-10      (self RID)                      //
//     Authenticated User      S-1-5-11      (Authenticated user somewhere)  //
//     Restricted Code         S-1-5-12      (Running restricted code)       //
//     Terminal Server         S-1-5-13      (Running on Terminal Server)    //
//     Remote Logon            S-1-5-14      (Remote Interactive Logon)      //
//     This Organization       S-1-5-15                                      //
//                                                                           //
//     IUser                   S-1-5-17
//     Local System            S-1-5-18                                      //
//     Local Service           S-1-5-19                                      //
//     Network Service         S-1-5-20                                      //
//                                                                           //
//     (NT non-unique IDs)     S-1-5-0x15-... (NT Domain Sids)               //
//                                                                           //
//     (Built-in domain)       S-1-5-0x20                                    //
//                                                                           //
//     (Security Package IDs)  S-1-5-0x40                                    //
//     NTLM Authentication     S-1-5-0x40-10                                 //
//     SChannel Authentication S-1-5-0x40-14                                 //
//     Digest Authentication   S-1-5-0x40-21                                 //
//                                                                           //
//     Other Organization      S-1-5-1000    (>=1000 can not be filtered)    //
//                                                                           //
//                                                                           //
// NOTE: the relative identifier values (RIDs) determine which security      //
//       boundaries the SID is allowed to cross.  Before adding new RIDs,    //
//       a determination needs to be made regarding which range they should  //
//       be added to in order to ensure proper "SID filtering"               //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////



























































































//
// Virtual account logon is not limited to inbox callers.  Reserve base RID 0x6F for application usage.
//







//
//Service SID type RIDs are in the range 0x50- 0x6F.  Therefore, we are giving  the next available RID to Windows Mobile team.
//


//
// Installer Capability Group Sid related. Currently Base RID is same as LOCAL DOMAIN.
//



// Note: This is because the App Capability Rid is S-1-15-3-1024-...
//       whereas the service group rid is          S-1-5-32-...
//	The number of RIDs from hash (8) are the same for both


//
//Well-known group for local accounts
//



/////////////////////////////////////////////////////////////////////////////
//                                                                         //
// well-known domain relative sub-authority values (RIDs)...               //
//                                                                         //
/////////////////////////////////////////////////////////////////////////////








// Well-known users ...










// well-known groups ...

















// well-known aliases ...







































//
// Application Package Authority.
//













//
// Built-in Packages.
//




//
// Built-in Capabilities.
//
















//
// Mandatory Label Authority.
//










//
// SECURITY_MANDATORY_MAXIMUM_USER_RID is the highest RID that
// can be set by a usermode caller.
//







//
// Authentication Authority
//










//
// Process Trust Authority
//















//
// Trusted Installer RIDs
//











//
// Well known SID definitions for lookup.
//

typedef enum {

    WinNullSid                                  = 0,
    WinWorldSid                                 = 1,
    WinLocalSid                                 = 2,
    WinCreatorOwnerSid                          = 3,
    WinCreatorGroupSid                          = 4,
    WinCreatorOwnerServerSid                    = 5,
    WinCreatorGroupServerSid                    = 6,
    WinNtAuthoritySid                           = 7,
    WinDialupSid                                = 8,
    WinNetworkSid                               = 9,
    WinBatchSid                                 = 10,
    WinInteractiveSid                           = 11,
    WinServiceSid                               = 12,
    WinAnonymousSid                             = 13,
    WinProxySid                                 = 14,
    WinEnterpriseControllersSid                 = 15,
    WinSelfSid                                  = 16,
    WinAuthenticatedUserSid                     = 17,
    WinRestrictedCodeSid                        = 18,
    WinTerminalServerSid                        = 19,
    WinRemoteLogonIdSid                         = 20,
    WinLogonIdsSid                              = 21,
    WinLocalSystemSid                           = 22,
    WinLocalServiceSid                          = 23,
    WinNetworkServiceSid                        = 24,
    WinBuiltinDomainSid                         = 25,
    WinBuiltinAdministratorsSid                 = 26,
    WinBuiltinUsersSid                          = 27,
    WinBuiltinGuestsSid                         = 28,
    WinBuiltinPowerUsersSid                     = 29,
    WinBuiltinAccountOperatorsSid               = 30,
    WinBuiltinSystemOperatorsSid                = 31,
    WinBuiltinPrintOperatorsSid                 = 32,
    WinBuiltinBackupOperatorsSid                = 33,
    WinBuiltinReplicatorSid                     = 34,
    WinBuiltinPreWindows2000CompatibleAccessSid = 35,
    WinBuiltinRemoteDesktopUsersSid             = 36,
    WinBuiltinNetworkConfigurationOperatorsSid  = 37,
    WinAccountAdministratorSid                  = 38,
    WinAccountGuestSid                          = 39,
    WinAccountKrbtgtSid                         = 40,
    WinAccountDomainAdminsSid                   = 41,
    WinAccountDomainUsersSid                    = 42,
    WinAccountDomainGuestsSid                   = 43,
    WinAccountComputersSid                      = 44,
    WinAccountControllersSid                    = 45,
    WinAccountCertAdminsSid                     = 46,
    WinAccountSchemaAdminsSid                   = 47,
    WinAccountEnterpriseAdminsSid               = 48,
    WinAccountPolicyAdminsSid                   = 49,
    WinAccountRasAndIasServersSid               = 50,
    WinNTLMAuthenticationSid                    = 51,
    WinDigestAuthenticationSid                  = 52,
    WinSChannelAuthenticationSid                = 53,
    WinThisOrganizationSid                      = 54,
    WinOtherOrganizationSid                     = 55,
    WinBuiltinIncomingForestTrustBuildersSid    = 56,
    WinBuiltinPerfMonitoringUsersSid            = 57,
    WinBuiltinPerfLoggingUsersSid               = 58,
    WinBuiltinAuthorizationAccessSid            = 59,
    WinBuiltinTerminalServerLicenseServersSid   = 60,
    WinBuiltinDCOMUsersSid                      = 61,
    WinBuiltinIUsersSid                         = 62,
    WinIUserSid                                 = 63,
    WinBuiltinCryptoOperatorsSid                = 64,
    WinUntrustedLabelSid                        = 65,
    WinLowLabelSid                              = 66,
    WinMediumLabelSid                           = 67,
    WinHighLabelSid                             = 68,
    WinSystemLabelSid                           = 69,
    WinWriteRestrictedCodeSid                   = 70,
    WinCreatorOwnerRightsSid                    = 71,
    WinCacheablePrincipalsGroupSid              = 72,
    WinNonCacheablePrincipalsGroupSid           = 73,
    WinEnterpriseReadonlyControllersSid         = 74,
    WinAccountReadonlyControllersSid            = 75,
    WinBuiltinEventLogReadersGroup              = 76,
    WinNewEnterpriseReadonlyControllersSid      = 77,
    WinBuiltinCertSvcDComAccessGroup            = 78,
    WinMediumPlusLabelSid                       = 79,
    WinLocalLogonSid                            = 80,
    WinConsoleLogonSid                          = 81,
    WinThisOrganizationCertificateSid           = 82,
    WinApplicationPackageAuthoritySid           = 83,
    WinBuiltinAnyPackageSid                     = 84,
    WinCapabilityInternetClientSid              = 85,
    WinCapabilityInternetClientServerSid        = 86,
    WinCapabilityPrivateNetworkClientServerSid  = 87,
    WinCapabilityPicturesLibrarySid             = 88,
    WinCapabilityVideosLibrarySid               = 89,
    WinCapabilityMusicLibrarySid                = 90,
    WinCapabilityDocumentsLibrarySid            = 91,
    WinCapabilitySharedUserCertificatesSid      = 92,
    WinCapabilityEnterpriseAuthenticationSid    = 93,
    WinCapabilityRemovableStorageSid            = 94,
    WinBuiltinRDSRemoteAccessServersSid         = 95,
    WinBuiltinRDSEndpointServersSid             = 96,
    WinBuiltinRDSManagementServersSid           = 97,
    WinUserModeDriversSid                       = 98,
    WinBuiltinHyperVAdminsSid                   = 99,
    WinAccountCloneableControllersSid           = 100,
    WinBuiltinAccessControlAssistanceOperatorsSid = 101,
    WinBuiltinRemoteManagementUsersSid          = 102,
    WinAuthenticationAuthorityAssertedSid       = 103,
    WinAuthenticationServiceAssertedSid         = 104,
    WinLocalAccountSid                          = 105,
    WinLocalAccountAndAdministratorSid          = 106,
    WinAccountProtectedUsersSid                 = 107,
    WinCapabilityAppointmentsSid                = 108,
    WinCapabilityContactsSid                    = 109,
    WinAccountDefaultSystemManagedSid           = 110,
    WinBuiltinDefaultSystemManagedGroupSid      = 111,
    WinBuiltinStorageReplicaAdminsSid           = 112,
    WinAccountKeyAdminsSid                      = 113,
    WinAccountEnterpriseKeyAdminsSid            = 114,
    WinAuthenticationKeyTrustSid                = 115,
    WinAuthenticationKeyPropertyMFASid          = 116,
    WinAuthenticationKeyPropertyAttestationSid  = 117,
    WinAuthenticationFreshKeyAuthSid            = 118,
    WinBuiltinDeviceOwnersSid                   = 119,
} WELL_KNOWN_SID_TYPE;

//
// Allocate the System Luid.  The first 1000 LUIDs are reserved.
// Use #999 here (0x3e7 = 999)
//








// end_ntifs

////////////////////////////////////////////////////////////////////////
//                                                                    //
//                          User and Group related SID attributes     //
//                                                                    //
////////////////////////////////////////////////////////////////////////

//
// Group attributes
//





















//
// User attributes
//

// (None yet defined.)




////////////////////////////////////////////////////////////////////////
//                                                                    //
//                         ACL  and  ACE                              //
//                                                                    //
////////////////////////////////////////////////////////////////////////

//
//  Define an ACL and the ACE format.  The structure of an ACL header
//  followed by one or more ACEs.  Pictorally the structure of an ACL header
//  is as follows:
//
//       3 3 2 2 2 2 2 2 2 2 2 2 1 1 1 1 1 1 1 1 1 1
//       1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0
//      +-------------------------------+---------------+---------------+
//      |            AclSize            |      Sbz1     |  AclRevision  |
//      +-------------------------------+---------------+---------------+
//      |              Sbz2             |           AceCount            |
//      +-------------------------------+-------------------------------+
//
//  The current AclRevision is defined to be ACL_REVISION.
//
//  AclSize is the size, in bytes, allocated for the ACL.  This includes
//  the ACL header, ACES, and remaining free space in the buffer.
//
//  AceCount is the number of ACES in the ACL.
//

// begin_wdm
// This is the *current* ACL revision




// This is the history of ACL revisions.  Add a new one whenever
// ACL_REVISION is updated








typedef struct _ACL {
    BYTE  AclRevision;
    BYTE  Sbz1;
    WORD   AclSize;
    WORD   AceCount;
    WORD   Sbz2;
} ACL;
typedef ACL *PACL;

// end_wdm
// begin_ntifs

//
//  The structure of an ACE is a common ace header followed by ace type
//  specific data.  Pictorally the structure of the common ace header is
//  as follows:
//
//       3 3 2 2 2 2 2 2 2 2 2 2 1 1 1 1 1 1 1 1 1 1
//       1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0
//      +---------------+-------+-------+---------------+---------------+
//      |            AceSize            |    AceFlags   |     AceType   |
//      +---------------+-------+-------+---------------+---------------+
//
//  AceType denotes the type of the ace, there are some predefined ace
//  types
//
//  AceSize is the size, in bytes, of ace.
//
//  AceFlags are the Ace flags for audit and inheritance, defined shortly.

typedef struct _ACE_HEADER {
    BYTE  AceType;
    BYTE  AceFlags;
    WORD   AceSize;
} ACE_HEADER;
typedef ACE_HEADER *PACE_HEADER;

//
//  The following are the predefined ace types that go into the AceType
//  field of an Ace header.
//






































//
//  The following are the inherit flags that go into the AceFlags field
//  of an Ace header.
//









//  The following are the currently defined ACE flags that go into the
//  AceFlags field of an ACE header.  Each ACE type has its own set of
//  AceFlags.
//
//

//
// ACCESS_ALLOWED_ACE_TYPE
//
// These control whether the ACE is critical and cannot be removed.
//
// CRITICAL_ACE_FLAG - used only with access allowed ACE types to
// indicate that the ACE is critical and cannot be removed.
//



//
//  SYSTEM_AUDIT and SYSTEM_ALARM AceFlags
//
//  These control the signaling of audit and alarms for success or failure.
//
//  SUCCESSFUL_ACCESS_ACE_FLAG - used only with system audit and alarm ACE
//  types to indicate that a message is generated for successful accesses.
//
//  FAILED_ACCESS_ACE_FLAG - used only with system audit and alarm ACE types
//  to indicate that a message is generated for failed accesses.
//




//
//  SYSTEM_ACCESS_FILTER_ACE AceFlags
//
//  These control the behaviour of SYSTEM_ACCESS_FILTER_ACE .
//
//  TRUST_PROTECTED_FILTER_ACE_FLAG - used only with SYSTEM_FILTERING_ACE_TYPE
//  ACEs to indicate that this ACE may not be deleted/modified except when the,
//  the current Trust Level dominates the one specified in the Ace SID.
//  If this flag is set then the SID in the ACE should be a valid TrustLevelSid.
//




//
//  We'll define the structure of the predefined ACE types.  Pictorally
//  the structure of the predefined ACE's is as follows:
//
//       3 3 2 2 2 2 2 2 2 2 2 2 1 1 1 1 1 1 1 1 1 1
//       1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0
//      +---------------+-------+-------+---------------+---------------+
//      |    AceFlags   | Resd  |Inherit|    AceSize    |     AceType   |
//      +---------------+-------+-------+---------------+---------------+
//      |                              Mask                             |
//      +---------------------------------------------------------------+
//      |                                                               |
//      +                                                               +
//      |                                                               |
//      +                              Sid                              +
//      |                                                               |
//      +                                                               +
//      |                                                               |
//      +---------------------------------------------------------------+
//
//  Mask is the access mask associated with the ACE.  This is either the
//  access allowed, access denied, audit, or alarm mask.
//
//  Sid is the Sid associated with the ACE.
//

//  The following are the four predefined ACE types.

//  Examine the AceType field in the Header to determine
//  which structure is appropriate to use for casting.


typedef struct _ACCESS_ALLOWED_ACE {
    ACE_HEADER Header;
    ACCESS_MASK Mask;
    DWORD SidStart;
} ACCESS_ALLOWED_ACE;

typedef ACCESS_ALLOWED_ACE *PACCESS_ALLOWED_ACE;

typedef struct _ACCESS_DENIED_ACE {
    ACE_HEADER Header;
    ACCESS_MASK Mask;
    DWORD SidStart;
} ACCESS_DENIED_ACE;
typedef ACCESS_DENIED_ACE *PACCESS_DENIED_ACE;

typedef struct _SYSTEM_AUDIT_ACE {
    ACE_HEADER Header;
    ACCESS_MASK Mask;
    DWORD SidStart;
} SYSTEM_AUDIT_ACE;
typedef SYSTEM_AUDIT_ACE *PSYSTEM_AUDIT_ACE;

typedef struct _SYSTEM_ALARM_ACE {
    ACE_HEADER Header;
    ACCESS_MASK Mask;
    DWORD SidStart;
} SYSTEM_ALARM_ACE;
typedef SYSTEM_ALARM_ACE *PSYSTEM_ALARM_ACE;

typedef struct _SYSTEM_RESOURCE_ATTRIBUTE_ACE {
    ACE_HEADER Header;
    ACCESS_MASK Mask;
    DWORD SidStart;
    // Sid followed by CLAIM_SECURITY_ATTRIBUTE_RELATIVE_V1 structure
} SYSTEM_RESOURCE_ATTRIBUTE_ACE, *PSYSTEM_RESOURCE_ATTRIBUTE_ACE;

typedef struct _SYSTEM_SCOPED_POLICY_ID_ACE {
    ACE_HEADER Header;
    ACCESS_MASK Mask;
    DWORD SidStart;
} SYSTEM_SCOPED_POLICY_ID_ACE, *PSYSTEM_SCOPED_POLICY_ID_ACE;

typedef struct _SYSTEM_MANDATORY_LABEL_ACE {
    ACE_HEADER Header;
    ACCESS_MASK Mask;
    DWORD SidStart;
} SYSTEM_MANDATORY_LABEL_ACE, *PSYSTEM_MANDATORY_LABEL_ACE;

typedef struct _SYSTEM_PROCESS_TRUST_LABEL_ACE {
    ACE_HEADER Header;
    ACCESS_MASK Mask;
    DWORD SidStart;
} SYSTEM_PROCESS_TRUST_LABEL_ACE, *PSYSTEM_PROCESS_TRUST_LABEL_ACE;

typedef struct _SYSTEM_ACCESS_FILTER_ACE {
    ACE_HEADER Header;
    ACCESS_MASK Mask;
    DWORD SidStart;
    // Filter Condition follows the SID
} SYSTEM_ACCESS_FILTER_ACE, *PSYSTEM_ACCESS_FILTER_ACE;









// Placeholder value that allows all ranges




// end_ntifs


typedef struct _ACCESS_ALLOWED_OBJECT_ACE {
    ACE_HEADER Header;
    ACCESS_MASK Mask;
    DWORD Flags;
    GUID ObjectType;
    GUID InheritedObjectType;
    DWORD SidStart;
} ACCESS_ALLOWED_OBJECT_ACE, *PACCESS_ALLOWED_OBJECT_ACE;

typedef struct _ACCESS_DENIED_OBJECT_ACE {
    ACE_HEADER Header;
    ACCESS_MASK Mask;
    DWORD Flags;
    GUID ObjectType;
    GUID InheritedObjectType;
    DWORD SidStart;
} ACCESS_DENIED_OBJECT_ACE, *PACCESS_DENIED_OBJECT_ACE;

typedef struct _SYSTEM_AUDIT_OBJECT_ACE {
    ACE_HEADER Header;
    ACCESS_MASK Mask;
    DWORD Flags;
    GUID ObjectType;
    GUID InheritedObjectType;
    DWORD SidStart;
} SYSTEM_AUDIT_OBJECT_ACE, *PSYSTEM_AUDIT_OBJECT_ACE;

typedef struct _SYSTEM_ALARM_OBJECT_ACE {
    ACE_HEADER Header;
    ACCESS_MASK Mask;
    DWORD Flags;
    GUID ObjectType;
    GUID InheritedObjectType;
    DWORD SidStart;
} SYSTEM_ALARM_OBJECT_ACE, *PSYSTEM_ALARM_OBJECT_ACE;

//
// Callback ace support in post Win2000.
// Resource managers can put their own data after Sidstart + Length of the sid
//

typedef struct _ACCESS_ALLOWED_CALLBACK_ACE {
    ACE_HEADER Header;
    ACCESS_MASK Mask;
    DWORD SidStart;
    // Opaque resource manager specific data
} ACCESS_ALLOWED_CALLBACK_ACE, *PACCESS_ALLOWED_CALLBACK_ACE;

typedef struct _ACCESS_DENIED_CALLBACK_ACE {
    ACE_HEADER Header;
    ACCESS_MASK Mask;
    DWORD SidStart;
    // Opaque resource manager specific data
} ACCESS_DENIED_CALLBACK_ACE, *PACCESS_DENIED_CALLBACK_ACE;

typedef struct _SYSTEM_AUDIT_CALLBACK_ACE {
    ACE_HEADER Header;
    ACCESS_MASK Mask;
    DWORD SidStart;
    // Opaque resource manager specific data
} SYSTEM_AUDIT_CALLBACK_ACE, *PSYSTEM_AUDIT_CALLBACK_ACE;

typedef struct _SYSTEM_ALARM_CALLBACK_ACE {
    ACE_HEADER Header;
    ACCESS_MASK Mask;
    DWORD SidStart;
    // Opaque resource manager specific data
} SYSTEM_ALARM_CALLBACK_ACE, *PSYSTEM_ALARM_CALLBACK_ACE;

typedef struct _ACCESS_ALLOWED_CALLBACK_OBJECT_ACE {
    ACE_HEADER Header;
    ACCESS_MASK Mask;
    DWORD Flags;
    GUID ObjectType;
    GUID InheritedObjectType;
    DWORD SidStart;
    // Opaque resource manager specific data
} ACCESS_ALLOWED_CALLBACK_OBJECT_ACE, *PACCESS_ALLOWED_CALLBACK_OBJECT_ACE;

typedef struct _ACCESS_DENIED_CALLBACK_OBJECT_ACE {
    ACE_HEADER Header;
    ACCESS_MASK Mask;
    DWORD Flags;
    GUID ObjectType;
    GUID InheritedObjectType;
    DWORD SidStart;
    // Opaque resource manager specific data
} ACCESS_DENIED_CALLBACK_OBJECT_ACE, *PACCESS_DENIED_CALLBACK_OBJECT_ACE;

typedef struct _SYSTEM_AUDIT_CALLBACK_OBJECT_ACE {
    ACE_HEADER Header;
    ACCESS_MASK Mask;
    DWORD Flags;
    GUID ObjectType;
    GUID InheritedObjectType;
    DWORD SidStart;
    // Opaque resource manager specific data
} SYSTEM_AUDIT_CALLBACK_OBJECT_ACE, *PSYSTEM_AUDIT_CALLBACK_OBJECT_ACE;

typedef struct _SYSTEM_ALARM_CALLBACK_OBJECT_ACE {
    ACE_HEADER Header;
    ACCESS_MASK Mask;
    DWORD Flags;
    GUID ObjectType;
    GUID InheritedObjectType;
    DWORD SidStart;
    // Opaque resource manager specific data
} SYSTEM_ALARM_CALLBACK_OBJECT_ACE, *PSYSTEM_ALARM_CALLBACK_OBJECT_ACE;

//
// Currently define Flags for "OBJECT" ACE types.
//





//
//  The following declarations are used for setting and querying information
//  about and ACL.  First are the various information classes available to
//  the user.
//

typedef enum _ACL_INFORMATION_CLASS {
    AclRevisionInformation = 1,
    AclSizeInformation
} ACL_INFORMATION_CLASS;

//
//  This record is returned/sent if the user is requesting/setting the
//  AclRevisionInformation
//

typedef struct _ACL_REVISION_INFORMATION {
    DWORD AclRevision;
} ACL_REVISION_INFORMATION;
typedef ACL_REVISION_INFORMATION *PACL_REVISION_INFORMATION;

//
//  This record is returned if the user is requesting AclSizeInformation
//

typedef struct _ACL_SIZE_INFORMATION {
    DWORD AceCount;
    DWORD AclBytesInUse;
    DWORD AclBytesFree;
} ACL_SIZE_INFORMATION;
typedef ACL_SIZE_INFORMATION *PACL_SIZE_INFORMATION;


////////////////////////////////////////////////////////////////////////
//                                                                    //
//                             SECURITY_DESCRIPTOR                    //
//                                                                    //
////////////////////////////////////////////////////////////////////////
//
//  Define the Security Descriptor and related data types.
//  This is an opaque data structure.
//

// begin_wdm
//
// Current security descriptor revision value
//




// end_wdm
// begin_ntifs




typedef WORD   SECURITY_DESCRIPTOR_CONTROL, *PSECURITY_DESCRIPTOR_CONTROL;
















//
//  Where:
//
//      SE_OWNER_DEFAULTED - This boolean flag, when set, indicates that the
//          SID pointed to by the Owner field was provided by a
//          defaulting mechanism rather than explicitly provided by the
//          original provider of the security descriptor.  This may
//          affect the treatment of the SID with respect to inheritence
//          of an owner.
//
//      SE_GROUP_DEFAULTED - This boolean flag, when set, indicates that the
//          SID in the Group field was provided by a defaulting mechanism
//          rather than explicitly provided by the original provider of
//          the security descriptor.  This may affect the treatment of
//          the SID with respect to inheritence of a primary group.
//
//      SE_DACL_PRESENT - This boolean flag, when set, indicates that the
//          security descriptor contains a discretionary ACL.  If this
//          flag is set and the Dacl field of the SECURITY_DESCRIPTOR is
//          null, then a null ACL is explicitly being specified.
//
//      SE_DACL_DEFAULTED - This boolean flag, when set, indicates that the
//          ACL pointed to by the Dacl field was provided by a defaulting
//          mechanism rather than explicitly provided by the original
//          provider of the security descriptor.  This may affect the
//          treatment of the ACL with respect to inheritence of an ACL.
//          This flag is ignored if the DaclPresent flag is not set.
//
//      SE_SACL_PRESENT - This boolean flag, when set,  indicates that the
//          security descriptor contains a system ACL pointed to by the
//          Sacl field.  If this flag is set and the Sacl field of the
//          SECURITY_DESCRIPTOR is null, then an empty (but present)
//          ACL is being specified.
//
//      SE_SACL_DEFAULTED - This boolean flag, when set, indicates that the
//          ACL pointed to by the Sacl field was provided by a defaulting
//          mechanism rather than explicitly provided by the original
//          provider of the security descriptor.  This may affect the
//          treatment of the ACL with respect to inheritence of an ACL.
//          This flag is ignored if the SaclPresent flag is not set.
//
//      SE_SELF_RELATIVE - This boolean flag, when set, indicates that the
//          security descriptor is in self-relative form.  In this form,
//          all fields of the security descriptor are contiguous in memory
//          and all pointer fields are expressed as offsets from the
//          beginning of the security descriptor.  This form is useful
//          for treating security descriptors as opaque data structures
//          for transmission in communication protocol or for storage on
//          secondary media.
//
//
//
// Pictorially the structure of a security descriptor is as follows:
//
//       3 3 2 2 2 2 2 2 2 2 2 2 1 1 1 1 1 1 1 1 1 1
//       1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0
//      +---------------------------------------------------------------+
//      |            Control            |Reserved1 (SBZ)|   Revision    |
//      +---------------------------------------------------------------+
//      |                            Owner                              |
//      +---------------------------------------------------------------+
//      |                            Group                              |
//      +---------------------------------------------------------------+
//      |                            Sacl                               |
//      +---------------------------------------------------------------+
//      |                            Dacl                               |
//      +---------------------------------------------------------------+
//
// In general, this data structure should be treated opaquely to ensure future
// compatibility.
//
//

typedef struct _SECURITY_DESCRIPTOR_RELATIVE {
    BYTE  Revision;
    BYTE  Sbz1;
    SECURITY_DESCRIPTOR_CONTROL Control;
    DWORD Owner;
    DWORD Group;
    DWORD Sacl;
    DWORD Dacl;
    } SECURITY_DESCRIPTOR_RELATIVE, *PISECURITY_DESCRIPTOR_RELATIVE;

typedef struct _SECURITY_DESCRIPTOR {
   BYTE  Revision;
   BYTE  Sbz1;
   SECURITY_DESCRIPTOR_CONTROL Control;
   PSID Owner;
   PSID Group;
   PACL Sacl;
   PACL Dacl;

   } SECURITY_DESCRIPTOR, *PISECURITY_DESCRIPTOR;

   
typedef struct _SECURITY_OBJECT_AI_PARAMS {
    DWORD Size;             //Set to sizeof(SECURITY_OBJECT_AI_PARAMS)
    DWORD ConstraintMask;
} SECURITY_OBJECT_AI_PARAMS, *PSECURITY_OBJECT_AI_PARAMS;


// end_ntifs

// Where:
//
//     Revision - Contains the revision level of the security
//         descriptor.  This allows this structure to be passed between
//         systems or stored on disk even though it is expected to
//         change in the future.
//
//     Control - A set of flags which qualify the meaning of the
//         security descriptor or individual fields of the security
//         descriptor.
//
//     Owner - is a pointer to an SID representing an object's owner.
//         If this field is null, then no owner SID is present in the
//         security descriptor.  If the security descriptor is in
//         self-relative form, then this field contains an offset to
//         the SID, rather than a pointer.
//
//     Group - is a pointer to an SID representing an object's primary
//         group.  If this field is null, then no primary group SID is
//         present in the security descriptor.  If the security descriptor
//         is in self-relative form, then this field contains an offset to
//         the SID, rather than a pointer.
//
//     Sacl - is a pointer to a system ACL.  This field value is only
//         valid if the DaclPresent control flag is set.  If the
//         SaclPresent flag is set and this field is null, then a null
//         ACL  is specified.  If the security descriptor is in
//         self-relative form, then this field contains an offset to
//         the ACL, rather than a pointer.
//
//     Dacl - is a pointer to a discretionary ACL.  This field value is
//         only valid if the DaclPresent control flag is set.  If the
//         DaclPresent flag is set and this field is null, then a null
//         ACL (unconditionally granting access) is specified.  If the
//         security descriptor is in self-relative form, then this field
//         contains an offset to the ACL, rather than a pointer.
//




////////////////////////////////////////////////////////////////////////
//                                                                    //
//               Object Type list for AccessCheckByType               //
//                                                                    //
////////////////////////////////////////////////////////////////////////

typedef struct _OBJECT_TYPE_LIST {
    WORD   Level;
    WORD   Sbz;
    GUID *ObjectType;
} OBJECT_TYPE_LIST, *POBJECT_TYPE_LIST;

//
// DS values for Level
//







//
// Parameters to NtAccessCheckByTypeAndAditAlarm
//

typedef enum _AUDIT_EVENT_TYPE {
    AuditEventObjectAccess,
    AuditEventDirectoryServiceAccess
} AUDIT_EVENT_TYPE, *PAUDIT_EVENT_TYPE;



//
// DS values for Source and ObjectTypeName
//






////////////////////////////////////////////////////////////////////////
//                                                                    //
//               Privilege Related Data Structures                    //
//                                                                    //
////////////////////////////////////////////////////////////////////////

// end_ntifs
// begin_wdm
//
// Privilege attributes
//












//
// Privilege Set Control flags
//



//
//  Privilege Set - This is defined for a privilege set of one.
//                  If more than one privilege is needed, then this structure
//                  will need to be allocated with more space.
//
//  Note: don't change this structure without fixing the INITIAL_PRIVILEGE_SET
//  structure (defined in se.h)
//

typedef struct _PRIVILEGE_SET {
    DWORD PrivilegeCount;
    DWORD Control;
    LUID_AND_ATTRIBUTES Privilege[1 ];
    } PRIVILEGE_SET, * PPRIVILEGE_SET;




//
// Values for different access granted\denied reasons:
// AccessReasonAceN = AccessReasonAce + N.
// AccessReasonPrivilegeN = AccessReasonPrivilege + N.
//







typedef enum _ACCESS_REASON_TYPE{

    AccessReasonNone                    = 0x00000000,   // Indicate no reason for the bit. The bit may not be checked, or just no known reason.

    //
    // The lowest 2 bytes store the index of the ACE that grant/deny this bit.
    // If the corresponding access mask is zero, then it is deny ACE; otherwise,
    // it is allow ACE.
    //
    AccessReasonAllowedAce                  = 0x00010000,   // Granted a permission.
    AccessReasonDeniedAce                   = 0x00020000,   // Denied a permission.

    AccessReasonAllowedParentAce            = 0x00030000,   // Granted a permission from parent ACE
    AccessReasonDeniedParentAce             = 0x00040000,   // Denied a permission from parent ACE

    AccessReasonNotGrantedByCape            = 0x00050000,   // A CAPE didn't grant the permission
    AccessReasonNotGrantedByParentCape      = 0x00060000,   // A CAPE from the parent's SD didn't grant the permission

    AccessReasonNotGrantedToAppContainer    = 0x00070000,   // This is an AppContainer and no ACE granted the permission.

    AccessReasonMissingPrivilege            = 0x00100000,
    AccessReasonFromPrivilege               = 0x00200000,


    AccessReasonIntegrityLevel              = 0x00300000,

    AccessReasonOwnership                   = 0x00400000,

    AccessReasonNullDacl                    = 0x00500000,
    AccessReasonEmptyDacl                   = 0x00600000,

    AccessReasonNoSD                        = 0x00700000,
    AccessReasonNoGrant                     = 0x00800000,   // this access bit is not granted by any ACE.

    AccessReasonTrustLabel                  = 0x00900000,   // The trust label ACE did not grant this access.

    AccessReasonFilterAce                   = 0x00a00000    // The filtering ACE did not grant this access
}
ACCESS_REASON_TYPE;

 //
// Structure to hold access denied\granted reason for every bit of ACCESS_MASK.
// There are 32-bits in ACCESS_MASK and only 27-bits are actually valid on
// return from AccessCheck because MAXIMUM_ALLOWED, GENERIC_READ,
// GENERIC_WRITE, GENERIC_EXECUTE, and GENERIC_ALL are never returned.
//
// The content in Data fields depends on the Access Reason, for example,
// if the reason is AccessReasonAce, the Data will be the ACE ID.
// If there are more than one reason (more than one bit is set), the array size
// of the Data is equal to the number of bits set (or number of reasons).
// The Data could be null for a particular reason.
//

typedef DWORD ACCESS_REASON;

typedef struct _ACCESS_REASONS{
        ACCESS_REASON Data[32];
} ACCESS_REASONS, *PACCESS_REASONS;


/*
The following data structures are defined to consolidate various falvors of
access check functions. In particular for Windows 7, the new access check
function will enable security attribute check, plus returning the reason
for a access check result.

The new access check function based on these data structures will
form the foundation to reimplement other flavors of access check
functions.

*/

//
// Structure to hold pointer to security descriptor and its unique id, which
// can be used for caching access check results.
// (NOTE NOTE) The cache key can be constructed by SecurityDescriptorId, Token and
// PrincipalSelfSid. Watch how GenericMapping affects the cache results.
//









typedef struct _SE_SECURITY_DESCRIPTOR
{
    DWORD Size;
    DWORD Flags;
    PSECURITY_DESCRIPTOR SecurityDescriptor;
} SE_SECURITY_DESCRIPTOR, *PSE_SECURITY_DESCRIPTOR;

typedef struct _SE_ACCESS_REQUEST
{
    DWORD Size;
    PSE_SECURITY_DESCRIPTOR SeSecurityDescriptor;
    ACCESS_MASK DesiredAccess;
    ACCESS_MASK PreviouslyGrantedAccess;
    PSID PrincipalSelfSid;      // Need to watch how this field affects the cache.
    PGENERIC_MAPPING GenericMapping;
    DWORD ObjectTypeListCount;
    POBJECT_TYPE_LIST ObjectTypeList;
} SE_ACCESS_REQUEST, *PSE_ACCESS_REQUEST;


typedef struct _SE_ACCESS_REPLY
{
    DWORD Size;
    DWORD ResultListCount;  // Indicate the array size of GrantedAccess and AccessStatus, it only can be either 1 or ObjectTypeListCount.
    PACCESS_MASK GrantedAccess;
    PDWORD    AccessStatus;
    PACCESS_REASONS AccessReason;
    PPRIVILEGE_SET* Privileges;
} SE_ACCESS_REPLY, *PSE_ACCESS_REPLY;


////////////////////////////////////////////////////////////////////////
//                                                                    //
//               NT Defined Privileges                                //
//                                                                    //
////////////////////////////////////////////////////////////////////////






































// begin_ntosifs

//
// List Of String Capabilities.
//






// end_ntosifs



////////////////////////////////////////////////////////////////////
//                                                                //
//           Security Quality Of Service                          //
//                                                                //
//                                                                //
////////////////////////////////////////////////////////////////////

// begin_wdm
//
// Impersonation Level
//
// Impersonation level is represented by a pair of bits in Windows.
// If a new impersonation level is added or lowest value is changed from
// 0 to something else, fix the Windows CreateFile call.
//

typedef enum _SECURITY_IMPERSONATION_LEVEL {
    SecurityAnonymous,
    SecurityIdentification,
    SecurityImpersonation,
    SecurityDelegation
    } SECURITY_IMPERSONATION_LEVEL, * PSECURITY_IMPERSONATION_LEVEL;







////////////////////////////////////////////////////////////////////
//                                                                //
//           Token Object Definitions                             //
//                                                                //
//                                                                //
////////////////////////////////////////////////////////////////////

// begin_access

//
// Token Specific Access Rights.
//


























#line 10689 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winnt.h"






















#line 10712 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winnt.h"
//
// end_access
//
//
// Token Types
//

typedef enum _TOKEN_TYPE {
    TokenPrimary = 1,
    TokenImpersonation
    } TOKEN_TYPE;
typedef TOKEN_TYPE *PTOKEN_TYPE;

//
// Token elevation values describe the relative strength of a given token.
// A full token is a token with all groups and privileges to which the principal
// is authorized.  A limited token is one with some groups or privileges removed.
//

typedef enum _TOKEN_ELEVATION_TYPE {
    TokenElevationTypeDefault = 1,
    TokenElevationTypeFull,
    TokenElevationTypeLimited,
} TOKEN_ELEVATION_TYPE, *PTOKEN_ELEVATION_TYPE;

//
// Token Information Classes.
//


typedef enum _TOKEN_INFORMATION_CLASS {
    TokenUser = 1,
    TokenGroups,
    TokenPrivileges,
    TokenOwner,
    TokenPrimaryGroup,
    TokenDefaultDacl,
    TokenSource,
    TokenType,
    TokenImpersonationLevel,
    TokenStatistics,
    TokenRestrictedSids,
    TokenSessionId,
    TokenGroupsAndPrivileges,
    TokenSessionReference,
    TokenSandBoxInert,
    TokenAuditPolicy,
    TokenOrigin,
    TokenElevationType,
    TokenLinkedToken,
    TokenElevation,
    TokenHasRestrictions,
    TokenAccessInformation,
    TokenVirtualizationAllowed,
    TokenVirtualizationEnabled,
    TokenIntegrityLevel,
    TokenUIAccess,
    TokenMandatoryPolicy,
    TokenLogonSid,
    TokenIsAppContainer,
    TokenCapabilities,
    TokenAppContainerSid,
    TokenAppContainerNumber,
    TokenUserClaimAttributes,
    TokenDeviceClaimAttributes,
    TokenRestrictedUserClaimAttributes,
    TokenRestrictedDeviceClaimAttributes,
    TokenDeviceGroups,
    TokenRestrictedDeviceGroups,
    TokenSecurityAttributes,
    TokenIsRestricted,
    TokenProcessTrustLevel,
    TokenPrivateNameSpace,
    TokenSingletonAttributes,
    TokenBnoIsolation,
    TokenChildProcessFlags,
    TokenIsLessPrivilegedAppContainer,
    TokenIsSandboxed,
    TokenOriginatingProcessTrustLevel,
    MaxTokenInfoClass  // MaxTokenInfoClass should always be the last enum
} TOKEN_INFORMATION_CLASS, *PTOKEN_INFORMATION_CLASS;

//
// Token information class structures
//

typedef struct _TOKEN_USER {
    SID_AND_ATTRIBUTES User;
} TOKEN_USER, *PTOKEN_USER;



typedef struct _SE_TOKEN_USER {
    union {
        TOKEN_USER TokenUser;
        SID_AND_ATTRIBUTES User;
    }  ;

    union {
        SID Sid;
        BYTE  Buffer[(sizeof(SID) - sizeof(DWORD) + ((15) * sizeof(DWORD))) ];
    }  ;

} SE_TOKEN_USER , PSE_TOKEN_USER;



#line 10820 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winnt.h"


typedef struct _TOKEN_GROUPS {
    DWORD GroupCount;



    SID_AND_ATTRIBUTES Groups[1 ];
#line 10829 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winnt.h"
} TOKEN_GROUPS, *PTOKEN_GROUPS;

typedef struct _TOKEN_PRIVILEGES {
    DWORD PrivilegeCount;
    LUID_AND_ATTRIBUTES Privileges[1 ];
} TOKEN_PRIVILEGES, *PTOKEN_PRIVILEGES;


typedef struct _TOKEN_OWNER {
    PSID Owner;
} TOKEN_OWNER, *PTOKEN_OWNER;



#line 10844 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winnt.h"

typedef struct _TOKEN_PRIMARY_GROUP {
    PSID PrimaryGroup;
} TOKEN_PRIMARY_GROUP, *PTOKEN_PRIMARY_GROUP;


typedef struct _TOKEN_DEFAULT_DACL {
    PACL DefaultDacl;
} TOKEN_DEFAULT_DACL, *PTOKEN_DEFAULT_DACL;

typedef struct _TOKEN_USER_CLAIMS {
    PCLAIMS_BLOB UserClaims;
} TOKEN_USER_CLAIMS, *PTOKEN_USER_CLAIMS;

typedef struct _TOKEN_DEVICE_CLAIMS {
    PCLAIMS_BLOB DeviceClaims;
} TOKEN_DEVICE_CLAIMS, *PTOKEN_DEVICE_CLAIMS;

typedef struct _TOKEN_GROUPS_AND_PRIVILEGES {
    DWORD SidCount;
    DWORD SidLength;
    PSID_AND_ATTRIBUTES Sids;
    DWORD RestrictedSidCount;
    DWORD RestrictedSidLength;
    PSID_AND_ATTRIBUTES RestrictedSids;
    DWORD PrivilegeCount;
    DWORD PrivilegeLength;
    PLUID_AND_ATTRIBUTES Privileges;
    LUID AuthenticationId;
} TOKEN_GROUPS_AND_PRIVILEGES, *PTOKEN_GROUPS_AND_PRIVILEGES;

typedef struct _TOKEN_LINKED_TOKEN {
    HANDLE LinkedToken;
} TOKEN_LINKED_TOKEN, *PTOKEN_LINKED_TOKEN;

typedef struct _TOKEN_ELEVATION {
    DWORD TokenIsElevated;
} TOKEN_ELEVATION, *PTOKEN_ELEVATION;

typedef struct _TOKEN_MANDATORY_LABEL {
    SID_AND_ATTRIBUTES Label;
} TOKEN_MANDATORY_LABEL, *PTOKEN_MANDATORY_LABEL;










#line 10897 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winnt.h"

typedef struct _TOKEN_MANDATORY_POLICY {
    DWORD Policy;
} TOKEN_MANDATORY_POLICY, *PTOKEN_MANDATORY_POLICY;

typedef PVOID PSECURITY_ATTRIBUTES_OPAQUE;

typedef struct _TOKEN_ACCESS_INFORMATION {
    PSID_AND_ATTRIBUTES_HASH SidHash;
    PSID_AND_ATTRIBUTES_HASH RestrictedSidHash;
    PTOKEN_PRIVILEGES Privileges;
    LUID AuthenticationId;
    TOKEN_TYPE TokenType;
    SECURITY_IMPERSONATION_LEVEL ImpersonationLevel;
    TOKEN_MANDATORY_POLICY MandatoryPolicy;
    DWORD Flags;
    DWORD AppContainerNumber;
    PSID PackageSid;
    PSID_AND_ATTRIBUTES_HASH CapabilitiesHash;
    PSID TrustLevelSid;
    PSECURITY_ATTRIBUTES_OPAQUE SecurityAttributes;
} TOKEN_ACCESS_INFORMATION, *PTOKEN_ACCESS_INFORMATION;

//
// Valid bits for each TOKEN_AUDIT_POLICY policy mask field.
//



typedef struct _TOKEN_AUDIT_POLICY {
    BYTE  PerUserPolicy[(((59) ) >> 1) + 1];
} TOKEN_AUDIT_POLICY, *PTOKEN_AUDIT_POLICY;



typedef struct _TOKEN_SOURCE {
    CHAR SourceName[8 ];
    LUID SourceIdentifier;
} TOKEN_SOURCE, *PTOKEN_SOURCE;


typedef struct _TOKEN_STATISTICS {
    LUID TokenId;
    LUID AuthenticationId;
    LARGE_INTEGER ExpirationTime;
    TOKEN_TYPE TokenType;
    SECURITY_IMPERSONATION_LEVEL ImpersonationLevel;
    DWORD DynamicCharged;
    DWORD DynamicAvailable;
    DWORD GroupCount;
    DWORD PrivilegeCount;
    LUID ModifiedId;
} TOKEN_STATISTICS, *PTOKEN_STATISTICS;



typedef struct _TOKEN_CONTROL {
    LUID TokenId;
    LUID AuthenticationId;
    LUID ModifiedId;
    TOKEN_SOURCE TokenSource;
} TOKEN_CONTROL, *PTOKEN_CONTROL;

typedef struct _TOKEN_ORIGIN {
    LUID OriginatingLogonSession ;
} TOKEN_ORIGIN, * PTOKEN_ORIGIN ;


typedef enum _MANDATORY_LEVEL {
    MandatoryLevelUntrusted = 0,
    MandatoryLevelLow,
    MandatoryLevelMedium,
    MandatoryLevelHigh,
    MandatoryLevelSystem,
    MandatoryLevelSecureProcess,
    MandatoryLevelCount
} MANDATORY_LEVEL, *PMANDATORY_LEVEL;

typedef struct _TOKEN_APPCONTAINER_INFORMATION {
    PSID TokenAppContainer;
} TOKEN_APPCONTAINER_INFORMATION, *PTOKEN_APPCONTAINER_INFORMATION;



#line 10982 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winnt.h"

typedef struct _TOKEN_SID_INFORMATION {
    PSID Sid;
} TOKEN_SID_INFORMATION, *PTOKEN_SID_INFORMATION;

typedef struct _TOKEN_BNO_ISOLATION_INFORMATION {
    PWSTR       IsolationPrefix;
    BOOLEAN     IsolationEnabled;
} TOKEN_BNO_ISOLATION_INFORMATION, *PTOKEN_BNO_ISOLATION_INFORMATION;

//
//  *** Claim Security attributes ***
//
//      These #defines and data structures (almost) exactly mirror
//      the Token_XXX definitions (except for PWSTR/PUNICODE changes)
//      in ntseapi.w as well as AUTHZ_XXX in authz.w. 
//      Keep them in sync. 
//
//
//  Security attribute data types ...
//






//
//  Case insensitive attribute value string by default.
//  Unless the flag CLAIM_SECURITY_ATTRIBUTE_VALUE_CASE_SENSITIVE
//  is set indicating otherwise.
//



//
//  Fully-qualified binary name.
//

typedef struct _CLAIM_SECURITY_ATTRIBUTE_FQBN_VALUE {
    DWORD64             Version;
    PWSTR               Name;
} CLAIM_SECURITY_ATTRIBUTE_FQBN_VALUE, *PCLAIM_SECURITY_ATTRIBUTE_FQBN_VALUE;








typedef struct _CLAIM_SECURITY_ATTRIBUTE_OCTET_STRING_VALUE {
    PVOID   pValue;         //  Pointer is BYTE aligned.
    DWORD   ValueLength;    //  In bytes
} CLAIM_SECURITY_ATTRIBUTE_OCTET_STRING_VALUE,
    *PCLAIM_SECURITY_ATTRIBUTE_OCTET_STRING_VALUE;



//
// Attribute Flags
//

//
//  Attribute must not be inherited across process spawns.
//




//
//  Attribute value is compared in a case sensitive way. It is valid with string value
//  or composite type containing string value. For other types of value, this flag
//  will be ignored. Currently, it is valid with the two types:
//  CLAIM_SECURITY_ATTRIBUTE_TYPE_STRING and CLAIM_SECURITY_ATTRIBUTE_TYPE_FQBN.
//


//
// Attribute is considered only for Deny Aces.
//



//
// Attribute is disabled by default.
//



// 
// Attribute is disabled.
//



//
// Attribute is mandatory.
//













//
// Reserve upper 16 bits for custom flags. These should be preserved but not
// validated as they do not affect security in any way.
//


//
//  An individual security attribute.
//


typedef struct _CLAIM_SECURITY_ATTRIBUTE_V1 {

    //
    //  Name of the attribute.
    //  Case insensitive Unicode string.
    //

    PWSTR   Name; 

    //
    //  Data type of attribute.
    //

    WORD    ValueType;

    //
    //  Pass 0 in a set operation and check for 0 in
    //  a get operation.
    //

    WORD    Reserved;

    //
    // Attribute Flags
    //

    DWORD   Flags;

    //
    //  Number of values.
    //

    DWORD   ValueCount;

    //
    //  The actual value itself.
    //

    union {
        PLONG64                                         pInt64;
        PDWORD64                                        pUint64;
        PWSTR                                           *ppString;
        PCLAIM_SECURITY_ATTRIBUTE_FQBN_VALUE            pFqbn;
        PCLAIM_SECURITY_ATTRIBUTE_OCTET_STRING_VALUE    pOctetString;
    } Values;
} CLAIM_SECURITY_ATTRIBUTE_V1, *PCLAIM_SECURITY_ATTRIBUTE_V1;

//
//  Relative form of the security attribute.
//


typedef struct _CLAIM_SECURITY_ATTRIBUTE_RELATIVE_V1 {

    //
    //  Name of the attribute.
    //  Offset from beginning of structure.
    //

    DWORD   Name;

    //
    //  Data type of attribute.
    //

    WORD    ValueType;

    //
    //  Pass 0 in a set operation and check for 0 in
    //  a get operation.
    //

    WORD    Reserved;

    //
    // Attribute Flags
    //

    DWORD   Flags;

    //
    //  Number of values.
    //

    DWORD   ValueCount;

    //
    //  The actual value itself.
    //

    union {
        DWORD pInt64[1 ];
        DWORD pUint64[1 ];
        DWORD ppString[1 ];
        DWORD pFqbn[1 ];
        DWORD pOctetString[1 ];
    } Values;
} CLAIM_SECURITY_ATTRIBUTE_RELATIVE_V1, *PCLAIM_SECURITY_ATTRIBUTE_RELATIVE_V1;


//
//  Set of security attributes.
//

//
//  Versioning. The interpretation of the pointers in the
//  Attribute field below is dependent on the version field.
//
//  Get operations return the version while the set operation
//  MUST specify the version of the data structure passed in.
//








typedef struct _CLAIM_SECURITY_ATTRIBUTES_INFORMATION {

    //
    //  MUST BE first.
    //

    WORD    Version;

    //
    //  Pass 0 in set operations and ignore on get operations.
    //

    WORD    Reserved;

    DWORD   AttributeCount;
    union {
        PCLAIM_SECURITY_ATTRIBUTE_V1    pAttributeV1;
    } Attribute;
} CLAIM_SECURITY_ATTRIBUTES_INFORMATION, *PCLAIM_SECURITY_ATTRIBUTES_INFORMATION;

//
// Security Tracking Mode
//




typedef BOOLEAN SECURITY_CONTEXT_TRACKING_MODE,
                    * PSECURITY_CONTEXT_TRACKING_MODE;



//
// Quality Of Service
//

typedef struct _SECURITY_QUALITY_OF_SERVICE {
    DWORD Length;
    SECURITY_IMPERSONATION_LEVEL ImpersonationLevel;
    SECURITY_CONTEXT_TRACKING_MODE ContextTrackingMode;
    BOOLEAN EffectiveOnly;
    } SECURITY_QUALITY_OF_SERVICE, * PSECURITY_QUALITY_OF_SERVICE;


//
// Used to represent information related to a thread impersonation
//

typedef struct _SE_IMPERSONATION_STATE {
    PACCESS_TOKEN Token;
    BOOLEAN CopyOnOpen;
    BOOLEAN EffectiveOnly;
    SECURITY_IMPERSONATION_LEVEL Level;
} SE_IMPERSONATION_STATE, *PSE_IMPERSONATION_STATE;






typedef DWORD SECURITY_INFORMATION, *PSECURITY_INFORMATION;


















//
// Base signing levels.
//

typedef BYTE  SE_SIGNING_LEVEL, *PSE_SIGNING_LEVEL;




















//
// Image signature types.
//

typedef enum _SE_IMAGE_SIGNATURE_TYPE
{
    SeImageSignatureNone = 0,
    SeImageSignatureEmbedded,
    SeImageSignatureCache,
    SeImageSignatureCatalogCached,
    SeImageSignatureCatalogNotCached,
    SeImageSignatureCatalogHint,
    SeImageSignaturePackageCatalog,
} SE_IMAGE_SIGNATURE_TYPE, *PSE_IMAGE_SIGNATURE_TYPE;


//
// Learning Mode Types.
//

typedef enum _SE_LEARNING_MODE_DATA_TYPE {
    SeLearningModeInvalidType = 0,
    SeLearningModeSettings,
    SeLearningModeMax
} SE_LEARNING_MODE_DATA_TYPE;



typedef struct _SECURITY_CAPABILITIES {




    PSID AppContainerSid;
    PSID_AND_ATTRIBUTES Capabilities;
#line 11364 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winnt.h"
    DWORD CapabilityCount;
    DWORD Reserved;
} SECURITY_CAPABILITIES, *PSECURITY_CAPABILITIES, *LPSECURITY_CAPABILITIES;






















#line 11390 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winnt.h"










// begin_wdm









#line 11411 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winnt.h"









// end_access

typedef struct _JOB_SET_ARRAY {
    HANDLE JobHandle;   // Handle to job object to insert
    DWORD MemberLevel;  // Level of this job in the set. Must be > 0. Can be sparse.
    DWORD Flags;        // Unused. Must be zero
} JOB_SET_ARRAY, *PJOB_SET_ARRAY;




typedef struct _EXCEPTION_REGISTRATION_RECORD {
    struct _EXCEPTION_REGISTRATION_RECORD *Next;
    PEXCEPTION_ROUTINE Handler;
} EXCEPTION_REGISTRATION_RECORD;

typedef EXCEPTION_REGISTRATION_RECORD *PEXCEPTION_REGISTRATION_RECORD;

typedef struct _NT_TIB {
    struct _EXCEPTION_REGISTRATION_RECORD *ExceptionList;
    PVOID StackBase;
    PVOID StackLimit;
    PVOID SubSystemTib;

    union {
        PVOID FiberData;
        DWORD Version;
    };


#line 11451 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winnt.h"
    PVOID ArbitraryUserPointer;
    struct _NT_TIB *Self;
} NT_TIB;
typedef NT_TIB *PNT_TIB;

//
// 32 and 64 bit specific version for wow64 and the debugger
//
typedef struct _NT_TIB32 {
    DWORD ExceptionList;
    DWORD StackBase;
    DWORD StackLimit;
    DWORD SubSystemTib;


    union {
        DWORD FiberData;
        DWORD Version;
    };


#line 11473 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winnt.h"

    DWORD ArbitraryUserPointer;
    DWORD Self;
} NT_TIB32, *PNT_TIB32;

typedef struct _NT_TIB64 {
    DWORD64 ExceptionList;
    DWORD64 StackBase;
    DWORD64 StackLimit;
    DWORD64 SubSystemTib;


    union {
        DWORD64 FiberData;
        DWORD Version;
    };



#line 11493 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winnt.h"

    DWORD64 ArbitraryUserPointer;
    DWORD64 Self;
} NT_TIB64, *PNT_TIB64;










typedef struct _UMS_CREATE_THREAD_ATTRIBUTES {  
    DWORD UmsVersion;   
        PVOID UmsContext;   
        PVOID UmsCompletionList;   
} UMS_CREATE_THREAD_ATTRIBUTES, *PUMS_CREATE_THREAD_ATTRIBUTES; 

typedef struct _WOW64_ARCHITECTURE_INFORMATION {
    DWORD Machine : 16;
    DWORD KernelMode : 1;
    DWORD UserMode : 1;
    DWORD Native : 1;
    DWORD Process : 1;
    DWORD ReservedZero0 : 12;
} WOW64_ARCHITECTURE_INFORMATION;


//
// Page/memory priorities.
//









typedef struct _QUOTA_LIMITS {
    SIZE_T PagedPoolLimit;
    SIZE_T NonPagedPoolLimit;
    SIZE_T MinimumWorkingSetSize;
    SIZE_T MaximumWorkingSetSize;
    SIZE_T PagefileLimit;
    LARGE_INTEGER TimeLimit;
} QUOTA_LIMITS, *PQUOTA_LIMITS;







typedef union _RATE_QUOTA_LIMIT {
    DWORD RateData;
    struct {
        DWORD RatePercent : 7;
        DWORD Reserved0   : 25;
    }  ;
} RATE_QUOTA_LIMIT, *PRATE_QUOTA_LIMIT;

typedef struct _QUOTA_LIMITS_EX {
    SIZE_T PagedPoolLimit;
    SIZE_T NonPagedPoolLimit;
    SIZE_T MinimumWorkingSetSize;
    SIZE_T MaximumWorkingSetSize;
    SIZE_T PagefileLimit;               // Limit expressed in pages
    LARGE_INTEGER TimeLimit;
    SIZE_T WorkingSetLimit;             // Limit expressed in pages
    SIZE_T Reserved2;
    SIZE_T Reserved3;
    SIZE_T Reserved4;
    DWORD  Flags;
    RATE_QUOTA_LIMIT CpuRateLimit;
} QUOTA_LIMITS_EX, *PQUOTA_LIMITS_EX;

typedef struct _IO_COUNTERS {
    ULONGLONG  ReadOperationCount;
    ULONGLONG  WriteOperationCount;
    ULONGLONG  OtherOperationCount;
    ULONGLONG ReadTransferCount;
    ULONGLONG WriteTransferCount;
    ULONGLONG OtherTransferCount;
} IO_COUNTERS;
typedef IO_COUNTERS *PIO_COUNTERS;




typedef enum _HARDWARE_COUNTER_TYPE {
    PMCCounter,
    MaxHardwareCounterType
} HARDWARE_COUNTER_TYPE, *PHARDWARE_COUNTER_TYPE;
typedef enum _PROCESS_MITIGATION_POLICY {
    ProcessDEPPolicy,
    ProcessASLRPolicy,
    ProcessDynamicCodePolicy,
    ProcessStrictHandleCheckPolicy,
    ProcessSystemCallDisablePolicy,
    ProcessMitigationOptionsMask,
    ProcessExtensionPointDisablePolicy,
    ProcessControlFlowGuardPolicy,
    ProcessSignaturePolicy,
    ProcessFontDisablePolicy,
    ProcessImageLoadPolicy,
    ProcessSystemCallFilterPolicy,
    ProcessPayloadRestrictionPolicy,
    ProcessChildProcessPolicy,
    ProcessSideChannelIsolationPolicy,
    MaxProcessMitigationPolicy
} PROCESS_MITIGATION_POLICY, *PPROCESS_MITIGATION_POLICY;

//
// N.B.  High entropy mode is read only and can only be set at creation time
//       and not via the ProcessMitigationPolicy APIs.
//

typedef struct _PROCESS_MITIGATION_ASLR_POLICY {
    union {
        DWORD Flags;
        struct {
            DWORD EnableBottomUpRandomization : 1;
            DWORD EnableForceRelocateImages : 1;
            DWORD EnableHighEntropy : 1;
            DWORD DisallowStrippedImages : 1;
            DWORD ReservedFlags : 28;
        }  ;
    }  ;
} PROCESS_MITIGATION_ASLR_POLICY, *PPROCESS_MITIGATION_ASLR_POLICY;

typedef struct _PROCESS_MITIGATION_DEP_POLICY {
    union {
        DWORD Flags;
        struct {
            DWORD Enable : 1;
            DWORD DisableAtlThunkEmulation : 1;
            DWORD ReservedFlags : 30;
        }  ;
    }  ;
    BOOLEAN Permanent;
} PROCESS_MITIGATION_DEP_POLICY, *PPROCESS_MITIGATION_DEP_POLICY;

typedef struct _PROCESS_MITIGATION_STRICT_HANDLE_CHECK_POLICY {
    union {
        DWORD Flags;
        struct {
            DWORD RaiseExceptionOnInvalidHandleReference : 1;
            DWORD HandleExceptionsPermanentlyEnabled : 1;
            DWORD ReservedFlags : 30;
        }  ;
    }  ;
} PROCESS_MITIGATION_STRICT_HANDLE_CHECK_POLICY, *PPROCESS_MITIGATION_STRICT_HANDLE_CHECK_POLICY;

typedef struct _PROCESS_MITIGATION_SYSTEM_CALL_DISABLE_POLICY {
    union {
        DWORD Flags;
        struct {
            DWORD DisallowWin32kSystemCalls : 1;
            DWORD AuditDisallowWin32kSystemCalls : 1;
            DWORD ReservedFlags : 30;
        }  ;
    }  ;
} PROCESS_MITIGATION_SYSTEM_CALL_DISABLE_POLICY, *PPROCESS_MITIGATION_SYSTEM_CALL_DISABLE_POLICY;

typedef struct _PROCESS_MITIGATION_EXTENSION_POINT_DISABLE_POLICY {
    union {
        DWORD Flags;
        struct {
            DWORD DisableExtensionPoints : 1;
            DWORD ReservedFlags : 31;
        }  ;
    }  ;
} PROCESS_MITIGATION_EXTENSION_POINT_DISABLE_POLICY, *PPROCESS_MITIGATION_EXTENSION_POINT_DISABLE_POLICY;

typedef struct _PROCESS_MITIGATION_DYNAMIC_CODE_POLICY {
    union {
        DWORD Flags;
        struct {
            DWORD ProhibitDynamicCode : 1;
            DWORD AllowThreadOptOut : 1;
            DWORD AllowRemoteDowngrade : 1;
            DWORD AuditProhibitDynamicCode : 1;
            DWORD ReservedFlags : 28;
        }  ;
    }  ;
} PROCESS_MITIGATION_DYNAMIC_CODE_POLICY, *PPROCESS_MITIGATION_DYNAMIC_CODE_POLICY;

typedef struct _PROCESS_MITIGATION_CONTROL_FLOW_GUARD_POLICY {
    union {
        DWORD Flags;
        struct {
            DWORD EnableControlFlowGuard : 1;
            DWORD EnableExportSuppression : 1;
            DWORD StrictMode : 1;
            DWORD ReservedFlags : 29;
        }  ;
    }  ;
} PROCESS_MITIGATION_CONTROL_FLOW_GUARD_POLICY, *PPROCESS_MITIGATION_CONTROL_FLOW_GUARD_POLICY;

typedef struct _PROCESS_MITIGATION_BINARY_SIGNATURE_POLICY {
    union {
        DWORD Flags;
        struct {
            DWORD MicrosoftSignedOnly : 1;
            DWORD StoreSignedOnly : 1;
            DWORD MitigationOptIn : 1;
            DWORD AuditMicrosoftSignedOnly : 1;
            DWORD AuditStoreSignedOnly : 1;
            DWORD ReservedFlags : 27;
        }  ;
    }  ;
} PROCESS_MITIGATION_BINARY_SIGNATURE_POLICY, *PPROCESS_MITIGATION_BINARY_SIGNATURE_POLICY;

typedef struct _PROCESS_MITIGATION_FONT_DISABLE_POLICY {
    union {
        DWORD Flags;
        struct {
            DWORD DisableNonSystemFonts     : 1;
            DWORD AuditNonSystemFontLoading : 1;
            DWORD ReservedFlags             : 30;
        }  ;
    }  ;
} PROCESS_MITIGATION_FONT_DISABLE_POLICY, *PPROCESS_MITIGATION_FONT_DISABLE_POLICY;

typedef struct _PROCESS_MITIGATION_IMAGE_LOAD_POLICY {
    union {
        DWORD Flags;
        struct {
            DWORD NoRemoteImages : 1;
            DWORD NoLowMandatoryLabelImages : 1;
            DWORD PreferSystem32Images : 1;
            DWORD AuditNoRemoteImages : 1;
            DWORD AuditNoLowMandatoryLabelImages : 1;
            DWORD ReservedFlags : 27;
        }  ;
    }  ;
} PROCESS_MITIGATION_IMAGE_LOAD_POLICY, *PPROCESS_MITIGATION_IMAGE_LOAD_POLICY;

typedef struct _PROCESS_MITIGATION_SYSTEM_CALL_FILTER_POLICY {
    union {
        DWORD Flags;
        struct {
            DWORD FilterId: 4;
            DWORD ReservedFlags : 28;
        }  ;
    }  ;
} PROCESS_MITIGATION_SYSTEM_CALL_FILTER_POLICY, *PPROCESS_MITIGATION_SYSTEM_CALL_FILTER_POLICY;

typedef struct _PROCESS_MITIGATION_PAYLOAD_RESTRICTION_POLICY {
    union {
        DWORD Flags;
        struct {
            DWORD EnableExportAddressFilter     : 1;
            DWORD AuditExportAddressFilter      : 1;

            DWORD EnableExportAddressFilterPlus : 1;
            DWORD AuditExportAddressFilterPlus  : 1;

            DWORD EnableImportAddressFilter     : 1;
            DWORD AuditImportAddressFilter      : 1;

            DWORD EnableRopStackPivot           : 1;
            DWORD AuditRopStackPivot            : 1;

            DWORD EnableRopCallerCheck          : 1;
            DWORD AuditRopCallerCheck           : 1;

            DWORD EnableRopSimExec              : 1;
            DWORD AuditRopSimExec               : 1;

            DWORD ReservedFlags                 : 20;
        }  ;
    }  ;
} PROCESS_MITIGATION_PAYLOAD_RESTRICTION_POLICY, *PPROCESS_MITIGATION_PAYLOAD_RESTRICTION_POLICY;

typedef struct _PROCESS_MITIGATION_CHILD_PROCESS_POLICY {
    union {
        DWORD Flags;
        struct {
            DWORD NoChildProcessCreation : 1;
            DWORD AuditNoChildProcessCreation : 1;
            DWORD AllowSecureProcessCreation : 1;
            DWORD ReservedFlags : 29;
        }  ;
    }  ;
} PROCESS_MITIGATION_CHILD_PROCESS_POLICY, *PPROCESS_MITIGATION_CHILD_PROCESS_POLICY;

typedef struct _PROCESS_MITIGATION_SIDE_CHANNEL_ISOLATION_POLICY {
    union {
        DWORD Flags;
        struct {

            //
            // Prevent branch target pollution cross-SMT-thread in user mode.
            //

            DWORD SmtBranchTargetIsolation : 1;

            //
            // Isolate this process into a distinct security domain, even from
            // other processes running as the same security context.  This
            // prevents branch target injection cross-process (normally such
            // branch target injection is only inhibited across different
            // security contexts).
            //
            // Page combining is limited to processes within the same security
            // domain.  This flag thus also effectively limits the process to
            // only being able to combine internally to the process itself,
            // except for common pages (unless further restricted by the
            // DisablePageCombine policy).
            //

            DWORD IsolateSecurityDomain : 1;

            //
            // Disable all page combining for this process, even internally to
            // the process itself, except for common pages (zeroes or ones).
            //

            DWORD DisablePageCombine : 1;

            //
            // Memory Disambiguation Disable.
            //

            DWORD SpeculativeStoreBypassDisable : 1;

            DWORD ReservedFlags : 28;

        }  ;
    }  ;
} PROCESS_MITIGATION_SIDE_CHANNEL_ISOLATION_POLICY, *PPROCESS_MITIGATION_SIDE_CHANNEL_ISOLATION_POLICY;


typedef struct _JOBOBJECT_BASIC_ACCOUNTING_INFORMATION {
    LARGE_INTEGER TotalUserTime;
    LARGE_INTEGER TotalKernelTime;
    LARGE_INTEGER ThisPeriodTotalUserTime;
    LARGE_INTEGER ThisPeriodTotalKernelTime;
    DWORD TotalPageFaultCount;
    DWORD TotalProcesses;
    DWORD ActiveProcesses;
    DWORD TotalTerminatedProcesses;
} JOBOBJECT_BASIC_ACCOUNTING_INFORMATION, *PJOBOBJECT_BASIC_ACCOUNTING_INFORMATION;

typedef struct _JOBOBJECT_BASIC_LIMIT_INFORMATION {
    LARGE_INTEGER PerProcessUserTimeLimit;
    LARGE_INTEGER PerJobUserTimeLimit;
    DWORD LimitFlags;
    SIZE_T MinimumWorkingSetSize;
    SIZE_T MaximumWorkingSetSize;
    DWORD ActiveProcessLimit;
    ULONG_PTR Affinity;
    DWORD PriorityClass;
    DWORD SchedulingClass;
} JOBOBJECT_BASIC_LIMIT_INFORMATION, *PJOBOBJECT_BASIC_LIMIT_INFORMATION;

typedef struct _JOBOBJECT_EXTENDED_LIMIT_INFORMATION {
    JOBOBJECT_BASIC_LIMIT_INFORMATION BasicLimitInformation;
    IO_COUNTERS IoInfo;
    SIZE_T ProcessMemoryLimit;
    SIZE_T JobMemoryLimit;
    SIZE_T PeakProcessMemoryUsed;
    SIZE_T PeakJobMemoryUsed;
} JOBOBJECT_EXTENDED_LIMIT_INFORMATION, *PJOBOBJECT_EXTENDED_LIMIT_INFORMATION;


//@[comment("MVI_tracked")]
typedef struct _JOBOBJECT_BASIC_PROCESS_ID_LIST {
    DWORD NumberOfAssignedProcesses;
    DWORD NumberOfProcessIdsInList;
    ULONG_PTR ProcessIdList[1];
} JOBOBJECT_BASIC_PROCESS_ID_LIST, *PJOBOBJECT_BASIC_PROCESS_ID_LIST;

typedef struct _JOBOBJECT_BASIC_UI_RESTRICTIONS {
    DWORD UIRestrictionsClass;
} JOBOBJECT_BASIC_UI_RESTRICTIONS, *PJOBOBJECT_BASIC_UI_RESTRICTIONS;

//
// N.B. The JOBOBJECT_SECURITY_LIMIT_INFORMATION information class is no longer supported.
//

typedef struct _JOBOBJECT_SECURITY_LIMIT_INFORMATION {
    DWORD SecurityLimitFlags ;
    HANDLE JobToken ;
    PTOKEN_GROUPS SidsToDisable ;
    PTOKEN_PRIVILEGES PrivilegesToDelete ;
    PTOKEN_GROUPS RestrictedSids ;
} JOBOBJECT_SECURITY_LIMIT_INFORMATION, *PJOBOBJECT_SECURITY_LIMIT_INFORMATION ;

typedef struct _JOBOBJECT_END_OF_JOB_TIME_INFORMATION {
    DWORD EndOfJobTimeAction;
} JOBOBJECT_END_OF_JOB_TIME_INFORMATION, *PJOBOBJECT_END_OF_JOB_TIME_INFORMATION;

typedef struct _JOBOBJECT_ASSOCIATE_COMPLETION_PORT {
    PVOID CompletionKey;
    HANDLE CompletionPort;
} JOBOBJECT_ASSOCIATE_COMPLETION_PORT, *PJOBOBJECT_ASSOCIATE_COMPLETION_PORT;

typedef struct _JOBOBJECT_BASIC_AND_IO_ACCOUNTING_INFORMATION {
    JOBOBJECT_BASIC_ACCOUNTING_INFORMATION BasicInfo;
    IO_COUNTERS IoInfo;
} JOBOBJECT_BASIC_AND_IO_ACCOUNTING_INFORMATION, *PJOBOBJECT_BASIC_AND_IO_ACCOUNTING_INFORMATION;

typedef struct _JOBOBJECT_JOBSET_INFORMATION {
    DWORD MemberLevel;
} JOBOBJECT_JOBSET_INFORMATION, *PJOBOBJECT_JOBSET_INFORMATION;

typedef enum _JOBOBJECT_RATE_CONTROL_TOLERANCE {
    ToleranceLow = 1,
    ToleranceMedium,
    ToleranceHigh
} JOBOBJECT_RATE_CONTROL_TOLERANCE, *PJOBOBJECT_RATE_CONTROL_TOLERANCE;

typedef enum _JOBOBJECT_RATE_CONTROL_TOLERANCE_INTERVAL {
    ToleranceIntervalShort = 1,
    ToleranceIntervalMedium,
    ToleranceIntervalLong
} JOBOBJECT_RATE_CONTROL_TOLERANCE_INTERVAL,
  *PJOBOBJECT_RATE_CONTROL_TOLERANCE_INTERVAL;

typedef struct _JOBOBJECT_NOTIFICATION_LIMIT_INFORMATION {
    DWORD64 IoReadBytesLimit;
    DWORD64 IoWriteBytesLimit;
    LARGE_INTEGER PerJobUserTimeLimit;
    DWORD64 JobMemoryLimit;
    JOBOBJECT_RATE_CONTROL_TOLERANCE RateControlTolerance;
    JOBOBJECT_RATE_CONTROL_TOLERANCE_INTERVAL RateControlToleranceInterval;
    DWORD LimitFlags;
} JOBOBJECT_NOTIFICATION_LIMIT_INFORMATION, *PJOBOBJECT_NOTIFICATION_LIMIT_INFORMATION;

typedef struct JOBOBJECT_NOTIFICATION_LIMIT_INFORMATION_2 {
    DWORD64 IoReadBytesLimit;
    DWORD64 IoWriteBytesLimit;
    LARGE_INTEGER PerJobUserTimeLimit;
    union {
        DWORD64 JobHighMemoryLimit;
        DWORD64 JobMemoryLimit;
    }  ;

    union {
        JOBOBJECT_RATE_CONTROL_TOLERANCE RateControlTolerance;
        JOBOBJECT_RATE_CONTROL_TOLERANCE CpuRateControlTolerance;
    }  ;

    union {
        JOBOBJECT_RATE_CONTROL_TOLERANCE_INTERVAL RateControlToleranceInterval;
        JOBOBJECT_RATE_CONTROL_TOLERANCE_INTERVAL
            CpuRateControlToleranceInterval;
    }  ;

    DWORD LimitFlags;
    JOBOBJECT_RATE_CONTROL_TOLERANCE IoRateControlTolerance;
    DWORD64 JobLowMemoryLimit;
    JOBOBJECT_RATE_CONTROL_TOLERANCE_INTERVAL IoRateControlToleranceInterval;
    JOBOBJECT_RATE_CONTROL_TOLERANCE NetRateControlTolerance;
    JOBOBJECT_RATE_CONTROL_TOLERANCE_INTERVAL NetRateControlToleranceInterval;
} JOBOBJECT_NOTIFICATION_LIMIT_INFORMATION_2;


typedef struct _JOBOBJECT_LIMIT_VIOLATION_INFORMATION {
    DWORD LimitFlags;
    DWORD ViolationLimitFlags;
    DWORD64 IoReadBytes;
    DWORD64 IoReadBytesLimit;
    DWORD64 IoWriteBytes;
    DWORD64 IoWriteBytesLimit;
    LARGE_INTEGER PerJobUserTime;
    LARGE_INTEGER PerJobUserTimeLimit;
    DWORD64 JobMemory;
    DWORD64 JobMemoryLimit;
    JOBOBJECT_RATE_CONTROL_TOLERANCE RateControlTolerance;
    JOBOBJECT_RATE_CONTROL_TOLERANCE RateControlToleranceLimit;
} JOBOBJECT_LIMIT_VIOLATION_INFORMATION, *PJOBOBJECT_LIMIT_VIOLATION_INFORMATION;

typedef struct JOBOBJECT_LIMIT_VIOLATION_INFORMATION_2 {
    DWORD LimitFlags;
    DWORD ViolationLimitFlags;
    DWORD64 IoReadBytes;
    DWORD64 IoReadBytesLimit;
    DWORD64 IoWriteBytes;
    DWORD64 IoWriteBytesLimit;
    LARGE_INTEGER PerJobUserTime;
    LARGE_INTEGER PerJobUserTimeLimit;
    DWORD64 JobMemory;
    union {
        DWORD64 JobHighMemoryLimit;
        DWORD64 JobMemoryLimit;
    }  ;

    union {
        JOBOBJECT_RATE_CONTROL_TOLERANCE RateControlTolerance;
        JOBOBJECT_RATE_CONTROL_TOLERANCE CpuRateControlTolerance;
    }  ;

    union {
        JOBOBJECT_RATE_CONTROL_TOLERANCE RateControlToleranceLimit;
        JOBOBJECT_RATE_CONTROL_TOLERANCE CpuRateControlToleranceLimit;
    }  ;

    DWORD64 JobLowMemoryLimit;
    JOBOBJECT_RATE_CONTROL_TOLERANCE IoRateControlTolerance;
    JOBOBJECT_RATE_CONTROL_TOLERANCE IoRateControlToleranceLimit;
    JOBOBJECT_RATE_CONTROL_TOLERANCE NetRateControlTolerance;
    JOBOBJECT_RATE_CONTROL_TOLERANCE NetRateControlToleranceLimit;
} JOBOBJECT_LIMIT_VIOLATION_INFORMATION_2;


typedef struct _JOBOBJECT_CPU_RATE_CONTROL_INFORMATION {
    DWORD ControlFlags;
    union {
        DWORD CpuRate;
        DWORD Weight;
        struct {
            WORD   MinRate;
            WORD   MaxRate;
        }  ;
    }  ;
} JOBOBJECT_CPU_RATE_CONTROL_INFORMATION, *PJOBOBJECT_CPU_RATE_CONTROL_INFORMATION;

//
// Control flags for network rate control.
//

typedef enum JOB_OBJECT_NET_RATE_CONTROL_FLAGS {
    JOB_OBJECT_NET_RATE_CONTROL_ENABLE = 0x1,
    JOB_OBJECT_NET_RATE_CONTROL_MAX_BANDWIDTH = 0x2,
    JOB_OBJECT_NET_RATE_CONTROL_DSCP_TAG = 0x4,
    JOB_OBJECT_NET_RATE_CONTROL_VALID_FLAGS = 0x7
} JOB_OBJECT_NET_RATE_CONTROL_FLAGS;



extern "C++" { inline constexpr JOB_OBJECT_NET_RATE_CONTROL_FLAGS operator | (JOB_OBJECT_NET_RATE_CONTROL_FLAGS a, JOB_OBJECT_NET_RATE_CONTROL_FLAGS b) throw() { return JOB_OBJECT_NET_RATE_CONTROL_FLAGS(((_ENUM_FLAG_SIZED_INTEGER<JOB_OBJECT_NET_RATE_CONTROL_FLAGS>::type)a) | ((_ENUM_FLAG_SIZED_INTEGER<JOB_OBJECT_NET_RATE_CONTROL_FLAGS>::type)b)); } inline JOB_OBJECT_NET_RATE_CONTROL_FLAGS &operator |= (JOB_OBJECT_NET_RATE_CONTROL_FLAGS &a, JOB_OBJECT_NET_RATE_CONTROL_FLAGS b) throw() { return (JOB_OBJECT_NET_RATE_CONTROL_FLAGS &)(((_ENUM_FLAG_SIZED_INTEGER<JOB_OBJECT_NET_RATE_CONTROL_FLAGS>::type &)a) |= ((_ENUM_FLAG_SIZED_INTEGER<JOB_OBJECT_NET_RATE_CONTROL_FLAGS>::type)b)); } inline constexpr JOB_OBJECT_NET_RATE_CONTROL_FLAGS operator & (JOB_OBJECT_NET_RATE_CONTROL_FLAGS a, JOB_OBJECT_NET_RATE_CONTROL_FLAGS b) throw() { return JOB_OBJECT_NET_RATE_CONTROL_FLAGS(((_ENUM_FLAG_SIZED_INTEGER<JOB_OBJECT_NET_RATE_CONTROL_FLAGS>::type)a) & ((_ENUM_FLAG_SIZED_INTEGER<JOB_OBJECT_NET_RATE_CONTROL_FLAGS>::type)b)); } inline JOB_OBJECT_NET_RATE_CONTROL_FLAGS &operator &= (JOB_OBJECT_NET_RATE_CONTROL_FLAGS &a, JOB_OBJECT_NET_RATE_CONTROL_FLAGS b) throw() { return (JOB_OBJECT_NET_RATE_CONTROL_FLAGS &)(((_ENUM_FLAG_SIZED_INTEGER<JOB_OBJECT_NET_RATE_CONTROL_FLAGS>::type &)a) &= ((_ENUM_FLAG_SIZED_INTEGER<JOB_OBJECT_NET_RATE_CONTROL_FLAGS>::type)b)); } inline constexpr JOB_OBJECT_NET_RATE_CONTROL_FLAGS operator ~ (JOB_OBJECT_NET_RATE_CONTROL_FLAGS a) throw() { return JOB_OBJECT_NET_RATE_CONTROL_FLAGS(~((_ENUM_FLAG_SIZED_INTEGER<JOB_OBJECT_NET_RATE_CONTROL_FLAGS>::type)a)); } inline constexpr JOB_OBJECT_NET_RATE_CONTROL_FLAGS operator ^ (JOB_OBJECT_NET_RATE_CONTROL_FLAGS a, JOB_OBJECT_NET_RATE_CONTROL_FLAGS b) throw() { return JOB_OBJECT_NET_RATE_CONTROL_FLAGS(((_ENUM_FLAG_SIZED_INTEGER<JOB_OBJECT_NET_RATE_CONTROL_FLAGS>::type)a) ^ ((_ENUM_FLAG_SIZED_INTEGER<JOB_OBJECT_NET_RATE_CONTROL_FLAGS>::type)b)); } inline JOB_OBJECT_NET_RATE_CONTROL_FLAGS &operator ^= (JOB_OBJECT_NET_RATE_CONTROL_FLAGS &a, JOB_OBJECT_NET_RATE_CONTROL_FLAGS b) throw() { return (JOB_OBJECT_NET_RATE_CONTROL_FLAGS &)(((_ENUM_FLAG_SIZED_INTEGER<JOB_OBJECT_NET_RATE_CONTROL_FLAGS>::type &)a) ^= ((_ENUM_FLAG_SIZED_INTEGER<JOB_OBJECT_NET_RATE_CONTROL_FLAGS>::type)b)); } }
typedef char __C_ASSERT__[(JOB_OBJECT_NET_RATE_CONTROL_VALID_FLAGS == (JOB_OBJECT_NET_RATE_CONTROL_ENABLE + JOB_OBJECT_NET_RATE_CONTROL_MAX_BANDWIDTH + JOB_OBJECT_NET_RATE_CONTROL_DSCP_TAG))?1:-1]


;

#line 12037 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winnt.h"



typedef struct JOBOBJECT_NET_RATE_CONTROL_INFORMATION {
    DWORD64 MaxBandwidth;
    JOB_OBJECT_NET_RATE_CONTROL_FLAGS ControlFlags;
    BYTE  DscpTag;
} JOBOBJECT_NET_RATE_CONTROL_INFORMATION;


//
// Control flags for IO rate control.
//

// begin_ntosifs

typedef enum JOB_OBJECT_IO_RATE_CONTROL_FLAGS {
    JOB_OBJECT_IO_RATE_CONTROL_ENABLE = 0x1,
    JOB_OBJECT_IO_RATE_CONTROL_STANDALONE_VOLUME = 0x2,
    JOB_OBJECT_IO_RATE_CONTROL_FORCE_UNIT_ACCESS_ALL = 0x4,
    JOB_OBJECT_IO_RATE_CONTROL_FORCE_UNIT_ACCESS_ON_SOFT_CAP = 0x8,
    JOB_OBJECT_IO_RATE_CONTROL_VALID_FLAGS = JOB_OBJECT_IO_RATE_CONTROL_ENABLE |
                                             JOB_OBJECT_IO_RATE_CONTROL_STANDALONE_VOLUME |
                                             JOB_OBJECT_IO_RATE_CONTROL_FORCE_UNIT_ACCESS_ALL |
                                             JOB_OBJECT_IO_RATE_CONTROL_FORCE_UNIT_ACCESS_ON_SOFT_CAP
} JOB_OBJECT_IO_RATE_CONTROL_FLAGS;



extern "C++" { inline constexpr JOB_OBJECT_IO_RATE_CONTROL_FLAGS operator | (JOB_OBJECT_IO_RATE_CONTROL_FLAGS a, JOB_OBJECT_IO_RATE_CONTROL_FLAGS b) throw() { return JOB_OBJECT_IO_RATE_CONTROL_FLAGS(((_ENUM_FLAG_SIZED_INTEGER<JOB_OBJECT_IO_RATE_CONTROL_FLAGS>::type)a) | ((_ENUM_FLAG_SIZED_INTEGER<JOB_OBJECT_IO_RATE_CONTROL_FLAGS>::type)b)); } inline JOB_OBJECT_IO_RATE_CONTROL_FLAGS &operator |= (JOB_OBJECT_IO_RATE_CONTROL_FLAGS &a, JOB_OBJECT_IO_RATE_CONTROL_FLAGS b) throw() { return (JOB_OBJECT_IO_RATE_CONTROL_FLAGS &)(((_ENUM_FLAG_SIZED_INTEGER<JOB_OBJECT_IO_RATE_CONTROL_FLAGS>::type &)a) |= ((_ENUM_FLAG_SIZED_INTEGER<JOB_OBJECT_IO_RATE_CONTROL_FLAGS>::type)b)); } inline constexpr JOB_OBJECT_IO_RATE_CONTROL_FLAGS operator & (JOB_OBJECT_IO_RATE_CONTROL_FLAGS a, JOB_OBJECT_IO_RATE_CONTROL_FLAGS b) throw() { return JOB_OBJECT_IO_RATE_CONTROL_FLAGS(((_ENUM_FLAG_SIZED_INTEGER<JOB_OBJECT_IO_RATE_CONTROL_FLAGS>::type)a) & ((_ENUM_FLAG_SIZED_INTEGER<JOB_OBJECT_IO_RATE_CONTROL_FLAGS>::type)b)); } inline JOB_OBJECT_IO_RATE_CONTROL_FLAGS &operator &= (JOB_OBJECT_IO_RATE_CONTROL_FLAGS &a, JOB_OBJECT_IO_RATE_CONTROL_FLAGS b) throw() { return (JOB_OBJECT_IO_RATE_CONTROL_FLAGS &)(((_ENUM_FLAG_SIZED_INTEGER<JOB_OBJECT_IO_RATE_CONTROL_FLAGS>::type &)a) &= ((_ENUM_FLAG_SIZED_INTEGER<JOB_OBJECT_IO_RATE_CONTROL_FLAGS>::type)b)); } inline constexpr JOB_OBJECT_IO_RATE_CONTROL_FLAGS operator ~ (JOB_OBJECT_IO_RATE_CONTROL_FLAGS a) throw() { return JOB_OBJECT_IO_RATE_CONTROL_FLAGS(~((_ENUM_FLAG_SIZED_INTEGER<JOB_OBJECT_IO_RATE_CONTROL_FLAGS>::type)a)); } inline constexpr JOB_OBJECT_IO_RATE_CONTROL_FLAGS operator ^ (JOB_OBJECT_IO_RATE_CONTROL_FLAGS a, JOB_OBJECT_IO_RATE_CONTROL_FLAGS b) throw() { return JOB_OBJECT_IO_RATE_CONTROL_FLAGS(((_ENUM_FLAG_SIZED_INTEGER<JOB_OBJECT_IO_RATE_CONTROL_FLAGS>::type)a) ^ ((_ENUM_FLAG_SIZED_INTEGER<JOB_OBJECT_IO_RATE_CONTROL_FLAGS>::type)b)); } inline JOB_OBJECT_IO_RATE_CONTROL_FLAGS &operator ^= (JOB_OBJECT_IO_RATE_CONTROL_FLAGS &a, JOB_OBJECT_IO_RATE_CONTROL_FLAGS b) throw() { return (JOB_OBJECT_IO_RATE_CONTROL_FLAGS &)(((_ENUM_FLAG_SIZED_INTEGER<JOB_OBJECT_IO_RATE_CONTROL_FLAGS>::type &)a) ^= ((_ENUM_FLAG_SIZED_INTEGER<JOB_OBJECT_IO_RATE_CONTROL_FLAGS>::type)b)); } }

#line 12069 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winnt.h"

typedef struct JOBOBJECT_IO_RATE_CONTROL_INFORMATION_NATIVE {
    LONG64 MaxIops;
    LONG64 MaxBandwidth;
    LONG64 ReservationIops;
    PWSTR VolumeName;
    DWORD BaseIoSize;
    JOB_OBJECT_IO_RATE_CONTROL_FLAGS ControlFlags;
    WORD   VolumeNameLength;
} JOBOBJECT_IO_RATE_CONTROL_INFORMATION_NATIVE;

typedef JOBOBJECT_IO_RATE_CONTROL_INFORMATION_NATIVE
    JOBOBJECT_IO_RATE_CONTROL_INFORMATION_NATIVE_V1;

typedef struct JOBOBJECT_IO_RATE_CONTROL_INFORMATION_NATIVE_V2 {
    LONG64 MaxIops;
    LONG64 MaxBandwidth;
    LONG64 ReservationIops;
    PWSTR VolumeName;
    DWORD BaseIoSize;
    JOB_OBJECT_IO_RATE_CONTROL_FLAGS ControlFlags;
    WORD   VolumeNameLength;
    LONG64 CriticalReservationIops;
    LONG64 ReservationBandwidth;
    LONG64 CriticalReservationBandwidth;
    LONG64 MaxTimePercent;
    LONG64 ReservationTimePercent;
    LONG64 CriticalReservationTimePercent;
} JOBOBJECT_IO_RATE_CONTROL_INFORMATION_NATIVE_V2;

typedef struct JOBOBJECT_IO_RATE_CONTROL_INFORMATION_NATIVE_V3 {
    LONG64 MaxIops;
    LONG64 MaxBandwidth;
    LONG64 ReservationIops;
    PWSTR VolumeName;
    DWORD BaseIoSize;
    JOB_OBJECT_IO_RATE_CONTROL_FLAGS ControlFlags;
    WORD   VolumeNameLength;
    LONG64 CriticalReservationIops;
    LONG64 ReservationBandwidth;
    LONG64 CriticalReservationBandwidth;
    LONG64 MaxTimePercent;
    LONG64 ReservationTimePercent;
    LONG64 CriticalReservationTimePercent;
    LONG64 SoftMaxIops;
    LONG64 SoftMaxBandwidth;
    LONG64 SoftMaxTimePercent;
    LONG64 LimitExcessNotifyIops;
    LONG64 LimitExcessNotifyBandwidth;
    LONG64 LimitExcessNotifyTimePercent;
} JOBOBJECT_IO_RATE_CONTROL_INFORMATION_NATIVE_V3;

// end_ntosifs

typedef enum JOBOBJECT_IO_ATTRIBUTION_CONTROL_FLAGS {
    JOBOBJECT_IO_ATTRIBUTION_CONTROL_ENABLE = 0x1,
    JOBOBJECT_IO_ATTRIBUTION_CONTROL_DISABLE = 0x2,
    JOBOBJECT_IO_ATTRIBUTION_CONTROL_VALID_FLAGS = 0x3
} JOBOBJECT_IO_ATTRIBUTION_CONTROL_FLAGS;

typedef struct _JOBOBJECT_IO_ATTRIBUTION_STATS {

    ULONG_PTR IoCount;
    ULONGLONG TotalNonOverlappedQueueTime;
    ULONGLONG TotalNonOverlappedServiceTime;
    ULONGLONG TotalSize;

} JOBOBJECT_IO_ATTRIBUTION_STATS, *PJOBOBJECT_IO_ATTRIBUTION_STATS;

typedef struct _JOBOBJECT_IO_ATTRIBUTION_INFORMATION {
    DWORD ControlFlags;

    JOBOBJECT_IO_ATTRIBUTION_STATS ReadStats;
    JOBOBJECT_IO_ATTRIBUTION_STATS WriteStats;

} JOBOBJECT_IO_ATTRIBUTION_INFORMATION, *PJOBOBJECT_IO_ATTRIBUTION_INFORMATION;





//
// Completion Port Messages for job objects
//
// These values are returned via the lpNumberOfBytesTransferred parameter
//














//
// Define the valid notification filter values.
//








//
// Basic Limits
//









//
// Extended Limits
//










//
// Notification Limits
//









//
// Valid Job Object Limits
//















//
// UI restrictions for jobs
//























//
// Control flags for CPU rate control.
//









//@[comment("MVI_tracked")]
typedef enum _JOBOBJECTINFOCLASS {
    JobObjectBasicAccountingInformation = 1,
    JobObjectBasicLimitInformation,
    JobObjectBasicProcessIdList,
    JobObjectBasicUIRestrictions,
    JobObjectSecurityLimitInformation,  // deprecated
    JobObjectEndOfJobTimeInformation,
    JobObjectAssociateCompletionPortInformation,
    JobObjectBasicAndIoAccountingInformation,
    JobObjectExtendedLimitInformation,
    JobObjectJobSetInformation,
    JobObjectGroupInformation,
    JobObjectNotificationLimitInformation,
    JobObjectLimitViolationInformation,
    JobObjectGroupInformationEx,
    JobObjectCpuRateControlInformation,
    JobObjectCompletionFilter,
    JobObjectCompletionCounter,
    JobObjectReserved1Information = 18,
    JobObjectReserved2Information,
    JobObjectReserved3Information,
    JobObjectReserved4Information,
    JobObjectReserved5Information,
    JobObjectReserved6Information,
    JobObjectReserved7Information,
    JobObjectReserved8Information,
    JobObjectReserved9Information,
    JobObjectReserved10Information,
    JobObjectReserved11Information,
    JobObjectReserved12Information,
    JobObjectReserved13Information,
    JobObjectReserved14Information = 31,
    JobObjectNetRateControlInformation,
    JobObjectNotificationLimitInformation2,
    JobObjectLimitViolationInformation2,
    JobObjectCreateSilo,
    JobObjectSiloBasicInformation,
    JobObjectReserved15Information = 37,
    JobObjectReserved16Information = 38,
    JobObjectReserved17Information = 39,
    JobObjectReserved18Information = 40,
    JobObjectReserved19Information = 41,
    JobObjectReserved20Information = 42,
    JobObjectReserved21Information = 43,
    JobObjectReserved22Information = 44,
    JobObjectReserved23Information = 45,
    JobObjectReserved24Information = 46,
    JobObjectReserved25Information = 47,
    MaxJobObjectInfoClass
} JOBOBJECTINFOCLASS;



typedef struct _SILOOBJECT_BASIC_INFORMATION {
    DWORD SiloId;
    DWORD SiloParentId;
    DWORD NumberOfProcesses;
    BOOLEAN IsInServerSilo;
    BYTE  Reserved[3];
} SILOOBJECT_BASIC_INFORMATION, *PSILOOBJECT_BASIC_INFORMATION;

typedef enum _SERVERSILO_STATE {
    SERVERSILO_INITING = 0,
    SERVERSILO_STARTED,
    SERVERSILO_SHUTTING_DOWN,
    SERVERSILO_TERMINATING,
    SERVERSILO_TERMINATED,
} SERVERSILO_STATE, *PSERVERSILO_STATE;

typedef struct _SERVERSILO_BASIC_INFORMATION {
    DWORD ServiceSessionId;
    SERVERSILO_STATE State;
    DWORD    ExitStatus;
} SERVERSILO_BASIC_INFORMATION, *PSERVERSILO_BASIC_INFORMATION;


typedef enum _FIRMWARE_TYPE {
    FirmwareTypeUnknown,
    FirmwareTypeBios,
    FirmwareTypeUefi,
    FirmwareTypeMax
} FIRMWARE_TYPE, *PFIRMWARE_TYPE;




//
// Mutant Specific Access Rights
//








//
// Timer Specific Access Rights.
//







// begin_nthal





// end_nthal

typedef enum _LOGICAL_PROCESSOR_RELATIONSHIP {
    RelationProcessorCore,
    RelationNumaNode,
    RelationCache,
    RelationProcessorPackage,
    RelationGroup,
    RelationAll = 0xffff
} LOGICAL_PROCESSOR_RELATIONSHIP;



typedef enum _PROCESSOR_CACHE_TYPE {
    CacheUnified,
    CacheInstruction,
    CacheData,
    CacheTrace
} PROCESSOR_CACHE_TYPE;



typedef struct _CACHE_DESCRIPTOR {
    BYTE   Level;
    BYTE   Associativity;
    WORD   LineSize;
    DWORD  Size;
    PROCESSOR_CACHE_TYPE Type;
} CACHE_DESCRIPTOR, *PCACHE_DESCRIPTOR;

typedef struct _SYSTEM_LOGICAL_PROCESSOR_INFORMATION {
    ULONG_PTR   ProcessorMask;
    LOGICAL_PROCESSOR_RELATIONSHIP Relationship;
    union {
        struct {
            BYTE  Flags;
        } ProcessorCore;
        struct {
            DWORD NodeNumber;
        } NumaNode;
        CACHE_DESCRIPTOR Cache;
        ULONGLONG  Reserved[2];
    }  ;
} SYSTEM_LOGICAL_PROCESSOR_INFORMATION, *PSYSTEM_LOGICAL_PROCESSOR_INFORMATION;

typedef struct _PROCESSOR_RELATIONSHIP {
    BYTE  Flags;
    BYTE  EfficiencyClass;
    BYTE  Reserved[20];
    WORD   GroupCount;
     GROUP_AFFINITY GroupMask[1 ];
} PROCESSOR_RELATIONSHIP, *PPROCESSOR_RELATIONSHIP;

typedef struct _NUMA_NODE_RELATIONSHIP {
    DWORD NodeNumber;
    BYTE  Reserved[20];
    GROUP_AFFINITY GroupMask;
} NUMA_NODE_RELATIONSHIP, *PNUMA_NODE_RELATIONSHIP;

typedef struct _CACHE_RELATIONSHIP {
    BYTE  Level;
    BYTE  Associativity;
    WORD   LineSize;
    DWORD CacheSize;
    PROCESSOR_CACHE_TYPE Type;
    BYTE  Reserved[20];
    GROUP_AFFINITY GroupMask;
} CACHE_RELATIONSHIP, *PCACHE_RELATIONSHIP;

typedef struct _PROCESSOR_GROUP_INFO {
    BYTE  MaximumProcessorCount;
    BYTE  ActiveProcessorCount;
    BYTE  Reserved[38];
    KAFFINITY ActiveProcessorMask;
} PROCESSOR_GROUP_INFO, *PPROCESSOR_GROUP_INFO;

typedef struct _GROUP_RELATIONSHIP {
    WORD   MaximumGroupCount;
    WORD   ActiveGroupCount;
    BYTE  Reserved[20];
    PROCESSOR_GROUP_INFO GroupInfo[1 ];
} GROUP_RELATIONSHIP, *PGROUP_RELATIONSHIP;

 struct _SYSTEM_LOGICAL_PROCESSOR_INFORMATION_EX {
    LOGICAL_PROCESSOR_RELATIONSHIP Relationship;
    DWORD Size;
    union {
        PROCESSOR_RELATIONSHIP Processor;
        NUMA_NODE_RELATIONSHIP NumaNode;
        CACHE_RELATIONSHIP Cache;
        GROUP_RELATIONSHIP Group;
    }  ;
};

typedef struct _SYSTEM_LOGICAL_PROCESSOR_INFORMATION_EX SYSTEM_LOGICAL_PROCESSOR_INFORMATION_EX, *PSYSTEM_LOGICAL_PROCESSOR_INFORMATION_EX;

typedef enum _CPU_SET_INFORMATION_TYPE {
    CpuSetInformation
} CPU_SET_INFORMATION_TYPE, *PCPU_SET_INFORMATION_TYPE;

 struct _SYSTEM_CPU_SET_INFORMATION {
    DWORD Size;
    CPU_SET_INFORMATION_TYPE Type;
    union {
        struct {
            DWORD Id;
            WORD   Group;
            BYTE  LogicalProcessorIndex;
            BYTE  CoreIndex;
            BYTE  LastLevelCacheIndex;
            BYTE  NumaNodeIndex;
            BYTE  EfficiencyClass;
            union {






                BYTE  AllFlags;
                struct {
                    BYTE  Parked : 1;
                    BYTE  Allocated : 1;
                    BYTE  AllocatedToTargetProcess : 1;
                    BYTE  RealTime : 1;
                    BYTE  ReservedFlags : 4;
                }  ;
            }  ;

            union {
                DWORD Reserved;
                BYTE  SchedulingClass;
            };

            DWORD64 AllocationTag;
        } CpuSet;
    }  ;
};

typedef struct _SYSTEM_CPU_SET_INFORMATION SYSTEM_CPU_SET_INFORMATION, *PSYSTEM_CPU_SET_INFORMATION;

// end_wdm end_ntminiport

typedef struct _SYSTEM_PROCESSOR_CYCLE_TIME_INFORMATION {
    DWORD64 CycleTime;
} SYSTEM_PROCESSOR_CYCLE_TIME_INFORMATION, *PSYSTEM_PROCESSOR_CYCLE_TIME_INFORMATION;
















































































//
// Known extended CPU state feature BITs
//
// 0    x87
// 1    SSE
// 2    AVX
// 3    BNDREGS (B0.LB-B3.LB B0.UB-B3.UB)
// 4    BNDCSR  (BNDCFGU + BNDSTATUS)       Persistent
// 5    KMASK   (KMASK [63:0][0-7])
// 6    ZMM_H   (ZMM_H[511:256][0-15])
// 7    ZMM     (ZMM[511:0][16-31])
// 8    IPT                                 Supervisor
//
// 11   CET_U                               Supervisor
//
// 62   LWP                                 Persistent
//
// 63   RZ0                                 Reserved
//















//
// Known extended CPU state feature MASKs
//
































//
// Flags associated with compaction mask
//












//
// Extended processor state configuration
//

typedef struct _XSTATE_FEATURE {
    DWORD Offset;
    DWORD Size;
} XSTATE_FEATURE, *PXSTATE_FEATURE;

typedef struct _XSTATE_CONFIGURATION {
    // Mask of all enabled features
    DWORD64 EnabledFeatures;

    // Mask of volatile enabled features
    DWORD64 EnabledVolatileFeatures;

    // Total size of the save area for user states
    DWORD Size;

    // Control Flags
    union {
        DWORD ControlFlags;
        struct
        {
            DWORD OptimizedSave : 1;
            DWORD CompactionEnabled : 1;
        };
    };

    // List of features
    XSTATE_FEATURE Features[(64) ];

    // Mask of all supervisor features
    DWORD64 EnabledSupervisorFeatures;

    // Mask of features that require start address to be 64 byte aligned
    DWORD64 AlignedFeatures;

    // Total size of the save area for user and supervisor states
    DWORD AllFeatureSize;

    // List which holds size of each user and supervisor state supported by CPU
    DWORD AllFeatures[(64) ];

    // Mask of all supervisor features that are exposed to user-mode
    DWORD64 EnabledUserVisibleSupervisorFeatures;

} XSTATE_CONFIGURATION, *PXSTATE_CONFIGURATION;

// begin_ntifs

typedef struct _MEMORY_BASIC_INFORMATION {
    PVOID BaseAddress;
    PVOID AllocationBase;
    DWORD AllocationProtect;
    SIZE_T RegionSize;
    DWORD State;
    DWORD Protect;
    DWORD Type;
} MEMORY_BASIC_INFORMATION, *PMEMORY_BASIC_INFORMATION;

// end_ntifs

typedef struct _MEMORY_BASIC_INFORMATION32 {
    DWORD BaseAddress;
    DWORD AllocationBase;
    DWORD AllocationProtect;
    DWORD RegionSize;
    DWORD State;
    DWORD Protect;
    DWORD Type;
} MEMORY_BASIC_INFORMATION32, *PMEMORY_BASIC_INFORMATION32;

typedef struct __declspec(align(16)) _MEMORY_BASIC_INFORMATION64 {
    ULONGLONG BaseAddress;
    ULONGLONG AllocationBase;
    DWORD     AllocationProtect;
    DWORD     __alignment1;
    ULONGLONG RegionSize;
    DWORD     State;
    DWORD     Protect;
    DWORD     Type;
    DWORD     __alignment2;
} MEMORY_BASIC_INFORMATION64, *PMEMORY_BASIC_INFORMATION64;

//
// Define flags for setting process CFG valid call target entries.
//

//
// Call target should be made valid.  If not set, the call target is made
// invalid.  Input flag.
//



//
// Call target has been successfully processed.  Used to report to the caller
// how much progress has been made.  Output flag.
//



//
// Call target should be made valid only if it is suppressed export.
// What this flag means is that it can *only* be used on a cell which is
// currently in the CFG export suppressed state (only considered for export
// suppressed processes and not legacy CFG processes!), and it is also
// allowed to be used even if the process is a restricted (i.e. no ACG) process.
//



typedef struct _CFG_CALL_TARGET_INFO {
    ULONG_PTR Offset;
    ULONG_PTR Flags;
} CFG_CALL_TARGET_INFO, *PCFG_CALL_TARGET_INFO;














//
// Session Specific Access Rights.
//








// end_access












































// begin_wdm

typedef struct _MEM_ADDRESS_REQUIREMENTS {
    PVOID LowestStartingAddress;
    PVOID HighestEndingAddress;
    SIZE_T Alignment;
} MEM_ADDRESS_REQUIREMENTS, *PMEM_ADDRESS_REQUIREMENTS;







//
// Use the high DWORD64 bit of the MEM_EXTENDED_PARAMETER to indicate
// that the supplied NUMA node in the low bits is mandatory.  Note this
// is different from the MEM_EXTENDED_PARAMETER_XXX fields above because
// those are encoded in the Type field; this is encoded in the ULong64 field.
//
// This can only be used nonpaged allocations since we don't want page
// faults to fail due to transient memory shortages on arbitrary nodes.
//



typedef enum MEM_EXTENDED_PARAMETER_TYPE {
    MemExtendedParameterInvalidType = 0,
    MemExtendedParameterAddressRequirements,
    MemExtendedParameterNumaNode,
    MemExtendedParameterPartitionHandle,
    MemExtendedParameterUserPhysicalHandle,
    MemExtendedParameterAttributeFlags,
    MemExtendedParameterMax
} MEM_EXTENDED_PARAMETER_TYPE, *PMEM_EXTENDED_PARAMETER_TYPE;



typedef struct __declspec(align(8)) MEM_EXTENDED_PARAMETER {

    struct {
        DWORD64 Type : 8 ;
        DWORD64 Reserved : 64 - 8 ;
    }  ;

    union {
        DWORD64 ULong64;
        PVOID Pointer;
        SIZE_T Size;
        HANDLE Handle;
        DWORD ULong;
    }  ;

} MEM_EXTENDED_PARAMETER, *PMEM_EXTENDED_PARAMETER;












// begin_wdm

typedef enum MEM_SECTION_EXTENDED_PARAMETER_TYPE {
    MemSectionExtendedParameterInvalidType = 0,
    MemSectionExtendedParameterUserPhysicalFlags,
    MemSectionExtendedParameterNumaNode,
    MemSectionExtendedParameterMax
} MEM_SECTION_EXTENDED_PARAMETER_TYPE, *PMEM_SECTION_EXTENDED_PARAMETER_TYPE;









typedef struct _ENCLAVE_CREATE_INFO_SGX {
    BYTE  Secs[4096];
} ENCLAVE_CREATE_INFO_SGX, *PENCLAVE_CREATE_INFO_SGX;

typedef struct _ENCLAVE_INIT_INFO_SGX {
    BYTE  SigStruct[1808];
    BYTE  Reserved1[240];
    BYTE  EInitToken[304];
    BYTE  Reserved2[1744];
} ENCLAVE_INIT_INFO_SGX, *PENCLAVE_INIT_INFO_SGX;



typedef struct _ENCLAVE_CREATE_INFO_VBS {
    DWORD Flags;
    BYTE  OwnerID[32];
} ENCLAVE_CREATE_INFO_VBS, *PENCLAVE_CREATE_INFO_VBS;





typedef struct _ENCLAVE_CREATE_INFO_VBS_BASIC {
    DWORD Flags;
    BYTE  OwnerID[32];
} ENCLAVE_CREATE_INFO_VBS_BASIC, *PENCLAVE_CREATE_INFO_VBS_BASIC;

typedef struct _ENCLAVE_LOAD_DATA_VBS_BASIC {
    DWORD PageType;
} ENCLAVE_LOAD_DATA_VBS_BASIC, *PENCLAVE_LOAD_DATA_VBS_BASIC;







typedef struct _ENCLAVE_INIT_INFO_VBS_BASIC {
    BYTE  FamilyId[16 ];
    BYTE  ImageId[16 ];
    ULONGLONG EnclaveSize;
    DWORD EnclaveSvn;
    DWORD Reserved;
    union {
        HANDLE SignatureInfoHandle;
        ULONGLONG Unused;
    }  ;
} ENCLAVE_INIT_INFO_VBS_BASIC, *PENCLAVE_INIT_INFO_VBS_BASIC;


typedef struct _ENCLAVE_INIT_INFO_VBS {
    DWORD Length;
    DWORD ThreadCount;
} ENCLAVE_INIT_INFO_VBS, *PENCLAVE_INIT_INFO_VBS;



typedef PVOID (ENCLAVE_TARGET_FUNCTION)(PVOID);
typedef ENCLAVE_TARGET_FUNCTION (*PENCLAVE_TARGET_FUNCTION);
typedef PENCLAVE_TARGET_FUNCTION LPENCLAVE_TARGET_FUNCTION;

#line 13029 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winnt.h"

// begin_access

//
// Define access rights to files and directories
//

//
// The FILE_READ_DATA and FILE_WRITE_DATA constants are also defined in
// devioctl.h as FILE_READ_ACCESS and FILE_WRITE_ACCESS. The values for these
// constants *MUST* always be in sync.
// The values are redefined in devioctl.h because they must be available to
// both DOS and NT.
//















































// end_access














































































typedef struct _FILE_ID_128 {                               
    BYTE  Identifier[16];                                   
} FILE_ID_128, *PFILE_ID_128;                               

//
// Define the file notification information structure
//

typedef struct _FILE_NOTIFY_INFORMATION {
    DWORD NextEntryOffset;
    DWORD Action;
    DWORD FileNameLength;
    WCHAR FileName[1];
} FILE_NOTIFY_INFORMATION, *PFILE_NOTIFY_INFORMATION;


typedef struct _FILE_NOTIFY_EXTENDED_INFORMATION {
    DWORD NextEntryOffset;
    DWORD Action;
    LARGE_INTEGER CreationTime;
    LARGE_INTEGER LastModificationTime;
    LARGE_INTEGER LastChangeTime;
    LARGE_INTEGER LastAccessTime;
    LARGE_INTEGER AllocatedLength;
    LARGE_INTEGER FileSize;
    DWORD FileAttributes;
    DWORD ReparsePointTag;
    LARGE_INTEGER FileId;
    LARGE_INTEGER ParentFileId;
    DWORD FileNameLength;
    WCHAR FileName[1];
} FILE_NOTIFY_EXTENDED_INFORMATION, *PFILE_NOTIFY_EXTENDED_INFORMATION;
#line 13202 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winnt.h"


//
// Flag definitions for Flags in FILE_CASE_SENSITIVE_INFO.
//




//
// Define segment buffer structure for scatter/gather read/write.
//

typedef union _FILE_SEGMENT_ELEMENT {
    PVOID64 Buffer;
    ULONGLONG Alignment;
}FILE_SEGMENT_ELEMENT, *PFILE_SEGMENT_ELEMENT;













































#line 13265 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winnt.h"













#line 13279 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winnt.h"


//
// The reparse GUID structure is used by all 3rd party layered drivers to
// store data in a reparse point. For non-Microsoft tags, The GUID field
// cannot be GUID_NULL.
// The constraints on reparse tags are defined below.
// Microsoft tags can also be used with this format of the reparse point buffer.
//

typedef struct _REPARSE_GUID_DATA_BUFFER {
    DWORD  ReparseTag;
    WORD   ReparseDataLength;
    WORD   Reserved;
    GUID   ReparseGuid;
    struct {
        BYTE   DataBuffer[1];
    } GenericReparseBuffer;
} REPARSE_GUID_DATA_BUFFER, *PREPARSE_GUID_DATA_BUFFER;



//
// Maximum allowed size of the reparse data.
//



//
// Predefined reparse tags.
// These tags need to avoid conflicting with IO_REMOUNT defined in ntos\inc\io.h
//





//
// The value of the following constant needs to satisfy the following conditions:
//  (1) Be at least as large as the largest of the reserved tags.
//  (2) Be strictly smaller than all the tags in use.
//



//
// The reparse tags are a DWORD. The 32 bits are laid out as follows:
//
//   3 3 2 2 2 2 2 2 2 2 2 2 1 1 1 1 1 1 1 1 1 1
//   1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0
//  +-+-+-+-+-----------------------+-------------------------------+
//  |M|R|N|D|     Reserved bits     |       Reparse Tag Value       |
//  +-+-+-+-+-----------------------+-------------------------------+
//
// M is the Microsoft bit. When set to 1, it denotes a tag owned by Microsoft.
//   All ISVs must use a tag with a 0 in this position.
//   Note: If a Microsoft tag is used by non-Microsoft software, the
//   behavior is not defined.
//
// R is reserved.  Must be zero for non-Microsoft tags.
//
// N is name surrogate. When set to 1, the file represents another named
//   entity in the system.
//
// D is the directory bit. When set to 1, indicates that any directory
//   with this reparse tag can have children. Has no special meaning when used
//   on a non-directory file. Not compatible with the name surrogate bit.
//
// The M and N bits are OR-able.
// The following macros check for the M and N bit values:
//

//
// Macro to determine whether a reparse point tag corresponds to a tag
// owned by Microsoft.
//





//
// Macro to determine whether a reparse point tag is a name surrogate
//





//
// Macro to determine whether a directory with this reparse point can have
// children.
//









































































































































































































































































































#line 13670 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winnt.h"














































































#line 13749 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winnt.h"



//
//=============== FSCTL_REARRANGE_FILE ====================
//

//
//  Input structure for FSCTL_REARRANGE_FILE
//

typedef struct _REARRANGE_FILE_DATA {

    //
    // Cluster-aligned byte offset of the base of the contiguous source region
    // in the source file to move to the target location of the target file.
    //
    ULONGLONG SourceStartingOffset;

    //
    // Cluster-aligned byte offset of the point to insert the source region.
    //
    ULONGLONG TargetOffset;

    //
    // Alternate file to move the source region clusters from;
    // if NULL, the source region is from the same file.
    //
    HANDLE SourceFileHandle;

    //
    // Cluster-aligned length (in bytes) of the source region.
    //
    DWORD Length;

    //
    // Flags - reserved for future definition and must be zero.
    //
    DWORD Flags;

} REARRANGE_FILE_DATA, *PREARRANGE_FILE_DATA;


//
//  32/64 Bit thunking support structure
//

typedef struct _REARRANGE_FILE_DATA32 {

    ULONGLONG SourceStartingOffset;
    ULONGLONG TargetOffset;
    UINT32 SourceFileHandle;
    DWORD Length;
    DWORD Flags;

} REARRANGE_FILE_DATA32, *PREARRANGE_FILE_DATA32;
#line 13806 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winnt.h"

#line 13808 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winnt.h"




















#line 13829 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winnt.h"

// begin_access

//
// I/O Completion Specific Access Rights.
//







//
// Some applications include both ntioapi_x.h and winioctl.h
//



#line 13849 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winnt.h"








































#line 13890 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winnt.h"

#line 13892 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winnt.h"

// begin_access

//
// Object Manager Symbolic Link Specific Access Rights.
//




//
// =========================================
// Define GUIDs which represent well-known power schemes
// =========================================
//

//
// Maximum Power Savings - indicates that very aggressive power savings measures will be used to help
//                         stretch battery life.
//
// {a1841308-3541-4fab-bc81-f71556f20b4a}
//
extern "C" const GUID GUID_MAX_POWER_SAVINGS ;

//
// No Power Savings - indicates that almost no power savings measures will be used.
//
// {8c5e7fda-e8bf-4a96-9a85-a6e23a8c635c}
//
extern "C" const GUID GUID_MIN_POWER_SAVINGS ;

//
// Typical Power Savings - indicates that fairly aggressive power savings measures will be used.
//
// {381b4222-f694-41f0-9685-ff5bb260df2e}
//
extern "C" const GUID GUID_TYPICAL_POWER_SAVINGS ;

//
// This is a special GUID that represents "no subgroup" of settings.  That is, it indicates
// that settings that are in the root of the power policy hierarchy as opposed to settings
// that are buried under a subgroup of settings.  This should be used when querying for
// power settings that may not fall into a subgroup.
//
extern "C" const GUID NO_SUBGROUP_GUID ;

//
// This is a special GUID that represents "every power scheme".  That is, it indicates
// that any write to this power scheme should be reflected to every scheme present.
// This allows users to write a single setting once and have it apply to all schemes.  They
// can then apply custom settings to specific power schemes that they care about.
//
extern "C" const GUID ALL_POWERSCHEMES_GUID ;

//
// This is a special GUID that represents a 'personality' that each power scheme will have.
// In other words, each power scheme will have this key indicating "I'm most like *this* base
// power scheme."  This individual setting will have one of three settings:
// GUID_MAX_POWER_SAVINGS
// GUID_MIN_POWER_SAVINGS
// GUID_TYPICAL_POWER_SAVINGS
//
// This allows several features:
// 1. Drivers and applications can register for notification of this GUID.  So when this power
//    scheme is activiated, this GUID's setting will be sent across the system and drivers/applications
//    can see "GUID_MAX_POWER_SAVINGS" which will tell them in a generic fashion "get real aggressive
//    about conserving power".
// 2. UserB may install a driver or application which creates power settings, and UserB may modify
//    those power settings.  Now UserA logs in.  How does he see those settings?  They simply don't
//    exist in his private power key.  Well they do exist over in the system power key.  When we
//    enumerate all the power settings in this system power key and don't find a corresponding entry
//    in the user's private power key, then we can go look at this "personality" key in the users
//    power scheme.  We can then go get a default value for the power setting, depending on which
//    "personality" power scheme is being operated on.  Here's an example:
//    A. UserB installs an application that creates a power setting Seetting1
//    B. UserB changes Setting1 to have a value of 50 because that's one of the possible settings
//       available for setting1.
//    C. UserB logs out
//    D. UserA logs in and his active power scheme is some custom scheme that was derived from
//       the GUID_TYPICAL_POWER_SAVINGS.  But remember that UserA has no setting1 in his
//       private power key.
//    E. When activating UserA's selected power scheme, all power settings in the system power key will
//       be enumerated (including Setting1).
//    F. The power manager will see that UserA has no Setting1 power setting in his private power scheme.
//    G. The power manager will query UserA's power scheme for its personality and retrieve
//       GUID_TYPICAL_POWER_SAVINGS.
//    H. The power manager then looks in Setting1 in the system power key and looks in its set of default
//       values for the corresponding value for GUID_TYPICAL_POWER_SAVINGS power schemes.
//    I. This derived power setting is applied.
extern "C" const GUID GUID_POWERSCHEME_PERSONALITY ;

//
// Define a special GUID which will be used to define the active power scheme.
// User will register for this power setting GUID, and when the active power
// scheme changes, they'll get a callback where the payload is the GUID
// representing the active powerscheme.
// ( 31F9F286-5084-42FE-B720-2B0264993763 }
//
extern "C" const GUID GUID_ACTIVE_POWERSCHEME ;

//
// =========================================
// Define GUIDs which represent well-known power settings
// =========================================
//

// Idle resiliency settings
// -------------------------
//
// Specifies the subgroup which will contain all of the idle resiliency
// settings for a single policy.
//
// {2E601130-5351-4d9d-8E04-252966BAD054}
extern "C" const GUID GUID_IDLE_RESILIENCY_SUBGROUP ;

//
// Specifies the maximum clock interrupt period (in ms)
//
// N.B. This power setting is DEPRECATED.
//
// {C42B79AA-AA3A-484b-A98F-2CF32AA90A28}
extern "C" const GUID GUID_IDLE_RESILIENCY_PERIOD ;

//
// Specifies the deep sleep policy setting.
// This is intended to override the GUID_IDLE_RESILIENCY_PERIOD
// {d502f7ee-1dc7-4efd-a55d-f04b6f5c0545}
extern "C" const GUID GUID_DEEP_SLEEP_ENABLED ;

//
// Specifies the platform idle state index associated with idle resiliency
// period.
//
// N.B. This power setting is DEPRECATED.
//
// {D23F2FB8-9536-4038-9C94-1CE02E5C2152}
extern "C" const GUID GUID_DEEP_SLEEP_PLATFORM_STATE ;

//
// Specifies (in milliseconds) how long we wait after the last disk access
// before we power off the disk in case when IO coalescing is active.
//
// {C36F0EB4-2988-4a70-8EEE-0884FC2C2433}
extern "C" const GUID GUID_DISK_COALESCING_POWERDOWN_TIMEOUT ;

//
// Specifies (in seconds) how long we wait after the CS Enter before
// we deactivate execution required request.
//
//   0 : implies execution power requests are disabled and have no effect
//  -1 : implies execution power requests are never deactivated
//
// Note: Execution required power requests are mapped into system required
//      power requests on non-AoAc machines and this value has no effect.
//
// {3166BC41-7E98-4e03-B34E-EC0F5F2B218E}
extern "C" const GUID GUID_EXECUTION_REQUIRED_REQUEST_TIMEOUT ;


// Video settings
// --------------
//
// Specifies the subgroup which will contain all of the video
// settings for a single policy.
//
// {7516b95f-f776-4464-8c53-06167f40cc99}
//
extern "C" const GUID GUID_VIDEO_SUBGROUP ;

//
// Specifies (in seconds) how long we wait after the last user input has been
// received before we power off the video.
//
// {3c0bc021-c8a8-4e07-a973-6b14cbcb2b7e}
//
extern "C" const GUID GUID_VIDEO_POWERDOWN_TIMEOUT ;

//
// Specifies whether adaptive display dimming is turned on or off.
//
// N.B. This setting is DEPRECATED in Windows 8.1
//
// {82DBCF2D-CD67-40C5-BFDC-9F1A5CCD4663}
//
extern "C" const GUID GUID_VIDEO_ANNOYANCE_TIMEOUT ;

//
// Specifies how much adaptive dim time out will be increased by.
//
// N.B. This setting is DEPRECATED in Windows 8.1
//
// {EED904DF-B142-4183-B10B-5A1197A37864}
//
extern "C" const GUID GUID_VIDEO_ADAPTIVE_PERCENT_INCREASE ;

//
// Specifies (in seconds) how long we wait after the last user input has been
// received before we dim the video.
//
// {17aaa29b-8b43-4b94-aafe-35f64daaf1ee}
//
extern "C" const GUID GUID_VIDEO_DIM_TIMEOUT ;

//
// Specifies if the operating system should use adaptive timers (based on
// previous behavior) to power down the video.
//
// {90959d22-d6a1-49b9-af93-bce885ad335b}
//
extern "C" const GUID GUID_VIDEO_ADAPTIVE_POWERDOWN ;

//
// Specifies if the monitor is currently being powered or not.
//
// {02731015-4510-4526-99E6-E5A17EBD1AEA}
//
extern "C" const GUID GUID_MONITOR_POWER_ON ;

//
// Monitor brightness policy when in normal state.
//
// {aded5e82-b909-4619-9949-f5d71dac0bcb}
//
extern "C" const GUID GUID_DEVICE_POWER_POLICY_VIDEO_BRIGHTNESS ;

//
// Monitor brightness policy when in dim state.
//
// {f1fbfde2-a960-4165-9f88-50667911ce96}
//
extern "C" const GUID GUID_DEVICE_POWER_POLICY_VIDEO_DIM_BRIGHTNESS ;

//
// Current monitor brightness.
//
// {8ffee2c6-2d01-46be-adb9-398addc5b4ff}
//
extern "C" const GUID GUID_VIDEO_CURRENT_MONITOR_BRIGHTNESS ;

//
// Specifies if the operating system should use ambient light sensor to change
// adaptively the display's brightness.
//
// {FBD9AA66-9553-4097-BA44-ED6E9D65EAB8}
//
extern "C" const GUID GUID_VIDEO_ADAPTIVE_DISPLAY_BRIGHTNESS ;

//
// Specifies a change in the current monitor's display state.
//
// {6fe69556-704a-47a0-8f24-c28d936fda47}
//
extern "C" const GUID GUID_CONSOLE_DISPLAY_STATE ;

//
// Defines a guid for enabling/disabling the ability to create display required
// power requests.
//
// {A9CEB8DA-CD46-44FB-A98B-02AF69DE4623}
//
extern "C" const GUID GUID_ALLOW_DISPLAY_REQUIRED ;

//
// Specifies the video power down timeout (in seconds) after the interactive
// console is locked (and sensors indicate UserNotPresent). Value 0
// effectively disables this feature.
//
// {8EC4B3A5-6868-48c2-BE75-4F3044BE88A7}
//
extern "C" const GUID GUID_VIDEO_CONSOLE_LOCK_TIMEOUT ;

//
// Specifies power settings which will decide whether to
// prefer visual quality or battery life for an Advanced
// Color capable display
//
// {684C3E69-A4F7-4014-8754-D45179A56167}
//
extern "C" const GUID GUID_ADVANCED_COLOR_QUALITY_BIAS ;


// Adaptive power behavior settings
// --------------------------------
//
// {8619B916-E004-4dd8-9B66-DAE86F806698}
extern "C" const GUID GUID_ADAPTIVE_POWER_BEHAVIOR_SUBGROUP ;

//
// Specifies the input timeout (in seconds) to be used to indicate UserUnkown.
// Value 0 effectively disables this feature.
//
// {5ADBBFBC-074E-4da1-BA38-DB8B36B2C8F3}
extern "C" const GUID GUID_NON_ADAPTIVE_INPUT_TIMEOUT ;

//
// Specifies a change in the input controller(s) global system's state:
// e.g. enabled, suppressed, filtered.
//
// {0E98FAE9-F45A-4DE1-A757-6031F197F6EA}
extern "C" const GUID GUID_ADAPTIVE_INPUT_CONTROLLER_STATE ;

// Harddisk settings
// -----------------
//
// Specifies the subgroup which will contain all of the harddisk
// settings for a single policy.
//
extern "C" const GUID GUID_DISK_SUBGROUP ;

//
// Specifies a maximum power consumption level.
//
extern "C" const GUID GUID_DISK_MAX_POWER ;

//
// Specifies (in seconds) how long we wait after the last disk access
// before we power off the disk.
//
extern "C" const GUID GUID_DISK_POWERDOWN_TIMEOUT ;

//
// Specifies (in milliseconds) how long we wait after the last disk access
// before we power off the disk taking into account if IO coalescing is active.
//
// {58E39BA8-B8E6-4EF6-90D0-89AE32B258D6}
extern "C" const GUID GUID_DISK_IDLE_TIMEOUT ;

//
// Specifies the amount of contiguous disk activity time to ignore when
// calculating disk idleness.
//
// 80e3c60e-bb94-4ad8-bbe0-0d3195efc663
//

extern "C" const GUID GUID_DISK_BURST_IGNORE_THRESHOLD ;

//
// Specifies if the operating system should use adaptive timers (based on
// previous behavior) to power down the disk,
//
extern "C" const GUID GUID_DISK_ADAPTIVE_POWERDOWN ;

// System sleep settings
// ---------------------
//
// Specifies the subgroup which will contain all of the sleep
// settings for a single policy.
// { 238C9FA8-0AAD-41ED-83F4-97BE242C8F20 }
//
extern "C" const GUID GUID_SLEEP_SUBGROUP ;

//
// Specifies an idle treshold percentage (0-100). The system must be this idle
// over a period of time in order to idle to sleep.
//
// N.B. DEPRECATED IN WINDOWS 6.1
//
extern "C" const GUID GUID_SLEEP_IDLE_THRESHOLD ;

//
// Specifies (in seconds) how long we wait after the system is deemed
// "idle" before moving to standby (S1, S2 or S3).
//
extern "C" const GUID GUID_STANDBY_TIMEOUT ;

//
// Specifies (in seconds) how long the system should go back to sleep after
// waking unattended. 0 indicates that the standard standby/hibernate idle
// policy should be used instead.
//
// {7bc4a2f9-d8fc-4469-b07b-33eb785aaca0}
//
extern "C" const GUID GUID_UNATTEND_SLEEP_TIMEOUT ;

//
// Specifies (in seconds) how long we wait after the system is deemed
// "idle" before moving to hibernate (S4).
//
extern "C" const GUID GUID_HIBERNATE_TIMEOUT ;

//
// Specifies whether or not Fast S4 should be enabled if the system supports it
// 94AC6D29-73CE-41A6-809F-6363BA21B47E
//
extern "C" const GUID GUID_HIBERNATE_FASTS4_POLICY ;

//
// Define a GUID for controlling the criticality of sleep state transitions.
// Critical sleep transitions do not query applications, services or drivers
// before transitioning the platform to a sleep state.
//
// {B7A27025-E569-46c2-A504-2B96CAD225A1}
//
extern "C" const GUID GUID_CRITICAL_POWER_TRANSITION ;

//
// Specifies if the system is entering or exiting 'away mode'.
// 98A7F580-01F7-48AA-9C0F-44352C29E5C0
//
extern "C" const GUID GUID_SYSTEM_AWAYMODE ;

//
// Specify whether away mode is allowed
//
// {25DFA149-5DD1-4736-B5AB-E8A37B5B8187}
//
extern "C" const GUID GUID_ALLOW_AWAYMODE ;

//
// Defines a guid to control User Presence Prediction mode.
//
// {82011705-FB95-4D46-8D35-4042B1D20DEF}
//
extern "C" const GUID GUID_USER_PRESENCE_PREDICTION ;

//
// Defines a guid to control Standby Budget Grace Period.
//
// {60C07FE1-0556-45CF-9903-D56E32210242}
//
extern "C" const GUID GUID_STANDBY_BUDGET_GRACE_PERIOD ;

//
// Defines a guid to control Standby Budget Percent.
//
// {9FE527BE-1B70-48DA-930D-7BCF17B44990}
//
extern "C" const GUID GUID_STANDBY_BUDGET_PERCENT ;

//
// Defines a guid to control Standby Reserve Grace Period.
//
// {C763EE92-71E8-4127-84EB-F6ED043A3E3D}
//
extern "C" const GUID GUID_STANDBY_RESERVE_GRACE_PERIOD ;

//
// Defines a guid to control Standby Reserve Time.
//
// {468FE7E5-1158-46EC-88BC-5B96C9E44FD0}
//
extern "C" const GUID GUID_STANDBY_RESERVE_TIME ;

//
// Defines a guid to control Standby Reset Percentage.
//
// {49CB11A5-56E2-4AFB-9D38-3DF47872E21B}
//
extern "C" const GUID GUID_STANDBY_RESET_PERCENT ;

//
// Defines a guid for enabling/disabling standby (S1-S3) states. This does not
// affect hibernation (S4).
//
// {abfc2519-3608-4c2a-94ea-171b0ed546ab}
//
extern "C" const GUID GUID_ALLOW_STANDBY_STATES ;

//
// Defines a guid for enabling/disabling the ability to wake via RTC.
//
// {BD3B718A-0680-4D9D-8AB2-E1D2B4AC806D}
//
extern "C" const GUID GUID_ALLOW_RTC_WAKE ;

//
// Defines a guid for enabling/disabling legacy RTC mitigations.
//
// {1A34BDC3-7E6B-442E-A9D0-64B6EF378E84}
//
extern "C" const GUID GUID_LEGACY_RTC_MITIGATION ;

//
// Defines a guid for enabling/disabling the ability to create system required
// power requests.
//
// {A4B195F5-8225-47D8-8012-9D41369786E2}
//
extern "C" const GUID GUID_ALLOW_SYSTEM_REQUIRED ;

// Energy Saver settings
// ---------------------
//
// Indicates if Enegry Saver is ON or OFF.
//
// {E00958C0-C213-4ACE-AC77-FECCED2EEEA5}
//
extern "C" const GUID GUID_POWER_SAVING_STATUS ;

//
// Specifies the subgroup which will contain all of the Energy Saver settings
// for a single policy.
//
// {DE830923-A562-41AF-A086-E3A2C6BAD2DA}
//
extern "C" const GUID GUID_ENERGY_SAVER_SUBGROUP ;

//
// Defines a guid to engage Energy Saver at specific battery charge level
//
// {E69653CA-CF7F-4F05-AA73-CB833FA90AD4}
//
extern "C" const GUID GUID_ENERGY_SAVER_BATTERY_THRESHOLD ;

//
// Defines a guid to specify display brightness weight when Energy Saver is engaged
//
// {13D09884-F74E-474A-A852-B6BDE8AD03A8}
//
extern "C" const GUID GUID_ENERGY_SAVER_BRIGHTNESS ;

//
// Defines a guid to specify the Energy Saver policy
//
// {5C5BB349-AD29-4ee2-9D0B-2B25270F7A81}
//
extern "C" const GUID GUID_ENERGY_SAVER_POLICY ;

// System button actions
// ---------------------
//
//
// Specifies the subgroup which will contain all of the system button
// settings for a single policy.
//
extern "C" const GUID GUID_SYSTEM_BUTTON_SUBGROUP ;







//
// System button values which contain the PowerAction* value for each action.
//







// Specifies (in a POWER_ACTION_POLICY structure) the appropriate action to
// take when the system power button is pressed.
//
extern "C" const GUID GUID_POWERBUTTON_ACTION ;

//
// Specifies (in a POWER_ACTION_POLICY structure) the appropriate action to
// take when the system sleep button is pressed.
//
extern "C" const GUID GUID_SLEEPBUTTON_ACTION ;

//
// Specifies (in a POWER_ACTION_POLICY structure) the appropriate action to
// take when the system sleep button is pressed.
// { A7066653-8D6C-40A8-910E-A1F54B84C7E5 }
//
extern "C" const GUID GUID_USERINTERFACEBUTTON_ACTION ;

//
// Specifies (in a POWER_ACTION_POLICY structure) the appropriate action to
// take when the system lid is closed.
//
extern "C" const GUID GUID_LIDCLOSE_ACTION ;
extern "C" const GUID GUID_LIDOPEN_POWERSTATE ;


// Battery Discharge Settings
// --------------------------
//
// Specifies the subgroup which will contain all of the battery discharge
// settings for a single policy.
//
extern "C" const GUID GUID_BATTERY_SUBGROUP ;

//
// 4 battery discharge alarm settings.
//
// GUID_BATTERY_DISCHARGE_ACTION_x - This is the action to take.  It is a value
//                                   of type POWER_ACTION
// GUID_BATTERY_DISCHARGE_LEVEL_x  - This is the battery level (%)
// GUID_BATTERY_DISCHARGE_FLAGS_x  - Flags defined below:
//                                   POWER_ACTION_POLICY->EventCode flags
//                                   BATTERY_DISCHARGE_FLAGS_EVENTCODE_MASK
//                                   BATTERY_DISCHARGE_FLAGS_ENABLE
extern "C" const GUID GUID_BATTERY_DISCHARGE_ACTION_0 ;
extern "C" const GUID GUID_BATTERY_DISCHARGE_LEVEL_0 ;
extern "C" const GUID GUID_BATTERY_DISCHARGE_FLAGS_0 ;

extern "C" const GUID GUID_BATTERY_DISCHARGE_ACTION_1 ;
extern "C" const GUID GUID_BATTERY_DISCHARGE_LEVEL_1 ;
extern "C" const GUID GUID_BATTERY_DISCHARGE_FLAGS_1 ;

extern "C" const GUID GUID_BATTERY_DISCHARGE_ACTION_2 ;
extern "C" const GUID GUID_BATTERY_DISCHARGE_LEVEL_2 ;
extern "C" const GUID GUID_BATTERY_DISCHARGE_FLAGS_2 ;

extern "C" const GUID GUID_BATTERY_DISCHARGE_ACTION_3 ;
extern "C" const GUID GUID_BATTERY_DISCHARGE_LEVEL_3 ;
extern "C" const GUID GUID_BATTERY_DISCHARGE_FLAGS_3 ;

// Processor power settings
// ------------------------
//

// Specifies the subgroup which will contain all of the processor
// settings for a single policy.
//
// {54533251-82be-4824-96c1-47b60b740d00}
//
extern "C" const GUID GUID_PROCESSOR_SETTINGS_SUBGROUP ;

//
// Specifies various attributes that control processor performance/throttle
// states.
//
extern "C" const GUID GUID_PROCESSOR_THROTTLE_POLICY ;









//
// Specifies a percentage (between 0 and 100) that the processor frequency
// should never go above.  For example, if this value is set to 80, then
// the processor frequency will never be throttled above 80 percent of its
// maximum frequency by the system.
//
// {bc5038f7-23e0-4960-96da-33abaf5935ec}
//
extern "C" const GUID GUID_PROCESSOR_THROTTLE_MAXIMUM ;

//
// Specifies a percentage (between 0 and 100) that the processor frequency
// should never go above for Processor Power Efficiency Class 1.
// For example, if this value is set to 80, then the processor frequency will
// never be throttled above 80 percent of its maximum frequency by the system.
//
// {bc5038f7-23e0-4960-96da-33abaf5935ed}
//
extern "C" const GUID GUID_PROCESSOR_THROTTLE_MAXIMUM_1 ;

//
// Specifies a percentage (between 0 and 100) that the processor frequency
// should not drop below.  For example, if this value is set to 50, then the
// processor frequency will never be throttled below 50 percent of its
// maximum frequency by the system.
//
// {893dee8e-2bef-41e0-89c6-b55d0929964c}
//
extern "C" const GUID GUID_PROCESSOR_THROTTLE_MINIMUM ;

//
// Specifies a percentage (between 0 and 100) that the processor frequency
// should not drop below for Processor Power Efficiency Class 1.
// For example, if this value is set to 50, then the processor frequency will
// never be throttled below 50 percent of its maximum frequency by the system.
//
// {893dee8e-2bef-41e0-89c6-b55d0929964d}
//
extern "C" const GUID GUID_PROCESSOR_THROTTLE_MINIMUM_1 ;

//
// Specifies the maximum processor frequency (expresssed in MHz).
//

// {75B0AE3F-BCE0-45a7-8C89-C9611C25E100}
extern "C" const GUID GUID_PROCESSOR_FREQUENCY_LIMIT
;

// {75B0AE3F-BCE0-45a7-8C89-C9611C25E101}
extern "C" const GUID GUID_PROCESSOR_FREQUENCY_LIMIT_1
;

//
// Specifies whether throttle states are allowed to be used even when
// performance states are available.
//
// {3b04d4fd-1cc7-4f23-ab1c-d1337819c4bb}
//
extern "C" const GUID GUID_PROCESSOR_ALLOW_THROTTLING ;





//
// Specifies processor power settings for CState policy data
// {68F262A7-F621-4069-B9A5-4874169BE23C}
//
extern "C" const GUID GUID_PROCESSOR_IDLESTATE_POLICY ;

//
// Specifies processor power settings for PerfState policy data
// {BBDC3814-18E9-4463-8A55-D197327C45C0}
//
extern "C" const GUID GUID_PROCESSOR_PERFSTATE_POLICY ;

//
// Specifies the increase busy percentage threshold that must be met before
// increasing the processor performance state.
//
// {06cadf0e-64ed-448a-8927-ce7bf90eb35d}
//
extern "C" const GUID GUID_PROCESSOR_PERF_INCREASE_THRESHOLD ;

//
// Specifies the increase busy percentage threshold that must be met before
// increasing the processor performance state for Processor Power Efficiency
// Class 1.
//
// {06cadf0e-64ed-448a-8927-ce7bf90eb35e}
//
extern "C" const GUID GUID_PROCESSOR_PERF_INCREASE_THRESHOLD_1 ;

//
// Specifies the decrease busy percentage threshold that must be met before
// decreasing the processor performance state.
//
// {12a0ab44-fe28-4fa9-b3bd-4b64f44960a6}
//
extern "C" const GUID GUID_PROCESSOR_PERF_DECREASE_THRESHOLD ;

//
// Specifies the decrease busy percentage threshold that must be met before
// decreasing the processor performance state for Processor Power Efficiency
// Class 1.
//
// {12a0ab44-fe28-4fa9-b3bd-4b64f44960a7}
//
extern "C" const GUID GUID_PROCESSOR_PERF_DECREASE_THRESHOLD_1 ;

//
// Specifies, either as ideal, single or rocket, how aggressive performance
// states should be selected when increasing the processor performance state.
//
// {465E1F50-B610-473a-AB58-00D1077DC418}
//
extern "C" const GUID GUID_PROCESSOR_PERF_INCREASE_POLICY ;

//
// Specifies, either as ideal, single or rocket, how aggressive performance
// states should be selected when increasing the processor performance state
// for Processor Power Efficiency Class 1.
//
// {465E1F50-B610-473a-AB58-00D1077DC419}
//
extern "C" const GUID GUID_PROCESSOR_PERF_INCREASE_POLICY_1 ;

//
// Specifies, either as ideal, single or rocket, how aggressive performance
// states should be selected when decreasing the processor performance state.
//
// {40FBEFC7-2E9D-4d25-A185-0CFD8574BAC6}
//
extern "C" const GUID GUID_PROCESSOR_PERF_DECREASE_POLICY ;

//
// Specifies, either as ideal, single or rocket, how aggressive performance
// states should be selected when decreasing the processor performance state for
// Processor Power Efficiency Class 1.
//
// {40FBEFC7-2E9D-4d25-A185-0CFD8574BAC7}
//
extern "C" const GUID GUID_PROCESSOR_PERF_DECREASE_POLICY_1 ;

//
// Specifies, in milliseconds, the minimum amount of time that must elapse after
// the last processor performance state change before increasing the processor
// performance state.
//
// {984CF492-3BED-4488-A8F9-4286C97BF5AA}
//
extern "C" const GUID GUID_PROCESSOR_PERF_INCREASE_TIME ;

//
// Specifies, in milliseconds, the minimum amount of time that must elapse after
// the last processor performance state change before increasing the processor
// performance state for Processor Power Efficiency Class 1.
//
// {984CF492-3BED-4488-A8F9-4286C97BF5AB}
//
extern "C" const GUID GUID_PROCESSOR_PERF_INCREASE_TIME_1 ;

//
// Specifies, in milliseconds, the minimum amount of time that must elapse after
// the last processor performance state change before increasing the processor
// performance state.
//
// {D8EDEB9B-95CF-4f95-A73C-B061973693C8}
//
extern "C" const GUID GUID_PROCESSOR_PERF_DECREASE_TIME ;

//
// Specifies, in milliseconds, the minimum amount of time that must elapse after
// the last processor performance state change before increasing the processor
// performance state for Processor Power Efficiency Class 1.
//
// {D8EDEB9B-95CF-4f95-A73C-B061973693C9}
//
extern "C" const GUID GUID_PROCESSOR_PERF_DECREASE_TIME_1 ;

//
// Specifies the time, in milliseconds, that must expire before considering
// a change in the processor performance states or parked core set.
//
// {4D2B0152-7D5C-498b-88E2-34345392A2C5}
//
extern "C" const GUID GUID_PROCESSOR_PERF_TIME_CHECK ;

//
// Specifies how the processor should manage performance and efficiency
// tradeoffs when boosting frequency above the maximum.
//
// {45BCC044-D885-43e2-8605-EE0EC6E96B59}
//
extern "C" const GUID GUID_PROCESSOR_PERF_BOOST_POLICY
;




//
// Specifies how a processor opportunistically increases frequency above
// the maximum when operating contitions allow it to do so safely.
//
// {BE337238-0D82-4146-A960-4F3749D470C7}
//
extern "C" const GUID GUID_PROCESSOR_PERF_BOOST_MODE
;










//
// Specifies whether or not a procesor should autonomously select its
// operating performance state.
//
// {8BAA4A8A-14C6-4451-8E8B-14BDBD197537}
//
extern "C" const GUID GUID_PROCESSOR_PERF_AUTONOMOUS_MODE
;




//
// Specifies the tradeoff between performance and energy the processor should
// make when operating in autonomous mode.
//
// {36687F9E-E3A5-4dbf-B1DC-15EB381C6863}
extern "C" const GUID GUID_PROCESSOR_PERF_ENERGY_PERFORMANCE_PREFERENCE
;

//
// Specifies the tradeoff between performance and energy the processor should
// make when operating in autonomous mode for class 1 processors.
//
// {36687F9E-E3A5-4dbf-B1DC-15EB381C6864}
extern "C" const GUID GUID_PROCESSOR_PERF_ENERGY_PERFORMANCE_PREFERENCE_1
;




//
// Specifies the window over which the processor should observe utilization when
// operating in autonomous mode, in microseconds.
//
// {CFEDA3D0-7697-4566-A922-A9086CD49DFA}
extern "C" const GUID GUID_PROCESSOR_PERF_AUTONOMOUS_ACTIVITY_WINDOW
;




//
// Specifies whether the processor should perform duty cycling.
//
// {4E4450B3-6179-4e91-B8F1-5BB9938F81A1}
extern "C" const GUID GUID_PROCESSOR_DUTY_CYCLING
;




//
// Specifies if idle state promotion and demotion values should be scaled based
// on the current peformance state.
//
// {6C2993B0-8F48-481f-BCC6-00DD2742AA06}
//
extern "C" const GUID GUID_PROCESSOR_IDLE_ALLOW_SCALING ;

//
// Specifies if idle states should be disabled.
//
// {5D76A2CA-E8C0-402f-A133-2158492D58AD}
//
extern "C" const GUID GUID_PROCESSOR_IDLE_DISABLE ;

//
// Specifies the deepest idle state type that should be used. If this value is
// set to zero, this setting is ignored. Values higher than supported by the
// processor then this setting has no effect.
//
// {9943e905-9a30-4ec1-9b99-44dd3b76f7a2}
//
extern "C" const GUID GUID_PROCESSOR_IDLE_STATE_MAXIMUM ;

//
// Specifies the time that elapsed since the last idle state promotion or
// demotion before idle states may be promoted or demoted again (in
// microseconds).
//
// {C4581C31-89AB-4597-8E2B-9C9CAB440E6B}
//
extern "C" const GUID GUID_PROCESSOR_IDLE_TIME_CHECK ;


//
// Specifies the upper busy threshold that must be met before demoting the
// processor to a lighter idle state (in percentage).
//
// {4B92D758-5A24-4851-A470-815D78AEE119}
//
extern "C" const GUID GUID_PROCESSOR_IDLE_DEMOTE_THRESHOLD ;

//
// Specifies the lower busy threshold that must be met before promoting the
// processor to a deeper idle state (in percentage).
//
// {7B224883-B3CC-4d79-819F-8374152CBE7C}
//
extern "C" const GUID GUID_PROCESSOR_IDLE_PROMOTE_THRESHOLD ;

//
// Specifies the utilization threshold in percent that must be crossed in order to un-park cores.
//
// N.B. This power setting is DEPRECATED.
//
// {df142941-20f3-4edf-9a4a-9c83d3d717d1}
//
extern "C" const GUID GUID_PROCESSOR_CORE_PARKING_INCREASE_THRESHOLD ;

//
// Specifies the utilization threshold in percent that must be crossed in order to park cores.
//
// N.B. This power setting is DEPRECATED.
//
// {68dd2f27-a4ce-4e11-8487-3794e4135dfa}
//
extern "C" const GUID GUID_PROCESSOR_CORE_PARKING_DECREASE_THRESHOLD ;

//
// Specifies, either as ideal, single or rocket, how aggressive core parking is when cores must be unparked.
//
// {c7be0679-2817-4d69-9d02-519a537ed0c6}
//
extern "C" const GUID GUID_PROCESSOR_CORE_PARKING_INCREASE_POLICY ;







//
// Specifies, either as ideal, single or rocket, how aggressive core parking is when cores must be parked.
//
// {71021b41-c749-4d21-be74-a00f335d582b}
//
extern "C" const GUID GUID_PROCESSOR_CORE_PARKING_DECREASE_POLICY ;

//
// Specifies, on a per processor group basis, the maximum number of cores that can be kept unparked.
//
// {ea062031-0e34-4ff1-9b6d-eb1059334028}
//
extern "C" const GUID GUID_PROCESSOR_CORE_PARKING_MAX_CORES ;

//
// Specifies, on a per processor group basis, the maximum number of cores that
// can be kept unparked for Processor Power Efficiency Class 1.
//
// {ea062031-0e34-4ff1-9b6d-eb1059334029}
//
extern "C" const GUID GUID_PROCESSOR_CORE_PARKING_MAX_CORES_1 ;

//
// Specifies, on a per processor group basis, the minimum number of cores that must be kept unparked.
//
// {0cc5b647-c1df-4637-891a-dec35c318583}
//
extern "C" const GUID GUID_PROCESSOR_CORE_PARKING_MIN_CORES ;

//
// Specifies, on a per processor group basis, the minimum number of cores that
// must be kept unparked in Processor Power Efficiency Class 1.
//
// {0cc5b647-c1df-4637-891a-dec35c318584}
//
extern "C" const GUID GUID_PROCESSOR_CORE_PARKING_MIN_CORES_1 ;

//
// Specifies, in milliseconds, the minimum amount of time a core must be parked before it can be unparked.
//
// {2ddd5a84-5a71-437e-912a-db0b8c788732}
//
extern "C" const GUID GUID_PROCESSOR_CORE_PARKING_INCREASE_TIME ;

//
// Specifies, in milliseconds, the minimum amount of time a core must be unparked before it can be parked.
//
// {dfd10d17-d5eb-45dd-877a-9a34ddd15c82}
//
extern "C" const GUID GUID_PROCESSOR_CORE_PARKING_DECREASE_TIME ;

//
// Specifies the factor by which to decrease affinity history on each core after each check.
//
// {8f7b45e3-c393-480a-878c-f67ac3d07082}
//
extern "C" const GUID GUID_PROCESSOR_CORE_PARKING_AFFINITY_HISTORY_DECREASE_FACTOR ;

//
// Specifies the threshold above which a core is considered to have had significant affinitized work scheduled to it while parked.
//
// {5b33697b-e89d-4d38-aa46-9e7dfb7cd2f9}
//
extern "C" const GUID GUID_PROCESSOR_CORE_PARKING_AFFINITY_HISTORY_THRESHOLD ;

//
// Specifies the weighting given to each occurence where affinitized work was scheduled to a parked core.
//
// {e70867f1-fa2f-4f4e-aea1-4d8a0ba23b20}
//
extern "C" const GUID GUID_PROCESSOR_CORE_PARKING_AFFINITY_WEIGHTING ;

//
// Specifies the factor by which to decrease the over utilization history on each core after the current performance check.
//
// {1299023c-bc28-4f0a-81ec-d3295a8d815d}
//
extern "C" const GUID GUID_PROCESSOR_CORE_PARKING_OVER_UTILIZATION_HISTORY_DECREASE_FACTOR ;

//
// Specifies the threshold above which a core is considered to have been recently over utilized while parked.
//
// {9ac18e92-aa3c-4e27-b307-01ae37307129}
//
extern "C" const GUID GUID_PROCESSOR_CORE_PARKING_OVER_UTILIZATION_HISTORY_THRESHOLD ;

//
// Specifies the weighting given to each occurence where a parked core is found to be over utilized.
//
// {8809c2d8-b155-42d4-bcda-0d345651b1db}
//
extern "C" const GUID GUID_PROCESSOR_CORE_PARKING_OVER_UTILIZATION_WEIGHTING ;

//
// Specifies, in percentage, the busy threshold that must be met before a parked core is considered over utilized.
//
// {943c8cb6-6f93-4227-ad87-e9a3feec08d1}
//
extern "C" const GUID GUID_PROCESSOR_CORE_PARKING_OVER_UTILIZATION_THRESHOLD ;

//
// Specifies if at least one processor per core should always remain unparked.
//
// {a55612aa-f624-42c6-a443-7397d064c04f}
//

extern "C" const GUID GUID_PROCESSOR_PARKING_CORE_OVERRIDE ;

//
// Specifies what performance state a processor should enter when first parked.
//
// {447235c7-6a8d-4cc0-8e24-9eaf70b96e2b}
//

extern "C" const GUID GUID_PROCESSOR_PARKING_PERF_STATE ;

//
// Specifies what performance state a processor should enter when first parked
// for Processor Power Efficiency Class 1.
//
// {447235c7-6a8d-4cc0-8e24-9eaf70b96e2c}
//
extern "C" const GUID GUID_PROCESSOR_PARKING_PERF_STATE_1 ;

//
// Specify the busy threshold that must be met when calculating the concurrency of a node's workload.
//
// {2430ab6f-a520-44a2-9601-f7f23b5134b1}
//

extern "C" const GUID GUID_PROCESSOR_PARKING_CONCURRENCY_THRESHOLD ;

//
// Specify the busy threshold that must be met by all cores in a concurrency set to unpark an extra core.
//
// {f735a673-2066-4f80-a0c5-ddee0cf1bf5d}
//

extern "C" const GUID GUID_PROCESSOR_PARKING_HEADROOM_THRESHOLD ;

//
// Specify the percentage utilization used to calculate the distribution concurrency.
//
// {4bdaf4e9-d103-46d7-a5f0-6280121616ef}
//

extern "C" const GUID GUID_PROCESSOR_PARKING_DISTRIBUTION_THRESHOLD ;

//
// Specifies the number of perf time check intervals to average utility over.
//
// {7d24baa7-0b84-480f-840c-1b0743c00f5f}
//
extern "C" const GUID GUID_PROCESSOR_PERF_HISTORY ;

//
// Specifies the number of perf time check intervals to average utility over in
// Processor Power Efficiency Class 1.
//
// {7d24baa7-0b84-480f-840c-1b0743c00f60}
//
extern "C" const GUID GUID_PROCESSOR_PERF_HISTORY_1 ;

//
// Specifies the number of perf time check intervals to average utility over to
// determine performance increase.
//
// N.B. This power setting is DEPRECATED.
//
// {99B3EF01-752F-46a1-80FB-7730011F2354}
//
extern "C" const GUID GUID_PROCESSOR_PERF_INCREASE_HISTORY ;

//
// Specifies the number of perf time check intervals to average utility over to
// determine performance decrease.
//
// N.B. This power setting is DEPRECATED.
//
// {0300F6F8-ABD6-45a9-B74F-4908691A40B5}
//
extern "C" const GUID GUID_PROCESSOR_PERF_DECREASE_HISTORY ;

//
// Specifies the number of perf time check intervals to average utility over for
// core parking.
//
// N.B. This power setting is DEPRECATED.
//
// {77D7F282-8F1A-42cd-8537-45450A839BE8}
//
extern "C" const GUID GUID_PROCESSOR_PERF_CORE_PARKING_HISTORY ;

//
// Specifies whether latency sensitivity hints should be taken into account by
// the perf state engine.
//
// N.B. This power setting is DEPRECATED.
//
// {0822df31-9c83-441c-a079-0de4cf009c7b}
//
extern "C" const GUID GUID_PROCESSOR_PERF_LATENCY_HINT ;

//
// Specifies the processor performance state in response to latency sensitivity hints.
//
// {619b7505-003b-4e82-b7a6-4dd29c300971}
//
extern "C" const GUID GUID_PROCESSOR_PERF_LATENCY_HINT_PERF ;

//
// Specifies the processor performance state in response to latency sensitivity
// hints for Processor Power Efficiency Class 1.
//
// {619b7505-003b-4e82-b7a6-4dd29c300972}
//
extern "C" const GUID GUID_PROCESSOR_PERF_LATENCY_HINT_PERF_1 ;

//
// Specifies the minimum unparked processors when a latency hint is active
// (in a percentage).
//
// {616cdaa5-695e-4545-97ad-97dc2d1bdd88}
//
extern "C" const GUID GUID_PROCESSOR_LATENCY_HINT_MIN_UNPARK ;

//
// Specifies the minimum unparked processors when a latency hint is active
// for Processor Power Efficiency Class 1 (in a percentage).
//
// {616cdaa5-695e-4545-97ad-97dc2d1bdd89}
//
extern "C" const GUID GUID_PROCESSOR_LATENCY_HINT_MIN_UNPARK_1 ;

//
// Specifies whether the core parking engine should distribute processor
// utility.
//
// {e0007330-f589-42ed-a401-5ddb10e785d3}
//
extern "C" const GUID GUID_PROCESSOR_DISTRIBUTE_UTILITY ;

//
// GUIDS to control PPM settings on computer system with more than one
// Processor Power Efficiency Classes (heterogeneous system).
// -----------------
//
// Specifies the current active heterogeneous policy.
//
// {7f2f5cfa-f10c-4823-b5e1-e93ae85f46b5}
//
extern "C" const GUID GUID_PROCESSOR_HETEROGENEOUS_POLICY ;

//
// Specifies the number of perf check cycles required to decrease the number of
// Processor Power Efficiency Class 1 processors.
//
// {7f2492b6-60b1-45e5-ae55-773f8cd5caec}
//
extern "C" const GUID GUID_PROCESSOR_HETERO_DECREASE_TIME ;

//
// Specifies the number of perf check cycles required to increase the number of
// Processor Power Efficiency Class 1 processors.
//
// {4009efa7-e72d-4cba-9edf-91084ea8cbc3}
//
extern "C" const GUID GUID_PROCESSOR_HETERO_INCREASE_TIME ;

//
// Specifies the performance level (in units of Processor Power Efficiency
// Class 0 processor performance) at which the number of Processor Power
// Efficiency Class 1 processors is decreased.
//
// {f8861c27-95e7-475c-865b-13c0cb3f9d6b}
//
extern "C" const GUID GUID_PROCESSOR_HETERO_DECREASE_THRESHOLD ;

//
// Specifies the performance level (in units of Processor Power Efficiency
// Class 0 processor performance) at which the number of Processor Power
// Efficiency Class 1 processors is increased.
//
// {b000397d-9b0b-483d-98c9-692a6060cfbf}
//
extern "C" const GUID GUID_PROCESSOR_HETERO_INCREASE_THRESHOLD ;

//
// Specifies the performance target floor of a Processor Power Efficiency
// Class 0 processor when the system unparks Processor Power Efficiency Class 1
// processor(s).
//
// {fddc842b-8364-4edc-94cf-c17f60de1c80}
//
extern "C" const GUID GUID_PROCESSOR_CLASS0_FLOOR_PERF ;

//
// Specifies the initial performance target of a Processor Power Efficiency
// Class 1 processor when the system makes a transition up from zero Processor
// Power Efficiency Class 1 processors.
//
// {1facfc65-a930-4bc5-9f38-504ec097bbc0}
//
extern "C" const GUID GUID_PROCESSOR_CLASS1_INITIAL_PERF ;

//
// Specifies the scheduling policy for threads in a given QoS class.
//
// {93B8B6DC-0698-4d1c-9EE4-0644E900C85D}
//
extern "C" const GUID GUID_PROCESSOR_THREAD_SCHEDULING_POLICY
;

//
// Specifies the scheduling policy for short running threads in a given QoS
// class.
//
// {BAE08B81-2D5E-4688-AD6A-13243356654B}
//
extern "C" const GUID GUID_PROCESSOR_SHORT_THREAD_SCHEDULING_POLICY
;

//
// Specifies active vs passive cooling.  Although not directly related to
// processor settings, it is the processor that gets throttled if we're doing
// passive cooling, so it is fairly strongly related.
// {94D3A615-A899-4AC5-AE2B-E4D8F634367F}
//
extern "C" const GUID GUID_SYSTEM_COOLING_POLICY ;

//
// Processor responsiveness settings
//
// Specifies the number of responsiveness events required to disable
// responsiveness policy overrides.
//
// {38B8383D-CCE0-4c79-9E3E-56A4F17CC480}
//
extern "C" const GUID GUID_PROCESSOR_RESPONSIVENESS_DISABLE_THRESHOLD
;

//
// Specifies the number of responsiveness events required to disable
// responsiveness policy overrides for efficiency class 1 processors.
//
// {38B8383D-CCE0-4c79-9E3E-56A4F17CC481}
//
extern "C" const GUID GUID_PROCESSOR_RESPONSIVENESS_DISABLE_THRESHOLD_1
;

//
// Specifies the number of responsiveness events required to enable
// responsiveness policy overrides.
//
// {3D44E256-7222-4415-A9ED-9C45FA3DD830}
extern "C" const GUID GUID_PROCESSOR_RESPONSIVENESS_ENABLE_THRESHOLD
;

//
// Specifies the number of responsiveness events required to enable
// responsiveness policy overrides for efficiency class 1 processors.
//
// {3D44E256-7222-4415-A9ED-9C45FA3DD831}
extern "C" const GUID GUID_PROCESSOR_RESPONSIVENESS_ENABLE_THRESHOLD_1
;

//
// Specifies the number of consecutive perf checks with a disable hint before
// responsivenss overrides will be disabled.
//
// {F565999F-3FB0-411a-A226-3F0198DEC130}
extern "C" const GUID GUID_PROCESSOR_RESPONSIVENESS_DISABLE_TIME
;

//
// Specifies the number of consecutive perf checks with a disable hint before
// responsivenss overrides will be disabled for efficiency class 1 processors.
//
// {F565999F-3FB0-411a-A226-3F0198DEC131}
extern "C" const GUID GUID_PROCESSOR_RESPONSIVENESS_DISABLE_TIME_1
;

//
// Specifies the number of consecutive perf checks with a enable hint before
// responsivenss overrides will be enabled.
//
// {3D915188-7830-49ae-A79A-0FB0A1E5A200}
extern "C" const GUID GUID_PROCESSOR_RESPONSIVENESS_ENABLE_TIME
;

//
// Specifies the number of consecutive perf checks with a enable hint before
// responsivenss overrides will be enabled for efficiency class 1 processors.
//
// {3D915188-7830-49ae-A79A-0FB0A1E5A201}
extern "C" const GUID GUID_PROCESSOR_RESPONSIVENESS_ENABLE_TIME_1
;

//
// Specifies the ceiling placed on EPP when responsiveness hints are enabled.
//
// {4427C73B-9756-4a5c-B84B-C7BDA79C7320}
extern "C" const GUID GUID_PROCESSOR_RESPONSIVENESS_EPP_CEILING
;

//
// Specifies the ceiling placed on EPP when responsiveness hints are enabled
// for efficiency class 1 processors.
//
// {4427C73B-9756-4a5c-B84B-C7BDA79C7321}
extern "C" const GUID GUID_PROCESSOR_RESPONSIVENESS_EPP_CEILING_1
;

//
// Specifies the floor placed on processor performance when responsiveness hints
// are enabled.
//
// {CE8E92EE-6A86-4572-BFE0-20C21D03CD40}
extern "C" const GUID GUID_PROCESSOR_RESPONSIVENESS_PERF_FLOOR
;

//
// Specifies the floor placed on processor performance when responsiveness hints
// are enabled for efficiency class 1 processors.
//
// {CE8E92EE-6A86-4572-BFE0-20C21D03CD41}
extern "C" const GUID GUID_PROCESSOR_RESPONSIVENESS_PERF_FLOOR_1
;

// Lock Console on Wake
// --------------------
//

// Specifies the behavior of the system when we wake from standby or
// hibernate.  If this is set, then we will cause the console to lock
// after we resume.
//
extern "C" const GUID GUID_LOCK_CONSOLE_ON_WAKE ;

// Device idle characteristics
// ---------------------------
//
// Specifies whether to use the "performance" or "conservative" timeouts for
// device idle management.
//
// 4faab71a-92e5-4726-b531-224559672d19
//
extern "C" const GUID GUID_DEVICE_IDLE_POLICY ;




//
// Specifies standby connectivity preference.
//
// F15576E8-98B7-4186-B944-EAFA664402D9
extern "C" const GUID GUID_CONNECTIVITY_IN_STANDBY ;





//
// Specifies the mode for disconnected standby.
//
// 68AFB2D9-EE95-47A8-8F50-4115088073B1
extern "C" const GUID GUID_DISCONNECTED_STANDBY_MODE ;




// AC/DC power source
// ------------------
//

// Specifies the power source for the system.  consumers may register for
// notification when the power source changes and will be notified with
// one of 3 values:
// 0 - Indicates the system is being powered by an AC power source.
// 1 - Indicates the system is being powered by a DC power source.
// 2 - Indicates the system is being powered by a short-term DC power
//     source.  For example, this would be the case if the system is
//     being powed by a short-term battery supply in a backing UPS
//     system.  When this value is recieved, the consumer should make
//     preparations for either a system hibernate or system shutdown.
//
// { 5D3E9A59-E9D5-4B00-A6BD-FF34FF516548 }
extern "C" const GUID GUID_ACDC_POWER_SOURCE ;

// Lid state changes
// -----------------
//
// Specifies the current state of the lid (open or closed). The callback won't
// be called at all until a lid device is found and its current state is known.
//
// Values:
//
// 0 - closed
// 1 - opened
//
// { BA3E0F4D-B817-4094-A2D1-D56379E6A0F3 }
//

extern "C" const GUID GUID_LIDSWITCH_STATE_CHANGE ;

// Battery status changes
// ----------------------
//

// Specifies the percentage of battery life remaining.  The consumer
// may register for notification in order to track battery life in
// a fine-grained manner.
//
// Once registered, the consumer can expect to be notified as the battery
// life percentage changes.
//
// The consumer will recieve a value between 0 and 100 (inclusive) which
// indicates percent battery life remaining.
//
// { A7AD8041-B45A-4CAE-87A3-EECBB468A9E1 }
extern "C" const GUID GUID_BATTERY_PERCENTAGE_REMAINING ;

// Specifies change in number of batteries present on the system. The consumer
// may register for notification in order to track change in number of batteries
// available on a system.
//
// Once registered, the consumer can expect to be notified whenever the
// batteries are added or removed from the system.
//
// The consumer will recieve a value indicating number of batteries currently
// present on the system.
//
// {7D263F15-FCA4-49E5-854B-A9F2BFBD5C24}
extern "C" const GUID GUID_BATTERY_COUNT ;

//
// Global notification indicating to listeners user activity/presence accross
// all sessions in the system (Present, NotPresent, Inactive)
//
// {786E8A1D-B427-4344-9207-09E70BDCBEA9}
extern "C" const GUID GUID_GLOBAL_USER_PRESENCE ;

//
// Session specific notification indicating to listeners whether or not the display
// related to the given session is on/off/dim
//
// N.B. This is a session-specific notification, sent only to interactive
//      session registrants. Session 0 and kernel mode consumers do not receive
//      this notification.
//
// {2B84C20E-AD23-4ddf-93DB-05FFBD7EFCA5}
extern "C" const GUID GUID_SESSION_DISPLAY_STATUS ;

//
// Session specific notification indicating to listeners user activity/presence
//(Present, NotPresent, Inactive)
//
// N.B. This is a session-specific notification, sent only to interactive
//      session registrants. Session 0 and kernel mode consumers do not receive
//      this notification.
// {3C0F4548-C03F-4c4d-B9F2-237EDE686376}
extern "C" const GUID GUID_SESSION_USER_PRESENCE ;


// Notification to listeners that the system is fairly busy and won't be moving
// into an idle state any time soon.  This can be used as a hint to listeners
// that now might be a good time to do background tasks.
//
extern "C" const GUID GUID_IDLE_BACKGROUND_TASK ;

// Notification to listeners that the system is fairly busy and won't be moving
// into an idle state any time soon.  This can be used as a hint to listeners
// that now might be a good time to do background tasks.
//
// { CF23F240-2A54-48D8-B114-DE1518FF052E }
extern "C" const GUID GUID_BACKGROUND_TASK_NOTIFICATION ;

// Define a GUID that will represent the action of a direct experience button
// on the platform.  Users will register for this DPPE setting and recieve
// notification when the h/w button is pressed.
//
// { 1A689231-7399-4E9A-8F99-B71F999DB3FA }
//
extern "C" const GUID GUID_APPLAUNCH_BUTTON ;

// PCI Express power settings
// ------------------------
//

// Specifies the subgroup which will contain all of the PCI Express
// settings for a single policy.
//
// {501a4d13-42af-4429-9fd1-a8218c268e20}
//
extern "C" const GUID GUID_PCIEXPRESS_SETTINGS_SUBGROUP ;

// Specifies the PCI Express ASPM power policy.
//
// {ee12f906-d277-404b-b6da-e5fa1a576df5}
//
extern "C" const GUID GUID_PCIEXPRESS_ASPM_POLICY ;

// POWER Shutdown settings
// ------------------------
//

// Specifies if forced shutdown should be used for all button and lid initiated
// shutdown actions.
//
// {833a6b62-dfa4-46d1-82f8-e09e34d029d6}
//

extern "C" const GUID GUID_ENABLE_SWITCH_FORCED_SHUTDOWN ;

// Interrupt Steering power settings
// ------------------------
//

// {48672F38-7A9A-4bb2-8BF8-3D85BE19DE4E}
extern "C" const GUID GUID_INTSTEER_SUBGROUP
;

// {2BFC24F9-5EA2-4801-8213-3DBAE01AA39D}
extern "C" const GUID GUID_INTSTEER_MODE
;

// {73CDE64D-D720-4bb2-A860-C755AFE77EF2}
extern "C" const GUID GUID_INTSTEER_LOAD_PER_PROC_TRIGGER
;

// {D6BA4903-386F-4c2c-8ADB-5C21B3328D25}
extern "C" const GUID GUID_INTSTEER_TIME_UNPARK_TRIGGER
;

// Graphics power settings
// ------------------------
//

// Specified the subgroup which contains all inbox graphics settings.
//
// {5FB4938D-1EE8-4b0f-9A3C-5036B0AB995C}
//
extern "C" const GUID GUID_GRAPHICS_SUBGROUP ;

// Specifies the GPU preference policy.
//
// {DD848B2A-8A5D-4451-9AE2-39CD41658F6C}
//
extern "C" const GUID GUID_GPU_PREFERENCE_POLICY ;

// Other miscellaneous power notification GUIDs
// ------------------------
//

// Specifies whether mixed reality mode is engaged.
//
// {1E626B4E-CF04-4f8d-9CC7-C97C5B0F2391}
//

extern "C" const GUID GUID_MIXED_REALITY_MODE
;

// Specifies a change (start/end) in System Power Report's Active Session.
//
// {0E24CE38-C393-4742-BDB1-744F4B9EE08E}
//

extern "C" const GUID GUID_SPR_ACTIVE_SESSION_CHANGE
;


typedef enum _SYSTEM_POWER_STATE {
    PowerSystemUnspecified = 0,
    PowerSystemWorking     = 1,
    PowerSystemSleeping1   = 2,
    PowerSystemSleeping2   = 3,
    PowerSystemSleeping3   = 4,
    PowerSystemHibernate   = 5,
    PowerSystemShutdown    = 6,
    PowerSystemMaximum     = 7
} SYSTEM_POWER_STATE, *PSYSTEM_POWER_STATE;



typedef enum {
    PowerActionNone = 0,
    PowerActionReserved,
    PowerActionSleep,
    PowerActionHibernate,
    PowerActionShutdown,
    PowerActionShutdownReset,
    PowerActionShutdownOff,
    PowerActionWarmEject,
    PowerActionDisplayOff
} POWER_ACTION, *PPOWER_ACTION;

typedef enum _DEVICE_POWER_STATE {
    PowerDeviceUnspecified = 0,
    PowerDeviceD0,
    PowerDeviceD1,
    PowerDeviceD2,
    PowerDeviceD3,
    PowerDeviceMaximum
} DEVICE_POWER_STATE, *PDEVICE_POWER_STATE;

typedef enum _MONITOR_DISPLAY_STATE {
    PowerMonitorOff = 0,
    PowerMonitorOn,
    PowerMonitorDim
} MONITOR_DISPLAY_STATE, *PMONITOR_DISPLAY_STATE;

typedef enum _USER_ACTIVITY_PRESENCE {
    PowerUserPresent = 0,
    PowerUserNotPresent,
    PowerUserInactive,
    PowerUserMaximum,
    PowerUserInvalid = PowerUserMaximum
} USER_ACTIVITY_PRESENCE, *PUSER_ACTIVITY_PRESENCE;









typedef DWORD EXECUTION_STATE, *PEXECUTION_STATE;

typedef enum {
    LT_DONT_CARE,
    LT_LOWEST_LATENCY
} LATENCY_TIME;









//
// Defines for power request APIs
//






typedef enum _POWER_REQUEST_TYPE {
    PowerRequestDisplayRequired,
    PowerRequestSystemRequired,
    PowerRequestAwayModeRequired,
    PowerRequestExecutionRequired
} POWER_REQUEST_TYPE, *PPOWER_REQUEST_TYPE;

// end_ntminiport



//-----------------------------------------------------------------------------
// Device Power Information
// Accessable via CM_Get_DevInst_Registry_Property_Ex(CM_DRP_DEVICE_POWER_DATA)
//-----------------------------------------------------------------------------











typedef struct CM_Power_Data_s {
    DWORD               PD_Size;
    DEVICE_POWER_STATE  PD_MostRecentPowerState;
    DWORD               PD_Capabilities;
    DWORD               PD_D1Latency;
    DWORD               PD_D2Latency;
    DWORD               PD_D3Latency;
    DEVICE_POWER_STATE  PD_PowerStateMapping[7 ];
    SYSTEM_POWER_STATE  PD_DeepestSystemWake;
} CM_POWER_DATA, *PCM_POWER_DATA;

#line 15660 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winnt.h"

// begin_wdm

typedef enum {
    SystemPowerPolicyAc,
    SystemPowerPolicyDc,
    VerifySystemPolicyAc,
    VerifySystemPolicyDc,
    SystemPowerCapabilities,
    SystemBatteryState,
    SystemPowerStateHandler,
    ProcessorStateHandler,
    SystemPowerPolicyCurrent,
    AdministratorPowerPolicy,
    SystemReserveHiberFile,
    ProcessorInformation,
    SystemPowerInformation,
    ProcessorStateHandler2,
    LastWakeTime,                                   // Compare with KeQueryInterruptTime()
    LastSleepTime,                                  // Compare with KeQueryInterruptTime()
    SystemExecutionState,
    SystemPowerStateNotifyHandler,
    ProcessorPowerPolicyAc,
    ProcessorPowerPolicyDc,
    VerifyProcessorPowerPolicyAc,
    VerifyProcessorPowerPolicyDc,
    ProcessorPowerPolicyCurrent,
    SystemPowerStateLogging,
    SystemPowerLoggingEntry,
    SetPowerSettingValue,
    NotifyUserPowerSetting,
    PowerInformationLevelUnused0,
    SystemMonitorHiberBootPowerOff,
    SystemVideoState,
    TraceApplicationPowerMessage,
    TraceApplicationPowerMessageEnd,
    ProcessorPerfStates,
    ProcessorIdleStates,
    ProcessorCap,
    SystemWakeSource,
    SystemHiberFileInformation,
    TraceServicePowerMessage,
    ProcessorLoad,
    PowerShutdownNotification,
    MonitorCapabilities,
    SessionPowerInit,
    SessionDisplayState,
    PowerRequestCreate,
    PowerRequestAction,
    GetPowerRequestList,
    ProcessorInformationEx,
    NotifyUserModeLegacyPowerEvent,
    GroupPark,
    ProcessorIdleDomains,
    WakeTimerList,
    SystemHiberFileSize,
    ProcessorIdleStatesHv,
    ProcessorPerfStatesHv,
    ProcessorPerfCapHv,
    ProcessorSetIdle,
    LogicalProcessorIdling,
    UserPresence,
    PowerSettingNotificationName,
    GetPowerSettingValue,
    IdleResiliency,
    SessionRITState,
    SessionConnectNotification,
    SessionPowerCleanup,
    SessionLockState,
    SystemHiberbootState,
    PlatformInformation,
    PdcInvocation,
    MonitorInvocation,
    FirmwareTableInformationRegistered,
    SetShutdownSelectedTime,
    SuspendResumeInvocation,
    PlmPowerRequestCreate,
    ScreenOff,
    CsDeviceNotification,
    PlatformRole,
    LastResumePerformance,
    DisplayBurst,
    ExitLatencySamplingPercentage,
    RegisterSpmPowerSettings,
    PlatformIdleStates,
    ProcessorIdleVeto,                              // Deprecated.
    PlatformIdleVeto,                               // Deprecated.
    SystemBatteryStatePrecise,
    ThermalEvent,
    PowerRequestActionInternal,
    BatteryDeviceState,
    PowerInformationInternal,
    ThermalStandby,
    SystemHiberFileType,
    PhysicalPowerButtonPress,
    QueryPotentialDripsConstraint,
    EnergyTrackerCreate,
    EnergyTrackerQuery,
    UpdateBlackBoxRecorder,
    PowerInformationLevelMaximum
} POWER_INFORMATION_LEVEL;

//
// User Presence Values
//

typedef enum {
    UserNotPresent = 0,
    UserPresent = 1,
    UserUnknown = 0xff
} POWER_USER_PRESENCE_TYPE, *PPOWER_USER_PRESENCE_TYPE;

typedef struct _POWER_USER_PRESENCE {
    POWER_USER_PRESENCE_TYPE UserPresence;
} POWER_USER_PRESENCE, *PPOWER_USER_PRESENCE;

//
// Session Connect/Disconnect
//
typedef struct _POWER_SESSION_CONNECT {
    BOOLEAN Connected;  // TRUE - connected, FALSE - disconnected
    BOOLEAN Console;    // TRUE - console, FALSE - TS (not used for Connected = FALSE)
} POWER_SESSION_CONNECT, *PPOWER_SESSION_CONNECT;

typedef struct _POWER_SESSION_TIMEOUTS {
    DWORD InputTimeout;
    DWORD DisplayTimeout;
} POWER_SESSION_TIMEOUTS, *PPOWER_SESSION_TIMEOUTS;

//
// Session RIT State
//
typedef struct _POWER_SESSION_RIT_STATE {
    BOOLEAN Active;  // TRUE - RIT input received, FALSE - RIT timeout
    DWORD LastInputTime; // last input time held for this session
} POWER_SESSION_RIT_STATE, *PPOWER_SESSION_RIT_STATE;

//
// Winlogon notifications
//
typedef struct _POWER_SESSION_WINLOGON {
    DWORD SessionId; // the Win32k session identifier
    BOOLEAN Console; // TRUE - for console session, FALSE - for remote session
    BOOLEAN Locked; // TRUE - lock, FALSE - unlock
} POWER_SESSION_WINLOGON, *PPOWER_SESSION_WINLOGON;

//
// Idle resiliency
//
typedef struct _POWER_IDLE_RESILIENCY {
    DWORD CoalescingTimeout;
    DWORD IdleResiliencyPeriod;
} POWER_IDLE_RESILIENCY, *PPOWER_IDLE_RESILIENCY;

//
// Monitor on/off reasons
//
// N.B. Update power-event mapping when adding new events.
//
typedef enum {
    MonitorRequestReasonUnknown,
    MonitorRequestReasonPowerButton,
    MonitorRequestReasonRemoteConnection,
    MonitorRequestReasonScMonitorpower,
    MonitorRequestReasonUserInput,
    MonitorRequestReasonAcDcDisplayBurst,
    MonitorRequestReasonUserDisplayBurst,
    MonitorRequestReasonPoSetSystemState,
    MonitorRequestReasonSetThreadExecutionState,
    MonitorRequestReasonFullWake,
    MonitorRequestReasonSessionUnlock,
    MonitorRequestReasonScreenOffRequest,
    MonitorRequestReasonIdleTimeout,
    MonitorRequestReasonPolicyChange,
    MonitorRequestReasonSleepButton,
    MonitorRequestReasonLid,
    MonitorRequestReasonBatteryCountChange,
    MonitorRequestReasonGracePeriod,
    MonitorRequestReasonPnP,
    MonitorRequestReasonDP,
    MonitorRequestReasonSxTransition,
    MonitorRequestReasonSystemIdle,
    MonitorRequestReasonNearProximity,
    MonitorRequestReasonThermalStandby,
    MonitorRequestReasonResumePdc,
    MonitorRequestReasonResumeS4,
    MonitorRequestReasonTerminal,
    MonitorRequestReasonPdcSignal,
    MonitorRequestReasonAcDcDisplayBurstSuppressed,
    MonitorRequestReasonSystemStateEntered, // When CS exit happens because system
                                            // transition to S4/S5, please note this
                                            // reason is different than ReasonSxTransition.
    MonitorRequestReasonWinrt,
    MonitorRequestReasonUserInputKeyboard,
    MonitorRequestReasonUserInputMouse,
    MonitorRequestReasonUserInputTouch,
    MonitorRequestReasonUserInputPen,
    MonitorRequestReasonUserInputAccelerometer,
    MonitorRequestReasonUserInputHid,
    MonitorRequestReasonUserInputPoUserPresent,
    MonitorRequestReasonUserInputSessionSwitch,
    MonitorRequestReasonUserInputInitialization,
    MonitorRequestReasonPdcSignalWindowsMobilePwrNotif,         // PDC_SIGNAL_PROVIDER_PWRNOTIF_SVC
    MonitorRequestReasonPdcSignalWindowsMobileShell,            // PDC_SIGNAL_PROVIDER_UM_CS_CONTROL
    MonitorRequestReasonPdcSignalHeyCortana,                    // PDC_SIGNAL_PROVIDER_HEY_CORTANA
    MonitorRequestReasonPdcSignalHolographicShell,              // PDC_SIGNAL_PROVIDER_HOLOSI_CRITICAL_BATTERY_WAKE
    MonitorRequestReasonPdcSignalFingerprint,                   // PDC_SIGNAL_PROVIDER_WINBIO
    MonitorRequestReasonDirectedDrips,
    MonitorRequestReasonMax
} POWER_MONITOR_REQUEST_REASON;

typedef enum _POWER_MONITOR_REQUEST_TYPE {
    MonitorRequestTypeOff,
    MonitorRequestTypeOnAndPresent,
    MonitorRequestTypeToggleOn
} POWER_MONITOR_REQUEST_TYPE;

//
// Monitor invocation
//
typedef struct _POWER_MONITOR_INVOCATION {
    BOOLEAN Console;
    POWER_MONITOR_REQUEST_REASON RequestReason;
} POWER_MONITOR_INVOCATION, *PPOWER_MONITOR_INVOCATION;

//
// Last resume performance structure
//

typedef struct _RESUME_PERFORMANCE {
    DWORD PostTimeMs;
    ULONGLONG TotalResumeTimeMs;
    ULONGLONG ResumeCompleteTimestamp;
} RESUME_PERFORMANCE, *PRESUME_PERFORMANCE;

//
// Power Setting definitions
//

typedef enum {
    PoAc,
    PoDc,
    PoHot,
    PoConditionMaximum
} SYSTEM_POWER_CONDITION;

typedef struct {

    //
    // Version of this structure.  Currently should be set to
    // POWER_SETTING_VALUE_VERSION.
    //
    DWORD       Version;


    //
    // GUID representing the power setting being applied.
    //
    GUID        Guid;


    //
    // What power state should this setting be applied to?  E.g.
    // AC, DC, thermal, ...
    //
    SYSTEM_POWER_CONDITION PowerCondition;

    //
    // Length (in bytes) of the 'Data' member.
    //
    DWORD       DataLength;

    //
    // Data which contains the actual setting value.
    //
    BYTE    Data[1 ];
} SET_POWER_SETTING_VALUE, *PSET_POWER_SETTING_VALUE;



typedef struct {
    GUID Guid;
} NOTIFY_USER_POWER_SETTING, *PNOTIFY_USER_POWER_SETTING;

//
// Package definition for an experience button device notification.  When
// someone registers for GUID_EXPERIENCE_BUTTON, this is the definition of
// the setting data they'll get.
//
typedef struct _APPLICATIONLAUNCH_SETTING_VALUE {

    //
    // System time when the most recent button press ocurred.  Note that this is
    // specified in 100ns internvals since January 1, 1601.
    //
    LARGE_INTEGER       ActivationTime;

    //
    // Reserved for internal use.
    //
    DWORD               Flags;

    //
    // which instance of this device was pressed?
    //
    DWORD               ButtonInstanceID;


} APPLICATIONLAUNCH_SETTING_VALUE, *PAPPLICATIONLAUNCH_SETTING_VALUE;

//
// define platform roles
//

typedef enum _POWER_PLATFORM_ROLE {
    PlatformRoleUnspecified = 0,
    PlatformRoleDesktop,
    PlatformRoleMobile,
    PlatformRoleWorkstation,
    PlatformRoleEnterpriseServer,
    PlatformRoleSOHOServer,
    PlatformRoleAppliancePC,
    PlatformRolePerformanceServer, // v1 last supported
    PlatformRoleSlate,             // v2 last supported
    PlatformRoleMaximum
} POWER_PLATFORM_ROLE, *PPOWER_PLATFORM_ROLE;












#line 15999 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winnt.h"




#line 16004 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winnt.h"

typedef struct _POWER_PLATFORM_INFORMATION {
    BOOLEAN AoAc;
} POWER_PLATFORM_INFORMATION, *PPOWER_PLATFORM_INFORMATION;

//
// System power manager capabilities
//


typedef struct {
    DWORD       Granularity;
    DWORD       Capacity;
} BATTERY_REPORTING_SCALE, *PBATTERY_REPORTING_SCALE;
#line 16019 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winnt.h"

//

typedef struct {
    DWORD   Frequency;
    DWORD   Flags;
    DWORD   PercentFrequency;
} PPM_WMI_LEGACY_PERFSTATE, *PPPM_WMI_LEGACY_PERFSTATE;

typedef struct {
    DWORD Latency;
    DWORD Power;
    DWORD TimeCheck;
    BYTE  PromotePercent;
    BYTE  DemotePercent;
    BYTE  StateType;
    BYTE  Reserved;
    DWORD StateFlags;
    DWORD Context;
    DWORD IdleHandler;
    DWORD Reserved1;            // reserved for future use
} PPM_WMI_IDLE_STATE, *PPPM_WMI_IDLE_STATE;

typedef struct {
    DWORD Type;
    DWORD Count;
    DWORD TargetState;          // current idle state
    DWORD OldState;             // previous idle state
    DWORD64 TargetProcessors;
    PPM_WMI_IDLE_STATE State[1 ];
} PPM_WMI_IDLE_STATES, *PPPM_WMI_IDLE_STATES;

typedef struct {
    DWORD Type;
    DWORD Count;
    DWORD TargetState;          // current idle state
    DWORD OldState;             // previous idle state
    PVOID TargetProcessors;
    PPM_WMI_IDLE_STATE State[1 ];
} PPM_WMI_IDLE_STATES_EX, *PPPM_WMI_IDLE_STATES_EX;

typedef struct {
    DWORD Frequency;            // in Mhz
    DWORD Power;                // in milliwatts
    BYTE  PercentFrequency;
    BYTE  IncreaseLevel;        // goto higher state
    BYTE  DecreaseLevel;        // goto lower state
    BYTE  Type;                 // performance or throttle
    DWORD IncreaseTime;         // in tick counts
    DWORD DecreaseTime;         // in tick counts
    DWORD64 Control;            // control value
    DWORD64 Status;             // control value
    DWORD HitCount;
    DWORD Reserved1;            // reserved for future use
    DWORD64 Reserved2;
    DWORD64 Reserved3;
} PPM_WMI_PERF_STATE, *PPPM_WMI_PERF_STATE;

typedef struct {
    DWORD Count;
    DWORD MaxFrequency;
    DWORD CurrentState;         // current state
    DWORD MaxPerfState;         // fastest state considering policy restrictions
    DWORD MinPerfState;         // slowest state considering policy restrictions
    DWORD LowestPerfState;      // slowest perf state, fixed, aka the "knee"
    DWORD ThermalConstraint;
    BYTE  BusyAdjThreshold;
    BYTE  PolicyType;           // domain coordination
    BYTE  Type;
    BYTE  Reserved;
    DWORD TimerInterval;
    DWORD64 TargetProcessors;   // domain affinity
    DWORD PStateHandler;
    DWORD PStateContext;
    DWORD TStateHandler;
    DWORD TStateContext;
    DWORD FeedbackHandler;
    DWORD Reserved1;
    DWORD64 Reserved2;
    PPM_WMI_PERF_STATE State[1 ];
} PPM_WMI_PERF_STATES, *PPPM_WMI_PERF_STATES;

typedef struct {
    DWORD Count;
    DWORD MaxFrequency;
    DWORD CurrentState;         // current state
    DWORD MaxPerfState;         // fastest state considering policy restrictions
    DWORD MinPerfState;         // slowest state considering policy restrictions
    DWORD LowestPerfState;      // slowest perf state, fixed, aka the "knee"
    DWORD ThermalConstraint;
    BYTE  BusyAdjThreshold;
    BYTE  PolicyType;           // domain coordination
    BYTE  Type;
    BYTE  Reserved;
    DWORD TimerInterval;
    PVOID TargetProcessors;     // domain affinity
    DWORD PStateHandler;
    DWORD PStateContext;
    DWORD TStateHandler;
    DWORD TStateContext;
    DWORD FeedbackHandler;
    DWORD Reserved1;
    DWORD64 Reserved2;
    PPM_WMI_PERF_STATE State[1 ];
} PPM_WMI_PERF_STATES_EX, *PPPM_WMI_PERF_STATES_EX;

//
// Legacy processor idle accounting.
//



typedef struct {
    DWORD IdleTransitions;
    DWORD FailedTransitions;
    DWORD InvalidBucketIndex;
    DWORD64 TotalTime;
    DWORD IdleTimeBuckets[6 ];
} PPM_IDLE_STATE_ACCOUNTING, *PPPM_IDLE_STATE_ACCOUNTING;

typedef struct {
    DWORD StateCount;
    DWORD TotalTransitions;
    DWORD ResetCount;
    DWORD64 StartTime;
    PPM_IDLE_STATE_ACCOUNTING State[1 ];
} PPM_IDLE_ACCOUNTING, *PPPM_IDLE_ACCOUNTING;

//
// Processor idle accounting.
//



typedef struct {
    DWORD64 TotalTimeUs;
    DWORD MinTimeUs;
    DWORD MaxTimeUs;
    DWORD Count;
} PPM_IDLE_STATE_BUCKET_EX, *PPPM_IDLE_STATE_BUCKET_EX;

typedef struct {
    DWORD64 TotalTime;
    DWORD IdleTransitions;
    DWORD FailedTransitions;
    DWORD InvalidBucketIndex;
    DWORD MinTimeUs;
    DWORD MaxTimeUs;
    DWORD CancelledTransitions;
    PPM_IDLE_STATE_BUCKET_EX IdleTimeBuckets[16 ];
} PPM_IDLE_STATE_ACCOUNTING_EX, *PPPM_IDLE_STATE_ACCOUNTING_EX;

typedef struct {
    DWORD StateCount;
    DWORD TotalTransitions;
    DWORD ResetCount;
    DWORD AbortCount;
    DWORD64 StartTime;
     PPM_IDLE_STATE_ACCOUNTING_EX State[1 ];
} PPM_IDLE_ACCOUNTING_EX, *PPPM_IDLE_ACCOUNTING_EX;

//
// Definitions of coordination types for _PSD, _TSD, and _CSD BIOS objects from
// the Acpi 3.0 specification
//





//
// Definition of Microsoft PPM coordination types.
//



//
// Processor firmware rundown feature bit definitions.
//






















//
// Processor performance and idle controls implementations.
//













//
// Processor Power Management WMI interface.
//

// {A5B32DDD-7F39-4abc-B892-900E43B59EBB}
extern "C" const GUID PPM_PERFSTATE_CHANGE_GUID
;

// {995e6b7f-d653-497a-b978-36a30c29bf01}
extern "C" const GUID PPM_PERFSTATE_DOMAIN_CHANGE_GUID
;

// {4838fe4f-f71c-4e51-9ecc-8430a7ac4c6c}
extern "C" const GUID PPM_IDLESTATE_CHANGE_GUID
;

// {5708cc20-7d40-4bf4-b4aa-2b01338d0126}
extern "C" const GUID PPM_PERFSTATES_DATA_GUID
;

// {ba138e10-e250-4ad7-8616-cf1a7ad410e7}
extern "C" const GUID PPM_IDLESTATES_DATA_GUID
;

// {e2a26f78-ae07-4ee0-a30f-ce354f5a94cd}
extern "C" const GUID PPM_IDLE_ACCOUNTING_GUID
;

// {d67abd39-81f8-4a5e-8152-72e31ec912ee}
extern "C" const GUID PPM_IDLE_ACCOUNTING_EX_GUID
;

// {a852c2c8-1a4c-423b-8c2c-f30d82931a88}
extern "C" const GUID PPM_THERMALCONSTRAINT_GUID
;

// {7fd18652-0cfe-40d2-b0a1-0b066a87759e}
extern "C" const GUID PPM_PERFMON_PERFSTATE_GUID
;

// {48f377b8-6880-4c7b-8bdc-380176c6654d}
extern "C" const GUID PPM_THERMAL_POLICY_CHANGE_GUID
;


typedef struct {
    DWORD State;
    DWORD Status;
    DWORD Latency;
    DWORD Speed;
    DWORD Processor;
} PPM_PERFSTATE_EVENT, *PPPM_PERFSTATE_EVENT;

typedef struct {
    DWORD State;
    DWORD Latency;
    DWORD Speed;
    DWORD64 Processors;
} PPM_PERFSTATE_DOMAIN_EVENT, *PPPM_PERFSTATE_DOMAIN_EVENT;

typedef struct {
    DWORD NewState;
    DWORD OldState;
    DWORD64 Processors;
} PPM_IDLESTATE_EVENT, *PPPM_IDLESTATE_EVENT;

typedef struct {
    DWORD ThermalConstraint;
    DWORD64 Processors;
} PPM_THERMALCHANGE_EVENT, *PPPM_THERMALCHANGE_EVENT;

#pragma warning(push)
#pragma warning(disable:4121)

typedef struct {
    BYTE  Mode;
    DWORD64 Processors;
} PPM_THERMAL_POLICY_EVENT, *PPPM_THERMAL_POLICY_EVENT;

#pragma warning(pop)

// Power Policy Management interfaces
//

typedef struct {
    POWER_ACTION    Action;
    DWORD           Flags;
    DWORD           EventCode;
} POWER_ACTION_POLICY, *PPOWER_ACTION_POLICY;

// POWER_ACTION_POLICY->Flags:















// POWER_ACTION_POLICY->EventCode flags








// Note: for battery alarm EventCodes, the ID of the battery alarm << 16 is ORed
// into the flags.  For example: DISCHARGE_POLICY_LOW << 16

//
// The GUID_BATTERY_DISCHARGE_FLAGS_x power settings use a subset of EventCode
// flags.  The POWER_FORCE_TRIGGER_RESET flag doesn't make sense for a battery
// alarm so it is overloaded for other purposes (gerneral enable/disable).



// system battery drain policies
typedef struct {
    BOOLEAN                 Enable;
    BYTE                    Spare[3];
    DWORD                   BatteryLevel;
    POWER_ACTION_POLICY     PowerPolicy;
    SYSTEM_POWER_STATE      MinSystemState;
} SYSTEM_POWER_LEVEL, *PSYSTEM_POWER_LEVEL;

// Discharge policy constants





// system power policies
typedef struct _SYSTEM_POWER_POLICY {
    DWORD                   Revision;       // 1

    // events
    POWER_ACTION_POLICY     PowerButton;
    POWER_ACTION_POLICY     SleepButton;
    POWER_ACTION_POLICY     LidClose;
    SYSTEM_POWER_STATE      LidOpenWake;
    DWORD                   Reserved;

    // "system idle" detection
    POWER_ACTION_POLICY     Idle;
    DWORD                   IdleTimeout;
    BYTE                    IdleSensitivity;

    BYTE                    DynamicThrottle;
    BYTE                    Spare2[2];

    // meaning of power action "sleep"
    SYSTEM_POWER_STATE      MinSleep;
    SYSTEM_POWER_STATE      MaxSleep;
    SYSTEM_POWER_STATE      ReducedLatencySleep;
    DWORD                   WinLogonFlags;

    DWORD                   Spare3;

    // parameters for dozing
    //
    DWORD                   DozeS4Timeout;

    // battery policies
    DWORD                   BroadcastCapacityResolution;
    SYSTEM_POWER_LEVEL      DischargePolicy[4 ];

    // video policies
    DWORD                   VideoTimeout;
    BOOLEAN                 VideoDimDisplay;
    DWORD                   VideoReserved[3];

    // hard disk policies
    DWORD                   SpindownTimeout;

    // processor policies
    BOOLEAN                 OptimizeForPower;
    BYTE                    FanThrottleTolerance;
    BYTE                    ForcedThrottle;
    BYTE                    MinThrottle;
    POWER_ACTION_POLICY     OverThrottled;

} SYSTEM_POWER_POLICY, *PSYSTEM_POWER_POLICY;


// processor power policy state

//
// Processor Idle State Policy.
//



typedef struct {
    DWORD TimeCheck;
    BYTE  DemotePercent;
    BYTE  PromotePercent;
    BYTE  Spare[2];
} PROCESSOR_IDLESTATE_INFO, *PPROCESSOR_IDLESTATE_INFO;

typedef struct {
    WORD   Revision;
    union {
        WORD   AsWORD  ;
        struct {
            WORD   AllowScaling : 1;
            WORD   Disabled : 1;
            WORD   Reserved : 14;
        }  ;
    } Flags;

    DWORD PolicyCount;
    PROCESSOR_IDLESTATE_INFO Policy[0x3 ];
} PROCESSOR_IDLESTATE_POLICY, *PPROCESSOR_IDLESTATE_POLICY;

//
// Legacy Processor Policy.  This is only provided to allow legacy
// applications to compile.  New applications must use
// PROCESSOR_IDLESTATE_POLICY.
//








typedef struct _PROCESSOR_POWER_POLICY_INFO {

    // Time based information (will be converted to kernel units)
    DWORD                   TimeCheck;                      // in US
    DWORD                   DemoteLimit;                    // in US
    DWORD                   PromoteLimit;                   // in US

    // Percentage based information
    BYTE                    DemotePercent;
    BYTE                    PromotePercent;
    BYTE                    Spare[2];

    // Flags
    DWORD                   AllowDemotion:1;
    DWORD                   AllowPromotion:1;
    DWORD                   Reserved:30;

} PROCESSOR_POWER_POLICY_INFO, *PPROCESSOR_POWER_POLICY_INFO;

// processor power policy
typedef struct _PROCESSOR_POWER_POLICY {
    DWORD                       Revision;       // 1

    // Dynamic Throttling Policy
    BYTE                        DynamicThrottle;
    BYTE                        Spare[3];

    // Flags
    DWORD                       DisableCStates:1;
    DWORD                       Reserved:31;

    // System policy information
    // The Array is last, in case it needs to be grown and the structure
    // revision incremented.
    DWORD                       PolicyCount;
    PROCESSOR_POWER_POLICY_INFO Policy[3];

} PROCESSOR_POWER_POLICY, *PPROCESSOR_POWER_POLICY;

//
// Processor Perf State Policy.
//

typedef struct {
    DWORD Revision;
    BYTE  MaxThrottle;
    BYTE  MinThrottle;
    BYTE  BusyAdjThreshold;
    union {
        BYTE  Spare;
        union {
            BYTE  AsBYTE ;
            struct {
                BYTE  NoDomainAccounting : 1;
                BYTE  IncreasePolicy: 2;
                BYTE  DecreasePolicy: 2;
                BYTE  Reserved : 3;
            }  ;
        } Flags;
    }  ;

    DWORD TimeCheck;
    DWORD IncreaseTime;
    DWORD DecreaseTime;
    DWORD IncreasePercent;
    DWORD DecreasePercent;
} PROCESSOR_PERFSTATE_POLICY, *PPROCESSOR_PERFSTATE_POLICY;

// administrator power policy overrides
typedef struct _ADMINISTRATOR_POWER_POLICY {

    // meaning of power action "sleep"
    SYSTEM_POWER_STATE      MinSleep;
    SYSTEM_POWER_STATE      MaxSleep;

    // video policies
    DWORD                   MinVideoTimeout;
    DWORD                   MaxVideoTimeout;

    // disk policies
    DWORD                   MinSpindownTimeout;
    DWORD                   MaxSpindownTimeout;
} ADMINISTRATOR_POWER_POLICY, *PADMINISTRATOR_POWER_POLICY;


typedef enum _HIBERFILE_BUCKET_SIZE {
    HiberFileBucket1GB = 0,
    HiberFileBucket2GB,
    HiberFileBucket4GB,
    HiberFileBucket8GB,
    HiberFileBucket16GB,
    HiberFileBucket32GB,
    HiberFileBucketUnlimited,
    HiberFileBucketMax
} HIBERFILE_BUCKET_SIZE, *PHIBERFILE_BUCKET_SIZE;






typedef struct _HIBERFILE_BUCKET {
    DWORD64 MaxPhysicalMemory;
    DWORD PhysicalMemoryPercent[0x03 ];
} HIBERFILE_BUCKET, *PHIBERFILE_BUCKET;

typedef struct {
    // Misc supported system features
    BOOLEAN             PowerButtonPresent;
    BOOLEAN             SleepButtonPresent;
    BOOLEAN             LidPresent;
    BOOLEAN             SystemS1;
    BOOLEAN             SystemS2;
    BOOLEAN             SystemS3;
    BOOLEAN             SystemS4;           // hibernate
    BOOLEAN             SystemS5;           // off
    BOOLEAN             HiberFilePresent;
    BOOLEAN             FullWake;
    BOOLEAN             VideoDimPresent;
    BOOLEAN             ApmPresent;
    BOOLEAN             UpsPresent;

    // Processors
    BOOLEAN             ThermalControl;
    BOOLEAN             ProcessorThrottle;
    BYTE                ProcessorMinThrottle;




#line 16603 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winnt.h"
    BYTE                ProcessorMaxThrottle;
    BOOLEAN             FastSystemS4;
    BOOLEAN             Hiberboot;
    BOOLEAN             WakeAlarmPresent;
    BOOLEAN             AoAc;
#line 16609 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winnt.h"

    // Disk
    BOOLEAN             DiskSpinDown;


    BYTE                spare3[8];





#line 16621 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winnt.h"

    // System Battery
    BOOLEAN             SystemBatteriesPresent;
    BOOLEAN             BatteriesAreShortTerm;
    BATTERY_REPORTING_SCALE BatteryScale[3];

    // Wake
    SYSTEM_POWER_STATE  AcOnLineWake;
    SYSTEM_POWER_STATE  SoftLidWake;
    SYSTEM_POWER_STATE  RtcWake;
    SYSTEM_POWER_STATE  MinDeviceWakeState; // note this may change on driver load
    SYSTEM_POWER_STATE  DefaultLowLatencyWake;
} SYSTEM_POWER_CAPABILITIES, *PSYSTEM_POWER_CAPABILITIES;

typedef struct {
    BOOLEAN             AcOnLine;
    BOOLEAN             BatteryPresent;
    BOOLEAN             Charging;
    BOOLEAN             Discharging;
    BOOLEAN             Spare1[3];

    BYTE                Tag;

    DWORD               MaxCapacity;
    DWORD               RemainingCapacity;
    DWORD               Rate;
    DWORD               EstimatedTime;

    DWORD               DefaultAlert1;
    DWORD               DefaultAlert2;
} SYSTEM_BATTERY_STATE, *PSYSTEM_BATTERY_STATE;



//
// Image Format
//




#line 1 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\shared\\pshpack4.h"
/*++

Copyright (c) Microsoft Corporation.  All rights reserved.

Module Name:

    pshpack4.h

Abstract:

    This file turns 4 byte packing of structures on.  (That is, it disables
    automatic alignment of structure fields.)  An include file is needed
    because various compilers do this in different ways.  For Microsoft
    compatible compilers, this files uses the push option to the pack pragma
    so that the poppack.h include file can restore the previous packing
    reliably.

    The file poppack.h is the complement to this file.

--*/



#pragma warning(disable:4103)

#pragma pack(push,4)


#line 30 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\shared\\pshpack4.h"


#line 33 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\shared\\pshpack4.h"
#line 34 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\shared\\pshpack4.h"
#line 16663 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winnt.h"







#line 1 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\shared\\pshpack2.h"
/*++

Copyright (c) Microsoft Corporation.  All rights reserved.

Module Name:

    pshpack2.h

Abstract:

    This file turns 2 byte packing of structures on.  (That is, it disables
    automatic alignment of structure fields.)  An include file is needed
    because various compilers do this in different ways.  For Microsoft
    compatible compilers, this files uses the push option to the pack pragma
    so that the poppack.h include file can restore the previous packing
    reliably.

    The file poppack.h is the complement to this file.

--*/



#pragma warning(disable:4103)

#pragma pack(push,2)


#line 30 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\shared\\pshpack2.h"


#line 33 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\shared\\pshpack2.h"
#line 34 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\shared\\pshpack2.h"
#line 16671 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winnt.h"









#line 16681 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winnt.h"

typedef struct _IMAGE_DOS_HEADER {      // DOS .EXE header
    WORD   e_magic;                     // Magic number
    WORD   e_cblp;                      // Bytes on last page of file
    WORD   e_cp;                        // Pages in file
    WORD   e_crlc;                      // Relocations
    WORD   e_cparhdr;                   // Size of header in paragraphs
    WORD   e_minalloc;                  // Minimum extra paragraphs needed
    WORD   e_maxalloc;                  // Maximum extra paragraphs needed
    WORD   e_ss;                        // Initial (relative) SS value
    WORD   e_sp;                        // Initial SP value
    WORD   e_csum;                      // Checksum
    WORD   e_ip;                        // Initial IP value
    WORD   e_cs;                        // Initial (relative) CS value
    WORD   e_lfarlc;                    // File address of relocation table
    WORD   e_ovno;                      // Overlay number
    WORD   e_res[4];                    // Reserved words
    WORD   e_oemid;                     // OEM identifier (for e_oeminfo)
    WORD   e_oeminfo;                   // OEM information; e_oemid specific
    WORD   e_res2[10];                  // Reserved words
    LONG   e_lfanew;                    // File address of new exe header
  } IMAGE_DOS_HEADER, *PIMAGE_DOS_HEADER;

typedef struct _IMAGE_OS2_HEADER {      // OS/2 .EXE header
    WORD   ne_magic;                    // Magic number
    CHAR   ne_ver;                      // Version number
    CHAR   ne_rev;                      // Revision number
    WORD   ne_enttab;                   // Offset of Entry Table
    WORD   ne_cbenttab;                 // Number of bytes in Entry Table
    LONG   ne_crc;                      // Checksum of whole file
    WORD   ne_flags;                    // Flag word
    WORD   ne_autodata;                 // Automatic data segment number
    WORD   ne_heap;                     // Initial heap allocation
    WORD   ne_stack;                    // Initial stack allocation
    LONG   ne_csip;                     // Initial CS:IP setting
    LONG   ne_sssp;                     // Initial SS:SP setting
    WORD   ne_cseg;                     // Count of file segments
    WORD   ne_cmod;                     // Entries in Module Reference Table
    WORD   ne_cbnrestab;                // Size of non-resident name table
    WORD   ne_segtab;                   // Offset of Segment Table
    WORD   ne_rsrctab;                  // Offset of Resource Table
    WORD   ne_restab;                   // Offset of resident name table
    WORD   ne_modtab;                   // Offset of Module Reference Table
    WORD   ne_imptab;                   // Offset of Imported Names Table
    LONG   ne_nrestab;                  // Offset of Non-resident Names Table
    WORD   ne_cmovent;                  // Count of movable entries
    WORD   ne_align;                    // Segment alignment shift count
    WORD   ne_cres;                     // Count of resource segments
    BYTE   ne_exetyp;                   // Target Operating system
    BYTE   ne_flagsothers;              // Other .EXE flags
    WORD   ne_pretthunks;               // offset to return thunks
    WORD   ne_psegrefbytes;             // offset to segment ref. bytes
    WORD   ne_swaparea;                 // Minimum code swap area size
    WORD   ne_expver;                   // Expected Windows version number
  } IMAGE_OS2_HEADER, *PIMAGE_OS2_HEADER;

typedef struct _IMAGE_VXD_HEADER {      // Windows VXD header
    WORD   e32_magic;                   // Magic number
    BYTE   e32_border;                  // The byte ordering for the VXD
    BYTE   e32_worder;                  // The word ordering for the VXD
    DWORD  e32_level;                   // The EXE format level for now = 0
    WORD   e32_cpu;                     // The CPU type
    WORD   e32_os;                      // The OS type
    DWORD  e32_ver;                     // Module version
    DWORD  e32_mflags;                  // Module flags
    DWORD  e32_mpages;                  // Module # pages
    DWORD  e32_startobj;                // Object # for instruction pointer
    DWORD  e32_eip;                     // Extended instruction pointer
    DWORD  e32_stackobj;                // Object # for stack pointer
    DWORD  e32_esp;                     // Extended stack pointer
    DWORD  e32_pagesize;                // VXD page size
    DWORD  e32_lastpagesize;            // Last page size in VXD
    DWORD  e32_fixupsize;               // Fixup section size
    DWORD  e32_fixupsum;                // Fixup section checksum
    DWORD  e32_ldrsize;                 // Loader section size
    DWORD  e32_ldrsum;                  // Loader section checksum
    DWORD  e32_objtab;                  // Object table offset
    DWORD  e32_objcnt;                  // Number of objects in module
    DWORD  e32_objmap;                  // Object page map offset
    DWORD  e32_itermap;                 // Object iterated data map offset
    DWORD  e32_rsrctab;                 // Offset of Resource Table
    DWORD  e32_rsrccnt;                 // Number of resource entries
    DWORD  e32_restab;                  // Offset of resident name table
    DWORD  e32_enttab;                  // Offset of Entry Table
    DWORD  e32_dirtab;                  // Offset of Module Directive Table
    DWORD  e32_dircnt;                  // Number of module directives
    DWORD  e32_fpagetab;                // Offset of Fixup Page Table
    DWORD  e32_frectab;                 // Offset of Fixup Record Table
    DWORD  e32_impmod;                  // Offset of Import Module Name Table
    DWORD  e32_impmodcnt;               // Number of entries in Import Module Name Table
    DWORD  e32_impproc;                 // Offset of Import Procedure Name Table
    DWORD  e32_pagesum;                 // Offset of Per-Page Checksum Table
    DWORD  e32_datapage;                // Offset of Enumerated Data Pages
    DWORD  e32_preload;                 // Number of preload pages
    DWORD  e32_nrestab;                 // Offset of Non-resident Names Table
    DWORD  e32_cbnrestab;               // Size of Non-resident Name Table
    DWORD  e32_nressum;                 // Non-resident Name Table Checksum
    DWORD  e32_autodata;                // Object # for automatic data object
    DWORD  e32_debuginfo;               // Offset of the debugging information
    DWORD  e32_debuglen;                // The length of the debugging info. in bytes
    DWORD  e32_instpreload;             // Number of instance pages in preload section of VXD file
    DWORD  e32_instdemand;              // Number of instance pages in demand load section of VXD file
    DWORD  e32_heapsize;                // Size of heap - for 16-bit apps
    BYTE   e32_res3[12];                // Reserved words
    DWORD  e32_winresoff;
    DWORD  e32_winreslen;
    WORD   e32_devid;                   // Device ID for VxD
    WORD   e32_ddkver;                  // DDK version for VxD
  } IMAGE_VXD_HEADER, *PIMAGE_VXD_HEADER;


#line 1 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\shared\\poppack.h"
/*++

Copyright (c) Microsoft Corporation.  All rights reserved.

Module Name:

    poppack.h

Abstract:

    This file turns packing of structures off.  (That is, it enables
    automatic alignment of structure fields.)  An include file is needed
    because various compilers do this in different ways.

    poppack.h is the complement to pshpack?.h.  An inclusion of poppack.h
    MUST ALWAYS be preceded by an inclusion of one of pshpack?.h, in one-to-one
    correspondence.

    For Microsoft compatible compilers, this file uses the pop option
    to the pack pragma so that it can restore the previous saved by the
    pshpack?.h include file.

--*/



#pragma warning(disable:4103)

#pragma pack(pop)


#line 33 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\shared\\poppack.h"


#line 36 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\shared\\poppack.h"
#line 37 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\shared\\poppack.h"
#line 16793 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winnt.h"
#line 16794 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winnt.h"

//
// File header format.
//

typedef struct _IMAGE_FILE_HEADER {
    WORD    Machine;
    WORD    NumberOfSections;
    DWORD   TimeDateStamp;
    DWORD   PointerToSymbolTable;
    DWORD   NumberOfSymbols;
    WORD    SizeOfOptionalHeader;
    WORD    Characteristics;
} IMAGE_FILE_HEADER, *PIMAGE_FILE_HEADER;





















































//
// Directory format.
//

typedef struct _IMAGE_DATA_DIRECTORY {
    DWORD   VirtualAddress;
    DWORD   Size;
} IMAGE_DATA_DIRECTORY, *PIMAGE_DATA_DIRECTORY;



//
// Optional header format.
//

typedef struct _IMAGE_OPTIONAL_HEADER {
    //
    // Standard fields.
    //

    WORD    Magic;
    BYTE    MajorLinkerVersion;
    BYTE    MinorLinkerVersion;
    DWORD   SizeOfCode;
    DWORD   SizeOfInitializedData;
    DWORD   SizeOfUninitializedData;
    DWORD   AddressOfEntryPoint;
    DWORD   BaseOfCode;
    DWORD   BaseOfData;

    //
    // NT additional fields.
    //

    DWORD   ImageBase;
    DWORD   SectionAlignment;
    DWORD   FileAlignment;
    WORD    MajorOperatingSystemVersion;
    WORD    MinorOperatingSystemVersion;
    WORD    MajorImageVersion;
    WORD    MinorImageVersion;
    WORD    MajorSubsystemVersion;
    WORD    MinorSubsystemVersion;
    DWORD   Win32VersionValue;
    DWORD   SizeOfImage;
    DWORD   SizeOfHeaders;
    DWORD   CheckSum;
    WORD    Subsystem;
    WORD    DllCharacteristics;
    DWORD   SizeOfStackReserve;
    DWORD   SizeOfStackCommit;
    DWORD   SizeOfHeapReserve;
    DWORD   SizeOfHeapCommit;
    DWORD   LoaderFlags;
    DWORD   NumberOfRvaAndSizes;
    IMAGE_DATA_DIRECTORY DataDirectory[16 ];
} IMAGE_OPTIONAL_HEADER32, *PIMAGE_OPTIONAL_HEADER32;

typedef struct _IMAGE_ROM_OPTIONAL_HEADER {
    WORD   Magic;
    BYTE   MajorLinkerVersion;
    BYTE   MinorLinkerVersion;
    DWORD  SizeOfCode;
    DWORD  SizeOfInitializedData;
    DWORD  SizeOfUninitializedData;
    DWORD  AddressOfEntryPoint;
    DWORD  BaseOfCode;
    DWORD  BaseOfData;
    DWORD  BaseOfBss;
    DWORD  GprMask;
    DWORD  CprMask[4];
    DWORD  GpValue;
} IMAGE_ROM_OPTIONAL_HEADER, *PIMAGE_ROM_OPTIONAL_HEADER;

typedef struct _IMAGE_OPTIONAL_HEADER64 {
    WORD        Magic;
    BYTE        MajorLinkerVersion;
    BYTE        MinorLinkerVersion;
    DWORD       SizeOfCode;
    DWORD       SizeOfInitializedData;
    DWORD       SizeOfUninitializedData;
    DWORD       AddressOfEntryPoint;
    DWORD       BaseOfCode;
    ULONGLONG   ImageBase;
    DWORD       SectionAlignment;
    DWORD       FileAlignment;
    WORD        MajorOperatingSystemVersion;
    WORD        MinorOperatingSystemVersion;
    WORD        MajorImageVersion;
    WORD        MinorImageVersion;
    WORD        MajorSubsystemVersion;
    WORD        MinorSubsystemVersion;
    DWORD       Win32VersionValue;
    DWORD       SizeOfImage;
    DWORD       SizeOfHeaders;
    DWORD       CheckSum;
    WORD        Subsystem;
    WORD        DllCharacteristics;
    ULONGLONG   SizeOfStackReserve;
    ULONGLONG   SizeOfStackCommit;
    ULONGLONG   SizeOfHeapReserve;
    ULONGLONG   SizeOfHeapCommit;
    DWORD       LoaderFlags;
    DWORD       NumberOfRvaAndSizes;
    IMAGE_DATA_DIRECTORY DataDirectory[16 ];
} IMAGE_OPTIONAL_HEADER64, *PIMAGE_OPTIONAL_HEADER64;






typedef IMAGE_OPTIONAL_HEADER64             IMAGE_OPTIONAL_HEADER;
typedef PIMAGE_OPTIONAL_HEADER64            PIMAGE_OPTIONAL_HEADER;





#line 16981 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winnt.h"

typedef struct _IMAGE_NT_HEADERS64 {
    DWORD Signature;
    IMAGE_FILE_HEADER FileHeader;
    IMAGE_OPTIONAL_HEADER64 OptionalHeader;
} IMAGE_NT_HEADERS64, *PIMAGE_NT_HEADERS64;

typedef struct _IMAGE_NT_HEADERS {
    DWORD Signature;
    IMAGE_FILE_HEADER FileHeader;
    IMAGE_OPTIONAL_HEADER32 OptionalHeader;
} IMAGE_NT_HEADERS32, *PIMAGE_NT_HEADERS32;

typedef struct _IMAGE_ROM_HEADERS {
    IMAGE_FILE_HEADER FileHeader;
    IMAGE_ROM_OPTIONAL_HEADER OptionalHeader;
} IMAGE_ROM_HEADERS, *PIMAGE_ROM_HEADERS;


typedef IMAGE_NT_HEADERS64                  IMAGE_NT_HEADERS;
typedef PIMAGE_NT_HEADERS64                 PIMAGE_NT_HEADERS;



#line 17006 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winnt.h"

// IMAGE_FIRST_SECTION doesn't need 32/64 versions since the file header is the same either way.







// Subsystem Values

















// DllCharacteristics Entries

//      IMAGE_LIBRARY_PROCESS_INIT            0x0001     // Reserved.
//      IMAGE_LIBRARY_PROCESS_TERM            0x0002     // Reserved.
//      IMAGE_LIBRARY_THREAD_INIT             0x0004     // Reserved.
//      IMAGE_LIBRARY_THREAD_TERM             0x0008     // Reserved.












// Directory Entries








//      IMAGE_DIRECTORY_ENTRY_COPYRIGHT       7   // (X86 usage)









//
// Non-COFF Object file header
//

typedef struct ANON_OBJECT_HEADER {
    WORD    Sig1;            // Must be IMAGE_FILE_MACHINE_UNKNOWN
    WORD    Sig2;            // Must be 0xffff
    WORD    Version;         // >= 1 (implies the CLSID field is present)
    WORD    Machine;
    DWORD   TimeDateStamp;
    CLSID   ClassID;         // Used to invoke CoCreateInstance
    DWORD   SizeOfData;      // Size of data that follows the header
} ANON_OBJECT_HEADER;

typedef struct ANON_OBJECT_HEADER_V2 {
    WORD    Sig1;            // Must be IMAGE_FILE_MACHINE_UNKNOWN
    WORD    Sig2;            // Must be 0xffff
    WORD    Version;         // >= 2 (implies the Flags field is present - otherwise V1)
    WORD    Machine;
    DWORD   TimeDateStamp;
    CLSID   ClassID;         // Used to invoke CoCreateInstance
    DWORD   SizeOfData;      // Size of data that follows the header
    DWORD   Flags;           // 0x1 -> contains metadata
    DWORD   MetaDataSize;    // Size of CLR metadata
    DWORD   MetaDataOffset;  // Offset of CLR metadata
} ANON_OBJECT_HEADER_V2;

typedef struct ANON_OBJECT_HEADER_BIGOBJ {
   /* same as ANON_OBJECT_HEADER_V2 */
    WORD    Sig1;            // Must be IMAGE_FILE_MACHINE_UNKNOWN
    WORD    Sig2;            // Must be 0xffff
    WORD    Version;         // >= 2 (implies the Flags field is present)
    WORD    Machine;         // Actual machine - IMAGE_FILE_MACHINE_xxx
    DWORD   TimeDateStamp;
    CLSID   ClassID;         // {D1BAA1C7-BAEE-4ba9-AF20-FAF66AA4DCB8}
    DWORD   SizeOfData;      // Size of data that follows the header
    DWORD   Flags;           // 0x1 -> contains metadata
    DWORD   MetaDataSize;    // Size of CLR metadata
    DWORD   MetaDataOffset;  // Offset of CLR metadata

    /* bigobj specifics */
    DWORD   NumberOfSections; // extended from WORD
    DWORD   PointerToSymbolTable;
    DWORD   NumberOfSymbols;
} ANON_OBJECT_HEADER_BIGOBJ;

//
// Section header format.
//



typedef struct _IMAGE_SECTION_HEADER {
    BYTE    Name[8 ];
    union {
            DWORD   PhysicalAddress;
            DWORD   VirtualSize;
    } Misc;
    DWORD   VirtualAddress;
    DWORD   SizeOfRawData;
    DWORD   PointerToRawData;
    DWORD   PointerToRelocations;
    DWORD   PointerToLinenumbers;
    WORD    NumberOfRelocations;
    WORD    NumberOfLinenumbers;
    DWORD   Characteristics;
} IMAGE_SECTION_HEADER, *PIMAGE_SECTION_HEADER;



//
// Section characteristics.
//
//      IMAGE_SCN_TYPE_REG                   0x00000000  // Reserved.
//      IMAGE_SCN_TYPE_DSECT                 0x00000001  // Reserved.
//      IMAGE_SCN_TYPE_NOLOAD                0x00000002  // Reserved.
//      IMAGE_SCN_TYPE_GROUP                 0x00000004  // Reserved.

//      IMAGE_SCN_TYPE_COPY                  0x00000010  // Reserved.







//      IMAGE_SCN_TYPE_OVER                  0x00000400  // Reserved.


//                                           0x00002000  // Reserved.
//      IMAGE_SCN_MEM_PROTECTED - Obsolete   0x00004000



//      IMAGE_SCN_MEM_SYSHEAP  - Obsolete    0x00010000



















// Unused                                    0x00F00000











//
// TLS Characteristic Flags
//



#line 1 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\shared\\pshpack2.h"
/*++

Copyright (c) Microsoft Corporation.  All rights reserved.

Module Name:

    pshpack2.h

Abstract:

    This file turns 2 byte packing of structures on.  (That is, it disables
    automatic alignment of structure fields.)  An include file is needed
    because various compilers do this in different ways.  For Microsoft
    compatible compilers, this files uses the push option to the pack pragma
    so that the poppack.h include file can restore the previous packing
    reliably.

    The file poppack.h is the complement to this file.

--*/



#pragma warning(disable:4103)

#pragma pack(push,2)


#line 30 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\shared\\pshpack2.h"


#line 33 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\shared\\pshpack2.h"
#line 34 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\shared\\pshpack2.h"
#line 17203 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winnt.h"
#line 17204 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winnt.h"

//
// Symbol format.
//

typedef struct _IMAGE_SYMBOL {
    union {
        BYTE    ShortName[8];
        struct {
            DWORD   Short;     // if 0, use LongName
            DWORD   Long;      // offset into string table
        } Name;
        DWORD   LongName[2];    // PBYTE [2]
    } N;
    DWORD   Value;
    SHORT   SectionNumber;
    WORD    Type;
    BYTE    StorageClass;
    BYTE    NumberOfAuxSymbols;
} IMAGE_SYMBOL;
typedef IMAGE_SYMBOL __unaligned *PIMAGE_SYMBOL;



typedef struct _IMAGE_SYMBOL_EX {
    union {
        BYTE     ShortName[8];
        struct {
            DWORD   Short;     // if 0, use LongName
            DWORD   Long;      // offset into string table
        } Name;
        DWORD   LongName[2];    // PBYTE  [2]
    } N;
    DWORD   Value;
    LONG    SectionNumber;
    WORD    Type;
    BYTE    StorageClass;
    BYTE    NumberOfAuxSymbols;
} IMAGE_SYMBOL_EX;
typedef IMAGE_SYMBOL_EX __unaligned *PIMAGE_SYMBOL_EX;

//
// Section values.
//
// Symbols have a section number of the section in which they are
// defined. Otherwise, section numbers have the following meanings:
//







//
// Type (fundamental) values.
//


















//
// Type (derived) values.
//






//
// Storage classes.
//



























// new





// type packing constants







// MACROS

// Basic Type of  x


// Is x a pointer?


#line 17341 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winnt.h"

// Is x a function?


#line 17346 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winnt.h"

// Is x an array?



#line 17352 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winnt.h"

// Is x a structure, union, or enumeration TAG?


#line 17357 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winnt.h"



#line 17361 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winnt.h"


#line 17364 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winnt.h"

#line 1 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\shared\\pshpack2.h"
/*++

Copyright (c) Microsoft Corporation.  All rights reserved.

Module Name:

    pshpack2.h

Abstract:

    This file turns 2 byte packing of structures on.  (That is, it disables
    automatic alignment of structure fields.)  An include file is needed
    because various compilers do this in different ways.  For Microsoft
    compatible compilers, this files uses the push option to the pack pragma
    so that the poppack.h include file can restore the previous packing
    reliably.

    The file poppack.h is the complement to this file.

--*/



#pragma warning(disable:4103)

#pragma pack(push,2)


#line 30 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\shared\\pshpack2.h"


#line 33 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\shared\\pshpack2.h"
#line 34 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\shared\\pshpack2.h"
#line 17366 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winnt.h"

typedef struct IMAGE_AUX_SYMBOL_TOKEN_DEF {
    BYTE  bAuxType;                  // IMAGE_AUX_SYMBOL_TYPE
    BYTE  bReserved;                 // Must be 0
    DWORD SymbolTableIndex;
    BYTE  rgbReserved[12];           // Must be 0
} IMAGE_AUX_SYMBOL_TOKEN_DEF;

typedef IMAGE_AUX_SYMBOL_TOKEN_DEF __unaligned *PIMAGE_AUX_SYMBOL_TOKEN_DEF;

#line 1 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\shared\\poppack.h"
/*++

Copyright (c) Microsoft Corporation.  All rights reserved.

Module Name:

    poppack.h

Abstract:

    This file turns packing of structures off.  (That is, it enables
    automatic alignment of structure fields.)  An include file is needed
    because various compilers do this in different ways.

    poppack.h is the complement to pshpack?.h.  An inclusion of poppack.h
    MUST ALWAYS be preceded by an inclusion of one of pshpack?.h, in one-to-one
    correspondence.

    For Microsoft compatible compilers, this file uses the pop option
    to the pack pragma so that it can restore the previous saved by the
    pshpack?.h include file.

--*/



#pragma warning(disable:4103)

#pragma pack(pop)


#line 33 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\shared\\poppack.h"


#line 36 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\shared\\poppack.h"
#line 37 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\shared\\poppack.h"
#line 17377 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winnt.h"

//
// Auxiliary entry format.
//

typedef union _IMAGE_AUX_SYMBOL {
    struct {
        DWORD    TagIndex;                      // struct, union, or enum tag index
        union {
            struct {
                WORD    Linenumber;             // declaration line number
                WORD    Size;                   // size of struct, union, or enum
            } LnSz;
           DWORD    TotalSize;
        } Misc;
        union {
            struct {                            // if ISFCN, tag, or .bb
                DWORD    PointerToLinenumber;
                DWORD    PointerToNextFunction;
            } Function;
            struct {                            // if ISARY, up to 4 dimen.
                WORD     Dimension[4];
            } Array;
        } FcnAry;
        WORD    TvIndex;                        // tv index
    } Sym;
    struct {
        BYTE    Name[18 ];
    } File;
    struct {
        DWORD   Length;                         // section length
        WORD    NumberOfRelocations;            // number of relocation entries
        WORD    NumberOfLinenumbers;            // number of line numbers
        DWORD   CheckSum;                       // checksum for communal
        SHORT   Number;                         // section number to associate with
        BYTE    Selection;                      // communal selection type
	BYTE    bReserved;
	SHORT   HighNumber;                     // high bits of the section number
    } Section;
    IMAGE_AUX_SYMBOL_TOKEN_DEF TokenDef;
    struct {
        DWORD crc;
        BYTE  rgbReserved[14];
    } CRC;
} IMAGE_AUX_SYMBOL;
typedef IMAGE_AUX_SYMBOL __unaligned *PIMAGE_AUX_SYMBOL;

typedef union _IMAGE_AUX_SYMBOL_EX {
    struct {
        DWORD   WeakDefaultSymIndex;                       // the weak extern default symbol index
        DWORD   WeakSearchType;
        BYTE    rgbReserved[12];
    } Sym;
    struct {
        BYTE    Name[sizeof(IMAGE_SYMBOL_EX)];
    } File;
    struct {
        DWORD   Length;                         // section length
        WORD    NumberOfRelocations;            // number of relocation entries
        WORD    NumberOfLinenumbers;            // number of line numbers
        DWORD   CheckSum;                       // checksum for communal
        SHORT   Number;                         // section number to associate with
        BYTE    Selection;                      // communal selection type
        BYTE    bReserved;
        SHORT   HighNumber;                     // high bits of the section number
        BYTE    rgbReserved[2];
    } Section;
    struct{
        IMAGE_AUX_SYMBOL_TOKEN_DEF TokenDef;
        BYTE  rgbReserved[2];
    }  ;
    struct {
        DWORD crc;
        BYTE  rgbReserved[16];
    } CRC;
} IMAGE_AUX_SYMBOL_EX;
typedef IMAGE_AUX_SYMBOL_EX __unaligned *PIMAGE_AUX_SYMBOL_EX;

typedef enum IMAGE_AUX_SYMBOL_TYPE {
    IMAGE_AUX_SYMBOL_TYPE_TOKEN_DEF = 1,
} IMAGE_AUX_SYMBOL_TYPE;


//
// Communal selection types.
//














//
// Relocation format.
//

typedef struct _IMAGE_RELOCATION {
    union {
        DWORD   VirtualAddress;
        DWORD   RelocCount;             // Set to the real count when IMAGE_SCN_LNK_NRELOC_OVFL is set
    }  ;
    DWORD   SymbolTableIndex;
    WORD    Type;
} IMAGE_RELOCATION;
typedef IMAGE_RELOCATION __unaligned *PIMAGE_RELOCATION;

//
// I386 relocation types.
//












//
// MIPS relocation types.
//

















//
// Alpha Relocation types.
//

























//
// IBM PowerPC relocation types.
//



























// Flag bits in IMAGE_RELOCATION.TYPE






//
// Hitachi SH3 relocation types.
//




















                                                //  instruction in longwords
                                                //  if not NOMODE, insert the
                                                //  inverse of the low bit at
                                                //  bit 32 to select PTA/PTB











































//
// ARM64 relocations types.
//


















//
// x64 relocations
//





























//
// IA64 relocation types.
//















//















//
// CEF relocation types.
//








//
// clr relocation types.
//
































































































































//
// Line number format.
//

typedef struct _IMAGE_LINENUMBER {
    union {
        DWORD   SymbolTableIndex;               // Symbol table index of function name if Linenumber is 0.
        DWORD   VirtualAddress;                 // Virtual address of line number.
    } Type;
    WORD    Linenumber;                         // Line number.
} IMAGE_LINENUMBER;
typedef IMAGE_LINENUMBER __unaligned *PIMAGE_LINENUMBER;


#line 1 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\shared\\poppack.h"
/*++

Copyright (c) Microsoft Corporation.  All rights reserved.

Module Name:

    poppack.h

Abstract:

    This file turns packing of structures off.  (That is, it enables
    automatic alignment of structure fields.)  An include file is needed
    because various compilers do this in different ways.

    poppack.h is the complement to pshpack?.h.  An inclusion of poppack.h
    MUST ALWAYS be preceded by an inclusion of one of pshpack?.h, in one-to-one
    correspondence.

    For Microsoft compatible compilers, this file uses the pop option
    to the pack pragma so that it can restore the previous saved by the
    pshpack?.h include file.

--*/



#pragma warning(disable:4103)

#pragma pack(pop)


#line 33 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\shared\\poppack.h"


#line 36 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\shared\\poppack.h"
#line 37 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\shared\\poppack.h"
#line 17905 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winnt.h"
#line 17906 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winnt.h"

//
// Based relocation format.
//

//@[comment("MVI_tracked")]
typedef struct _IMAGE_BASE_RELOCATION {
    DWORD   VirtualAddress;
    DWORD   SizeOfBlock;
//  WORD    TypeOffset[1];
} IMAGE_BASE_RELOCATION;
typedef IMAGE_BASE_RELOCATION __unaligned * PIMAGE_BASE_RELOCATION;

//
// Based relocation types.
//













//
// Platform-specific based relocation types.
//










//
// Archive format.
//










typedef struct _IMAGE_ARCHIVE_MEMBER_HEADER {
    BYTE     Name[16];                          // File member name - `/' terminated.
    BYTE     Date[12];                          // File member date - decimal.
    BYTE     UserID[6];                         // File member user id - decimal.
    BYTE     GroupID[6];                        // File member group id - decimal.
    BYTE     Mode[8];                           // File member mode - octal.
    BYTE     Size[10];                          // File member size - decimal.
    BYTE     EndHeader[2];                      // String to end header.
} IMAGE_ARCHIVE_MEMBER_HEADER, *PIMAGE_ARCHIVE_MEMBER_HEADER;



//
// DLL support.
//

//
// Export Format
//

//@[comment("MVI_tracked")]
typedef struct _IMAGE_EXPORT_DIRECTORY {
    DWORD   Characteristics;
    DWORD   TimeDateStamp;
    WORD    MajorVersion;
    WORD    MinorVersion;
    DWORD   Name;
    DWORD   Base;
    DWORD   NumberOfFunctions;
    DWORD   NumberOfNames;
    DWORD   AddressOfFunctions;     // RVA from base of image
    DWORD   AddressOfNames;         // RVA from base of image
    DWORD   AddressOfNameOrdinals;  // RVA from base of image
} IMAGE_EXPORT_DIRECTORY, *PIMAGE_EXPORT_DIRECTORY;

//
// Import Format
//

//@[comment("MVI_tracked")]
typedef struct _IMAGE_IMPORT_BY_NAME {
    WORD    Hint;
    CHAR   Name[1];
} IMAGE_IMPORT_BY_NAME, *PIMAGE_IMPORT_BY_NAME;

#line 1 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\shared\\pshpack8.h"
/*++

Copyright (c) Microsoft Corporation.  All rights reserved.

Module Name:

    pshpack8.h

Abstract:

    This file turns 8 byte packing of structures on.  (That is, it disables
    automatic alignment of structure fields.)  An include file is needed
    because various compilers do this in different ways.  For Microsoft
    compatible compilers, this files uses the push option to the pack pragma
    so that the poppack.h include file can restore the previous packing
    reliably.

    The file poppack.h is the complement to this file.

--*/



#pragma warning(disable:4103)

#pragma pack(push,8)


#line 30 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\shared\\pshpack8.h"


#line 33 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\shared\\pshpack8.h"
#line 34 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\shared\\pshpack8.h"
#line 18007 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winnt.h"

typedef struct _IMAGE_THUNK_DATA64 {
    union {
        ULONGLONG ForwarderString;  // PBYTE 
        ULONGLONG Function;         // PDWORD
        ULONGLONG Ordinal;
        ULONGLONG AddressOfData;    // PIMAGE_IMPORT_BY_NAME
    } u1;
} IMAGE_THUNK_DATA64;
typedef IMAGE_THUNK_DATA64 * PIMAGE_THUNK_DATA64;

#line 1 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\shared\\poppack.h"
/*++

Copyright (c) Microsoft Corporation.  All rights reserved.

Module Name:

    poppack.h

Abstract:

    This file turns packing of structures off.  (That is, it enables
    automatic alignment of structure fields.)  An include file is needed
    because various compilers do this in different ways.

    poppack.h is the complement to pshpack?.h.  An inclusion of poppack.h
    MUST ALWAYS be preceded by an inclusion of one of pshpack?.h, in one-to-one
    correspondence.

    For Microsoft compatible compilers, this file uses the pop option
    to the pack pragma so that it can restore the previous saved by the
    pshpack?.h include file.

--*/



#pragma warning(disable:4103)

#pragma pack(pop)


#line 33 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\shared\\poppack.h"


#line 36 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\shared\\poppack.h"
#line 37 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\shared\\poppack.h"
#line 18019 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winnt.h"

typedef struct _IMAGE_THUNK_DATA32 {
    union {
        DWORD ForwarderString;      // PBYTE 
        DWORD Function;             // PDWORD
        DWORD Ordinal;
        DWORD AddressOfData;        // PIMAGE_IMPORT_BY_NAME
    } u1;
} IMAGE_THUNK_DATA32;
typedef IMAGE_THUNK_DATA32 * PIMAGE_THUNK_DATA32;








//
// Thread Local Storage
//

typedef void
(__stdcall *PIMAGE_TLS_CALLBACK) (
    PVOID DllHandle,
    DWORD Reason,
    PVOID Reserved
    );

typedef struct _IMAGE_TLS_DIRECTORY64 {
    ULONGLONG StartAddressOfRawData;
    ULONGLONG EndAddressOfRawData;
    ULONGLONG AddressOfIndex;         // PDWORD
    ULONGLONG AddressOfCallBacks;     // PIMAGE_TLS_CALLBACK *;
    DWORD SizeOfZeroFill;
    union {
        DWORD Characteristics;
        struct {
            DWORD Reserved0 : 20;
            DWORD Alignment : 4;
            DWORD Reserved1 : 8;
        }  ;
    }  ;

} IMAGE_TLS_DIRECTORY64;

typedef IMAGE_TLS_DIRECTORY64 * PIMAGE_TLS_DIRECTORY64;

typedef struct _IMAGE_TLS_DIRECTORY32 {
    DWORD   StartAddressOfRawData;
    DWORD   EndAddressOfRawData;
    DWORD   AddressOfIndex;             // PDWORD
    DWORD   AddressOfCallBacks;         // PIMAGE_TLS_CALLBACK *
    DWORD   SizeOfZeroFill;
    union {
        DWORD Characteristics;
        struct {
            DWORD Reserved0 : 20;
            DWORD Alignment : 4;
            DWORD Reserved1 : 8;
        }  ;
    }  ;

} IMAGE_TLS_DIRECTORY32;
typedef IMAGE_TLS_DIRECTORY32 * PIMAGE_TLS_DIRECTORY32;




typedef IMAGE_THUNK_DATA64              IMAGE_THUNK_DATA;
typedef PIMAGE_THUNK_DATA64             PIMAGE_THUNK_DATA;

typedef IMAGE_TLS_DIRECTORY64           IMAGE_TLS_DIRECTORY;
typedef PIMAGE_TLS_DIRECTORY64          PIMAGE_TLS_DIRECTORY;








#line 18102 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winnt.h"

////@[comment("MVI_tracked")]
typedef struct _IMAGE_IMPORT_DESCRIPTOR {
    union {
        DWORD   Characteristics;            // 0 for terminating null import descriptor
        DWORD   OriginalFirstThunk;         // RVA to original unbound IAT (PIMAGE_THUNK_DATA)
    }  ;
    DWORD   TimeDateStamp;                  // 0 if not bound,
                                            // -1 if bound, and real date\time stamp
                                            //     in IMAGE_DIRECTORY_ENTRY_BOUND_IMPORT (new BIND)
                                            // O.W. date/time stamp of DLL bound to (Old BIND)

    DWORD   ForwarderChain;                 // -1 if no forwarders
    DWORD   Name;
    DWORD   FirstThunk;                     // RVA to IAT (if bound this IAT has actual addresses)
} IMAGE_IMPORT_DESCRIPTOR;
typedef IMAGE_IMPORT_DESCRIPTOR __unaligned *PIMAGE_IMPORT_DESCRIPTOR;

//
// New format import descriptors pointed to by DataDirectory[ IMAGE_DIRECTORY_ENTRY_BOUND_IMPORT ]
//

typedef struct _IMAGE_BOUND_IMPORT_DESCRIPTOR {
    DWORD   TimeDateStamp;
    WORD    OffsetModuleName;
    WORD    NumberOfModuleForwarderRefs;
// Array of zero or more IMAGE_BOUND_FORWARDER_REF follows
} IMAGE_BOUND_IMPORT_DESCRIPTOR,  *PIMAGE_BOUND_IMPORT_DESCRIPTOR;

typedef struct _IMAGE_BOUND_FORWARDER_REF {
    DWORD   TimeDateStamp;
    WORD    OffsetModuleName;
    WORD    Reserved;
} IMAGE_BOUND_FORWARDER_REF, *PIMAGE_BOUND_FORWARDER_REF;

typedef struct _IMAGE_DELAYLOAD_DESCRIPTOR {
    union {
        DWORD AllAttributes;
        struct {
            DWORD RvaBased : 1;             // Delay load version 2
            DWORD ReservedAttributes : 31;
        }  ;
    } Attributes;

    DWORD DllNameRVA;                       // RVA to the name of the target library (NULL-terminate ASCII string)
    DWORD ModuleHandleRVA;                  // RVA to the HMODULE caching location (PHMODULE)
    DWORD ImportAddressTableRVA;            // RVA to the start of the IAT (PIMAGE_THUNK_DATA)
    DWORD ImportNameTableRVA;               // RVA to the start of the name table (PIMAGE_THUNK_DATA::AddressOfData)
    DWORD BoundImportAddressTableRVA;       // RVA to an optional bound IAT
    DWORD UnloadInformationTableRVA;        // RVA to an optional unload info table
    DWORD TimeDateStamp;                    // 0 if not bound,
                                            // Otherwise, date/time of the target DLL

} IMAGE_DELAYLOAD_DESCRIPTOR, *PIMAGE_DELAYLOAD_DESCRIPTOR;

typedef const IMAGE_DELAYLOAD_DESCRIPTOR *PCIMAGE_DELAYLOAD_DESCRIPTOR;

//
// Resource Format.
//

//
// Resource directory consists of two counts, following by a variable length
// array of directory entries.  The first count is the number of entries at
// beginning of the array that have actual names associated with each entry.
// The entries are in ascending order, case insensitive strings.  The second
// count is the number of entries that immediately follow the named entries.
// This second count identifies the number of entries that have 16-bit integer
// Ids as their name.  These entries are also sorted in ascending order.
//
// This structure allows fast lookup by either name or number, but for any
// given resource entry only one form of lookup is supported, not both.
// This is consistant with the syntax of the .RC file and the .RES file.
//

typedef struct _IMAGE_RESOURCE_DIRECTORY {
    DWORD   Characteristics;
    DWORD   TimeDateStamp;
    WORD    MajorVersion;
    WORD    MinorVersion;
    WORD    NumberOfNamedEntries;
    WORD    NumberOfIdEntries;
//  IMAGE_RESOURCE_DIRECTORY_ENTRY DirectoryEntries[];
} IMAGE_RESOURCE_DIRECTORY, *PIMAGE_RESOURCE_DIRECTORY;



//
// Each directory contains the 32-bit Name of the entry and an offset,
// relative to the beginning of the resource directory of the data associated
// with this directory entry.  If the name of the entry is an actual text
// string instead of an integer Id, then the high order bit of the name field
// is set to one and the low order 31-bits are an offset, relative to the
// beginning of the resource directory of the string, which is of type
// IMAGE_RESOURCE_DIRECTORY_STRING.  Otherwise the high bit is clear and the
// low-order 16-bits are the integer Id that identify this resource directory
// entry. If the directory entry is yet another resource directory (i.e. a
// subdirectory), then the high order bit of the offset field will be
// set to indicate this.  Otherwise the high bit is clear and the offset
// field points to a resource data entry.
//

////@[comment("MVI_tracked")]
typedef struct _IMAGE_RESOURCE_DIRECTORY_ENTRY {
    union {
        struct {
            DWORD NameOffset:31;
            DWORD NameIsString:1;
        }  ;
        DWORD   Name;
        WORD    Id;
    }  ;
    union {
        DWORD   OffsetToData;
        struct {
            DWORD   OffsetToDirectory:31;
            DWORD   DataIsDirectory:1;
        }  ;
    }  ;
} IMAGE_RESOURCE_DIRECTORY_ENTRY, *PIMAGE_RESOURCE_DIRECTORY_ENTRY;

//
// For resource directory entries that have actual string names, the Name
// field of the directory entry points to an object of the following type.
// All of these string objects are stored together after the last resource
// directory entry and before the first resource data object.  This minimizes
// the impact of these variable length objects on the alignment of the fixed
// size directory entry objects.
//

typedef struct _IMAGE_RESOURCE_DIRECTORY_STRING {
    WORD    Length;
    CHAR    NameString[ 1 ];
} IMAGE_RESOURCE_DIRECTORY_STRING, *PIMAGE_RESOURCE_DIRECTORY_STRING;


typedef struct _IMAGE_RESOURCE_DIR_STRING_U {
    WORD    Length;
    WCHAR   NameString[ 1 ];
} IMAGE_RESOURCE_DIR_STRING_U, *PIMAGE_RESOURCE_DIR_STRING_U;


//
// Each resource data entry describes a leaf node in the resource directory
// tree.  It contains an offset, relative to the beginning of the resource
// directory of the data for the resource, a size field that gives the number
// of bytes of data at that offset, a CodePage that should be used when
// decoding code point values within the resource data.  Typically for new
// applications the code page would be the unicode code page.
//

//@[comment("MVI_tracked")]
typedef struct _IMAGE_RESOURCE_DATA_ENTRY {
    DWORD   OffsetToData;
    DWORD   Size;
    DWORD   CodePage;
    DWORD   Reserved;
} IMAGE_RESOURCE_DATA_ENTRY, *PIMAGE_RESOURCE_DATA_ENTRY;

// begin_ntoshvp

//
// Code Integrity in loadconfig (CI)
//

typedef struct _IMAGE_LOAD_CONFIG_CODE_INTEGRITY {
    WORD    Flags;          // Flags to indicate if CI information is available, etc.
    WORD    Catalog;        // 0xFFFF means not available
    DWORD   CatalogOffset;
    DWORD   Reserved;       // Additional bitmask to be defined later
} IMAGE_LOAD_CONFIG_CODE_INTEGRITY, *PIMAGE_LOAD_CONFIG_CODE_INTEGRITY;

//
// Dynamic value relocation table in loadconfig
//

typedef struct _IMAGE_DYNAMIC_RELOCATION_TABLE {
    DWORD Version;
    DWORD Size;
//  IMAGE_DYNAMIC_RELOCATION DynamicRelocations[0];
} IMAGE_DYNAMIC_RELOCATION_TABLE, *PIMAGE_DYNAMIC_RELOCATION_TABLE;

//
// Dynamic value relocation entries following IMAGE_DYNAMIC_RELOCATION_TABLE
//

#line 1 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\shared\\pshpack1.h"
/*++

Copyright (c) Microsoft Corporation.  All rights reserved.

Module Name:

    pshpack1.h

Abstract:

    This file turns 1 byte packing of structures on.  (That is, it disables
    automatic alignment of structure fields.)  An include file is needed
    because various compilers do this in different ways.  For Microsoft
    compatible compilers, this files uses the push option to the pack pragma
    so that the poppack.h include file can restore the previous packing
    reliably.

    The file poppack.h is the complement to this file.

--*/



#pragma warning(disable:4103)

#pragma pack(push,1)


#line 30 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\shared\\pshpack1.h"


#line 33 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\shared\\pshpack1.h"
#line 34 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\shared\\pshpack1.h"
#line 18289 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winnt.h"

typedef struct _IMAGE_DYNAMIC_RELOCATION32 {
    DWORD      Symbol;
    DWORD      BaseRelocSize;
//  IMAGE_BASE_RELOCATION BaseRelocations[0];
} IMAGE_DYNAMIC_RELOCATION32, *PIMAGE_DYNAMIC_RELOCATION32;

typedef struct _IMAGE_DYNAMIC_RELOCATION64 {
    ULONGLONG  Symbol;
    DWORD      BaseRelocSize;
//  IMAGE_BASE_RELOCATION BaseRelocations[0];
} IMAGE_DYNAMIC_RELOCATION64, *PIMAGE_DYNAMIC_RELOCATION64;

typedef struct _IMAGE_DYNAMIC_RELOCATION32_V2 {
    DWORD      HeaderSize;
    DWORD      FixupInfoSize;
    DWORD      Symbol;
    DWORD      SymbolGroup;
    DWORD      Flags;
    // ...     variable length header fields
    // BYTE    FixupInfo[FixupInfoSize]
} IMAGE_DYNAMIC_RELOCATION32_V2, *PIMAGE_DYNAMIC_RELOCATION32_V2;

typedef struct _IMAGE_DYNAMIC_RELOCATION64_V2 {
    DWORD      HeaderSize;
    DWORD      FixupInfoSize;
    ULONGLONG  Symbol;
    DWORD      SymbolGroup;
    DWORD      Flags;
    // ...     variable length header fields
    // BYTE    FixupInfo[FixupInfoSize]
} IMAGE_DYNAMIC_RELOCATION64_V2, *PIMAGE_DYNAMIC_RELOCATION64_V2;

#line 1 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\shared\\poppack.h"
/*++

Copyright (c) Microsoft Corporation.  All rights reserved.

Module Name:

    poppack.h

Abstract:

    This file turns packing of structures off.  (That is, it enables
    automatic alignment of structure fields.)  An include file is needed
    because various compilers do this in different ways.

    poppack.h is the complement to pshpack?.h.  An inclusion of poppack.h
    MUST ALWAYS be preceded by an inclusion of one of pshpack?.h, in one-to-one
    correspondence.

    For Microsoft compatible compilers, this file uses the pop option
    to the pack pragma so that it can restore the previous saved by the
    pshpack?.h include file.

--*/



#pragma warning(disable:4103)

#pragma pack(pop)


#line 33 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\shared\\poppack.h"


#line 36 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\shared\\poppack.h"
#line 37 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\shared\\poppack.h"
#line 18323 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winnt.h"


typedef IMAGE_DYNAMIC_RELOCATION64          IMAGE_DYNAMIC_RELOCATION;
typedef PIMAGE_DYNAMIC_RELOCATION64         PIMAGE_DYNAMIC_RELOCATION;
typedef IMAGE_DYNAMIC_RELOCATION64_V2       IMAGE_DYNAMIC_RELOCATION_V2;
typedef PIMAGE_DYNAMIC_RELOCATION64_V2      PIMAGE_DYNAMIC_RELOCATION_V2;





#line 18335 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winnt.h"

//
// Defined symbolic dynamic relocation entries.
//







#line 1 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\shared\\pshpack1.h"
/*++

Copyright (c) Microsoft Corporation.  All rights reserved.

Module Name:

    pshpack1.h

Abstract:

    This file turns 1 byte packing of structures on.  (That is, it disables
    automatic alignment of structure fields.)  An include file is needed
    because various compilers do this in different ways.  For Microsoft
    compatible compilers, this files uses the push option to the pack pragma
    so that the poppack.h include file can restore the previous packing
    reliably.

    The file poppack.h is the complement to this file.

--*/



#pragma warning(disable:4103)

#pragma pack(push,1)


#line 30 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\shared\\pshpack1.h"


#line 33 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\shared\\pshpack1.h"
#line 34 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\shared\\pshpack1.h"
#line 18347 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winnt.h"

typedef struct _IMAGE_PROLOGUE_DYNAMIC_RELOCATION_HEADER {
    BYTE       PrologueByteCount;
    // BYTE    PrologueBytes[PrologueByteCount];
} IMAGE_PROLOGUE_DYNAMIC_RELOCATION_HEADER;
typedef IMAGE_PROLOGUE_DYNAMIC_RELOCATION_HEADER __unaligned * PIMAGE_PROLOGUE_DYNAMIC_RELOCATION_HEADER;

typedef struct _IMAGE_EPILOGUE_DYNAMIC_RELOCATION_HEADER {
    DWORD      EpilogueCount;
    BYTE       EpilogueByteCount;
    BYTE       BranchDescriptorElementSize;
    WORD       BranchDescriptorCount;
    // BYTE    BranchDescriptors[...];
    // BYTE    BranchDescriptorBitMap[...];
} IMAGE_EPILOGUE_DYNAMIC_RELOCATION_HEADER;
typedef IMAGE_EPILOGUE_DYNAMIC_RELOCATION_HEADER __unaligned * PIMAGE_EPILOGUE_DYNAMIC_RELOCATION_HEADER;

typedef struct _IMAGE_IMPORT_CONTROL_TRANSFER_DYNAMIC_RELOCATION {
    DWORD       PageRelativeOffset : 12;
    DWORD       IndirectCall       : 1;
    DWORD       IATIndex           : 19;
} IMAGE_IMPORT_CONTROL_TRANSFER_DYNAMIC_RELOCATION;
typedef IMAGE_IMPORT_CONTROL_TRANSFER_DYNAMIC_RELOCATION __unaligned * PIMAGE_IMPORT_CONTROL_TRANSFER_DYNAMIC_RELOCATION;

typedef struct _IMAGE_INDIR_CONTROL_TRANSFER_DYNAMIC_RELOCATION {
    WORD        PageRelativeOffset : 12;
    WORD        IndirectCall       : 1;
    WORD        RexWPrefix         : 1;
    WORD        CfgCheck           : 1;
    WORD        Reserved           : 1;
} IMAGE_INDIR_CONTROL_TRANSFER_DYNAMIC_RELOCATION;
typedef IMAGE_INDIR_CONTROL_TRANSFER_DYNAMIC_RELOCATION __unaligned * PIMAGE_INDIR_CONTROL_TRANSFER_DYNAMIC_RELOCATION;

typedef struct _IMAGE_SWITCHTABLE_BRANCH_DYNAMIC_RELOCATION {
    WORD        PageRelativeOffset : 12;
    WORD        RegisterNumber     : 4;
} IMAGE_SWITCHTABLE_BRANCH_DYNAMIC_RELOCATION;
typedef IMAGE_SWITCHTABLE_BRANCH_DYNAMIC_RELOCATION __unaligned * PIMAGE_SWITCHTABLE_BRANCH_DYNAMIC_RELOCATION;

#line 1 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\shared\\poppack.h"
/*++

Copyright (c) Microsoft Corporation.  All rights reserved.

Module Name:

    poppack.h

Abstract:

    This file turns packing of structures off.  (That is, it enables
    automatic alignment of structure fields.)  An include file is needed
    because various compilers do this in different ways.

    poppack.h is the complement to pshpack?.h.  An inclusion of poppack.h
    MUST ALWAYS be preceded by an inclusion of one of pshpack?.h, in one-to-one
    correspondence.

    For Microsoft compatible compilers, this file uses the pop option
    to the pack pragma so that it can restore the previous saved by the
    pshpack?.h include file.

--*/



#pragma warning(disable:4103)

#pragma pack(pop)


#line 33 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\shared\\poppack.h"


#line 36 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\shared\\poppack.h"
#line 37 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\shared\\poppack.h"
#line 18387 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winnt.h"

//
// Load Configuration Directory Entry
//

typedef struct _IMAGE_LOAD_CONFIG_DIRECTORY32 {
    DWORD   Size;
    DWORD   TimeDateStamp;
    WORD    MajorVersion;
    WORD    MinorVersion;
    DWORD   GlobalFlagsClear;
    DWORD   GlobalFlagsSet;
    DWORD   CriticalSectionDefaultTimeout;
    DWORD   DeCommitFreeBlockThreshold;
    DWORD   DeCommitTotalFreeThreshold;
    DWORD   LockPrefixTable;                // VA
    DWORD   MaximumAllocationSize;
    DWORD   VirtualMemoryThreshold;
    DWORD   ProcessHeapFlags;
    DWORD   ProcessAffinityMask;
    WORD    CSDVersion;
    WORD    DependentLoadFlags;
    DWORD   EditList;                       // VA
    DWORD   SecurityCookie;                 // VA
    DWORD   SEHandlerTable;                 // VA
    DWORD   SEHandlerCount;
    DWORD   GuardCFCheckFunctionPointer;    // VA
    DWORD   GuardCFDispatchFunctionPointer; // VA
    DWORD   GuardCFFunctionTable;           // VA
    DWORD   GuardCFFunctionCount;
    DWORD   GuardFlags;
    IMAGE_LOAD_CONFIG_CODE_INTEGRITY CodeIntegrity;
    DWORD   GuardAddressTakenIatEntryTable; // VA
    DWORD   GuardAddressTakenIatEntryCount;
    DWORD   GuardLongJumpTargetTable;       // VA
    DWORD   GuardLongJumpTargetCount;
    DWORD   DynamicValueRelocTable;         // VA
    DWORD   CHPEMetadataPointer;
    DWORD   GuardRFFailureRoutine;          // VA
    DWORD   GuardRFFailureRoutineFunctionPointer; // VA
    DWORD   DynamicValueRelocTableOffset;
    WORD    DynamicValueRelocTableSection;
    WORD    Reserved2;
    DWORD   GuardRFVerifyStackPointerFunctionPointer; // VA
    DWORD   HotPatchTableOffset;
    DWORD   Reserved3;
    DWORD   EnclaveConfigurationPointer;    // VA
    DWORD   VolatileMetadataPointer;        // VA
} IMAGE_LOAD_CONFIG_DIRECTORY32, *PIMAGE_LOAD_CONFIG_DIRECTORY32;

typedef struct _IMAGE_LOAD_CONFIG_DIRECTORY64 {
    DWORD      Size;
    DWORD      TimeDateStamp;
    WORD       MajorVersion;
    WORD       MinorVersion;
    DWORD      GlobalFlagsClear;
    DWORD      GlobalFlagsSet;
    DWORD      CriticalSectionDefaultTimeout;
    ULONGLONG  DeCommitFreeBlockThreshold;
    ULONGLONG  DeCommitTotalFreeThreshold;
    ULONGLONG  LockPrefixTable;                // VA
    ULONGLONG  MaximumAllocationSize;
    ULONGLONG  VirtualMemoryThreshold;
    ULONGLONG  ProcessAffinityMask;
    DWORD      ProcessHeapFlags;
    WORD       CSDVersion;
    WORD       DependentLoadFlags;
    ULONGLONG  EditList;                       // VA
    ULONGLONG  SecurityCookie;                 // VA
    ULONGLONG  SEHandlerTable;                 // VA
    ULONGLONG  SEHandlerCount;
    ULONGLONG  GuardCFCheckFunctionPointer;    // VA
    ULONGLONG  GuardCFDispatchFunctionPointer; // VA
    ULONGLONG  GuardCFFunctionTable;           // VA
    ULONGLONG  GuardCFFunctionCount;
    DWORD      GuardFlags;
    IMAGE_LOAD_CONFIG_CODE_INTEGRITY CodeIntegrity;
    ULONGLONG  GuardAddressTakenIatEntryTable; // VA
    ULONGLONG  GuardAddressTakenIatEntryCount;
    ULONGLONG  GuardLongJumpTargetTable;       // VA
    ULONGLONG  GuardLongJumpTargetCount;
    ULONGLONG  DynamicValueRelocTable;         // VA
    ULONGLONG  CHPEMetadataPointer;            // VA
    ULONGLONG  GuardRFFailureRoutine;          // VA
    ULONGLONG  GuardRFFailureRoutineFunctionPointer; // VA
    DWORD      DynamicValueRelocTableOffset;
    WORD       DynamicValueRelocTableSection;
    WORD       Reserved2;
    ULONGLONG  GuardRFVerifyStackPointerFunctionPointer; // VA
    DWORD      HotPatchTableOffset;
    DWORD      Reserved3;
    ULONGLONG  EnclaveConfigurationPointer;     // VA
    ULONGLONG  VolatileMetadataPointer;         // VA
} IMAGE_LOAD_CONFIG_DIRECTORY64, *PIMAGE_LOAD_CONFIG_DIRECTORY64;

// end_ntoshvp
// begin_ntoshvp


typedef IMAGE_LOAD_CONFIG_DIRECTORY64     IMAGE_LOAD_CONFIG_DIRECTORY;
typedef PIMAGE_LOAD_CONFIG_DIRECTORY64    PIMAGE_LOAD_CONFIG_DIRECTORY;



#line 18492 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winnt.h"

// end_ntoshvp

typedef struct _IMAGE_HOT_PATCH_INFO {
    DWORD Version;
    DWORD Size;
    DWORD SequenceNumber;
    DWORD BaseImageList;
    DWORD BaseImageCount;
    DWORD BufferOffset;             // Version 2 and later
    DWORD ExtraPatchSize;           // Version 3 and later
} IMAGE_HOT_PATCH_INFO, *PIMAGE_HOT_PATCH_INFO;

typedef struct _IMAGE_HOT_PATCH_BASE {
    DWORD SequenceNumber;
    DWORD Flags;
    DWORD OriginalTimeDateStamp;
    DWORD OriginalCheckSum;
    DWORD CodeIntegrityInfo;
    DWORD CodeIntegritySize;
    DWORD PatchTable;
    DWORD BufferOffset;             // Version 2 and later
} IMAGE_HOT_PATCH_BASE, *PIMAGE_HOT_PATCH_BASE;

typedef struct _IMAGE_HOT_PATCH_HASHES {
    BYTE  SHA256[32];
    BYTE  SHA1[20];
} IMAGE_HOT_PATCH_HASHES, *PIMAGE_HOT_PATCH_HASHES;




























                                                                  // taken IAT table is also present in the load config.










//
// GFIDS table entry flags.
//




//
// WIN CE Exception table format
//

//
// Function table entry format.  Function table is pointed to by the
// IMAGE_DIRECTORY_ENTRY_EXCEPTION directory entry.
//

typedef struct _IMAGE_CE_RUNTIME_FUNCTION_ENTRY {
    DWORD FuncStart;
    DWORD PrologLen : 8;
    DWORD FuncLen : 22;
    DWORD ThirtyTwoBit : 1;
    DWORD ExceptionFlag : 1;
} IMAGE_CE_RUNTIME_FUNCTION_ENTRY, * PIMAGE_CE_RUNTIME_FUNCTION_ENTRY;

typedef struct _IMAGE_ARM_RUNTIME_FUNCTION_ENTRY {
    DWORD BeginAddress;
    union {
        DWORD UnwindData;
        struct {
            DWORD Flag : 2;
            DWORD FunctionLength : 11;
            DWORD Ret : 2;
            DWORD H : 1;
            DWORD Reg : 3;
            DWORD R : 1;
            DWORD L : 1;
            DWORD C : 1;
            DWORD StackAdjust : 10;
        }  ;
    }  ;
} IMAGE_ARM_RUNTIME_FUNCTION_ENTRY, * PIMAGE_ARM_RUNTIME_FUNCTION_ENTRY;

typedef struct _IMAGE_ARM64_RUNTIME_FUNCTION_ENTRY {
    DWORD BeginAddress;
    union {
        DWORD UnwindData;
        struct {
            DWORD Flag : 2;
            DWORD FunctionLength : 11;
            DWORD RegF : 3;
            DWORD RegI : 4;
            DWORD H : 1;
            DWORD CR : 2;
            DWORD FrameSize : 9;
        }  ;
    }  ;
} IMAGE_ARM64_RUNTIME_FUNCTION_ENTRY, * PIMAGE_ARM64_RUNTIME_FUNCTION_ENTRY;

typedef struct _IMAGE_ALPHA64_RUNTIME_FUNCTION_ENTRY {
    ULONGLONG BeginAddress;
    ULONGLONG EndAddress;
    ULONGLONG ExceptionHandler;
    ULONGLONG HandlerData;
    ULONGLONG PrologEndAddress;
} IMAGE_ALPHA64_RUNTIME_FUNCTION_ENTRY, *PIMAGE_ALPHA64_RUNTIME_FUNCTION_ENTRY;

typedef struct _IMAGE_ALPHA_RUNTIME_FUNCTION_ENTRY {
    DWORD BeginAddress;
    DWORD EndAddress;
    DWORD ExceptionHandler;
    DWORD HandlerData;
    DWORD PrologEndAddress;
} IMAGE_ALPHA_RUNTIME_FUNCTION_ENTRY, *PIMAGE_ALPHA_RUNTIME_FUNCTION_ENTRY;

typedef struct _IMAGE_RUNTIME_FUNCTION_ENTRY {
    DWORD BeginAddress;
    DWORD EndAddress;
    union {
        DWORD UnwindInfoAddress;
        DWORD UnwindData;
    }  ;
} _IMAGE_RUNTIME_FUNCTION_ENTRY, *_PIMAGE_RUNTIME_FUNCTION_ENTRY;

typedef  _IMAGE_RUNTIME_FUNCTION_ENTRY  IMAGE_IA64_RUNTIME_FUNCTION_ENTRY;
typedef _PIMAGE_RUNTIME_FUNCTION_ENTRY PIMAGE_IA64_RUNTIME_FUNCTION_ENTRY;








#line 18653 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winnt.h"




#line 18658 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winnt.h"




#line 18663 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winnt.h"




#line 18668 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winnt.h"

typedef  _IMAGE_RUNTIME_FUNCTION_ENTRY  IMAGE_RUNTIME_FUNCTION_ENTRY;
typedef _PIMAGE_RUNTIME_FUNCTION_ENTRY PIMAGE_RUNTIME_FUNCTION_ENTRY;

#line 18673 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winnt.h"

//
// Sofware enclave information
//




typedef struct _IMAGE_ENCLAVE_CONFIG32 {
    DWORD Size;
    DWORD MinimumRequiredConfigSize;
    DWORD PolicyFlags;
    DWORD NumberOfImports;
    DWORD ImportList;
    DWORD ImportEntrySize;
    BYTE  FamilyID[16 ];
    BYTE  ImageID[16 ];
    DWORD ImageVersion;
    DWORD SecurityVersion;
    DWORD EnclaveSize;
    DWORD NumberOfThreads;
    DWORD EnclaveFlags;
} IMAGE_ENCLAVE_CONFIG32, *PIMAGE_ENCLAVE_CONFIG32;

typedef struct _IMAGE_ENCLAVE_CONFIG64 {
    DWORD Size;
    DWORD MinimumRequiredConfigSize;
    DWORD PolicyFlags;
    DWORD NumberOfImports;
    DWORD ImportList;
    DWORD ImportEntrySize;
    BYTE  FamilyID[16 ];
    BYTE  ImageID[16 ];
    DWORD ImageVersion;
    DWORD SecurityVersion;
    ULONGLONG EnclaveSize;
    DWORD NumberOfThreads;
    DWORD EnclaveFlags;
} IMAGE_ENCLAVE_CONFIG64, *PIMAGE_ENCLAVE_CONFIG64;


typedef IMAGE_ENCLAVE_CONFIG64          IMAGE_ENCLAVE_CONFIG;
typedef PIMAGE_ENCLAVE_CONFIG64         PIMAGE_ENCLAVE_CONFIG;



#line 18720 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winnt.h"







typedef struct _IMAGE_ENCLAVE_IMPORT {
    DWORD MatchType;
    DWORD MinimumSecurityVersion;
    BYTE  UniqueOrAuthorID[32 ];
    BYTE  FamilyID[16 ];
    BYTE  ImageID[16 ];
    DWORD ImportName;
    DWORD Reserved;
} IMAGE_ENCLAVE_IMPORT, *PIMAGE_ENCLAVE_IMPORT;







//
// Debug Format
//

typedef struct _IMAGE_DEBUG_DIRECTORY {
    DWORD   Characteristics;
    DWORD   TimeDateStamp;
    WORD    MajorVersion;
    WORD    MinorVersion;
    DWORD   Type;
    DWORD   SizeOfData;
    DWORD   AddressOfRawData;
    DWORD   PointerToRawData;
} IMAGE_DEBUG_DIRECTORY, *PIMAGE_DEBUG_DIRECTORY;




















typedef struct _IMAGE_COFF_SYMBOLS_HEADER {
    DWORD   NumberOfSymbols;
    DWORD   LvaToFirstSymbol;
    DWORD   NumberOfLinenumbers;
    DWORD   LvaToFirstLinenumber;
    DWORD   RvaToFirstByteOfCode;
    DWORD   RvaToLastByteOfCode;
    DWORD   RvaToFirstByteOfData;
    DWORD   RvaToLastByteOfData;
} IMAGE_COFF_SYMBOLS_HEADER, *PIMAGE_COFF_SYMBOLS_HEADER;






typedef struct _FPO_DATA {
    DWORD       ulOffStart;             // offset 1st byte of function code
    DWORD       cbProcSize;             // # bytes in function
    DWORD       cdwLocals;              // # bytes in locals/4
    WORD        cdwParams;              // # bytes in params/4
    WORD        cbProlog : 8;           // # bytes in prolog
    WORD        cbRegs   : 3;           // # regs saved
    WORD        fHasSEH  : 1;           // TRUE if SEH in func
    WORD        fUseBP   : 1;           // TRUE if EBP has been allocated
    WORD        reserved : 1;           // reserved for future use
    WORD        cbFrame  : 2;           // frame type
} FPO_DATA, *PFPO_DATA;





typedef struct _IMAGE_DEBUG_MISC {
    DWORD       DataType;               // type of misc data, see defines
    DWORD       Length;                 // total length of record, rounded to four
                                        // byte multiple.
    BOOLEAN     Unicode;                // TRUE if data is unicode string
    BYTE        Reserved[ 3 ];
    BYTE        Data[ 1 ];              // Actual data
} IMAGE_DEBUG_MISC, *PIMAGE_DEBUG_MISC;


//
// Function table extracted from MIPS/ALPHA/IA64 images.  Does not contain
// information needed only for runtime support.  Just those fields for
// each entry needed by a debugger.
//

typedef struct _IMAGE_FUNCTION_ENTRY {
    DWORD   StartingAddress;
    DWORD   EndingAddress;
    DWORD   EndOfPrologue;
} IMAGE_FUNCTION_ENTRY, *PIMAGE_FUNCTION_ENTRY;

typedef struct _IMAGE_FUNCTION_ENTRY64 {
    ULONGLONG   StartingAddress;
    ULONGLONG   EndingAddress;
    union {
        ULONGLONG   EndOfPrologue;
        ULONGLONG   UnwindInfoAddress;
    }  ;
} IMAGE_FUNCTION_ENTRY64, *PIMAGE_FUNCTION_ENTRY64;

//
// Debugging information can be stripped from an image file and placed
// in a separate .DBG file, whose file name part is the same as the
// image file name part (e.g. symbols for CMD.EXE could be stripped
// and placed in CMD.DBG).  This is indicated by the IMAGE_FILE_DEBUG_STRIPPED
// flag in the Characteristics field of the file header.  The beginning of
// the .DBG file contains the following structure which captures certain
// information from the image file.  This allows a debug to proceed even if
// the original image file is not accessable.  This header is followed by
// zero of more IMAGE_SECTION_HEADER structures, followed by zero or more
// IMAGE_DEBUG_DIRECTORY structures.  The latter structures and those in
// the image file contain file offsets relative to the beginning of the
// .DBG file.
//
// If symbols have been stripped from an image, the IMAGE_DEBUG_MISC structure
// is left in the image file, but not mapped.  This allows a debugger to
// compute the name of the .DBG file, from the name of the image in the
// IMAGE_DEBUG_MISC structure.
//

typedef struct _IMAGE_SEPARATE_DEBUG_HEADER {
    WORD        Signature;
    WORD        Flags;
    WORD        Machine;
    WORD        Characteristics;
    DWORD       TimeDateStamp;
    DWORD       CheckSum;
    DWORD       ImageBase;
    DWORD       SizeOfImage;
    DWORD       NumberOfSections;
    DWORD       ExportedNamesSize;
    DWORD       DebugDirectorySize;
    DWORD       SectionAlignment;
    DWORD       Reserved[2];
} IMAGE_SEPARATE_DEBUG_HEADER, *PIMAGE_SEPARATE_DEBUG_HEADER;

// begin_ntoshvp

typedef struct _NON_PAGED_DEBUG_INFO {
    WORD        Signature;
    WORD        Flags;
    DWORD       Size;
    WORD        Machine;
    WORD        Characteristics;
    DWORD       TimeDateStamp;
    DWORD       CheckSum;
    DWORD       SizeOfImage;
    ULONGLONG   ImageBase;
    //DebugDirectorySize
    //IMAGE_DEBUG_DIRECTORY
} NON_PAGED_DEBUG_INFO, *PNON_PAGED_DEBUG_INFO;

// end_ntoshvp







#line 18902 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winnt.h"



                                                // old checksum didn't match.

//
//  The .arch section is made up of headers, each describing an amask position/value
//  pointing to an array of IMAGE_ARCHITECTURE_ENTRY's.  Each "array" (both the header
//  and entry arrays) are terminiated by a quadword of 0xffffffffL.
//
//  NOTE: There may be quadwords of 0 sprinkled around and must be skipped.
//

typedef struct _ImageArchitectureHeader {
    unsigned int AmaskValue: 1;                 // 1 -> code section depends on mask bit
                                                // 0 -> new instruction depends on mask bit
    int :7;                                     // MBZ
    unsigned int AmaskShift: 8;                 // Amask bit in question for this fixup
    int :16;                                    // MBZ
    DWORD FirstEntryRVA;                        // RVA into .arch section to array of ARCHITECTURE_ENTRY's
} IMAGE_ARCHITECTURE_HEADER, *PIMAGE_ARCHITECTURE_HEADER;

typedef struct _ImageArchitectureEntry {
    DWORD FixupInstRVA;                         // RVA of instruction to fixup
    DWORD NewInst;                              // fixup instruction (see alphaops.h)
} IMAGE_ARCHITECTURE_ENTRY, *PIMAGE_ARCHITECTURE_ENTRY;

#line 1 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\shared\\poppack.h"
/*++

Copyright (c) Microsoft Corporation.  All rights reserved.

Module Name:

    poppack.h

Abstract:

    This file turns packing of structures off.  (That is, it enables
    automatic alignment of structure fields.)  An include file is needed
    because various compilers do this in different ways.

    poppack.h is the complement to pshpack?.h.  An inclusion of poppack.h
    MUST ALWAYS be preceded by an inclusion of one of pshpack?.h, in one-to-one
    correspondence.

    For Microsoft compatible compilers, this file uses the pop option
    to the pack pragma so that it can restore the previous saved by the
    pshpack?.h include file.

--*/



#pragma warning(disable:4103)

#pragma pack(pop)


#line 33 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\shared\\poppack.h"


#line 36 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\shared\\poppack.h"
#line 37 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\shared\\poppack.h"
#line 18930 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winnt.h"

// The following structure defines the new import object.  Note the values of the first two fields,
// which must be set as stated in order to differentiate old and new import members.
// Following this structure, the linker emits two null-terminated strings used to recreate the
// import at the time of use.  The first string is the import's name, the second is the dll's name.



typedef struct IMPORT_OBJECT_HEADER {
    WORD    Sig1;                       // Must be IMAGE_FILE_MACHINE_UNKNOWN
    WORD    Sig2;                       // Must be IMPORT_OBJECT_HDR_SIG2.
    WORD    Version;
    WORD    Machine;
    DWORD   TimeDateStamp;              // Time/date stamp
    DWORD   SizeOfData;                 // particularly useful for incremental links

    union {
        WORD    Ordinal;                // if grf & IMPORT_OBJECT_ORDINAL
        WORD    Hint;
    }  ;

    WORD    Type : 2;                   // IMPORT_TYPE
    WORD    NameType : 3;               // IMPORT_NAME_TYPE
    WORD    Reserved : 11;              // Reserved. Must be zero.
} IMPORT_OBJECT_HEADER;

typedef enum IMPORT_OBJECT_TYPE
{
    IMPORT_OBJECT_CODE = 0,
    IMPORT_OBJECT_DATA = 1,
    IMPORT_OBJECT_CONST = 2,
} IMPORT_OBJECT_TYPE;

typedef enum IMPORT_OBJECT_NAME_TYPE
{
    IMPORT_OBJECT_ORDINAL = 0,          // Import by ordinal
    IMPORT_OBJECT_NAME = 1,             // Import name == public symbol name.
    IMPORT_OBJECT_NAME_NO_PREFIX = 2,   // Import name == public symbol name skipping leading ?, @, or optionally _.
    IMPORT_OBJECT_NAME_UNDECORATE = 3,  // Import name == public symbol name skipping leading ?, @, or optionally _
                                        //  and truncating at first @.
    IMPORT_OBJECT_NAME_EXPORTAS = 4,    // Import name == a name is explicitly provided after the DLL name.
} IMPORT_OBJECT_NAME_TYPE;





typedef enum ReplacesCorHdrNumericDefines
{
// COM+ Header entry point flags.
    COMIMAGE_FLAGS_ILONLY               =0x00000001,
    COMIMAGE_FLAGS_32BITREQUIRED        =0x00000002,
    COMIMAGE_FLAGS_IL_LIBRARY           =0x00000004,
    COMIMAGE_FLAGS_STRONGNAMESIGNED     =0x00000008,
    COMIMAGE_FLAGS_NATIVE_ENTRYPOINT    =0x00000010,
    COMIMAGE_FLAGS_TRACKDEBUGDATA       =0x00010000,
    COMIMAGE_FLAGS_32BITPREFERRED       =0x00020000,

// Version flags for image.
    COR_VERSION_MAJOR_V2                =2,
    COR_VERSION_MAJOR                   =COR_VERSION_MAJOR_V2,
    COR_VERSION_MINOR                   =5,
    COR_DELETED_NAME_LENGTH             =8,
    COR_VTABLEGAP_NAME_LENGTH           =8,

// Maximum size of a NativeType descriptor.
    NATIVE_TYPE_MAX_CB                  =1,
    COR_ILMETHOD_SECT_SMALL_MAX_DATASIZE=0xFF,

// #defines for the MIH FLAGS
    IMAGE_COR_MIH_METHODRVA             =0x01,
    IMAGE_COR_MIH_EHRVA                 =0x02,
    IMAGE_COR_MIH_BASICBLOCK            =0x08,

// V-table constants
    COR_VTABLE_32BIT                    =0x01,          // V-table slots are 32-bits in size.
    COR_VTABLE_64BIT                    =0x02,          // V-table slots are 64-bits in size.
    COR_VTABLE_FROM_UNMANAGED           =0x04,          // If set, transition from unmanaged.
    COR_VTABLE_FROM_UNMANAGED_RETAIN_APPDOMAIN  =0x08,  // If set, transition from unmanaged with keeping the current appdomain.
    COR_VTABLE_CALL_MOST_DERIVED        =0x10,          // Call most derived method described by

// EATJ constants
    IMAGE_COR_EATJ_THUNK_SIZE           =32,            // Size of a jump thunk reserved range.

// Max name lengths
    //@todo: Change to unlimited name lengths.
    MAX_CLASS_NAME                      =1024,
    MAX_PACKAGE_NAME                    =1024,
} ReplacesCorHdrNumericDefines;

// CLR 2.0 header structure.
typedef struct IMAGE_COR20_HEADER
{
    // Header versioning
    DWORD                   cb;
    WORD                    MajorRuntimeVersion;
    WORD                    MinorRuntimeVersion;

    // Symbol table and startup information
    IMAGE_DATA_DIRECTORY    MetaData;
    DWORD                   Flags;

    // If COMIMAGE_FLAGS_NATIVE_ENTRYPOINT is not set, EntryPointToken represents a managed entrypoint.
    // If COMIMAGE_FLAGS_NATIVE_ENTRYPOINT is set, EntryPointRVA represents an RVA to a native entrypoint.
    union {
        DWORD               EntryPointToken;
        DWORD               EntryPointRVA;
    }  ;

    // Binding information
    IMAGE_DATA_DIRECTORY    Resources;
    IMAGE_DATA_DIRECTORY    StrongNameSignature;

    // Regular fixup and binding information
    IMAGE_DATA_DIRECTORY    CodeManagerTable;
    IMAGE_DATA_DIRECTORY    VTableFixups;
    IMAGE_DATA_DIRECTORY    ExportAddressTableJumps;

    // Precompiled image info (internal use only - set to zero)
    IMAGE_DATA_DIRECTORY    ManagedNativeHeader;

} IMAGE_COR20_HEADER, *PIMAGE_COR20_HEADER;

#line 19054 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winnt.h"

//
// End Image Format
//

#line 1 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\shared\\apiset.h"
/*++

Copyright (c) 2008  Microsoft Corporation

Module Name:

    apiset.h

Abstract:

    This module contains definitions related to the management of API namespaces.

Author:

    Arun Kishan (arunki) 14-Sep-2008

--*/




//
// API set interface definitions.
//













#line 39 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\shared\\apiset.h"





































































#line 109 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\shared\\apiset.h"




















#line 130 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\shared\\apiset.h"
// This section is intended for internal contract generation to build artifacts that model the contract without forwarding.



















#line 151 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\shared\\apiset.h"



#line 155 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\shared\\apiset.h"

#line 157 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\shared\\apiset.h"
#line 19060 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winnt.h"

//
// prototypes
//

// begin_ntifs

#pragma region Application or OneCore Family




__declspec(dllimport)

WORD  
__stdcall
RtlCaptureStackBackTrace(
     DWORD FramesToSkip,
     DWORD FramesToCapture,
     PVOID* BackTrace,
     PDWORD BackTraceHash
    );


#line 19085 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winnt.h"

#line 19087 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winnt.h"
#pragma endregion

#pragma region Desktop Family or OneCore Family




__declspec(dllimport)
void
__stdcall
RtlCaptureContext(
     PCONTEXT ContextRecord
    );


#line 19103 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winnt.h"

#line 19105 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winnt.h"
#pragma endregion

// end_ntifs

#pragma region Application or OneCore Family


__declspec(dllimport)
void
__stdcall
RtlUnwind(
     PVOID TargetFrame,
     PVOID TargetIp,
     PEXCEPTION_RECORD ExceptionRecord,
     PVOID ReturnValue
    );


#line 19124 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winnt.h"
#pragma endregion



#pragma region Desktop Family or OneCore Family


__declspec(dllimport)
BOOLEAN
__cdecl
RtlAddFunctionTable(
     PRUNTIME_FUNCTION FunctionTable,
     DWORD EntryCount,
     DWORD64 BaseAddress
    );


__declspec(dllimport)
BOOLEAN
__cdecl
RtlDeleteFunctionTable(
     PRUNTIME_FUNCTION FunctionTable
    );


__declspec(dllimport)
BOOLEAN
__cdecl
RtlInstallFunctionTableCallback(
     DWORD64 TableIdentifier,
     DWORD64 BaseAddress,
     DWORD Length,
     PGET_RUNTIME_FUNCTION_CALLBACK Callback,
     PVOID Context,
     PCWSTR OutOfProcessCallbackDll
    );


































#line 19195 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winnt.h"
#line 19196 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winnt.h"
#pragma endregion

#pragma region Application or OneCore Family or Games Family


__declspec(dllimport)
PRUNTIME_FUNCTION
__stdcall
RtlLookupFunctionEntry(
     DWORD64 ControlPc,
     PDWORD64 ImageBase,
     PUNWIND_HISTORY_TABLE HistoryTable
    );


#line 19212 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winnt.h"
#pragma endregion

#pragma region Desktop Family or OneCore Family or Games Family


__declspec(dllimport)
void
__cdecl
RtlRestoreContext(
     PCONTEXT ContextRecord,
     struct _EXCEPTION_RECORD* ExceptionRecord
    );


#line 19227 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winnt.h"
#pragma endregion

#pragma region Application or OneCore Family or Games Family


__declspec(dllimport)
void
__stdcall
RtlUnwindEx(
     PVOID TargetFrame,
     PVOID TargetIp,
     PEXCEPTION_RECORD ExceptionRecord,
     PVOID ReturnValue,
     PCONTEXT ContextRecord,
     PUNWIND_HISTORY_TABLE HistoryTable
    );


__declspec(dllimport)
PEXCEPTION_ROUTINE
__stdcall
RtlVirtualUnwind(
     DWORD HandlerType,
     DWORD64 ImageBase,
     DWORD64 ControlPc,
     PRUNTIME_FUNCTION FunctionEntry,
     PCONTEXT ContextRecord,
     PVOID* HandlerData,
     PDWORD64 EstablisherFrame,
     PKNONVOLATILE_CONTEXT_POINTERS ContextPointers
    );


#line 19261 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winnt.h"
#pragma endregion

#line 19264 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winnt.h"











































































































































#line 19404 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winnt.h"











































































































































#line 19544 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winnt.h"






































#line 19583 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winnt.h"

#pragma region Desktop Family or OneCore Family or Games Family


__declspec(dllimport)

void
__stdcall
RtlRaiseException(
     PEXCEPTION_RECORD ExceptionRecord
    );


#line 19597 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winnt.h"
#pragma endregion

#pragma region Application or OneCore Family


__declspec(dllimport)
PVOID
__stdcall
RtlPcToFileHeader(
     PVOID PcValue,
     PVOID* BaseOfImage
    );


#line 19612 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winnt.h"
#pragma endregion


#pragma region Desktop Family or OneCore Family





__declspec(dllimport)
SIZE_T
__stdcall
RtlCompareMemory(
     const void * Source1,
     const void * Source2,
     SIZE_T Length
    );


#line 19632 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winnt.h"

#line 19634 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winnt.h"
#pragma endregion

//
// for move macros
//






#line 19646 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winnt.h"







//
// The type SINGLE_LIST_ENTRY is not suitable for use with SLISTs.  For
// WIN64, an entry on an SLIST is required to be 16-byte aligned, while a
// SINGLE_LIST_ENTRY structure has only 8 byte alignment.
//
// Therefore, all SLIST code should use the SLIST_ENTRY type instead of the
// SINGLE_LIST_ENTRY type.
//

#pragma warning(push)
#pragma warning(disable:4324)   

typedef struct __declspec(align(16)) _SLIST_ENTRY {
    struct _SLIST_ENTRY *Next;
} SLIST_ENTRY, *PSLIST_ENTRY;

#pragma warning(pop)





#line 19676 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winnt.h"



typedef union __declspec(align(16)) _SLIST_HEADER {
    struct {  // original struct
        ULONGLONG Alignment;
        ULONGLONG Region;
    }  ;
    struct {  // x64 16-byte header
        ULONGLONG Depth:16;
        ULONGLONG Sequence:48;
        ULONGLONG Reserved:4;
        ULONGLONG NextEntry:60; // last 4 bits are always 0's
    } HeaderX64;
} SLIST_HEADER, *PSLIST_HEADER;







































#line 19731 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winnt.h"

#line 19733 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winnt.h"


#pragma region Desktop Family or OneCore Family


__declspec(dllimport)
void
__stdcall
RtlInitializeSListHead (
     PSLIST_HEADER ListHead
    );


__declspec(dllimport)
PSLIST_ENTRY
__stdcall
RtlFirstEntrySList (
     const SLIST_HEADER *ListHead
    );

__declspec(dllimport)
PSLIST_ENTRY
__stdcall
RtlInterlockedPopEntrySList (
     PSLIST_HEADER ListHead
    );

__declspec(dllimport)
PSLIST_ENTRY
__stdcall
RtlInterlockedPushEntrySList (
     PSLIST_HEADER ListHead,
      PSLIST_ENTRY ListEntry
    );

__declspec(dllimport)
PSLIST_ENTRY
__stdcall
RtlInterlockedPushListSListEx (
     PSLIST_HEADER ListHead,
      PSLIST_ENTRY List,
     PSLIST_ENTRY ListEnd,
     DWORD Count
    );

__declspec(dllimport)
PSLIST_ENTRY
__stdcall
RtlInterlockedFlushSList (
     PSLIST_HEADER ListHead
    );

__declspec(dllimport)
WORD  
__stdcall
RtlQueryDepthSList (
     PSLIST_HEADER ListHead
    );

#line 19793 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winnt.h"
#pragma endregion





//
// Run once
//



//
// Run once flags
//





//
// The context stored in the run once structure must leave the following number
// of low order bits unused.
//



typedef union _RTL_RUN_ONCE {       
    PVOID Ptr;                      
} RTL_RUN_ONCE, *PRTL_RUN_ONCE;     

#line 19825 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winnt.h"

typedef struct _RTL_BARRIER {                       
            DWORD Reserved1;                        
            DWORD Reserved2;                        
            ULONG_PTR Reserved3[2];                 
            DWORD Reserved4;                        
            DWORD Reserved5;                        
} RTL_BARRIER, *PRTL_BARRIER;                       
// begin_ntoshvp

// Include the more obscure SAL annotations (like __drv_aliasesMem) instead of assuming the crtdefs.h will include them.


//
// Fast fail failure codes.
//
// N.B.  Failure code zero should not be used, but is required to be reserved
//       for compatibility with previous handling of the
//       STATUS_STACK_BUFFER_OVERRUN exception status code.
//

// When updating failure codes here, please also update references in
// the debugger codebase (currently onecore\sdktools\debuggers\ntsd64\util.cpp)






























































__declspec(noreturn)
void
__fastfail(
     unsigned int Code
    );

#pragma intrinsic(__fastfail)

#line 19919 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winnt.h"

















#pragma region Desktop Family


__forceinline
DWORD
HEAP_MAKE_TAG_FLAGS (
     DWORD TagBase,
     DWORD Tag
    )

{
    return ((DWORD)((TagBase) + ((Tag) << 18 )));
}
#line 19950 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winnt.h"
#line 19951 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winnt.h"
#pragma endregion






















































#line 20007 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winnt.h"











__forceinline
PVOID
RtlSecureZeroMemory(
     PVOID ptr,
     SIZE_T cnt
    )
{
    volatile char *vptr = (volatile char *)ptr;



    __stosb((PBYTE )((DWORD64)vptr), 0, cnt);



















#line 20050 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winnt.h"

    return ptr;
}

#line 20055 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winnt.h"

// begin_wdm



















// end_wdm

typedef struct _MESSAGE_RESOURCE_ENTRY {
    WORD   Length;
    WORD   Flags;
    BYTE  Text[ 1 ];
} MESSAGE_RESOURCE_ENTRY, *PMESSAGE_RESOURCE_ENTRY;



typedef struct _MESSAGE_RESOURCE_BLOCK {
    DWORD LowId;
    DWORD HighId;
    DWORD OffsetToEntries;
} MESSAGE_RESOURCE_BLOCK, *PMESSAGE_RESOURCE_BLOCK;

typedef struct _MESSAGE_RESOURCE_DATA {
    DWORD NumberOfBlocks;
    MESSAGE_RESOURCE_BLOCK Blocks[ 1 ];
} MESSAGE_RESOURCE_DATA, *PMESSAGE_RESOURCE_DATA;

typedef struct _OSVERSIONINFOA {
    DWORD dwOSVersionInfoSize;
    DWORD dwMajorVersion;
    DWORD dwMinorVersion;
    DWORD dwBuildNumber;
    DWORD dwPlatformId;
    CHAR   szCSDVersion[ 128 ];     // Maintenance string for PSS usage
} OSVERSIONINFOA, *POSVERSIONINFOA, *LPOSVERSIONINFOA;

typedef struct _OSVERSIONINFOW {
    DWORD dwOSVersionInfoSize;
    DWORD dwMajorVersion;
    DWORD dwMinorVersion;
    DWORD dwBuildNumber;
    DWORD dwPlatformId;
    WCHAR  szCSDVersion[ 128 ];     // Maintenance string for PSS usage
} OSVERSIONINFOW, *POSVERSIONINFOW, *LPOSVERSIONINFOW, RTL_OSVERSIONINFOW, *PRTL_OSVERSIONINFOW;





typedef OSVERSIONINFOA OSVERSIONINFO;
typedef POSVERSIONINFOA POSVERSIONINFO;
typedef LPOSVERSIONINFOA LPOSVERSIONINFO;
#line 20123 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winnt.h"

typedef struct _OSVERSIONINFOEXA {
    DWORD dwOSVersionInfoSize;
    DWORD dwMajorVersion;
    DWORD dwMinorVersion;
    DWORD dwBuildNumber;
    DWORD dwPlatformId;
    CHAR   szCSDVersion[ 128 ];     // Maintenance string for PSS usage
    WORD   wServicePackMajor;
    WORD   wServicePackMinor;
    WORD   wSuiteMask;
    BYTE  wProductType;
    BYTE  wReserved;
} OSVERSIONINFOEXA, *POSVERSIONINFOEXA, *LPOSVERSIONINFOEXA;
typedef struct _OSVERSIONINFOEXW {
    DWORD dwOSVersionInfoSize;
    DWORD dwMajorVersion;
    DWORD dwMinorVersion;
    DWORD dwBuildNumber;
    DWORD dwPlatformId;
    WCHAR  szCSDVersion[ 128 ];     // Maintenance string for PSS usage
    WORD   wServicePackMajor;
    WORD   wServicePackMinor;
    WORD   wSuiteMask;
    BYTE  wProductType;
    BYTE  wReserved;
} OSVERSIONINFOEXW, *POSVERSIONINFOEXW, *LPOSVERSIONINFOEXW, RTL_OSVERSIONINFOEXW, *PRTL_OSVERSIONINFOEXW;





typedef OSVERSIONINFOEXA OSVERSIONINFOEX;
typedef POSVERSIONINFOEXA POSVERSIONINFOEX;
typedef LPOSVERSIONINFOEXA LPOSVERSIONINFOEX;
#line 20159 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winnt.h"

// begin_wudfpwdm

//
// RtlVerifyVersionInfo() conditions
//












//
// RtlVerifyVersionInfo() type mask bits
//










//
// RtlVerifyVersionInfo() os product type values
//





//
// dwPlatformId defines:
//





#pragma region Desktop Family or OneCore Family


//
//
// VerifyVersionInfo() macro to set the condition mask
//
// For documentation sakes here's the old version of the macro that got
// changed to call an API
// #define VER_SET_CONDITION(_m_,_t_,_c_)  _m_=(_m_|(_c_<<(1<<_t_)))
//








__declspec(dllimport)
ULONGLONG
__stdcall
VerSetConditionMask(
     ULONGLONG ConditionMask,
     DWORD TypeMask,
     BYTE  Condition
    );

#line 20235 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winnt.h"

#line 20237 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winnt.h"

#line 20239 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winnt.h"
#pragma endregion

//

#pragma region Desktop Family or OneCore Family


// begin_ntddk



__declspec(dllimport)
BOOLEAN
__stdcall
RtlGetProductInfo(
      DWORD  OSMajorVersion,
      DWORD  OSMinorVersion,
      DWORD  SpMajorVersion,
      DWORD  SpMinorVersion,
     PDWORD ReturnedProductType
    );

#line 20262 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winnt.h"

// end_ntddk

#line 20266 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winnt.h"
#pragma endregion



typedef enum _RTL_UMS_THREAD_INFO_CLASS {
    UmsThreadInvalidInfoClass = 0,
    UmsThreadUserContext,
    UmsThreadPriority,              // Reserved
    UmsThreadAffinity,              // Reserved
    UmsThreadTeb,
    UmsThreadIsSuspended,
    UmsThreadIsTerminated,
    UmsThreadMaxInfoClass
} RTL_UMS_THREAD_INFO_CLASS, *PRTL_UMS_THREAD_INFO_CLASS;

typedef enum _RTL_UMS_SCHEDULER_REASON {
    UmsSchedulerStartup = 0,
    UmsSchedulerThreadBlocked,
    UmsSchedulerThreadYield,
} RTL_UMS_SCHEDULER_REASON, *PRTL_UMS_SCHEDULER_REASON;

typedef

void
__stdcall
RTL_UMS_SCHEDULER_ENTRY_POINT(
     RTL_UMS_SCHEDULER_REASON Reason,
     ULONG_PTR ActivationPayload,
     PVOID SchedulerParam
    );

typedef RTL_UMS_SCHEDULER_ENTRY_POINT *PRTL_UMS_SCHEDULER_ENTRY_POINT;
































#line 20331 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winnt.h"

#line 20333 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winnt.h"











#line 20345 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winnt.h"








































#line 20386 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winnt.h"

























#line 20412 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winnt.h"


//
// Flush routines for DAX mapped files
//




















































































































































































































#line 20630 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winnt.h"


//
// Correlation Vector Routines.
//























































#line 20691 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winnt.h"








































#line 20732 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winnt.h"


//
// Support for process policy settings embedded into executable image.
//





typedef enum _IMAGE_POLICY_ENTRY_TYPE {
    ImagePolicyEntryTypeNone = 0,
    ImagePolicyEntryTypeBool,
    ImagePolicyEntryTypeInt8,
    ImagePolicyEntryTypeUInt8,
    ImagePolicyEntryTypeInt16,
    ImagePolicyEntryTypeUInt16,
    ImagePolicyEntryTypeInt32,
    ImagePolicyEntryTypeUInt32,
    ImagePolicyEntryTypeInt64,
    ImagePolicyEntryTypeUInt64,
    ImagePolicyEntryTypeAnsiString,
    ImagePolicyEntryTypeUnicodeString,
    ImagePolicyEntryTypeOverride,
    ImagePolicyEntryTypeMaximum
} IMAGE_POLICY_ENTRY_TYPE;

typedef enum _IMAGE_POLICY_ID {
    ImagePolicyIdNone = 0,
    ImagePolicyIdEtw,
    ImagePolicyIdDebug,
    ImagePolicyIdCrashDump,
    ImagePolicyIdCrashDumpKey,
    ImagePolicyIdCrashDumpKeyGuid,
    ImagePolicyIdParentSd,
    ImagePolicyIdParentSdRev,
    ImagePolicyIdSvn,
    ImagePolicyIdDeviceId,
    ImagePolicyIdCapability,
    ImagePolicyIdScenarioId,
    ImagePolicyIdMaximum
} IMAGE_POLICY_ID;

typedef struct _IMAGE_POLICY_ENTRY {
    IMAGE_POLICY_ENTRY_TYPE Type;
    IMAGE_POLICY_ID PolicyId;
    union {
        const void * None;
        BOOLEAN BoolValue;
        INT8 Int8Value;
        UINT8 UInt8Value;
        INT16 Int16Value;
        UINT16 UInt16Value;
        INT32 Int32Value;
        UINT32 UInt32Value;
        INT64 Int64Value;
        UINT64 UInt64Value;
        PCSTR AnsiStringValue;
        PCWSTR UnicodeStringValue;
    } u;
} IMAGE_POLICY_ENTRY;
typedef const IMAGE_POLICY_ENTRY* PCIMAGE_POLICY_ENTRY;

#pragma warning(push)
#pragma warning(disable:4200) 
typedef struct _IMAGE_POLICY_METADATA {
    BYTE  Version;
    BYTE  Reserved0[7];
    ULONGLONG ApplicationId;
    IMAGE_POLICY_ENTRY Policies[];
} IMAGE_POLICY_METADATA;
typedef const IMAGE_POLICY_METADATA* PCIMAGE_POLICY_METADATA;
#pragma warning(pop)





















































typedef struct _RTL_CRITICAL_SECTION_DEBUG {
    WORD   Type;
    WORD   CreatorBackTraceIndex;
    struct _RTL_CRITICAL_SECTION *CriticalSection;
    LIST_ENTRY ProcessLocksList;
    DWORD EntryCount;
    DWORD ContentionCount;
    DWORD Flags;
    WORD   CreatorBackTraceIndexHigh;
    WORD   SpareWORD  ;
} RTL_CRITICAL_SECTION_DEBUG, *PRTL_CRITICAL_SECTION_DEBUG, RTL_RESOURCE_DEBUG, *PRTL_RESOURCE_DEBUG;

//
// These flags define the upper byte of the critical section SpinCount field
//








//
// These flags define possible values stored in the Flags field of a critsec debuginfo.
//


#pragma pack(push, 8)

typedef struct _RTL_CRITICAL_SECTION {
    PRTL_CRITICAL_SECTION_DEBUG DebugInfo;

    //
    //  The following three fields control entering and exiting the critical
    //  section for the resource
    //

    LONG LockCount;
    LONG RecursionCount;
    HANDLE OwningThread;        // from the thread's ClientId->UniqueThread
    HANDLE LockSemaphore;
    ULONG_PTR SpinCount;        // force size on 64-bit systems when packed
} RTL_CRITICAL_SECTION, *PRTL_CRITICAL_SECTION;

#pragma pack(pop)

typedef struct _RTL_SRWLOCK {                            
        PVOID Ptr;                                       
} RTL_SRWLOCK, *PRTL_SRWLOCK;                            

typedef struct _RTL_CONDITION_VARIABLE {                    
        PVOID Ptr;                                       
} RTL_CONDITION_VARIABLE, *PRTL_CONDITION_VARIABLE;      


typedef
void
(__stdcall *PAPCFUNC)(
     ULONG_PTR Parameter
    );
typedef LONG (__stdcall *PVECTORED_EXCEPTION_HANDLER)(
    struct _EXCEPTION_POINTERS *ExceptionInfo
    );

typedef enum _HEAP_INFORMATION_CLASS {

    HeapCompatibilityInformation = 0,
    HeapEnableTerminationOnCorruption = 1







#line 20936 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winnt.h"


} HEAP_INFORMATION_CLASS;










#line 20951 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winnt.h"













typedef void (__stdcall * WAITORTIMERCALLBACKFUNC) (PVOID, BOOLEAN );   
typedef void (__stdcall * WORKERCALLBACKFUNC) (PVOID );                 
typedef void (__stdcall * APC_CALLBACK_FUNCTION) (DWORD   , PVOID, PVOID); 
typedef WAITORTIMERCALLBACKFUNC WAITORTIMERCALLBACK; 
typedef
void
(__stdcall *PFLS_CALLBACK_FUNCTION) (
     PVOID lpFlsData
    );

typedef
BOOLEAN
(__stdcall *PSECURE_MEMORY_CACHE_CALLBACK) (
     PVOID Addr,
     SIZE_T Range
    );




typedef enum _ACTIVATION_CONTEXT_INFO_CLASS {
    ActivationContextBasicInformation                       = 1,
    ActivationContextDetailedInformation                    = 2,
    AssemblyDetailedInformationInActivationContext          = 3,
    FileInformationInAssemblyOfAssemblyInActivationContext  = 4,
    RunlevelInformationInActivationContext                  = 5,
    CompatibilityInformationInActivationContext             = 6,
    ActivationContextManifestResourceName                   = 7,
    MaxActivationContextInfoClass,

    //
    // compatibility with old names
    //
    AssemblyDetailedInformationInActivationContxt           = 3,
    FileInformationInAssemblyOfAssemblyInActivationContxt   = 4
} ACTIVATION_CONTEXT_INFO_CLASS;




typedef struct _ACTIVATION_CONTEXT_QUERY_INDEX {
    DWORD ulAssemblyIndex;
    DWORD ulFileIndexInAssembly;
} ACTIVATION_CONTEXT_QUERY_INDEX, * PACTIVATION_CONTEXT_QUERY_INDEX;

typedef const struct _ACTIVATION_CONTEXT_QUERY_INDEX * PCACTIVATION_CONTEXT_QUERY_INDEX;







typedef struct _ASSEMBLY_FILE_DETAILED_INFORMATION {
    DWORD ulFlags;
    DWORD ulFilenameLength;
    DWORD ulPathLength;

    PCWSTR lpFileName;
    PCWSTR lpFilePath;
} ASSEMBLY_FILE_DETAILED_INFORMATION, *PASSEMBLY_FILE_DETAILED_INFORMATION;
typedef const ASSEMBLY_FILE_DETAILED_INFORMATION *PCASSEMBLY_FILE_DETAILED_INFORMATION;

//
// compatibility with old names
// The new names use "file" consistently.
//





typedef struct _ACTIVATION_CONTEXT_ASSEMBLY_DETAILED_INFORMATION {
    DWORD ulFlags;
    DWORD ulEncodedAssemblyIdentityLength;      // in bytes
    DWORD ulManifestPathType;                   // ACTIVATION_CONTEXT_PATH_TYPE_*
    DWORD ulManifestPathLength;                 // in bytes
    LARGE_INTEGER liManifestLastWriteTime;      // FILETIME
    DWORD ulPolicyPathType;                     // ACTIVATION_CONTEXT_PATH_TYPE_*
    DWORD ulPolicyPathLength;                   // in bytes
    LARGE_INTEGER liPolicyLastWriteTime;        // FILETIME
    DWORD ulMetadataSatelliteRosterIndex;

    DWORD ulManifestVersionMajor;               // 1
    DWORD ulManifestVersionMinor;               // 0
    DWORD ulPolicyVersionMajor;                 // 0
    DWORD ulPolicyVersionMinor;                 // 0
    DWORD ulAssemblyDirectoryNameLength;        // in bytes

    PCWSTR lpAssemblyEncodedAssemblyIdentity;
    PCWSTR lpAssemblyManifestPath;
    PCWSTR lpAssemblyPolicyPath;
    PCWSTR lpAssemblyDirectoryName;

    DWORD  ulFileCount;
} ACTIVATION_CONTEXT_ASSEMBLY_DETAILED_INFORMATION, * PACTIVATION_CONTEXT_ASSEMBLY_DETAILED_INFORMATION;

typedef const struct _ACTIVATION_CONTEXT_ASSEMBLY_DETAILED_INFORMATION * PCACTIVATION_CONTEXT_ASSEMBLY_DETAILED_INFORMATION ;

typedef enum
{
    ACTCTX_RUN_LEVEL_UNSPECIFIED = 0,
    ACTCTX_RUN_LEVEL_AS_INVOKER,
    ACTCTX_RUN_LEVEL_HIGHEST_AVAILABLE,
    ACTCTX_RUN_LEVEL_REQUIRE_ADMIN,
    ACTCTX_RUN_LEVEL_NUMBERS
} ACTCTX_REQUESTED_RUN_LEVEL;

typedef struct _ACTIVATION_CONTEXT_RUN_LEVEL_INFORMATION {
    DWORD ulFlags;
    ACTCTX_REQUESTED_RUN_LEVEL  RunLevel;
    DWORD UiAccess;
} ACTIVATION_CONTEXT_RUN_LEVEL_INFORMATION, * PACTIVATION_CONTEXT_RUN_LEVEL_INFORMATION;

typedef const struct _ACTIVATION_CONTEXT_RUN_LEVEL_INFORMATION * PCACTIVATION_CONTEXT_RUN_LEVEL_INFORMATION ;

typedef enum
{
    ACTCTX_COMPATIBILITY_ELEMENT_TYPE_UNKNOWN = 0,
    ACTCTX_COMPATIBILITY_ELEMENT_TYPE_OS,
    ACTCTX_COMPATIBILITY_ELEMENT_TYPE_MITIGATION,
    ACTCTX_COMPATIBILITY_ELEMENT_TYPE_MAXVERSIONTESTED
} ACTCTX_COMPATIBILITY_ELEMENT_TYPE;

typedef struct _COMPATIBILITY_CONTEXT_ELEMENT {
    GUID Id;
    ACTCTX_COMPATIBILITY_ELEMENT_TYPE Type;
    ULONGLONG MaxVersionTested;
} COMPATIBILITY_CONTEXT_ELEMENT, *PCOMPATIBILITY_CONTEXT_ELEMENT;

typedef const struct _COMPATIBILITY_CONTEXT_ELEMENT *PCCOMPATIBILITY_CONTEXT_ELEMENT;




#pragma warning(push)
#pragma warning(disable:4200) 
#line 21102 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winnt.h"

typedef struct _ACTIVATION_CONTEXT_COMPATIBILITY_INFORMATION {
    DWORD ElementCount;
    COMPATIBILITY_CONTEXT_ELEMENT Elements[];
} ACTIVATION_CONTEXT_COMPATIBILITY_INFORMATION, * PACTIVATION_CONTEXT_COMPATIBILITY_INFORMATION;


#pragma warning(pop)
#line 21111 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winnt.h"

typedef const struct _ACTIVATION_CONTEXT_COMPATIBILITY_INFORMATION * PCACTIVATION_CONTEXT_COMPATIBILITY_INFORMATION;

#line 21115 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winnt.h"

typedef struct _SUPPORTED_OS_INFO {
    WORD   MajorVersion;
    WORD   MinorVersion;
} SUPPORTED_OS_INFO, *PSUPPORTED_OS_INFO;

typedef struct _MAXVERSIONTESTED_INFO {
    ULONGLONG MaxVersionTested;
} MAXVERSIONTESTED_INFO, *PMAXVERSIONTESTED_INFO;

typedef struct _ACTIVATION_CONTEXT_DETAILED_INFORMATION {
    DWORD dwFlags;
    DWORD ulFormatVersion;
    DWORD ulAssemblyCount;
    DWORD ulRootManifestPathType;
    DWORD ulRootManifestPathChars;
    DWORD ulRootConfigurationPathType;
    DWORD ulRootConfigurationPathChars;
    DWORD ulAppDirPathType;
    DWORD ulAppDirPathChars;
    PCWSTR lpRootManifestPath;
    PCWSTR lpRootConfigurationPath;
    PCWSTR lpAppDirPath;
} ACTIVATION_CONTEXT_DETAILED_INFORMATION, *PACTIVATION_CONTEXT_DETAILED_INFORMATION;

typedef const struct _ACTIVATION_CONTEXT_DETAILED_INFORMATION *PCACTIVATION_CONTEXT_DETAILED_INFORMATION;




typedef struct _HARDWARE_COUNTER_DATA {
    HARDWARE_COUNTER_TYPE Type;
    DWORD Reserved;
    DWORD64 Value;
} HARDWARE_COUNTER_DATA, *PHARDWARE_COUNTER_DATA;



typedef struct _PERFORMANCE_DATA {
    WORD   Size;
    BYTE  Version;
    BYTE  HwCountersCount;
    DWORD ContextSwitchCount;
    DWORD64 WaitReasonBitMap;
    DWORD64 CycleTime;
    DWORD RetryCount;
    DWORD Reserved;
    HARDWARE_COUNTER_DATA HwCounters[16 ];
} PERFORMANCE_DATA, *PPERFORMANCE_DATA;




#pragma region Desktop Family
































































































#line 21266 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winnt.h"

#line 21268 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winnt.h"
#pragma endregion






//
// Defines for the READ flags for Eventlogging
//





//
// The types of events that can be logged.
//







//
// Defines for the WRITE flags used by Auditing for paired events
// These are not implemented in Product 1
//







//
// Structure that defines the header of the Eventlog record. This is the
// fixed-sized portion before all the variable-length strings, binary
// data and pad bytes.
//
// TimeGenerated is the time it was generated at the client.
// TimeWritten is the time it was put into the log at the server end.
//

typedef struct _EVENTLOGRECORD {
    DWORD  Length;        // Length of full record
    DWORD  Reserved;      // Used by the service
    DWORD  RecordNumber;  // Absolute record number
    DWORD  TimeGenerated; // Seconds since 1-1-1970
    DWORD  TimeWritten;   // Seconds since 1-1-1970
    DWORD  EventID;
    WORD   EventType;
    WORD   NumStrings;
    WORD   EventCategory;
    WORD   ReservedFlags; // For use with paired events (auditing)
    DWORD  ClosingRecordNumber; // For use with paired events (auditing)
    DWORD  StringOffset;  // Offset from beginning of record
    DWORD  UserSidLength;
    DWORD  UserSidOffset;
    DWORD  DataLength;
    DWORD  DataOffset;    // Offset from beginning of record
    //
    // Then follow:
    //
    // WCHAR SourceName[]
    // WCHAR Computername[]
    // SID   UserSid
    // WCHAR Strings[]
    // BYTE  Data[]
    // CHAR  Pad[]
    // DWORD Length;
    //
} EVENTLOGRECORD, *PEVENTLOGRECORD;

//SS: start of changes to support clustering
//SS: ideally the



#pragma warning(push)
#line 21350 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winnt.h"
#pragma warning(disable : 4200) 

struct _EVENTSFORLOGFILE;
typedef struct _EVENTSFORLOGFILE EVENTSFORLOGFILE, *PEVENTSFORLOGFILE;

struct _PACKEDEVENTINFO;
typedef struct _PACKEDEVENTINFO PACKEDEVENTINFO, *PPACKEDEVENTINFO;



struct _EVENTSFORLOGFILE
{
    DWORD           ulSize;
    WCHAR           szLogicalLogFile[256 ];        //name of the logical file-security/application/system
    DWORD           ulNumRecords;
    EVENTLOGRECORD  pEventLogRecords[];
};

struct _PACKEDEVENTINFO
{
    DWORD               ulSize;  //total size of the structure
    DWORD               ulNumEventsForLogFile; //number of EventsForLogFile structure that follow
    DWORD               ulOffsets[];           //the offsets from the start of this structure to the EVENTSFORLOGFILE structure
};

#line 21376 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winnt.h"


#pragma warning(pop)


#line 21382 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winnt.h"
//SS: end of changes to support clustering
//

// begin_wdm
// begin_access

//
// Registry Specific Access Rights.
//







































// end_access

//
// Open/Create Options
//




                                                    // when system is rebooted


                                                    // when system is rebooted


                                                    // symbolic link


                                                    // special access rules
                                                    // privilege required




                                                    // virtualization for this
                                                    // open and the resulting
                                                    // handle.
















//
// Key creation/open disposition
//




//
// hive format to be used by Reg(Nt)SaveKeyEx
//




//
// Key restore & hive load flags
//


















//
// Unload Flags
//



//
// Notify filter values
//






                                                      // for async user event based notification








// end_wdm

//
//
// Predefined Value Types.
//




                                            // (with environment variable references)












// end_wdm

// begin_wdm
//
// Service Types (Bit Mask)
//

































//
// Start Type
//







//
// Error control type
//





//
//
// Define the registry driver node enumerations
//

typedef enum _CM_SERVICE_NODE_TYPE {
    DriverType               = 0x00000001 ,
    FileSystemType           = 0x00000002 ,
    Win32ServiceOwnProcess   = 0x00000010 ,
    Win32ServiceShareProcess = 0x00000020 ,
    AdapterType              = 0x00000004 ,
    RecognizerType           = 0x00000008
} SERVICE_NODE_TYPE;

typedef enum _CM_SERVICE_LOAD_TYPE {
    BootLoad    = 0x00000000 ,
    SystemLoad  = 0x00000001 ,
    AutoLoad    = 0x00000002 ,
    DemandLoad  = 0x00000003 ,
    DisableLoad = 0x00000004
} SERVICE_LOAD_TYPE;

typedef enum _CM_ERROR_CONTROL_TYPE {
    IgnoreError   = 0x00000000 ,
    NormalError   = 0x00000001 ,
    SevereError   = 0x00000002 ,
    CriticalError = 0x00000003
} SERVICE_ERROR_TYPE;

//
// Service node Flags. These flags are used by the OS loader to promote
// a driver's start type to boot start if the system is booting using
// the specified mechanism. The flags should be set in the driver's
// registry configuration.
//
// CM_SERVICE_NETWORK_BOOT_LOAD - Specified if a driver should be
// promoted on network boot.
//
// CM_SERVICE_VIRTUAL_DISK_BOOT_LOAD - Specified if a driver should be
// promoted on booting from a VHD.
//
// CM_SERVICE_USB_DISK_BOOT_LOAD - Specified if a driver should be promoted
// while booting from a USB disk.
//
// CM_SERVICE_SD_DISK_BOOT_LOAD - Specified if a driver should be promoted
// while booting from SD storage.
//
// CM_SERVICE_USB3_DISK_BOOT_LOAD - Specified if a driver should be promoted
// while booting from a disk on a USB3 controller.
//
// CM_SERVICE_MEASURED_BOOT_LOAD - Specified if a driver should be promoted
// while booting with measured boot enabled.
//
// CM_SERVICE_VERIFIER_BOOT_LOAD - Specified if a driver should be promoted
// while booting with verifier boot enabled.
//
// CM_SERVICE_WINPE_BOOT_LOAD - Specified if a driver should be promoted
// on WinPE boot.
//
// CM_SERVICE_RAM_DISK_BOOT_LOAD - Specified if a driver should be promoted
// when booting from a RAM disk.
//











//
// Mask defining the legal promotion flag values.
//















//
// IOCTL_TAPE_ERASE definitions
//




typedef struct _TAPE_ERASE {
    DWORD Type;
    BOOLEAN Immediate;
} TAPE_ERASE, *PTAPE_ERASE;

//
// IOCTL_TAPE_PREPARE definitions
//








typedef struct _TAPE_PREPARE {
    DWORD Operation;
    BOOLEAN Immediate;
} TAPE_PREPARE, *PTAPE_PREPARE;

//
// IOCTL_TAPE_WRITE_MARKS definitions
//






typedef struct _TAPE_WRITE_MARKS {
    DWORD Type;
    DWORD Count;
    BOOLEAN Immediate;
} TAPE_WRITE_MARKS, *PTAPE_WRITE_MARKS;

//
// IOCTL_TAPE_GET_POSITION definitions
//





typedef struct _TAPE_GET_POSITION {
    DWORD Type;
    DWORD Partition;
    LARGE_INTEGER Offset;
} TAPE_GET_POSITION, *PTAPE_GET_POSITION;

//
// IOCTL_TAPE_SET_POSITION definitions
//












typedef struct _TAPE_SET_POSITION {
    DWORD Method;
    DWORD Partition;
    LARGE_INTEGER Offset;
    BOOLEAN Immediate;
} TAPE_SET_POSITION, *PTAPE_SET_POSITION;

//
// IOCTL_TAPE_GET_DRIVE_PARAMS definitions
//

//
// Definitions for FeaturesLow parameter
//
































//                                              //can't be a low features bit!
//                                              //reserved; high features only

//
// Definitions for FeaturesHigh parameter
//









































typedef struct _TAPE_GET_DRIVE_PARAMETERS {
    BOOLEAN ECC;
    BOOLEAN Compression;
    BOOLEAN DataPadding;
    BOOLEAN ReportSetmarks;
    DWORD DefaultBlockSize;
    DWORD MaximumBlockSize;
    DWORD MinimumBlockSize;
    DWORD MaximumPartitionCount;
    DWORD FeaturesLow;
    DWORD FeaturesHigh;
    DWORD EOTWarningZoneSize;
} TAPE_GET_DRIVE_PARAMETERS, *PTAPE_GET_DRIVE_PARAMETERS;

//
// IOCTL_TAPE_SET_DRIVE_PARAMETERS definitions
//

typedef struct _TAPE_SET_DRIVE_PARAMETERS {
    BOOLEAN ECC;
    BOOLEAN Compression;
    BOOLEAN DataPadding;
    BOOLEAN ReportSetmarks;
    DWORD EOTWarningZoneSize;
} TAPE_SET_DRIVE_PARAMETERS, *PTAPE_SET_DRIVE_PARAMETERS;

//
// IOCTL_TAPE_GET_MEDIA_PARAMETERS definitions
//

typedef struct _TAPE_GET_MEDIA_PARAMETERS {
    LARGE_INTEGER Capacity;
    LARGE_INTEGER Remaining;
    DWORD BlockSize;
    DWORD PartitionCount;
    BOOLEAN WriteProtected;
} TAPE_GET_MEDIA_PARAMETERS, *PTAPE_GET_MEDIA_PARAMETERS;

//
// IOCTL_TAPE_SET_MEDIA_PARAMETERS definitions
//

typedef struct _TAPE_SET_MEDIA_PARAMETERS {
    DWORD BlockSize;
} TAPE_SET_MEDIA_PARAMETERS, *PTAPE_SET_MEDIA_PARAMETERS;

//
// IOCTL_TAPE_CREATE_PARTITION definitions
//





typedef struct _TAPE_CREATE_PARTITION {
    DWORD Method;
    DWORD Count;
    DWORD Size;
} TAPE_CREATE_PARTITION, *PTAPE_CREATE_PARTITION;


//
// WMI Methods
//






typedef struct _TAPE_WMI_OPERATIONS {
   DWORD Method;
   DWORD DataBufferSize;
   PVOID DataBuffer;
} TAPE_WMI_OPERATIONS, *PTAPE_WMI_OPERATIONS;

//
// Type of drive errors
//
typedef enum _TAPE_DRIVE_PROBLEM_TYPE {
   TapeDriveProblemNone, TapeDriveReadWriteWarning,
   TapeDriveReadWriteError, TapeDriveReadWarning,
   TapeDriveWriteWarning, TapeDriveReadError,
   TapeDriveWriteError, TapeDriveHardwareError,
   TapeDriveUnsupportedMedia, TapeDriveScsiConnectionError,
   TapeDriveTimetoClean, TapeDriveCleanDriveNow,
   TapeDriveMediaLifeExpired, TapeDriveSnappedTape
} TAPE_DRIVE_PROBLEM_TYPE;

#line 21958 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winnt.h"





extern "C" {
#line 21965 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winnt.h"


#line 1 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\shared\\ktmtypes.h"
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    ktmtypes.h

Abstract:

    Common types for KTM exposed at both the Nt- and Win32-layer.

Revision History:

--*/

// begin_wdm begin_winnt





extern "C" {
#line 25 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\shared\\ktmtypes.h"


#pragma warning(push)
#pragma warning(disable:4820) 
#line 30 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\shared\\ktmtypes.h"

typedef GUID UOW, *PUOW;
typedef GUID CRM_PROTOCOL_ID, *PCRM_PROTOCOL_ID;

//
// Define the TransactionManager option values
//











//
// Define the Transaction option values
//





//
// Define the ResourceManager option values
//






//
// Define the RegisterProtocol option values
//






//
// Define the Enlistment option values
//





typedef ULONG NOTIFICATION_MASK;


























//
//  Note that this flag is not included in the TRANSACTION_NOTIFY_MASK.
//  The reason being that KTM does not understand this flag yet. This
//  flag is strictly for the use of filter manager. In fact we mask it
//  out before enlisting in any transaction.
//


//
// Path to the transaction manager objects in the NT
// object namespace.
//





//
// The following three defines are here to ease the allocation
// of string buffers which are to contain a fully qualified 
// transaction manager object name, e.g., \Transaction\{GUID}
//





// TODO: warning, duplicated def in tm.h.
typedef struct _TRANSACTION_NOTIFICATION {
    PVOID         TransactionKey;
    ULONG         TransactionNotification;
    LARGE_INTEGER TmVirtualClock;
    ULONG         ArgumentLength;
} TRANSACTION_NOTIFICATION, *PTRANSACTION_NOTIFICATION;

typedef struct _TRANSACTION_NOTIFICATION_RECOVERY_ARGUMENT {
    GUID   EnlistmentId;
    UOW    UOW;
} TRANSACTION_NOTIFICATION_RECOVERY_ARGUMENT, *PTRANSACTION_NOTIFICATION_RECOVERY_ARGUMENT;



typedef struct _TRANSACTION_NOTIFICATION_TM_ONLINE_ARGUMENT {
    GUID TmIdentity;
    ULONG Flags;
} TRANSACTION_NOTIFICATION_TM_ONLINE_ARGUMENT, *PTRANSACTION_NOTIFICATION_TM_ONLINE_ARGUMENT;

typedef ULONG SAVEPOINT_ID, *PSAVEPOINT_ID;

typedef struct _TRANSACTION_NOTIFICATION_SAVEPOINT_ARGUMENT {
    SAVEPOINT_ID SavepointId;
} TRANSACTION_NOTIFICATION_SAVEPOINT_ARGUMENT, *PTRANSACTION_NOTIFICATION_SAVEPOINT_ARGUMENT;

typedef struct _TRANSACTION_NOTIFICATION_PROPAGATE_ARGUMENT {
    ULONG PropagationCookie;
    GUID  UOW;
    GUID  TmIdentity;
    ULONG BufferLength;
    // Bufferlength bytes of Buffer follow
} TRANSACTION_NOTIFICATION_PROPAGATE_ARGUMENT, *PTRANSACTION_NOTIFICATION_PROPAGATE_ARGUMENT;

typedef struct _TRANSACTION_NOTIFICATION_MARSHAL_ARGUMENT {
    ULONG MarshalCookie;
    GUID  UOW;
} TRANSACTION_NOTIFICATION_MARSHAL_ARGUMENT, *PTRANSACTION_NOTIFICATION_MARSHAL_ARGUMENT;

typedef TRANSACTION_NOTIFICATION_PROPAGATE_ARGUMENT TRANSACTION_NOTIFICATION_PROMOTE_ARGUMENT, *PTRANSACTION_NOTIFICATION_PROMOTE_ARGUMENT;







typedef struct _KCRM_MARSHAL_HEADER {
    ULONG              VersionMajor;
    ULONG              VersionMinor;
    ULONG              NumProtocols;
    ULONG              Unused;        // for alignment purposes
} KCRM_MARSHAL_HEADER, *PKCRM_MARSHAL_HEADER, * PRKCRM_MARSHAL_HEADER;

typedef struct _KCRM_TRANSACTION_BLOB {
    UOW                UOW;
    GUID               TmIdentity;
    ULONG              IsolationLevel;
    ULONG              IsolationFlags;
    ULONG              Timeout;
    WCHAR              Description[64 ];
} KCRM_TRANSACTION_BLOB, *PKCRM_TRANSACTION_BLOB, * PRKCRM_TRANSACTION_BLOB;

typedef struct _KCRM_PROTOCOL_BLOB {
    CRM_PROTOCOL_ID    ProtocolId;
     ULONG StaticInfoLength;
    ULONG              TransactionIdInfoLength; //??? ProtocolDynamicInfoLength;
    ULONG              Unused1;        // for alignment purposes
    ULONG              Unused2;        // for alignment purposes
} KCRM_PROTOCOL_BLOB, *PKCRM_PROTOCOL_BLOB, * PRKCRM_PROTOCOL_BLOB;


#pragma warning(pop)
#line 210 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\shared\\ktmtypes.h"


}
#line 214 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\shared\\ktmtypes.h"

#line 216 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\shared\\ktmtypes.h"
#line 21968 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winnt.h"


#pragma warning(push)
#pragma warning(disable:4820) 
#line 21973 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winnt.h"

//
// Types for Nt level TM calls
//

// begin_access

//
// KTM Tm object rights
//






// The following right is intended for DTC's use only; it will be
// deprecated, and no one else should take a dependency on it.


//
// Generic mappings for transaction manager rights.
//



















//
// KTM transaction object rights.
//








//
// Generic mappings for transaction rights.
// Resource managers, when enlisting, should generally use the macro
// TRANSACTION_RESOURCE_MANAGER_RIGHTS when opening a transaction.
// It's the same as generic read and write except that it does not allow
// a commit decision to be made.
//































//
// KTM resource manager object rights.
//








//
// Generic mappings for resource manager rights.
//


























//
// KTM enlistment object rights.
//






//
// Generic mappings for enlistment rights.
//



















// end_access

//
// Transaction outcomes.
//
// TODO: warning, must match values in KTRANSACTION_OUTCOME duplicated def 
// in tm.h.
//

typedef enum _TRANSACTION_OUTCOME {
    TransactionOutcomeUndetermined = 1,
    TransactionOutcomeCommitted,
    TransactionOutcomeAborted,
} TRANSACTION_OUTCOME;


typedef enum _TRANSACTION_STATE {
    TransactionStateNormal = 1,
    TransactionStateIndoubt,
    TransactionStateCommittedNotify,
} TRANSACTION_STATE;


typedef struct _TRANSACTION_BASIC_INFORMATION {
    GUID    TransactionId;
    DWORD   State;
    DWORD   Outcome;
} TRANSACTION_BASIC_INFORMATION, *PTRANSACTION_BASIC_INFORMATION;

typedef struct _TRANSACTIONMANAGER_BASIC_INFORMATION {
    GUID    TmIdentity;
    LARGE_INTEGER VirtualClock;
} TRANSACTIONMANAGER_BASIC_INFORMATION, *PTRANSACTIONMANAGER_BASIC_INFORMATION;

typedef struct _TRANSACTIONMANAGER_LOG_INFORMATION {
    GUID  LogIdentity;
} TRANSACTIONMANAGER_LOG_INFORMATION, *PTRANSACTIONMANAGER_LOG_INFORMATION;

typedef struct _TRANSACTIONMANAGER_LOGPATH_INFORMATION {
    DWORD LogPathLength;
     WCHAR LogPath[1]; // Variable size
//  Data[1];                                        // Variable size data not declared
} TRANSACTIONMANAGER_LOGPATH_INFORMATION, *PTRANSACTIONMANAGER_LOGPATH_INFORMATION;

typedef struct _TRANSACTIONMANAGER_RECOVERY_INFORMATION {
    ULONGLONG  LastRecoveredLsn;
} TRANSACTIONMANAGER_RECOVERY_INFORMATION, *PTRANSACTIONMANAGER_RECOVERY_INFORMATION;


// end_wdm
typedef struct _TRANSACTIONMANAGER_OLDEST_INFORMATION {
    GUID OldestTransactionGuid;
} TRANSACTIONMANAGER_OLDEST_INFORMATION, *PTRANSACTIONMANAGER_OLDEST_INFORMATION;
// begin_wdm


typedef struct _TRANSACTION_PROPERTIES_INFORMATION {
    DWORD              IsolationLevel;
    DWORD              IsolationFlags;
    LARGE_INTEGER      Timeout;
    DWORD              Outcome;
    DWORD              DescriptionLength;
    WCHAR              Description[1];            // Variable size
//          Data[1];            // Variable size data not declared
} TRANSACTION_PROPERTIES_INFORMATION, *PTRANSACTION_PROPERTIES_INFORMATION;

// The following info-class is intended for DTC's use only; it will be
// deprecated, and no one else should take a dependency on it.
typedef struct _TRANSACTION_BIND_INFORMATION {
    HANDLE TmHandle;
} TRANSACTION_BIND_INFORMATION, *PTRANSACTION_BIND_INFORMATION;

typedef struct _TRANSACTION_ENLISTMENT_PAIR {
    GUID   EnlistmentId;
    GUID   ResourceManagerId;
} TRANSACTION_ENLISTMENT_PAIR, *PTRANSACTION_ENLISTMENT_PAIR;

typedef struct _TRANSACTION_ENLISTMENTS_INFORMATION {
    DWORD                       NumberOfEnlistments;
    TRANSACTION_ENLISTMENT_PAIR EnlistmentPair[1]; // Variable size
} TRANSACTION_ENLISTMENTS_INFORMATION, *PTRANSACTION_ENLISTMENTS_INFORMATION;

typedef struct _TRANSACTION_SUPERIOR_ENLISTMENT_INFORMATION {
    TRANSACTION_ENLISTMENT_PAIR SuperiorEnlistmentPair;
} TRANSACTION_SUPERIOR_ENLISTMENT_INFORMATION, *PTRANSACTION_SUPERIOR_ENLISTMENT_INFORMATION;


typedef struct _RESOURCEMANAGER_BASIC_INFORMATION {
    GUID    ResourceManagerId;
    DWORD   DescriptionLength;
    WCHAR   Description[1];            // Variable size
} RESOURCEMANAGER_BASIC_INFORMATION, *PRESOURCEMANAGER_BASIC_INFORMATION;

typedef struct _RESOURCEMANAGER_COMPLETION_INFORMATION {
    HANDLE    IoCompletionPortHandle;
    ULONG_PTR CompletionKey;
} RESOURCEMANAGER_COMPLETION_INFORMATION, *PRESOURCEMANAGER_COMPLETION_INFORMATION;

// end_wdm

// begin_wdm
typedef enum _TRANSACTION_INFORMATION_CLASS {
    TransactionBasicInformation,
    TransactionPropertiesInformation,
    TransactionEnlistmentInformation,
    TransactionSuperiorEnlistmentInformation
// end_wdm
    ,
// The following info-classes are intended for DTC's use only; it will be
// deprecated, and no one else should take a dependency on it.
    TransactionBindInformation, // private and deprecated
    TransactionDTCPrivateInformation // private and deprecated
    ,
// begin_wdm
} TRANSACTION_INFORMATION_CLASS;

// begin_wdm
typedef enum _TRANSACTIONMANAGER_INFORMATION_CLASS {
    TransactionManagerBasicInformation,
    TransactionManagerLogInformation,
    TransactionManagerLogPathInformation,
    TransactionManagerRecoveryInformation = 4
// end_wdm
    ,
// The following info-classes are intended for internal use only; they
// are considered deprecated, and no one else should take a dependency
// on them.
    TransactionManagerOnlineProbeInformation = 3,
    TransactionManagerOldestTransactionInformation = 5
// end_wdm

// begin_wdm
} TRANSACTIONMANAGER_INFORMATION_CLASS;


// begin_wdm
typedef enum _RESOURCEMANAGER_INFORMATION_CLASS {
    ResourceManagerBasicInformation,
    ResourceManagerCompletionInformation,
} RESOURCEMANAGER_INFORMATION_CLASS;


typedef struct _ENLISTMENT_BASIC_INFORMATION {
    GUID    EnlistmentId;
    GUID    TransactionId;
    GUID    ResourceManagerId;
} ENLISTMENT_BASIC_INFORMATION, *PENLISTMENT_BASIC_INFORMATION;

typedef struct _ENLISTMENT_CRM_INFORMATION {
    GUID   CrmTransactionManagerId;
    GUID   CrmResourceManagerId;
    GUID   CrmEnlistmentId;
} ENLISTMENT_CRM_INFORMATION, *PENLISTMENT_CRM_INFORMATION;


// begin_wdm
typedef enum _ENLISTMENT_INFORMATION_CLASS {
    EnlistmentBasicInformation,
    EnlistmentRecoveryInformation,
    EnlistmentCrmInformation
} ENLISTMENT_INFORMATION_CLASS;

typedef struct _TRANSACTION_LIST_ENTRY {
    UOW    UOW;
} TRANSACTION_LIST_ENTRY, *PTRANSACTION_LIST_ENTRY;

typedef struct _TRANSACTION_LIST_INFORMATION {
    DWORD   NumberOfTransactions;
    TRANSACTION_LIST_ENTRY TransactionInformation[1]; // Var size
} TRANSACTION_LIST_INFORMATION, *PTRANSACTION_LIST_INFORMATION;


//
// Types of objects known to the kernel transaction manager.
//

typedef enum _KTMOBJECT_TYPE {

    KTMOBJECT_TRANSACTION,
    KTMOBJECT_TRANSACTION_MANAGER,
    KTMOBJECT_RESOURCE_MANAGER,
    KTMOBJECT_ENLISTMENT,
    KTMOBJECT_INVALID

} KTMOBJECT_TYPE, *PKTMOBJECT_TYPE;


//
// KTMOBJECT_CURSOR
//
// Used by NtEnumerateTransactionObject to enumerate a transaction
// object namespace (e.g. enlistments in a resource manager).
//

typedef struct _KTMOBJECT_CURSOR {

    //
    // The last GUID enumerated; zero if beginning enumeration.
    // 

    GUID    LastQuery;

    //
    // A count of GUIDs filled in by this last enumeration.
    // 

    DWORD   ObjectIdCount;

    //
    // ObjectIdCount GUIDs from the namespace specified.
    // 

    GUID    ObjectIds[1];

} KTMOBJECT_CURSOR, *PKTMOBJECT_CURSOR;

// begin_wdm


#pragma warning(pop)
#line 22356 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winnt.h"


}
#line 22360 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winnt.h"

#line 22362 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winnt.h"
typedef DWORD TP_VERSION, *PTP_VERSION; 

typedef struct _TP_CALLBACK_INSTANCE TP_CALLBACK_INSTANCE, *PTP_CALLBACK_INSTANCE;

typedef void (__stdcall *PTP_SIMPLE_CALLBACK)(
         PTP_CALLBACK_INSTANCE Instance,
     PVOID                 Context
    );

typedef struct _TP_POOL TP_POOL, *PTP_POOL; 

typedef enum _TP_CALLBACK_PRIORITY {
    TP_CALLBACK_PRIORITY_HIGH,
    TP_CALLBACK_PRIORITY_NORMAL,
    TP_CALLBACK_PRIORITY_LOW,
    TP_CALLBACK_PRIORITY_INVALID,
    TP_CALLBACK_PRIORITY_COUNT = TP_CALLBACK_PRIORITY_INVALID
} TP_CALLBACK_PRIORITY;

typedef struct _TP_POOL_STACK_INFORMATION {
    SIZE_T StackReserve;
    SIZE_T StackCommit;
}TP_POOL_STACK_INFORMATION, *PTP_POOL_STACK_INFORMATION;

typedef struct _TP_CLEANUP_GROUP TP_CLEANUP_GROUP, *PTP_CLEANUP_GROUP; 

typedef void (__stdcall *PTP_CLEANUP_GROUP_CANCEL_CALLBACK)(
     PVOID ObjectContext,
     PVOID CleanupContext
    );

//
// Do not manipulate this structure directly!  Allocate space for it
// and use the inline interfaces below.
//



typedef struct _TP_CALLBACK_ENVIRON_V3 {
    TP_VERSION                         Version;
    PTP_POOL                           Pool;
    PTP_CLEANUP_GROUP                  CleanupGroup;
    PTP_CLEANUP_GROUP_CANCEL_CALLBACK  CleanupGroupCancelCallback;
    PVOID                              RaceDll;
    struct _ACTIVATION_CONTEXT        *ActivationContext;
    PTP_SIMPLE_CALLBACK                FinalizationCallback;
    union {
        DWORD                          Flags;
        struct {
            DWORD                      LongFunction :  1;
            DWORD                      Persistent   :  1;
            DWORD                      Private      : 30;
        } s;
    } u;
    TP_CALLBACK_PRIORITY               CallbackPriority;
    DWORD                              Size;
} TP_CALLBACK_ENVIRON_V3;

typedef TP_CALLBACK_ENVIRON_V3 TP_CALLBACK_ENVIRON, *PTP_CALLBACK_ENVIRON;























#line 22445 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winnt.h"



__forceinline
void
TpInitializeCallbackEnviron(
     PTP_CALLBACK_ENVIRON CallbackEnviron
    )
{



    CallbackEnviron->Version = 3;





#line 22464 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winnt.h"

    CallbackEnviron->Pool = 0 ;
    CallbackEnviron->CleanupGroup = 0 ;
    CallbackEnviron->CleanupGroupCancelCallback = 0 ;
    CallbackEnviron->RaceDll = 0 ;
    CallbackEnviron->ActivationContext = 0 ;
    CallbackEnviron->FinalizationCallback = 0 ;
    CallbackEnviron->u.Flags = 0;



    CallbackEnviron->CallbackPriority = TP_CALLBACK_PRIORITY_NORMAL;
    CallbackEnviron->Size = sizeof(TP_CALLBACK_ENVIRON);

#line 22479 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winnt.h"

}

__forceinline
void
TpSetCallbackThreadpool(
     PTP_CALLBACK_ENVIRON CallbackEnviron,
        PTP_POOL             Pool
    )
{
    CallbackEnviron->Pool = Pool;
}

__forceinline
void
TpSetCallbackCleanupGroup(
      PTP_CALLBACK_ENVIRON              CallbackEnviron,
         PTP_CLEANUP_GROUP                 CleanupGroup,
     PTP_CLEANUP_GROUP_CANCEL_CALLBACK CleanupGroupCancelCallback
    )
{
    CallbackEnviron->CleanupGroup = CleanupGroup;
    CallbackEnviron->CleanupGroupCancelCallback = CleanupGroupCancelCallback;
}

__forceinline
void
TpSetCallbackActivationContext(
      PTP_CALLBACK_ENVIRON CallbackEnviron,
     struct _ACTIVATION_CONTEXT *ActivationContext
    )
{
    CallbackEnviron->ActivationContext = ActivationContext;
}

__forceinline
void
TpSetCallbackNoActivationContext(
     PTP_CALLBACK_ENVIRON CallbackEnviron
    )
{
    CallbackEnviron->ActivationContext = (struct _ACTIVATION_CONTEXT *)(LONG_PTR) -1; // INVALID_ACTIVATION_CONTEXT
}

__forceinline
void
TpSetCallbackLongFunction(
     PTP_CALLBACK_ENVIRON CallbackEnviron
    )
{
    CallbackEnviron->u.s.LongFunction = 1;
}

__forceinline
void
TpSetCallbackRaceWithDll(
     PTP_CALLBACK_ENVIRON CallbackEnviron,
        PVOID                DllHandle
    )
{
    CallbackEnviron->RaceDll = DllHandle;
}

__forceinline
void
TpSetCallbackFinalizationCallback(
     PTP_CALLBACK_ENVIRON CallbackEnviron,
        PTP_SIMPLE_CALLBACK  FinalizationCallback
    )
{
    CallbackEnviron->FinalizationCallback = FinalizationCallback;
}



__forceinline
void
TpSetCallbackPriority(
     PTP_CALLBACK_ENVIRON CallbackEnviron,
        TP_CALLBACK_PRIORITY Priority
    )
{
    CallbackEnviron->CallbackPriority = Priority;
}

#line 22565 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winnt.h"

__forceinline
void
TpSetCallbackPersistent(
     PTP_CALLBACK_ENVIRON CallbackEnviron
    )
{
    CallbackEnviron->u.s.Persistent = 1;
}


__forceinline
void
TpDestroyCallbackEnviron(
     PTP_CALLBACK_ENVIRON CallbackEnviron
    )
{
    //
    // For the current version of the callback environment, no actions
    // need to be taken to tear down an initialized structure.  This
    // may change in a future release.
    //

    (CallbackEnviron) ;
}

#line 22592 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winnt.h"


typedef struct _TP_WORK TP_WORK, *PTP_WORK;

typedef void (__stdcall *PTP_WORK_CALLBACK)(
         PTP_CALLBACK_INSTANCE Instance,
     PVOID                 Context,
         PTP_WORK              Work
    );

typedef struct _TP_TIMER TP_TIMER, *PTP_TIMER;

typedef void (__stdcall *PTP_TIMER_CALLBACK)(
         PTP_CALLBACK_INSTANCE Instance,
     PVOID                 Context,
         PTP_TIMER             Timer
    );

typedef DWORD    TP_WAIT_RESULT;

typedef struct _TP_WAIT TP_WAIT, *PTP_WAIT;

typedef void (__stdcall *PTP_WAIT_CALLBACK)(
         PTP_CALLBACK_INSTANCE Instance,
     PVOID                 Context,
         PTP_WAIT              Wait,
            TP_WAIT_RESULT        WaitResult
    );

typedef struct _TP_IO TP_IO, *PTP_IO;



__forceinline
struct _TEB *
NtCurrentTeb (
    void
    )

{
    return (struct _TEB *)__readgsqword(((LONG)(LONG_PTR)&(((NT_TIB *)0)->Self)) );
}

__forceinline
PVOID
GetCurrentFiber (
    void
    )

{

    return (PVOID)__readgsqword(((LONG)(LONG_PTR)&(((NT_TIB *)0)->FiberData)) );
}

__forceinline
PVOID
GetFiberData (
    void
    )

{

    return *(PVOID *)GetCurrentFiber();
}

#line 22658 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winnt.h"
































#line 22691 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winnt.h"
































#line 22724 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winnt.h"












#line 22737 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winnt.h"














#line 22752 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winnt.h"


}
#line 22756 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winnt.h"


#pragma warning(pop)




#line 22764 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winnt.h"

#line 22766 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winnt.h"

#line 183 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\shared\\minwindef.h"
#line 184 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\shared\\minwindef.h"

/* Types use for passing & returning polymorphic values */
typedef UINT_PTR            WPARAM;
typedef LONG_PTR            LPARAM;
typedef LONG_PTR            LRESULT;





#line 195 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\shared\\minwindef.h"



#line 199 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\shared\\minwindef.h"

#line 201 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\shared\\minwindef.h"








typedef HANDLE          *SPHANDLE;
typedef HANDLE           *LPHANDLE;
typedef HANDLE              HGLOBAL;
typedef HANDLE              HLOCAL;
typedef HANDLE              GLOBALHANDLE;
typedef HANDLE              LOCALHANDLE;



#pragma warning(push)
#pragma warning(disable:4255) 
#line 221 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\shared\\minwindef.h"


typedef INT_PTR ( __stdcall *FARPROC)();
typedef INT_PTR ( __stdcall *NEARPROC)();
typedef INT_PTR (__stdcall *PROC)();




#line 231 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\shared\\minwindef.h"




#line 236 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\shared\\minwindef.h"

#pragma warning(pop)
#line 239 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\shared\\minwindef.h"




#line 244 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\shared\\minwindef.h"

typedef WORD                ATOM;   //BUGBUG - might want to remove this from minwin

struct HKEY__{int unused;}; typedef struct HKEY__ *HKEY ;
typedef HKEY *PHKEY;
struct HMETAFILE__{int unused;}; typedef struct HMETAFILE__ *HMETAFILE ;
struct HINSTANCE__{int unused;}; typedef struct HINSTANCE__ *HINSTANCE ;
typedef HINSTANCE HMODULE;      /* HMODULEs can be used in place of HINSTANCEs */
struct HRGN__{int unused;}; typedef struct HRGN__ *HRGN ;
struct HRSRC__{int unused;}; typedef struct HRSRC__ *HRSRC ;
struct HSPRITE__{int unused;}; typedef struct HSPRITE__ *HSPRITE ;
struct HLSURF__{int unused;}; typedef struct HLSURF__ *HLSURF ;
struct HSTR__{int unused;}; typedef struct HSTR__ *HSTR ;
struct HTASK__{int unused;}; typedef struct HTASK__ *HTASK ;
struct HWINSTA__{int unused;}; typedef struct HWINSTA__ *HWINSTA ;
struct HKL__{int unused;}; typedef struct HKL__ *HKL ;


typedef int HFILE;


#line 266 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\shared\\minwindef.h"

//
//  File System time stamps are represented with the following structure:
//

typedef struct _FILETIME {
    DWORD dwLowDateTime;
    DWORD dwHighDateTime;
} FILETIME, *PFILETIME, *LPFILETIME;



}
#line 280 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\shared\\minwindef.h"

#line 282 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\shared\\minwindef.h"
#pragma endregion

#line 285 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\shared\\minwindef.h"

#line 25 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\shared\\windef.h"







#line 33 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\shared\\windef.h"



#pragma region Application Family or OneCore Family or Games Family


struct HWND__{int unused;}; typedef struct HWND__ *HWND ;
struct HHOOK__{int unused;}; typedef struct HHOOK__ *HHOOK ;

#line 43 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\shared\\windef.h"
#pragma endregion












#line 57 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\shared\\windef.h"

#pragma region Application Family




typedef void  * HGDIOBJ;


#line 67 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\shared\\windef.h"
#line 68 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\shared\\windef.h"


struct HACCEL__{int unused;}; typedef struct HACCEL__ *HACCEL ;
#line 72 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\shared\\windef.h"

struct HBITMAP__{int unused;}; typedef struct HBITMAP__ *HBITMAP ;
struct HBRUSH__{int unused;}; typedef struct HBRUSH__ *HBRUSH ;
#line 76 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\shared\\windef.h"

struct HCOLORSPACE__{int unused;}; typedef struct HCOLORSPACE__ *HCOLORSPACE ;
#line 79 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\shared\\windef.h"

struct HDC__{int unused;}; typedef struct HDC__ *HDC ;
#line 82 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\shared\\windef.h"
struct HGLRC__{int unused;}; typedef struct HGLRC__ *HGLRC ;          // OpenGL
struct HDESK__{int unused;}; typedef struct HDESK__ *HDESK ;
struct HENHMETAFILE__{int unused;}; typedef struct HENHMETAFILE__ *HENHMETAFILE ;

struct HFONT__{int unused;}; typedef struct HFONT__ *HFONT ;
#line 88 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\shared\\windef.h"
struct HICON__{int unused;}; typedef struct HICON__ *HICON ;

struct HMENU__{int unused;}; typedef struct HMENU__ *HMENU ;
#line 92 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\shared\\windef.h"

struct HPALETTE__{int unused;}; typedef struct HPALETTE__ *HPALETTE ;
struct HPEN__{int unused;}; typedef struct HPEN__ *HPEN ;
#line 96 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\shared\\windef.h"


struct HWINEVENTHOOK__{int unused;}; typedef struct HWINEVENTHOOK__ *HWINEVENTHOOK ;
#line 100 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\shared\\windef.h"

#line 102 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\shared\\windef.h"
#pragma endregion




#pragma region Application Family


struct HMONITOR__{int unused;}; typedef struct HMONITOR__ *HMONITOR ;

#line 113 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\shared\\windef.h"
#pragma endregion

#line 116 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\shared\\windef.h"

#pragma region Desktop Family


struct HUMPD__{int unused;}; typedef struct HUMPD__ *HUMPD ;

#line 123 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\shared\\windef.h"
#pragma endregion

#line 126 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\shared\\windef.h"

#pragma region Application Family



typedef HICON HCURSOR;      /* HICONs & HCURSORs are polymorphic */


#line 135 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\shared\\windef.h"

typedef DWORD   COLORREF;

#line 139 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\shared\\windef.h"
#pragma endregion

#pragma region Desktop Family


typedef DWORD   *LPCOLORREF;



#line 149 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\shared\\windef.h"
#pragma endregion

#pragma region Application Family or Games Family


typedef struct tagRECT
{
    LONG    left;
    LONG    top;
    LONG    right;
    LONG    bottom;
} RECT, *PRECT,  *NPRECT,  *LPRECT;

typedef const RECT  * LPCRECT;

typedef struct _RECTL       /* rcl */
{
    LONG    left;
    LONG    top;
    LONG    right;
    LONG    bottom;
} RECTL, *PRECTL, *LPRECTL;

typedef const RECTL  * LPCRECTL;

typedef struct tagPOINT
{
    LONG  x;
    LONG  y;
} POINT, *PPOINT,  *NPPOINT,  *LPPOINT;

typedef struct _POINTL      /* ptl  */
{
    LONG  x;
    LONG  y;
} POINTL, *PPOINTL;

typedef struct tagSIZE
{
    LONG        cx;
    LONG        cy;
} SIZE, *PSIZE, *LPSIZE;

typedef SIZE               SIZEL;
typedef SIZE               *PSIZEL, *LPSIZEL;

typedef struct tagPOINTS
{

    SHORT   x;
    SHORT   y;



#line 204 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\shared\\windef.h"
} POINTS, *PPOINTS, *LPPOINTS;

#line 207 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\shared\\windef.h"
#pragma endregion

/* mode selections for the device mode function */










/* device capabilities indices */




















}
#line 243 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\shared\\windef.h"

#pragma region Desktop Family





struct DPI_AWARENESS_CONTEXT__{int unused;}; typedef struct DPI_AWARENESS_CONTEXT__ *DPI_AWARENESS_CONTEXT ;

typedef enum DPI_AWARENESS {
    DPI_AWARENESS_INVALID           = -1,
    DPI_AWARENESS_UNAWARE           = 0,
    DPI_AWARENESS_SYSTEM_AWARE      = 1,
    DPI_AWARENESS_PER_MONITOR_AWARE = 2
} DPI_AWARENESS;







typedef enum DPI_HOSTING_BEHAVIOR {
    DPI_HOSTING_BEHAVIOR_INVALID     = -1,
    DPI_HOSTING_BEHAVIOR_DEFAULT     = 0,
    DPI_HOSTING_BEHAVIOR_MIXED       = 1
} DPI_HOSTING_BEHAVIOR;

#line 272 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\shared\\windef.h"

#line 274 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\shared\\windef.h"

#line 172 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\Windows.h"
#line 1 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winbase.h"
//@[contract("winbase"), comment("MVI_tracked - https://osgwiki.com/wiki/Microsoft_Virus_Initiative")];



/************************************************************************
*                                                                       *
*   winbase.h -- This module defines the 32-Bit Windows Base APIs       *
*                                                                       *
*   Copyright (c) Microsoft Corp. All rights reserved.                  *
*                                                                       *
************************************************************************/






#pragma once
#line 20 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winbase.h"

#pragma warning(push)
#pragma warning(disable:4820) 
#pragma warning(disable:4668) 
#line 25 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winbase.h"
#pragma warning(disable:4001) 
#pragma warning(disable:4201) 
#pragma warning(disable:4214) 
#line 29 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winbase.h"





#line 1 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\shared\\apisetcconv.h"
/************************************************************************
*                                                                       *
*   apisetcconv.h -- Contains Win32 Calling Conventions for APISETs     *
*                    that were a part of the old legacy APIs            *
*   Copyright (c) Microsoft Corp. All rights reserved.                  *
*                                                                       *
************************************************************************/









#line 18 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\shared\\apisetcconv.h"
#line 19 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\shared\\apisetcconv.h"






#line 26 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\shared\\apisetcconv.h"
#line 27 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\shared\\apisetcconv.h"






#line 34 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\shared\\apisetcconv.h"
#line 35 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\shared\\apisetcconv.h"








#line 44 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\shared\\apisetcconv.h"
#line 45 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\shared\\apisetcconv.h"







#line 53 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\shared\\apisetcconv.h"






#line 60 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\shared\\apisetcconv.h"
#line 61 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\shared\\apisetcconv.h"






#line 68 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\shared\\apisetcconv.h"
#line 69 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\shared\\apisetcconv.h"






#line 76 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\shared\\apisetcconv.h"
#line 77 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\shared\\apisetcconv.h"






#line 84 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\shared\\apisetcconv.h"
#line 85 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\shared\\apisetcconv.h"






#line 92 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\shared\\apisetcconv.h"
#line 93 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\shared\\apisetcconv.h"






#line 100 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\shared\\apisetcconv.h"
#line 101 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\shared\\apisetcconv.h"

#line 103 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\shared\\apisetcconv.h"
#line 35 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winbase.h"
#line 1 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\minwinbase.h"
/************************************************************************
*                                                                       *
*   minwinbase.h -- This module defines the 32-Bit Windows Base APIs    *
*                                                                       *
*   Copyright (c) Microsoft Corp. All rights reserved.                  *
*                                                                       *
************************************************************************/
#pragma once




#pragma warning(disable:4514)

#pragma warning(disable:4103)
#line 17 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\minwinbase.h"

#pragma warning(push)
#pragma warning(disable:4820) 
#line 21 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\minwinbase.h"
#pragma warning(disable:4001)
#pragma warning(disable:4201)
#pragma warning(disable:4214)
#line 25 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\minwinbase.h"





extern "C" {
#line 32 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\minwinbase.h"

//
// Constants
//






//
// Typedefs
//

typedef struct _SECURITY_ATTRIBUTES {
    DWORD nLength;
    LPVOID lpSecurityDescriptor;
    BOOL bInheritHandle;
} SECURITY_ATTRIBUTES, *PSECURITY_ATTRIBUTES, *LPSECURITY_ATTRIBUTES;

typedef struct _OVERLAPPED {
    ULONG_PTR Internal;
    ULONG_PTR InternalHigh;
    union {
        struct {
            DWORD Offset;
            DWORD OffsetHigh;
        }  ;
        PVOID Pointer;
    }  ;

    HANDLE  hEvent;
} OVERLAPPED, *LPOVERLAPPED;

typedef struct _OVERLAPPED_ENTRY {
    ULONG_PTR lpCompletionKey;
    LPOVERLAPPED lpOverlapped;
    ULONG_PTR Internal;
    DWORD dwNumberOfBytesTransferred;
} OVERLAPPED_ENTRY, *LPOVERLAPPED_ENTRY;

//
//  File System time stamps are represented with the following structure:
//










//
// System time is represented with the following structure:
//

typedef struct _SYSTEMTIME {
    WORD wYear;
    WORD wMonth;
    WORD wDayOfWeek;
    WORD wDay;
    WORD wHour;
    WORD wMinute;
    WORD wSecond;
    WORD wMilliseconds;
} SYSTEMTIME, *PSYSTEMTIME, *LPSYSTEMTIME;


typedef struct _WIN32_FIND_DATAA {
    DWORD dwFileAttributes;
    FILETIME ftCreationTime;
    FILETIME ftLastAccessTime;
    FILETIME ftLastWriteTime;
    DWORD nFileSizeHigh;
    DWORD nFileSizeLow;
    DWORD dwReserved0;
    DWORD dwReserved1;
     CHAR   cFileName[ 260 ];
     CHAR   cAlternateFileName[ 14 ];





} WIN32_FIND_DATAA, *PWIN32_FIND_DATAA, *LPWIN32_FIND_DATAA;
typedef struct _WIN32_FIND_DATAW {
    DWORD dwFileAttributes;
    FILETIME ftCreationTime;
    FILETIME ftLastAccessTime;
    FILETIME ftLastWriteTime;
    DWORD nFileSizeHigh;
    DWORD nFileSizeLow;
    DWORD dwReserved0;
    DWORD dwReserved1;
     WCHAR  cFileName[ 260 ];
     WCHAR  cAlternateFileName[ 14 ];





} WIN32_FIND_DATAW, *PWIN32_FIND_DATAW, *LPWIN32_FIND_DATAW;





typedef WIN32_FIND_DATAA WIN32_FIND_DATA;
typedef PWIN32_FIND_DATAA PWIN32_FIND_DATA;
typedef LPWIN32_FIND_DATAA LPWIN32_FIND_DATA;
#line 145 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\minwinbase.h"



typedef enum _FINDEX_INFO_LEVELS {
    FindExInfoStandard,
    FindExInfoBasic,
    FindExInfoMaxInfoLevel
} FINDEX_INFO_LEVELS;





#line 159 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\minwinbase.h"

typedef enum _FINDEX_SEARCH_OPS {
    FindExSearchNameMatch,
    FindExSearchLimitToDirectories,
    FindExSearchLimitToDevices,
    FindExSearchMaxSearchOp
} FINDEX_SEARCH_OPS;
#line 167 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\minwinbase.h"







#line 175 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\minwinbase.h"
#line 176 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\minwinbase.h"

typedef enum _GET_FILEEX_INFO_LEVELS {
    GetFileExInfoStandard,
    GetFileExMaxInfoLevel
} GET_FILEEX_INFO_LEVELS;


typedef enum _FILE_INFO_BY_HANDLE_CLASS {
    FileBasicInfo,
    FileStandardInfo,
    FileNameInfo,
    FileRenameInfo,
    FileDispositionInfo,
    FileAllocationInfo,
    FileEndOfFileInfo,
    FileStreamInfo,
    FileCompressionInfo,
    FileAttributeTagInfo,
    FileIdBothDirectoryInfo,
    FileIdBothDirectoryRestartInfo,
    FileIoPriorityHintInfo,
    FileRemoteProtocolInfo,
    FileFullDirectoryInfo,
    FileFullDirectoryRestartInfo,






#line 207 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\minwinbase.h"

    FileDispositionInfoEx,
    FileRenameInfoEx,
#line 211 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\minwinbase.h"
    FileCaseSensitiveInfo,
    FileNormalizedNameInfo,
    MaximumFileInfoByHandleClass
} FILE_INFO_BY_HANDLE_CLASS, *PFILE_INFO_BY_HANDLE_CLASS;
#line 216 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\minwinbase.h"

typedef RTL_CRITICAL_SECTION CRITICAL_SECTION;
typedef PRTL_CRITICAL_SECTION PCRITICAL_SECTION;
typedef PRTL_CRITICAL_SECTION LPCRITICAL_SECTION;

typedef RTL_CRITICAL_SECTION_DEBUG CRITICAL_SECTION_DEBUG;
typedef PRTL_CRITICAL_SECTION_DEBUG PCRITICAL_SECTION_DEBUG;
typedef PRTL_CRITICAL_SECTION_DEBUG LPCRITICAL_SECTION_DEBUG;

typedef
void
(__stdcall *LPOVERLAPPED_COMPLETION_ROUTINE)(
        DWORD dwErrorCode,
        DWORD dwNumberOfBytesTransfered,
     LPOVERLAPPED lpOverlapped
    );




typedef struct _PROCESS_HEAP_ENTRY {
    PVOID lpData;
    DWORD cbData;
    BYTE cbOverhead;
    BYTE iRegionIndex;
    WORD wFlags;
    union {
        struct {
            HANDLE hMem;
            DWORD dwReserved[ 3 ];
        } Block;
        struct {
            DWORD dwCommittedSize;
            DWORD dwUnCommittedSize;
            LPVOID lpFirstBlock;
            LPVOID lpLastBlock;
        } Region;
    }  ;
} PROCESS_HEAP_ENTRY, *LPPROCESS_HEAP_ENTRY, *PPROCESS_HEAP_ENTRY;








typedef struct _REASON_CONTEXT {
    ULONG Version;
    DWORD Flags;
    union {
        struct {
            HMODULE LocalizedReasonModule;
            ULONG LocalizedReasonId;
            ULONG ReasonStringCount;
            LPWSTR *ReasonStrings;

        } Detailed;

        LPWSTR SimpleReasonString;
    } Reason;
} REASON_CONTEXT, *PREASON_CONTEXT;

//
// Debug APIs
//










typedef DWORD (__stdcall *PTHREAD_START_ROUTINE)(
    LPVOID lpThreadParameter
    );
typedef PTHREAD_START_ROUTINE LPTHREAD_START_ROUTINE;

typedef LPVOID (__stdcall *PENCLAVE_ROUTINE)(
    LPVOID lpThreadParameter
    );
typedef PENCLAVE_ROUTINE LPENCLAVE_ROUTINE;

typedef struct _EXCEPTION_DEBUG_INFO {
    EXCEPTION_RECORD ExceptionRecord;
    DWORD dwFirstChance;
} EXCEPTION_DEBUG_INFO, *LPEXCEPTION_DEBUG_INFO;

typedef struct _CREATE_THREAD_DEBUG_INFO {
    HANDLE hThread;
    LPVOID lpThreadLocalBase;
    LPTHREAD_START_ROUTINE lpStartAddress;
} CREATE_THREAD_DEBUG_INFO, *LPCREATE_THREAD_DEBUG_INFO;

typedef struct _CREATE_PROCESS_DEBUG_INFO {
    HANDLE hFile;
    HANDLE hProcess;
    HANDLE hThread;
    LPVOID lpBaseOfImage;
    DWORD dwDebugInfoFileOffset;
    DWORD nDebugInfoSize;
    LPVOID lpThreadLocalBase;
    LPTHREAD_START_ROUTINE lpStartAddress;
    LPVOID lpImageName;
    WORD fUnicode;
} CREATE_PROCESS_DEBUG_INFO, *LPCREATE_PROCESS_DEBUG_INFO;

typedef struct _EXIT_THREAD_DEBUG_INFO {
    DWORD dwExitCode;
} EXIT_THREAD_DEBUG_INFO, *LPEXIT_THREAD_DEBUG_INFO;

typedef struct _EXIT_PROCESS_DEBUG_INFO {
    DWORD dwExitCode;
} EXIT_PROCESS_DEBUG_INFO, *LPEXIT_PROCESS_DEBUG_INFO;

typedef struct _LOAD_DLL_DEBUG_INFO {
    HANDLE hFile;
    LPVOID lpBaseOfDll;
    DWORD dwDebugInfoFileOffset;
    DWORD nDebugInfoSize;
    LPVOID lpImageName;
    WORD fUnicode;
} LOAD_DLL_DEBUG_INFO, *LPLOAD_DLL_DEBUG_INFO;

typedef struct _UNLOAD_DLL_DEBUG_INFO {
    LPVOID lpBaseOfDll;
} UNLOAD_DLL_DEBUG_INFO, *LPUNLOAD_DLL_DEBUG_INFO;

typedef struct _OUTPUT_DEBUG_STRING_INFO {
    LPSTR lpDebugStringData;
    WORD fUnicode;
    WORD nDebugStringLength;
} OUTPUT_DEBUG_STRING_INFO, *LPOUTPUT_DEBUG_STRING_INFO;

typedef struct _RIP_INFO {
    DWORD dwError;
    DWORD dwType;
} RIP_INFO, *LPRIP_INFO;


typedef struct _DEBUG_EVENT {
    DWORD dwDebugEventCode;
    DWORD dwProcessId;
    DWORD dwThreadId;
    union {
        EXCEPTION_DEBUG_INFO Exception;
        CREATE_THREAD_DEBUG_INFO CreateThread;
        CREATE_PROCESS_DEBUG_INFO CreateProcessInfo;
        EXIT_THREAD_DEBUG_INFO ExitThread;
        EXIT_PROCESS_DEBUG_INFO ExitProcess;
        LOAD_DLL_DEBUG_INFO LoadDll;
        UNLOAD_DLL_DEBUG_INFO UnloadDll;
        OUTPUT_DEBUG_STRING_INFO DebugString;
        RIP_INFO RipInfo;
    } u;
} DEBUG_EVENT, *LPDEBUG_EVENT;


//
// Context definitions
//


typedef PCONTEXT LPCONTEXT;
#line 384 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\minwinbase.h"

//
// macros
//

/* compatibility macros */


























/* Local Memory Flags */


















/* Flags returned by LocalFlags (in addition to LMEM_DISCARDABLE) */



//
// NUMA values
//




}
#line 448 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\minwinbase.h"





#pragma warning(pop)





#line 460 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\minwinbase.h"
#line 461 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\minwinbase.h"

#line 463 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\minwinbase.h"

#line 36 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winbase.h"

//
// APISET contracts
//

#line 1 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\apiquery2.h"
/********************************************************************************
*                                                                               *
* apiquery2.h -- ApiSet Contract for api-ms-win-core-apiquery-l2                *
*                                                                               *
* Copyright (c) Microsoft Corporation. All rights reserved.                     *
*                                                                               *
********************************************************************************/


#pragma once
#line 12 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\apiquery2.h"













#line 26 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\apiquery2.h"


extern "C" {
#line 30 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\apiquery2.h"

#pragma region Desktop Family or OneCore Family



BOOL
__stdcall
IsApiSetImplemented(
     PCSTR Contract
    );


#line 43 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\apiquery2.h"
#pragma endregion


}
#line 48 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\apiquery2.h"

#line 50 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\apiquery2.h"
#line 42 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winbase.h"
#line 1 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\processenv.h"
/********************************************************************************
*                                                                               *
* ProcessEnv.h -- ApiSet Contract for api-ms-win-core-processenvironment-l1     *
*                                                                               *
* Copyright (c) Microsoft Corporation. All rights reserved.                     *
*                                                                               *
********************************************************************************/


#pragma once
#line 12 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\processenv.h"











extern "C" {
#line 25 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\processenv.h"

#pragma region Desktop Family or OneCore Family


__declspec(dllimport)
BOOL
__stdcall
SetEnvironmentStringsW(
       LPWCH NewEnvironment
    );





#line 41 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\processenv.h"
#pragma endregion

#pragma region PC Family or OneCore Family


__declspec(dllimport)
HANDLE
__stdcall
GetStdHandle(
     DWORD nStdHandle
    );


__declspec(dllimport)
BOOL
__stdcall
SetStdHandle(
     DWORD nStdHandle,
     HANDLE hHandle
    );




__declspec(dllimport)
BOOL
__stdcall
SetStdHandleEx(
     DWORD nStdHandle,
     HANDLE hHandle,
     PHANDLE phPrevValue
    );


#line 76 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\processenv.h"

#line 78 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\processenv.h"
#pragma endregion

#pragma region Application Family or OneCore Family


__declspec(dllimport)
LPSTR
__stdcall
GetCommandLineA(
    void
    );

__declspec(dllimport)
LPWSTR
__stdcall
GetCommandLineW(
    void
    );





#line 102 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\processenv.h"

__declspec(dllimport)

LPCH
__stdcall
GetEnvironmentStrings(
    void
    );


__declspec(dllimport)

LPWCH
__stdcall
GetEnvironmentStringsW(
    void
    );






#line 126 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\processenv.h"

__declspec(dllimport)
BOOL
__stdcall
FreeEnvironmentStringsA(
       LPCH penv
    );

__declspec(dllimport)
BOOL
__stdcall
FreeEnvironmentStringsW(
       LPWCH penv
    );





#line 146 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\processenv.h"

__declspec(dllimport)

DWORD
__stdcall
GetEnvironmentVariableA(
     LPCSTR lpName,
     LPSTR lpBuffer,
     DWORD nSize
    );

__declspec(dllimport)

DWORD
__stdcall
GetEnvironmentVariableW(
     LPCWSTR lpName,
     LPWSTR lpBuffer,
     DWORD nSize
    );





#line 172 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\processenv.h"

__declspec(dllimport)
BOOL
__stdcall
SetEnvironmentVariableA(
     LPCSTR lpName,
     LPCSTR lpValue
    );

__declspec(dllimport)
BOOL
__stdcall
SetEnvironmentVariableW(
     LPCWSTR lpName,
     LPCWSTR lpValue
    );





#line 194 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\processenv.h"

__declspec(dllimport)

DWORD
__stdcall
ExpandEnvironmentStringsA(
     LPCSTR lpSrc,
     LPSTR lpDst,
     DWORD nSize
    );

__declspec(dllimport)

DWORD
__stdcall
ExpandEnvironmentStringsW(
     LPCWSTR lpSrc,
     LPWSTR lpDst,
     DWORD nSize
    );





#line 220 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\processenv.h"

__declspec(dllimport)
BOOL
__stdcall
SetCurrentDirectoryA(
     LPCSTR lpPathName
    );

__declspec(dllimport)
BOOL
__stdcall
SetCurrentDirectoryW(
     LPCWSTR lpPathName
    );





#line 240 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\processenv.h"

__declspec(dllimport)

DWORD
__stdcall
GetCurrentDirectoryA(
     DWORD nBufferLength,
     LPSTR lpBuffer
    );

__declspec(dllimport)

DWORD
__stdcall
GetCurrentDirectoryW(
     DWORD nBufferLength,
     LPWSTR lpBuffer
    );





#line 264 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\processenv.h"

#line 266 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\processenv.h"
#pragma endregion

#pragma region Desktop Family or OneCore Family


__declspec(dllimport)
DWORD
__stdcall
SearchPathW(
     LPCWSTR lpPath,
     LPCWSTR lpFileName,
     LPCWSTR lpExtension,
     DWORD nBufferLength,
     LPWSTR lpBuffer,
     LPWSTR* lpFilePart
    );






#line 289 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\processenv.h"

__declspec(dllimport)
DWORD
__stdcall
SearchPathA(
     LPCSTR lpPath,
     LPCSTR lpFileName,
     LPCSTR lpExtension,
     DWORD nBufferLength,
     LPSTR lpBuffer,
     LPSTR* lpFilePart
    );




__declspec(dllimport)
BOOL
__stdcall
NeedCurrentDirectoryForExePathA(
     LPCSTR ExeName
    );

__declspec(dllimport)
BOOL
__stdcall
NeedCurrentDirectoryForExePathW(
     LPCWSTR ExeName
    );





#line 324 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\processenv.h"

#line 326 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\processenv.h"

#line 328 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\processenv.h"
#pragma endregion


}
#line 333 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\processenv.h"

#line 335 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\processenv.h"
#line 43 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winbase.h"
#line 1 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\fileapifromapp.h"
/*********************************************************************************
*                                                                                *
* fileapifromapp.h - ApiSet Contract for api-ms-win-core-file-fromapp-l1         *
*                                                                                *
* Copyright (c) Microsoft Corporation. All rights reserved.                      *
*                                                                                *
*********************************************************************************/





#pragma once
#line 15 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\fileapifromapp.h"





#line 1 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\fileapi.h"
/********************************************************************************
*                                                                               *
* FileApi.h -- ApiSet Contract for api-ms-win-core-file-l1                      *
*                                                                               *
* Copyright (c) Microsoft Corporation. All rights reserved.                     *
*                                                                               *
********************************************************************************/


#pragma once
#line 12 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\fileapi.h"










extern "C" {
#line 24 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\fileapi.h"

#pragma region Application Family or OneCore Family


//
// Constants
//










#line 42 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\fileapi.h"
#pragma endregion

#pragma region Application Family or OneCore Family


__declspec(dllimport)
LONG
__stdcall
CompareFileTime(
     const FILETIME* lpFileTime1,
     const FILETIME* lpFileTime2
    );


__declspec(dllimport)
BOOL
__stdcall
CreateDirectoryA(
     LPCSTR lpPathName,
     LPSECURITY_ATTRIBUTES lpSecurityAttributes
    );

__declspec(dllimport)
BOOL
__stdcall
CreateDirectoryW(
     LPCWSTR lpPathName,
     LPSECURITY_ATTRIBUTES lpSecurityAttributes
    );





#line 77 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\fileapi.h"

#line 79 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\fileapi.h"
#pragma endregion

#pragma region Desktop Family or OneCore Family


__declspec(dllimport)
HANDLE
__stdcall
CreateFileA(
     LPCSTR lpFileName,
     DWORD dwDesiredAccess,
     DWORD dwShareMode,
     LPSECURITY_ATTRIBUTES lpSecurityAttributes,
     DWORD dwCreationDisposition,
     DWORD dwFlagsAndAttributes,
     HANDLE hTemplateFile
    );

__declspec(dllimport)
HANDLE
__stdcall
CreateFileW(
     LPCWSTR lpFileName,
     DWORD dwDesiredAccess,
     DWORD dwShareMode,
     LPSECURITY_ATTRIBUTES lpSecurityAttributes,
     DWORD dwCreationDisposition,
     DWORD dwFlagsAndAttributes,
     HANDLE hTemplateFile
    );





#line 115 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\fileapi.h"

__declspec(dllimport)
BOOL
__stdcall
DefineDosDeviceW(
     DWORD dwFlags,
     LPCWSTR lpDeviceName,
     LPCWSTR lpTargetPath
    );






#line 131 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\fileapi.h"
#pragma endregion

#pragma region Application Family or OneCore Family


__declspec(dllimport)
BOOL
__stdcall
DeleteFileA(
     LPCSTR lpFileName
    );

__declspec(dllimport)
BOOL
__stdcall
DeleteFileW(
     LPCWSTR lpFileName
    );





#line 155 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\fileapi.h"

__declspec(dllimport)
BOOL
__stdcall
DeleteVolumeMountPointW(
     LPCWSTR lpszVolumeMountPoint
    );






__declspec(dllimport)
BOOL
__stdcall
FileTimeToLocalFileTime(
     const FILETIME* lpFileTime,
     LPFILETIME lpLocalFileTime
    );



__declspec(dllimport)
BOOL
__stdcall
FindClose(
     HANDLE hFindFile
    );


#line 187 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\fileapi.h"
#pragma endregion

#pragma region Desktop Family or OneCore Family


__declspec(dllimport)
BOOL
__stdcall
FindCloseChangeNotification(
     HANDLE hChangeHandle
    );


__declspec(dllimport)
HANDLE
__stdcall
FindFirstChangeNotificationA(
     LPCSTR lpPathName,
     BOOL bWatchSubtree,
     DWORD dwNotifyFilter
    );

__declspec(dllimport)
HANDLE
__stdcall
FindFirstChangeNotificationW(
     LPCWSTR lpPathName,
     BOOL bWatchSubtree,
     DWORD dwNotifyFilter
    );





#line 223 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\fileapi.h"

#line 225 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\fileapi.h"
#pragma endregion

#pragma region Application Family or OneCore Family


__declspec(dllimport)
HANDLE
__stdcall
FindFirstFileA(
     LPCSTR lpFileName,
     LPWIN32_FIND_DATAA lpFindFileData
    );

__declspec(dllimport)
HANDLE
__stdcall
FindFirstFileW(
     LPCWSTR lpFileName,
     LPWIN32_FIND_DATAW lpFindFileData
    );





#line 251 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\fileapi.h"



__declspec(dllimport)
HANDLE
__stdcall
FindFirstFileExA(
     LPCSTR lpFileName,
     FINDEX_INFO_LEVELS fInfoLevelId,
     LPVOID lpFindFileData,
     FINDEX_SEARCH_OPS fSearchOp,
     LPVOID lpSearchFilter,
     DWORD dwAdditionalFlags
    );

__declspec(dllimport)
HANDLE
__stdcall
FindFirstFileExW(
     LPCWSTR lpFileName,
     FINDEX_INFO_LEVELS fInfoLevelId,
     LPVOID lpFindFileData,
     FINDEX_SEARCH_OPS fSearchOp,
     LPVOID lpSearchFilter,
     DWORD dwAdditionalFlags
    );





#line 283 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\fileapi.h"

#line 285 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\fileapi.h"

#line 287 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\fileapi.h"
#pragma endregion

#pragma region Desktop Family or OneCore Family


__declspec(dllimport)
HANDLE
__stdcall
FindFirstVolumeW(
     LPWSTR lpszVolumeName,
     DWORD cchBufferLength
    );






__declspec(dllimport)
BOOL
__stdcall
FindNextChangeNotification(
     HANDLE hChangeHandle
    );


#line 314 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\fileapi.h"
#pragma endregion

#pragma region Application Family or OneCore Family


__declspec(dllimport)
BOOL
__stdcall
FindNextFileA(
     HANDLE hFindFile,
     LPWIN32_FIND_DATAA lpFindFileData
    );

__declspec(dllimport)
BOOL
__stdcall
FindNextFileW(
     HANDLE hFindFile,
     LPWIN32_FIND_DATAW lpFindFileData
    );





#line 340 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\fileapi.h"

#line 342 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\fileapi.h"
#pragma endregion

#pragma region Desktop Family or OneCore Family


__declspec(dllimport)
BOOL
__stdcall
FindNextVolumeW(
     HANDLE hFindVolume,
     LPWSTR lpszVolumeName,
     DWORD cchBufferLength
    );






__declspec(dllimport)
BOOL
__stdcall
FindVolumeClose(
     HANDLE hFindVolume
    );


#line 370 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\fileapi.h"
#pragma endregion

#pragma region Application Family or OneCore Family


__declspec(dllimport)
BOOL
__stdcall
FlushFileBuffers(
     HANDLE hFile
    );


#line 384 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\fileapi.h"
#pragma endregion

#pragma region Application Family or OneCore Family


__declspec(dllimport)
BOOL
__stdcall
GetDiskFreeSpaceA(
     LPCSTR lpRootPathName,
     LPDWORD lpSectorsPerCluster,
     LPDWORD lpBytesPerSector,
     LPDWORD lpNumberOfFreeClusters,
     LPDWORD lpTotalNumberOfClusters
    );

__declspec(dllimport)
BOOL
__stdcall
GetDiskFreeSpaceW(
     LPCWSTR lpRootPathName,
     LPDWORD lpSectorsPerCluster,
     LPDWORD lpBytesPerSector,
     LPDWORD lpNumberOfFreeClusters,
     LPDWORD lpTotalNumberOfClusters
    );





#line 416 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\fileapi.h"

__declspec(dllimport)
BOOL
__stdcall
GetDiskFreeSpaceExA(
     LPCSTR lpDirectoryName,
     PULARGE_INTEGER lpFreeBytesAvailableToCaller,
     PULARGE_INTEGER lpTotalNumberOfBytes,
     PULARGE_INTEGER lpTotalNumberOfFreeBytes
    );

__declspec(dllimport)
BOOL
__stdcall
GetDiskFreeSpaceExW(
     LPCWSTR lpDirectoryName,
     PULARGE_INTEGER lpFreeBytesAvailableToCaller,
     PULARGE_INTEGER lpTotalNumberOfBytes,
     PULARGE_INTEGER lpTotalNumberOfFreeBytes
    );





#line 442 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\fileapi.h"

//
//  The structure definition must be same as the one 
//  (FILE_FS_FULL_SIZE_INFORMATION_EX) defined in ntioapi_x.w
//

typedef struct DISK_SPACE_INFORMATION {

    //
    //  AllocationUnits are actually file system clusters.
    //  AllocationUnits * SectorsPerAllocationUnit * BytesPerSector
    //  will get you the sizes in bytes.
    //

    //
    //  The Actual*AllocationUnits are volume sizes without considering Quota
    //  setting.
    //  ActualPoolUnavailableAllocationUnits is the unavailable space for the
    //  volume due to insufficient free pool space (PoolAvailableAllocationUnits).
    //  Be aware AllocationUnits are mesured in clusters, see comments at the beginning.
    //
    //  ActualTotalAllocationUnits = ActualAvailableAllocationUnits +
    //                               ActualPoolUnavailableAllocationUnits +
    //                               UsedAllocationUnits +
    //                               TotalReservedAllocationUnits
    //

    ULONGLONG ActualTotalAllocationUnits;
    ULONGLONG ActualAvailableAllocationUnits;
    ULONGLONG ActualPoolUnavailableAllocationUnits;

    //
    //  The Caller*AllocationUnits are limited by Quota setting.
    //  CallerAvailableAllocationUnits is the unavailable space for the
    //  volume due to insufficient free pool space (PoolAvailableAllocationUnits).
    //  Be aware AllocationUnits are mesured in clusters, see comments at the beginning.
    //
    //  CallerTotalAllocationUnits = CallerAvailableAllocationUnits +
    //                               CallerPoolUnavailableAllocationUnits +
    //                               UsedAllocationUnits +
    //                               TotalReservedAllocationUnits
    //

    ULONGLONG CallerTotalAllocationUnits;
    ULONGLONG CallerAvailableAllocationUnits;
    ULONGLONG CallerPoolUnavailableAllocationUnits;

    //
    //  The used space (in clusters) of the volume.
    //

    ULONGLONG UsedAllocationUnits;

    //
    //  Total reserved space (in clusters).
    //

    ULONGLONG TotalReservedAllocationUnits;

    //
    //  A special type of reserved space (in clusters) for per-volume storage
    //  reserve and this is included in the above TotalReservedAllocationUnits.
    //

    ULONGLONG VolumeStorageReserveAllocationUnits;

    //
    //  This refers to the space (in clusters) that has been committed by
    //  storage pool but has not been allocated by file system.
    //
    //  s1 = (ActualTotalAllocationUnits - UsedAllocationUnits - TotalReservedAllocationUnits)
    //  s2 = (AvailableCommittedAllocationUnits + PoolAvailableAllocationUnits)
    //  ActualAvailableAllocationUnits = min( s1, s2 )
    //
    //  When s1 >= s2, ActualPoolUnavailableAllocationUnits = 0
    //  When s1 < s2, ActualPoolUnavailableAllocationUnits = s2 - s1.
    //

    ULONGLONG AvailableCommittedAllocationUnits;

    //
    //  Available space (in clusters) in corresponding storage pool. If the volume
    //  is not a spaces volume, the PoolAvailableAllocationUnits is set to zero.
    //

    ULONGLONG PoolAvailableAllocationUnits;

    DWORD SectorsPerAllocationUnit;
    DWORD BytesPerSector;

} DISK_SPACE_INFORMATION;

__declspec(dllimport)
HRESULT
__stdcall
GetDiskSpaceInformationA(
     LPCSTR rootPath,
     DISK_SPACE_INFORMATION* diskSpaceInfo
    );

__declspec(dllimport)
HRESULT
__stdcall
GetDiskSpaceInformationW(
     LPCWSTR rootPath,
     DISK_SPACE_INFORMATION* diskSpaceInfo
    );





#line 555 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\fileapi.h"

__declspec(dllimport)
UINT
__stdcall
GetDriveTypeA(
     LPCSTR lpRootPathName
    );

__declspec(dllimport)
UINT
__stdcall
GetDriveTypeW(
     LPCWSTR lpRootPathName
    );





#line 575 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\fileapi.h"

#line 577 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\fileapi.h"
#pragma endregion

#pragma region Application Family or OneCore Family


typedef struct _WIN32_FILE_ATTRIBUTE_DATA {
    DWORD dwFileAttributes;
    FILETIME ftCreationTime;
    FILETIME ftLastAccessTime;
    FILETIME ftLastWriteTime;
    DWORD nFileSizeHigh;
    DWORD nFileSizeLow;
} WIN32_FILE_ATTRIBUTE_DATA, *LPWIN32_FILE_ATTRIBUTE_DATA;

__declspec(dllimport)
DWORD
__stdcall
GetFileAttributesA(
     LPCSTR lpFileName
    );

__declspec(dllimport)
DWORD
__stdcall
GetFileAttributesW(
     LPCWSTR lpFileName
    );





#line 610 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\fileapi.h"

__declspec(dllimport)
BOOL
__stdcall
GetFileAttributesExA(
     LPCSTR lpFileName,
     GET_FILEEX_INFO_LEVELS fInfoLevelId,
     LPVOID lpFileInformation
    );

__declspec(dllimport)
BOOL
__stdcall
GetFileAttributesExW(
     LPCWSTR lpFileName,
     GET_FILEEX_INFO_LEVELS fInfoLevelId,
     LPVOID lpFileInformation
    );





#line 634 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\fileapi.h"

typedef struct _BY_HANDLE_FILE_INFORMATION {
    DWORD dwFileAttributes;
    FILETIME ftCreationTime;
    FILETIME ftLastAccessTime;
    FILETIME ftLastWriteTime;
    DWORD dwVolumeSerialNumber;
    DWORD nFileSizeHigh;
    DWORD nFileSizeLow;
    DWORD nNumberOfLinks;
    DWORD nFileIndexHigh;
    DWORD nFileIndexLow;
} BY_HANDLE_FILE_INFORMATION, *PBY_HANDLE_FILE_INFORMATION, *LPBY_HANDLE_FILE_INFORMATION;

__declspec(dllimport)
BOOL
__stdcall
GetFileInformationByHandle(
     HANDLE hFile,
     LPBY_HANDLE_FILE_INFORMATION lpFileInformation
    );


#line 658 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\fileapi.h"
#pragma endregion

#pragma region Desktop Family or OneCore Family


__declspec(dllimport)
DWORD
__stdcall
GetFileSize(
     HANDLE hFile,
     LPDWORD lpFileSizeHigh
    );


#line 673 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\fileapi.h"
#pragma endregion

#pragma region Application Family


__declspec(dllimport)
BOOL
__stdcall
GetFileSizeEx(
     HANDLE hFile,
     PLARGE_INTEGER lpFileSize
    );


__declspec(dllimport)
DWORD
__stdcall
GetFileType(
     HANDLE hFile
    );




__declspec(dllimport)
DWORD
__stdcall
GetFinalPathNameByHandleA(
     HANDLE hFile,
     LPSTR lpszFilePath,
     DWORD cchFilePath,
     DWORD dwFlags
    );

__declspec(dllimport)
DWORD
__stdcall
GetFinalPathNameByHandleW(
     HANDLE hFile,
     LPWSTR lpszFilePath,
     DWORD cchFilePath,
     DWORD dwFlags
    );





#line 722 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\fileapi.h"

#line 724 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\fileapi.h"

__declspec(dllimport)
BOOL
__stdcall
GetFileTime(
     HANDLE hFile,
     LPFILETIME lpCreationTime,
     LPFILETIME lpLastAccessTime,
     LPFILETIME lpLastWriteTime
    );


#line 737 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\fileapi.h"
#pragma endregion

#pragma region Application Family or Games Family


__declspec(dllimport)

DWORD
__stdcall
GetFullPathNameW(
     LPCWSTR lpFileName,
     DWORD nBufferLength,
     LPWSTR lpBuffer,
     LPWSTR* lpFilePart
    );






__declspec(dllimport)

DWORD
__stdcall
GetFullPathNameA(
     LPCSTR lpFileName,
     DWORD nBufferLength,
     LPSTR lpBuffer,
     LPSTR* lpFilePart
    );




#line 773 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\fileapi.h"

#line 775 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\fileapi.h"
#pragma endregion

#pragma region Application Family


__declspec(dllimport)
DWORD
__stdcall
GetLogicalDrives(
    void
    );


#line 789 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\fileapi.h"
#pragma endregion

#pragma region Desktop Family or OneCore Family


__declspec(dllimport)
DWORD
__stdcall
GetLogicalDriveStringsW(
     DWORD nBufferLength,
     LPWSTR lpBuffer
    );






__declspec(dllimport)

DWORD
__stdcall
GetLongPathNameA(
     LPCSTR lpszShortPath,
     LPSTR lpszLongPath,
     DWORD cchBuffer
    );




#line 821 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\fileapi.h"

#line 823 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\fileapi.h"
#pragma endregion

#pragma region Application Family or OneCore Family


__declspec(dllimport)

DWORD
__stdcall
GetLongPathNameW(
     LPCWSTR lpszShortPath,
     LPWSTR lpszLongPath,
     DWORD cchBuffer
    );






#line 844 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\fileapi.h"
#pragma endregion

#pragma region Desktop Family or OneCore Family


__declspec(dllimport)

DWORD
__stdcall
GetShortPathNameW(
     LPCWSTR lpszLongPath,
     LPWSTR lpszShortPath,
     DWORD cchBuffer
    );






#line 865 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\fileapi.h"
#pragma endregion

#pragma region Application Family or OneCore Family


__declspec(dllimport)
UINT
__stdcall
GetTempFileNameW(
     LPCWSTR lpPathName,
     LPCWSTR lpPrefixString,
     UINT uUnique,
     LPWSTR lpTempFileName
    );






#line 886 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\fileapi.h"
#pragma endregion

#pragma region Desktop Family or OneCore Family




__declspec(dllimport)
BOOL
__stdcall
GetVolumeInformationByHandleW(
     HANDLE hFile,
     LPWSTR lpVolumeNameBuffer,
     DWORD nVolumeNameSize,
     LPDWORD lpVolumeSerialNumber,
     LPDWORD lpMaximumComponentLength,
     LPDWORD lpFileSystemFlags,
     LPWSTR lpFileSystemNameBuffer,
     DWORD nFileSystemNameSize
    );


#line 909 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\fileapi.h"
#line 910 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\fileapi.h"
#pragma endregion

#pragma region Application Family or OneCore Family


__declspec(dllimport)
BOOL
__stdcall
GetVolumeInformationW(
     LPCWSTR lpRootPathName,
     LPWSTR lpVolumeNameBuffer,
     DWORD nVolumeNameSize,
     LPDWORD lpVolumeSerialNumber,
     LPDWORD lpMaximumComponentLength,
     LPDWORD lpFileSystemFlags,
     LPWSTR lpFileSystemNameBuffer,
     DWORD nFileSystemNameSize
    );






#line 935 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\fileapi.h"
#pragma endregion

#pragma region Desktop Family or OneCore Family


__declspec(dllimport)
BOOL
__stdcall
GetVolumePathNameW(
     LPCWSTR lpszFileName,
     LPWSTR lpszVolumePathName,
     DWORD cchBufferLength
    );






#line 955 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\fileapi.h"
#pragma endregion

#pragma region Application Family or OneCore Family


__declspec(dllimport)
BOOL
__stdcall
LocalFileTimeToFileTime(
     const FILETIME* lpLocalFileTime,
     LPFILETIME lpFileTime
    );


__declspec(dllimport)
BOOL
__stdcall
LockFile(
     HANDLE hFile,
     DWORD dwFileOffsetLow,
     DWORD dwFileOffsetHigh,
     DWORD nNumberOfBytesToLockLow,
     DWORD nNumberOfBytesToLockHigh
    );


__declspec(dllimport)
BOOL
__stdcall
LockFileEx(
     HANDLE hFile,
     DWORD dwFlags,
     DWORD dwReserved,
     DWORD nNumberOfBytesToLockLow,
     DWORD nNumberOfBytesToLockHigh,
     LPOVERLAPPED lpOverlapped
    );


#line 995 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\fileapi.h"
#pragma endregion

#pragma region Desktop Family or OneCore Family


__declspec(dllimport)
DWORD
__stdcall
QueryDosDeviceW(
     LPCWSTR lpDeviceName,
     LPWSTR lpTargetPath,
     DWORD ucchMax
    );






#line 1015 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\fileapi.h"
#pragma endregion

#pragma region Application Family or OneCore Family


__declspec(dllimport)

BOOL
__stdcall
ReadFile(
     HANDLE hFile,
      LPVOID lpBuffer,
     DWORD nNumberOfBytesToRead,
     LPDWORD lpNumberOfBytesRead,
     LPOVERLAPPED lpOverlapped
    );


__declspec(dllimport)

BOOL
__stdcall
ReadFileEx(
     HANDLE hFile,
      LPVOID lpBuffer,
     DWORD nNumberOfBytesToRead,
     LPOVERLAPPED lpOverlapped,
     LPOVERLAPPED_COMPLETION_ROUTINE lpCompletionRoutine
    );

    
#line 1047 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\fileapi.h"
#pragma endregion

#pragma region Desktop Family or OneCore Family


__declspec(dllimport)

BOOL
__stdcall
ReadFileScatter(
     HANDLE hFile,
     FILE_SEGMENT_ELEMENT aSegmentArray[],
     DWORD nNumberOfBytesToRead,
     LPDWORD lpReserved,
     LPOVERLAPPED lpOverlapped
    );


#line 1066 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\fileapi.h"
#pragma endregion

#pragma region Application Family or OneCore Family


__declspec(dllimport)
BOOL
__stdcall
RemoveDirectoryA(
     LPCSTR lpPathName
    );

__declspec(dllimport)
BOOL
__stdcall
RemoveDirectoryW(
     LPCWSTR lpPathName
    );





#line 1090 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\fileapi.h"

__declspec(dllimport)
BOOL
__stdcall
SetEndOfFile(
     HANDLE hFile
    );


__declspec(dllimport)
BOOL
__stdcall
SetFileAttributesA(
     LPCSTR lpFileName,
     DWORD dwFileAttributes
    );

__declspec(dllimport)
BOOL
__stdcall
SetFileAttributesW(
     LPCWSTR lpFileName,
     DWORD dwFileAttributes
    );





#line 1120 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\fileapi.h"



__declspec(dllimport)
BOOL
__stdcall
SetFileInformationByHandle(
     HANDLE hFile,
     FILE_INFO_BY_HANDLE_CLASS FileInformationClass,
     LPVOID lpFileInformation,
     DWORD dwBufferSize
    );


#line 1135 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\fileapi.h"

__declspec(dllimport)
DWORD
__stdcall
SetFilePointer(
     HANDLE hFile,
     LONG lDistanceToMove,
     PLONG lpDistanceToMoveHigh,
     DWORD dwMoveMethod
    );


__declspec(dllimport)
BOOL
__stdcall
SetFilePointerEx(
     HANDLE hFile,
     LARGE_INTEGER liDistanceToMove,
     PLARGE_INTEGER lpNewFilePointer,
     DWORD dwMoveMethod
    );


__declspec(dllimport)
BOOL
__stdcall
SetFileTime(
     HANDLE hFile,
     const FILETIME* lpCreationTime,
     const FILETIME* lpLastAccessTime,
     const FILETIME* lpLastWriteTime
    );


#line 1170 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\fileapi.h"
#pragma endregion

#pragma region Desktop Family or OneCore Family




__declspec(dllimport)
BOOL
__stdcall
SetFileValidData(
     HANDLE hFile,
     LONGLONG ValidDataLength
    );


#line 1187 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\fileapi.h"

#line 1189 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\fileapi.h"
#pragma endregion

#pragma region Application Family or OneCore Family


__declspec(dllimport)
BOOL
__stdcall
UnlockFile(
     HANDLE hFile,
     DWORD dwFileOffsetLow,
     DWORD dwFileOffsetHigh,
     DWORD nNumberOfBytesToUnlockLow,
     DWORD nNumberOfBytesToUnlockHigh
    );


__declspec(dllimport)
BOOL
__stdcall
UnlockFileEx(
     HANDLE hFile,
     DWORD dwReserved,
     DWORD nNumberOfBytesToUnlockLow,
     DWORD nNumberOfBytesToUnlockHigh,
     LPOVERLAPPED lpOverlapped
    );


__declspec(dllimport)
BOOL
__stdcall
WriteFile(
     HANDLE hFile,
     LPCVOID lpBuffer,
     DWORD nNumberOfBytesToWrite,
     LPDWORD lpNumberOfBytesWritten,
     LPOVERLAPPED lpOverlapped
    );


__declspec(dllimport)
BOOL
__stdcall
WriteFileEx(
     HANDLE hFile,
     LPCVOID lpBuffer,
     DWORD nNumberOfBytesToWrite,
     LPOVERLAPPED lpOverlapped,
     LPOVERLAPPED_COMPLETION_ROUTINE lpCompletionRoutine
    );

    
#line 1243 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\fileapi.h"
#pragma endregion

#pragma region Desktop Family or OneCore Family


__declspec(dllimport)
BOOL
__stdcall
WriteFileGather(
     HANDLE hFile,
     FILE_SEGMENT_ELEMENT aSegmentArray[],
     DWORD nNumberOfBytesToWrite,
     LPDWORD lpReserved,
     LPOVERLAPPED lpOverlapped
    );


#line 1261 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\fileapi.h"
#pragma endregion

#pragma region Application Family or OneCore Family


__declspec(dllimport)
DWORD
__stdcall
GetTempPathW(
     DWORD nBufferLength,
     LPWSTR lpBuffer
    );






#line 1280 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\fileapi.h"
#pragma endregion

#pragma region Desktop Family or OneCore Family


__declspec(dllimport)
BOOL
__stdcall
GetVolumeNameForVolumeMountPointW(
     LPCWSTR lpszVolumeMountPoint,
     LPWSTR lpszVolumeName,
     DWORD cchBufferLength
    );








__declspec(dllimport)
BOOL
__stdcall
GetVolumePathNamesForVolumeNameW(
     LPCWSTR lpszVolumeName,
       LPWCH lpszVolumePathNames,
     DWORD cchBufferLength,
     PDWORD lpcchReturnLength
    );






#line 1317 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\fileapi.h"

#line 1319 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\fileapi.h"
#pragma endregion

#pragma region Application Family or OneCore Family

























#line 1348 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\fileapi.h"

#line 1350 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\fileapi.h"
#pragma endregion

#pragma region Desktop Family or OneCore Family




__declspec(dllimport)
BOOL
__stdcall
SetFileIoOverlappedRange(
     HANDLE FileHandle,
     PUCHAR OverlappedRangeStart,
     ULONG Length
    );


#line 1368 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\fileapi.h"

#line 1370 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\fileapi.h"
#pragma endregion

#pragma region Desktop Family or OneCore Family




__declspec(dllimport)
DWORD
__stdcall
GetCompressedFileSizeA(
     LPCSTR lpFileName,
     LPDWORD lpFileSizeHigh
    );

__declspec(dllimport)
DWORD
__stdcall
GetCompressedFileSizeW(
     LPCWSTR lpFileName,
     LPDWORD lpFileSizeHigh
    );





#line 1398 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\fileapi.h"

#line 1400 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\fileapi.h"

#line 1402 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\fileapi.h"
#pragma endregion

#pragma region Desktop Family or OneCore Family




typedef enum _STREAM_INFO_LEVELS {

    FindStreamInfoStandard,
    FindStreamInfoMaxInfoLevel

} STREAM_INFO_LEVELS;

typedef struct _WIN32_FIND_STREAM_DATA {

    LARGE_INTEGER StreamSize;
    WCHAR cStreamName[ 260 + 36 ];

} WIN32_FIND_STREAM_DATA, *PWIN32_FIND_STREAM_DATA;

__declspec(dllimport)
HANDLE
__stdcall
FindFirstStreamW(
     LPCWSTR lpFileName,
     STREAM_INFO_LEVELS InfoLevel,
     LPVOID lpFindStreamData,
     DWORD dwFlags
    );


__declspec(dllimport)
BOOL
__stdcall
FindNextStreamW(
     HANDLE hFindStream,
     LPVOID lpFindStreamData
    );


#line 1444 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\fileapi.h"

__declspec(dllimport)
BOOL
__stdcall
AreFileApisANSI(
    void
    );


#line 1454 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\fileapi.h"
#pragma endregion

#pragma region Application Family or OneCore Family


__declspec(dllimport)
DWORD
__stdcall
GetTempPathA(
     DWORD nBufferLength,
     LPSTR lpBuffer
    );




#line 1471 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\fileapi.h"

#line 1473 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\fileapi.h"
#pragma endregion

#pragma region Desktop Family or OneCore Family




__declspec(dllimport)
HANDLE
__stdcall
FindFirstFileNameW(
     LPCWSTR lpFileName,
     DWORD dwFlags,
     LPDWORD StringLength,
     PWSTR LinkName
    );


__declspec(dllimport)
BOOL
__stdcall
FindNextFileNameW(
     HANDLE hFindStream,
     LPDWORD StringLength,
     PWSTR LinkName
    );


#line 1502 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\fileapi.h"

#line 1504 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\fileapi.h"
#pragma endregion

#pragma region Application Family or OneCore Family


__declspec(dllimport)
BOOL
__stdcall
GetVolumeInformationA(
     LPCSTR lpRootPathName,
     LPSTR lpVolumeNameBuffer,
     DWORD nVolumeNameSize,
     LPDWORD lpVolumeSerialNumber,
     LPDWORD lpMaximumComponentLength,
     LPDWORD lpFileSystemFlags,
     LPSTR lpFileSystemNameBuffer,
     DWORD nFileSystemNameSize
    );




#line 1527 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\fileapi.h"

__declspec(dllimport)
UINT
__stdcall
GetTempFileNameA(
     LPCSTR lpPathName,
     LPCSTR lpPrefixString,
     UINT uUnique,
     LPSTR lpTempFileName
    );




#line 1542 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\fileapi.h"
#line 1543 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\fileapi.h"
#pragma endregion

#pragma region Desktop Family or OneCore Family


__declspec(dllimport)
void
__stdcall
SetFileApisToOEM(
    void
    );


__declspec(dllimport)
void
__stdcall
SetFileApisToANSI(
    void
    );


#line 1565 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\fileapi.h"
#pragma endregion


}
#line 1570 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\fileapi.h"

#line 1572 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\fileapi.h"
#line 21 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\fileapifromapp.h"


extern "C" {
#line 25 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\fileapifromapp.h"

#pragma region Application Family






















































































































#line 146 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\fileapifromapp.h"
#line 147 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\fileapifromapp.h"
#pragma endregion


} // extern "C"
#line 152 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\fileapifromapp.h"

#line 154 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\fileapifromapp.h"
#line 44 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winbase.h"
#line 1 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\debugapi.h"
/********************************************************************************
*                                                                               *
* DebugApi.h -- ApiSet Contract for api-ms-win-core-debug-l1                    *
*                                                                               *
* Copyright (c) Microsoft Corporation. All rights reserved.                     *
*                                                                               *
********************************************************************************/


#pragma once
#line 12 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\debugapi.h"










extern "C" {
#line 24 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\debugapi.h"

#pragma region Application Family or OneCore Family



__declspec(dllimport)
BOOL
__stdcall
IsDebuggerPresent(
    void
    );

#line 37 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\debugapi.h"

#line 39 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\debugapi.h"
#pragma endregion

#pragma region Application Family or OneCore Family


__declspec(dllimport)
void
__stdcall
DebugBreak(
    void
    );


__declspec(dllimport)
void
__stdcall
OutputDebugStringA(
     LPCSTR lpOutputString
    );

__declspec(dllimport)
void
__stdcall
OutputDebugStringW(
     LPCWSTR lpOutputString
    );





#line 71 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\debugapi.h"

#line 73 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\debugapi.h"
#pragma endregion

#pragma region Desktop Family or OneCore Family


__declspec(dllimport)
BOOL
__stdcall
ContinueDebugEvent(
     DWORD dwProcessId,
     DWORD dwThreadId,
     DWORD dwContinueStatus
    );


__declspec(dllimport)
BOOL
__stdcall
WaitForDebugEvent(
     LPDEBUG_EVENT lpDebugEvent,
     DWORD dwMilliseconds
    );


__declspec(dllimport)
BOOL
__stdcall
DebugActiveProcess(
     DWORD dwProcessId
    );


__declspec(dllimport)
BOOL
__stdcall
DebugActiveProcessStop(
     DWORD dwProcessId
    );




__declspec(dllimport)
BOOL
__stdcall
CheckRemoteDebuggerPresent(
     HANDLE hProcess,
     PBOOL pbDebuggerPresent
    );


#line 125 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\debugapi.h"

#line 127 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\debugapi.h"
#pragma endregion

#pragma region Desktop Family or OneCore Family


__declspec(dllimport)
BOOL
__stdcall
WaitForDebugEventEx(
     LPDEBUG_EVENT lpDebugEvent,
     DWORD dwMilliseconds
    );


#line 142 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\debugapi.h"
#pragma endregion


}
#line 147 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\debugapi.h"

#line 149 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\debugapi.h"
#line 45 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winbase.h"
#line 1 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\utilapiset.h"
/********************************************************************************
*                                                                               *
* UtilApiSet.h -- ApiSet Contract for api-ms-win-core-util-l1-1-0               *
*                                                                               *
* Copyright (c) Microsoft Corporation. All rights reserved.                     *
*                                                                               *
********************************************************************************/


#pragma once
#line 12 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\utilapiset.h"









extern "C" {
#line 23 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\utilapiset.h"

#pragma region Application Family or OneCore Family


__declspec(dllimport)

PVOID
__stdcall
EncodePointer(
     PVOID Ptr
    );


__declspec(dllimport)

PVOID
__stdcall
DecodePointer(
     PVOID Ptr
    );


#line 46 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\utilapiset.h"
#pragma endregion

#pragma region Desktop Family or OneCore Family


__declspec(dllimport)

PVOID
__stdcall
EncodeSystemPointer(
     PVOID Ptr
    );


__declspec(dllimport)

PVOID
__stdcall
DecodeSystemPointer(
     PVOID Ptr
    );


__declspec(dllimport)
HRESULT
__stdcall
EncodeRemotePointer(
     HANDLE ProcessHandle,
     PVOID Ptr,
     PVOID* EncodedPtr
    );


__declspec(dllimport)
HRESULT
__stdcall
DecodeRemotePointer(
     HANDLE ProcessHandle,
     PVOID Ptr,
     PVOID* DecodedPtr
    );


#line 90 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\utilapiset.h"
#pragma endregion

#pragma region PC Family or OneCore Family


__declspec(dllimport)
BOOL
__stdcall
Beep(
     DWORD dwFreq,
     DWORD dwDuration
    );


#line 105 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\utilapiset.h"
#pragma endregion


}
#line 110 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\utilapiset.h"

#line 112 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\utilapiset.h"
#line 46 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winbase.h"
#line 1 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\handleapi.h"
/********************************************************************************
*                                                                               *
* handleapi.h -- ApiSet Contract for api-ms-win-core-handle-l1-1-0              *
*                                                                               *
* Copyright (c) Microsoft Corporation. All rights reserved.                     *
*                                                                               *
********************************************************************************/


#pragma once
#line 12 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\handleapi.h"









extern "C" {
#line 23 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\handleapi.h"

//
// Constants
//


#pragma region Application Family or OneCore Family


//
// Prototypes
//
__declspec(dllimport)
BOOL
__stdcall
CloseHandle(
      HANDLE hObject
    );


__declspec(dllimport)
BOOL
__stdcall
DuplicateHandle(
     HANDLE hSourceProcessHandle,
     HANDLE hSourceHandle,
     HANDLE hTargetProcessHandle,
     LPHANDLE lpTargetHandle,
     DWORD dwDesiredAccess,
     BOOL bInheritHandle,
     DWORD dwOptions
    );


__declspec(dllimport)
BOOL
__stdcall
CompareObjectHandles(
     HANDLE hFirstObjectHandle,
     HANDLE hSecondObjectHandle
    );


#line 67 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\handleapi.h"
#pragma endregion

#pragma region Desktop Family or OneCore Family


__declspec(dllimport)
BOOL
__stdcall
GetHandleInformation(
     HANDLE hObject,
     LPDWORD lpdwFlags
    );


__declspec(dllimport)
BOOL
__stdcall
SetHandleInformation(
     HANDLE hObject,
     DWORD dwMask,
     DWORD dwFlags
    );


#line 92 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\handleapi.h"
#pragma endregion


}
#line 97 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\handleapi.h"

#line 99 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\handleapi.h"
#line 47 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winbase.h"
#line 1 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\errhandlingapi.h"
/********************************************************************************
*                                                                               *
* errhandlingapi.h - ApiSet Contract for api-ms-win-core-errorhandling-l1       *
*                                                                               *
* Copyright (c) Microsoft Corporation. All rights reserved.                     *
*                                                                               *
********************************************************************************/


#pragma once
#line 12 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\errhandlingapi.h"









extern "C" {
#line 23 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\errhandlingapi.h"

#pragma region Application Family or OneCore Family


//
// Typedefs
//

typedef LONG (__stdcall *PTOP_LEVEL_EXCEPTION_FILTER)(
     struct _EXCEPTION_POINTERS *ExceptionInfo
    );

typedef PTOP_LEVEL_EXCEPTION_FILTER LPTOP_LEVEL_EXCEPTION_FILTER;

//
// Prototypes
//

__declspec(dllimport)

void
__stdcall
RaiseException(
     DWORD dwExceptionCode,
     DWORD dwExceptionFlags,
     DWORD nNumberOfArguments,
     const ULONG_PTR* lpArguments
    );


#line 54 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\errhandlingapi.h"
#pragma endregion

#pragma region Desktop Family or OneCore Family



__declspec(dllimport)
LONG
__stdcall
UnhandledExceptionFilter(
     struct _EXCEPTION_POINTERS* ExceptionInfo
    );


#line 69 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\errhandlingapi.h"
#pragma endregion

#pragma region Application Family or OneCore Family


__declspec(dllimport)
LPTOP_LEVEL_EXCEPTION_FILTER
__stdcall
SetUnhandledExceptionFilter(
     LPTOP_LEVEL_EXCEPTION_FILTER lpTopLevelExceptionFilter
    );




__declspec(dllimport)


DWORD
__stdcall
GetLastError(
    void
    );


#line 95 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\errhandlingapi.h"

__declspec(dllimport)
void
__stdcall
SetLastError(
     DWORD dwErrCode
    );


#line 105 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\errhandlingapi.h"
#pragma endregion

#pragma region Desktop Family or OneCore Family




__declspec(dllimport)
UINT
__stdcall
GetErrorMode(
    void
    );


#line 121 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\errhandlingapi.h"

#line 123 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\errhandlingapi.h"
#pragma endregion

#pragma region Application Family or OneCore Family


__declspec(dllimport)
UINT
__stdcall
SetErrorMode(
     UINT uMode
    );


#line 137 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\errhandlingapi.h"
#pragma endregion

#pragma region Desktop Family or OneCore Family




__declspec(dllimport)

PVOID
__stdcall
AddVectoredExceptionHandler(
     ULONG First,
     PVECTORED_EXCEPTION_HANDLER Handler
    );


__declspec(dllimport)
ULONG
__stdcall
RemoveVectoredExceptionHandler(
     PVOID Handle
    );


__declspec(dllimport)

PVOID
__stdcall
AddVectoredContinueHandler(
     ULONG First,
     PVECTORED_EXCEPTION_HANDLER Handler
    );


__declspec(dllimport)
ULONG
__stdcall
RemoveVectoredContinueHandler(
     PVOID Handle
    );


#line 181 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\errhandlingapi.h"
#line 182 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\errhandlingapi.h"
#pragma endregion

#pragma region Desktop Family or OneCore Family or Games Family


// RC warns because "WINBASE_DECLARE_RESTORE_LAST_ERROR" is a bit long.

//#if _WIN32_WINNT >= 0x0501 || defined(WINBASE_DECLARE_RESTORE_LAST_ERROR)















#line 206 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\errhandlingapi.h"
#line 207 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\errhandlingapi.h"

#line 209 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\errhandlingapi.h"
#pragma endregion

#pragma region Application Family or OneCore Family


__declspec(dllimport)
void
__stdcall
RaiseFailFastException(
     PEXCEPTION_RECORD pExceptionRecord,
     PCONTEXT pContextRecord,
     DWORD dwFlags
    );


#line 225 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\errhandlingapi.h"
#pragma endregion

#pragma region Desktop Family or OneCore Family


__declspec(dllimport)
void
__stdcall
FatalAppExitA(
     UINT uAction,
     LPCSTR lpMessageText
    );

__declspec(dllimport)
void
__stdcall
FatalAppExitW(
     UINT uAction,
     LPCWSTR lpMessageText
    );





#line 251 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\errhandlingapi.h"

#line 253 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\errhandlingapi.h"
#pragma endregion

#pragma region Application Family or OneCore Family


__declspec(dllimport)
DWORD
__stdcall
GetThreadErrorMode(
    void
    );


__declspec(dllimport)
BOOL
__stdcall
SetThreadErrorMode(
     DWORD dwNewMode,
     LPDWORD lpOldMode
    );


#line 276 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\errhandlingapi.h"
#pragma endregion

#pragma region Desktop Family or OneCore Family


__declspec(dllimport)
void
__stdcall
TerminateProcessOnMemoryExhaustion(
     SIZE_T FailedAllocationSize
    );


#line 290 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\errhandlingapi.h"
#pragma endregion


}
#line 295 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\errhandlingapi.h"

#line 297 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\errhandlingapi.h"
#line 48 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winbase.h"
#line 1 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\fibersapi.h"
/********************************************************************************
*                                                                               *
* fibersapi.h - ApiSet Contract for api-ms-win-core-fibers-l1                   *
*                                                                               *
* Copyright (c) Microsoft Corporation. All rights reserved.                     *
*                                                                               *
********************************************************************************/


#pragma once
#line 12 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\fibersapi.h"









extern "C" {
#line 23 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\fibersapi.h"

#pragma region Application Family or OneCore Family






#line 32 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\fibersapi.h"

__declspec(dllimport)
DWORD
__stdcall
FlsAlloc(
     PFLS_CALLBACK_FUNCTION lpCallback
    );


__declspec(dllimport)
PVOID
__stdcall
FlsGetValue(
     DWORD dwFlsIndex
    );


__declspec(dllimport)
BOOL
__stdcall
FlsSetValue(
     DWORD dwFlsIndex,
     PVOID lpFlsData
    );


__declspec(dllimport)
BOOL
__stdcall
FlsFree(
     DWORD dwFlsIndex
    );


#line 67 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\fibersapi.h"

#line 69 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\fibersapi.h"
#pragma endregion

#pragma region Application Family or OneCore Family




__declspec(dllimport)
BOOL
__stdcall
IsThreadAFiber(
    void
    );


#line 85 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\fibersapi.h"

#line 87 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\fibersapi.h"
#pragma endregion


}
#line 92 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\fibersapi.h"

#line 94 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\fibersapi.h"
#line 49 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winbase.h"
#line 1 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\namedpipeapi.h"
/********************************************************************************
*                                                                               *
* namedpipeapi.h - ApiSet Contract for api-ms-win-core-namedpipe-l1-1-0         *
*                                                                               *
* Copyright (c) Microsoft Corporation. All rights reserved.                     *
*                                                                               *
********************************************************************************/


#pragma once
#line 12 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\namedpipeapi.h"










extern "C" {
#line 24 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\namedpipeapi.h"



__declspec(dllimport)
BOOL
__stdcall
CreatePipe(
     PHANDLE hReadPipe,
     PHANDLE hWritePipe,
     LPSECURITY_ATTRIBUTES lpPipeAttributes,
     DWORD nSize
    );


__declspec(dllimport)
BOOL
__stdcall
ConnectNamedPipe(
     HANDLE hNamedPipe,
     LPOVERLAPPED lpOverlapped
    );


__declspec(dllimport)
BOOL
__stdcall
DisconnectNamedPipe(
     HANDLE hNamedPipe
    );


__declspec(dllimport)
BOOL
__stdcall
SetNamedPipeHandleState(
     HANDLE hNamedPipe,
     LPDWORD lpMode,
     LPDWORD lpMaxCollectionCount,
     LPDWORD lpCollectDataTimeout
    );


__declspec(dllimport)
BOOL
__stdcall
PeekNamedPipe(
     HANDLE hNamedPipe,
     LPVOID lpBuffer,
     DWORD nBufferSize,
     LPDWORD lpBytesRead,
     LPDWORD lpTotalBytesAvail,
     LPDWORD lpBytesLeftThisMessage
    );


__declspec(dllimport)
BOOL
__stdcall
TransactNamedPipe(
     HANDLE hNamedPipe,
     LPVOID lpInBuffer,
     DWORD nInBufferSize,
     LPVOID lpOutBuffer,
     DWORD nOutBufferSize,
     LPDWORD lpBytesRead,
     LPOVERLAPPED lpOverlapped
    );


__declspec(dllimport)
HANDLE
__stdcall
CreateNamedPipeW(
     LPCWSTR lpName,
     DWORD dwOpenMode,
     DWORD dwPipeMode,
     DWORD nMaxInstances,
     DWORD nOutBufferSize,
     DWORD nInBufferSize,
     DWORD nDefaultTimeOut,
     LPSECURITY_ATTRIBUTES lpSecurityAttributes
    );






__declspec(dllimport)
BOOL
__stdcall
WaitNamedPipeW(
     LPCWSTR lpNamedPipeName,
     DWORD nTimeOut
    );








__declspec(dllimport)
BOOL
__stdcall
GetNamedPipeClientComputerNameW(
     HANDLE Pipe,
     LPWSTR ClientComputerName,
     ULONG ClientComputerNameLength
    );


#line 138 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\namedpipeapi.h"





__declspec(dllimport)

BOOL
__stdcall
ImpersonateNamedPipeClient(
     HANDLE hNamedPipe
    );
                               

#line 153 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\namedpipeapi.h"


#pragma region Application Family or OneCore Family


__declspec(dllimport)
BOOL
__stdcall
GetNamedPipeInfo(
     HANDLE hNamedPipe,
     LPDWORD lpFlags,
     LPDWORD lpOutBufferSize,
     LPDWORD lpInBufferSize,
     LPDWORD lpMaxInstances
    );


__declspec(dllimport)
BOOL
__stdcall
GetNamedPipeHandleStateW(
     HANDLE hNamedPipe,
     LPDWORD lpState,
     LPDWORD lpCurInstances,
     LPDWORD lpMaxCollectionCount,
     LPDWORD lpCollectDataTimeout,
     LPWSTR lpUserName,
     DWORD nMaxUserNameSize
    );





#line 188 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\namedpipeapi.h"
#pragma endregion

#pragma region Application Family or OneCore Family


__declspec(dllimport)
BOOL
__stdcall
CallNamedPipeW(
     LPCWSTR lpNamedPipeName,
     LPVOID lpInBuffer,
     DWORD nInBufferSize,
     LPVOID lpOutBuffer,
     DWORD nOutBufferSize,
     LPDWORD lpBytesRead,
     DWORD nTimeOut
    );






#line 212 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\namedpipeapi.h"
#pragma endregion


}
#line 217 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\namedpipeapi.h"

#line 219 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\namedpipeapi.h"

#line 50 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winbase.h"
#line 1 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\profileapi.h"
/********************************************************************************
*                                                                               *
* profileapi.h -- ApiSet Contract for api-ms-win-core-profile-l1                *  
*                                                                               *
* Copyright (c) Microsoft Corporation. All rights reserved.                     *
*                                                                               *
********************************************************************************/


#pragma once
#line 12 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\profileapi.h"









extern "C" {
#line 23 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\profileapi.h"

#pragma region Application Family or OneCore Family


//
// Performance counter API's
//

__declspec(dllimport)
BOOL
__stdcall
QueryPerformanceCounter(
     LARGE_INTEGER* lpPerformanceCount
    );


__declspec(dllimport)
BOOL
__stdcall
QueryPerformanceFrequency(
     LARGE_INTEGER* lpFrequency
    );


#line 48 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\profileapi.h"
#pragma endregion


}
#line 53 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\profileapi.h"

#line 55 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\profileapi.h"
#line 51 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winbase.h"
#line 1 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\heapapi.h"
/********************************************************************************
*                                                                               *
* HeapApi.h -- ApiSet Contract for api-ms-win-core-heap-l1                      *  
*                                                                               *
* Copyright (c) Microsoft Corporation. All rights reserved.                     *
*                                                                               *
********************************************************************************/


#pragma once
#line 12 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\heapapi.h"











#line 24 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\heapapi.h"

#line 26 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\heapapi.h"


extern "C" {
#line 30 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\heapapi.h"


#pragma warning(push)
#pragma warning(disable:4820) 
#line 35 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\heapapi.h"

#pragma region Desktop Family or OneCore Family or Games Family


//
// typdefs
//

typedef struct _HEAP_SUMMARY {
    DWORD cb;
    SIZE_T cbAllocated;
    SIZE_T cbCommitted;
    SIZE_T cbReserved;
    SIZE_T cbMaxReserve;
} HEAP_SUMMARY, *PHEAP_SUMMARY;
typedef PHEAP_SUMMARY LPHEAP_SUMMARY;

#line 53 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\heapapi.h"
#pragma endregion

#pragma region Application Family or OneCore Family or Games Family


//
// Prototypes
//

__declspec(dllimport)

HANDLE
__stdcall
HeapCreate(
     DWORD flOptions,
     SIZE_T dwInitialSize,
     SIZE_T dwMaximumSize
    );


__declspec(dllimport)
BOOL
__stdcall
HeapDestroy(
     HANDLE hHeap
    );


__declspec(dllimport)


__declspec(allocator)
LPVOID
__stdcall
HeapAlloc(
     HANDLE hHeap,
     DWORD dwFlags,
     SIZE_T dwBytes
    );


__declspec(dllimport)



__declspec(allocator)
LPVOID
__stdcall
HeapReAlloc(
     HANDLE hHeap,
     DWORD dwFlags,
     LPVOID lpMem,
     SIZE_T dwBytes
    );


__declspec(dllimport)

BOOL
__stdcall
HeapFree(
     HANDLE hHeap,
     DWORD dwFlags,
      LPVOID lpMem
    );


__declspec(dllimport)
SIZE_T
__stdcall
HeapSize(
     HANDLE hHeap,
     DWORD dwFlags,
     LPCVOID lpMem
    );


__declspec(dllimport)
HANDLE
__stdcall
GetProcessHeap(
    void
    );


__declspec(dllimport)
SIZE_T
__stdcall
HeapCompact(
     HANDLE hHeap,
     DWORD dwFlags
    );


__declspec(dllimport)
BOOL
__stdcall
HeapSetInformation(
     HANDLE HeapHandle,
     HEAP_INFORMATION_CLASS HeapInformationClass,
     PVOID HeapInformation,
     SIZE_T HeapInformationLength
    );


#line 159 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\heapapi.h"
#pragma endregion

#pragma region Desktop Family or OneCore Family or Games Family


__declspec(dllimport)
BOOL
__stdcall
HeapValidate(
     HANDLE hHeap,
     DWORD dwFlags,
     LPCVOID lpMem
    );


#line 175 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\heapapi.h"
#pragma endregion

#pragma region Desktop Family


BOOL
__stdcall
HeapSummary(
     HANDLE hHeap,
     DWORD dwFlags,
     LPHEAP_SUMMARY lpSummary
    );


#line 190 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\heapapi.h"
#pragma endregion

#pragma region Desktop Family or OneCore Family or Games Family


__declspec(dllimport)
DWORD
__stdcall
GetProcessHeaps(
     DWORD NumberOfHeaps,
     PHANDLE ProcessHeaps
    );


__declspec(dllimport)
BOOL
__stdcall
HeapLock(
     HANDLE hHeap
    );


__declspec(dllimport)
BOOL
__stdcall
HeapUnlock(
     HANDLE hHeap
    );


__declspec(dllimport)
BOOL
__stdcall
HeapWalk(
     HANDLE hHeap,
     LPPROCESS_HEAP_ENTRY lpEntry
    );


__declspec(dllimport)
BOOL
__stdcall
HeapQueryInformation(
     HANDLE HeapHandle,
     HEAP_INFORMATION_CLASS HeapInformationClass,
     PVOID HeapInformation,
     SIZE_T HeapInformationLength,
     PSIZE_T ReturnLength
    );

    
#line 242 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\heapapi.h"
#pragma endregion

//
// HeapSummary() is in minwinbase.w within ;beg_internal tags. Has to stay there for downlevel reasons.
// 


#pragma warning(pop)
#line 251 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\heapapi.h"


}
#line 255 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\heapapi.h"

#line 257 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\heapapi.h"
#line 52 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winbase.h"
#line 1 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\ioapiset.h"
/********************************************************************************
*                                                                               *
* ioapiset.h -- ApiSet Contract for api-ms-win-core-io-l1                       *
*                                                                               *
* Copyright (c) Microsoft Corporation. All rights reserved.                     *
*                                                                               *
********************************************************************************/


#pragma once
#line 12 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\ioapiset.h"










extern "C" {
#line 24 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\ioapiset.h"

#pragma region Application Family or OneCore Family


__declspec(dllimport)

HANDLE
__stdcall
CreateIoCompletionPort(
     HANDLE FileHandle,
     HANDLE ExistingCompletionPort,
     ULONG_PTR CompletionKey,
     DWORD NumberOfConcurrentThreads
    );


__declspec(dllimport)
BOOL
__stdcall
GetQueuedCompletionStatus(
     HANDLE CompletionPort,
     LPDWORD lpNumberOfBytesTransferred,
     PULONG_PTR lpCompletionKey,
     LPOVERLAPPED* lpOverlapped,
     DWORD dwMilliseconds
    );




__declspec(dllimport)
BOOL
__stdcall
GetQueuedCompletionStatusEx(
     HANDLE CompletionPort,
     LPOVERLAPPED_ENTRY lpCompletionPortEntries,
     ULONG ulCount,
     PULONG ulNumEntriesRemoved,
     DWORD dwMilliseconds,
     BOOL fAlertable
    );


#line 68 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\ioapiset.h"

__declspec(dllimport)
BOOL
__stdcall
PostQueuedCompletionStatus(
     HANDLE CompletionPort,
     DWORD dwNumberOfBytesTransferred,
     ULONG_PTR dwCompletionKey,
     LPOVERLAPPED lpOverlapped
    );


#line 81 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\ioapiset.h"
#pragma endregion

#pragma region  Desktop Family or OneCore Family or Application Family


__declspec(dllimport)
BOOL
__stdcall
DeviceIoControl(
     HANDLE hDevice,
     DWORD dwIoControlCode,
     LPVOID lpInBuffer,
     DWORD nInBufferSize,
     LPVOID lpOutBuffer,
     DWORD nOutBufferSize,
     LPDWORD lpBytesReturned,
     LPOVERLAPPED lpOverlapped
    );


#line 102 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\ioapiset.h"
#pragma endregion

#pragma region Application Family or OneCore Family


__declspec(dllimport)
BOOL
__stdcall
GetOverlappedResult(
     HANDLE hFile,
     LPOVERLAPPED lpOverlapped,
     LPDWORD lpNumberOfBytesTransferred,
     BOOL bWait
    );




__declspec(dllimport)
BOOL
__stdcall
CancelIoEx(
     HANDLE hFile,
     LPOVERLAPPED lpOverlapped
    );


#line 130 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\ioapiset.h"

#line 132 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\ioapiset.h"
#pragma endregion

#pragma region Application Family or OneCore Family


__declspec(dllimport)
BOOL
__stdcall
CancelIo(
     HANDLE hFile
    );


__declspec(dllimport)
BOOL
__stdcall
GetOverlappedResultEx(
     HANDLE hFile,
     LPOVERLAPPED lpOverlapped,
     LPDWORD lpNumberOfBytesTransferred,
     DWORD dwMilliseconds,
     BOOL bAlertable
    );


#line 158 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\ioapiset.h"
#pragma endregion

#pragma region Desktop Family or OneCore Family




__declspec(dllimport)
BOOL
__stdcall
CancelSynchronousIo(
     HANDLE hThread
    );


#line 174 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\ioapiset.h"

#line 176 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\ioapiset.h"
#pragma endregion


}
#line 181 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\ioapiset.h"

#line 183 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\ioapiset.h"
#line 53 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winbase.h"
#line 1 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\synchapi.h"
/********************************************************************************
*                                                                               *
* synchapi.h -- ApiSet Contract for api-ms-win-core-synch-l1                    *
*                                                                               *
* Copyright (c) Microsoft Corporation. All rights reserved.                     *
*                                                                               *
********************************************************************************/


#pragma once
#line 12 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\synchapi.h"










extern "C" {
#line 24 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\synchapi.h"

#pragma region Application or OneCore Family


//
// Define the slim R/W lock.
//



typedef RTL_SRWLOCK SRWLOCK, *PSRWLOCK;

#line 37 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\synchapi.h"
#pragma endregion

#pragma region Application or OneCore Family




__declspec(dllimport)
void
__stdcall
InitializeSRWLock(
     PSRWLOCK SRWLock
    );


__declspec(dllimport)

void
__stdcall
ReleaseSRWLockExclusive(
     PSRWLOCK SRWLock
    );


__declspec(dllimport)

void
__stdcall
ReleaseSRWLockShared(
     PSRWLOCK SRWLock
    );


__declspec(dllimport)

void
__stdcall
AcquireSRWLockExclusive(
     PSRWLOCK SRWLock
    );


__declspec(dllimport)

void
__stdcall
AcquireSRWLockShared(
     PSRWLOCK SRWLock
    );


__declspec(dllimport)

BOOLEAN
__stdcall
TryAcquireSRWLockExclusive(
     PSRWLOCK SRWLock
    );


__declspec(dllimport)

BOOLEAN
__stdcall
TryAcquireSRWLockShared(
     PSRWLOCK SRWLock
    );


#line 107 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\synchapi.h"











#line 119 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\synchapi.h"

__declspec(dllimport)
void
__stdcall
InitializeCriticalSection(
     LPCRITICAL_SECTION lpCriticalSection
    );


#line 129 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\synchapi.h"

__declspec(dllimport)
void
__stdcall
EnterCriticalSection(
     LPCRITICAL_SECTION lpCriticalSection
    );


__declspec(dllimport)
void
__stdcall
LeaveCriticalSection(
     LPCRITICAL_SECTION lpCriticalSection
    );


__declspec(dllimport)

BOOL
__stdcall
InitializeCriticalSectionAndSpinCount(
     LPCRITICAL_SECTION lpCriticalSection,
     DWORD dwSpinCount
    );




__declspec(dllimport)
BOOL
__stdcall
InitializeCriticalSectionEx(
     LPCRITICAL_SECTION lpCriticalSection,
     DWORD dwSpinCount,
     DWORD Flags
    );


#line 169 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\synchapi.h"

__declspec(dllimport)
DWORD
__stdcall
SetCriticalSectionSpinCount(
     LPCRITICAL_SECTION lpCriticalSection,
     DWORD dwSpinCount
    );




__declspec(dllimport)
BOOL
__stdcall
TryEnterCriticalSection(
     LPCRITICAL_SECTION lpCriticalSection
    );


#line 190 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\synchapi.h"

__declspec(dllimport)
void
__stdcall
DeleteCriticalSection(
     LPCRITICAL_SECTION lpCriticalSection
    );


//
// Define one-time initialization primitive
//

typedef RTL_RUN_ONCE INIT_ONCE;
typedef PRTL_RUN_ONCE PINIT_ONCE;
typedef PRTL_RUN_ONCE LPINIT_ONCE;



//
// Run once flags
//





//
// The context stored in the run once structure must leave the following number
// of low order bits unused.
//



typedef
BOOL
(__stdcall *PINIT_ONCE_FN) (
     PINIT_ONCE InitOnce,
     PVOID Parameter,
     PVOID *Context
    );



__declspec(dllimport)
void
__stdcall
InitOnceInitialize(
     PINIT_ONCE InitOnce
    );


__declspec(dllimport)
BOOL
__stdcall
InitOnceExecuteOnce(
     PINIT_ONCE InitOnce,
      PINIT_ONCE_FN InitFn,
     PVOID Parameter,
     LPVOID* Context
    );


__declspec(dllimport)
BOOL
__stdcall
InitOnceBeginInitialize(
     LPINIT_ONCE lpInitOnce,
     DWORD dwFlags,
     PBOOL fPending,
     LPVOID* lpContext
    );


__declspec(dllimport)
BOOL
__stdcall
InitOnceComplete(
     LPINIT_ONCE lpInitOnce,
     DWORD dwFlags,
     LPVOID lpContext
    );


#line 275 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\synchapi.h"

//
// Define condition variable
//

typedef RTL_CONDITION_VARIABLE CONDITION_VARIABLE, *PCONDITION_VARIABLE;

//
// Static initializer for the condition variable
//



//
// Flags for condition variables
//





__declspec(dllimport)
void
__stdcall
InitializeConditionVariable(
     PCONDITION_VARIABLE ConditionVariable
    );


__declspec(dllimport)
void
__stdcall
WakeConditionVariable(
     PCONDITION_VARIABLE ConditionVariable
    );


__declspec(dllimport)
void
__stdcall
WakeAllConditionVariable(
     PCONDITION_VARIABLE ConditionVariable
    );


__declspec(dllimport)
BOOL
__stdcall
SleepConditionVariableCS(
     PCONDITION_VARIABLE ConditionVariable,
     PCRITICAL_SECTION CriticalSection,
     DWORD dwMilliseconds
    );


__declspec(dllimport)
BOOL
__stdcall
SleepConditionVariableSRW(
     PCONDITION_VARIABLE ConditionVariable,
     PSRWLOCK SRWLock,
     DWORD dwMilliseconds,
     ULONG Flags
    );


#line 342 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\synchapi.h"

__declspec(dllimport)
BOOL
__stdcall
SetEvent(
     HANDLE hEvent
    );


__declspec(dllimport)
BOOL
__stdcall
ResetEvent(
     HANDLE hEvent
    );


__declspec(dllimport)
BOOL
__stdcall
ReleaseSemaphore(
     HANDLE hSemaphore,
     LONG lReleaseCount,
     LPLONG lpPreviousCount
    );


__declspec(dllimport)
BOOL
__stdcall
ReleaseMutex(
     HANDLE hMutex
    );


__declspec(dllimport)
DWORD
__stdcall
WaitForSingleObject(
     HANDLE hHandle,
     DWORD dwMilliseconds
    );


__declspec(dllimport)
DWORD
__stdcall
SleepEx(
     DWORD dwMilliseconds,
     BOOL bAlertable
    );


__declspec(dllimport)
DWORD
__stdcall
WaitForSingleObjectEx(
     HANDLE hHandle,
     DWORD dwMilliseconds,
     BOOL bAlertable
    );


__declspec(dllimport)
DWORD
__stdcall
WaitForMultipleObjectsEx(
     DWORD nCount,
     const HANDLE* lpHandles,
     BOOL bWaitAll,
     DWORD dwMilliseconds,
     BOOL bAlertable
    );


//
// Synchronization APIs
//




__declspec(dllimport)

HANDLE
__stdcall
CreateMutexA(
     LPSECURITY_ATTRIBUTES lpMutexAttributes,
     BOOL bInitialOwner,
     LPCSTR lpName
    );

__declspec(dllimport)

HANDLE
__stdcall
CreateMutexW(
     LPSECURITY_ATTRIBUTES lpMutexAttributes,
     BOOL bInitialOwner,
     LPCWSTR lpName
    );





#line 449 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\synchapi.h"

__declspec(dllimport)

HANDLE
__stdcall
OpenMutexW(
     DWORD dwDesiredAccess,
     BOOL bInheritHandle,
     LPCWSTR lpName
    );






__declspec(dllimport)

HANDLE
__stdcall
CreateEventA(
     LPSECURITY_ATTRIBUTES lpEventAttributes,
     BOOL bManualReset,
     BOOL bInitialState,
     LPCSTR lpName
    );

__declspec(dllimport)

HANDLE
__stdcall
CreateEventW(
     LPSECURITY_ATTRIBUTES lpEventAttributes,
     BOOL bManualReset,
     BOOL bInitialState,
     LPCWSTR lpName
    );





#line 492 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\synchapi.h"

__declspec(dllimport)

HANDLE
__stdcall
OpenEventA(
     DWORD dwDesiredAccess,
     BOOL bInheritHandle,
     LPCSTR lpName
    );

__declspec(dllimport)

HANDLE
__stdcall
OpenEventW(
     DWORD dwDesiredAccess,
     BOOL bInheritHandle,
     LPCWSTR lpName
    );





#line 518 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\synchapi.h"

__declspec(dllimport)

HANDLE
__stdcall
OpenSemaphoreW(
     DWORD dwDesiredAccess,
     BOOL bInheritHandle,
     LPCWSTR lpName
    );








typedef
void
(__stdcall *PTIMERAPCROUTINE)(
     LPVOID lpArgToCompletionRoutine,
         DWORD dwTimerLowValue,
         DWORD dwTimerHighValue
    );

__declspec(dllimport)

HANDLE
__stdcall
OpenWaitableTimerW(
     DWORD dwDesiredAccess,
     BOOL bInheritHandle,
     LPCWSTR lpTimerName
    );








BOOL
__stdcall
SetWaitableTimerEx(
     HANDLE hTimer,
     const LARGE_INTEGER* lpDueTime,
     LONG lPeriod,
     PTIMERAPCROUTINE pfnCompletionRoutine,
     LPVOID lpArgToCompletionRoutine,
     PREASON_CONTEXT WakeContext,
     ULONG TolerableDelay
    );


#line 575 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\synchapi.h"

__declspec(dllimport)
BOOL
__stdcall
SetWaitableTimer(
     HANDLE hTimer,
     const LARGE_INTEGER* lpDueTime,
     LONG lPeriod,
     PTIMERAPCROUTINE pfnCompletionRoutine,
     LPVOID lpArgToCompletionRoutine,
     BOOL fResume
    );


__declspec(dllimport)
BOOL
__stdcall
CancelWaitableTimer(
     HANDLE hTimer
    );






__declspec(dllimport)

HANDLE
__stdcall
CreateMutexExA(
     LPSECURITY_ATTRIBUTES lpMutexAttributes,
     LPCSTR lpName,
     DWORD dwFlags,
     DWORD dwDesiredAccess
    );

__declspec(dllimport)

HANDLE
__stdcall
CreateMutexExW(
     LPSECURITY_ATTRIBUTES lpMutexAttributes,
     LPCWSTR lpName,
     DWORD dwFlags,
     DWORD dwDesiredAccess
    );





#line 628 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\synchapi.h"




__declspec(dllimport)

HANDLE
__stdcall
CreateEventExA(
     LPSECURITY_ATTRIBUTES lpEventAttributes,
     LPCSTR lpName,
     DWORD dwFlags,
     DWORD dwDesiredAccess
    );

__declspec(dllimport)

HANDLE
__stdcall
CreateEventExW(
     LPSECURITY_ATTRIBUTES lpEventAttributes,
     LPCWSTR lpName,
     DWORD dwFlags,
     DWORD dwDesiredAccess
    );





#line 659 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\synchapi.h"

__declspec(dllimport)

HANDLE
__stdcall
CreateSemaphoreExW(
     LPSECURITY_ATTRIBUTES lpSemaphoreAttributes,
     LONG lInitialCount,
     LONG lMaximumCount,
     LPCWSTR lpName,
     DWORD dwFlags,
     DWORD dwDesiredAccess
    );









#line 682 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\synchapi.h"

__declspec(dllimport)

HANDLE
__stdcall
CreateWaitableTimerExW(
     LPSECURITY_ATTRIBUTES lpTimerAttributes,
     LPCWSTR lpTimerName,
     DWORD dwFlags,
     DWORD dwDesiredAccess
    );






#line 700 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\synchapi.h"

#line 702 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\synchapi.h"

#line 704 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\synchapi.h"
#pragma endregion

#pragma region Desktop or OneCore Family


typedef RTL_BARRIER SYNCHRONIZATION_BARRIER;
typedef PRTL_BARRIER PSYNCHRONIZATION_BARRIER;
typedef PRTL_BARRIER LPSYNCHRONIZATION_BARRIER;





BOOL
__stdcall
EnterSynchronizationBarrier(
     LPSYNCHRONIZATION_BARRIER lpBarrier,
     DWORD dwFlags
    );


BOOL
__stdcall
InitializeSynchronizationBarrier(
     LPSYNCHRONIZATION_BARRIER lpBarrier,
     LONG lTotalThreads,
     LONG lSpinCount
    );


BOOL
__stdcall
DeleteSynchronizationBarrier(
     LPSYNCHRONIZATION_BARRIER lpBarrier
    );


#line 742 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\synchapi.h"
#pragma endregion

#pragma region Application or OneCore Family


__declspec(dllimport)
void
__stdcall
Sleep(
     DWORD dwMilliseconds
    );


BOOL
__stdcall
WaitOnAddress(
     volatile void * Address,
     PVOID CompareAddress,
     SIZE_T AddressSize,
     DWORD dwMilliseconds
    );


void
__stdcall
WakeByAddressSingle(
     PVOID Address
    );


void
__stdcall
WakeByAddressAll(
     PVOID Address
    );


#line 780 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\synchapi.h"
#pragma endregion

#pragma region Desktop or OneCore Family




__declspec(dllimport)
DWORD
__stdcall
SignalObjectAndWait(
     HANDLE hObjectToSignal,
     HANDLE hObjectToWaitOn,
     DWORD dwMilliseconds,
     BOOL bAlertable
    );


#line 799 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\synchapi.h"

#line 801 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\synchapi.h"
#pragma endregion

#pragma region Application or OneCore Family


__declspec(dllimport)
DWORD
__stdcall
WaitForMultipleObjects(
     DWORD nCount,
     const HANDLE* lpHandles,
     BOOL bWaitAll,
     DWORD dwMilliseconds
    );


__declspec(dllimport)
HANDLE
__stdcall
CreateSemaphoreW(
     LPSECURITY_ATTRIBUTES lpSemaphoreAttributes,
     LONG lInitialCount,
     LONG lMaximumCount,
     LPCWSTR lpName
    );






__declspec(dllimport)

HANDLE
__stdcall
CreateWaitableTimerW(
     LPSECURITY_ATTRIBUTES lpTimerAttributes,
     BOOL bManualReset,
     LPCWSTR lpTimerName
    );






#line 848 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\synchapi.h"
#pragma endregion


}
#line 853 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\synchapi.h"

#line 855 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\synchapi.h"
#line 54 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winbase.h"
#line 1 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\interlockedapi.h"
 
// begin_1_0
/********************************************************************************
*                                                                               *
* interlockedapi.h -- ApiSet Contract for api-ms-win-core-interlocked-l1        *
*                                                                               *
* Copyright (c) Microsoft Corporation. All rights reserved.                     *
*                                                                               *
********************************************************************************/


#pragma once
#line 14 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\interlockedapi.h"









extern "C" {
#line 25 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\interlockedapi.h"

#pragma region Application Family or OneCore Family










__declspec(dllimport)
void
__stdcall
InitializeSListHead(
     PSLIST_HEADER ListHead
    );


__declspec(dllimport)
PSLIST_ENTRY
__stdcall
InterlockedPopEntrySList(
     PSLIST_HEADER ListHead
    );


__declspec(dllimport)
PSLIST_ENTRY
__stdcall
InterlockedPushEntrySList(
     PSLIST_HEADER ListHead,
      PSLIST_ENTRY ListEntry
    );

















#line 78 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\interlockedapi.h"

__declspec(dllimport)
PSLIST_ENTRY
__stdcall
InterlockedFlushSList(
     PSLIST_HEADER ListHead
    );


__declspec(dllimport)
USHORT
__stdcall
QueryDepthSList(
     PSLIST_HEADER ListHead
    );


#line 96 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\interlockedapi.h"

#line 98 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\interlockedapi.h"

#line 100 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\interlockedapi.h"

// end_1_0
// begin_1_0

#line 105 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\interlockedapi.h"
#pragma endregion


}
#line 110 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\interlockedapi.h"

#line 112 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\interlockedapi.h"
// end_1_0
#line 55 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winbase.h"
#line 1 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\processthreadsapi.h"
/***********************************************************************************
*                                                                                  *
* processthreadsapi.h -- ApiSet Contract for api-ms-win-core-processthreads-l1     *
*                                                                                  *
* Copyright (c) Microsoft Corporation. All rights reserved.                        *
*                                                                                  *
***********************************************************************************/


#pragma once
#line 12 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\processthreadsapi.h"










extern "C" {
#line 24 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\processthreadsapi.h"

#pragma region Application Family or OneCore Family


typedef struct _PROCESS_INFORMATION {
    HANDLE hProcess;
    HANDLE hThread;
    DWORD dwProcessId;
    DWORD dwThreadId;
} PROCESS_INFORMATION, *PPROCESS_INFORMATION, *LPPROCESS_INFORMATION;

typedef struct _STARTUPINFOA {
    DWORD   cb;
    LPSTR   lpReserved;
    LPSTR   lpDesktop;
    LPSTR   lpTitle;
    DWORD   dwX;
    DWORD   dwY;
    DWORD   dwXSize;
    DWORD   dwYSize;
    DWORD   dwXCountChars;
    DWORD   dwYCountChars;
    DWORD   dwFillAttribute;
    DWORD   dwFlags;
    WORD    wShowWindow;
    WORD    cbReserved2;
    LPBYTE  lpReserved2;
    HANDLE  hStdInput;
    HANDLE  hStdOutput;
    HANDLE  hStdError;
} STARTUPINFOA, *LPSTARTUPINFOA;
typedef struct _STARTUPINFOW {
    DWORD   cb;
    LPWSTR  lpReserved;
    LPWSTR  lpDesktop;
    LPWSTR  lpTitle;
    DWORD   dwX;
    DWORD   dwY;
    DWORD   dwXSize;
    DWORD   dwYSize;
    DWORD   dwXCountChars;
    DWORD   dwYCountChars;
    DWORD   dwFillAttribute;
    DWORD   dwFlags;
    WORD    wShowWindow;
    WORD    cbReserved2;
    LPBYTE  lpReserved2;
    HANDLE  hStdInput;
    HANDLE  hStdOutput;
    HANDLE  hStdError;
} STARTUPINFOW, *LPSTARTUPINFOW;




typedef STARTUPINFOA STARTUPINFO;
typedef LPSTARTUPINFOA LPSTARTUPINFO;
#line 82 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\processthreadsapi.h"

#line 84 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\processthreadsapi.h"
#pragma endregion

#pragma region Application Family or OneCore Family




__declspec(dllimport)
DWORD
__stdcall
QueueUserAPC(
     PAPCFUNC pfnAPC,
     HANDLE hThread,
     ULONG_PTR dwData
    );


#line 102 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\processthreadsapi.h"

__declspec(dllimport)
BOOL
__stdcall
GetProcessTimes(
     HANDLE hProcess,
     LPFILETIME lpCreationTime,
     LPFILETIME lpExitTime,
     LPFILETIME lpKernelTime,
     LPFILETIME lpUserTime
    );


__declspec(dllimport)
HANDLE
__stdcall
GetCurrentProcess(
    void
    );


__declspec(dllimport)
DWORD
__stdcall
GetCurrentProcessId(
    void
    );


__declspec(dllimport)
__declspec(noreturn)
void
__stdcall
ExitProcess(
     UINT uExitCode
    );


__declspec(dllimport)
BOOL
__stdcall
TerminateProcess(
     HANDLE hProcess,
     UINT uExitCode
    );


__declspec(dllimport)
BOOL
__stdcall
GetExitCodeProcess(
     HANDLE hProcess,
     LPDWORD lpExitCode
    );


__declspec(dllimport)
BOOL
__stdcall
SwitchToThread(
    void
    );


__declspec(dllimport)

HANDLE
__stdcall
CreateThread(
     LPSECURITY_ATTRIBUTES lpThreadAttributes,
     SIZE_T dwStackSize,
     LPTHREAD_START_ROUTINE lpStartAddress,
      LPVOID lpParameter,
     DWORD dwCreationFlags,
     LPDWORD lpThreadId
    );

#line 180 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\processthreadsapi.h"
#pragma endregion

#pragma region Desktop Family or OneCore Family

__declspec(dllimport)

HANDLE
__stdcall
CreateRemoteThread(
     HANDLE hProcess,
     LPSECURITY_ATTRIBUTES lpThreadAttributes,
     SIZE_T dwStackSize,
     LPTHREAD_START_ROUTINE lpStartAddress,
     LPVOID lpParameter,
     DWORD dwCreationFlags,
     LPDWORD lpThreadId
    );


#line 200 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\processthreadsapi.h"
#pragma endregion

#pragma region Application Family or OneCore Family


__declspec(dllimport)
HANDLE
__stdcall
GetCurrentThread(
    void
    );


__declspec(dllimport)
DWORD
__stdcall
GetCurrentThreadId(
    void
    );


__declspec(dllimport)

HANDLE
__stdcall
OpenThread(
     DWORD dwDesiredAccess,
     BOOL bInheritHandle,
     DWORD dwThreadId
    );


__declspec(dllimport)
BOOL
__stdcall
SetThreadPriority(
     HANDLE hThread,
     int nPriority
    );


__declspec(dllimport)
BOOL
__stdcall
SetThreadPriorityBoost(
     HANDLE hThread,
     BOOL bDisablePriorityBoost
    );


__declspec(dllimport)
BOOL
__stdcall
GetThreadPriorityBoost(
     HANDLE hThread,
     PBOOL pDisablePriorityBoost
    );


__declspec(dllimport)
int
__stdcall
GetThreadPriority(
     HANDLE hThread
    );


__declspec(dllimport)
__declspec(noreturn)
void
__stdcall
ExitThread(
     DWORD dwExitCode
    );

#line 276 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\processthreadsapi.h"
#pragma endregion

#pragma region Desktop Family or OneCore Family

__declspec(dllimport)
BOOL
__stdcall
TerminateThread(
     HANDLE hThread,
     DWORD dwExitCode
    );

#line 289 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\processthreadsapi.h"
#pragma endregion

#pragma region Application Family or OneCore Family


__declspec(dllimport)

BOOL
__stdcall
GetExitCodeThread(
     HANDLE hThread,
     LPDWORD lpExitCode
    );


__declspec(dllimport)
DWORD
__stdcall
SuspendThread(
     HANDLE hThread
    );


__declspec(dllimport)
DWORD
__stdcall
ResumeThread(
     HANDLE hThread
    );




#line 323 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\processthreadsapi.h"


__declspec(dllimport)
DWORD
__stdcall
TlsAlloc(
    void
    );


__declspec(dllimport)
LPVOID
__stdcall
TlsGetValue(
     DWORD dwTlsIndex
    );


__declspec(dllimport)
BOOL
__stdcall
TlsSetValue(
     DWORD dwTlsIndex,
     LPVOID lpTlsValue
    );


__declspec(dllimport)
BOOL
__stdcall
TlsFree(
     DWORD dwTlsIndex
    );


__declspec(dllimport)
BOOL
__stdcall
CreateProcessA(
     LPCSTR lpApplicationName,
     LPSTR lpCommandLine,
     LPSECURITY_ATTRIBUTES lpProcessAttributes,
     LPSECURITY_ATTRIBUTES lpThreadAttributes,
     BOOL bInheritHandles,
     DWORD dwCreationFlags,
     LPVOID lpEnvironment,
     LPCSTR lpCurrentDirectory,
     LPSTARTUPINFOA lpStartupInfo,
     LPPROCESS_INFORMATION lpProcessInformation
    );

__declspec(dllimport)
BOOL
__stdcall
CreateProcessW(
     LPCWSTR lpApplicationName,
     LPWSTR lpCommandLine,
     LPSECURITY_ATTRIBUTES lpProcessAttributes,
     LPSECURITY_ATTRIBUTES lpThreadAttributes,
     BOOL bInheritHandles,
     DWORD dwCreationFlags,
     LPVOID lpEnvironment,
     LPCWSTR lpCurrentDirectory,
     LPSTARTUPINFOW lpStartupInfo,
     LPPROCESS_INFORMATION lpProcessInformation
    );





#line 395 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\processthreadsapi.h"

#line 397 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\processthreadsapi.h"
#pragma endregion

#pragma region Desktop Family or OneCore Family


__declspec(dllimport)
BOOL
__stdcall
SetProcessShutdownParameters(
     DWORD dwLevel,
     DWORD dwFlags
    );


__declspec(dllimport)
DWORD
__stdcall
GetProcessVersion(
     DWORD ProcessId
    );


__declspec(dllimport)
void
__stdcall
GetStartupInfoW(
     LPSTARTUPINFOW lpStartupInfo
    );





__declspec(dllimport)
BOOL
__stdcall
CreateProcessAsUserW(
     HANDLE hToken,
     LPCWSTR lpApplicationName,
     LPWSTR lpCommandLine,
     LPSECURITY_ATTRIBUTES lpProcessAttributes,
     LPSECURITY_ATTRIBUTES lpThreadAttributes,
     BOOL bInheritHandles,
     DWORD dwCreationFlags,
     LPVOID lpEnvironment,
     LPCWSTR lpCurrentDirectory,
     LPSTARTUPINFOW lpStartupInfo,
     LPPROCESS_INFORMATION lpProcessInformation
    );






//
// TODO: neerajsi-2013/12/08 - this should be moved to official documentation.
//
// These are shorthand ways of referring to the thread token, the process token,
// or the "effective token" (the thread token if it exists, otherwise the
// process token), respectively. These handles only have TOKEN_QUERY and
// TOKEN_QUERY_SOURCE access in Windows 8 (use TOKEN_ACCESS_PSEUDO_HANDLE to
// determine the granted access on the target version of Windows). These handles
// do not need to be closed.
//































#line 494 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\processthreadsapi.h"
#line 495 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\processthreadsapi.h"

#line 497 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\processthreadsapi.h"
#pragma endregion

#pragma region Application Family or OneCore Family


__declspec(dllimport)

BOOL
__stdcall
SetThreadToken(
     PHANDLE Thread,
     HANDLE Token
    );


__declspec(dllimport)
BOOL
__stdcall
OpenProcessToken(
     HANDLE ProcessHandle,
     DWORD DesiredAccess,
     PHANDLE TokenHandle
    );


__declspec(dllimport)
BOOL
__stdcall
OpenThreadToken(
     HANDLE ThreadHandle,
     DWORD DesiredAccess,
     BOOL OpenAsSelf,
     PHANDLE TokenHandle
    );


__declspec(dllimport)
BOOL
__stdcall
SetPriorityClass(
     HANDLE hProcess,
     DWORD dwPriorityClass
    );


__declspec(dllimport)
DWORD
__stdcall
GetPriorityClass(
     HANDLE hProcess
    );


#line 551 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\processthreadsapi.h"
#pragma endregion

#pragma region Desktop Family or OneCore Family


__declspec(dllimport)
BOOL
__stdcall
SetThreadStackGuarantee(
     PULONG StackSizeInBytes
    );


__declspec(dllimport)
BOOL
__stdcall
ProcessIdToSessionId(
     DWORD dwProcessId,
     DWORD* pSessionId
    );


typedef struct _PROC_THREAD_ATTRIBUTE_LIST *PPROC_THREAD_ATTRIBUTE_LIST, *LPPROC_THREAD_ATTRIBUTE_LIST;

#line 576 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\processthreadsapi.h"
#pragma endregion

#pragma region Application Family or OneCore Family




__declspec(dllimport)
DWORD
__stdcall
GetProcessId(
     HANDLE Process
    );


#line 592 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\processthreadsapi.h"



__declspec(dllimport)
DWORD
__stdcall
GetThreadId(
     HANDLE Thread
    );


#line 604 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\processthreadsapi.h"



__declspec(dllimport)
void
__stdcall
FlushProcessWriteBuffers(
    void
    );


#line 616 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\processthreadsapi.h"

#line 618 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\processthreadsapi.h"
#pragma endregion



#pragma region Desktop Family or OneCore Family


__declspec(dllimport)
DWORD
__stdcall
GetProcessIdOfThread(
     HANDLE Thread
    );


__declspec(dllimport)

BOOL
__stdcall
InitializeProcThreadAttributeList(
     LPPROC_THREAD_ATTRIBUTE_LIST lpAttributeList,
     DWORD dwAttributeCount,
     DWORD dwFlags,
      PSIZE_T lpSize
    );


__declspec(dllimport)
void
__stdcall
DeleteProcThreadAttributeList(
     LPPROC_THREAD_ATTRIBUTE_LIST lpAttributeList
    );




__declspec(dllimport)
BOOL
__stdcall
SetProcessAffinityUpdateMode(
     HANDLE hProcess,
     DWORD dwFlags
    );


__declspec(dllimport)
BOOL
__stdcall
QueryProcessAffinityUpdateMode(
     HANDLE hProcess,
     LPDWORD lpdwFlags
    );




__declspec(dllimport)
BOOL
__stdcall
UpdateProcThreadAttribute(
     LPPROC_THREAD_ATTRIBUTE_LIST lpAttributeList,
     DWORD dwFlags,
     DWORD_PTR Attribute,
     PVOID lpValue,
     SIZE_T cbSize,
     PVOID lpPreviousValue,
     PSIZE_T lpReturnSize
    );


#line 690 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\processthreadsapi.h"
#pragma endregion

#line 693 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\processthreadsapi.h"

#pragma region Desktop Family or OneCore Family


__declspec(dllimport)

HANDLE
__stdcall
CreateRemoteThreadEx(
     HANDLE hProcess,
     LPSECURITY_ATTRIBUTES lpThreadAttributes,
     SIZE_T dwStackSize,
     LPTHREAD_START_ROUTINE lpStartAddress,
     LPVOID lpParameter,
     DWORD dwCreationFlags,
     LPPROC_THREAD_ATTRIBUTE_LIST lpAttributeList,
     LPDWORD lpThreadId
    );


#line 714 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\processthreadsapi.h"
#pragma endregion



#pragma region Application Family or OneCore Family













#line 733 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\processthreadsapi.h"

__declspec(dllimport)
BOOL
__stdcall
GetThreadContext(
     HANDLE hThread,
     LPCONTEXT lpContext
    );















#line 757 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\processthreadsapi.h"

#line 759 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\processthreadsapi.h"
#pragma endregion

#pragma region Desktop Family or OneCore Family


__declspec(dllimport)
BOOL
__stdcall
SetThreadContext(
     HANDLE hThread,
     const CONTEXT* lpContext
    );














#line 786 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\processthreadsapi.h"

#line 788 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\processthreadsapi.h"
#pragma endregion

#line 791 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\processthreadsapi.h"

#pragma region Application Family or OneCore Family


__declspec(dllimport)
BOOL
__stdcall
FlushInstructionCache(
     HANDLE hProcess,
     LPCVOID lpBaseAddress,
     SIZE_T dwSize
    );


__declspec(dllimport)
BOOL
__stdcall
GetThreadTimes(
     HANDLE hThread,
     LPFILETIME lpCreationTime,
     LPFILETIME lpExitTime,
     LPFILETIME lpKernelTime,
     LPFILETIME lpUserTime
    );


__declspec(dllimport)
HANDLE
__stdcall
OpenProcess(
     DWORD dwDesiredAccess,
     BOOL bInheritHandle,
     DWORD dwProcessId
    );


__declspec(dllimport)
BOOL
__stdcall
IsProcessorFeaturePresent(
     DWORD ProcessorFeature
    );


#line 836 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\processthreadsapi.h"
#pragma endregion



#pragma region Desktop Family or OneCore Family


__declspec(dllimport)
BOOL
__stdcall
GetProcessHandleCount(
     HANDLE hProcess,
     PDWORD pdwHandleCount
    );


#line 853 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\processthreadsapi.h"
#pragma endregion

#line 856 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\processthreadsapi.h"



#pragma region Application Family or OneCore Family


__declspec(dllimport)
DWORD
__stdcall
GetCurrentProcessorNumber(
    void
    );


#line 871 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\processthreadsapi.h"
#pragma endregion

#line 874 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\processthreadsapi.h"



#pragma region Application Family or OneCore Family


__declspec(dllimport)
BOOL
__stdcall
SetThreadIdealProcessorEx(
     HANDLE hThread,
     PPROCESSOR_NUMBER lpIdealProcessor,
     PPROCESSOR_NUMBER lpPreviousIdealProcessor
    );


__declspec(dllimport)
BOOL
__stdcall
GetThreadIdealProcessorEx(
     HANDLE hThread,
     PPROCESSOR_NUMBER lpIdealProcessor
    );


__declspec(dllimport)
void
__stdcall
GetCurrentProcessorNumberEx(
     PPROCESSOR_NUMBER ProcNumber
    );


#line 908 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\processthreadsapi.h"
#pragma endregion

#line 911 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\processthreadsapi.h"

#pragma region Application Family or OneCore Family




__declspec(dllimport)
BOOL
__stdcall
GetProcessPriorityBoost(
     HANDLE hProcess,
     PBOOL pDisablePriorityBoost
    );


__declspec(dllimport)
BOOL
__stdcall
SetProcessPriorityBoost(
     HANDLE hProcess,
     BOOL bDisablePriorityBoost
    );


#line 936 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\processthreadsapi.h"

#line 938 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\processthreadsapi.h"
#pragma endregion

#pragma region Desktop Family or OneCore Family




__declspec(dllimport)
BOOL
__stdcall
GetThreadIOPendingFlag(
     HANDLE hThread,
     PBOOL lpIOIsPending
    );


#line 955 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\processthreadsapi.h"
#line 956 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\processthreadsapi.h"
#pragma endregion

#pragma region Application Family or OneCore Family




__declspec(dllimport)
BOOL
__stdcall
GetSystemTimes(
     PFILETIME lpIdleTime,
     PFILETIME lpKernelTime,
     PFILETIME lpUserTime
    );


#line 974 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\processthreadsapi.h"
#line 975 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\processthreadsapi.h"
#pragma endregion

#pragma region Application Family or OneCore Family


//
// Thread information classes.
//

typedef enum _THREAD_INFORMATION_CLASS {
    ThreadMemoryPriority,
    ThreadAbsoluteCpuPriority,
    ThreadDynamicCodePolicy,
    ThreadPowerThrottling,
    ThreadInformationClassMax
} THREAD_INFORMATION_CLASS;





























#line 1021 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\processthreadsapi.h"









typedef struct _THREAD_POWER_THROTTLING_STATE {
    ULONG Version;
    ULONG ControlMask;
    ULONG StateMask;
} THREAD_POWER_THROTTLING_STATE;

#line 1037 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\processthreadsapi.h"

#line 1039 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\processthreadsapi.h"
#pragma endregion

#pragma region Desktop Family or OneCore Family













#line 1056 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\processthreadsapi.h"






















#line 1079 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\processthreadsapi.h"

#line 1081 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\processthreadsapi.h"
#pragma endregion

#pragma region Desktop Family or OneCore Family


__declspec(dllimport)
DWORD
__stdcall
SetThreadIdealProcessor(
     HANDLE hThread,
     DWORD dwIdealProcessor
    );


#line 1096 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\processthreadsapi.h"
#pragma endregion

#pragma region Application Family or OneCore Family


typedef enum _PROCESS_INFORMATION_CLASS {
    ProcessMemoryPriority,
    ProcessMemoryExhaustionInfo,
    ProcessAppMemoryInfo,
    ProcessInPrivateInfo,
    ProcessPowerThrottling,
    ProcessReservedValue1,           // Used to be for ProcessActivityThrottlePolicyInfo
    ProcessTelemetryCoverageInfo,
    ProcessProtectionLevelInfo,
    ProcessLeapSecondInfo,
    ProcessInformationClassMax
} PROCESS_INFORMATION_CLASS;

typedef struct _APP_MEMORY_INFORMATION {
    ULONG64 AvailableCommit;
    ULONG64 PrivateCommitUsage;
    ULONG64 PeakPrivateCommitUsage;
    ULONG64 TotalCommitUsage;
} APP_MEMORY_INFORMATION, *PAPP_MEMORY_INFORMATION;

//
// Constants and structures needed to enable the fail fast on commit failure
// feature.
//



typedef enum _PROCESS_MEMORY_EXHAUSTION_TYPE {
    PMETypeFailFastOnCommitFailure,
    PMETypeMax
} PROCESS_MEMORY_EXHAUSTION_TYPE, *PPROCESS_MEMORY_EXHAUSTION_TYPE;




typedef struct _PROCESS_MEMORY_EXHAUSTION_INFO {
    USHORT Version;
    USHORT Reserved;
    PROCESS_MEMORY_EXHAUSTION_TYPE Type;
    ULONG_PTR Value;
} PROCESS_MEMORY_EXHAUSTION_INFO, *PPROCESS_MEMORY_EXHAUSTION_INFO;







typedef struct _PROCESS_POWER_THROTTLING_STATE {
    ULONG Version;
    ULONG ControlMask;
    ULONG StateMask;
} PROCESS_POWER_THROTTLING_STATE, *PPROCESS_POWER_THROTTLING_STATE;

typedef struct PROCESS_PROTECTION_LEVEL_INFORMATION {
    DWORD ProtectionLevel;
} PROCESS_PROTECTION_LEVEL_INFORMATION;





typedef struct _PROCESS_LEAP_SECOND_INFO {
    ULONG Flags;
    ULONG Reserved;
} PROCESS_LEAP_SECOND_INFO, *PPROCESS_LEAP_SECOND_INFO;

























#line 1193 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\processthreadsapi.h"

























































#line 1251 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\processthreadsapi.h"

#line 1253 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\processthreadsapi.h"
#pragma endregion

#pragma region Desktop Family or OneCore Family


__declspec(dllimport)
BOOL
__stdcall
CreateProcessAsUserA(
     HANDLE hToken,
     LPCSTR lpApplicationName,
     LPSTR lpCommandLine,
     LPSECURITY_ATTRIBUTES lpProcessAttributes,
     LPSECURITY_ATTRIBUTES lpThreadAttributes,
     BOOL bInheritHandles,
     DWORD dwCreationFlags,
     LPVOID lpEnvironment,
     LPCSTR lpCurrentDirectory,
     LPSTARTUPINFOA lpStartupInfo,
     LPPROCESS_INFORMATION lpProcessInformation
    );




#line 1279 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\processthreadsapi.h"

__declspec(dllimport)
BOOL
__stdcall
GetProcessShutdownParameters(
     LPDWORD lpdwLevel,
     LPDWORD lpdwFlags
    );


#line 1290 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\processthreadsapi.h"
#pragma endregion

__declspec(dllimport)
HRESULT
__stdcall
SetThreadDescription(
     HANDLE hThread,
     PCWSTR lpThreadDescription
    );

 
__declspec(dllimport)
HRESULT
__stdcall
GetThreadDescription(
     HANDLE hThread,
     PWSTR* ppszThreadDescription
    );



}
#line 1313 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\processthreadsapi.h"

#line 1315 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\processthreadsapi.h"
#line 56 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winbase.h"
#line 1 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\sysinfoapi.h"
/********************************************************************************
*                                                                               *
* sysinfoapi.h -- ApiSet Contract for api-ms-win-core-sysinfo-l1                *
*                                                                               *
* Copyright (c) Microsoft Corporation. All rights reserved.                     *
*                                                                               *
********************************************************************************/


#pragma once
#line 12 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\sysinfoapi.h"










#pragma warning(disable:4514)

#pragma warning(disable:4103)
#line 26 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\sysinfoapi.h"

#pragma warning(push)
#line 29 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\sysinfoapi.h"
#pragma warning(disable:4001)
#pragma warning(disable:4201)
#pragma warning(disable:4214)
#line 33 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\sysinfoapi.h"



#line 37 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\sysinfoapi.h"

#line 39 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\sysinfoapi.h"


extern "C" {
#line 43 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\sysinfoapi.h"

#pragma region Application Family or OneCore Family


typedef struct _SYSTEM_INFO {
    union {
        DWORD dwOemId;          // Obsolete field...do not use
        struct {
            WORD wProcessorArchitecture;
            WORD wReserved;
        }  ;
    }  ;
    DWORD dwPageSize;
    LPVOID lpMinimumApplicationAddress;
    LPVOID lpMaximumApplicationAddress;
    DWORD_PTR dwActiveProcessorMask;
    DWORD dwNumberOfProcessors;
    DWORD dwProcessorType;
    DWORD dwAllocationGranularity;
    WORD wProcessorLevel;
    WORD wProcessorRevision;
} SYSTEM_INFO, *LPSYSTEM_INFO;

#line 67 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\sysinfoapi.h"
#pragma endregion

#pragma region Application Family or OneCore Family


typedef struct _MEMORYSTATUSEX {
    DWORD dwLength;
    DWORD dwMemoryLoad;
    DWORDLONG ullTotalPhys;
    DWORDLONG ullAvailPhys;
    DWORDLONG ullTotalPageFile;
    DWORDLONG ullAvailPageFile;
    DWORDLONG ullTotalVirtual;
    DWORDLONG ullAvailVirtual;
    DWORDLONG ullAvailExtendedVirtual;
} MEMORYSTATUSEX, *LPMEMORYSTATUSEX;

__declspec(dllimport)
BOOL
__stdcall
GlobalMemoryStatusEx(
     LPMEMORYSTATUSEX lpBuffer
    );


__declspec(dllimport)
void
__stdcall
GetSystemInfo(
     LPSYSTEM_INFO lpSystemInfo
    );


__declspec(dllimport)
void
__stdcall
GetSystemTime(
     LPSYSTEMTIME lpSystemTime
    );


__declspec(dllimport)
void
__stdcall
GetSystemTimeAsFileTime(
     LPFILETIME lpSystemTimeAsFileTime
    );


__declspec(dllimport)
void
__stdcall
GetLocalTime(
     LPSYSTEMTIME lpSystemTime
    );


__declspec(dllimport)
BOOL
__stdcall
GetSystemLeapSecondInformation(
     PBOOL Enabled,
     PDWORD Flags
    );


#line 134 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\sysinfoapi.h"
#pragma endregion

#pragma region Desktop Family or OneCore Family


__declspec(deprecated)
__declspec(dllimport)

DWORD
__stdcall
GetVersion(
    void
    );


__declspec(dllimport)
BOOL
__stdcall
SetLocalTime(
     const SYSTEMTIME* lpSystemTime
    );


#line 158 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\sysinfoapi.h"
#pragma endregion


#pragma region Application Family or OneCore Family



__declspec(dllimport)
DWORD
__stdcall
GetTickCount(
    void
    );




__declspec(dllimport)
ULONGLONG
__stdcall
GetTickCount64(
    void
    );


#line 184 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\sysinfoapi.h"

#line 186 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\sysinfoapi.h"
#pragma endregion

#pragma region Desktop Family or OneCore Family


__declspec(dllimport)

BOOL
__stdcall
GetSystemTimeAdjustment(
     PDWORD lpTimeAdjustment,
     PDWORD lpTimeIncrement,
     PBOOL lpTimeAdjustmentDisabled
    );


__declspec(dllimport)

BOOL
__stdcall
GetSystemTimeAdjustmentPrecise(
     PDWORD64 lpTimeAdjustment,
     PDWORD64 lpTimeIncrement,
     PBOOL lpTimeAdjustmentDisabled
    );


#line 214 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\sysinfoapi.h"
#pragma endregion

#pragma region Application Family or OneCore Family


__declspec(dllimport)

UINT
__stdcall
GetSystemDirectoryA(
     LPSTR lpBuffer,
     UINT uSize
    );

__declspec(dllimport)

UINT
__stdcall
GetSystemDirectoryW(
     LPWSTR lpBuffer,
     UINT uSize
    );





#line 242 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\sysinfoapi.h"

#line 244 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\sysinfoapi.h"
#pragma endregion

#pragma region Desktop Family or OneCore Family


__declspec(dllimport)


UINT
__stdcall
GetWindowsDirectoryA(
     LPSTR lpBuffer,
     UINT uSize
    );

__declspec(dllimport)


UINT
__stdcall
GetWindowsDirectoryW(
     LPWSTR lpBuffer,
     UINT uSize
    );





#line 274 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\sysinfoapi.h"

__declspec(dllimport)

UINT
__stdcall
GetSystemWindowsDirectoryA(
     LPSTR lpBuffer,
     UINT uSize
    );

__declspec(dllimport)

UINT
__stdcall
GetSystemWindowsDirectoryW(
     LPWSTR lpBuffer,
     UINT uSize
    );





#line 298 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\sysinfoapi.h"

#line 300 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\sysinfoapi.h"
#pragma endregion

#pragma region Desktop Family or OneCore Family


typedef enum _COMPUTER_NAME_FORMAT {
    ComputerNameNetBIOS,
    ComputerNameDnsHostname,
    ComputerNameDnsDomain,
    ComputerNameDnsFullyQualified,
    ComputerNamePhysicalNetBIOS,
    ComputerNamePhysicalDnsHostname,
    ComputerNamePhysicalDnsDomain,
    ComputerNamePhysicalDnsFullyQualified,
    ComputerNameMax
} COMPUTER_NAME_FORMAT ;

#line 318 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\sysinfoapi.h"
#pragma endregion

#pragma region Desktop Family or OneCore Family


__declspec(dllimport)

BOOL
__stdcall
GetComputerNameExA(
     COMPUTER_NAME_FORMAT NameType,
     LPSTR lpBuffer,
     LPDWORD nSize
    );

__declspec(dllimport)

BOOL
__stdcall
GetComputerNameExW(
     COMPUTER_NAME_FORMAT NameType,
     LPWSTR lpBuffer,
     LPDWORD nSize
    );





#line 348 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\sysinfoapi.h"

#line 350 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\sysinfoapi.h"
#pragma endregion

#pragma region Desktop Family or OneCore Family


__declspec(dllimport)
BOOL
__stdcall
SetComputerNameExW(
     COMPUTER_NAME_FORMAT NameType,
     LPCWSTR lpBuffer
    );






__declspec(dllimport)
BOOL
__stdcall
SetSystemTime(
     const SYSTEMTIME* lpSystemTime
    );


#line 377 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\sysinfoapi.h"
#pragma endregion

#pragma region Application Family or OneCore Family


__declspec(deprecated)
__declspec(dllimport)

BOOL
__stdcall
GetVersionExA(
     LPOSVERSIONINFOA lpVersionInformation
    );

__declspec(deprecated)
__declspec(dllimport)

BOOL
__stdcall
GetVersionExW(
     LPOSVERSIONINFOW lpVersionInformation
    );





#line 405 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\sysinfoapi.h"

__declspec(dllimport)
BOOL
__stdcall
GetLogicalProcessorInformation(
     PSYSTEM_LOGICAL_PROCESSOR_INFORMATION Buffer,
     PDWORD ReturnedLength
    );




__declspec(dllimport)
BOOL
__stdcall
GetLogicalProcessorInformationEx(
     LOGICAL_PROCESSOR_RELATIONSHIP RelationshipType,
     PSYSTEM_LOGICAL_PROCESSOR_INFORMATION_EX Buffer,
     PDWORD ReturnedLength
    );


#line 428 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\sysinfoapi.h"

#line 430 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\sysinfoapi.h"
#pragma endregion

#pragma region Application Family or OneCore Family




__declspec(dllimport)
void
__stdcall
GetNativeSystemInfo(
     LPSYSTEM_INFO lpSystemInfo
    );


#line 446 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\sysinfoapi.h"











#line 458 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\sysinfoapi.h"



__declspec(dllimport)
BOOL
__stdcall
GetProductInfo(
     DWORD dwOSMajorVersion,
     DWORD dwOSMinorVersion,
     DWORD dwSpMajorVersion,
     DWORD dwSpMinorVersion,
     PDWORD pdwReturnedProductType
    );


#line 474 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\sysinfoapi.h"

#line 476 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\sysinfoapi.h"
#pragma endregion

#pragma region Desktop Family or OneCore Family




__declspec(dllimport)
ULONGLONG
__stdcall
VerSetConditionMask(
     ULONGLONG ConditionMask,
     ULONG TypeMask,
     UCHAR Condition
    );


#line 494 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\sysinfoapi.h"











#line 506 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\sysinfoapi.h"

#line 508 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\sysinfoapi.h"
#pragma endregion

#pragma region OneCore Family or App Family


__declspec(dllimport)
UINT
__stdcall
EnumSystemFirmwareTables(
     DWORD FirmwareTableProviderSignature,
     PVOID pFirmwareTableEnumBuffer,
     DWORD BufferSize
    );


__declspec(dllimport)
UINT
__stdcall
GetSystemFirmwareTable(
     DWORD FirmwareTableProviderSignature,
     DWORD FirmwareTableID,
     PVOID pFirmwareTableBuffer,
     DWORD BufferSize
    );


#line 535 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\sysinfoapi.h"
#pragma endregion

#pragma region Desktop Family or OneCore Family


__declspec(dllimport)

BOOL
__stdcall
DnsHostnameToComputerNameExW(
     LPCWSTR Hostname,
     LPWSTR ComputerName,
     LPDWORD nSize
    );


__declspec(dllimport)

BOOL
__stdcall
GetPhysicallyInstalledSystemMemory(
     PULONGLONG TotalMemoryInKilobytes
    );




__declspec(dllimport)
BOOL
__stdcall
SetComputerNameEx2W(
     COMPUTER_NAME_FORMAT NameType,
     DWORD Flags,
     LPCWSTR lpBuffer
    );






__declspec(dllimport)

BOOL
__stdcall
SetSystemTimeAdjustment(
     DWORD dwTimeAdjustment,
     BOOL bTimeAdjustmentDisabled
    );


__declspec(dllimport)

BOOL
__stdcall
SetSystemTimeAdjustmentPrecise(
     DWORD64 dwTimeAdjustment,
     BOOL bTimeAdjustmentDisabled
    );


__declspec(dllimport)
BOOL
__stdcall
InstallELAMCertificateInfo(
     HANDLE ELAMFile
    );


#line 605 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\sysinfoapi.h"
#pragma endregion



__declspec(dllimport)
BOOL
__stdcall
GetProcessorSystemCycleTime(
     USHORT Group,
     PSYSTEM_PROCESSOR_CYCLE_TIME_INFORMATION Buffer,
     PDWORD ReturnedLength
    );


#line 620 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\sysinfoapi.h"

#pragma region Desktop Family or OneCore Family











#line 634 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\sysinfoapi.h"

#line 636 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\sysinfoapi.h"
#pragma endregion

#pragma region App Family or OneCore Family












#line 652 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\sysinfoapi.h"

#line 654 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\sysinfoapi.h"
#pragma endregion

#pragma region Desktop Family or OneCore Family


__declspec(dllimport)
BOOL
__stdcall
SetComputerNameA(
     LPCSTR lpComputerName
    );

__declspec(dllimport)
BOOL
__stdcall
SetComputerNameW(
     LPCWSTR lpComputerName
    );





#line 678 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\sysinfoapi.h"

__declspec(dllimport)
BOOL
__stdcall
SetComputerNameExA(
     COMPUTER_NAME_FORMAT NameType,
     LPCSTR lpBuffer
    );




#line 691 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\sysinfoapi.h"

#line 693 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\sysinfoapi.h"
#pragma endregion


}
#line 698 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\sysinfoapi.h"



#pragma warning(pop)





#line 708 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\sysinfoapi.h"
#line 709 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\sysinfoapi.h"

#line 711 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\sysinfoapi.h"

#line 57 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winbase.h"
#line 1 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\memoryapi.h"
/********************************************************************************
*                                                                               *
* memoryapi.h -- ApiSet Contract for api-ms-win-core-memory-l1-1-0              *
*                                                                               *
* Copyright (c) Microsoft Corporation. All rights reserved.                     *
*                                                                               *
********************************************************************************/


#pragma once
#line 12 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\memoryapi.h"










extern "C" {
#line 24 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\memoryapi.h"


#pragma warning(push)
#pragma warning(disable:4668) 
#line 29 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\memoryapi.h"

#pragma region Application Family or OneCore Family














#line 46 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\memoryapi.h"
#pragma endregion

#pragma region Desktop Family or OneCore Family


__declspec(dllimport)


LPVOID
__stdcall
VirtualAlloc(
     LPVOID lpAddress,
     SIZE_T dwSize,
     DWORD flAllocationType,
     DWORD flProtect
    );


__declspec(dllimport)

BOOL
__stdcall
VirtualProtect(
     LPVOID lpAddress,
     SIZE_T dwSize,
     DWORD flNewProtect,
     PDWORD lpflOldProtect
    );


#line 77 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\memoryapi.h"
#pragma endregion

#pragma region Application Family or OneCore Family











__declspec(dllimport)
BOOL
__stdcall
VirtualFree(
       LPVOID lpAddress,
     SIZE_T dwSize,
     DWORD dwFreeType
    );


__declspec(dllimport)
SIZE_T
__stdcall
VirtualQuery(
     LPCVOID lpAddress,
     PMEMORY_BASIC_INFORMATION lpBuffer,
     SIZE_T dwLength
    );


#line 112 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\memoryapi.h"
#pragma endregion

#pragma region Desktop Family or OneCore Family


__declspec(dllimport)


LPVOID
__stdcall
VirtualAllocEx(
     HANDLE hProcess,
     LPVOID lpAddress,
     SIZE_T dwSize,
     DWORD flAllocationType,
     DWORD flProtect
    );


__declspec(dllimport)

BOOL
__stdcall
VirtualProtectEx(
     HANDLE hProcess,
     LPVOID lpAddress,
     SIZE_T dwSize,
     DWORD flNewProtect,
     PDWORD lpflOldProtect
    );


__declspec(dllimport)
SIZE_T
__stdcall
VirtualQueryEx(
     HANDLE hProcess,
     LPCVOID lpAddress,
     PMEMORY_BASIC_INFORMATION lpBuffer,
     SIZE_T dwLength
    );


__declspec(dllimport)

BOOL
__stdcall
ReadProcessMemory(
     HANDLE hProcess,
     LPCVOID lpBaseAddress,
     LPVOID lpBuffer,
     SIZE_T nSize,
     SIZE_T* lpNumberOfBytesRead
    );


__declspec(dllimport)

BOOL
__stdcall
WriteProcessMemory(
     HANDLE hProcess,
     LPVOID lpBaseAddress,
     LPCVOID lpBuffer,
     SIZE_T nSize,
     SIZE_T* lpNumberOfBytesWritten
    );


__declspec(dllimport)

HANDLE
__stdcall
CreateFileMappingW(
     HANDLE hFile,
     LPSECURITY_ATTRIBUTES lpFileMappingAttributes,
     DWORD flProtect,
     DWORD dwMaximumSizeHigh,
     DWORD dwMaximumSizeLow,
     LPCWSTR lpName
    );






__declspec(dllimport)

HANDLE
__stdcall
OpenFileMappingW(
     DWORD dwDesiredAccess,
     BOOL bInheritHandle,
     LPCWSTR lpName
    );






__declspec(dllimport)
  
LPVOID
__stdcall
MapViewOfFile(
     HANDLE hFileMappingObject,
     DWORD dwDesiredAccess,
     DWORD dwFileOffsetHigh,
     DWORD dwFileOffsetLow,
     SIZE_T dwNumberOfBytesToMap
    );


__declspec(dllimport)
  
LPVOID
__stdcall
MapViewOfFileEx(
     HANDLE hFileMappingObject,
     DWORD dwDesiredAccess,
     DWORD dwFileOffsetHigh,
     DWORD dwFileOffsetLow,
     SIZE_T dwNumberOfBytesToMap,
     LPVOID lpBaseAddress
    );


#line 242 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\memoryapi.h"
#pragma endregion

#pragma region Application Family or OneCore Family














__declspec(dllimport)
BOOL
__stdcall
VirtualFreeEx(
     HANDLE hProcess,
       LPVOID lpAddress,
     SIZE_T dwSize,
     DWORD dwFreeType
    );


__declspec(dllimport)
BOOL
__stdcall
FlushViewOfFile(
     LPCVOID lpBaseAddress,
     SIZE_T dwNumberOfBytesToFlush
    );


__declspec(dllimport)
BOOL
__stdcall
UnmapViewOfFile(
     LPCVOID lpBaseAddress
    );


#line 288 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\memoryapi.h"
#pragma endregion

#pragma region Application Family or OneCore Family


__declspec(dllimport)
SIZE_T
__stdcall
GetLargePageMinimum(
    void
    );


__declspec(dllimport)

BOOL
__stdcall
GetProcessWorkingSetSizeEx(
     HANDLE hProcess,
     PSIZE_T lpMinimumWorkingSetSize,
     PSIZE_T lpMaximumWorkingSetSize,
     PDWORD Flags
    );


__declspec(dllimport)
BOOL
__stdcall
SetProcessWorkingSetSizeEx(
     HANDLE hProcess,
     SIZE_T dwMinimumWorkingSetSize,
     SIZE_T dwMaximumWorkingSetSize,
     DWORD Flags
    );


#line 325 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\memoryapi.h"
#pragma endregion

#pragma region Desktop Family or OneCore Family


__declspec(dllimport)
BOOL
__stdcall
VirtualLock(
     LPVOID lpAddress,
     SIZE_T dwSize
    );


__declspec(dllimport)
BOOL
__stdcall
VirtualUnlock(
     LPVOID lpAddress,
     SIZE_T dwSize
    );


#line 349 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\memoryapi.h"
#pragma endregion

#pragma region Application Family or OneCore Family


__declspec(dllimport)

UINT
__stdcall
GetWriteWatch(
     DWORD dwFlags,
     PVOID lpBaseAddress,
     SIZE_T dwRegionSize,
     PVOID* lpAddresses,
     ULONG_PTR* lpdwCount,
     LPDWORD lpdwGranularity
    );


__declspec(dllimport)
UINT
__stdcall
ResetWriteWatch(
     LPVOID lpBaseAddress,
     SIZE_T dwRegionSize
    );


#line 378 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\memoryapi.h"
#pragma endregion

#pragma region Desktop Family or OneCore Family




typedef enum _MEMORY_RESOURCE_NOTIFICATION_TYPE {
    LowMemoryResourceNotification,
    HighMemoryResourceNotification
} MEMORY_RESOURCE_NOTIFICATION_TYPE;

__declspec(dllimport)

HANDLE
__stdcall
CreateMemoryResourceNotification(
     MEMORY_RESOURCE_NOTIFICATION_TYPE NotificationType
    );


__declspec(dllimport)

BOOL
__stdcall
QueryMemoryResourceNotification(
     HANDLE ResourceNotificationHandle,
     PBOOL ResourceState
    );


#line 410 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\memoryapi.h"









__declspec(dllimport)

BOOL
__stdcall
GetSystemFileCacheSize(
     PSIZE_T lpMinimumFileCacheSize,
     PSIZE_T lpMaximumFileCacheSize,
     PDWORD lpFlags
    );


__declspec(dllimport)
BOOL
__stdcall
SetSystemFileCacheSize(
     SIZE_T MinimumFileCacheSize,
     SIZE_T MaximumFileCacheSize,
     DWORD Flags
    );


#line 441 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\memoryapi.h"



__declspec(dllimport)

HANDLE
__stdcall
CreateFileMappingNumaW(
     HANDLE hFile,
     LPSECURITY_ATTRIBUTES lpFileMappingAttributes,
     DWORD flProtect,
     DWORD dwMaximumSizeHigh,
     DWORD dwMaximumSizeLow,
     LPCWSTR lpName,
     DWORD nndPreferred
    );






#line 464 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\memoryapi.h"



















#line 484 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\memoryapi.h"

#line 486 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\memoryapi.h"
#pragma endregion

#pragma region Application Family or OneCore Family






































#line 528 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\memoryapi.h"

#line 530 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\memoryapi.h"
#pragma endregion

#pragma region Desktop Family or OneCore Family




__declspec(dllimport)

BOOL
__stdcall
AllocateUserPhysicalPages(
     HANDLE hProcess,
     PULONG_PTR NumberOfPages,
     PULONG_PTR PageArray
    );


__declspec(dllimport)

BOOL
__stdcall
FreeUserPhysicalPages(
     HANDLE hProcess,
     PULONG_PTR NumberOfPages,
     PULONG_PTR PageArray
    );


__declspec(dllimport)

BOOL
__stdcall
MapUserPhysicalPages(
     PVOID VirtualAddress,
     ULONG_PTR NumberOfPages,
     PULONG_PTR PageArray
    );


#line 571 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\memoryapi.h"



__declspec(dllimport)

BOOL
__stdcall
AllocateUserPhysicalPagesNuma(
     HANDLE hProcess,
     PULONG_PTR NumberOfPages,
     PULONG_PTR PageArray,
     DWORD nndPreferred
    );


__declspec(dllimport)

LPVOID
__stdcall
VirtualAllocExNuma(
     HANDLE hProcess,
     LPVOID lpAddress,
     SIZE_T dwSize,
     DWORD flAllocationType,
     DWORD flProtect,
     DWORD nndPreferred
    );


#line 601 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\memoryapi.h"










































#line 644 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\memoryapi.h"

#line 646 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\memoryapi.h"
#pragma endregion

#pragma region Application Family or OneCore Family


// This API is not actually available in all blue builds since it is part
// of the S14 GDR release, however because there is no new version for GDR
// this is the most accurate version available.  To safely use this API on
// BLUE builds callers will need to use LoadLibrary and GetProcAddress to 
// check for the existance of the API's before calling them.







































#line 696 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\memoryapi.h"

#line 698 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\memoryapi.h"
#pragma endregion

#pragma region Application Family or OneCore Family


































































#line 768 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\memoryapi.h"

#line 770 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\memoryapi.h"
#pragma endregion

#pragma region Application Family





























































































#line 867 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\memoryapi.h"
#pragma endregion

#pragma region Desktop Family or OneCore Family






















































#line 925 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\memoryapi.h"

#line 927 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\memoryapi.h"
#pragma endregion

#pragma region Desktop Family or OneCore Family















































#line 978 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\memoryapi.h"

#line 980 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\memoryapi.h"
#pragma endregion

#pragma region Application Family or OneCore Family


__declspec(dllimport)
BOOL
__stdcall
UnmapViewOfFile2(
     HANDLE Process,
     PVOID BaseAddress,
     ULONG UnmapFlags
    );


__declspec(dllimport)
BOOL
__stdcall
VirtualUnlockEx(
     HANDLE Process,
     LPVOID Address,
     SIZE_T Size
    );


#line 1006 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\memoryapi.h"
#pragma endregion

















































































#line 1089 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\memoryapi.h"


























#line 1116 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\memoryapi.h"


#pragma warning(pop)
#line 1120 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\memoryapi.h"


}
#line 1124 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\memoryapi.h"

#line 1126 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\memoryapi.h"
#line 58 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winbase.h"
#line 1 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\enclaveapi.h"
/********************************************************************************
*                                                                               *
* enclaveapi.h -- ApiSet Contract for api-ms-win-core-enclave-l1-1-0            *
*                                                                               *
* Copyright (c) Microsoft Corporation. All rights reserved.                     *
*                                                                               *
********************************************************************************/


#pragma once
#line 12 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\enclaveapi.h"










extern "C" {
#line 24 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\enclaveapi.h"

#pragma region Desktop Family or OneCore Or App Family


__declspec(dllimport)

BOOL
__stdcall
IsEnclaveTypeSupported(
     DWORD flEnclaveType
    );


__declspec(dllimport)


LPVOID
__stdcall
CreateEnclave(
     HANDLE hProcess,
     LPVOID lpAddress,
     SIZE_T dwSize,
     SIZE_T dwInitialCommitment,
     DWORD flEnclaveType,
     LPCVOID lpEnclaveInformation,
     DWORD dwInfoLength,
     LPDWORD lpEnclaveError
    );


__declspec(dllimport)

BOOL
__stdcall
LoadEnclaveData(
     HANDLE hProcess,
     LPVOID lpAddress,
     LPCVOID lpBuffer,
     SIZE_T nSize,
     DWORD flProtect,
     LPCVOID lpPageInformation,
     DWORD dwInfoLength,
     PSIZE_T lpNumberOfBytesWritten,
     LPDWORD lpEnclaveError
    );


__declspec(dllimport)

BOOL
__stdcall
InitializeEnclave(
     HANDLE hProcess,
     LPVOID lpAddress,
     LPCVOID lpEnclaveInformation,
     DWORD dwInfoLength,
     LPDWORD lpEnclaveError
    );


#line 85 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\enclaveapi.h"
#pragma endregion

#pragma region Desktop Family or OneCore Family


__declspec(dllimport)

BOOL
__stdcall
LoadEnclaveImageA(
     LPVOID lpEnclaveAddress,
     LPCSTR lpImageName
    );

__declspec(dllimport)

BOOL
__stdcall
LoadEnclaveImageW(
     LPVOID lpEnclaveAddress,
     LPCWSTR lpImageName
    );





#line 113 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\enclaveapi.h"

__declspec(dllimport)

BOOL
__stdcall
CallEnclave(
     LPENCLAVE_ROUTINE lpRoutine,
     LPVOID lpParameter,
     BOOL fWaitForThread,
     LPVOID* lpReturnValue
    );


__declspec(dllimport)

BOOL
__stdcall
TerminateEnclave(
     LPVOID lpAddress,
     BOOL fWait
    );


__declspec(dllimport)

BOOL
__stdcall
DeleteEnclave(
     LPVOID lpAddress
    );


#line 146 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\enclaveapi.h"
#pragma endregion


}
#line 151 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\enclaveapi.h"

#line 153 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\enclaveapi.h"
#line 59 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winbase.h"
#line 1 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\threadpoollegacyapiset.h"
/********************************************************************************
*                                                                               *
* threadpoolapi.h -- ApiSet Contract for api-ms-win-core-threadpool-l1          *
*                                                                               *
* Copyright (c) Microsoft Corporation. All rights reserved.                     *
*                                                                               *
********************************************************************************/


#pragma once
#line 12 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\threadpoollegacyapiset.h"










extern "C" {
#line 24 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\threadpoollegacyapiset.h"

//
// Thread pool API's
//

#pragma region Desktop Family or OneCore Family


__declspec(dllimport)
BOOL
__stdcall
QueueUserWorkItem(
     LPTHREAD_START_ROUTINE Function,
     PVOID Context,
     ULONG Flags
    );


__declspec(dllimport)

BOOL
__stdcall
UnregisterWaitEx(
     HANDLE WaitHandle,
     HANDLE CompletionEvent
    );


__declspec(dllimport)

HANDLE
__stdcall
CreateTimerQueue(
    void
    );


__declspec(dllimport)
BOOL
__stdcall
CreateTimerQueueTimer(
     PHANDLE phNewTimer,
     HANDLE TimerQueue,
     WAITORTIMERCALLBACK Callback,
     PVOID Parameter,
     DWORD DueTime,
     DWORD Period,
     ULONG Flags
    );


__declspec(dllimport)

BOOL
__stdcall
ChangeTimerQueueTimer(
     HANDLE TimerQueue,
     HANDLE Timer,
     ULONG DueTime,
     ULONG Period
    );


__declspec(dllimport)

BOOL
__stdcall
DeleteTimerQueueTimer(
     HANDLE TimerQueue,
     HANDLE Timer,
     HANDLE CompletionEvent
    );


__declspec(dllimport)

BOOL
__stdcall
DeleteTimerQueueEx(
     HANDLE TimerQueue,
     HANDLE CompletionEvent
    );


#line 109 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\threadpoollegacyapiset.h"
#pragma endregion


}
#line 114 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\threadpoollegacyapiset.h"

#line 116 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\threadpoollegacyapiset.h"
#line 60 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winbase.h"
#line 1 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\threadpoolapiset.h"
/********************************************************************************
*                                                                               *
* threadpoolapi.h -- ApiSet Contract for api-ms-win-core-threadpool-l1          *
*                                                                               *
* Copyright (c) Microsoft Corporation. All rights reserved.                     *
*                                                                               *
********************************************************************************/


#pragma once
#line 12 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\threadpoolapiset.h"










extern "C" {
#line 24 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\threadpoolapiset.h"

//
// Thread pool API's
//

#pragma region Application Family or OneCore Family


typedef
void
(__stdcall *PTP_WIN32_IO_CALLBACK)(
         PTP_CALLBACK_INSTANCE Instance,
     PVOID                 Context,
     PVOID                 Overlapped,
            ULONG                 IoResult,
            ULONG_PTR             NumberOfBytesTransferred,
         PTP_IO                Io
    );



__declspec(dllimport)

PTP_POOL
__stdcall
CreateThreadpool(
     PVOID reserved
    );


__declspec(dllimport)
void
__stdcall
SetThreadpoolThreadMaximum(
     PTP_POOL ptpp,
     DWORD cthrdMost
    );


__declspec(dllimport)
BOOL
__stdcall
SetThreadpoolThreadMinimum(
     PTP_POOL ptpp,
     DWORD cthrdMic
    );


__declspec(dllimport)
BOOL
__stdcall
SetThreadpoolStackInformation(
     PTP_POOL ptpp,
     PTP_POOL_STACK_INFORMATION ptpsi
    );


__declspec(dllimport)
BOOL
__stdcall
QueryThreadpoolStackInformation(
     PTP_POOL ptpp,
     PTP_POOL_STACK_INFORMATION ptpsi
    );


__declspec(dllimport)
void
__stdcall
CloseThreadpool(
     PTP_POOL ptpp
    );


__declspec(dllimport)

PTP_CLEANUP_GROUP
__stdcall
CreateThreadpoolCleanupGroup(
    void
    );


__declspec(dllimport)
void
__stdcall
CloseThreadpoolCleanupGroupMembers(
     PTP_CLEANUP_GROUP ptpcg,
     BOOL fCancelPendingCallbacks,
     PVOID pvCleanupContext
    );


__declspec(dllimport)
void
__stdcall
CloseThreadpoolCleanupGroup(
     PTP_CLEANUP_GROUP ptpcg
    );


__declspec(dllimport)
void
__stdcall
SetEventWhenCallbackReturns(
     PTP_CALLBACK_INSTANCE pci,
     HANDLE evt
    );


__declspec(dllimport)
void
__stdcall
ReleaseSemaphoreWhenCallbackReturns(
     PTP_CALLBACK_INSTANCE pci,
     HANDLE sem,
     DWORD crel
    );


__declspec(dllimport)
void
__stdcall
ReleaseMutexWhenCallbackReturns(
     PTP_CALLBACK_INSTANCE pci,
     HANDLE mut
    );


__declspec(dllimport)
void
__stdcall
LeaveCriticalSectionWhenCallbackReturns(
     PTP_CALLBACK_INSTANCE pci,
     PCRITICAL_SECTION pcs
    );


__declspec(dllimport)
void
__stdcall
FreeLibraryWhenCallbackReturns(
     PTP_CALLBACK_INSTANCE pci,
     HMODULE mod
    );


__declspec(dllimport)
BOOL
__stdcall
CallbackMayRunLong(
     PTP_CALLBACK_INSTANCE pci
    );


__declspec(dllimport)
void
__stdcall
DisassociateCurrentThreadFromCallback(
     PTP_CALLBACK_INSTANCE pci
    );


__declspec(dllimport)

BOOL
__stdcall
TrySubmitThreadpoolCallback(
     PTP_SIMPLE_CALLBACK pfns,
     PVOID pv,
     PTP_CALLBACK_ENVIRON pcbe
    );


__declspec(dllimport)

PTP_WORK
__stdcall
CreateThreadpoolWork(
     PTP_WORK_CALLBACK pfnwk,
     PVOID pv,
     PTP_CALLBACK_ENVIRON pcbe
    );


__declspec(dllimport)
void
__stdcall
SubmitThreadpoolWork(
     PTP_WORK pwk
    );


__declspec(dllimport)
void
__stdcall
WaitForThreadpoolWorkCallbacks(
     PTP_WORK pwk,
     BOOL fCancelPendingCallbacks
    );


__declspec(dllimport)
void
__stdcall
CloseThreadpoolWork(
     PTP_WORK pwk
    );


__declspec(dllimport)

PTP_TIMER
__stdcall
CreateThreadpoolTimer(
     PTP_TIMER_CALLBACK pfnti,
     PVOID pv,
     PTP_CALLBACK_ENVIRON pcbe
    );


__declspec(dllimport)
void
__stdcall
SetThreadpoolTimer(
     PTP_TIMER pti,
     PFILETIME pftDueTime,
     DWORD msPeriod,
     DWORD msWindowLength
    );


__declspec(dllimport)
BOOL
__stdcall
IsThreadpoolTimerSet(
     PTP_TIMER pti
    );


__declspec(dllimport)
void
__stdcall
WaitForThreadpoolTimerCallbacks(
     PTP_TIMER pti,
     BOOL fCancelPendingCallbacks
    );


__declspec(dllimport)
void
__stdcall
CloseThreadpoolTimer(
     PTP_TIMER pti
    );


__declspec(dllimport)

PTP_WAIT
__stdcall
CreateThreadpoolWait(
     PTP_WAIT_CALLBACK pfnwa,
     PVOID pv,
     PTP_CALLBACK_ENVIRON pcbe
    );


__declspec(dllimport)
void
__stdcall
SetThreadpoolWait(
     PTP_WAIT pwa,
     HANDLE h,
     PFILETIME pftTimeout
    );


__declspec(dllimport)
void
__stdcall
WaitForThreadpoolWaitCallbacks(
     PTP_WAIT pwa,
     BOOL fCancelPendingCallbacks
    );


__declspec(dllimport)
void
__stdcall
CloseThreadpoolWait(
     PTP_WAIT pwa
    );


__declspec(dllimport)

PTP_IO
__stdcall
CreateThreadpoolIo(
     HANDLE fl,
     PTP_WIN32_IO_CALLBACK pfnio,
     PVOID pv,
     PTP_CALLBACK_ENVIRON pcbe
    );


__declspec(dllimport)
void
__stdcall
StartThreadpoolIo(
     PTP_IO pio
    );


__declspec(dllimport)
void
__stdcall
CancelThreadpoolIo(
     PTP_IO pio
    );


__declspec(dllimport)
void
__stdcall
WaitForThreadpoolIoCallbacks(
     PTP_IO pio,
     BOOL fCancelPendingCallbacks
    );


__declspec(dllimport)
void
__stdcall
CloseThreadpoolIo(
     PTP_IO pio
    );


__declspec(dllimport)
BOOL
__stdcall
SetThreadpoolTimerEx(
     PTP_TIMER pti,
     PFILETIME pftDueTime,
     DWORD msPeriod,
     DWORD msWindowLength
    );


__declspec(dllimport)
BOOL
__stdcall
SetThreadpoolWaitEx(
     PTP_WAIT pwa,
     HANDLE h,
     PFILETIME pftTimeout,
     PVOID Reserved
    );


#line 387 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\threadpoolapiset.h"

#line 389 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\threadpoolapiset.h"
#pragma endregion

#pragma region Desktop Family or OneCore Family




#line 397 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\threadpoolapiset.h"

#line 399 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\threadpoolapiset.h"
#pragma endregion


}
#line 404 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\threadpoolapiset.h"

#line 406 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\threadpoolapiset.h"
#line 61 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winbase.h"
#line 1 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\jobapi.h"
/********************************************************************************
*                                                                               *
* jobapiset.h -- ApiSet Contract for api-ms-win-core-job-l1                     *  
*                                                                               *
* Copyright (c) Microsoft Corporation. All rights reserved.                     *
*                                                                               *
********************************************************************************/


#pragma once
#line 12 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\jobapi.h"










extern "C" {
#line 24 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\jobapi.h"

#pragma region Desktop Family or OneCore Family




__declspec(dllimport)
BOOL
__stdcall
IsProcessInJob(
     HANDLE ProcessHandle,
     HANDLE JobHandle,
     PBOOL Result
    );


#line 41 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\jobapi.h"

#line 43 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\jobapi.h"
#pragma endregion


}
#line 48 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\jobapi.h"

#line 50 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\jobapi.h"
#line 62 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winbase.h"
#line 1 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\jobapi2.h"
/********************************************************************************
*                                                                               *
* jobapiset2.h -- ApiSet Contract for api-ms-win-core-job-l2                     *
*                                                                               *
* Copyright (c) Microsoft Corporation. All rights reserved.                     *
*                                                                               *
********************************************************************************/



#pragma once









extern "C" {
#line 23 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\jobapi2.h"

#pragma region Desktop Family or OneCore Family



typedef struct JOBOBJECT_IO_RATE_CONTROL_INFORMATION {
    LONG64 MaxIops;
    LONG64 MaxBandwidth;
    LONG64 ReservationIops;
    PCWSTR VolumeName;
    ULONG BaseIoSize;
    ULONG ControlFlags;
} JOBOBJECT_IO_RATE_CONTROL_INFORMATION;

__declspec(dllimport)
HANDLE
__stdcall
CreateJobObjectW(
     LPSECURITY_ATTRIBUTES lpJobAttributes,
     LPCWSTR lpName
    );


__declspec(dllimport)
void
__stdcall
FreeMemoryJobObject(
      void * Buffer
    );

__declspec(dllimport)
HANDLE
__stdcall
OpenJobObjectW(
     DWORD dwDesiredAccess,
     BOOL bInheritHandle,
     LPCWSTR lpName
    );


__declspec(dllimport)
BOOL
__stdcall
AssignProcessToJobObject(
     HANDLE hJob,
     HANDLE hProcess
    );


__declspec(dllimport)
BOOL
__stdcall
TerminateJobObject(
     HANDLE hJob,
     UINT uExitCode
    );


__declspec(dllimport)
BOOL
__stdcall
SetInformationJobObject(
     HANDLE hJob,
     JOBOBJECTINFOCLASS JobObjectInformationClass,
     LPVOID lpJobObjectInformation,
     DWORD cbJobObjectInformationLength
    );


__declspec(dllimport)
DWORD
__stdcall
SetIoRateControlInformationJobObject(
     HANDLE hJob,
     JOBOBJECT_IO_RATE_CONTROL_INFORMATION* IoRateControlInfo
    );

__declspec(dllimport)
BOOL
__stdcall
QueryInformationJobObject(
     HANDLE hJob,
     JOBOBJECTINFOCLASS JobObjectInformationClass,
     LPVOID lpJobObjectInformation,
     DWORD cbJobObjectInformationLength,
     LPDWORD lpReturnLength
    );


__declspec(dllimport)
DWORD
__stdcall
QueryIoRateControlInformationJobObject(
     HANDLE hJob,
     PCWSTR VolumeName,
     JOBOBJECT_IO_RATE_CONTROL_INFORMATION** InfoBlocks,
     ULONG* InfoBlockCount
    );

#line 123 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\jobapi2.h"

#pragma endregion


}
#line 129 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\jobapi2.h"

#line 131 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\jobapi2.h"
#line 63 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winbase.h"
#line 1 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\wow64apiset.h"
/********************************************************************************
*                                                                               *
* wow64app.h - ApiSet Contract for api-ms-win-core-wow64-l1                     *
*                                                                               *
* Copyright (c) Microsoft Corporation. All rights reserved.                     *
*                                                                               *
********************************************************************************/


#pragma once
#line 12 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\wow64apiset.h"










extern "C" {
#line 24 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\wow64apiset.h"

#pragma region Desktop Family or OneCore Family


// RC warns because "WINBASE_DECLARE_GET_SYSTEM_WOW64_DIRECTORY" is a bit long.



__declspec(dllimport)
BOOL
__stdcall
Wow64DisableWow64FsRedirection(
     PVOID* OldValue
    );


__declspec(dllimport)
BOOL
__stdcall
Wow64RevertWow64FsRedirection(
     PVOID OlValue
    );


#line 49 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\wow64apiset.h"
#line 50 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\wow64apiset.h"

#line 52 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\wow64apiset.h"
#pragma endregion

#pragma region Application Family or OneCore Family




__declspec(dllimport)
BOOL
__stdcall
IsWow64Process(
     HANDLE hProcess,
     PBOOL Wow64Process
    );


#line 69 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\wow64apiset.h"

#line 71 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\wow64apiset.h"
#pragma endregion

#pragma region Desktop Family or OneCore Family


// RC warns because "WINBASE_DECLARE_GET_SYSTEM_WOW64_DIRECTORY" is a bit long.



__declspec(dllimport)


UINT
__stdcall
GetSystemWow64DirectoryA(
     LPSTR lpBuffer,
     UINT uSize
    );

__declspec(dllimport)


UINT
__stdcall
GetSystemWow64DirectoryW(
     LPWSTR lpBuffer,
     UINT uSize
    );





#line 105 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\wow64apiset.h"

#line 107 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\wow64apiset.h"
#line 108 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\wow64apiset.h"











#line 120 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\wow64apiset.h"

#line 122 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\wow64apiset.h"
#pragma endregion

#pragma region Application Family or OneCore Family














#line 140 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\wow64apiset.h"

#line 142 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\wow64apiset.h"
#pragma endregion

#pragma region Desktop Family or OneCore Family
































#line 178 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\wow64apiset.h"













#line 192 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\wow64apiset.h"

#line 194 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\wow64apiset.h"
#pragma endregion


}
#line 199 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\wow64apiset.h"

#line 201 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\wow64apiset.h"
#line 64 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winbase.h"
#line 1 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\libloaderapi.h"
/********************************************************************************
*                                                                               *
* libloaderapi.h -- ApiSet Contract for api-ms-win-core-libraryloader-l1        *
*                                                                               *
* Copyright (c) Microsoft Corporation. All rights reserved.                     *
*                                                                               *
********************************************************************************/


#pragma once
#line 12 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\libloaderapi.h"










extern "C" {
#line 24 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\libloaderapi.h"

#pragma region Desktop Family or OneCore Family














typedef struct tagENUMUILANG {
    ULONG  NumOfEnumUILang;    // Acutall number of enumerated languages
    ULONG  SizeOfEnumUIBuffer; // Buffer size of pMUIEnumUILanguages
    LANGID *pEnumUIBuffer;
} ENUMUILANG, *PENUMUILANG;



typedef BOOL (__stdcall * ENUMRESLANGPROCA)(
     HMODULE hModule,
     LPCSTR lpType,
     LPCSTR lpName,
     WORD wLanguage,
     LONG_PTR lParam);
typedef BOOL (__stdcall * ENUMRESLANGPROCW)(
     HMODULE hModule,
     LPCWSTR lpType,
     LPCWSTR lpName,
     WORD wLanguage,
     LONG_PTR lParam);




#line 65 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\libloaderapi.h"

typedef BOOL (__stdcall * ENUMRESNAMEPROCA)(
     HMODULE hModule,
     LPCSTR lpType,
     LPSTR lpName,
     LONG_PTR lParam);
typedef BOOL (__stdcall * ENUMRESNAMEPROCW)(
     HMODULE hModule,
     LPCWSTR lpType,
     LPWSTR lpName,
     LONG_PTR lParam);




#line 81 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\libloaderapi.h"

typedef BOOL (__stdcall * ENUMRESTYPEPROCA)(
     HMODULE hModule,
     LPSTR lpType,
     LONG_PTR lParam
    );
typedef BOOL (__stdcall * ENUMRESTYPEPROCW)(
     HMODULE hModule,
     LPWSTR lpType,
     LONG_PTR lParam
    );




#line 97 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\libloaderapi.h"

























#line 123 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\libloaderapi.h"

#line 125 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\libloaderapi.h"
#pragma endregion

#pragma region Application Family or OneCore Family


__declspec(dllimport)
BOOL
__stdcall
DisableThreadLibraryCalls(
     HMODULE hLibModule
    );


#line 139 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\libloaderapi.h"
#pragma endregion

#pragma region Desktop Family or OneCore Family or Games Family


__declspec(dllimport)

HRSRC
__stdcall
FindResourceExW(
     HMODULE hModule,
     LPCWSTR lpType,
     LPCWSTR lpName,
     WORD wLanguage
    );






#line 161 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\libloaderapi.h"
#pragma endregion

#pragma region Application Family or OneCore Family




__declspec(dllimport)
int
__stdcall
FindStringOrdinal(
     DWORD dwFindStringOrdinalFlags,
     LPCWSTR lpStringSource,
     int cchSource,
     LPCWSTR lpStringValue,
     int cchValue,
     BOOL bIgnoreCase
    );


#line 182 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\libloaderapi.h"

__declspec(dllimport)
BOOL
__stdcall
FreeLibrary(
     HMODULE hLibModule
    );


__declspec(dllimport)
__declspec(noreturn)
void
__stdcall
FreeLibraryAndExitThread(
     HMODULE hLibModule,
     DWORD dwExitCode
    );

    
#line 202 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\libloaderapi.h"
#pragma endregion

#pragma region Desktop Family or OneCore Family


__declspec(dllimport)
BOOL
__stdcall
FreeResource(
     HGLOBAL hResData
    );

    
#line 216 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\libloaderapi.h"
#pragma endregion

#pragma region Application Family or OneCore Family


__declspec(dllimport)


DWORD
__stdcall
GetModuleFileNameA(
     HMODULE hModule,
     LPSTR lpFilename,
     DWORD nSize
    );

__declspec(dllimport)


DWORD
__stdcall
GetModuleFileNameW(
     HMODULE hModule,
     LPWSTR lpFilename,
     DWORD nSize
    );





#line 248 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\libloaderapi.h"

#line 250 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\libloaderapi.h"
#pragma endregion

#pragma region Desktop Family or OneCore Family


__declspec(dllimport)


HMODULE
__stdcall
GetModuleHandleA(
     LPCSTR lpModuleName
    );

__declspec(dllimport)


HMODULE
__stdcall
GetModuleHandleW(
     LPCWSTR lpModuleName
    );





#line 278 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\libloaderapi.h"







typedef
BOOL
(__stdcall *
PGET_MODULE_HANDLE_EXA)(
            DWORD        dwFlags,
        LPCSTR     lpModuleName,
     HMODULE*    phModule
    );
typedef
BOOL
(__stdcall *
PGET_MODULE_HANDLE_EXW)(
            DWORD        dwFlags,
        LPCWSTR     lpModuleName,
     HMODULE*    phModule
    );




#line 306 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\libloaderapi.h"

__declspec(dllimport)
BOOL
__stdcall
GetModuleHandleExA(
     DWORD dwFlags,
     LPCSTR lpModuleName,
     HMODULE* phModule
    );

__declspec(dllimport)
BOOL
__stdcall
GetModuleHandleExW(
     DWORD dwFlags,
     LPCWSTR lpModuleName,
     HMODULE* phModule
    );





#line 330 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\libloaderapi.h"

#line 332 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\libloaderapi.h"

#line 334 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\libloaderapi.h"
#pragma endregion

#pragma region Application Family or OneCore Family


__declspec(dllimport)
FARPROC
__stdcall
GetProcAddress(
     HMODULE hModule,
     LPCSTR lpProcName
    );




typedef struct _REDIRECTION_FUNCTION_DESCRIPTOR {
    PCSTR DllName;
    PCSTR FunctionName;
    PVOID RedirectionTarget;
} REDIRECTION_FUNCTION_DESCRIPTOR, *PREDIRECTION_FUNCTION_DESCRIPTOR;

typedef const REDIRECTION_FUNCTION_DESCRIPTOR *PCREDIRECTION_FUNCTION_DESCRIPTOR;

typedef struct _REDIRECTION_DESCRIPTOR {
    ULONG Version;
    ULONG FunctionCount;
    PCREDIRECTION_FUNCTION_DESCRIPTOR Redirections;
} REDIRECTION_DESCRIPTOR, *PREDIRECTION_DESCRIPTOR;

typedef const REDIRECTION_DESCRIPTOR *PCREDIRECTION_DESCRIPTOR;

#line 367 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\libloaderapi.h"
#pragma endregion

#pragma region Desktop Family or OneCore Family


__declspec(dllimport)

HMODULE
__stdcall
LoadLibraryExA(
     LPCSTR lpLibFileName,
     HANDLE hFile,
     DWORD dwFlags
    );

__declspec(dllimport)

HMODULE
__stdcall
LoadLibraryExW(
     LPCWSTR lpLibFileName,
     HANDLE hFile,
     DWORD dwFlags
    );





#line 397 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\libloaderapi.h"



// reserved for internal LOAD_PACKAGED_LIBRARY: 0x00000004

















#line 419 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\libloaderapi.h"

//
// For anything building for downlevel, set the flag to be the same as LOAD_LIBRARY_SEARCH_SYSTEM32
// such that they're treated the same when running on older version of OS.
//



#line 428 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\libloaderapi.h"





#line 434 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\libloaderapi.h"

__declspec(dllimport)

HGLOBAL
__stdcall
LoadResource(
     HMODULE hModule,
     HRSRC hResInfo
    );


#line 446 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\libloaderapi.h"
#pragma endregion

#pragma region Desktop Family or OneCore Family


__declspec(dllimport)
int
__stdcall
LoadStringA(
     HINSTANCE hInstance,
     UINT uID,
     LPSTR lpBuffer,
     int cchBufferMax
    );

__declspec(dllimport)
int
__stdcall
LoadStringW(
     HINSTANCE hInstance,
     UINT uID,
     LPWSTR lpBuffer,
     int cchBufferMax
    );





#line 476 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\libloaderapi.h"

#line 478 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\libloaderapi.h"
#pragma endregion

#pragma region Desktop Family or OneCore Family


__declspec(dllimport)
LPVOID
__stdcall
LockResource(
     HGLOBAL hResData
    );


__declspec(dllimport)
DWORD
__stdcall
SizeofResource(
     HMODULE hModule,
     HRSRC hResInfo
    );


#line 501 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\libloaderapi.h"
#pragma endregion

#pragma region Desktop Family or OneCore Family


typedef PVOID DLL_DIRECTORY_COOKIE, *PDLL_DIRECTORY_COOKIE;

__declspec(dllimport)
DLL_DIRECTORY_COOKIE
__stdcall
AddDllDirectory(
     PCWSTR NewDirectory
    );


__declspec(dllimport)
BOOL
__stdcall
RemoveDllDirectory(
     DLL_DIRECTORY_COOKIE Cookie
    );


__declspec(dllimport)
BOOL
__stdcall
SetDefaultDllDirectories(
     DWORD DirectoryFlags
    );


#line 533 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\libloaderapi.h"
#pragma endregion

#pragma region Desktop Family or OneCore Family




__declspec(dllimport)
BOOL
__stdcall
EnumResourceLanguagesExA(
     HMODULE hModule,
     LPCSTR lpType,
     LPCSTR lpName,
     ENUMRESLANGPROCA lpEnumFunc,
     LONG_PTR lParam,
    DWORD dwFlags,
    LANGID LangId
    );

__declspec(dllimport)
BOOL
__stdcall
EnumResourceLanguagesExW(
     HMODULE hModule,
     LPCWSTR lpType,
     LPCWSTR lpName,
     ENUMRESLANGPROCW lpEnumFunc,
     LONG_PTR lParam,
    DWORD dwFlags,
    LANGID LangId
    );





#line 571 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\libloaderapi.h"

__declspec(dllimport)
BOOL
__stdcall
EnumResourceNamesExA(
     HMODULE hModule,
     LPCSTR lpType,
     ENUMRESNAMEPROCA lpEnumFunc,
     LONG_PTR lParam,
    DWORD dwFlags,
    LANGID LangId
    );

__declspec(dllimport)
BOOL
__stdcall
EnumResourceNamesExW(
     HMODULE hModule,
     LPCWSTR lpType,
     ENUMRESNAMEPROCW lpEnumFunc,
     LONG_PTR lParam,
    DWORD dwFlags,
    LANGID LangId
    );





#line 601 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\libloaderapi.h"

__declspec(dllimport)
BOOL
__stdcall
EnumResourceTypesExA(
     HMODULE hModule,
     ENUMRESTYPEPROCA lpEnumFunc,
     LONG_PTR lParam,
    DWORD dwFlags,
    LANGID LangId
    );

__declspec(dllimport)
BOOL
__stdcall
EnumResourceTypesExW(
     HMODULE hModule,
     ENUMRESTYPEPROCW lpEnumFunc,
     LONG_PTR lParam,
    DWORD dwFlags,
    LANGID LangId
    );





#line 629 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\libloaderapi.h"

#line 631 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\libloaderapi.h"

#line 633 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\libloaderapi.h"
#pragma endregion

#pragma region Desktop Family or OneCore Family or Games Family


__declspec(dllimport)

HRSRC
__stdcall
FindResourceW(
     HMODULE hModule,
     LPCWSTR lpName,
     LPCWSTR lpType
    );






#line 654 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\libloaderapi.h"
#pragma endregion

#pragma region Desktop Family or OneCore Family


__declspec(dllimport)

HMODULE
__stdcall
LoadLibraryA(
     LPCSTR lpLibFileName
    );

__declspec(dllimport)

HMODULE
__stdcall
LoadLibraryW(
     LPCWSTR lpLibFileName
    );





#line 680 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\libloaderapi.h"

#line 682 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\libloaderapi.h"
#pragma endregion

#pragma region Desktop Family or OneCore Family


__declspec(dllimport)
BOOL
__stdcall
EnumResourceNamesW(
     HMODULE hModule,
     LPCWSTR lpType,
     ENUMRESNAMEPROCW lpEnumFunc,
     LONG_PTR lParam
    );






#line 703 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\libloaderapi.h"
#pragma endregion


}
#line 708 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\libloaderapi.h"

#line 710 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\libloaderapi.h"

#line 65 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winbase.h"
#line 1 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\securitybaseapi.h"
/********************************************************************************
*                                                                               *
* securitybaseapi.h -- ApiSet Contract for api-ms-win-security-base-l1          *
*                                                                               *
* Copyright (c) Microsoft Corporation. All rights reserved.                     *
*                                                                               *
********************************************************************************/


#pragma once
#line 12 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\securitybaseapi.h"










extern "C" {
#line 24 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\securitybaseapi.h"

//
//
// Security APIs
//

#pragma region Desktop Family or OneCore Family


__declspec(dllimport)
BOOL
__stdcall
AccessCheck(
     PSECURITY_DESCRIPTOR pSecurityDescriptor,
     HANDLE ClientToken,
     DWORD DesiredAccess,
     PGENERIC_MAPPING GenericMapping,
     PPRIVILEGE_SET PrivilegeSet,
     LPDWORD PrivilegeSetLength,
     LPDWORD GrantedAccess,
     LPBOOL AccessStatus
    );


__declspec(dllimport)
BOOL
__stdcall
AccessCheckAndAuditAlarmW(
     LPCWSTR SubsystemName,
     LPVOID HandleId,
     LPWSTR ObjectTypeName,
     LPWSTR ObjectName,
     PSECURITY_DESCRIPTOR SecurityDescriptor,
     DWORD DesiredAccess,
     PGENERIC_MAPPING GenericMapping,
     BOOL ObjectCreation,
     LPDWORD GrantedAccess,
     LPBOOL AccessStatus,
     LPBOOL pfGenerateOnClose
    );






__declspec(dllimport)
BOOL
__stdcall
AccessCheckByType(
     PSECURITY_DESCRIPTOR pSecurityDescriptor,
     PSID PrincipalSelfSid,
     HANDLE ClientToken,
     DWORD DesiredAccess,
     POBJECT_TYPE_LIST ObjectTypeList,
     DWORD ObjectTypeListLength,
     PGENERIC_MAPPING GenericMapping,
     PPRIVILEGE_SET PrivilegeSet,
     LPDWORD PrivilegeSetLength,
     LPDWORD GrantedAccess,
     LPBOOL AccessStatus
    );


__declspec(dllimport)
BOOL
__stdcall
AccessCheckByTypeResultList(
     PSECURITY_DESCRIPTOR pSecurityDescriptor,
     PSID PrincipalSelfSid,
     HANDLE ClientToken,
     DWORD DesiredAccess,
     POBJECT_TYPE_LIST ObjectTypeList,
     DWORD ObjectTypeListLength,
     PGENERIC_MAPPING GenericMapping,
     PPRIVILEGE_SET PrivilegeSet,
     LPDWORD PrivilegeSetLength,
     LPDWORD GrantedAccessList,
     LPDWORD AccessStatusList
    );


__declspec(dllimport)
BOOL
__stdcall
AccessCheckByTypeAndAuditAlarmW(
     LPCWSTR SubsystemName,
     LPVOID HandleId,
     LPCWSTR ObjectTypeName,
     LPCWSTR ObjectName,
     PSECURITY_DESCRIPTOR SecurityDescriptor,
     PSID PrincipalSelfSid,
     DWORD DesiredAccess,
     AUDIT_EVENT_TYPE AuditType,
     DWORD Flags,
     POBJECT_TYPE_LIST ObjectTypeList,
     DWORD ObjectTypeListLength,
     PGENERIC_MAPPING GenericMapping,
     BOOL ObjectCreation,
     LPDWORD GrantedAccess,
     LPBOOL AccessStatus,
     LPBOOL pfGenerateOnClose
    );






__declspec(dllimport)
BOOL
__stdcall
AccessCheckByTypeResultListAndAuditAlarmW(
     LPCWSTR SubsystemName,
     LPVOID HandleId,
     LPCWSTR ObjectTypeName,
     LPCWSTR ObjectName,
     PSECURITY_DESCRIPTOR SecurityDescriptor,
     PSID PrincipalSelfSid,
     DWORD DesiredAccess,
     AUDIT_EVENT_TYPE AuditType,
     DWORD Flags,
     POBJECT_TYPE_LIST ObjectTypeList,
     DWORD ObjectTypeListLength,
     PGENERIC_MAPPING GenericMapping,
     BOOL ObjectCreation,
     LPDWORD GrantedAccessList,
     LPDWORD AccessStatusList,
     LPBOOL pfGenerateOnClose
    );






__declspec(dllimport)
BOOL
__stdcall
AccessCheckByTypeResultListAndAuditAlarmByHandleW(
     LPCWSTR SubsystemName,
     LPVOID HandleId,
     HANDLE ClientToken,
     LPCWSTR ObjectTypeName,
     LPCWSTR ObjectName,
     PSECURITY_DESCRIPTOR SecurityDescriptor,
     PSID PrincipalSelfSid,
     DWORD DesiredAccess,
     AUDIT_EVENT_TYPE AuditType,
     DWORD Flags,
     POBJECT_TYPE_LIST ObjectTypeList,
     DWORD ObjectTypeListLength,
     PGENERIC_MAPPING GenericMapping,
     BOOL ObjectCreation,
     LPDWORD GrantedAccessList,
     LPDWORD AccessStatusList,
     LPBOOL pfGenerateOnClose
    );






#line 189 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\securitybaseapi.h"
#pragma endregion

#pragma region Application Family or OneCore Family


__declspec(dllimport)
BOOL
__stdcall
AddAccessAllowedAce(
     PACL pAcl,
     DWORD dwAceRevision,
     DWORD AccessMask,
     PSID pSid
    );


__declspec(dllimport)
BOOL
__stdcall
AddAccessAllowedAceEx(
     PACL pAcl,
     DWORD dwAceRevision,
     DWORD AceFlags,
     DWORD AccessMask,
     PSID pSid
    );


#line 218 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\securitybaseapi.h"
#pragma endregion

#pragma region Desktop Family or OneCore Family


__declspec(dllimport)
BOOL
__stdcall
AddAccessAllowedObjectAce(
     PACL pAcl,
     DWORD dwAceRevision,
     DWORD AceFlags,
     DWORD AccessMask,
     GUID* ObjectTypeGuid,
     GUID* InheritedObjectTypeGuid,
     PSID pSid
    );


__declspec(dllimport)
BOOL
__stdcall
AddAccessDeniedAce(
     PACL pAcl,
     DWORD dwAceRevision,
     DWORD AccessMask,
     PSID pSid
    );


__declspec(dllimport)
BOOL
__stdcall
AddAccessDeniedAceEx(
     PACL pAcl,
     DWORD dwAceRevision,
     DWORD AceFlags,
     DWORD AccessMask,
     PSID pSid
    );


__declspec(dllimport)
BOOL
__stdcall
AddAccessDeniedObjectAce(
     PACL pAcl,
     DWORD dwAceRevision,
     DWORD AceFlags,
     DWORD AccessMask,
     GUID* ObjectTypeGuid,
     GUID* InheritedObjectTypeGuid,
     PSID pSid
    );


#line 275 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\securitybaseapi.h"
#pragma endregion

#pragma region Application Family or OneCore Family


__declspec(dllimport)
BOOL
__stdcall
AddAce(
     PACL pAcl,
     DWORD dwAceRevision,
     DWORD dwStartingAceIndex,
     LPVOID pAceList,
     DWORD nAceListLength
    );


#line 293 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\securitybaseapi.h"
#pragma endregion

#pragma region Desktop Family or OneCore Family


__declspec(dllimport)
BOOL
__stdcall
AddAuditAccessAce(
     PACL pAcl,
     DWORD dwAceRevision,
     DWORD dwAccessMask,
     PSID pSid,
     BOOL bAuditSuccess,
     BOOL bAuditFailure
    );


__declspec(dllimport)
BOOL
__stdcall
AddAuditAccessAceEx(
     PACL pAcl,
     DWORD dwAceRevision,
     DWORD AceFlags,
     DWORD dwAccessMask,
     PSID pSid,
     BOOL bAuditSuccess,
     BOOL bAuditFailure
    );


__declspec(dllimport)
BOOL
__stdcall
AddAuditAccessObjectAce(
     PACL pAcl,
     DWORD dwAceRevision,
     DWORD AceFlags,
     DWORD AccessMask,
     GUID* ObjectTypeGuid,
     GUID* InheritedObjectTypeGuid,
     PSID pSid,
     BOOL bAuditSuccess,
     BOOL bAuditFailure
    );


#line 342 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\securitybaseapi.h"
#pragma endregion

#pragma region Application Family or OneCore Family




__declspec(dllimport)
BOOL
__stdcall
AddMandatoryAce(
     PACL pAcl,
     DWORD dwAceRevision,
     DWORD AceFlags,
     DWORD MandatoryPolicy,
     PSID pLabelSid
    );


#line 362 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\securitybaseapi.h"

#line 364 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\securitybaseapi.h"
#pragma endregion



































#line 401 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\securitybaseapi.h"

#pragma region Application Family or OneCore Family


__declspec(dllimport)
BOOL
__stdcall
AdjustTokenGroups(
     HANDLE TokenHandle,
     BOOL ResetToDefault,
     PTOKEN_GROUPS NewState,
     DWORD BufferLength,
     PTOKEN_GROUPS PreviousState,
     PDWORD ReturnLength
    );


__declspec(dllimport)
BOOL
__stdcall
AdjustTokenPrivileges(
     HANDLE TokenHandle,
     BOOL DisableAllPrivileges,
     PTOKEN_PRIVILEGES NewState,
     DWORD BufferLength,
     PTOKEN_PRIVILEGES PreviousState,
     PDWORD ReturnLength
    );


__declspec(dllimport)
BOOL
__stdcall
AllocateAndInitializeSid(
     PSID_IDENTIFIER_AUTHORITY pIdentifierAuthority,
     BYTE nSubAuthorityCount,
     DWORD nSubAuthority0,
     DWORD nSubAuthority1,
     DWORD nSubAuthority2,
     DWORD nSubAuthority3,
     DWORD nSubAuthority4,
     DWORD nSubAuthority5,
     DWORD nSubAuthority6,
     DWORD nSubAuthority7,
     PSID* pSid
    );


__declspec(dllimport)
BOOL
__stdcall
AllocateLocallyUniqueId(
     PLUID Luid
    );


#line 458 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\securitybaseapi.h"
#pragma endregion

#pragma region Desktop Family or OneCore Family


__declspec(dllimport)
BOOL
__stdcall
AreAllAccessesGranted(
     DWORD GrantedAccess,
     DWORD DesiredAccess
    );


__declspec(dllimport)
BOOL
__stdcall
AreAnyAccessesGranted(
     DWORD GrantedAccess,
     DWORD DesiredAccess
    );


#line 482 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\securitybaseapi.h"
#pragma endregion

#pragma region Application Family or OneCore Family


__declspec(dllimport)
BOOL
__stdcall
CheckTokenMembership(
     HANDLE TokenHandle,
     PSID SidToCheck,
     PBOOL IsMember
    );


#line 498 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\securitybaseapi.h"
#pragma endregion















































#line 547 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\securitybaseapi.h"

#pragma region Desktop Family or OneCore Family


__declspec(dllimport)
BOOL
__stdcall
ConvertToAutoInheritPrivateObjectSecurity(
     PSECURITY_DESCRIPTOR ParentDescriptor,
     PSECURITY_DESCRIPTOR CurrentSecurityDescriptor,
     PSECURITY_DESCRIPTOR* NewSecurityDescriptor,
     GUID* ObjectType,
     BOOLEAN IsDirectoryObject,
     PGENERIC_MAPPING GenericMapping
    );


#line 565 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\securitybaseapi.h"
#pragma endregion

#pragma region Application Family or OneCore Family


__declspec(dllimport)
BOOL
__stdcall
CopySid(
     DWORD nDestinationSidLength,
     PSID pDestinationSid,
     PSID pSourceSid
    );


#line 581 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\securitybaseapi.h"
#pragma endregion

#pragma region Desktop Family or OneCore Family


__declspec(dllimport)
BOOL
__stdcall
CreatePrivateObjectSecurity(
     PSECURITY_DESCRIPTOR ParentDescriptor,
     PSECURITY_DESCRIPTOR CreatorDescriptor,
     PSECURITY_DESCRIPTOR* NewDescriptor,
     BOOL IsDirectoryObject,
     HANDLE Token,
     PGENERIC_MAPPING GenericMapping
    );


__declspec(dllimport)
BOOL
__stdcall
CreatePrivateObjectSecurityEx(
     PSECURITY_DESCRIPTOR ParentDescriptor,
     PSECURITY_DESCRIPTOR CreatorDescriptor,
     PSECURITY_DESCRIPTOR* NewDescriptor,
     GUID* ObjectType,
     BOOL IsContainerObject,
     ULONG AutoInheritFlags,
     HANDLE Token,
     PGENERIC_MAPPING GenericMapping
    );


__declspec(dllimport)
BOOL
__stdcall
CreatePrivateObjectSecurityWithMultipleInheritance(
     PSECURITY_DESCRIPTOR ParentDescriptor,
     PSECURITY_DESCRIPTOR CreatorDescriptor,
     PSECURITY_DESCRIPTOR* NewDescriptor,
     GUID** ObjectTypes,
     ULONG GuidCount,
     BOOL IsContainerObject,
     ULONG AutoInheritFlags,
     HANDLE Token,
     PGENERIC_MAPPING GenericMapping
    );


__declspec(dllimport)
BOOL
__stdcall
CreateRestrictedToken(
     HANDLE ExistingTokenHandle,
     DWORD Flags,
     DWORD DisableSidCount,
     PSID_AND_ATTRIBUTES SidsToDisable,
     DWORD DeletePrivilegeCount,
     PLUID_AND_ATTRIBUTES PrivilegesToDelete,
     DWORD RestrictedSidCount,
     PSID_AND_ATTRIBUTES SidsToRestrict,
     PHANDLE NewTokenHandle
    );


#line 647 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\securitybaseapi.h"
#pragma endregion

#pragma region Application Family or OneCore Family




__declspec(dllimport)

BOOL
__stdcall
CreateWellKnownSid(
     WELL_KNOWN_SID_TYPE WellKnownSidType,
     PSID DomainSid,
     PSID pSid,
     DWORD* cbSid
    );


__declspec(dllimport)

BOOL
__stdcall
EqualDomainSid(
     PSID pSid1,
     PSID pSid2,
     BOOL* pfEqual
    );


#line 678 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\securitybaseapi.h"

__declspec(dllimport)
BOOL
__stdcall
DeleteAce(
     PACL pAcl,
     DWORD dwAceIndex
    );


#line 689 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\securitybaseapi.h"
#pragma endregion

#pragma region Desktop Family or OneCore Family


__declspec(dllimport)
BOOL
__stdcall
DestroyPrivateObjectSecurity(
      PSECURITY_DESCRIPTOR* ObjectDescriptor
    );


#line 703 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\securitybaseapi.h"
#pragma endregion

#pragma region Application Family or OneCore Family


__declspec(dllimport)
BOOL
__stdcall
DuplicateToken(
     HANDLE ExistingTokenHandle,
     SECURITY_IMPERSONATION_LEVEL ImpersonationLevel,
     PHANDLE DuplicateTokenHandle
    );


__declspec(dllimport)
BOOL
__stdcall
DuplicateTokenEx(
     HANDLE hExistingToken,
     DWORD dwDesiredAccess,
     LPSECURITY_ATTRIBUTES lpTokenAttributes,
     SECURITY_IMPERSONATION_LEVEL ImpersonationLevel,
     TOKEN_TYPE TokenType,
     PHANDLE phNewToken
    );


#line 732 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\securitybaseapi.h"
#pragma endregion

#pragma region Desktop Family or OneCore Family


__declspec(dllimport)
BOOL
__stdcall
EqualPrefixSid(
     PSID pSid1,
     PSID pSid2
    );


__declspec(dllimport)
BOOL
__stdcall
EqualSid(
     PSID pSid1,
     PSID pSid2
    );


__declspec(dllimport)
BOOL
__stdcall
FindFirstFreeAce(
     PACL pAcl,
     LPVOID* pAce
    );


#line 765 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\securitybaseapi.h"
#pragma endregion

#pragma region Application Family or OneCore Family


__declspec(dllimport)
PVOID
__stdcall
FreeSid(
     PSID pSid
    );


__declspec(dllimport)
BOOL
__stdcall
GetAce(
     PACL pAcl,
     DWORD dwAceIndex,
     LPVOID* pAce
    );


__declspec(dllimport)
BOOL
__stdcall
GetAclInformation(
     PACL pAcl,
     LPVOID pAclInformation,
     DWORD nAclInformationLength,
     ACL_INFORMATION_CLASS dwAclInformationClass
    );


#line 800 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\securitybaseapi.h"
#pragma endregion

#pragma region Desktop Family or OneCore Family


__declspec(dllimport)
BOOL
__stdcall
GetFileSecurityW(
     LPCWSTR lpFileName,
     SECURITY_INFORMATION RequestedInformation,
     PSECURITY_DESCRIPTOR pSecurityDescriptor,
     DWORD nLength,
     LPDWORD lpnLengthNeeded
    );






#line 822 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\securitybaseapi.h"
#pragma endregion

#pragma region Application Family or OneCore Family


__declspec(dllimport)
BOOL
__stdcall
GetKernelObjectSecurity(
     HANDLE Handle,
     SECURITY_INFORMATION RequestedInformation,
     PSECURITY_DESCRIPTOR pSecurityDescriptor,
     DWORD nLength,
     LPDWORD lpnLengthNeeded
    );


__declspec(dllimport)


DWORD
__stdcall
GetLengthSid(
      PSID pSid
    );


#line 850 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\securitybaseapi.h"
#pragma endregion

#pragma region Desktop Family or OneCore Family


__declspec(dllimport)

BOOL
__stdcall
GetPrivateObjectSecurity(
     PSECURITY_DESCRIPTOR ObjectDescriptor,
     SECURITY_INFORMATION SecurityInformation,
     PSECURITY_DESCRIPTOR ResultantDescriptor,
     DWORD DescriptorLength,
     PDWORD ReturnLength
    );


#line 869 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\securitybaseapi.h"
#pragma endregion

#pragma region Application Family or OneCore Family


__declspec(dllimport)
BOOL
__stdcall
GetSecurityDescriptorControl(
     PSECURITY_DESCRIPTOR pSecurityDescriptor,
     PSECURITY_DESCRIPTOR_CONTROL pControl,
     LPDWORD lpdwRevision
    );


__declspec(dllimport)
BOOL
__stdcall
GetSecurityDescriptorDacl(
     PSECURITY_DESCRIPTOR pSecurityDescriptor,
     LPBOOL lpbDaclPresent,
     PACL* pDacl,
     LPBOOL lpbDaclDefaulted
    );


__declspec(dllimport)
BOOL
__stdcall
GetSecurityDescriptorGroup(
     PSECURITY_DESCRIPTOR pSecurityDescriptor,
     PSID* pGroup,
     LPBOOL lpbGroupDefaulted
    );


__declspec(dllimport)
DWORD
__stdcall
GetSecurityDescriptorLength(
     PSECURITY_DESCRIPTOR pSecurityDescriptor
    );


__declspec(dllimport)
BOOL
__stdcall
GetSecurityDescriptorOwner(
     PSECURITY_DESCRIPTOR pSecurityDescriptor,
     PSID* pOwner,
     LPBOOL lpbOwnerDefaulted
    );


__declspec(dllimport)
DWORD
__stdcall
GetSecurityDescriptorRMControl(
     PSECURITY_DESCRIPTOR SecurityDescriptor,
     PUCHAR RMControl
    );


__declspec(dllimport)
BOOL
__stdcall
GetSecurityDescriptorSacl(
     PSECURITY_DESCRIPTOR pSecurityDescriptor,
     LPBOOL lpbSaclPresent,
     PACL* pSacl,
     LPBOOL lpbSaclDefaulted
    );


__declspec(dllimport)
PSID_IDENTIFIER_AUTHORITY
__stdcall
GetSidIdentifierAuthority(
     PSID pSid
    );


__declspec(dllimport)
DWORD
__stdcall
GetSidLengthRequired(
     UCHAR nSubAuthorityCount
    );


__declspec(dllimport)
PDWORD
__stdcall
GetSidSubAuthority(
     PSID pSid,
     DWORD nSubAuthority
    );


__declspec(dllimport)
PUCHAR
__stdcall
GetSidSubAuthorityCount(
     PSID pSid
    );


__declspec(dllimport)
BOOL
__stdcall
GetTokenInformation(
     HANDLE TokenHandle,
     TOKEN_INFORMATION_CLASS TokenInformationClass,
     LPVOID TokenInformation,
     DWORD TokenInformationLength,
     PDWORD ReturnLength
    );




__declspec(dllimport)

BOOL
__stdcall
GetWindowsAccountDomainSid(
     PSID pSid,
     PSID pDomainSid,
     DWORD* cbDomainSid
    );


#line 1002 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\securitybaseapi.h"

#line 1004 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\securitybaseapi.h"
#pragma endregion

#pragma region Desktop Family or OneCore Family


__declspec(dllimport)
BOOL
__stdcall
ImpersonateAnonymousToken(
     HANDLE ThreadHandle
    );



__declspec(dllimport)
BOOL
__stdcall
ImpersonateLoggedOnUser(
     HANDLE hToken
    );



__declspec(dllimport)
BOOL
__stdcall
ImpersonateSelf(
     SECURITY_IMPERSONATION_LEVEL ImpersonationLevel
    );


#line 1036 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\securitybaseapi.h"
#pragma endregion

#pragma region Application Family or OneCore Family


__declspec(dllimport)
BOOL
__stdcall
InitializeAcl(
     PACL pAcl,
     DWORD nAclLength,
     DWORD dwAclRevision
    );


__declspec(dllimport)
BOOL
__stdcall
InitializeSecurityDescriptor(
     PSECURITY_DESCRIPTOR pSecurityDescriptor,
     DWORD dwRevision
    );


__declspec(dllimport)
BOOL
__stdcall
InitializeSid(
     PSID Sid,
     PSID_IDENTIFIER_AUTHORITY pIdentifierAuthority,
     BYTE nSubAuthorityCount
    );


#line 1071 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\securitybaseapi.h"
#pragma endregion

#pragma region Desktop Family or OneCore Family


__declspec(dllimport)
BOOL
__stdcall
IsTokenRestricted(
     HANDLE TokenHandle
    );


#line 1085 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\securitybaseapi.h"
#pragma endregion

#pragma region Application Family or OneCore Family


__declspec(dllimport)
BOOL
__stdcall
IsValidAcl(
     PACL pAcl
    );


__declspec(dllimport)
BOOL
__stdcall
IsValidSecurityDescriptor(
     PSECURITY_DESCRIPTOR pSecurityDescriptor
    );


__declspec(dllimport)
BOOL
__stdcall
IsValidSid(
     PSID pSid
    );




__declspec(dllimport)
BOOL
__stdcall
IsWellKnownSid(
     PSID pSid,
     WELL_KNOWN_SID_TYPE WellKnownSidType
    );


#line 1126 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\securitybaseapi.h"

__declspec(dllimport)

BOOL
__stdcall
MakeAbsoluteSD(
     PSECURITY_DESCRIPTOR pSelfRelativeSecurityDescriptor,
     PSECURITY_DESCRIPTOR pAbsoluteSecurityDescriptor,
     LPDWORD lpdwAbsoluteSecurityDescriptorSize,
     PACL pDacl,
     LPDWORD lpdwDaclSize,
     PACL pSacl,
     LPDWORD lpdwSaclSize,
     PSID pOwner,
     LPDWORD lpdwOwnerSize,
     PSID pPrimaryGroup,
     LPDWORD lpdwPrimaryGroupSize
    );


__declspec(dllimport)

BOOL
__stdcall
MakeSelfRelativeSD(
     PSECURITY_DESCRIPTOR pAbsoluteSecurityDescriptor,
     PSECURITY_DESCRIPTOR pSelfRelativeSecurityDescriptor,
     LPDWORD lpdwBufferLength
    );


#line 1158 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\securitybaseapi.h"
#pragma endregion

#pragma region Desktop Family or OneCore Family


__declspec(dllimport)
void
__stdcall
MapGenericMask(
     PDWORD AccessMask,
     PGENERIC_MAPPING GenericMapping
    );


__declspec(dllimport)
BOOL
__stdcall
ObjectCloseAuditAlarmW(
     LPCWSTR SubsystemName,
     LPVOID HandleId,
     BOOL GenerateOnClose
    );






__declspec(dllimport)
BOOL
__stdcall
ObjectDeleteAuditAlarmW(
     LPCWSTR SubsystemName,
     LPVOID HandleId,
     BOOL GenerateOnClose
    );






__declspec(dllimport)
BOOL
__stdcall
ObjectOpenAuditAlarmW(
     LPCWSTR SubsystemName,
     LPVOID HandleId,
     LPWSTR ObjectTypeName,
     LPWSTR ObjectName,
     PSECURITY_DESCRIPTOR pSecurityDescriptor,
     HANDLE ClientToken,
     DWORD DesiredAccess,
     DWORD GrantedAccess,
     PPRIVILEGE_SET Privileges,
     BOOL ObjectCreation,
     BOOL AccessGranted,
     LPBOOL GenerateOnClose
    );






__declspec(dllimport)
BOOL
__stdcall
ObjectPrivilegeAuditAlarmW(
     LPCWSTR SubsystemName,
     LPVOID HandleId,
     HANDLE ClientToken,
     DWORD DesiredAccess,
     PPRIVILEGE_SET Privileges,
     BOOL AccessGranted
    );






__declspec(dllimport)
BOOL
__stdcall
PrivilegeCheck(
     HANDLE ClientToken,
     PPRIVILEGE_SET RequiredPrivileges,
     LPBOOL pfResult
    );


__declspec(dllimport)
BOOL
__stdcall
PrivilegedServiceAuditAlarmW(
     LPCWSTR SubsystemName,
     LPCWSTR ServiceName,
     HANDLE ClientToken,
     PPRIVILEGE_SET Privileges,
     BOOL AccessGranted
    );








__declspec(dllimport)
void
__stdcall
QuerySecurityAccessMask(
     SECURITY_INFORMATION SecurityInformation,
     LPDWORD DesiredAccess
    );


#line 1278 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\securitybaseapi.h"

__declspec(dllimport)
BOOL
__stdcall
RevertToSelf(
    void
    );


__declspec(dllimport)
BOOL
__stdcall
SetAclInformation(
     PACL pAcl,
     LPVOID pAclInformation,
     DWORD nAclInformationLength,
     ACL_INFORMATION_CLASS dwAclInformationClass
    );


__declspec(dllimport)
BOOL
__stdcall
SetFileSecurityW(
     LPCWSTR lpFileName,
     SECURITY_INFORMATION SecurityInformation,
     PSECURITY_DESCRIPTOR pSecurityDescriptor
    );





#line 1312 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\securitybaseapi.h"
#pragma endregion

#pragma region Application Family or OneCore Family


__declspec(dllimport)
BOOL
__stdcall
SetKernelObjectSecurity(
     HANDLE Handle,
     SECURITY_INFORMATION SecurityInformation,
     PSECURITY_DESCRIPTOR SecurityDescriptor
    );


#line 1328 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\securitybaseapi.h"
#pragma endregion

#pragma region Desktop Family or OneCore Family


__declspec(dllimport)
BOOL
__stdcall
SetPrivateObjectSecurity(
     SECURITY_INFORMATION SecurityInformation,
     PSECURITY_DESCRIPTOR ModificationDescriptor,
     PSECURITY_DESCRIPTOR* ObjectsSecurityDescriptor,
     PGENERIC_MAPPING GenericMapping,
     HANDLE Token
    );


__declspec(dllimport)
BOOL
__stdcall
SetPrivateObjectSecurityEx(
     SECURITY_INFORMATION SecurityInformation,
     PSECURITY_DESCRIPTOR ModificationDescriptor,
     PSECURITY_DESCRIPTOR* ObjectsSecurityDescriptor,
     ULONG AutoInheritFlags,
     PGENERIC_MAPPING GenericMapping,
     HANDLE Token
    );




__declspec(dllimport)
void
__stdcall
SetSecurityAccessMask(
     SECURITY_INFORMATION SecurityInformation,
     LPDWORD DesiredAccess
    );


#line 1370 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\securitybaseapi.h"

#line 1372 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\securitybaseapi.h"
#pragma endregion

#pragma region Application Family or OneCore Family


__declspec(dllimport)
BOOL
__stdcall
SetSecurityDescriptorControl(
     PSECURITY_DESCRIPTOR pSecurityDescriptor,
     SECURITY_DESCRIPTOR_CONTROL ControlBitsOfInterest,
     SECURITY_DESCRIPTOR_CONTROL ControlBitsToSet
    );


__declspec(dllimport)
BOOL
__stdcall
SetSecurityDescriptorDacl(
     PSECURITY_DESCRIPTOR pSecurityDescriptor,
     BOOL bDaclPresent,
     PACL pDacl,
     BOOL bDaclDefaulted
    );


__declspec(dllimport)
BOOL
__stdcall
SetSecurityDescriptorGroup(
     PSECURITY_DESCRIPTOR pSecurityDescriptor,
     PSID pGroup,
     BOOL bGroupDefaulted
    );


__declspec(dllimport)
BOOL
__stdcall
SetSecurityDescriptorOwner(
     PSECURITY_DESCRIPTOR pSecurityDescriptor,
     PSID pOwner,
     BOOL bOwnerDefaulted
    );


__declspec(dllimport)
DWORD
__stdcall
SetSecurityDescriptorRMControl(
     PSECURITY_DESCRIPTOR SecurityDescriptor,
     PUCHAR RMControl
    );


__declspec(dllimport)
BOOL
__stdcall
SetSecurityDescriptorSacl(
     PSECURITY_DESCRIPTOR pSecurityDescriptor,
     BOOL bSaclPresent,
     PACL pSacl,
     BOOL bSaclDefaulted
    );


__declspec(dllimport)
BOOL
__stdcall
SetTokenInformation(
     HANDLE TokenHandle,
     TOKEN_INFORMATION_CLASS TokenInformationClass,
     LPVOID TokenInformation,
     DWORD TokenInformationLength
    );


#line 1450 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\securitybaseapi.h"
#pragma endregion

































#line 1485 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\securitybaseapi.h"
 
















#line 1503 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\securitybaseapi.h"
 



















#line 1524 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\securitybaseapi.h"
 

}
#line 1528 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\securitybaseapi.h"

#line 1530 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\securitybaseapi.h"
#line 66 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winbase.h"
#line 1 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\namespaceapi.h"
/********************************************************************************
*                                                                               *
* consoleapi.h -- ApiSet Contract for api-ms-win-core-namespace-l1              *
*                                                                               *
* Copyright (c) Microsoft Corporation. All rights reserved.                     *
*                                                                               *
********************************************************************************/


#pragma once
#line 12 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\namespaceapi.h"










extern "C" {
#line 24 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\namespaceapi.h"

#pragma region Desktop Family or OneCore Family




__declspec(dllimport)
HANDLE
__stdcall
CreatePrivateNamespaceW(
     LPSECURITY_ATTRIBUTES lpPrivateNamespaceAttributes,
     LPVOID lpBoundaryDescriptor,
     LPCWSTR lpAliasPrefix
    );


__declspec(dllimport)
HANDLE
__stdcall
OpenPrivateNamespaceW(
     LPVOID lpBoundaryDescriptor,
     LPCWSTR lpAliasPrefix
    );


__declspec(dllimport)
BOOLEAN
__stdcall
ClosePrivateNamespace(
     HANDLE Handle,
     ULONG Flags
    );


__declspec(dllimport)
HANDLE
__stdcall
CreateBoundaryDescriptorW(
     LPCWSTR Name,
     ULONG Flags
    );


__declspec(dllimport)
BOOL
__stdcall
AddSIDToBoundaryDescriptor(
     HANDLE* BoundaryDescriptor,
     PSID RequiredSid
    );


__declspec(dllimport)
void
__stdcall
DeleteBoundaryDescriptor(
     HANDLE BoundaryDescriptor
    );


#line 85 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\namespaceapi.h"
#pragma endregion


}
#line 90 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\namespaceapi.h"

#line 92 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\namespaceapi.h"
#line 67 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winbase.h"
#line 1 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\systemtopologyapi.h"
/********************************************************************************
*                                                                               *
* consoleapi.h -- ApiSet Contract for api-ms-win-core-systemtopology-l1         *
*                                                                               *
* Copyright (c) Microsoft Corporation. All rights reserved.                     *
*                                                                               *
********************************************************************************/


#pragma once
#line 12 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\systemtopologyapi.h"










extern "C" {
#line 24 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\systemtopologyapi.h"

#pragma region Desktop Family or OneCore Family


__declspec(dllimport)
BOOL
__stdcall
GetNumaHighestNodeNumber(
     PULONG HighestNodeNumber
    );




__declspec(dllimport)
BOOL
__stdcall
GetNumaNodeProcessorMaskEx(
     USHORT Node,
     PGROUP_AFFINITY ProcessorMask
    );


#line 48 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\systemtopologyapi.h"



__declspec(dllimport)
BOOL
__stdcall
GetNumaProximityNodeEx(
     ULONG ProximityId,
     PUSHORT NodeNumber
    );


#line 61 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\systemtopologyapi.h"

#line 63 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\systemtopologyapi.h"
#pragma endregion


}
#line 68 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\systemtopologyapi.h"

#line 70 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\systemtopologyapi.h"
#line 68 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winbase.h"
#line 1 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\processtopologyapi.h"
/********************************************************************************
*                                                                               *
* processtopologyapi.h -- ApiSet Contract for api-ms-win-core-processtopology-l1 *
*                                                                               *
* Copyright (c) Microsoft Corporation. All rights reserved.                     *
*                                                                               *
********************************************************************************/


#pragma once
#line 12 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\processtopologyapi.h"










extern "C" {
#line 24 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\processtopologyapi.h"

#pragma region Desktop Family or OneCore Family




__declspec(dllimport)
BOOL
__stdcall
GetProcessGroupAffinity(
     HANDLE hProcess,
     PUSHORT GroupCount,
     PUSHORT GroupArray
    );


#line 41 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\processtopologyapi.h"

#line 43 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\processtopologyapi.h"
#pragma endregion


#pragma region Desktop Family or OneCore Family




__declspec(dllimport)
BOOL
__stdcall
GetThreadGroupAffinity(
     HANDLE hThread,
     PGROUP_AFFINITY GroupAffinity
    );


__declspec(dllimport)
BOOL
__stdcall
SetThreadGroupAffinity(
     HANDLE hThread,
     const GROUP_AFFINITY* GroupAffinity,
     PGROUP_AFFINITY PreviousGroupAffinity
    );


#line 71 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\processtopologyapi.h"

#line 73 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\processtopologyapi.h"
#pragma endregion


}
#line 78 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\processtopologyapi.h"

#line 80 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\processtopologyapi.h"
#line 69 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winbase.h"
#line 1 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\securityappcontainer.h"
/********************************************************************************
*                                                                               *
* securityappcontainer.h -- ApiSet Contract for api-ms-win-security-appcontainer-l1 *
*                                                                               *
* Copyright (c) Microsoft Corporation. All rights reserved.                     *
*                                                                               *
********************************************************************************/


#pragma once
#line 12 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\securityappcontainer.h"











#pragma region Desktop Family or OneCore Family



extern "C" {
#line 29 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\securityappcontainer.h"


















#line 48 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\securityappcontainer.h"


}
#line 52 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\securityappcontainer.h"

#line 54 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\securityappcontainer.h"
#pragma endregion

#line 57 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\securityappcontainer.h"
#line 70 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winbase.h"
#line 1 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\realtimeapiset.h"
/********************************************************************************
*                                                                               *
* realtimeapi.h -- ApiSet Contract for api-ms-win-core-realtime-l1              *
*                                                                               *
* Copyright (c) Microsoft Corporation. All rights reserved.                     *
*                                                                               *
********************************************************************************/


#pragma once
#line 12 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\realtimeapiset.h"









extern "C" {
#line 23 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\realtimeapiset.h"

#pragma region Desktop Family or OneCore Family




__declspec(dllimport)
BOOL
__stdcall
QueryThreadCycleTime(
     HANDLE ThreadHandle,
     PULONG64 CycleTime
    );


__declspec(dllimport)
BOOL
__stdcall
QueryProcessCycleTime(
     HANDLE ProcessHandle,
     PULONG64 CycleTime
    );


__declspec(dllimport)
BOOL
__stdcall
QueryIdleProcessorCycleTime(
     PULONG BufferLength,
     PULONG64 ProcessorIdleCycleTime
    );


#line 57 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\realtimeapiset.h"



__declspec(dllimport)
BOOL
__stdcall
QueryIdleProcessorCycleTimeEx(
     USHORT Group,
     PULONG BufferLength,
     PULONG64 ProcessorIdleCycleTime
    );

    
#line 71 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\realtimeapiset.h"

#line 73 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\realtimeapiset.h"
#pragma endregion

#pragma region Application Family or OneCore Family


__declspec(dllimport)
void
__stdcall
QueryInterruptTimePrecise(
     PULONGLONG lpInterruptTimePrecise
    );


__declspec(dllimport)
void
__stdcall
QueryUnbiasedInterruptTimePrecise(
     PULONGLONG lpUnbiasedInterruptTimePrecise
    );


__declspec(dllimport)
void
__stdcall
QueryInterruptTime(
     PULONGLONG lpInterruptTime
    );




__declspec(dllimport)
BOOL
__stdcall
QueryUnbiasedInterruptTime(
     PULONGLONG UnbiasedTime
    );


#line 113 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\realtimeapiset.h"

__declspec(dllimport)
HRESULT
__stdcall
QueryAuxiliaryCounterFrequency(
     PULONGLONG lpAuxiliaryCounterFrequency
    );


__declspec(dllimport)
HRESULT
__stdcall
ConvertAuxiliaryCounterToPerformanceCounter(
     ULONGLONG ullAuxiliaryCounterValue,
     PULONGLONG lpPerformanceCounterValue,
     PULONGLONG lpConversionError
    );


__declspec(dllimport)
HRESULT
__stdcall
ConvertPerformanceCounterToAuxiliaryCounter(
     ULONGLONG ullPerformanceCounterValue,
     PULONGLONG lpAuxiliaryCounterValue,
     PULONGLONG lpConversionError
    );


#line 143 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\realtimeapiset.h"
#pragma endregion


}
#line 148 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\realtimeapiset.h"

#line 150 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\realtimeapiset.h"
#line 71 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winbase.h"


extern "C" {
#line 75 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winbase.h"

#pragma region Application Family


/*
 * Compatibility macros
 */







#line 90 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winbase.h"
#pragma endregion

#pragma region Desktop Family




#line 98 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winbase.h"
#pragma endregion

#pragma region Application Family or OneCore Family


















#line 120 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winbase.h"
#pragma endregion

#pragma region Application Family or OneCore Family or Games Family




#line 128 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winbase.h"
#pragma endregion

#pragma region Application Family


//
// File creation flags must start at the high end since they
// are combined with the attributes
//

//
//  These are flags supported through CreateFile (W7) and CreateFile2 (W8 and beyond)
//



























#line 169 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winbase.h"




//
// Define possible return codes from the CopyFileEx callback routine
//






//
// Define CopyFileEx callback routine state change values
//




//
// Define CopyFileEx option flags
//






//
//  Gap for private copyfile flags
//




#line 206 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winbase.h"














#line 221 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winbase.h"













#line 235 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winbase.h"

#line 237 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winbase.h"


//
// Define ReplaceFile option flags
//






#line 249 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winbase.h"

#line 251 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winbase.h"

//
// Define the NamedPipe definitions
//


//
// Define the dwOpenMode values for CreateNamedPipe
//





//
// Define the Named Pipe End flags for GetNamedPipeInfo
//




//
// Define the dwPipeMode values for CreateNamedPipe
//










//
// Define the well known values for CreateNamedPipe nMaxInstances
//



//
// Define the Security Quality of Service bits to be passed
// into CreateFile
//













//
// Fiber structures
//


typedef void (__stdcall *PFIBER_START_ROUTINE)(
    LPVOID lpFiberParameter
    );
typedef PFIBER_START_ROUTINE LPFIBER_START_ROUTINE;

typedef LPVOID (__stdcall *PFIBER_CALLOUT_ROUTINE)(
    LPVOID lpParameter
    );
#line 322 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winbase.h"

//
// FailFast Exception Flags
//






#line 333 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winbase.h"
typedef LPVOID LPLDT_ENTRY;
#line 335 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winbase.h"

//
// Serial provider type.
//



//
// Provider SubTypes
//















//
// Provider capabilities flags.
//












//
// Comm provider settable parameters.
//









//
// Settable baud rates in the provider.
//






















//
// Settable Data Bits
//








//
// Settable Stop and Parity bits.
//










typedef struct _COMMPROP {
    WORD wPacketLength;
    WORD wPacketVersion;
    DWORD dwServiceMask;
    DWORD dwReserved1;
    DWORD dwMaxTxQueue;
    DWORD dwMaxRxQueue;
    DWORD dwMaxBaud;
    DWORD dwProvSubType;
    DWORD dwProvCapabilities;
    DWORD dwSettableParams;
    DWORD dwSettableBaud;
    WORD wSettableData;
    WORD wSettableStopParity;
    DWORD dwCurrentTxQueue;
    DWORD dwCurrentRxQueue;
    DWORD dwProvSpec1;
    DWORD dwProvSpec2;
    WCHAR wcProvChar[1];
} COMMPROP,*LPCOMMPROP;

//
// Set dwProvSpec1 to COMMPROP_INITIALIZED to indicate that wPacketLength
// is valid before a call to GetCommProperties().
//


typedef struct _COMSTAT {
    DWORD fCtsHold : 1;
    DWORD fDsrHold : 1;
    DWORD fRlsdHold : 1;
    DWORD fXoffHold : 1;
    DWORD fXoffSent : 1;
    DWORD fEof : 1;
    DWORD fTxim : 1;
    DWORD fReserved : 25;
    DWORD cbInQue;
    DWORD cbOutQue;
} COMSTAT, *LPCOMSTAT;

//
// DTR Control Flow Values.
//




//
// RTS Control Flow Values
//





typedef struct _DCB {
    DWORD DCBlength;      /* sizeof(DCB)                     */
    DWORD BaudRate;       /* Baudrate at which running       */
    DWORD fBinary: 1;     /* Binary Mode (skip EOF check)    */
    DWORD fParity: 1;     /* Enable parity checking          */
    DWORD fOutxCtsFlow:1; /* CTS handshaking on output       */
    DWORD fOutxDsrFlow:1; /* DSR handshaking on output       */
    DWORD fDtrControl:2;  /* DTR Flow control                */
    DWORD fDsrSensitivity:1; /* DSR Sensitivity              */
    DWORD fTXContinueOnXoff: 1; /* Continue TX when Xoff sent */
    DWORD fOutX: 1;       /* Enable output X-ON/X-OFF        */
    DWORD fInX: 1;        /* Enable input X-ON/X-OFF         */
    DWORD fErrorChar: 1;  /* Enable Err Replacement          */
    DWORD fNull: 1;       /* Enable Null stripping           */
    DWORD fRtsControl:2;  /* Rts Flow control                */
    DWORD fAbortOnError:1; /* Abort all reads and writes on Error */
    DWORD fDummy2:17;     /* Reserved                        */
    WORD wReserved;       /* Not currently used              */
    WORD XonLim;          /* Transmit X-ON threshold         */
    WORD XoffLim;         /* Transmit X-OFF threshold        */
    BYTE ByteSize;        /* Number of bits/byte, 4-8        */
    BYTE Parity;          /* 0-4=None,Odd,Even,Mark,Space    */
    BYTE StopBits;        /* 0,1,2 = 1, 1.5, 2               */
    char XonChar;         /* Tx and Rx X-ON character        */
    char XoffChar;        /* Tx and Rx X-OFF character       */
    char ErrorChar;       /* Error replacement char          */
    char EofChar;         /* End of Input character          */
    char EvtChar;         /* Received Event character        */
    WORD wReserved1;      /* Fill for now.                   */
} DCB, *LPDCB;

typedef struct _COMMTIMEOUTS {
    DWORD ReadIntervalTimeout;          /* Maximum time between read chars. */
    DWORD ReadTotalTimeoutMultiplier;   /* Multiplier of characters.        */
    DWORD ReadTotalTimeoutConstant;     /* Constant in milliseconds.        */
    DWORD WriteTotalTimeoutMultiplier;  /* Multiplier of characters.        */
    DWORD WriteTotalTimeoutConstant;    /* Constant in milliseconds.        */
} COMMTIMEOUTS,*LPCOMMTIMEOUTS;

typedef struct _COMMCONFIG {
    DWORD dwSize;               /* Size of the entire struct */
    WORD wVersion;              /* version of the structure */
    WORD wReserved;             /* alignment */
    DCB dcb;                    /* device control block */
    DWORD dwProviderSubType;    /* ordinal value for identifying
                                   provider-defined data structure format*/
    DWORD dwProviderOffset;     /* Specifies the offset of provider specific
                                   data field in bytes from the start */
    DWORD dwProviderSize;       /* size of the provider-specific data field */
    WCHAR wcProviderData[1];    /* provider-specific data */
} COMMCONFIG,*LPCOMMCONFIG;

//
//






/* Global Memory Flags */






















/* Flags returned by GlobalFlags (in addition to GMEM_DISCARDABLE) */



typedef struct _MEMORYSTATUS {
    DWORD dwLength;
    DWORD dwMemoryLoad;
    SIZE_T dwTotalPhys;
    SIZE_T dwAvailPhys;
    SIZE_T dwTotalPageFile;
    SIZE_T dwAvailPageFile;
    SIZE_T dwTotalVirtual;
    SIZE_T dwAvailVirtual;
} MEMORYSTATUS, *LPMEMORYSTATUS;

//
// Process dwCreationFlag values
//








































//
// Thread dwCreationFlag values
//

//#define CREATE_SUSPENDED                  0x00000004



//
// Priority flags
//














//
// GetFinalPathNameByHandle
//









//
// JIT Debugging Info. This structure is defined to have constant size in
// both the emulated and native environment.
//

typedef struct _JIT_DEBUG_INFO {
    DWORD dwSize;
    DWORD dwProcessorArchitecture;
    DWORD dwThreadID;
    DWORD dwReserved0;
    ULONG64 lpExceptionAddress;
    ULONG64 lpExceptionRecord;
    ULONG64 lpContextRecord;
} JIT_DEBUG_INFO, *LPJIT_DEBUG_INFO;

typedef JIT_DEBUG_INFO JIT_DEBUG_INFO32, *LPJIT_DEBUG_INFO32;
typedef JIT_DEBUG_INFO JIT_DEBUG_INFO64, *LPJIT_DEBUG_INFO64;


typedef PEXCEPTION_RECORD LPEXCEPTION_RECORD;
typedef PEXCEPTION_POINTERS LPEXCEPTION_POINTERS;
#line 691 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winbase.h"














#line 706 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winbase.h"


























//
// Baud rates at which the communication device operates
//

















//
// Error Flags
//






















//
// Events
//















//
// Escape Functions
//











//
// PURGE function flags.
//







//
// Modem Status Flags
//





//
// WaitSoundState() Constants
//





//
// Accent Modes
//





//
// SetSoundNoise() Sources
//

























































typedef struct _OFSTRUCT {
    BYTE cBytes;
    BYTE fFixedDisk;
    WORD nErrCode;
    WORD Reserved1;
    WORD Reserved2;
    CHAR szPathName[128 ];
} OFSTRUCT, *LPOFSTRUCT, *POFSTRUCT;






#line 918 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winbase.h"
#pragma endregion

#pragma region Desktop Family


int



#line 928 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winbase.h"
__stdcall
#line 930 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winbase.h"


#line 933 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winbase.h"
WinMain (
     HINSTANCE hInstance,
     HINSTANCE hPrevInstance,
     LPSTR lpCmdLine,
     int nShowCmd
    );

int


#line 944 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winbase.h"
__stdcall
#line 946 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winbase.h"
wWinMain(
     HINSTANCE hInstance,
     HINSTANCE hPrevInstance,
     LPWSTR lpCmdLine,
     int nShowCmd
    );

#line 954 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winbase.h"
#pragma endregion

#pragma region Application Family or OneCore Family


__declspec(dllimport)


__declspec(allocator)
HGLOBAL
__stdcall
GlobalAlloc(
     UINT uFlags,
     SIZE_T dwBytes
    );

#line 971 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winbase.h"
#pragma endregion

#pragma region Application Family


__declspec(dllimport)

__declspec(allocator)
HGLOBAL
__stdcall
GlobalReAlloc (
     HGLOBAL hMem,
     SIZE_T dwBytes,
     UINT uFlags
    );

#line 988 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winbase.h"
#pragma endregion

#pragma region Application Family or OneCore Family


__declspec(dllimport)
SIZE_T
__stdcall
GlobalSize (
     HGLOBAL hMem
    );

__declspec(dllimport)
BOOL
__stdcall
GlobalUnlock(
     HGLOBAL hMem
    );

__declspec(dllimport)

LPVOID
__stdcall
GlobalLock (
     HGLOBAL hMem
    );

#line 1016 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winbase.h"
#pragma endregion

#pragma region Desktop Family


__declspec(dllimport)
UINT
__stdcall
GlobalFlags (
     HGLOBAL hMem
    );

__declspec(dllimport)

HGLOBAL
__stdcall
GlobalHandle (
     LPCVOID pMem
    );

#line 1037 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winbase.h"
#pragma endregion

#pragma region Application Family or OneCore Family


__declspec(dllimport)


HGLOBAL
__stdcall
GlobalFree(
     HGLOBAL hMem
    );

#line 1052 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winbase.h"
#pragma endregion

#pragma region Desktop Family


__declspec(dllimport)
SIZE_T
__stdcall
GlobalCompact(
     DWORD dwMinFree
    );

__declspec(dllimport)
void
__stdcall
GlobalFix(
     HGLOBAL hMem
    );

__declspec(dllimport)
void
__stdcall
GlobalUnfix(
     HGLOBAL hMem
    );

__declspec(dllimport)
LPVOID
__stdcall
GlobalWire(
     HGLOBAL hMem
    );

__declspec(dllimport)
BOOL
__stdcall
GlobalUnWire(
     HGLOBAL hMem
    );


__declspec(dllimport)
void
__stdcall
GlobalMemoryStatus(
     LPMEMORYSTATUS lpBuffer
    );

#line 1101 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winbase.h"
#pragma endregion

#pragma region Application Family or OneCore Family


__declspec(dllimport)


__declspec(allocator)
HLOCAL
__stdcall
LocalAlloc(
     UINT uFlags,
     SIZE_T uBytes
    );

__declspec(dllimport)

__declspec(allocator)
HLOCAL
__stdcall
LocalReAlloc(
     HLOCAL hMem,
     SIZE_T uBytes,
     UINT uFlags
    );

#line 1129 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winbase.h"
#pragma endregion

#pragma region Desktop Family or OneCore Family


__declspec(dllimport)

LPVOID
__stdcall
LocalLock(
     HLOCAL hMem
    );

#line 1143 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winbase.h"
#pragma endregion

#pragma region Desktop Family


__declspec(dllimport)

HLOCAL
__stdcall
LocalHandle(
     LPCVOID pMem
    );

#line 1157 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winbase.h"
#pragma endregion

#pragma region Desktop Family or OneCore Family


__declspec(dllimport)
BOOL
__stdcall
LocalUnlock(
     HLOCAL hMem
    );

#line 1170 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winbase.h"
#pragma endregion

#pragma region Desktop Family


__declspec(dllimport)
SIZE_T
__stdcall
LocalSize(
     HLOCAL hMem
    );

__declspec(dllimport)
UINT
__stdcall
LocalFlags(
     HLOCAL hMem
    );

#line 1190 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winbase.h"
#pragma endregion

#pragma region Application Family or OneCore Family


__declspec(dllimport)


HLOCAL
__stdcall
LocalFree(
     HLOCAL hMem
    );

#line 1205 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winbase.h"
#pragma endregion

#pragma region Desktop Family


__declspec(dllimport)
SIZE_T
__stdcall
LocalShrink(
     HLOCAL hMem,
     UINT cbNewSize
    );

__declspec(dllimport)
SIZE_T
__stdcall
LocalCompact(
     UINT uMinFree
    );

// GetBinaryType return values.













#line 1240 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winbase.h"

__declspec(dllimport)
BOOL
__stdcall
GetBinaryTypeA(
      LPCSTR lpApplicationName,
     LPDWORD  lpBinaryType
    );
__declspec(dllimport)
BOOL
__stdcall
GetBinaryTypeW(
      LPCWSTR lpApplicationName,
     LPDWORD  lpBinaryType
    );




#line 1260 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winbase.h"

__declspec(dllimport)

DWORD
__stdcall
GetShortPathNameA(
     LPCSTR lpszLongPath,
     LPSTR  lpszShortPath,
     DWORD cchBuffer
    );


#line 1273 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winbase.h"



__declspec(dllimport)

DWORD
__stdcall
GetLongPathNameTransactedA(
         LPCSTR lpszShortPath,
     LPSTR  lpszLongPath,
         DWORD cchBuffer,
         HANDLE hTransaction
    );
__declspec(dllimport)

DWORD
__stdcall
GetLongPathNameTransactedW(
         LPCWSTR lpszShortPath,
     LPWSTR  lpszLongPath,
         DWORD cchBuffer,
         HANDLE hTransaction
    );




#line 1301 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winbase.h"

#line 1303 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winbase.h"

#line 1305 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winbase.h"
#pragma endregion

#pragma region Application Family or OneCore Family


__declspec(dllimport)
BOOL
__stdcall
GetProcessAffinityMask(
      HANDLE hProcess,
     PDWORD_PTR lpProcessAffinityMask,
     PDWORD_PTR lpSystemAffinityMask
    );

__declspec(dllimport)
BOOL
__stdcall
SetProcessAffinityMask(
     HANDLE hProcess,
     DWORD_PTR dwProcessAffinityMask
    );

#line 1328 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winbase.h"
#pragma endregion

#pragma region Desktop Family


__declspec(dllimport)
BOOL
__stdcall
GetProcessIoCounters(
      HANDLE hProcess,
     PIO_COUNTERS lpIoCounters
    );

#line 1342 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winbase.h"
#pragma endregion

#pragma region Application Family or OneCore Family


__declspec(dllimport)
BOOL
__stdcall
GetProcessWorkingSetSize(
      HANDLE hProcess,
     PSIZE_T lpMinimumWorkingSetSize,
     PSIZE_T lpMaximumWorkingSetSize
    );

#line 1357 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winbase.h"
#pragma endregion

#pragma region Desktop Family


__declspec(dllimport)
BOOL
__stdcall
SetProcessWorkingSetSize(
     HANDLE hProcess,
     SIZE_T dwMinimumWorkingSetSize,
     SIZE_T dwMaximumWorkingSetSize
    );

__declspec(dllimport)

void
__stdcall
FatalExit(
     int ExitCode
    );

#line 1380 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winbase.h"
#pragma endregion

#pragma region Desktop Family or OneCore Family


__declspec(dllimport)
BOOL
__stdcall
SetEnvironmentStringsA(
       LPCH NewEnvironment
    );


#line 1394 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winbase.h"

#line 1396 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winbase.h"
#pragma endregion



//
// Fiber begin
//

#pragma region Application Family or OneCore Family




__declspec(dllimport)
void
__stdcall
SwitchToFiber(
     LPVOID lpFiber
    );

__declspec(dllimport)
void
__stdcall
DeleteFiber(
     LPVOID lpFiber
    );



__declspec(dllimport)
BOOL
__stdcall
ConvertFiberToThread(
    void
    );

#line 1433 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winbase.h"

__declspec(dllimport)

LPVOID
__stdcall
CreateFiberEx(
         SIZE_T dwStackCommitSize,
         SIZE_T dwStackReserveSize,
         DWORD dwFlags,
         LPFIBER_START_ROUTINE lpStartAddress,
     LPVOID lpParameter
    );

__declspec(dllimport)

LPVOID
__stdcall
ConvertThreadToFiberEx(
     LPVOID lpParameter,
         DWORD dwFlags
    );

#line 1456 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winbase.h"
#pragma endregion

#pragma region Desktop Family or OneCore Family


__declspec(dllimport)

LPVOID
__stdcall
CreateFiber(
         SIZE_T dwStackSize,
         LPFIBER_START_ROUTINE lpStartAddress,
     LPVOID lpParameter
    );

__declspec(dllimport)

LPVOID
__stdcall
ConvertThreadToFiber(
     LPVOID lpParameter
    );

#line 1480 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winbase.h"
#pragma endregion

//
// Fiber end
//

//
// UMS begin
//

#pragma region Desktop Family






typedef void *PUMS_CONTEXT;

typedef void *PUMS_COMPLETION_LIST;

typedef enum _RTL_UMS_THREAD_INFO_CLASS UMS_THREAD_INFO_CLASS, *PUMS_THREAD_INFO_CLASS;

typedef enum _RTL_UMS_SCHEDULER_REASON UMS_SCHEDULER_REASON;

typedef PRTL_UMS_SCHEDULER_ENTRY_POINT PUMS_SCHEDULER_ENTRY_POINT;

typedef struct _UMS_SCHEDULER_STARTUP_INFO {

    //
    // UMS Version the application was built to. Should be set to UMS_VERSION
    //
    ULONG UmsVersion;

    //
    // Completion List to associate the new User Scheduler to.
    //
    PUMS_COMPLETION_LIST CompletionList;

    //
    // A pointer to the application-defined function that represents the starting
    // address of the Sheduler.
    //
    PUMS_SCHEDULER_ENTRY_POINT SchedulerProc;

    //
    // pointer to a variable to be passed to the scheduler uppon first activation.
    //
    PVOID SchedulerParam;

} UMS_SCHEDULER_STARTUP_INFO, *PUMS_SCHEDULER_STARTUP_INFO;

typedef struct _UMS_SYSTEM_THREAD_INFORMATION {
    ULONG UmsVersion;
    union {
        struct {
            ULONG IsUmsSchedulerThread : 1;
            ULONG IsUmsWorkerThread : 1;
        }  ;
        ULONG ThreadUmsFlags;
    }  ;
} UMS_SYSTEM_THREAD_INFORMATION, *PUMS_SYSTEM_THREAD_INFORMATION;


__declspec(dllimport)
BOOL
__stdcall
CreateUmsCompletionList(
     PUMS_COMPLETION_LIST* UmsCompletionList
    );

__declspec(dllimport)
BOOL
__stdcall
DequeueUmsCompletionListItems(
     PUMS_COMPLETION_LIST UmsCompletionList,
     DWORD WaitTimeOut,
     PUMS_CONTEXT* UmsThreadList
    );

__declspec(dllimport)
BOOL
__stdcall
GetUmsCompletionListEvent(
     PUMS_COMPLETION_LIST UmsCompletionList,
     PHANDLE UmsCompletionEvent
    );

__declspec(dllimport)
BOOL
__stdcall
ExecuteUmsThread(
     PUMS_CONTEXT UmsThread
    );

__declspec(dllimport)
BOOL
__stdcall
UmsThreadYield(
     PVOID SchedulerParam
    );

__declspec(dllimport)
BOOL
__stdcall
DeleteUmsCompletionList(
     PUMS_COMPLETION_LIST UmsCompletionList
    );

__declspec(dllimport)
PUMS_CONTEXT
__stdcall
GetCurrentUmsThread(
    void
    );

__declspec(dllimport)
PUMS_CONTEXT
__stdcall
GetNextUmsListItem(
     PUMS_CONTEXT UmsContext
    );

__declspec(dllimport)
BOOL
__stdcall
QueryUmsThreadInformation(
     PUMS_CONTEXT UmsThread,
     UMS_THREAD_INFO_CLASS UmsThreadInfoClass,
     PVOID UmsThreadInformation,
     ULONG UmsThreadInformationLength,
     PULONG ReturnLength
    );

__declspec(dllimport)
BOOL
__stdcall
SetUmsThreadInformation(
     PUMS_CONTEXT UmsThread,
     UMS_THREAD_INFO_CLASS UmsThreadInfoClass,
     PVOID UmsThreadInformation,
     ULONG UmsThreadInformationLength
    );

__declspec(dllimport)
BOOL
__stdcall
DeleteUmsThreadContext(
     PUMS_CONTEXT UmsThread
    );

__declspec(dllimport)
BOOL
__stdcall
CreateUmsThreadContext(
     PUMS_CONTEXT *lpUmsThread
    );

__declspec(dllimport)
BOOL
__stdcall
EnterUmsSchedulingMode(
     PUMS_SCHEDULER_STARTUP_INFO SchedulerStartupInfo
    );

__declspec(dllimport)
BOOL
__stdcall
GetUmsSystemThreadInformation(
     HANDLE ThreadHandle,
     PUMS_SYSTEM_THREAD_INFORMATION SystemThreadInfo
    );

#line 1654 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winbase.h"

#line 1656 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winbase.h"
#pragma endregion

//
// UMS end
//

#line 1663 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winbase.h"

#pragma region Application Family or OneCore Family


__declspec(dllimport)
DWORD_PTR
__stdcall
SetThreadAffinityMask(
     HANDLE hThread,
     DWORD_PTR dwThreadAffinityMask
    );

#line 1676 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winbase.h"
#pragma endregion

#pragma region Desktop Family







__declspec(dllimport)
BOOL
__stdcall
SetProcessDEPPolicy(
     DWORD dwFlags
    );

__declspec(dllimport)
BOOL
__stdcall
GetProcessDEPPolicy(
     HANDLE hProcess,
     LPDWORD lpFlags,
     PBOOL lpPermanent
    );

#line 1703 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winbase.h"

__declspec(dllimport)
BOOL
__stdcall
RequestWakeupLatency(
     LATENCY_TIME latency
    );

__declspec(dllimport)
BOOL
__stdcall
IsSystemResumeAutomatic(
    void
    );

__declspec(dllimport)
BOOL
__stdcall
GetThreadSelectorEntry(
      HANDLE hThread,
      DWORD dwSelector,
     LPLDT_ENTRY lpSelectorEntry
    );

__declspec(dllimport)
EXECUTION_STATE
__stdcall
SetThreadExecutionState(
     EXECUTION_STATE esFlags
    );



//
// Power Request APIs
//

typedef REASON_CONTEXT POWER_REQUEST_CONTEXT, *PPOWER_REQUEST_CONTEXT, *LPPOWER_REQUEST_CONTEXT;

__declspec(dllimport)
HANDLE
__stdcall
PowerCreateRequest (
     PREASON_CONTEXT Context
    );

__declspec(dllimport)
BOOL
__stdcall
PowerSetRequest (
     HANDLE PowerRequest,
     POWER_REQUEST_TYPE RequestType
    );

__declspec(dllimport)
BOOL
__stdcall
PowerClearRequest (
     HANDLE PowerRequest,
     POWER_REQUEST_TYPE RequestType
    );

#line 1766 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winbase.h"

#line 1768 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winbase.h"
#pragma endregion

#pragma region Application Family






#line 1778 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winbase.h"
#pragma endregion

#pragma region Desktop or Games Family



//#if _WIN32_WINNT >= 0x0501 || defined(WINBASE_DECLARE_RESTORE_LAST_ERROR)














#line 1800 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winbase.h"
#line 1801 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winbase.h"



#line 1805 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winbase.h"
#pragma endregion

#pragma region Application Family or OneCore Family




//
// The following flags allows an application to change
// the semantics of IO completion notification.
//

//
// Don't queue an entry to an associated completion port if returning success
// synchronously.
//


//
// Don't set the file handle event on IO completion.
//


__declspec(dllimport)
BOOL
__stdcall
SetFileCompletionNotificationModes(
     HANDLE FileHandle,
     UCHAR Flags
    );

#line 1837 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winbase.h"

#line 1839 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winbase.h"
#pragma endregion

#pragma region Desktop Family











__declspec(dllimport)
BOOL
__stdcall
Wow64GetThreadContext(
        HANDLE hThread,
     PWOW64_CONTEXT lpContext
    );

__declspec(dllimport)
BOOL
__stdcall
Wow64SetThreadContext(
     HANDLE hThread,
     const WOW64_CONTEXT *lpContext
    );

#line 1870 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winbase.h"



__declspec(dllimport)
BOOL
__stdcall
Wow64GetThreadSelectorEntry(
     HANDLE hThread,
     DWORD dwSelector,
     PWOW64_LDT_ENTRY lpSelectorEntry
    );

#line 1883 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winbase.h"

#line 1885 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winbase.h"



__declspec(dllimport)
DWORD
__stdcall
Wow64SuspendThread(
     HANDLE hThread
    );

#line 1896 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winbase.h"

__declspec(dllimport)
BOOL
__stdcall
DebugSetProcessKillOnExit(
     BOOL KillOnExit
    );

__declspec(dllimport)
BOOL
__stdcall
DebugBreakProcess (
     HANDLE Process
    );

#line 1912 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winbase.h"
#pragma endregion

#pragma region Application Family




#line 1920 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winbase.h"

#line 1922 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winbase.h"
#pragma endregion

#pragma region Desktop Family


__declspec(dllimport)
BOOL
__stdcall
PulseEvent(
     HANDLE hEvent
    );

__declspec(dllimport)
ATOM
__stdcall
GlobalDeleteAtom(
     ATOM nAtom
    );

__declspec(dllimport)
BOOL
__stdcall
InitAtomTable(
     DWORD nSize
    );

__declspec(dllimport)
ATOM
__stdcall
DeleteAtom(
     ATOM nAtom
    );

__declspec(dllimport)
UINT
__stdcall
SetHandleCount(
     UINT uNumber
    );

__declspec(dllimport)
BOOL
__stdcall
RequestDeviceWakeup(
     HANDLE hDevice
    );

__declspec(dllimport)
BOOL
__stdcall
CancelDeviceWakeupRequest(
     HANDLE hDevice
    );

__declspec(dllimport)
BOOL
__stdcall
GetDevicePowerState(
      HANDLE hDevice,
     BOOL *pfOn
    );

__declspec(dllimport)
BOOL
__stdcall
SetMessageWaitingIndicator(
     HANDLE hMsgIndicator,
     ULONG ulMsgCount
    );


__declspec(dllimport)
BOOL
__stdcall
SetFileShortNameA(
     HANDLE hFile,
     LPCSTR lpShortName
    );
__declspec(dllimport)
BOOL
__stdcall
SetFileShortNameW(
     HANDLE hFile,
     LPCWSTR lpShortName
    );




#line 2012 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winbase.h"






__declspec(dllimport)
DWORD
__stdcall
LoadModule(
     LPCSTR lpModuleName,
     LPVOID lpParameterBlock
    );



__declspec(dllimport)
UINT
__stdcall
WinExec(
     LPCSTR lpCmdLine,
     UINT uCmdShow
    );


#line 2038 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winbase.h"
#pragma endregion

#pragma region Desktop Family or OneCore or App Family


__declspec(dllimport)
BOOL
__stdcall
ClearCommBreak(
     HANDLE hFile
    );

__declspec(dllimport)
BOOL
__stdcall
ClearCommError(
          HANDLE hFile,
     LPDWORD lpErrors,
     LPCOMSTAT lpStat
    );

__declspec(dllimport)
BOOL
__stdcall
SetupComm(
     HANDLE hFile,
     DWORD dwInQueue,
     DWORD dwOutQueue
    );

__declspec(dllimport)
BOOL
__stdcall
EscapeCommFunction(
     HANDLE hFile,
     DWORD dwFunc
    );

__declspec(dllimport)

BOOL
__stdcall
GetCommConfig(
          HANDLE hCommDev,
     LPCOMMCONFIG lpCC,
       LPDWORD lpdwSize
    );

__declspec(dllimport)
BOOL
__stdcall
GetCommMask(
      HANDLE hFile,
     LPDWORD lpEvtMask
    );

__declspec(dllimport)
BOOL
__stdcall
GetCommProperties(
        HANDLE hFile,
     LPCOMMPROP lpCommProp
    );

__declspec(dllimport)
BOOL
__stdcall
GetCommModemStatus(
      HANDLE hFile,
     LPDWORD lpModemStat
    );

__declspec(dllimport)
BOOL
__stdcall
GetCommState(
      HANDLE hFile,
     LPDCB lpDCB
    );

__declspec(dllimport)
BOOL
__stdcall
GetCommTimeouts(
      HANDLE hFile,
     LPCOMMTIMEOUTS lpCommTimeouts
    );

__declspec(dllimport)
BOOL
__stdcall
PurgeComm(
     HANDLE hFile,
     DWORD dwFlags
    );

__declspec(dllimport)
BOOL
__stdcall
SetCommBreak(
     HANDLE hFile
    );

__declspec(dllimport)
BOOL
__stdcall
SetCommConfig(
     HANDLE hCommDev,
     LPCOMMCONFIG lpCC,
     DWORD dwSize
    );

__declspec(dllimport)
BOOL
__stdcall
SetCommMask(
     HANDLE hFile,
     DWORD dwEvtMask
    );

__declspec(dllimport)
BOOL
__stdcall
SetCommState(
     HANDLE hFile,
     LPDCB lpDCB
    );

__declspec(dllimport)
BOOL
__stdcall
SetCommTimeouts(
     HANDLE hFile,
     LPCOMMTIMEOUTS lpCommTimeouts
    );

__declspec(dllimport)
BOOL
__stdcall
TransmitCommChar(
     HANDLE hFile,
     char cChar
    );

__declspec(dllimport)
BOOL
__stdcall
WaitCommEvent(
            HANDLE hFile,
         LPDWORD lpEvtMask,
     LPOVERLAPPED lpOverlapped
    );













#line 2204 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winbase.h"












#line 2217 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winbase.h"

#line 2219 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winbase.h"
#pragma endregion

#pragma region Desktop Family


__declspec(dllimport)
DWORD
__stdcall
SetTapePosition(
     HANDLE hDevice,
     DWORD dwPositionMethod,
     DWORD dwPartition,
     DWORD dwOffsetLow,
     DWORD dwOffsetHigh,
     BOOL bImmediate
    );

__declspec(dllimport)
DWORD
__stdcall
GetTapePosition(
      HANDLE hDevice,
      DWORD dwPositionType,
     LPDWORD lpdwPartition,
     LPDWORD lpdwOffsetLow,
     LPDWORD lpdwOffsetHigh
    );

__declspec(dllimport)
DWORD
__stdcall
PrepareTape(
     HANDLE hDevice,
     DWORD dwOperation,
     BOOL bImmediate
    );

__declspec(dllimport)
DWORD
__stdcall
EraseTape(
     HANDLE hDevice,
     DWORD dwEraseType,
     BOOL bImmediate
    );

__declspec(dllimport)
DWORD
__stdcall
CreateTapePartition(
     HANDLE hDevice,
     DWORD dwPartitionMethod,
     DWORD dwCount,
     DWORD dwSize
    );

__declspec(dllimport)
DWORD
__stdcall
WriteTapemark(
     HANDLE hDevice,
     DWORD dwTapemarkType,
     DWORD dwTapemarkCount,
     BOOL bImmediate
    );

__declspec(dllimport)
DWORD
__stdcall
GetTapeStatus(
     HANDLE hDevice
    );

__declspec(dllimport)
DWORD
__stdcall
GetTapeParameters(
        HANDLE hDevice,
        DWORD dwOperation,
     LPDWORD lpdwSize,
     LPVOID lpTapeInformation
    );




__declspec(dllimport)
DWORD
__stdcall
SetTapeParameters(
     HANDLE hDevice,
     DWORD dwOperation,
     LPVOID lpTapeInformation
    );




#line 2318 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winbase.h"
#pragma endregion

#pragma region Application Family or OneCore Family


__declspec(dllimport)
int
__stdcall
MulDiv(
     int nNumber,
     int nNumerator,
     int nDenominator
    );

#line 2333 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winbase.h"
#pragma endregion

#pragma region Desktop Family


typedef enum _DEP_SYSTEM_POLICY_TYPE {
    DEPPolicyAlwaysOff = 0,
    DEPPolicyAlwaysOn,
    DEPPolicyOptIn,
    DEPPolicyOptOut,
    DEPTotalPolicyCount
} DEP_SYSTEM_POLICY_TYPE;



__declspec(dllimport)
DEP_SYSTEM_POLICY_TYPE
__stdcall
GetSystemDEPPolicy(
    void
    );

#line 2356 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winbase.h"



__declspec(dllimport)
BOOL
__stdcall
GetSystemRegistryQuota(
     PDWORD pdwQuotaAllowed,
     PDWORD pdwQuotaUsed
    );

#line 2368 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winbase.h"

//
// Routines to convert back and forth between system time and file time
//

__declspec(dllimport)
BOOL
__stdcall
FileTimeToDosDateTime(
      const FILETIME *lpFileTime,
     LPWORD lpFatDate,
     LPWORD lpFatTime
    );

__declspec(dllimport)
BOOL
__stdcall
DosDateTimeToFileTime(
      WORD wFatDate,
      WORD wFatTime,
     LPFILETIME lpFileTime
    );

#line 2392 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winbase.h"
#pragma endregion

#pragma region Application Family or OneCore Family or Games Family


//
// FORMAT_MESSAGE_ALLOCATE_BUFFER requires use of HeapFree
//




__declspec(dllimport)

DWORD
__stdcall
FormatMessageA(
         DWORD dwFlags,
     LPCVOID lpSource,
         DWORD dwMessageId,
         DWORD dwLanguageId,
    
    
             LPSTR lpBuffer,
         DWORD nSize,
     va_list *Arguments
    );
__declspec(dllimport)

DWORD
__stdcall
FormatMessageW(
         DWORD dwFlags,
     LPCVOID lpSource,
         DWORD dwMessageId,
         DWORD dwLanguageId,
    
    
             LPWSTR lpBuffer,
         DWORD nSize,
     va_list *Arguments
    );




#line 2439 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winbase.h"





























#line 2469 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winbase.h"
#line 2470 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winbase.h"








#line 2479 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winbase.h"
#pragma endregion

#pragma region Desktop Family



__declspec(dllimport)
HANDLE
__stdcall
CreateMailslotA(
         LPCSTR lpName,
         DWORD nMaxMessageSize,
         DWORD lReadTimeout,
     LPSECURITY_ATTRIBUTES lpSecurityAttributes
    );
__declspec(dllimport)
HANDLE
__stdcall
CreateMailslotW(
         LPCWSTR lpName,
         DWORD nMaxMessageSize,
         DWORD lReadTimeout,
     LPSECURITY_ATTRIBUTES lpSecurityAttributes
    );




#line 2508 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winbase.h"

__declspec(dllimport)
BOOL
__stdcall
GetMailslotInfo(
          HANDLE hMailslot,
     LPDWORD lpMaxMessageSize,
     LPDWORD lpNextSize,
     LPDWORD lpMessageCount,
     LPDWORD lpReadTimeout
    );

__declspec(dllimport)
BOOL
__stdcall
SetMailslotInfo(
     HANDLE hMailslot,
     DWORD lReadTimeout
    );

//
// File Encryption API
//

__declspec(dllimport)
BOOL
__stdcall
EncryptFileA(
     LPCSTR lpFileName
    );
__declspec(dllimport)
BOOL
__stdcall
EncryptFileW(
     LPCWSTR lpFileName
    );




#line 2549 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winbase.h"

__declspec(dllimport)
BOOL
__stdcall
DecryptFileA(
           LPCSTR lpFileName,
     DWORD dwReserved
    );
__declspec(dllimport)
BOOL
__stdcall
DecryptFileW(
           LPCWSTR lpFileName,
     DWORD dwReserved
    );




#line 2569 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winbase.h"

//
//  Encryption Status Value
//












__declspec(dllimport)
BOOL
__stdcall
FileEncryptionStatusA(
      LPCSTR lpFileName,
     LPDWORD  lpStatus
    );
__declspec(dllimport)
BOOL
__stdcall
FileEncryptionStatusW(
      LPCWSTR lpFileName,
     LPDWORD  lpStatus
    );




#line 2604 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winbase.h"

//
// Currently defined recovery flags
//



typedef
DWORD
(__stdcall *PFE_EXPORT_FUNC)(
     PBYTE pbData,
     PVOID pvCallbackContext,
         ULONG ulLength
    );

typedef
DWORD
(__stdcall *PFE_IMPORT_FUNC)(
     PBYTE pbData,
     PVOID pvCallbackContext,
      PULONG ulLength
    );


//
//  OpenRaw flag values
//








__declspec(dllimport)
DWORD
__stdcall
OpenEncryptedFileRawA(
            LPCSTR lpFileName,
            ULONG    ulFlags,
     PVOID   *pvContext
    );
__declspec(dllimport)
DWORD
__stdcall
OpenEncryptedFileRawW(
            LPCWSTR lpFileName,
            ULONG    ulFlags,
     PVOID   *pvContext
    );




#line 2660 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winbase.h"

__declspec(dllimport)
DWORD
__stdcall
ReadEncryptedFileRaw(
         PFE_EXPORT_FUNC pfExportCallback,
     PVOID           pvCallbackContext,
         PVOID           pvContext
    );

__declspec(dllimport)
DWORD
__stdcall
WriteEncryptedFileRaw(
         PFE_IMPORT_FUNC pfImportCallback,
     PVOID           pvCallbackContext,
         PVOID           pvContext
    );

__declspec(dllimport)
void
__stdcall
CloseEncryptedFileRaw(
     PVOID           pvContext
    );

#line 2687 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winbase.h"
#pragma endregion

//
// _l Compat Functions
//

#pragma region Desktop Family or OneCore Family


__declspec(dllimport)
int
__stdcall
lstrcmpA(
     LPCSTR lpString1,
     LPCSTR lpString2
    );
__declspec(dllimport)
int
__stdcall
lstrcmpW(
     LPCWSTR lpString1,
     LPCWSTR lpString2
    );




#line 2715 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winbase.h"

__declspec(dllimport)
int
__stdcall
lstrcmpiA(
     LPCSTR lpString1,
     LPCSTR lpString2
    );
__declspec(dllimport)
int
__stdcall
lstrcmpiW(
     LPCWSTR lpString1,
     LPCWSTR lpString2
    );




#line 2735 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winbase.h"


#pragma warning(push)
#pragma warning(disable:4995)
#line 2740 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winbase.h"

__declspec(dllimport)




LPSTR
__stdcall
lstrcpynA(
     LPSTR lpString1,
     LPCSTR lpString2,
     int iMaxLength
    );
__declspec(dllimport)




LPWSTR
__stdcall
lstrcpynW(
     LPWSTR lpString1,
     LPCWSTR lpString2,
     int iMaxLength
    );




#line 2770 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winbase.h"

__declspec(dllimport)
LPSTR
__stdcall
lstrcpyA(
     LPSTR lpString1, // deprecated: annotation is as good as it gets
      LPCSTR lpString2
    );
__declspec(dllimport)
LPWSTR
__stdcall
lstrcpyW(
     LPWSTR lpString1, // deprecated: annotation is as good as it gets
      LPCWSTR lpString2
    );




#line 2790 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winbase.h"

__declspec(dllimport)
LPSTR
__stdcall
lstrcatA(
     LPSTR lpString1, // deprecated: annotation is as good as it gets
        LPCSTR lpString2
    );
__declspec(dllimport)
LPWSTR
__stdcall
lstrcatW(
     LPWSTR lpString1, // deprecated: annotation is as good as it gets
        LPCWSTR lpString2
    );




#line 2810 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winbase.h"


#pragma warning(pop)
#line 2814 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winbase.h"

__declspec(dllimport)
int
__stdcall
lstrlenA(
     LPCSTR lpString
    );
__declspec(dllimport)
int
__stdcall
lstrlenW(
     LPCWSTR lpString
    );




#line 2832 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winbase.h"

#line 2834 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winbase.h"
#pragma endregion

#pragma region Desktop Family


__declspec(dllimport)
HFILE
__stdcall
OpenFile(
        LPCSTR lpFileName,
     LPOFSTRUCT lpReOpenBuff,
        UINT uStyle
    );

__declspec(dllimport)
HFILE
__stdcall
_lopen(
     LPCSTR lpPathName,
     int iReadWrite
    );

__declspec(dllimport)
HFILE
__stdcall
_lcreat(
     LPCSTR lpPathName,
     int  iAttribute
    );

__declspec(dllimport)
UINT
__stdcall
_lread(
     HFILE hFile,
     LPVOID lpBuffer,
     UINT uBytes
    );

__declspec(dllimport)
UINT
__stdcall
_lwrite(
     HFILE hFile,
     LPCCH lpBuffer,
     UINT uBytes
    );

__declspec(dllimport)
long
__stdcall
_hread(
     HFILE hFile,
     LPVOID lpBuffer,
     long lBytes
    );

__declspec(dllimport)
long
__stdcall
_hwrite(
     HFILE hFile,
     LPCCH lpBuffer,
     long lBytes
    );

__declspec(dllimport)
HFILE
__stdcall
_lclose(
     HFILE hFile
    );

__declspec(dllimport)
LONG
__stdcall
_llseek(
     HFILE hFile,
     LONG lOffset,
     int iOrigin
    );

__declspec(dllimport)
BOOL
__stdcall
IsTextUnicode(
     const void * lpv,
            int iSize,
     LPINT lpiResult
    );

#line 2926 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winbase.h"
#pragma endregion

#pragma region Application Family or OneCore Family



__declspec(dllimport)
DWORD
__stdcall
SignalObjectAndWait(
     HANDLE hObjectToSignal,
     HANDLE hObjectToWaitOn,
     DWORD dwMilliseconds,
     BOOL bAlertable
    );
#line 2942 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winbase.h"

#line 2944 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winbase.h"
#pragma endregion

#pragma region Desktop Family


__declspec(dllimport)
BOOL
__stdcall
BackupRead(
        HANDLE hFile,
     LPBYTE lpBuffer,
        DWORD nNumberOfBytesToRead,
       LPDWORD lpNumberOfBytesRead,
        BOOL bAbort,
        BOOL bProcessSecurity,
     LPVOID *lpContext
    );

__declspec(dllimport)
BOOL
__stdcall
BackupSeek(
        HANDLE hFile,
        DWORD  dwLowBytesToSeek,
        DWORD  dwHighBytesToSeek,
       LPDWORD lpdwLowByteSeeked,
       LPDWORD lpdwHighByteSeeked,
     LPVOID *lpContext
    );

__declspec(dllimport)
BOOL
__stdcall
BackupWrite(
        HANDLE hFile,
     LPBYTE lpBuffer,
        DWORD nNumberOfBytesToWrite,
       LPDWORD lpNumberOfBytesWritten,
        BOOL bAbort,
        BOOL bProcessSecurity,
     LPVOID *lpContext
    );

//
//  Stream id structure
//
typedef struct _WIN32_STREAM_ID {
        DWORD          dwStreamId ;
        DWORD          dwStreamAttributes ;
        LARGE_INTEGER  Size ;
        DWORD          dwStreamNameSize ;
        WCHAR          cStreamName[ 1 ] ;
} WIN32_STREAM_ID, *LPWIN32_STREAM_ID ;

//
//  Stream Ids
//














//
//  Stream Attributes
//








//
// Dual Mode API below this line. Dual Mode Structures also included.
//

















#line 3047 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winbase.h"



#line 3051 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winbase.h"




typedef struct _STARTUPINFOEXA {
    STARTUPINFOA StartupInfo;
    LPPROC_THREAD_ATTRIBUTE_LIST lpAttributeList;
} STARTUPINFOEXA, *LPSTARTUPINFOEXA;
typedef struct _STARTUPINFOEXW {
    STARTUPINFOW StartupInfo;
    LPPROC_THREAD_ATTRIBUTE_LIST lpAttributeList;
} STARTUPINFOEXW, *LPSTARTUPINFOEXW;




typedef STARTUPINFOEXA STARTUPINFOEX;
typedef LPSTARTUPINFOEXA LPSTARTUPINFOEX;
#line 3070 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winbase.h"

#line 3072 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winbase.h"



#line 3076 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winbase.h"
#pragma endregion

#pragma region Application Family or OneCore Family


__declspec(dllimport)

HANDLE
__stdcall
OpenMutexA(
     DWORD dwDesiredAccess,
     BOOL bInheritHandle,
     LPCSTR lpName
    );


#line 3093 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winbase.h"

__declspec(dllimport)

HANDLE
__stdcall
CreateSemaphoreA(
     LPSECURITY_ATTRIBUTES lpSemaphoreAttributes,
         LONG lInitialCount,
         LONG lMaximumCount,
     LPCSTR lpName
    );


#line 3107 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winbase.h"

#line 3109 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winbase.h"
#pragma endregion

#pragma region Desktop Family or OneCore Family


__declspec(dllimport)

HANDLE
__stdcall
OpenSemaphoreA(
     DWORD dwDesiredAccess,
     BOOL bInheritHandle,
     LPCSTR lpName
    );


#line 3126 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winbase.h"

#line 3128 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winbase.h"
#pragma endregion



#pragma region Desktop Family or OneCore Family


__declspec(dllimport)

HANDLE
__stdcall
CreateWaitableTimerA(
     LPSECURITY_ATTRIBUTES lpTimerAttributes,
         BOOL bManualReset,
     LPCSTR lpTimerName
    );


#line 3147 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winbase.h"

__declspec(dllimport)

HANDLE
__stdcall
OpenWaitableTimerA(
     DWORD dwDesiredAccess,
     BOOL bInheritHandle,
     LPCSTR lpTimerName
    );


#line 3160 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winbase.h"



__declspec(dllimport)

HANDLE
__stdcall
CreateSemaphoreExA(
        LPSECURITY_ATTRIBUTES lpSemaphoreAttributes,
            LONG lInitialCount,
            LONG lMaximumCount,
        LPCSTR lpName,
      DWORD dwFlags,
            DWORD dwDesiredAccess
    );


#line 3178 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winbase.h"

__declspec(dllimport)

HANDLE
__stdcall
CreateWaitableTimerExA(
     LPSECURITY_ATTRIBUTES lpTimerAttributes,
     LPCSTR lpTimerName,
         DWORD dwFlags,
         DWORD dwDesiredAccess
    );


#line 3192 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winbase.h"

#line 3194 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winbase.h"

#line 3196 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winbase.h"

#line 3198 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winbase.h"

#pragma endregion

#pragma region Desktop Family


__declspec(dllimport)

HANDLE
__stdcall
CreateFileMappingA(
         HANDLE hFile,
     LPSECURITY_ATTRIBUTES lpFileMappingAttributes,
         DWORD flProtect,
         DWORD dwMaximumSizeHigh,
         DWORD dwMaximumSizeLow,
     LPCSTR lpName
    );


#line 3219 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winbase.h"



__declspec(dllimport)

HANDLE
__stdcall
CreateFileMappingNumaA(
         HANDLE hFile,
     LPSECURITY_ATTRIBUTES lpFileMappingAttributes,
         DWORD flProtect,
         DWORD dwMaximumSizeHigh,
         DWORD dwMaximumSizeLow,
     LPCSTR lpName,
         DWORD nndPreferred
    );



#line 3239 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winbase.h"

#line 3241 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winbase.h"

__declspec(dllimport)
HANDLE
__stdcall
OpenFileMappingA(
     DWORD dwDesiredAccess,
     BOOL bInheritHandle,
     LPCSTR lpName
    );


#line 3253 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winbase.h"

#line 3255 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winbase.h"
#pragma endregion

#pragma region Desktop Family or OneCore Family


__declspec(dllimport)

DWORD
__stdcall
GetLogicalDriveStringsA(
     DWORD nBufferLength,
     LPSTR lpBuffer
    );


#line 3271 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winbase.h"

#line 3273 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winbase.h"
#pragma endregion

#pragma region Desktop Family



#line 3280 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winbase.h"
#pragma endregion

#pragma region Application Family or OneCore Family













#line 3297 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winbase.h"

#line 3299 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winbase.h"
#pragma endregion



//
// Supported process protection levels.
//







//
// The following protection levels are supplied for testing only (no win32
// callers need these).
//








//
// The following is only used as a value for ProtectionLevel
// when querying ProcessProtectionLevelInfo in GetProcessInformation.
//


#line 3332 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winbase.h"

#pragma region Desktop Family or OneCore Family






__declspec(dllimport)
BOOL
__stdcall
QueryFullProcessImageNameA(
     HANDLE hProcess,
     DWORD dwFlags,
     LPSTR lpExeName,
     PDWORD lpdwSize
    );
__declspec(dllimport)
BOOL
__stdcall
QueryFullProcessImageNameW(
     HANDLE hProcess,
     DWORD dwFlags,
     LPWSTR lpExeName,
     PDWORD lpdwSize
    );




#line 3363 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winbase.h"

#line 3365 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winbase.h"



//
// Extended process and thread attribute support
//








typedef enum _PROC_THREAD_ATTRIBUTE_NUM {
    ProcThreadAttributeParentProcess                = 0,
    ProcThreadAttributeHandleList                   = 2,

    ProcThreadAttributeGroupAffinity                = 3,
    ProcThreadAttributePreferredNode                = 4,
    ProcThreadAttributeIdealProcessor               = 5,
    ProcThreadAttributeUmsThread                    = 6,
    ProcThreadAttributeMitigationPolicy             = 7,
#line 3389 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winbase.h"


#line 3392 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winbase.h"
    ProcThreadAttributeProtectionLevel              = 11,

#line 3395 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winbase.h"





#line 3401 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winbase.h"


#line 3404 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winbase.h"


#line 3407 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winbase.h"


#line 3410 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winbase.h"

#line 3412 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winbase.h"
} PROC_THREAD_ATTRIBUTE_NUM;
#line 3414 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winbase.h"












#line 3427 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winbase.h"












#line 3440 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winbase.h"




#line 3445 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winbase.h"





#line 3451 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winbase.h"




#line 3456 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winbase.h"


//
// Define legacy creation mitigation policy options, which are straight
// bitmasks.  Bits 0-5 are legacy bits.
//




#line 3467 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winbase.h"











































































































































































































































#line 3703 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winbase.h"





























#line 3733 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winbase.h"




#line 3738 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winbase.h"















#line 3754 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winbase.h"




#line 3759 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winbase.h"




#line 3764 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winbase.h"

#line 3766 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winbase.h"
#pragma endregion

#pragma region Desktop Family



__declspec(dllimport)
void
__stdcall
GetStartupInfoA(
     LPSTARTUPINFOA lpStartupInfo
    );


#line 3781 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winbase.h"

































#line 3815 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winbase.h"



















#line 3835 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winbase.h"

#line 3837 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winbase.h"
#pragma endregion

#pragma region OneCore Family or App Family


__declspec(dllimport)
DWORD
__stdcall
GetFirmwareEnvironmentVariableA(
     LPCSTR lpName,
     LPCSTR lpGuid,
     PVOID pBuffer,
     DWORD    nSize
    );
__declspec(dllimport)
DWORD
__stdcall
GetFirmwareEnvironmentVariableW(
     LPCWSTR lpName,
     LPCWSTR lpGuid,
     PVOID pBuffer,
     DWORD    nSize
    );




#line 3865 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winbase.h"





























#line 3895 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winbase.h"

__declspec(dllimport)
BOOL
__stdcall
SetFirmwareEnvironmentVariableA(
     LPCSTR lpName,
     LPCSTR lpGuid,
     PVOID pValue,
     DWORD    nSize
    );
__declspec(dllimport)
BOOL
__stdcall
SetFirmwareEnvironmentVariableW(
     LPCWSTR lpName,
     LPCWSTR lpGuid,
     PVOID pValue,
     DWORD    nSize
    );




#line 3919 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winbase.h"





























#line 3949 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winbase.h"

#line 3951 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winbase.h"
#pragma endregion

#pragma region Desktop Family



















#line 3974 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winbase.h"

__declspec(dllimport)

HRSRC
__stdcall
FindResourceA(
     HMODULE hModule,
         LPCSTR lpName,
         LPCSTR lpType
    );


#line 3987 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winbase.h"

__declspec(dllimport)

HRSRC
__stdcall
FindResourceExA(
     HMODULE hModule,
         LPCSTR lpType,
         LPCSTR lpName,
         WORD    wLanguage
    );


#line 4001 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winbase.h"

__declspec(dllimport)
BOOL
__stdcall
EnumResourceTypesA(
     HMODULE hModule,
         ENUMRESTYPEPROCA lpEnumFunc,
         LONG_PTR lParam
    );
__declspec(dllimport)
BOOL
__stdcall
EnumResourceTypesW(
     HMODULE hModule,
         ENUMRESTYPEPROCW lpEnumFunc,
         LONG_PTR lParam
    );




#line 4023 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winbase.h"

__declspec(dllimport)
BOOL
__stdcall
EnumResourceNamesA(
     HMODULE hModule,
         LPCSTR lpType,
         ENUMRESNAMEPROCA lpEnumFunc,
         LONG_PTR lParam
    );



#line 4037 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winbase.h"

__declspec(dllimport)
BOOL
__stdcall
EnumResourceLanguagesA(
     HMODULE hModule,
         LPCSTR lpType,
         LPCSTR lpName,
         ENUMRESLANGPROCA lpEnumFunc,
         LONG_PTR lParam
    );
__declspec(dllimport)
BOOL
__stdcall
EnumResourceLanguagesW(
     HMODULE hModule,
         LPCWSTR lpType,
         LPCWSTR lpName,
         ENUMRESLANGPROCW lpEnumFunc,
         LONG_PTR lParam
    );




#line 4063 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winbase.h"

__declspec(dllimport)
HANDLE
__stdcall
BeginUpdateResourceA(
     LPCSTR pFileName,
     BOOL bDeleteExistingResources
    );
__declspec(dllimport)
HANDLE
__stdcall
BeginUpdateResourceW(
     LPCWSTR pFileName,
     BOOL bDeleteExistingResources
    );




#line 4083 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winbase.h"

__declspec(dllimport)
BOOL
__stdcall
UpdateResourceA(
     HANDLE hUpdate,
     LPCSTR lpType,
     LPCSTR lpName,
     WORD wLanguage,
     LPVOID lpData,
     DWORD cb
    );
__declspec(dllimport)
BOOL
__stdcall
UpdateResourceW(
     HANDLE hUpdate,
     LPCWSTR lpType,
     LPCWSTR lpName,
     WORD wLanguage,
     LPVOID lpData,
     DWORD cb
    );




#line 4111 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winbase.h"

__declspec(dllimport)
BOOL
__stdcall
EndUpdateResourceA(
     HANDLE hUpdate,
     BOOL   fDiscard
    );
__declspec(dllimport)
BOOL
__stdcall
EndUpdateResourceW(
     HANDLE hUpdate,
     BOOL   fDiscard
    );




#line 4131 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winbase.h"



__declspec(dllimport)
ATOM
__stdcall
GlobalAddAtomA(
     LPCSTR lpString
    );
__declspec(dllimport)
ATOM
__stdcall
GlobalAddAtomW(
     LPCWSTR lpString
    );




#line 4151 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winbase.h"

__declspec(dllimport)
ATOM
__stdcall
GlobalAddAtomExA(
     LPCSTR lpString,
     DWORD Flags
    );
__declspec(dllimport)
ATOM
__stdcall
GlobalAddAtomExW(
     LPCWSTR lpString,
     DWORD Flags
    );




#line 4171 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winbase.h"

__declspec(dllimport)
ATOM
__stdcall
GlobalFindAtomA(
     LPCSTR lpString
    );
__declspec(dllimport)
ATOM
__stdcall
GlobalFindAtomW(
     LPCWSTR lpString
    );




#line 4189 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winbase.h"

__declspec(dllimport)
UINT
__stdcall
GlobalGetAtomNameA(
     ATOM nAtom,
     LPSTR lpBuffer,
     int nSize
    );
__declspec(dllimport)
UINT
__stdcall
GlobalGetAtomNameW(
     ATOM nAtom,
     LPWSTR lpBuffer,
     int nSize
    );




#line 4211 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winbase.h"

__declspec(dllimport)
ATOM
__stdcall
AddAtomA(
     LPCSTR lpString
    );
__declspec(dllimport)
ATOM
__stdcall
AddAtomW(
     LPCWSTR lpString
    );




#line 4229 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winbase.h"

__declspec(dllimport)
ATOM
__stdcall
FindAtomA(
     LPCSTR lpString
    );
__declspec(dllimport)
ATOM
__stdcall
FindAtomW(
     LPCWSTR lpString
    );




#line 4247 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winbase.h"

__declspec(dllimport)
UINT
__stdcall
GetAtomNameA(
     ATOM nAtom,
     LPSTR lpBuffer,
     int nSize
    );
__declspec(dllimport)
UINT
__stdcall
GetAtomNameW(
     ATOM nAtom,
     LPWSTR lpBuffer,
     int nSize
    );




#line 4269 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winbase.h"

#line 4271 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winbase.h"
#pragma endregion

#pragma region Desktop Family or OneCore Family


__declspec(dllimport)
UINT
__stdcall
GetProfileIntA(
     LPCSTR lpAppName,
     LPCSTR lpKeyName,
     INT nDefault
    );
__declspec(dllimport)
UINT
__stdcall
GetProfileIntW(
     LPCWSTR lpAppName,
     LPCWSTR lpKeyName,
     INT nDefault
    );




#line 4297 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winbase.h"

__declspec(dllimport)
DWORD
__stdcall
GetProfileStringA(
     LPCSTR lpAppName,
     LPCSTR lpKeyName,
     LPCSTR lpDefault,
     LPSTR lpReturnedString,
         DWORD nSize
    );
__declspec(dllimport)
DWORD
__stdcall
GetProfileStringW(
     LPCWSTR lpAppName,
     LPCWSTR lpKeyName,
     LPCWSTR lpDefault,
     LPWSTR lpReturnedString,
         DWORD nSize
    );




#line 4323 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winbase.h"

#line 4325 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winbase.h"
#pragma endregion

#pragma region Desktop Family


__declspec(dllimport)
BOOL
__stdcall
WriteProfileStringA(
     LPCSTR lpAppName,
     LPCSTR lpKeyName,
     LPCSTR lpString
    );
__declspec(dllimport)
BOOL
__stdcall
WriteProfileStringW(
     LPCWSTR lpAppName,
     LPCWSTR lpKeyName,
     LPCWSTR lpString
    );




#line 4351 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winbase.h"

#line 4353 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winbase.h"
#pragma endregion

#pragma region Desktop Family or OneCore Family


__declspec(dllimport)
DWORD
__stdcall
GetProfileSectionA(
     LPCSTR lpAppName,
     LPSTR lpReturnedString,
     DWORD nSize
    );
__declspec(dllimport)
DWORD
__stdcall
GetProfileSectionW(
     LPCWSTR lpAppName,
     LPWSTR lpReturnedString,
     DWORD nSize
    );




#line 4379 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winbase.h"

#line 4381 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winbase.h"
#pragma endregion

#pragma region Desktop Family


__declspec(dllimport)
BOOL
__stdcall
WriteProfileSectionA(
     LPCSTR lpAppName,
     LPCSTR lpString
    );
__declspec(dllimport)
BOOL
__stdcall
WriteProfileSectionW(
     LPCWSTR lpAppName,
     LPCWSTR lpString
    );




#line 4405 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winbase.h"

#line 4407 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winbase.h"
#pragma endregion

#pragma region Desktop Family or OneCore Family


__declspec(dllimport)
UINT
__stdcall
GetPrivateProfileIntA(
         LPCSTR lpAppName,
         LPCSTR lpKeyName,
         INT nDefault,
     LPCSTR lpFileName
    );
__declspec(dllimport)
UINT
__stdcall
GetPrivateProfileIntW(
         LPCWSTR lpAppName,
         LPCWSTR lpKeyName,
         INT nDefault,
     LPCWSTR lpFileName
    );




#line 4435 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winbase.h"























#line 4459 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winbase.h"

__declspec(dllimport)
DWORD
__stdcall
GetPrivateProfileStringA(
     LPCSTR lpAppName,
     LPCSTR lpKeyName,
     LPCSTR lpDefault,
     LPSTR lpReturnedString,
         DWORD nSize,
     LPCSTR lpFileName
    );
__declspec(dllimport)
DWORD
__stdcall
GetPrivateProfileStringW(
     LPCWSTR lpAppName,
     LPCWSTR lpKeyName,
     LPCWSTR lpDefault,
     LPWSTR lpReturnedString,
         DWORD nSize,
     LPCWSTR lpFileName
    );




#line 4487 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winbase.h"



























#line 4515 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winbase.h"

__declspec(dllimport)
BOOL
__stdcall
WritePrivateProfileStringA(
     LPCSTR lpAppName,
     LPCSTR lpKeyName,
     LPCSTR lpString,
     LPCSTR lpFileName
    );
__declspec(dllimport)
BOOL
__stdcall
WritePrivateProfileStringW(
     LPCWSTR lpAppName,
     LPCWSTR lpKeyName,
     LPCWSTR lpString,
     LPCWSTR lpFileName
    );




#line 4539 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winbase.h"

__declspec(dllimport)
DWORD
__stdcall
GetPrivateProfileSectionA(
         LPCSTR lpAppName,
     LPSTR lpReturnedString,
         DWORD nSize,
     LPCSTR lpFileName
    );
__declspec(dllimport)
DWORD
__stdcall
GetPrivateProfileSectionW(
         LPCWSTR lpAppName,
     LPWSTR lpReturnedString,
         DWORD nSize,
     LPCWSTR lpFileName
    );




#line 4563 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winbase.h"























#line 4587 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winbase.h"

__declspec(dllimport)
BOOL
__stdcall
WritePrivateProfileSectionA(
     LPCSTR lpAppName,
     LPCSTR lpString,
     LPCSTR lpFileName
    );
__declspec(dllimport)
BOOL
__stdcall
WritePrivateProfileSectionW(
     LPCWSTR lpAppName,
     LPCWSTR lpString,
     LPCWSTR lpFileName
    );




#line 4609 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winbase.h"

#line 4611 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winbase.h"
#pragma endregion

#pragma region Desktop Family


__declspec(dllimport)
DWORD
__stdcall
GetPrivateProfileSectionNamesA(
     LPSTR lpszReturnBuffer,
         DWORD nSize,
     LPCSTR lpFileName
    );
__declspec(dllimport)
DWORD
__stdcall
GetPrivateProfileSectionNamesW(
     LPWSTR lpszReturnBuffer,
         DWORD nSize,
     LPCWSTR lpFileName
    );




#line 4637 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winbase.h"





















#line 4659 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winbase.h"

__declspec(dllimport)
BOOL
__stdcall
GetPrivateProfileStructA(
         LPCSTR lpszSection,
         LPCSTR lpszKey,
     LPVOID   lpStruct,
         UINT     uSizeStruct,
     LPCSTR szFile
    );
__declspec(dllimport)
BOOL
__stdcall
GetPrivateProfileStructW(
         LPCWSTR lpszSection,
         LPCWSTR lpszKey,
     LPVOID   lpStruct,
         UINT     uSizeStruct,
     LPCWSTR szFile
    );




#line 4685 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winbase.h"

























#line 4711 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winbase.h"

__declspec(dllimport)
BOOL
__stdcall
WritePrivateProfileStructA(
         LPCSTR lpszSection,
         LPCSTR lpszKey,
     LPVOID lpStruct,
         UINT     uSizeStruct,
     LPCSTR szFile
    );
__declspec(dllimport)
BOOL
__stdcall
WritePrivateProfileStructW(
         LPCWSTR lpszSection,
         LPCWSTR lpszKey,
     LPVOID lpStruct,
         UINT     uSizeStruct,
     LPCWSTR szFile
    );




#line 4737 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winbase.h"























#line 4761 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winbase.h"




__declspec(dllimport)
BOOLEAN
__stdcall
Wow64EnableWow64FsRedirection (
     BOOLEAN Wow64FsEnableRedirection
    );

//
// for GetProcAddress
//
typedef UINT (__stdcall * PGET_SYSTEM_WOW64_DIRECTORY_A)( LPSTR lpBuffer,  UINT uSize);
typedef UINT (__stdcall * PGET_SYSTEM_WOW64_DIRECTORY_W)( LPWSTR lpBuffer,  UINT uSize);

//
// GetProcAddress only accepts GET_SYSTEM_WOW64_DIRECTORY_NAME_A_A,
// GET_SYSTEM_WOW64_DIRECTORY_NAME_W_A, GET_SYSTEM_WOW64_DIRECTORY_NAME_T_A.
// The others are if you want to use the strings in some other way.
//















#line 4799 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winbase.h"

#line 4801 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winbase.h"
#line 4802 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winbase.h"

















#line 4820 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winbase.h"



















#line 4840 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winbase.h"

#line 4842 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winbase.h"
#pragma endregion

#pragma region Desktop Family or Games Family




__declspec(dllimport)
BOOL
__stdcall
SetDllDirectoryA(
     LPCSTR lpPathName
    );
__declspec(dllimport)
BOOL
__stdcall
SetDllDirectoryW(
     LPCWSTR lpPathName
    );




#line 4866 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winbase.h"
#line 4867 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winbase.h"

#line 4869 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winbase.h"
#pragma endregion

#pragma region Desktop Family



__declspec(dllimport)

DWORD
__stdcall
GetDllDirectoryA(
     DWORD nBufferLength,
     LPSTR lpBuffer
    );
__declspec(dllimport)

DWORD
__stdcall
GetDllDirectoryW(
     DWORD nBufferLength,
     LPWSTR lpBuffer
    );




#line 4896 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winbase.h"

#line 4898 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winbase.h"






__declspec(dllimport)
BOOL
__stdcall
SetSearchPathMode (
     DWORD Flags
    );

#line 4912 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winbase.h"
#pragma endregion

#pragma region Application Family




















#line 4936 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winbase.h"

#line 4938 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winbase.h"
#pragma endregion

#pragma region Desktop Family or OneCore Family


__declspec(dllimport)
BOOL
__stdcall
CreateDirectoryExA(
         LPCSTR lpTemplateDirectory,
         LPCSTR lpNewDirectory,
     LPSECURITY_ATTRIBUTES lpSecurityAttributes
    );
__declspec(dllimport)
BOOL
__stdcall
CreateDirectoryExW(
         LPCWSTR lpTemplateDirectory,
         LPCWSTR lpNewDirectory,
     LPSECURITY_ATTRIBUTES lpSecurityAttributes
    );




#line 4964 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winbase.h"

#line 4966 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winbase.h"
#pragma endregion

#pragma region Desktop Family




__declspec(dllimport)
BOOL
__stdcall
CreateDirectoryTransactedA(
     LPCSTR lpTemplateDirectory,
         LPCSTR lpNewDirectory,
     LPSECURITY_ATTRIBUTES lpSecurityAttributes,
         HANDLE hTransaction
    );
__declspec(dllimport)
BOOL
__stdcall
CreateDirectoryTransactedW(
     LPCWSTR lpTemplateDirectory,
         LPCWSTR lpNewDirectory,
     LPSECURITY_ATTRIBUTES lpSecurityAttributes,
         HANDLE hTransaction
    );




#line 4996 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winbase.h"

__declspec(dllimport)
BOOL
__stdcall
RemoveDirectoryTransactedA(
     LPCSTR lpPathName,
         HANDLE hTransaction
    );
__declspec(dllimport)
BOOL
__stdcall
RemoveDirectoryTransactedW(
     LPCWSTR lpPathName,
         HANDLE hTransaction
    );




#line 5016 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winbase.h"

__declspec(dllimport)

DWORD
__stdcall
GetFullPathNameTransactedA(
                LPCSTR lpFileName,
                DWORD nBufferLength,
     LPSTR lpBuffer,
     LPSTR *lpFilePart,
                HANDLE hTransaction
    );
__declspec(dllimport)

DWORD
__stdcall
GetFullPathNameTransactedW(
                LPCWSTR lpFileName,
                DWORD nBufferLength,
     LPWSTR lpBuffer,
     LPWSTR *lpFilePart,
                HANDLE hTransaction
    );




#line 5044 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winbase.h"

#line 5046 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winbase.h"

#line 5048 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winbase.h"
#pragma endregion

#pragma region Desktop Family or OneCore Family








__declspec(dllimport)
BOOL
__stdcall
DefineDosDeviceA(
         DWORD dwFlags,
         LPCSTR lpDeviceName,
     LPCSTR lpTargetPath
    );


#line 5070 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winbase.h"

__declspec(dllimport)
DWORD
__stdcall
QueryDosDeviceA(
     LPCSTR lpDeviceName,
     LPSTR lpTargetPath,
         DWORD ucchMax
    );


#line 5082 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winbase.h"

#line 5084 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winbase.h"
#pragma endregion

#pragma region Desktop Family






__declspec(dllimport)
HANDLE
__stdcall
CreateFileTransactedA(
           LPCSTR lpFileName,
           DWORD dwDesiredAccess,
           DWORD dwShareMode,
       LPSECURITY_ATTRIBUTES lpSecurityAttributes,
           DWORD dwCreationDisposition,
           DWORD dwFlagsAndAttributes,
       HANDLE hTemplateFile,
           HANDLE hTransaction,
       PUSHORT pusMiniVersion,
     PVOID  lpExtendedParameter
    );
__declspec(dllimport)
HANDLE
__stdcall
CreateFileTransactedW(
           LPCWSTR lpFileName,
           DWORD dwDesiredAccess,
           DWORD dwShareMode,
       LPSECURITY_ATTRIBUTES lpSecurityAttributes,
           DWORD dwCreationDisposition,
           DWORD dwFlagsAndAttributes,
       HANDLE hTemplateFile,
           HANDLE hTransaction,
       PUSHORT pusMiniVersion,
     PVOID  lpExtendedParameter
    );




#line 5128 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winbase.h"

#line 5130 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winbase.h"

#line 5132 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winbase.h"
#pragma endregion

#pragma region Desktop Family or OneCore Family




__declspec(dllimport)
HANDLE
__stdcall
ReOpenFile(
     HANDLE  hOriginalFile,
     DWORD   dwDesiredAccess,
     DWORD   dwShareMode,
     DWORD   dwFlagsAndAttributes
    );

#line 5150 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winbase.h"

#line 5152 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winbase.h"
#pragma endregion


#pragma region Desktop Family




__declspec(dllimport)
BOOL
__stdcall
SetFileAttributesTransactedA(
         LPCSTR lpFileName,
         DWORD dwFileAttributes,
         HANDLE hTransaction
    );
__declspec(dllimport)
BOOL
__stdcall
SetFileAttributesTransactedW(
         LPCWSTR lpFileName,
         DWORD dwFileAttributes,
         HANDLE hTransaction
    );




#line 5181 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winbase.h"

__declspec(dllimport)
BOOL
__stdcall
GetFileAttributesTransactedA(
      LPCSTR lpFileName,
      GET_FILEEX_INFO_LEVELS fInfoLevelId,
     LPVOID lpFileInformation,
         HANDLE hTransaction
    );
__declspec(dllimport)
BOOL
__stdcall
GetFileAttributesTransactedW(
      LPCWSTR lpFileName,
      GET_FILEEX_INFO_LEVELS fInfoLevelId,
     LPVOID lpFileInformation,
         HANDLE hTransaction
    );




#line 5205 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winbase.h"

__declspec(dllimport)
DWORD
__stdcall
GetCompressedFileSizeTransactedA(
          LPCSTR lpFileName,
     LPDWORD  lpFileSizeHigh,
          HANDLE hTransaction
    );
__declspec(dllimport)
DWORD
__stdcall
GetCompressedFileSizeTransactedW(
          LPCWSTR lpFileName,
     LPDWORD  lpFileSizeHigh,
          HANDLE hTransaction
    );




#line 5227 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winbase.h"

__declspec(dllimport)
BOOL
__stdcall
DeleteFileTransactedA(
         LPCSTR lpFileName,
         HANDLE hTransaction
    );
__declspec(dllimport)
BOOL
__stdcall
DeleteFileTransactedW(
         LPCWSTR lpFileName,
         HANDLE hTransaction
    );




#line 5247 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winbase.h"

#line 5249 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winbase.h"

#line 5251 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winbase.h"
#pragma endregion

#pragma region Application Family


















#line 5273 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winbase.h"

#line 5275 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winbase.h"
#pragma endregion

#pragma region Desktop Family




__declspec(dllimport)
BOOL
__stdcall
CheckNameLegalDOS8Dot3A(
          LPCSTR lpName,
     LPSTR lpOemName,
          DWORD OemNameSize,
     PBOOL pbNameContainsSpaces  ,
         PBOOL pbNameLegal
    );
__declspec(dllimport)
BOOL
__stdcall
CheckNameLegalDOS8Dot3W(
          LPCWSTR lpName,
     LPSTR lpOemName,
          DWORD OemNameSize,
     PBOOL pbNameContainsSpaces  ,
         PBOOL pbNameLegal
    );




#line 5307 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winbase.h"

#line 5309 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winbase.h"

#line 5311 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winbase.h"
#pragma endregion



#pragma region Desktop Family




__declspec(dllimport)
HANDLE
__stdcall
FindFirstFileTransactedA(
           LPCSTR lpFileName,
           FINDEX_INFO_LEVELS fInfoLevelId,
     LPVOID lpFindFileData,
           FINDEX_SEARCH_OPS fSearchOp,
     LPVOID lpSearchFilter,
           DWORD dwAdditionalFlags,
           HANDLE hTransaction
    );
__declspec(dllimport)
HANDLE
__stdcall
FindFirstFileTransactedW(
           LPCWSTR lpFileName,
           FINDEX_INFO_LEVELS fInfoLevelId,
     LPVOID lpFindFileData,
           FINDEX_SEARCH_OPS fSearchOp,
     LPVOID lpSearchFilter,
           DWORD dwAdditionalFlags,
           HANDLE hTransaction
    );




#line 5349 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winbase.h"

#line 5351 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winbase.h"

#line 5353 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winbase.h"
#pragma endregion

#line 5356 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winbase.h"

#pragma region Application Family or OneCore Family



__declspec(dllimport)
BOOL
__stdcall
CopyFileA(
     LPCSTR lpExistingFileName,
     LPCSTR lpNewFileName,
     BOOL bFailIfExists
    );
__declspec(dllimport)
BOOL
__stdcall
CopyFileW(
     LPCWSTR lpExistingFileName,
     LPCWSTR lpNewFileName,
     BOOL bFailIfExists
    );




#line 5382 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winbase.h"





















#line 5404 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winbase.h"

#line 5406 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winbase.h"
#pragma endregion



#pragma region Application Family or OneCore Family


typedef
DWORD
(__stdcall *LPPROGRESS_ROUTINE)(
         LARGE_INTEGER TotalFileSize,
         LARGE_INTEGER TotalBytesTransferred,
         LARGE_INTEGER StreamSize,
         LARGE_INTEGER StreamBytesTransferred,
         DWORD dwStreamNumber,
         DWORD dwCallbackReason,
         HANDLE hSourceFile,
         HANDLE hDestinationFile,
     LPVOID lpData
    );

__declspec(dllimport)
BOOL
__stdcall
CopyFileExA(
            LPCSTR lpExistingFileName,
            LPCSTR lpNewFileName,
        LPPROGRESS_ROUTINE lpProgressRoutine,
        LPVOID lpData,
    
     LPBOOL pbCancel,
            DWORD dwCopyFlags
    );
__declspec(dllimport)
BOOL
__stdcall
CopyFileExW(
            LPCWSTR lpExistingFileName,
            LPCWSTR lpNewFileName,
        LPPROGRESS_ROUTINE lpProgressRoutine,
        LPVOID lpData,
    
     LPBOOL pbCancel,
            DWORD dwCopyFlags
    );




#line 5456 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winbase.h"

#line 5458 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winbase.h"
#pragma endregion

#pragma region Desktop Family




__declspec(dllimport)
BOOL
__stdcall
CopyFileTransactedA(
         LPCSTR lpExistingFileName,
         LPCSTR lpNewFileName,
     LPPROGRESS_ROUTINE lpProgressRoutine,
     LPVOID lpData,
     LPBOOL pbCancel,
         DWORD dwCopyFlags,
         HANDLE hTransaction
    );
__declspec(dllimport)
BOOL
__stdcall
CopyFileTransactedW(
         LPCWSTR lpExistingFileName,
         LPCWSTR lpNewFileName,
     LPPROGRESS_ROUTINE lpProgressRoutine,
     LPVOID lpData,
     LPBOOL pbCancel,
         DWORD dwCopyFlags,
         HANDLE hTransaction
    );




#line 5494 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winbase.h"

#line 5496 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winbase.h"

#line 5498 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winbase.h"
#pragma endregion

#pragma region Application Family


//
// TODO: Win7 for now, when we roll over the version number this needs to be updated.
//



typedef enum _COPYFILE2_MESSAGE_TYPE {
     COPYFILE2_CALLBACK_NONE = 0,
     COPYFILE2_CALLBACK_CHUNK_STARTED,
     COPYFILE2_CALLBACK_CHUNK_FINISHED,
     COPYFILE2_CALLBACK_STREAM_STARTED,
     COPYFILE2_CALLBACK_STREAM_FINISHED,
     COPYFILE2_CALLBACK_POLL_CONTINUE,
     COPYFILE2_CALLBACK_ERROR,
     COPYFILE2_CALLBACK_MAX,
} COPYFILE2_MESSAGE_TYPE;

typedef enum _COPYFILE2_MESSAGE_ACTION {
    COPYFILE2_PROGRESS_CONTINUE = 0,
    COPYFILE2_PROGRESS_CANCEL,
    COPYFILE2_PROGRESS_STOP,
    COPYFILE2_PROGRESS_QUIET,
    COPYFILE2_PROGRESS_PAUSE,
} COPYFILE2_MESSAGE_ACTION;

typedef enum _COPYFILE2_COPY_PHASE {
    COPYFILE2_PHASE_NONE = 0,
    COPYFILE2_PHASE_PREPARE_SOURCE,
    COPYFILE2_PHASE_PREPARE_DEST,
    COPYFILE2_PHASE_READ_SOURCE,
    COPYFILE2_PHASE_WRITE_DESTINATION,
    COPYFILE2_PHASE_SERVER_COPY,
    COPYFILE2_PHASE_NAMEGRAFT_COPY,
    // ... etc phases.
    COPYFILE2_PHASE_MAX,
} COPYFILE2_COPY_PHASE;



typedef struct COPYFILE2_MESSAGE {

    COPYFILE2_MESSAGE_TYPE  Type;
    DWORD                   dwPadding;

    union {

        struct {
            DWORD           dwStreamNumber; // monotonically increasing stream number
            DWORD           dwReserved;
            HANDLE           hSourceFile; // handle to the source stream
            HANDLE           hDestinationFile; // handle to the destination stream
            ULARGE_INTEGER  uliChunkNumber; // monotonically increasing chunk number
            ULARGE_INTEGER  uliChunkSize;  // size of the copied chunk
            ULARGE_INTEGER  uliStreamSize; // size of the current stream
            ULARGE_INTEGER  uliTotalFileSize; // size of all streams for this file
        } ChunkStarted;

        struct {
            DWORD           dwStreamNumber; // monotonically increasing stream number
            DWORD           dwFlags;
            HANDLE           hSourceFile; // handle to the source stream
            HANDLE           hDestinationFile; // handle to the destination stream
            ULARGE_INTEGER  uliChunkNumber; // monotonically increasing chunk number
            ULARGE_INTEGER  uliChunkSize;  // size of the copied chunk
            ULARGE_INTEGER  uliStreamSize; // size of the current stream
            ULARGE_INTEGER  uliStreamBytesTransferred; // bytes copied for this stream so far
            ULARGE_INTEGER  uliTotalFileSize; // size of all streams for this file
            ULARGE_INTEGER  uliTotalBytesTransferred; // total bytes copied so far
        } ChunkFinished;

        struct {
            DWORD           dwStreamNumber;
            DWORD           dwReserved;
            HANDLE           hSourceFile; // handle to the source stream
            HANDLE           hDestinationFile; // handle to the destination stream
            ULARGE_INTEGER  uliStreamSize; // size of this stream
            ULARGE_INTEGER  uliTotalFileSize; // total size of all streams for this file
        } StreamStarted;

        struct {
            DWORD           dwStreamNumber;
            DWORD           dwReserved;
            HANDLE           hSourceFile; // handle to the source stream
            HANDLE           hDestinationFile; // handle to the destination stream
            ULARGE_INTEGER  uliStreamSize;
            ULARGE_INTEGER  uliStreamBytesTransferred;
            ULARGE_INTEGER  uliTotalFileSize;
            ULARGE_INTEGER  uliTotalBytesTransferred;
        } StreamFinished;

        struct {
            DWORD           dwReserved;
        } PollContinue;

        struct {
            COPYFILE2_COPY_PHASE    CopyPhase;
            DWORD                   dwStreamNumber;
            HRESULT                 hrFailure;
            DWORD                   dwReserved;
            ULARGE_INTEGER          uliChunkNumber;
            ULARGE_INTEGER          uliStreamSize;
            ULARGE_INTEGER          uliStreamBytesTransferred;
            ULARGE_INTEGER          uliTotalFileSize;
            ULARGE_INTEGER          uliTotalBytesTransferred;
        } Error;

    } Info;

} COPYFILE2_MESSAGE;

typedef
COPYFILE2_MESSAGE_ACTION (__stdcall *PCOPYFILE2_PROGRESS_ROUTINE)(
        const COPYFILE2_MESSAGE     *pMessage,
    PVOID                       pvCallbackContext
);

typedef struct COPYFILE2_EXTENDED_PARAMETERS {
  DWORD                         dwSize;
  DWORD                         dwCopyFlags;
  BOOL                          *pfCancel;
  PCOPYFILE2_PROGRESS_ROUTINE   pProgressRoutine;
  PVOID                         pvCallbackContext;
} COPYFILE2_EXTENDED_PARAMETERS;

__declspec(dllimport)
HRESULT
__stdcall
CopyFile2(
        PCWSTR                          pwszExistingFileName,
        PCWSTR                          pwszNewFileName,
    COPYFILE2_EXTENDED_PARAMETERS   *pExtendedParameters
);

#line 5637 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winbase.h"

#line 5639 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winbase.h"
#pragma endregion

#line 5642 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winbase.h"

#pragma region Desktop Family or Games Family


__declspec(dllimport)
BOOL
__stdcall
MoveFileA(
     LPCSTR lpExistingFileName,
     LPCSTR lpNewFileName
    );
__declspec(dllimport)
BOOL
__stdcall
MoveFileW(
     LPCWSTR lpExistingFileName,
     LPCWSTR lpNewFileName
    );




#line 5665 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winbase.h"



















#line 5685 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winbase.h"

#line 5687 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winbase.h"
#pragma endregion

#pragma region Application Family or OneCore Family or Games Family


__declspec(dllimport)
BOOL
__stdcall
MoveFileExA(
         LPCSTR lpExistingFileName,
     LPCSTR lpNewFileName,
         DWORD    dwFlags
    );
__declspec(dllimport)
BOOL
__stdcall
MoveFileExW(
         LPCWSTR lpExistingFileName,
     LPCWSTR lpNewFileName,
         DWORD    dwFlags
    );




#line 5713 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winbase.h"

#line 5715 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winbase.h"
#pragma endregion

#pragma region Desktop Family or OneCore Family



__declspec(dllimport)
BOOL
__stdcall
MoveFileWithProgressA(
         LPCSTR lpExistingFileName,
     LPCSTR lpNewFileName,
     LPPROGRESS_ROUTINE lpProgressRoutine,
     LPVOID lpData,
         DWORD dwFlags
    );
__declspec(dllimport)
BOOL
__stdcall
MoveFileWithProgressW(
         LPCWSTR lpExistingFileName,
     LPCWSTR lpNewFileName,
     LPPROGRESS_ROUTINE lpProgressRoutine,
     LPVOID lpData,
         DWORD dwFlags
    );




#line 5746 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winbase.h"
#line 5747 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winbase.h"

#line 5749 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winbase.h"
#pragma endregion

#pragma region Desktop Family



__declspec(dllimport)
BOOL
__stdcall
MoveFileTransactedA(
         LPCSTR lpExistingFileName,
     LPCSTR lpNewFileName,
     LPPROGRESS_ROUTINE lpProgressRoutine,
     LPVOID lpData,
         DWORD dwFlags,
         HANDLE hTransaction
    );
__declspec(dllimport)
BOOL
__stdcall
MoveFileTransactedW(
         LPCWSTR lpExistingFileName,
     LPCWSTR lpNewFileName,
     LPPROGRESS_ROUTINE lpProgressRoutine,
     LPVOID lpData,
         DWORD dwFlags,
         HANDLE hTransaction
    );




#line 5782 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winbase.h"
#line 5783 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winbase.h"

#line 5785 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winbase.h"
#pragma endregion

#pragma region Application Family









#line 5798 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winbase.h"

#line 5800 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winbase.h"
#pragma endregion

#pragma region Desktop Family



#line 5807 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winbase.h"
#pragma endregion

#pragma region Application Family




__declspec(dllimport)
BOOL
__stdcall
ReplaceFileA(
           LPCSTR lpReplacedFileName,
           LPCSTR lpReplacementFileName,
       LPCSTR lpBackupFileName,
           DWORD    dwReplaceFlags,
     LPVOID   lpExclude,
     LPVOID  lpReserved
    );
__declspec(dllimport)
BOOL
__stdcall
ReplaceFileW(
           LPCWSTR lpReplacedFileName,
           LPCWSTR lpReplacementFileName,
       LPCWSTR lpBackupFileName,
           DWORD    dwReplaceFlags,
     LPVOID   lpExclude,
     LPVOID  lpReserved
    );




#line 5841 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winbase.h"
#line 5842 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winbase.h"

#line 5844 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winbase.h"
#pragma endregion

#pragma region Desktop Family or OneCore Family



//
// API call to create hard links.
//

__declspec(dllimport)
BOOL
__stdcall
CreateHardLinkA(
           LPCSTR lpFileName,
           LPCSTR lpExistingFileName,
     LPSECURITY_ATTRIBUTES lpSecurityAttributes
    );
__declspec(dllimport)
BOOL
__stdcall
CreateHardLinkW(
           LPCWSTR lpFileName,
           LPCWSTR lpExistingFileName,
     LPSECURITY_ATTRIBUTES lpSecurityAttributes
    );




#line 5875 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winbase.h"

#line 5877 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winbase.h"

#line 5879 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winbase.h"
#pragma endregion

#pragma region Desktop Family



//
// API call to create hard links.
//

__declspec(dllimport)
BOOL
__stdcall
CreateHardLinkTransactedA(
           LPCSTR lpFileName,
           LPCSTR lpExistingFileName,
     LPSECURITY_ATTRIBUTES lpSecurityAttributes,
           HANDLE hTransaction
    );
__declspec(dllimport)
BOOL
__stdcall
CreateHardLinkTransactedW(
           LPCWSTR lpFileName,
           LPCWSTR lpExistingFileName,
     LPSECURITY_ATTRIBUTES lpSecurityAttributes,
           HANDLE hTransaction
    );




#line 5912 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winbase.h"

#line 5914 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winbase.h"



__declspec(dllimport)
HANDLE
__stdcall
FindFirstStreamTransactedW (
           LPCWSTR lpFileName,
           STREAM_INFO_LEVELS InfoLevel,
     LPVOID lpFindStreamData,
     DWORD dwFlags,
           HANDLE hTransaction
    );

__declspec(dllimport)
HANDLE
__stdcall
FindFirstFileNameTransactedW (
         LPCWSTR lpFileName,
         DWORD dwFlags,
      LPDWORD StringLength,
     PWSTR LinkName,
     HANDLE hTransaction
    );

#line 5940 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winbase.h"

#line 5942 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winbase.h"
#pragma endregion

#pragma region Application Family or OneCore Family


__declspec(dllimport)
HANDLE
__stdcall
CreateNamedPipeA(
         LPCSTR lpName,
         DWORD dwOpenMode,
         DWORD dwPipeMode,
         DWORD nMaxInstances,
         DWORD nOutBufferSize,
         DWORD nInBufferSize,
         DWORD nDefaultTimeOut,
     LPSECURITY_ATTRIBUTES lpSecurityAttributes
    );


#line 5963 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winbase.h"

#line 5965 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winbase.h"
#pragma endregion

#pragma region Desktop Family or OneCore Family


__declspec(dllimport)
BOOL
__stdcall
GetNamedPipeHandleStateA(
          HANDLE hNamedPipe,
     LPDWORD lpState,
     LPDWORD lpCurInstances,
     LPDWORD lpMaxCollectionCount,
     LPDWORD lpCollectDataTimeout,
     LPSTR lpUserName,
          DWORD nMaxUserNameSize
    );


#line 5985 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winbase.h"

__declspec(dllimport)
BOOL
__stdcall
CallNamedPipeA(
      LPCSTR lpNamedPipeName,
     LPVOID lpInBuffer,
      DWORD nInBufferSize,
     LPVOID lpOutBuffer,
      DWORD nOutBufferSize,
     LPDWORD lpBytesRead,
      DWORD nTimeOut
    );



#line 6002 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winbase.h"

__declspec(dllimport)
BOOL
__stdcall
WaitNamedPipeA(
     LPCSTR lpNamedPipeName,
     DWORD nTimeOut
    );


#line 6013 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winbase.h"

#line 6015 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winbase.h"
#pragma endregion



#pragma region Desktop Family



#line 6024 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winbase.h"
#pragma endregion

#pragma region Desktop Family or OneCore Family


__declspec(dllimport)
BOOL
__stdcall
GetNamedPipeClientComputerNameA(
     HANDLE Pipe,
      LPSTR ClientComputerName,
     ULONG ClientComputerNameLength
    );



#line 6041 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winbase.h"

#line 6043 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winbase.h"
#pragma endregion

#pragma region Desktop Family


__declspec(dllimport)
BOOL
__stdcall
GetNamedPipeClientProcessId(
     HANDLE Pipe,
     PULONG ClientProcessId
    );

__declspec(dllimport)
BOOL
__stdcall
GetNamedPipeClientSessionId(
     HANDLE Pipe,
     PULONG ClientSessionId
    );

__declspec(dllimport)
BOOL
__stdcall
GetNamedPipeServerProcessId(
     HANDLE Pipe,
     PULONG ServerProcessId
    );

__declspec(dllimport)
BOOL
__stdcall
GetNamedPipeServerSessionId(
     HANDLE Pipe,
     PULONG ServerSessionId
    );

#line 6081 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winbase.h"
#pragma endregion

#line 6084 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winbase.h"

#pragma region Application Family or Desktop Family


__declspec(dllimport)
BOOL
__stdcall
SetVolumeLabelA(
     LPCSTR lpRootPathName,
     LPCSTR lpVolumeName
    );
__declspec(dllimport)
BOOL
__stdcall
SetVolumeLabelW(
     LPCWSTR lpRootPathName,
     LPCWSTR lpVolumeName
    );




#line 6107 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winbase.h"

#line 6109 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winbase.h"
#pragma endregion

#pragma region Desktop Family





__declspec(dllimport)
BOOL
__stdcall
SetFileBandwidthReservation(
      HANDLE  hFile,
      DWORD   nPeriodMilliseconds,
      DWORD   nBytesPerPeriod,
      BOOL    bDiscardable,
     LPDWORD lpTransferSize,
     LPDWORD lpNumOutstandingRequests
    );

__declspec(dllimport)
BOOL
__stdcall
GetFileBandwidthReservation(
      HANDLE  hFile,
     LPDWORD lpPeriodMilliseconds,
     LPDWORD lpBytesPerPeriod,
     LPBOOL  pDiscardable,
     LPDWORD lpTransferSize,
     LPDWORD lpNumOutstandingRequests
    );

#line 6142 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winbase.h"

//
// Event logging APIs
//

__declspec(dllimport)
BOOL
__stdcall
ClearEventLogA (
         HANDLE hEventLog,
     LPCSTR lpBackupFileName
    );
__declspec(dllimport)
BOOL
__stdcall
ClearEventLogW (
         HANDLE hEventLog,
     LPCWSTR lpBackupFileName
    );




#line 6166 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winbase.h"

__declspec(dllimport)
BOOL
__stdcall
BackupEventLogA (
     HANDLE hEventLog,
     LPCSTR lpBackupFileName
    );
__declspec(dllimport)
BOOL
__stdcall
BackupEventLogW (
     HANDLE hEventLog,
     LPCWSTR lpBackupFileName
    );




#line 6186 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winbase.h"

__declspec(dllimport)
BOOL
__stdcall
CloseEventLog (
     HANDLE hEventLog
    );

__declspec(dllimport)
BOOL
__stdcall
DeregisterEventSource (
     HANDLE hEventLog
    );

__declspec(dllimport)
BOOL
__stdcall
NotifyChangeEventLog(
     HANDLE  hEventLog,
     HANDLE  hEvent
    );

__declspec(dllimport)
BOOL
__stdcall
GetNumberOfEventLogRecords (
      HANDLE hEventLog,
     PDWORD NumberOfRecords
    );

__declspec(dllimport)
BOOL
__stdcall
GetOldestEventLogRecord (
      HANDLE hEventLog,
     PDWORD OldestRecord
    );

__declspec(dllimport)
HANDLE
__stdcall
OpenEventLogA (
     LPCSTR lpUNCServerName,
         LPCSTR lpSourceName
    );
__declspec(dllimport)
HANDLE
__stdcall
OpenEventLogW (
     LPCWSTR lpUNCServerName,
         LPCWSTR lpSourceName
    );




#line 6244 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winbase.h"

__declspec(dllimport)
HANDLE
__stdcall
RegisterEventSourceA (
     LPCSTR lpUNCServerName,
         LPCSTR lpSourceName
    );
__declspec(dllimport)
HANDLE
__stdcall
RegisterEventSourceW (
     LPCWSTR lpUNCServerName,
         LPCWSTR lpSourceName
    );




#line 6264 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winbase.h"

__declspec(dllimport)
HANDLE
__stdcall
OpenBackupEventLogA (
     LPCSTR lpUNCServerName,
         LPCSTR lpFileName
    );
__declspec(dllimport)
HANDLE
__stdcall
OpenBackupEventLogW (
     LPCWSTR lpUNCServerName,
         LPCWSTR lpFileName
    );




#line 6284 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winbase.h"

__declspec(dllimport)
BOOL
__stdcall
ReadEventLogA (
      HANDLE     hEventLog,
      DWORD      dwReadFlags,
      DWORD      dwRecordOffset,
     LPVOID     lpBuffer,
      DWORD      nNumberOfBytesToRead,
     DWORD      *pnBytesRead,
     DWORD      *pnMinNumberOfBytesNeeded
    );
__declspec(dllimport)
BOOL
__stdcall
ReadEventLogW (
      HANDLE     hEventLog,
      DWORD      dwReadFlags,
      DWORD      dwRecordOffset,
     LPVOID     lpBuffer,
      DWORD      nNumberOfBytesToRead,
     DWORD      *pnBytesRead,
     DWORD      *pnMinNumberOfBytesNeeded
    );




#line 6314 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winbase.h"

__declspec(dllimport)
BOOL
__stdcall
ReportEventA (
         HANDLE     hEventLog,
         WORD       wType,
         WORD       wCategory,
         DWORD      dwEventID,
     PSID       lpUserSid,
         WORD       wNumStrings,
         DWORD      dwDataSize,
     LPCSTR *lpStrings,
     LPVOID lpRawData
    );
__declspec(dllimport)
BOOL
__stdcall
ReportEventW (
         HANDLE     hEventLog,
         WORD       wType,
         WORD       wCategory,
         DWORD      dwEventID,
     PSID       lpUserSid,
         WORD       wNumStrings,
         DWORD      dwDataSize,
     LPCWSTR *lpStrings,
     LPVOID lpRawData
    );




#line 6348 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winbase.h"




typedef struct _EVENTLOG_FULL_INFORMATION
{
    DWORD    dwFull;
}
EVENTLOG_FULL_INFORMATION, *LPEVENTLOG_FULL_INFORMATION;

__declspec(dllimport)
BOOL
__stdcall
GetEventLogInformation (
      HANDLE     hEventLog,
      DWORD      dwInfoLevel,
     LPVOID lpBuffer,
      DWORD      cbBufSize,
     LPDWORD    pcbBytesNeeded
    );
















































#line 6417 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winbase.h"

//
//
// Security APIs
//


__declspec(dllimport)
BOOL
__stdcall
AccessCheckAndAuditAlarmA (
         LPCSTR SubsystemName,
     LPVOID HandleId,
         LPSTR ObjectTypeName,
     LPSTR ObjectName,
         PSECURITY_DESCRIPTOR SecurityDescriptor,
         DWORD DesiredAccess,
         PGENERIC_MAPPING GenericMapping,
         BOOL ObjectCreation,
        LPDWORD GrantedAccess,
        LPBOOL AccessStatus,
        LPBOOL pfGenerateOnClose
    );


#line 6443 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winbase.h"



__declspec(dllimport)
BOOL
__stdcall
AccessCheckByTypeAndAuditAlarmA (
         LPCSTR SubsystemName,
         LPVOID HandleId,
         LPCSTR ObjectTypeName,
     LPCSTR ObjectName,
         PSECURITY_DESCRIPTOR SecurityDescriptor,
     PSID PrincipalSelfSid,
         DWORD DesiredAccess,
         AUDIT_EVENT_TYPE AuditType,
         DWORD Flags,
     POBJECT_TYPE_LIST ObjectTypeList,
         DWORD ObjectTypeListLength,
         PGENERIC_MAPPING GenericMapping,
         BOOL ObjectCreation,
        LPDWORD GrantedAccess,
        LPBOOL AccessStatus,
        LPBOOL pfGenerateOnClose
    );


#line 6470 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winbase.h"

__declspec(dllimport)
BOOL
__stdcall
AccessCheckByTypeResultListAndAuditAlarmA (
         LPCSTR SubsystemName,
         LPVOID HandleId,
         LPCSTR ObjectTypeName,
     LPCSTR ObjectName,
         PSECURITY_DESCRIPTOR SecurityDescriptor,
     PSID PrincipalSelfSid,
         DWORD DesiredAccess,
         AUDIT_EVENT_TYPE AuditType,
         DWORD Flags,
     POBJECT_TYPE_LIST ObjectTypeList,
         DWORD ObjectTypeListLength,
         PGENERIC_MAPPING GenericMapping,
         BOOL ObjectCreation,
           LPDWORD GrantedAccess,
           LPDWORD AccessStatusList,
        LPBOOL pfGenerateOnClose
    );


#line 6495 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winbase.h"

__declspec(dllimport)
BOOL
__stdcall
AccessCheckByTypeResultListAndAuditAlarmByHandleA (
         LPCSTR SubsystemName,
         LPVOID HandleId,
         HANDLE ClientToken,
         LPCSTR ObjectTypeName,
     LPCSTR ObjectName,
         PSECURITY_DESCRIPTOR SecurityDescriptor,
     PSID PrincipalSelfSid,
         DWORD DesiredAccess,
         AUDIT_EVENT_TYPE AuditType,
         DWORD Flags,
     POBJECT_TYPE_LIST ObjectTypeList,
         DWORD ObjectTypeListLength,
         PGENERIC_MAPPING GenericMapping,
         BOOL ObjectCreation,
           LPDWORD GrantedAccess,
           LPDWORD AccessStatusList,
        LPBOOL pfGenerateOnClose
    );


#line 6521 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winbase.h"
#line 6522 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winbase.h"

__declspec(dllimport)
BOOL
__stdcall
ObjectOpenAuditAlarmA (
         LPCSTR SubsystemName,
         LPVOID HandleId,
         LPSTR ObjectTypeName,
     LPSTR ObjectName,
         PSECURITY_DESCRIPTOR pSecurityDescriptor,
         HANDLE ClientToken,
         DWORD DesiredAccess,
         DWORD GrantedAccess,
     PPRIVILEGE_SET Privileges,
         BOOL ObjectCreation,
         BOOL AccessGranted,
        LPBOOL GenerateOnClose
    );


#line 6543 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winbase.h"

__declspec(dllimport)
BOOL
__stdcall
ObjectPrivilegeAuditAlarmA (
     LPCSTR SubsystemName,
     LPVOID HandleId,
     HANDLE ClientToken,
     DWORD DesiredAccess,
     PPRIVILEGE_SET Privileges,
     BOOL AccessGranted
    );


#line 6558 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winbase.h"

__declspec(dllimport)
BOOL
__stdcall
ObjectCloseAuditAlarmA (
     LPCSTR SubsystemName,
     LPVOID HandleId,
     BOOL GenerateOnClose
    );


#line 6570 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winbase.h"

__declspec(dllimport)
BOOL
__stdcall
ObjectDeleteAuditAlarmA (
     LPCSTR SubsystemName,
     LPVOID HandleId,
     BOOL GenerateOnClose
    );


#line 6582 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winbase.h"

__declspec(dllimport)
BOOL
__stdcall
PrivilegedServiceAuditAlarmA (
     LPCSTR SubsystemName,
     LPCSTR ServiceName,
     HANDLE ClientToken,
     PPRIVILEGE_SET Privileges,
     BOOL AccessGranted
    );


#line 6596 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winbase.h"


__declspec(dllimport)
BOOL
__stdcall
AddConditionalAce (
     PACL pAcl,
        DWORD dwAceRevision,
        DWORD AceFlags,
        UCHAR AceType,
        DWORD AccessMask,
        PSID pSid,
      PWCHAR ConditionStr,
     DWORD *ReturnLength
    );
#line 6612 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winbase.h"

#line 6614 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winbase.h"
#pragma endregion

#pragma region Desktop Family or OneCore Family


__declspec(dllimport)
BOOL
__stdcall
SetFileSecurityA (
     LPCSTR lpFileName,
     SECURITY_INFORMATION SecurityInformation,
     PSECURITY_DESCRIPTOR pSecurityDescriptor
    );


#line 6630 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winbase.h"

__declspec(dllimport)
BOOL
__stdcall
GetFileSecurityA (
      LPCSTR lpFileName,
      SECURITY_INFORMATION RequestedInformation,
     PSECURITY_DESCRIPTOR pSecurityDescriptor,
      DWORD nLength,
     LPDWORD lpnLengthNeeded
    );


#line 6644 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winbase.h"

#line 6646 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winbase.h"
#pragma endregion

#pragma region Application Family or OneCore Family



__declspec(dllimport)
BOOL
__stdcall
ReadDirectoryChangesW(
            HANDLE hDirectory,
     LPVOID lpBuffer,
            DWORD nBufferLength,
            BOOL bWatchSubtree,
            DWORD dwNotifyFilter,
       LPDWORD lpBytesReturned,
     LPOVERLAPPED lpOverlapped,
        LPOVERLAPPED_COMPLETION_ROUTINE lpCompletionRoutine
    );
















#line 6682 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winbase.h"
#line 6683 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winbase.h"

#line 6685 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winbase.h"
#pragma endregion

#pragma region Desktop Family




__declspec(dllimport)
 
LPVOID
__stdcall
MapViewOfFileExNuma(
         HANDLE hFileMappingObject,
         DWORD dwDesiredAccess,
         DWORD dwFileOffsetHigh,
         DWORD dwFileOffsetLow,
         SIZE_T dwNumberOfBytesToMap,
     LPVOID lpBaseAddress,
         DWORD nndPreferred
    );

#line 6707 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winbase.h"

__declspec(dllimport)
BOOL
__stdcall
IsBadReadPtr(
     const void *lp,
         UINT_PTR ucb
    );

__declspec(dllimport)
BOOL
__stdcall
IsBadWritePtr(
     LPVOID lp,
         UINT_PTR ucb
    );

__declspec(dllimport)
BOOL
__stdcall
IsBadHugeReadPtr(
     const void *lp,
         UINT_PTR ucb
    );

__declspec(dllimport)
BOOL
__stdcall
IsBadHugeWritePtr(
     LPVOID lp,
         UINT_PTR ucb
    );

__declspec(dllimport)
BOOL
__stdcall
IsBadCodePtr(
     FARPROC lpfn
    );

__declspec(dllimport)
BOOL
__stdcall
IsBadStringPtrA(
     LPCSTR lpsz,
         UINT_PTR ucchMax
    );
__declspec(dllimport)
BOOL
__stdcall
IsBadStringPtrW(
     LPCWSTR lpsz,
         UINT_PTR ucchMax
    );




#line 6766 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winbase.h"

#line 6768 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winbase.h"
#pragma endregion

#pragma region Application Family or OneCore Family


__declspec(dllimport)
 BOOL
__stdcall
LookupAccountSidA(
     LPCSTR lpSystemName,
     PSID Sid,
     LPSTR Name,
      LPDWORD cchName,
     LPSTR ReferencedDomainName,
     LPDWORD cchReferencedDomainName,
     PSID_NAME_USE peUse
    );
__declspec(dllimport)
 BOOL
__stdcall
LookupAccountSidW(
     LPCWSTR lpSystemName,
     PSID Sid,
     LPWSTR Name,
      LPDWORD cchName,
     LPWSTR ReferencedDomainName,
     LPDWORD cchReferencedDomainName,
     PSID_NAME_USE peUse
    );




#line 6802 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winbase.h"

__declspec(dllimport)
 BOOL
__stdcall
LookupAccountNameA(
     LPCSTR lpSystemName,
         LPCSTR lpAccountName,
     PSID Sid,
      LPDWORD cbSid,
     LPSTR ReferencedDomainName,
      LPDWORD cchReferencedDomainName,
        PSID_NAME_USE peUse
    );
__declspec(dllimport)
 BOOL
__stdcall
LookupAccountNameW(
     LPCWSTR lpSystemName,
         LPCWSTR lpAccountName,
     PSID Sid,
      LPDWORD cbSid,
     LPWSTR ReferencedDomainName,
      LPDWORD cchReferencedDomainName,
        PSID_NAME_USE peUse
    );




#line 6832 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winbase.h"

#line 6834 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winbase.h"
#pragma endregion

#pragma region Desktop Family




__declspec(dllimport)
 BOOL
__stdcall
LookupAccountNameLocalA(
         LPCSTR lpAccountName,
     PSID Sid,
      LPDWORD cbSid,
     LPSTR ReferencedDomainName,
      LPDWORD cchReferencedDomainName,
        PSID_NAME_USE peUse
    );
__declspec(dllimport)
 BOOL
__stdcall
LookupAccountNameLocalW(
         LPCWSTR lpAccountName,
     PSID Sid,
      LPDWORD cbSid,
     LPWSTR ReferencedDomainName,
      LPDWORD cchReferencedDomainName,
        PSID_NAME_USE peUse
    );




#line 6868 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winbase.h"

__declspec(dllimport)
 BOOL
__stdcall
LookupAccountSidLocalA(
     PSID Sid,
     LPSTR Name,
      LPDWORD cchName,
     LPSTR ReferencedDomainName,
     LPDWORD cchReferencedDomainName,
     PSID_NAME_USE peUse
    );
__declspec(dllimport)
 BOOL
__stdcall
LookupAccountSidLocalW(
     PSID Sid,
     LPWSTR Name,
      LPDWORD cchName,
     LPWSTR ReferencedDomainName,
     LPDWORD cchReferencedDomainName,
     PSID_NAME_USE peUse
    );




#line 6896 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winbase.h"























#line 6920 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winbase.h"

#line 6922 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winbase.h"
#pragma endregion

#pragma region Application Family or OneCore Family


__declspec(dllimport)
BOOL
__stdcall
LookupPrivilegeValueA(
     LPCSTR lpSystemName,
         LPCSTR lpName,
        PLUID   lpLuid
    );
__declspec(dllimport)
BOOL
__stdcall
LookupPrivilegeValueW(
     LPCWSTR lpSystemName,
         LPCWSTR lpName,
        PLUID   lpLuid
    );




#line 6948 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winbase.h"

__declspec(dllimport)
 BOOL
__stdcall
LookupPrivilegeNameA(
     LPCSTR lpSystemName,
         PLUID   lpLuid,
     LPSTR lpName,
      LPDWORD cchName
    );
__declspec(dllimport)
 BOOL
__stdcall
LookupPrivilegeNameW(
     LPCWSTR lpSystemName,
         PLUID   lpLuid,
     LPWSTR lpName,
      LPDWORD cchName
    );




#line 6972 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winbase.h"

__declspec(dllimport)
 BOOL
__stdcall
LookupPrivilegeDisplayNameA(
     LPCSTR lpSystemName,
         LPCSTR lpName,
     LPSTR lpDisplayName,
      LPDWORD cchDisplayName,
        LPDWORD lpLanguageId
    );
__declspec(dllimport)
 BOOL
__stdcall
LookupPrivilegeDisplayNameW(
     LPCWSTR lpSystemName,
         LPCWSTR lpName,
     LPWSTR lpDisplayName,
      LPDWORD cchDisplayName,
        LPDWORD lpLanguageId
    );




#line 6998 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winbase.h"

#line 7000 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winbase.h"
#pragma endregion

#pragma region Desktop Family


__declspec(dllimport)
BOOL
__stdcall
BuildCommDCBA(
      LPCSTR lpDef,
     LPDCB lpDCB
    );
__declspec(dllimport)
BOOL
__stdcall
BuildCommDCBW(
      LPCWSTR lpDef,
     LPDCB lpDCB
    );




#line 7024 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winbase.h"

__declspec(dllimport)
BOOL
__stdcall
BuildCommDCBAndTimeoutsA(
      LPCSTR lpDef,
     LPDCB lpDCB,
     LPCOMMTIMEOUTS lpCommTimeouts
    );
__declspec(dllimport)
BOOL
__stdcall
BuildCommDCBAndTimeoutsW(
      LPCWSTR lpDef,
     LPDCB lpDCB,
     LPCOMMTIMEOUTS lpCommTimeouts
    );




#line 7046 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winbase.h"

__declspec(dllimport)
BOOL
__stdcall
CommConfigDialogA(
         LPCSTR lpszName,
     HWND hWnd,
      LPCOMMCONFIG lpCC
    );
__declspec(dllimport)
BOOL
__stdcall
CommConfigDialogW(
         LPCWSTR lpszName,
     HWND hWnd,
      LPCOMMCONFIG lpCC
    );




#line 7068 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winbase.h"

__declspec(dllimport)
BOOL
__stdcall
GetDefaultCommConfigA(
        LPCSTR lpszName,
     LPCOMMCONFIG lpCC,
     LPDWORD lpdwSize
    );
__declspec(dllimport)
BOOL
__stdcall
GetDefaultCommConfigW(
        LPCWSTR lpszName,
     LPCOMMCONFIG lpCC,
     LPDWORD lpdwSize
    );




#line 7090 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winbase.h"

__declspec(dllimport)
BOOL
__stdcall
SetDefaultCommConfigA(
     LPCSTR lpszName,
     LPCOMMCONFIG lpCC,
     DWORD dwSize
    );
__declspec(dllimport)
BOOL
__stdcall
SetDefaultCommConfigW(
     LPCWSTR lpszName,
     LPCOMMCONFIG lpCC,
     DWORD dwSize
    );




#line 7112 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winbase.h"

#line 7114 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winbase.h"
#pragma endregion

#pragma region Application Family or OneCore Family






#line 7124 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winbase.h"

__declspec(dllimport)

BOOL
__stdcall
GetComputerNameA (
     LPSTR lpBuffer,
     LPDWORD nSize
    );
__declspec(dllimport)

BOOL
__stdcall
GetComputerNameW (
     LPWSTR lpBuffer,
     LPDWORD nSize
    );




#line 7146 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winbase.h"

#line 7148 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winbase.h"
#pragma endregion

#pragma region Desktop Family





__declspec(dllimport)

BOOL
__stdcall
DnsHostnameToComputerNameA (
        LPCSTR Hostname,
     LPSTR ComputerName,
     LPDWORD nSize
    );
__declspec(dllimport)

BOOL
__stdcall
DnsHostnameToComputerNameW (
        LPCWSTR Hostname,
     LPWSTR ComputerName,
     LPDWORD nSize
    );




#line 7179 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winbase.h"

#line 7181 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winbase.h"

__declspec(dllimport)
BOOL
__stdcall
GetUserNameA (
     LPSTR lpBuffer,
     LPDWORD pcbBuffer
    );
__declspec(dllimport)
BOOL
__stdcall
GetUserNameW (
     LPWSTR lpBuffer,
     LPDWORD pcbBuffer
    );




#line 7201 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winbase.h"

//
// Logon Support APIs
//









#line 7215 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winbase.h"





#line 7221 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winbase.h"


#line 7224 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winbase.h"


#line 7227 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winbase.h"



__declspec(dllimport)
BOOL
__stdcall
LogonUserA (
            LPCSTR lpszUsername,
        LPCSTR lpszDomain,
        LPCSTR lpszPassword,
            DWORD dwLogonType,
            DWORD dwLogonProvider,
     PHANDLE phToken
    );
__declspec(dllimport)
BOOL
__stdcall
LogonUserW (
            LPCWSTR lpszUsername,
        LPCWSTR lpszDomain,
        LPCWSTR lpszPassword,
            DWORD dwLogonType,
            DWORD dwLogonProvider,
     PHANDLE phToken
    );




#line 7257 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winbase.h"

__declspec(dllimport)
BOOL
__stdcall
LogonUserExA (
                LPCSTR lpszUsername,
            LPCSTR lpszDomain,
            LPCSTR lpszPassword,
                DWORD dwLogonType,
                DWORD dwLogonProvider,
     PHANDLE phToken,
     PSID  *ppLogonSid,
     PVOID *ppProfileBuffer,
           LPDWORD pdwProfileLength,
           PQUOTA_LIMITS pQuotaLimits
    );
__declspec(dllimport)
BOOL
__stdcall
LogonUserExW (
                LPCWSTR lpszUsername,
            LPCWSTR lpszDomain,
            LPCWSTR lpszPassword,
                DWORD dwLogonType,
                DWORD dwLogonProvider,
     PHANDLE phToken,
     PSID  *ppLogonSid,
     PVOID *ppProfileBuffer,
           LPDWORD pdwProfileLength,
           PQUOTA_LIMITS pQuotaLimits
    );




#line 7293 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winbase.h"

#line 7295 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winbase.h"
#pragma endregion




#line 7301 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winbase.h"

#pragma region Desktop Family




//
// LogonFlags
//




//@[comment("MVI_tracked")]
__declspec(dllimport)
 BOOL
__stdcall
CreateProcessWithLogonW(
            LPCWSTR lpUsername,
        LPCWSTR lpDomain,
            LPCWSTR lpPassword,
            DWORD dwLogonFlags,
        LPCWSTR lpApplicationName,
     LPWSTR lpCommandLine,
            DWORD dwCreationFlags,
        LPVOID lpEnvironment,
        LPCWSTR lpCurrentDirectory,
            LPSTARTUPINFOW lpStartupInfo,
           LPPROCESS_INFORMATION lpProcessInformation
      );

__declspec(dllimport)
 BOOL
__stdcall
CreateProcessWithTokenW(
            HANDLE hToken,
            DWORD dwLogonFlags,
        LPCWSTR lpApplicationName,
     LPWSTR lpCommandLine,
            DWORD dwCreationFlags,
        LPVOID lpEnvironment,
        LPCWSTR lpCurrentDirectory,
            LPSTARTUPINFOW lpStartupInfo,
           LPPROCESS_INFORMATION lpProcessInformation
      );

#line 7348 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winbase.h"

__declspec(dllimport)
BOOL
__stdcall
IsTokenUntrusted(
     HANDLE TokenHandle
    );

#line 7357 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winbase.h"

#pragma region Desktop or Games Family


//
// Thread pool API's
//



__declspec(dllimport)
BOOL
__stdcall
RegisterWaitForSingleObject(
     PHANDLE phNewWaitObject,
            HANDLE hObject,
            WAITORTIMERCALLBACK Callback,
        PVOID Context,
            ULONG dwMilliseconds,
            ULONG dwFlags
    );

__declspec(dllimport)

BOOL
__stdcall
UnregisterWait(
     HANDLE WaitHandle
    );

__declspec(dllimport)
BOOL
__stdcall
BindIoCompletionCallback (
     HANDLE FileHandle,
     LPOVERLAPPED_COMPLETION_ROUTINE Function,
     ULONG Flags
    );

__declspec(dllimport)
HANDLE
__stdcall
SetTimerQueueTimer(
     HANDLE TimerQueue,
         WAITORTIMERCALLBACK Callback,
     PVOID Parameter,
         DWORD DueTime,
         DWORD Period,
         BOOL PreferIo
    );

__declspec(dllimport)

BOOL
__stdcall
CancelTimerQueueTimer(
     HANDLE TimerQueue,
         HANDLE Timer
    );

__declspec(dllimport)

BOOL
__stdcall
DeleteTimerQueue(
     HANDLE TimerQueue
    );

#line 7426 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winbase.h"

#line 7428 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winbase.h"









__forceinline
void
InitializeThreadpoolEnvironment(
     PTP_CALLBACK_ENVIRON pcbe
    )
{
    TpInitializeCallbackEnviron(pcbe);
}

__forceinline
void
SetThreadpoolCallbackPool(
     PTP_CALLBACK_ENVIRON pcbe,
        PTP_POOL             ptpp
    )
{
    TpSetCallbackThreadpool(pcbe, ptpp);
}

__forceinline
void
SetThreadpoolCallbackCleanupGroup(
      PTP_CALLBACK_ENVIRON              pcbe,
         PTP_CLEANUP_GROUP                 ptpcg,
     PTP_CLEANUP_GROUP_CANCEL_CALLBACK pfng
    )
{
    TpSetCallbackCleanupGroup(pcbe, ptpcg, pfng);
}

__forceinline
void
SetThreadpoolCallbackRunsLong(
     PTP_CALLBACK_ENVIRON pcbe
    )
{
    TpSetCallbackLongFunction(pcbe);
}

__forceinline
void
SetThreadpoolCallbackLibrary(
     PTP_CALLBACK_ENVIRON pcbe,
        PVOID                mod
    )
{
    TpSetCallbackRaceWithDll(pcbe, mod);
}



__forceinline
void
SetThreadpoolCallbackPriority(
     PTP_CALLBACK_ENVIRON pcbe,
        TP_CALLBACK_PRIORITY Priority
    )
{
    TpSetCallbackPriority(pcbe, Priority);
}

#line 7499 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winbase.h"

__forceinline
void
DestroyThreadpoolEnvironment(
     PTP_CALLBACK_ENVIRON pcbe
    )
{
    TpDestroyCallbackEnviron(pcbe);
}

#line 7510 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winbase.h"

#line 7512 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winbase.h"

#line 7514 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winbase.h"

#line 7516 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winbase.h"



#pragma region Desktop Family




__forceinline
void
SetThreadpoolCallbackPersistent(
     PTP_CALLBACK_ENVIRON pcbe
    )
{
    TpSetCallbackPersistent(pcbe);
}

#line 7534 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winbase.h"

#line 7536 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winbase.h"
#pragma endregion

#pragma region Application Family or OneCore Family


//
//  Private Namespaces support
//

__declspec(dllimport)

HANDLE
__stdcall
CreatePrivateNamespaceA(
     LPSECURITY_ATTRIBUTES lpPrivateNamespaceAttributes,
         LPVOID lpBoundaryDescriptor,
         LPCSTR lpAliasPrefix
    );





#line 7560 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winbase.h"

__declspec(dllimport)

HANDLE
__stdcall
OpenPrivateNamespaceA(
         LPVOID lpBoundaryDescriptor,
         LPCSTR lpAliasPrefix
    );





#line 7575 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winbase.h"


//
//  Boundary descriptors support
//

__declspec(dllimport)

HANDLE
__stdcall
CreateBoundaryDescriptorA(
     LPCSTR Name,
     ULONG Flags
    );





#line 7595 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winbase.h"

#line 7597 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winbase.h"
#pragma endregion

#pragma region Desktop Family


__declspec(dllimport)
BOOL
__stdcall
AddIntegrityLabelToBoundaryDescriptor(
     HANDLE * BoundaryDescriptor,
     PSID IntegrityLabel
    );

#line 7611 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winbase.h"
#pragma endregion

#line 7614 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winbase.h"

#pragma region Desktop Family



//
// Plug-and-Play API's
//










typedef struct tagHW_PROFILE_INFOA {
    DWORD  dwDockInfo;
    CHAR   szHwProfileGuid[39 ];
    CHAR   szHwProfileName[80 ];
} HW_PROFILE_INFOA, *LPHW_PROFILE_INFOA;
typedef struct tagHW_PROFILE_INFOW {
    DWORD  dwDockInfo;
    WCHAR  szHwProfileGuid[39 ];
    WCHAR  szHwProfileName[80 ];
} HW_PROFILE_INFOW, *LPHW_PROFILE_INFOW;




typedef HW_PROFILE_INFOA HW_PROFILE_INFO;
typedef LPHW_PROFILE_INFOA LPHW_PROFILE_INFO;
#line 7649 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winbase.h"


__declspec(dllimport)
BOOL
__stdcall
GetCurrentHwProfileA (
     LPHW_PROFILE_INFOA  lpHwProfileInfo
    );
__declspec(dllimport)
BOOL
__stdcall
GetCurrentHwProfileW (
     LPHW_PROFILE_INFOW  lpHwProfileInfo
    );




#line 7668 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winbase.h"
#line 7669 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winbase.h"

__declspec(dllimport)
BOOL
__stdcall
VerifyVersionInfoA(
     LPOSVERSIONINFOEXA lpVersionInformation,
        DWORD dwTypeMask,
        DWORDLONG dwlConditionMask
    );
__declspec(dllimport)
BOOL
__stdcall
VerifyVersionInfoW(
     LPOSVERSIONINFOEXW lpVersionInformation,
        DWORD dwTypeMask,
        DWORDLONG dwlConditionMask
    );




#line 7691 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winbase.h"


#line 7694 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winbase.h"
#pragma endregion

// DOS and OS/2 Compatible Error Code definitions returned by the Win32 Base
// API functions.
//

#line 1 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\shared\\winerror.h"
/************************************************************************
*                                                                       *
*   winerror.h --  error code definitions for the Win32 API functions   *
*                                                                       *
*   Copyright (c) Microsoft Corp. All rights reserved.                  *
*                                                                       *
************************************************************************/





#pragma once
#line 15 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\shared\\winerror.h"











//
// Note: There is a slightly modified layout for HRESULT values below,
//        after the heading "COM Error Codes".
//
// Search for "**** Available SYSTEM error codes ****" to find where to
// insert new error codes
//
//  Values are 32 bit values laid out as follows:
//
//   3 3 2 2 2 2 2 2 2 2 2 2 1 1 1 1 1 1 1 1 1 1
//   1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0
//  +---+-+-+-----------------------+-------------------------------+
//  |Sev|C|R|     Facility          |               Code            |
//  +---+-+-+-----------------------+-------------------------------+
//
//  where
//
//      Sev - is the severity code
//
//          00 - Success
//          01 - Informational
//          10 - Warning
//          11 - Error
//
//      C - is the Customer code flag
//
//      R - is a reserved bit
//
//      Facility - is the facility code
//
//      Code - is the facility's status code
//
//
// Define the facility codes
//

















































































































































//
// Define the severity codes
//


//
// MessageId: ERROR_SUCCESS
//
// MessageText:
//
// The operation completed successfully.
//





//
// MessageId: ERROR_INVALID_FUNCTION
//
// MessageText:
//
// Incorrect function.
//


//
// MessageId: ERROR_FILE_NOT_FOUND
//
// MessageText:
//
// The system cannot find the file specified.
//


//
// MessageId: ERROR_PATH_NOT_FOUND
//
// MessageText:
//
// The system cannot find the path specified.
//


//
// MessageId: ERROR_TOO_MANY_OPEN_FILES
//
// MessageText:
//
// The system cannot open the file.
//


//
// MessageId: ERROR_ACCESS_DENIED
//
// MessageText:
//
// Access is denied.
//


//
// MessageId: ERROR_INVALID_HANDLE
//
// MessageText:
//
// The handle is invalid.
//


//
// MessageId: ERROR_ARENA_TRASHED
//
// MessageText:
//
// The storage control blocks were destroyed.
//


//
// MessageId: ERROR_NOT_ENOUGH_MEMORY
//
// MessageText:
//
// Not enough memory resources are available to process this command.
//


//
// MessageId: ERROR_INVALID_BLOCK
//
// MessageText:
//
// The storage control block address is invalid.
//


//
// MessageId: ERROR_BAD_ENVIRONMENT
//
// MessageText:
//
// The environment is incorrect.
//


//
// MessageId: ERROR_BAD_FORMAT
//
// MessageText:
//
// An attempt was made to load a program with an incorrect format.
//


//
// MessageId: ERROR_INVALID_ACCESS
//
// MessageText:
//
// The access code is invalid.
//


//
// MessageId: ERROR_INVALID_DATA
//
// MessageText:
//
// The data is invalid.
//


//
// MessageId: ERROR_OUTOFMEMORY
//
// MessageText:
//
// Not enough memory resources are available to complete this operation.
//


//
// MessageId: ERROR_INVALID_DRIVE
//
// MessageText:
//
// The system cannot find the drive specified.
//


//
// MessageId: ERROR_CURRENT_DIRECTORY
//
// MessageText:
//
// The directory cannot be removed.
//


//
// MessageId: ERROR_NOT_SAME_DEVICE
//
// MessageText:
//
// The system cannot move the file to a different disk drive.
//


//
// MessageId: ERROR_NO_MORE_FILES
//
// MessageText:
//
// There are no more files.
//


//
// MessageId: ERROR_WRITE_PROTECT
//
// MessageText:
//
// The media is write protected.
//


//
// MessageId: ERROR_BAD_UNIT
//
// MessageText:
//
// The system cannot find the device specified.
//


//
// MessageId: ERROR_NOT_READY
//
// MessageText:
//
// The device is not ready.
//


//
// MessageId: ERROR_BAD_COMMAND
//
// MessageText:
//
// The device does not recognize the command.
//


//
// MessageId: ERROR_CRC
//
// MessageText:
//
// Data error (cyclic redundancy check).
//


//
// MessageId: ERROR_BAD_LENGTH
//
// MessageText:
//
// The program issued a command but the command length is incorrect.
//


//
// MessageId: ERROR_SEEK
//
// MessageText:
//
// The drive cannot locate a specific area or track on the disk.
//


//
// MessageId: ERROR_NOT_DOS_DISK
//
// MessageText:
//
// The specified disk or diskette cannot be accessed.
//


//
// MessageId: ERROR_SECTOR_NOT_FOUND
//
// MessageText:
//
// The drive cannot find the sector requested.
//


//
// MessageId: ERROR_OUT_OF_PAPER
//
// MessageText:
//
// The printer is out of paper.
//


//
// MessageId: ERROR_WRITE_FAULT
//
// MessageText:
//
// The system cannot write to the specified device.
//


//
// MessageId: ERROR_READ_FAULT
//
// MessageText:
//
// The system cannot read from the specified device.
//


//
// MessageId: ERROR_GEN_FAILURE
//
// MessageText:
//
// A device attached to the system is not functioning.
//


//
// MessageId: ERROR_SHARING_VIOLATION
//
// MessageText:
//
// The process cannot access the file because it is being used by another process.
//


//
// MessageId: ERROR_LOCK_VIOLATION
//
// MessageText:
//
// The process cannot access the file because another process has locked a portion of the file.
//


//
// MessageId: ERROR_WRONG_DISK
//
// MessageText:
//
// The wrong diskette is in the drive.
// Insert %2 (Volume Serial Number: %3) into drive %1.
//


//
// MessageId: ERROR_SHARING_BUFFER_EXCEEDED
//
// MessageText:
//
// Too many files opened for sharing.
//


//
// MessageId: ERROR_HANDLE_EOF
//
// MessageText:
//
// Reached the end of the file.
//


//
// MessageId: ERROR_HANDLE_DISK_FULL
//
// MessageText:
//
// The disk is full.
//


//
// MessageId: ERROR_NOT_SUPPORTED
//
// MessageText:
//
// The request is not supported.
//


//
// MessageId: ERROR_REM_NOT_LIST
//
// MessageText:
//
// Windows cannot find the network path. Verify that the network path is correct and the destination computer is not busy or turned off. If Windows still cannot find the network path, contact your network administrator.
//


//
// MessageId: ERROR_DUP_NAME
//
// MessageText:
//
// You were not connected because a duplicate name exists on the network. If joining a domain, go to System in Control Panel to change the computer name and try again. If joining a workgroup, choose another workgroup name.
//


//
// MessageId: ERROR_BAD_NETPATH
//
// MessageText:
//
// The network path was not found.
//


//
// MessageId: ERROR_NETWORK_BUSY
//
// MessageText:
//
// The network is busy.
//


//
// MessageId: ERROR_DEV_NOT_EXIST
//
// MessageText:
//
// The specified network resource or device is no longer available.
//


//
// MessageId: ERROR_TOO_MANY_CMDS
//
// MessageText:
//
// The network BIOS command limit has been reached.
//


//
// MessageId: ERROR_ADAP_HDW_ERR
//
// MessageText:
//
// A network adapter hardware error occurred.
//


//
// MessageId: ERROR_BAD_NET_RESP
//
// MessageText:
//
// The specified server cannot perform the requested operation.
//


//
// MessageId: ERROR_UNEXP_NET_ERR
//
// MessageText:
//
// An unexpected network error occurred.
//


//
// MessageId: ERROR_BAD_REM_ADAP
//
// MessageText:
//
// The remote adapter is not compatible.
//


//
// MessageId: ERROR_PRINTQ_FULL
//
// MessageText:
//
// The printer queue is full.
//


//
// MessageId: ERROR_NO_SPOOL_SPACE
//
// MessageText:
//
// Space to store the file waiting to be printed is not available on the server.
//


//
// MessageId: ERROR_PRINT_CANCELLED
//
// MessageText:
//
// Your file waiting to be printed was deleted.
//


//
// MessageId: ERROR_NETNAME_DELETED
//
// MessageText:
//
// The specified network name is no longer available.
//


//
// MessageId: ERROR_NETWORK_ACCESS_DENIED
//
// MessageText:
//
// Network access is denied.
//


//
// MessageId: ERROR_BAD_DEV_TYPE
//
// MessageText:
//
// The network resource type is not correct.
//


//
// MessageId: ERROR_BAD_NET_NAME
//
// MessageText:
//
// The network name cannot be found.
//


//
// MessageId: ERROR_TOO_MANY_NAMES
//
// MessageText:
//
// The name limit for the local computer network adapter card was exceeded.
//


//
// MessageId: ERROR_TOO_MANY_SESS
//
// MessageText:
//
// The network BIOS session limit was exceeded.
//


//
// MessageId: ERROR_SHARING_PAUSED
//
// MessageText:
//
// The remote server has been paused or is in the process of being started.
//


//
// MessageId: ERROR_REQ_NOT_ACCEP
//
// MessageText:
//
// No more connections can be made to this remote computer at this time because there are already as many connections as the computer can accept.
//


//
// MessageId: ERROR_REDIR_PAUSED
//
// MessageText:
//
// The specified printer or disk device has been paused.
//


//
// MessageId: ERROR_FILE_EXISTS
//
// MessageText:
//
// The file exists.
//


//
// MessageId: ERROR_CANNOT_MAKE
//
// MessageText:
//
// The directory or file cannot be created.
//


//
// MessageId: ERROR_FAIL_I24
//
// MessageText:
//
// Fail on INT 24.
//


//
// MessageId: ERROR_OUT_OF_STRUCTURES
//
// MessageText:
//
// Storage to process this request is not available.
//


//
// MessageId: ERROR_ALREADY_ASSIGNED
//
// MessageText:
//
// The local device name is already in use.
//


//
// MessageId: ERROR_INVALID_PASSWORD
//
// MessageText:
//
// The specified network password is not correct.
//


//
// MessageId: ERROR_INVALID_PARAMETER
//
// MessageText:
//
// The parameter is incorrect.
//


//
// MessageId: ERROR_NET_WRITE_FAULT
//
// MessageText:
//
// A write fault occurred on the network.
//


//
// MessageId: ERROR_NO_PROC_SLOTS
//
// MessageText:
//
// The system cannot start another process at this time.
//


//
// MessageId: ERROR_TOO_MANY_SEMAPHORES
//
// MessageText:
//
// Cannot create another system semaphore.
//


//
// MessageId: ERROR_EXCL_SEM_ALREADY_OWNED
//
// MessageText:
//
// The exclusive semaphore is owned by another process.
//


//
// MessageId: ERROR_SEM_IS_SET
//
// MessageText:
//
// The semaphore is set and cannot be closed.
//


//
// MessageId: ERROR_TOO_MANY_SEM_REQUESTS
//
// MessageText:
//
// The semaphore cannot be set again.
//


//
// MessageId: ERROR_INVALID_AT_INTERRUPT_TIME
//
// MessageText:
//
// Cannot request exclusive semaphores at interrupt time.
//


//
// MessageId: ERROR_SEM_OWNER_DIED
//
// MessageText:
//
// The previous ownership of this semaphore has ended.
//


//
// MessageId: ERROR_SEM_USER_LIMIT
//
// MessageText:
//
// Insert the diskette for drive %1.
//


//
// MessageId: ERROR_DISK_CHANGE
//
// MessageText:
//
// The program stopped because an alternate diskette was not inserted.
//


//
// MessageId: ERROR_DRIVE_LOCKED
//
// MessageText:
//
// The disk is in use or locked by another process.
//


//
// MessageId: ERROR_BROKEN_PIPE
//
// MessageText:
//
// The pipe has been ended.
//


//
// MessageId: ERROR_OPEN_FAILED
//
// MessageText:
//
// The system cannot open the device or file specified.
//


//
// MessageId: ERROR_BUFFER_OVERFLOW
//
// MessageText:
//
// The file name is too long.
//


//
// MessageId: ERROR_DISK_FULL
//
// MessageText:
//
// There is not enough space on the disk.
//


//
// MessageId: ERROR_NO_MORE_SEARCH_HANDLES
//
// MessageText:
//
// No more internal file identifiers available.
//


//
// MessageId: ERROR_INVALID_TARGET_HANDLE
//
// MessageText:
//
// The target internal file identifier is incorrect.
//


//
// MessageId: ERROR_INVALID_CATEGORY
//
// MessageText:
//
// The IOCTL call made by the application program is not correct.
//


//
// MessageId: ERROR_INVALID_VERIFY_SWITCH
//
// MessageText:
//
// The verify-on-write switch parameter value is not correct.
//


//
// MessageId: ERROR_BAD_DRIVER_LEVEL
//
// MessageText:
//
// The system does not support the command requested.
//


//
// MessageId: ERROR_CALL_NOT_IMPLEMENTED
//
// MessageText:
//
// This function is not supported on this system.
//


//
// MessageId: ERROR_SEM_TIMEOUT
//
// MessageText:
//
// The semaphore timeout period has expired.
//


//
// MessageId: ERROR_INSUFFICIENT_BUFFER
//
// MessageText:
//
// The data area passed to a system call is too small.
//


//
// MessageId: ERROR_INVALID_NAME
//
// MessageText:
//
// The filename, directory name, or volume label syntax is incorrect.
//


//
// MessageId: ERROR_INVALID_LEVEL
//
// MessageText:
//
// The system call level is not correct.
//


//
// MessageId: ERROR_NO_VOLUME_LABEL
//
// MessageText:
//
// The disk has no volume label.
//


//
// MessageId: ERROR_MOD_NOT_FOUND
//
// MessageText:
//
// The specified module could not be found.
//


//
// MessageId: ERROR_PROC_NOT_FOUND
//
// MessageText:
//
// The specified procedure could not be found.
//


//
// MessageId: ERROR_WAIT_NO_CHILDREN
//
// MessageText:
//
// There are no child processes to wait for.
//


//
// MessageId: ERROR_CHILD_NOT_COMPLETE
//
// MessageText:
//
// The %1 application cannot be run in Win32 mode.
//


//
// MessageId: ERROR_DIRECT_ACCESS_HANDLE
//
// MessageText:
//
// Attempt to use a file handle to an open disk partition for an operation other than raw disk I/O.
//


//
// MessageId: ERROR_NEGATIVE_SEEK
//
// MessageText:
//
// An attempt was made to move the file pointer before the beginning of the file.
//


//
// MessageId: ERROR_SEEK_ON_DEVICE
//
// MessageText:
//
// The file pointer cannot be set on the specified device or file.
//


//
// MessageId: ERROR_IS_JOIN_TARGET
//
// MessageText:
//
// A JOIN or SUBST command cannot be used for a drive that contains previously joined drives.
//


//
// MessageId: ERROR_IS_JOINED
//
// MessageText:
//
// An attempt was made to use a JOIN or SUBST command on a drive that has already been joined.
//


//
// MessageId: ERROR_IS_SUBSTED
//
// MessageText:
//
// An attempt was made to use a JOIN or SUBST command on a drive that has already been substituted.
//


//
// MessageId: ERROR_NOT_JOINED
//
// MessageText:
//
// The system tried to delete the JOIN of a drive that is not joined.
//


//
// MessageId: ERROR_NOT_SUBSTED
//
// MessageText:
//
// The system tried to delete the substitution of a drive that is not substituted.
//


//
// MessageId: ERROR_JOIN_TO_JOIN
//
// MessageText:
//
// The system tried to join a drive to a directory on a joined drive.
//


//
// MessageId: ERROR_SUBST_TO_SUBST
//
// MessageText:
//
// The system tried to substitute a drive to a directory on a substituted drive.
//


//
// MessageId: ERROR_JOIN_TO_SUBST
//
// MessageText:
//
// The system tried to join a drive to a directory on a substituted drive.
//


//
// MessageId: ERROR_SUBST_TO_JOIN
//
// MessageText:
//
// The system tried to SUBST a drive to a directory on a joined drive.
//


//
// MessageId: ERROR_BUSY_DRIVE
//
// MessageText:
//
// The system cannot perform a JOIN or SUBST at this time.
//


//
// MessageId: ERROR_SAME_DRIVE
//
// MessageText:
//
// The system cannot join or substitute a drive to or for a directory on the same drive.
//


//
// MessageId: ERROR_DIR_NOT_ROOT
//
// MessageText:
//
// The directory is not a subdirectory of the root directory.
//


//
// MessageId: ERROR_DIR_NOT_EMPTY
//
// MessageText:
//
// The directory is not empty.
//


//
// MessageId: ERROR_IS_SUBST_PATH
//
// MessageText:
//
// The path specified is being used in a substitute.
//


//
// MessageId: ERROR_IS_JOIN_PATH
//
// MessageText:
//
// Not enough resources are available to process this command.
//


//
// MessageId: ERROR_PATH_BUSY
//
// MessageText:
//
// The path specified cannot be used at this time.
//


//
// MessageId: ERROR_IS_SUBST_TARGET
//
// MessageText:
//
// An attempt was made to join or substitute a drive for which a directory on the drive is the target of a previous substitute.
//


//
// MessageId: ERROR_SYSTEM_TRACE
//
// MessageText:
//
// System trace information was not specified in your CONFIG.SYS file, or tracing is disallowed.
//


//
// MessageId: ERROR_INVALID_EVENT_COUNT
//
// MessageText:
//
// The number of specified semaphore events for DosMuxSemWait is not correct.
//


//
// MessageId: ERROR_TOO_MANY_MUXWAITERS
//
// MessageText:
//
// DosMuxSemWait did not execute; too many semaphores are already set.
//


//
// MessageId: ERROR_INVALID_LIST_FORMAT
//
// MessageText:
//
// The DosMuxSemWait list is not correct.
//


//
// MessageId: ERROR_LABEL_TOO_LONG
//
// MessageText:
//
// The volume label you entered exceeds the label character limit of the target file system.
//


//
// MessageId: ERROR_TOO_MANY_TCBS
//
// MessageText:
//
// Cannot create another thread.
//


//
// MessageId: ERROR_SIGNAL_REFUSED
//
// MessageText:
//
// The recipient process has refused the signal.
//


//
// MessageId: ERROR_DISCARDED
//
// MessageText:
//
// The segment is already discarded and cannot be locked.
//


//
// MessageId: ERROR_NOT_LOCKED
//
// MessageText:
//
// The segment is already unlocked.
//


//
// MessageId: ERROR_BAD_THREADID_ADDR
//
// MessageText:
//
// The address for the thread ID is not correct.
//


//
// MessageId: ERROR_BAD_ARGUMENTS
//
// MessageText:
//
// One or more arguments are not correct.
//


//
// MessageId: ERROR_BAD_PATHNAME
//
// MessageText:
//
// The specified path is invalid.
//


//
// MessageId: ERROR_SIGNAL_PENDING
//
// MessageText:
//
// A signal is already pending.
//


//
// MessageId: ERROR_MAX_THRDS_REACHED
//
// MessageText:
//
// No more threads can be created in the system.
//


//
// MessageId: ERROR_LOCK_FAILED
//
// MessageText:
//
// Unable to lock a region of a file.
//


//
// MessageId: ERROR_BUSY
//
// MessageText:
//
// The requested resource is in use.
//


//
// MessageId: ERROR_DEVICE_SUPPORT_IN_PROGRESS
//
// MessageText:
//
// Device's command support detection is in progress.
//


//
// MessageId: ERROR_CANCEL_VIOLATION
//
// MessageText:
//
// A lock request was not outstanding for the supplied cancel region.
//


//
// MessageId: ERROR_ATOMIC_LOCKS_NOT_SUPPORTED
//
// MessageText:
//
// The file system does not support atomic changes to the lock type.
//


//
// MessageId: ERROR_INVALID_SEGMENT_NUMBER
//
// MessageText:
//
// The system detected a segment number that was not correct.
//


//
// MessageId: ERROR_INVALID_ORDINAL
//
// MessageText:
//
// The operating system cannot run %1.
//


//
// MessageId: ERROR_ALREADY_EXISTS
//
// MessageText:
//
// Cannot create a file when that file already exists.
//


//
// MessageId: ERROR_INVALID_FLAG_NUMBER
//
// MessageText:
//
// The flag passed is not correct.
//


//
// MessageId: ERROR_SEM_NOT_FOUND
//
// MessageText:
//
// The specified system semaphore name was not found.
//


//
// MessageId: ERROR_INVALID_STARTING_CODESEG
//
// MessageText:
//
// The operating system cannot run %1.
//


//
// MessageId: ERROR_INVALID_STACKSEG
//
// MessageText:
//
// The operating system cannot run %1.
//


//
// MessageId: ERROR_INVALID_MODULETYPE
//
// MessageText:
//
// The operating system cannot run %1.
//


//
// MessageId: ERROR_INVALID_EXE_SIGNATURE
//
// MessageText:
//
// Cannot run %1 in Win32 mode.
//


//
// MessageId: ERROR_EXE_MARKED_INVALID
//
// MessageText:
//
// The operating system cannot run %1.
//


//
// MessageId: ERROR_BAD_EXE_FORMAT
//
// MessageText:
//
// %1 is not a valid Win32 application.
//


//
// MessageId: ERROR_ITERATED_DATA_EXCEEDS_64k
//
// MessageText:
//
// The operating system cannot run %1.
//


//
// MessageId: ERROR_INVALID_MINALLOCSIZE
//
// MessageText:
//
// The operating system cannot run %1.
//


//
// MessageId: ERROR_DYNLINK_FROM_INVALID_RING
//
// MessageText:
//
// The operating system cannot run this application program.
//


//
// MessageId: ERROR_IOPL_NOT_ENABLED
//
// MessageText:
//
// The operating system is not presently configured to run this application.
//


//
// MessageId: ERROR_INVALID_SEGDPL
//
// MessageText:
//
// The operating system cannot run %1.
//


//
// MessageId: ERROR_AUTODATASEG_EXCEEDS_64k
//
// MessageText:
//
// The operating system cannot run this application program.
//


//
// MessageId: ERROR_RING2SEG_MUST_BE_MOVABLE
//
// MessageText:
//
// The code segment cannot be greater than or equal to 64K.
//


//
// MessageId: ERROR_RELOC_CHAIN_XEEDS_SEGLIM
//
// MessageText:
//
// The operating system cannot run %1.
//


//
// MessageId: ERROR_INFLOOP_IN_RELOC_CHAIN
//
// MessageText:
//
// The operating system cannot run %1.
//


//
// MessageId: ERROR_ENVVAR_NOT_FOUND
//
// MessageText:
//
// The system could not find the environment option that was entered.
//


//
// MessageId: ERROR_NO_SIGNAL_SENT
//
// MessageText:
//
// No process in the command subtree has a signal handler.
//


//
// MessageId: ERROR_FILENAME_EXCED_RANGE
//
// MessageText:
//
// The filename or extension is too long.
//


//
// MessageId: ERROR_RING2_STACK_IN_USE
//
// MessageText:
//
// The ring 2 stack is in use.
//


//
// MessageId: ERROR_META_EXPANSION_TOO_LONG
//
// MessageText:
//
// The global filename characters, * or ?, are entered incorrectly or too many global filename characters are specified.
//


//
// MessageId: ERROR_INVALID_SIGNAL_NUMBER
//
// MessageText:
//
// The signal being posted is not correct.
//


//
// MessageId: ERROR_THREAD_1_INACTIVE
//
// MessageText:
//
// The signal handler cannot be set.
//


//
// MessageId: ERROR_LOCKED
//
// MessageText:
//
// The segment is locked and cannot be reallocated.
//


//
// MessageId: ERROR_TOO_MANY_MODULES
//
// MessageText:
//
// Too many dynamic-link modules are attached to this program or dynamic-link module.
//


//
// MessageId: ERROR_NESTING_NOT_ALLOWED
//
// MessageText:
//
// Cannot nest calls to LoadModule.
//


//
// MessageId: ERROR_EXE_MACHINE_TYPE_MISMATCH
//
// MessageText:
//
// This version of %1 is not compatible with the version of Windows you're running. Check your computer's system information and then contact the software publisher.
//


//
// MessageId: ERROR_EXE_CANNOT_MODIFY_SIGNED_BINARY
//
// MessageText:
//
// The image file %1 is signed, unable to modify.
//


//
// MessageId: ERROR_EXE_CANNOT_MODIFY_STRONG_SIGNED_BINARY
//
// MessageText:
//
// The image file %1 is strong signed, unable to modify.
//


//
// MessageId: ERROR_FILE_CHECKED_OUT
//
// MessageText:
//
// This file is checked out or locked for editing by another user.
//


//
// MessageId: ERROR_CHECKOUT_REQUIRED
//
// MessageText:
//
// The file must be checked out before saving changes.
//


//
// MessageId: ERROR_BAD_FILE_TYPE
//
// MessageText:
//
// The file type being saved or retrieved has been blocked.
//


//
// MessageId: ERROR_FILE_TOO_LARGE
//
// MessageText:
//
// The file size exceeds the limit allowed and cannot be saved.
//


//
// MessageId: ERROR_FORMS_AUTH_REQUIRED
//
// MessageText:
//
// Access Denied. Before opening files in this location, you must first add the web site to your trusted sites list, browse to the web site, and select the option to login automatically.
//


//
// MessageId: ERROR_VIRUS_INFECTED
//
// MessageText:
//
// Operation did not complete successfully because the file contains a virus or potentially unwanted software.
//


//
// MessageId: ERROR_VIRUS_DELETED
//
// MessageText:
//
// This file contains a virus or potentially unwanted software and cannot be opened. Due to the nature of this virus or potentially unwanted software, the file has been removed from this location.
//


//
// MessageId: ERROR_PIPE_LOCAL
//
// MessageText:
//
// The pipe is local.
//


//
// MessageId: ERROR_BAD_PIPE
//
// MessageText:
//
// The pipe state is invalid.
//


//
// MessageId: ERROR_PIPE_BUSY
//
// MessageText:
//
// All pipe instances are busy.
//


//
// MessageId: ERROR_NO_DATA
//
// MessageText:
//
// The pipe is being closed.
//


//
// MessageId: ERROR_PIPE_NOT_CONNECTED
//
// MessageText:
//
// No process is on the other end of the pipe.
//


//
// MessageId: ERROR_MORE_DATA
//
// MessageText:
//
// More data is available.
//


//
// MessageId: ERROR_NO_WORK_DONE
//
// MessageText:
//
// The action requested resulted in no work being done. Error-style clean-up has been performed.
//


//
// MessageId: ERROR_VC_DISCONNECTED
//
// MessageText:
//
// The session was canceled.
//


//
// MessageId: ERROR_INVALID_EA_NAME
//
// MessageText:
//
// The specified extended attribute name was invalid.
//


//
// MessageId: ERROR_EA_LIST_INCONSISTENT
//
// MessageText:
//
// The extended attributes are inconsistent.
//


//
// MessageId: WAIT_TIMEOUT
//
// MessageText:
//
// The wait operation timed out.
//


//
// MessageId: ERROR_NO_MORE_ITEMS
//
// MessageText:
//
// No more data is available.
//


//
// MessageId: ERROR_CANNOT_COPY
//
// MessageText:
//
// The copy functions cannot be used.
//


//
// MessageId: ERROR_DIRECTORY
//
// MessageText:
//
// The directory name is invalid.
//


//
// MessageId: ERROR_EAS_DIDNT_FIT
//
// MessageText:
//
// The extended attributes did not fit in the buffer.
//


//
// MessageId: ERROR_EA_FILE_CORRUPT
//
// MessageText:
//
// The extended attribute file on the mounted file system is corrupt.
//


//
// MessageId: ERROR_EA_TABLE_FULL
//
// MessageText:
//
// The extended attribute table file is full.
//


//
// MessageId: ERROR_INVALID_EA_HANDLE
//
// MessageText:
//
// The specified extended attribute handle is invalid.
//


//
// MessageId: ERROR_EAS_NOT_SUPPORTED
//
// MessageText:
//
// The mounted file system does not support extended attributes.
//


//
// MessageId: ERROR_NOT_OWNER
//
// MessageText:
//
// Attempt to release mutex not owned by caller.
//


//
// MessageId: ERROR_TOO_MANY_POSTS
//
// MessageText:
//
// Too many posts were made to a semaphore.
//


//
// MessageId: ERROR_PARTIAL_COPY
//
// MessageText:
//
// Only part of a ReadProcessMemory or WriteProcessMemory request was completed.
//


//
// MessageId: ERROR_OPLOCK_NOT_GRANTED
//
// MessageText:
//
// The oplock request is denied.
//


//
// MessageId: ERROR_INVALID_OPLOCK_PROTOCOL
//
// MessageText:
//
// An invalid oplock acknowledgment was received by the system.
//


//
// MessageId: ERROR_DISK_TOO_FRAGMENTED
//
// MessageText:
//
// The volume is too fragmented to complete this operation.
//


//
// MessageId: ERROR_DELETE_PENDING
//
// MessageText:
//
// The file cannot be opened because it is in the process of being deleted.
//


//
// MessageId: ERROR_INCOMPATIBLE_WITH_GLOBAL_SHORT_NAME_REGISTRY_SETTING
//
// MessageText:
//
// Short name settings may not be changed on this volume due to the global registry setting.
//


//
// MessageId: ERROR_SHORT_NAMES_NOT_ENABLED_ON_VOLUME
//
// MessageText:
//
// Short names are not enabled on this volume.
//


//
// MessageId: ERROR_SECURITY_STREAM_IS_INCONSISTENT
//
// MessageText:
//
// The security stream for the given volume is in an inconsistent state.
// Please run CHKDSK on the volume.
//


//
// MessageId: ERROR_INVALID_LOCK_RANGE
//
// MessageText:
//
// A requested file lock operation cannot be processed due to an invalid byte range.
//


//
// MessageId: ERROR_IMAGE_SUBSYSTEM_NOT_PRESENT
//
// MessageText:
//
// The subsystem needed to support the image type is not present.
//


//
// MessageId: ERROR_NOTIFICATION_GUID_ALREADY_DEFINED
//
// MessageText:
//
// The specified file already has a notification GUID associated with it.
//


//
// MessageId: ERROR_INVALID_EXCEPTION_HANDLER
//
// MessageText:
//
// An invalid exception handler routine has been detected.
//


//
// MessageId: ERROR_DUPLICATE_PRIVILEGES
//
// MessageText:
//
// Duplicate privileges were specified for the token.
//


//
// MessageId: ERROR_NO_RANGES_PROCESSED
//
// MessageText:
//
// No ranges for the specified operation were able to be processed.
//


//
// MessageId: ERROR_NOT_ALLOWED_ON_SYSTEM_FILE
//
// MessageText:
//
// Operation is not allowed on a file system internal file.
//


//
// MessageId: ERROR_DISK_RESOURCES_EXHAUSTED
//
// MessageText:
//
// The physical resources of this disk have been exhausted.
//


//
// MessageId: ERROR_INVALID_TOKEN
//
// MessageText:
//
// The token representing the data is invalid.
//


//
// MessageId: ERROR_DEVICE_FEATURE_NOT_SUPPORTED
//
// MessageText:
//
// The device does not support the command feature.
//


//
// MessageId: ERROR_MR_MID_NOT_FOUND
//
// MessageText:
//
// The system cannot find message text for message number 0x%1 in the message file for %2.
//


//
// MessageId: ERROR_SCOPE_NOT_FOUND
//
// MessageText:
//
// The scope specified was not found.
//


//
// MessageId: ERROR_UNDEFINED_SCOPE
//
// MessageText:
//
// The Central Access Policy specified is not defined on the target machine.
//


//
// MessageId: ERROR_INVALID_CAP
//
// MessageText:
//
// The Central Access Policy obtained from Active Directory is invalid.
//


//
// MessageId: ERROR_DEVICE_UNREACHABLE
//
// MessageText:
//
// The device is unreachable.
//


//
// MessageId: ERROR_DEVICE_NO_RESOURCES
//
// MessageText:
//
// The target device has insufficient resources to complete the operation.
//


//
// MessageId: ERROR_DATA_CHECKSUM_ERROR
//
// MessageText:
//
// A data integrity checksum error occurred. Data in the file stream is corrupt.
//


//
// MessageId: ERROR_INTERMIXED_KERNEL_EA_OPERATION
//
// MessageText:
//
// An attempt was made to modify both a KERNEL and normal Extended Attribute (EA) in the same operation.
//


//
// MessageId: ERROR_FILE_LEVEL_TRIM_NOT_SUPPORTED
//
// MessageText:
//
// Device does not support file-level TRIM.
//


//
// MessageId: ERROR_OFFSET_ALIGNMENT_VIOLATION
//
// MessageText:
//
// The command specified a data offset that does not align to the device's granularity/alignment.
//


//
// MessageId: ERROR_INVALID_FIELD_IN_PARAMETER_LIST
//
// MessageText:
//
// The command specified an invalid field in its parameter list.
//


//
// MessageId: ERROR_OPERATION_IN_PROGRESS
//
// MessageText:
//
// An operation is currently in progress with the device.
//


//
// MessageId: ERROR_BAD_DEVICE_PATH
//
// MessageText:
//
// An attempt was made to send down the command via an invalid path to the target device.
//


//
// MessageId: ERROR_TOO_MANY_DESCRIPTORS
//
// MessageText:
//
// The command specified a number of descriptors that exceeded the maximum supported by the device.
//


//
// MessageId: ERROR_SCRUB_DATA_DISABLED
//
// MessageText:
//
// Scrub is disabled on the specified file.
//


//
// MessageId: ERROR_NOT_REDUNDANT_STORAGE
//
// MessageText:
//
// The storage device does not provide redundancy.
//


//
// MessageId: ERROR_RESIDENT_FILE_NOT_SUPPORTED
//
// MessageText:
//
// An operation is not supported on a resident file.
//


//
// MessageId: ERROR_COMPRESSED_FILE_NOT_SUPPORTED
//
// MessageText:
//
// An operation is not supported on a compressed file.
//


//
// MessageId: ERROR_DIRECTORY_NOT_SUPPORTED
//
// MessageText:
//
// An operation is not supported on a directory.
//


//
// MessageId: ERROR_NOT_READ_FROM_COPY
//
// MessageText:
//
// The specified copy of the requested data could not be read.
//


//
// MessageId: ERROR_FT_WRITE_FAILURE
//
// MessageText:
//
// The specified data could not be written to any of the copies.
//


//
// MessageId: ERROR_FT_DI_SCAN_REQUIRED
//
// MessageText:
//
// One or more copies of data on this device may be out of sync. No writes may be performed until a data integrity scan is completed.
//


//
// MessageId: ERROR_INVALID_KERNEL_INFO_VERSION
//
// MessageText:
//
// The supplied kernel information version is invalid.
//


//
// MessageId: ERROR_INVALID_PEP_INFO_VERSION
//
// MessageText:
//
// The supplied PEP information version is invalid.
//


//
// MessageId: ERROR_OBJECT_NOT_EXTERNALLY_BACKED
//
// MessageText:
//
// This object is not externally backed by any provider.
//


//
// MessageId: ERROR_EXTERNAL_BACKING_PROVIDER_UNKNOWN
//
// MessageText:
//
// The external backing provider is not recognized.
//


//
// MessageId: ERROR_COMPRESSION_NOT_BENEFICIAL
//
// MessageText:
//
// Compressing this object would not save space.
//


//
// MessageId: ERROR_STORAGE_TOPOLOGY_ID_MISMATCH
//
// MessageText:
//
// The request failed due to a storage topology ID mismatch.
//


//
// MessageId: ERROR_BLOCKED_BY_PARENTAL_CONTROLS
//
// MessageText:
//
// The operation was blocked by parental controls.
//


//
// MessageId: ERROR_BLOCK_TOO_MANY_REFERENCES
//
// MessageText:
//
// A file system block being referenced has already reached the maximum reference count and can't be referenced any further.
//


//
// MessageId: ERROR_MARKED_TO_DISALLOW_WRITES
//
// MessageText:
//
// The requested operation failed because the file stream is marked to disallow writes.
//


//
// MessageId: ERROR_ENCLAVE_FAILURE
//
// MessageText:
//
// The requested operation failed with an architecture-specific failure code.
//


//
// MessageId: ERROR_FAIL_NOACTION_REBOOT
//
// MessageText:
//
// No action was taken as a system reboot is required.
//


//
// MessageId: ERROR_FAIL_SHUTDOWN
//
// MessageText:
//
// The shutdown operation failed.
//


//
// MessageId: ERROR_FAIL_RESTART
//
// MessageText:
//
// The restart operation failed.
//


//
// MessageId: ERROR_MAX_SESSIONS_REACHED
//
// MessageText:
//
// The maximum number of sessions has been reached.
//


//
// MessageId: ERROR_NETWORK_ACCESS_DENIED_EDP
//
// MessageText:
//
// Windows Information Protection policy does not allow access to this network resource.
//


//
// MessageId: ERROR_DEVICE_HINT_NAME_BUFFER_TOO_SMALL
//
// MessageText:
//
// The device hint name buffer is too small to receive the remaining name.
//


//
// MessageId: ERROR_EDP_POLICY_DENIES_OPERATION
//
// MessageText:
//
// The requested operation was blocked by Windows Information Protection policy. For more information, contact your system administrator.
//


//
// MessageId: ERROR_EDP_DPL_POLICY_CANT_BE_SATISFIED
//
// MessageText:
//
// The requested operation cannot be performed because hardware or software configuration of the device does not comply with Windows Information Protection under Lock policy. Please, verify that user PIN has been created. For more information, contact your system administrator.
//


//
// MessageId: ERROR_CLOUD_FILE_SYNC_ROOT_METADATA_CORRUPT
//
// MessageText:
//
// The cloud sync root metadata is corrupted.
//


//
// MessageId: ERROR_DEVICE_IN_MAINTENANCE
//
// MessageText:
//
// The device is in maintenance mode.
//


//
// MessageId: ERROR_NOT_SUPPORTED_ON_DAX
//
// MessageText:
//
// This operation is not supported on a DAX volume.
//


//
// MessageId: ERROR_DAX_MAPPING_EXISTS
//
// MessageText:
//
// The volume has active DAX mappings.
//


//
// MessageId: ERROR_CLOUD_FILE_PROVIDER_NOT_RUNNING
//
// MessageText:
//
// The cloud file provider is not running.
//


//
// MessageId: ERROR_CLOUD_FILE_METADATA_CORRUPT
//
// MessageText:
//
// The cloud file metadata is corrupt and unreadable.
//


//
// MessageId: ERROR_CLOUD_FILE_METADATA_TOO_LARGE
//
// MessageText:
//
// The cloud file metadata is too large.
//


//
// MessageId: ERROR_CLOUD_FILE_PROPERTY_BLOB_TOO_LARGE
//
// MessageText:
//
// The cloud file property is too large.
//


//
// MessageId: ERROR_CLOUD_FILE_PROPERTY_BLOB_CHECKSUM_MISMATCH
//
// MessageText:
//
// The cloud file property is possibly corrupt. The on-disk checksum does not match the computed checksum.
//


//
// MessageId: ERROR_CHILD_PROCESS_BLOCKED
//
// MessageText:
//
// The process creation has been blocked.
//


//
// MessageId: ERROR_STORAGE_LOST_DATA_PERSISTENCE
//
// MessageText:
//
// The storage device has lost data or persistence.
//


//
// MessageId: ERROR_FILE_SYSTEM_VIRTUALIZATION_UNAVAILABLE
//
// MessageText:
//
// The provider that supports file system virtualization is temporarily unavailable.
//


//
// MessageId: ERROR_FILE_SYSTEM_VIRTUALIZATION_METADATA_CORRUPT
//
// MessageText:
//
// The metadata for file system virtualization is corrupt and unreadable.
//


//
// MessageId: ERROR_FILE_SYSTEM_VIRTUALIZATION_BUSY
//
// MessageText:
//
// The provider that supports file system virtualization is too busy to complete this operation.
//


//
// MessageId: ERROR_FILE_SYSTEM_VIRTUALIZATION_PROVIDER_UNKNOWN
//
// MessageText:
//
// The provider that supports file system virtualization is unknown.
//


//
// MessageId: ERROR_GDI_HANDLE_LEAK
//
// MessageText:
//
// GDI handles were potentially leaked by the application.
//


//
// MessageId: ERROR_CLOUD_FILE_TOO_MANY_PROPERTY_BLOBS
//
// MessageText:
//
// The maximum number of cloud file properties has been reached.
//


//
// MessageId: ERROR_CLOUD_FILE_PROPERTY_VERSION_NOT_SUPPORTED
//
// MessageText:
//
// The version of the cloud file property store is not supported.
//


//
// MessageId: ERROR_NOT_A_CLOUD_FILE
//
// MessageText:
//
// The file is not a cloud file.
//


//
// MessageId: ERROR_CLOUD_FILE_NOT_IN_SYNC
//
// MessageText:
//
// The file is not in sync with the cloud.
//


//
// MessageId: ERROR_CLOUD_FILE_ALREADY_CONNECTED
//
// MessageText:
//
// The cloud sync root is already connected with another cloud sync provider.
//


//
// MessageId: ERROR_CLOUD_FILE_NOT_SUPPORTED
//
// MessageText:
//
// The operation is not supported by the cloud sync provider.
//


//
// MessageId: ERROR_CLOUD_FILE_INVALID_REQUEST
//
// MessageText:
//
// The cloud operation is invalid.
//


//
// MessageId: ERROR_CLOUD_FILE_READ_ONLY_VOLUME
//
// MessageText:
//
// The cloud operation is not supported on a read-only volume.
//


//
// MessageId: ERROR_CLOUD_FILE_CONNECTED_PROVIDER_ONLY
//
// MessageText:
//
// The operation is reserved for a connected cloud sync provider.
//


//
// MessageId: ERROR_CLOUD_FILE_VALIDATION_FAILED
//
// MessageText:
//
// The cloud sync provider failed to validate the downloaded data.
//


//
// MessageId: ERROR_SMB1_NOT_AVAILABLE
//
// MessageText:
//
// You can't connect to the file share because it's not secure. This share requires the obsolete SMB1 protocol, which is unsafe and could expose your system to attack.
// Your system requires SMB2 or higher. For more info on resolving this issue, see: https://go.microsoft.com/fwlink/?linkid=852747
//


//
// MessageId: ERROR_FILE_SYSTEM_VIRTUALIZATION_INVALID_OPERATION
//
// MessageText:
//
// The virtualization operation is not allowed on the file in its current state.
//


//
// MessageId: ERROR_CLOUD_FILE_AUTHENTICATION_FAILED
//
// MessageText:
//
// The cloud sync provider failed user authentication.
//


//
// MessageId: ERROR_CLOUD_FILE_INSUFFICIENT_RESOURCES
//
// MessageText:
//
// The cloud sync provider failed to perform the operation due to low system resources.
//


//
// MessageId: ERROR_CLOUD_FILE_NETWORK_UNAVAILABLE
//
// MessageText:
//
// The cloud sync provider failed to perform the operation due to network being unavailable.
//


//
// MessageId: ERROR_CLOUD_FILE_UNSUCCESSFUL
//
// MessageText:
//
// The cloud operation was unsuccessful.
//


//
// MessageId: ERROR_CLOUD_FILE_NOT_UNDER_SYNC_ROOT
//
// MessageText:
//
// The operation is only supported on files under a cloud sync root.
//


//
// MessageId: ERROR_CLOUD_FILE_IN_USE
//
// MessageText:
//
// The operation cannot be performed on cloud files in use.
//


//
// MessageId: ERROR_CLOUD_FILE_PINNED
//
// MessageText:
//
// The operation cannot be performed on pinned cloud files.
//


//
// MessageId: ERROR_CLOUD_FILE_REQUEST_ABORTED
//
// MessageText:
//
// The cloud operation was aborted.
//


//
// MessageId: ERROR_CLOUD_FILE_PROPERTY_CORRUPT
//
// MessageText:
//
// The cloud file's property store is corrupt.
//


//
// MessageId: ERROR_CLOUD_FILE_ACCESS_DENIED
//
// MessageText:
//
// Access to the cloud file is denied.
//


//
// MessageId: ERROR_CLOUD_FILE_INCOMPATIBLE_HARDLINKS
//
// MessageText:
//
// The cloud operation cannot be performed on a file with incompatible hardlinks.
//


//
// MessageId: ERROR_CLOUD_FILE_PROPERTY_LOCK_CONFLICT
//
// MessageText:
//
// The operation failed due to a conflicting cloud file property lock.
//


//
// MessageId: ERROR_CLOUD_FILE_REQUEST_CANCELED
//
// MessageText:
//
// The cloud operation was canceled by user.
//


//
// MessageId: ERROR_EXTERNAL_SYSKEY_NOT_SUPPORTED
//
// MessageText:
//
// An externally encrypted syskey has been configured, but the system no longer supports this feature.  Please see https://go.microsoft.com/fwlink/?linkid=851152 for more information.
//


//
// MessageId: ERROR_THREAD_MODE_ALREADY_BACKGROUND
//
// MessageText:
//
// The thread is already in background processing mode.
//


//
// MessageId: ERROR_THREAD_MODE_NOT_BACKGROUND
//
// MessageText:
//
// The thread is not in background processing mode.
//


//
// MessageId: ERROR_PROCESS_MODE_ALREADY_BACKGROUND
//
// MessageText:
//
// The process is already in background processing mode.
//


//
// MessageId: ERROR_PROCESS_MODE_NOT_BACKGROUND
//
// MessageText:
//
// The process is not in background processing mode.
//


//
// MessageId: ERROR_CLOUD_FILE_PROVIDER_TERMINATED
//
// MessageText:
//
// The cloud file provider exited unexpectedly.
//


//
// MessageId: ERROR_NOT_A_CLOUD_SYNC_ROOT
//
// MessageText:
//
// The file is not a cloud sync root.
//


//
// MessageId: ERROR_FILE_PROTECTED_UNDER_DPL
//
// MessageText:
//
// The read or write operation to an encrypted file could not be completed because the file can only be accessed when the device is unlocked.
//


//
// MessageId: ERROR_VOLUME_NOT_CLUSTER_ALIGNED
//
// MessageText:
//
// The volume is not cluster aligned on the disk.
//


//
// MessageId: ERROR_NO_PHYSICALLY_ALIGNED_FREE_SPACE_FOUND
//
// MessageText:
//
// No physically aligned free space was found on the volume.
//


//
// MessageId: ERROR_APPX_FILE_NOT_ENCRYPTED
//
// MessageText:
//
// The APPX file can not be accessed because it is not encrypted as expected.
//


//
// MessageId: ERROR_RWRAW_ENCRYPTED_FILE_NOT_ENCRYPTED
//
// MessageText:
//
// A read or write of raw encrypted data cannot be performed because the file is not encrypted.
//


//
// MessageId: ERROR_RWRAW_ENCRYPTED_INVALID_EDATAINFO_FILEOFFSET
//
// MessageText:
//
// An invalid file offset in the encrypted data info block was passed for read or write operation of file's raw encrypted data.
//


//
// MessageId: ERROR_RWRAW_ENCRYPTED_INVALID_EDATAINFO_FILERANGE
//
// MessageText:
//
// An invalid offset and length combination in the encrypted data info block was passed for read or write operation of file's raw encrypted data.
//


//
// MessageId: ERROR_RWRAW_ENCRYPTED_INVALID_EDATAINFO_PARAMETER
//
// MessageText:
//
// An invalid parameter in the encrypted data info block was passed for read or write operation of file's raw encrypted data.
//


//
// MessageId: ERROR_LINUX_SUBSYSTEM_NOT_PRESENT
//
// MessageText:
//
// The Windows Subsystem for Linux has not been enabled.
//


//
// MessageId: ERROR_FT_READ_FAILURE
//
// MessageText:
//
// The specified data could not be read from any of the copies.
//


//
// MessageId: ERROR_STORAGE_RESERVE_ID_INVALID
//
// MessageText:
//
// The specified storage reserve ID is invalid.
//


//
// MessageId: ERROR_STORAGE_RESERVE_DOES_NOT_EXIST
//
// MessageText:
//
// The specified storage reserve does not exist.
//


//
// MessageId: ERROR_STORAGE_RESERVE_ALREADY_EXISTS
//
// MessageText:
//
// The specified storage reserve already exists.
//


//
// MessageId: ERROR_STORAGE_RESERVE_NOT_EMPTY
//
// MessageText:
//
// The specified storage reserve is not empty.
//


//
// MessageId: ERROR_NOT_A_DAX_VOLUME
//
// MessageText:
//
// This operation requires a DAX volume.
//


//
// MessageId: ERROR_NOT_DAX_MAPPABLE
//
// MessageText:
//
// This stream is not DAX mappable.
//


//
// MessageId: ERROR_TIME_SENSITIVE_THREAD
//
// MessageText:
//
// Operation cannot be performed on a time critical thread.
//


//
// MessageId: ERROR_DPL_NOT_SUPPORTED_FOR_USER
//
// MessageText:
//
// User data protection is not supported for the current or provided user.
//


//
// MessageId: ERROR_CASE_DIFFERING_NAMES_IN_DIR
//
// MessageText:
//
// This directory contains entries whose names differ only in case.
//


//
// MessageId: ERROR_FILE_NOT_SUPPORTED
//
// MessageText:
//
// The file cannot be safely opened because it is not supported by this version of Windows.
//


//
// MessageId: ERROR_CLOUD_FILE_REQUEST_TIMEOUT
//
// MessageText:
//
// The cloud operation was not completed before the time-out period expired.
//


//
// MessageId: ERROR_NO_TASK_QUEUE
//
// MessageText:
//
// A task queue is required for this operation but none is available.
//


//
// MessageId: ERROR_SRC_SRV_DLL_LOAD_FAILED
//
// MessageText:
//
// Failed loading a valid version of srcsrv.dll.
//


//
// MessageId: ERROR_NOT_SUPPORTED_WITH_BTT
//
// MessageText:
//
// This operation is not supported with BTT enabled.
//


//
// MessageId: ERROR_ENCRYPTION_DISABLED
//
// MessageText:
//
// This operation cannot be performed because encryption is currently disabled.
//


//
// MessageId: ERROR_ENCRYPTING_METADATA_DISALLOWED
//
// MessageText:
//
// This encryption operation cannot be performed on filesystem metadata.
//


//
// MessageId: ERROR_CANT_CLEAR_ENCRYPTION_FLAG
//
// MessageText:
//
// Encryption cannot be cleared on this file/directory because it still has an encrypted attribute.
//


//
// MessageId: ERROR_NO_SUCH_DEVICE
//
// MessageText:
//
// A device which does not exist was specified.
//


//
// **** Available SYSTEM error codes ****
//

///////////////////////////////////////////////////
//                                               //
//    Capability Authorization Error codes       //
//                                               //
//                 0450 to 0460                  //
///////////////////////////////////////////////////

//
// MessageId: ERROR_CAPAUTHZ_NOT_DEVUNLOCKED
//
// MessageText:
//
// Neither developer unlocked mode nor side loading mode is enabled on the device.
//


//
// MessageId: ERROR_CAPAUTHZ_CHANGE_TYPE
//
// MessageText:
//
// Can not change application type during upgrade or re-provision.
//


//
// MessageId: ERROR_CAPAUTHZ_NOT_PROVISIONED
//
// MessageText:
//
// The application has not been provisioned.
//


//
// MessageId: ERROR_CAPAUTHZ_NOT_AUTHORIZED
//
// MessageText:
//
// The requested capability can not be authorized for this application.
//


//
// MessageId: ERROR_CAPAUTHZ_NO_POLICY
//
// MessageText:
//
// There is no capability authorization policy on the device.
//


//
// MessageId: ERROR_CAPAUTHZ_DB_CORRUPTED
//
// MessageText:
//
// The capability authorization database has been corrupted.
//


//
// MessageId: ERROR_CAPAUTHZ_SCCD_INVALID_CATALOG
//
// MessageText:
//
// The custom capability's SCCD has an invalid catalog.
//


//
// MessageId: ERROR_CAPAUTHZ_SCCD_NO_AUTH_ENTITY
//
// MessageText:
//
// None of the authorized entity elements in the SCCD matched the app being installed; either the PFNs don't match, or the element's signature hash doesn't validate.
//


//
// MessageId: ERROR_CAPAUTHZ_SCCD_PARSE_ERROR
//
// MessageText:
//
// The custom capability's SCCD failed to parse.
//


//
// MessageId: ERROR_CAPAUTHZ_SCCD_DEV_MODE_REQUIRED
//
// MessageText:
//
// The custom capability's SCCD requires developer mode.
//


//
// MessageId: ERROR_CAPAUTHZ_SCCD_NO_CAPABILITY_MATCH
//
// MessageText:
//
// There not all declared custom capabilities are found in the SCCD.
//


//
// **** Available SYSTEM error codes ****
//
//
// MessageId: ERROR_PNP_QUERY_REMOVE_DEVICE_TIMEOUT
//
// MessageText:
//
// The operation timed out waiting for this device to complete a PnP query-remove request due to a potential hang in its device stack. The system may need to be rebooted to complete the request.
//


//
// MessageId: ERROR_PNP_QUERY_REMOVE_RELATED_DEVICE_TIMEOUT
//
// MessageText:
//
// The operation timed out waiting for this device to complete a PnP query-remove request due to a potential hang in the device stack of a related device. The system may need to be rebooted to complete the operation.
//


//
// MessageId: ERROR_PNP_QUERY_REMOVE_UNRELATED_DEVICE_TIMEOUT
//
// MessageText:
//
// The operation timed out waiting for this device to complete a PnP query-remove request due to a potential hang in the device stack of an unrelated device. The system may need to be rebooted to complete the operation.
//


//
// MessageId: ERROR_DEVICE_HARDWARE_ERROR
//
// MessageText:
//
// The request failed due to a fatal device hardware error.
//


//
// MessageId: ERROR_INVALID_ADDRESS
//
// MessageText:
//
// Attempt to access invalid address.
//


//
// MessageId: ERROR_VRF_CFG_ENABLED
//
// MessageText:
//
// Driver Verifier Volatile settings cannot be set when CFG is enabled.
//


//
// MessageId: ERROR_PARTITION_TERMINATING
//
// MessageText:
//
// An attempt was made to access a partition that has begun termination.
//


//
// **** Available SYSTEM error codes ****
//
//
// MessageId: ERROR_USER_PROFILE_LOAD
//
// MessageText:
//
// User profile cannot be loaded.
//


//
// **** Available SYSTEM error codes ****
//
//
// MessageId: ERROR_ARITHMETIC_OVERFLOW
//
// MessageText:
//
// Arithmetic result exceeded 32 bits.
//


//
// MessageId: ERROR_PIPE_CONNECTED
//
// MessageText:
//
// There is a process on other end of the pipe.
//


//
// MessageId: ERROR_PIPE_LISTENING
//
// MessageText:
//
// Waiting for a process to open the other end of the pipe.
//


//
// MessageId: ERROR_VERIFIER_STOP
//
// MessageText:
//
// Application verifier has found an error in the current process.
//


//
// MessageId: ERROR_ABIOS_ERROR
//
// MessageText:
//
// An error occurred in the ABIOS subsystem.
//


//
// MessageId: ERROR_WX86_WARNING
//
// MessageText:
//
// A warning occurred in the WX86 subsystem.
//


//
// MessageId: ERROR_WX86_ERROR
//
// MessageText:
//
// An error occurred in the WX86 subsystem.
//


//
// MessageId: ERROR_TIMER_NOT_CANCELED
//
// MessageText:
//
// An attempt was made to cancel or set a timer that has an associated APC and the subject thread is not the thread that originally set the timer with an associated APC routine.
//


//
// MessageId: ERROR_UNWIND
//
// MessageText:
//
// Unwind exception code.
//


//
// MessageId: ERROR_BAD_STACK
//
// MessageText:
//
// An invalid or unaligned stack was encountered during an unwind operation.
//


//
// MessageId: ERROR_INVALID_UNWIND_TARGET
//
// MessageText:
//
// An invalid unwind target was encountered during an unwind operation.
//


//
// MessageId: ERROR_INVALID_PORT_ATTRIBUTES
//
// MessageText:
//
// Invalid Object Attributes specified to NtCreatePort or invalid Port Attributes specified to NtConnectPort
//


//
// MessageId: ERROR_PORT_MESSAGE_TOO_LONG
//
// MessageText:
//
// Length of message passed to NtRequestPort or NtRequestWaitReplyPort was longer than the maximum message allowed by the port.
//


//
// MessageId: ERROR_INVALID_QUOTA_LOWER
//
// MessageText:
//
// An attempt was made to lower a quota limit below the current usage.
//


//
// MessageId: ERROR_DEVICE_ALREADY_ATTACHED
//
// MessageText:
//
// An attempt was made to attach to a device that was already attached to another device.
//


//
// MessageId: ERROR_INSTRUCTION_MISALIGNMENT
//
// MessageText:
//
// An attempt was made to execute an instruction at an unaligned address and the host system does not support unaligned instruction references.
//


//
// MessageId: ERROR_PROFILING_NOT_STARTED
//
// MessageText:
//
// Profiling not started.
//


//
// MessageId: ERROR_PROFILING_NOT_STOPPED
//
// MessageText:
//
// Profiling not stopped.
//


//
// MessageId: ERROR_COULD_NOT_INTERPRET
//
// MessageText:
//
// The passed ACL did not contain the minimum required information.
//


//
// MessageId: ERROR_PROFILING_AT_LIMIT
//
// MessageText:
//
// The number of active profiling objects is at the maximum and no more may be started.
//


//
// MessageId: ERROR_CANT_WAIT
//
// MessageText:
//
// Used to indicate that an operation cannot continue without blocking for I/O.
//


//
// MessageId: ERROR_CANT_TERMINATE_SELF
//
// MessageText:
//
// Indicates that a thread attempted to terminate itself by default (called NtTerminateThread with NULL) and it was the last thread in the current process.
//


//
// MessageId: ERROR_UNEXPECTED_MM_CREATE_ERR
//
// MessageText:
//
// If an MM error is returned which is not defined in the standard FsRtl filter, it is converted to one of the following errors which is guaranteed to be in the filter.
// In this case information is lost, however, the filter correctly handles the exception.
//


//
// MessageId: ERROR_UNEXPECTED_MM_MAP_ERROR
//
// MessageText:
//
// If an MM error is returned which is not defined in the standard FsRtl filter, it is converted to one of the following errors which is guaranteed to be in the filter.
// In this case information is lost, however, the filter correctly handles the exception.
//


//
// MessageId: ERROR_UNEXPECTED_MM_EXTEND_ERR
//
// MessageText:
//
// If an MM error is returned which is not defined in the standard FsRtl filter, it is converted to one of the following errors which is guaranteed to be in the filter.
// In this case information is lost, however, the filter correctly handles the exception.
//


//
// MessageId: ERROR_BAD_FUNCTION_TABLE
//
// MessageText:
//
// A malformed function table was encountered during an unwind operation.
//


//
// MessageId: ERROR_NO_GUID_TRANSLATION
//
// MessageText:
//
// Indicates that an attempt was made to assign protection to a file system file or directory and one of the SIDs in the security descriptor could not be translated into a GUID that could be stored by the file system.
// This causes the protection attempt to fail, which may cause a file creation attempt to fail.
//


//
// MessageId: ERROR_INVALID_LDT_SIZE
//
// MessageText:
//
// Indicates that an attempt was made to grow an LDT by setting its size, or that the size was not an even number of selectors.
//


//
// MessageId: ERROR_INVALID_LDT_OFFSET
//
// MessageText:
//
// Indicates that the starting value for the LDT information was not an integral multiple of the selector size.
//


//
// MessageId: ERROR_INVALID_LDT_DESCRIPTOR
//
// MessageText:
//
// Indicates that the user supplied an invalid descriptor when trying to set up Ldt descriptors.
//


//
// MessageId: ERROR_TOO_MANY_THREADS
//
// MessageText:
//
// Indicates a process has too many threads to perform the requested action. For example, assignment of a primary token may only be performed when a process has zero or one threads.
//


//
// MessageId: ERROR_THREAD_NOT_IN_PROCESS
//
// MessageText:
//
// An attempt was made to operate on a thread within a specific process, but the thread specified is not in the process specified.
//


//
// MessageId: ERROR_PAGEFILE_QUOTA_EXCEEDED
//
// MessageText:
//
// Page file quota was exceeded.
//


//
// MessageId: ERROR_LOGON_SERVER_CONFLICT
//
// MessageText:
//
// The Netlogon service cannot start because another Netlogon service running in the domain conflicts with the specified role.
//


//
// MessageId: ERROR_SYNCHRONIZATION_REQUIRED
//
// MessageText:
//
// The SAM database on a Windows Server is significantly out of synchronization with the copy on the Domain Controller. A complete synchronization is required.
//


//
// MessageId: ERROR_NET_OPEN_FAILED
//
// MessageText:
//
// The NtCreateFile API failed. This error should never be returned to an application, it is a place holder for the Windows Lan Manager Redirector to use in its internal error mapping routines.
//


//
// MessageId: ERROR_IO_PRIVILEGE_FAILED
//
// MessageText:
//
// {Privilege Failed}
// The I/O permissions for the process could not be changed.
//


//
// MessageId: ERROR_CONTROL_C_EXIT
//
// MessageText:
//
// {Application Exit by CTRL+C}
// The application terminated as a result of a CTRL+C.
//


//
// MessageId: ERROR_MISSING_SYSTEMFILE
//
// MessageText:
//
// {Missing System File}
// The required system file %hs is bad or missing.
//


//
// MessageId: ERROR_UNHANDLED_EXCEPTION
//
// MessageText:
//
// {Application Error}
// The exception %s (0x%08lx) occurred in the application at location 0x%08lx.
//


//
// MessageId: ERROR_APP_INIT_FAILURE
//
// MessageText:
//
// {Application Error}
// The application was unable to start correctly (0x%lx). Click OK to close the application.
//


//
// MessageId: ERROR_PAGEFILE_CREATE_FAILED
//
// MessageText:
//
// {Unable to Create Paging File}
// The creation of the paging file %hs failed (%lx). The requested size was %ld.
//


//
// MessageId: ERROR_INVALID_IMAGE_HASH
//
// MessageText:
//
// Windows cannot verify the digital signature for this file. A recent hardware or software change might have installed a file that is signed incorrectly or damaged, or that might be malicious software from an unknown source.
//


//
// MessageId: ERROR_NO_PAGEFILE
//
// MessageText:
//
// {No Paging File Specified}
// No paging file was specified in the system configuration.
//


//
// MessageId: ERROR_ILLEGAL_FLOAT_CONTEXT
//
// MessageText:
//
// {EXCEPTION}
// A real-mode application issued a floating-point instruction and floating-point hardware is not present.
//


//
// MessageId: ERROR_NO_EVENT_PAIR
//
// MessageText:
//
// An event pair synchronization operation was performed using the thread specific client/server event pair object, but no event pair object was associated with the thread.
//


//
// MessageId: ERROR_DOMAIN_CTRLR_CONFIG_ERROR
//
// MessageText:
//
// A Windows Server has an incorrect configuration.
//


//
// MessageId: ERROR_ILLEGAL_CHARACTER
//
// MessageText:
//
// An illegal character was encountered. For a multi-byte character set this includes a lead byte without a succeeding trail byte. For the Unicode character set this includes the characters 0xFFFF and 0xFFFE.
//


//
// MessageId: ERROR_UNDEFINED_CHARACTER
//
// MessageText:
//
// The Unicode character is not defined in the Unicode character set installed on the system.
//


//
// MessageId: ERROR_FLOPPY_VOLUME
//
// MessageText:
//
// The paging file cannot be created on a floppy diskette.
//


//
// MessageId: ERROR_BIOS_FAILED_TO_CONNECT_INTERRUPT
//
// MessageText:
//
// The system BIOS failed to connect a system interrupt to the device or bus for which the device is connected.
//


//
// MessageId: ERROR_BACKUP_CONTROLLER
//
// MessageText:
//
// This operation is only allowed for the Primary Domain Controller of the domain.
//


//
// MessageId: ERROR_MUTANT_LIMIT_EXCEEDED
//
// MessageText:
//
// An attempt was made to acquire a mutant such that its maximum count would have been exceeded.
//


//
// MessageId: ERROR_FS_DRIVER_REQUIRED
//
// MessageText:
//
// A volume has been accessed for which a file system driver is required that has not yet been loaded.
//


//
// MessageId: ERROR_CANNOT_LOAD_REGISTRY_FILE
//
// MessageText:
//
// {Registry File Failure}
// The registry cannot load the hive (file):
// %hs
// or its log or alternate.
// It is corrupt, absent, or not writable.
//


//
// MessageId: ERROR_DEBUG_ATTACH_FAILED
//
// MessageText:
//
// {Unexpected Failure in DebugActiveProcess}
// An unexpected failure occurred while processing a DebugActiveProcess API request. You may choose OK to terminate the process, or Cancel to ignore the error.
//


//
// MessageId: ERROR_SYSTEM_PROCESS_TERMINATED
//
// MessageText:
//
// {Fatal System Error}
// The %hs system process terminated unexpectedly with a status of 0x%08x (0x%08x 0x%08x).
// The system has been shut down.
//


//
// MessageId: ERROR_DATA_NOT_ACCEPTED
//
// MessageText:
//
// {Data Not Accepted}
// The TDI client could not handle the data received during an indication.
//


//
// MessageId: ERROR_VDM_HARD_ERROR
//
// MessageText:
//
// NTVDM encountered a hard error.
//


//
// MessageId: ERROR_DRIVER_CANCEL_TIMEOUT
//
// MessageText:
//
// {Cancel Timeout}
// The driver %hs failed to complete a cancelled I/O request in the allotted time.
//


//
// MessageId: ERROR_REPLY_MESSAGE_MISMATCH
//
// MessageText:
//
// {Reply Message Mismatch}
// An attempt was made to reply to an LPC message, but the thread specified by the client ID in the message was not waiting on that message.
//


//
// MessageId: ERROR_LOST_WRITEBEHIND_DATA
//
// MessageText:
//
// {Delayed Write Failed}
// Windows was unable to save all the data for the file %hs. The data has been lost.
// This error may be caused by a failure of your computer hardware or network connection. Please try to save this file elsewhere.
//


//
// MessageId: ERROR_CLIENT_SERVER_PARAMETERS_INVALID
//
// MessageText:
//
// The parameter(s) passed to the server in the client/server shared memory window were invalid. Too much data may have been put in the shared memory window.
//


//
// MessageId: ERROR_NOT_TINY_STREAM
//
// MessageText:
//
// The stream is not a tiny stream.
//


//
// MessageId: ERROR_STACK_OVERFLOW_READ
//
// MessageText:
//
// The request must be handled by the stack overflow code.
//


//
// MessageId: ERROR_CONVERT_TO_LARGE
//
// MessageText:
//
// Internal OFS status codes indicating how an allocation operation is handled. Either it is retried after the containing onode is moved or the extent stream is converted to a large stream.
//


//
// MessageId: ERROR_FOUND_OUT_OF_SCOPE
//
// MessageText:
//
// The attempt to find the object found an object matching by ID on the volume but it is out of the scope of the handle used for the operation.
//


//
// MessageId: ERROR_ALLOCATE_BUCKET
//
// MessageText:
//
// The bucket array must be grown. Retry transaction after doing so.
//


//
// MessageId: ERROR_MARSHALL_OVERFLOW
//
// MessageText:
//
// The user/kernel marshalling buffer has overflowed.
//


//
// MessageId: ERROR_INVALID_VARIANT
//
// MessageText:
//
// The supplied variant structure contains invalid data.
//


//
// MessageId: ERROR_BAD_COMPRESSION_BUFFER
//
// MessageText:
//
// The specified buffer contains ill-formed data.
//


//
// MessageId: ERROR_AUDIT_FAILED
//
// MessageText:
//
// {Audit Failed}
// An attempt to generate a security audit failed.
//


//
// MessageId: ERROR_TIMER_RESOLUTION_NOT_SET
//
// MessageText:
//
// The timer resolution was not previously set by the current process.
//


//
// MessageId: ERROR_INSUFFICIENT_LOGON_INFO
//
// MessageText:
//
// There is insufficient account information to log you on.
//


//
// MessageId: ERROR_BAD_DLL_ENTRYPOINT
//
// MessageText:
//
// {Invalid DLL Entrypoint}
// The dynamic link library %hs is not written correctly. The stack pointer has been left in an inconsistent state.
// The entrypoint should be declared as WINAPI or STDCALL. Select YES to fail the DLL load. Select NO to continue execution. Selecting NO may cause the application to operate incorrectly.
//


//
// MessageId: ERROR_BAD_SERVICE_ENTRYPOINT
//
// MessageText:
//
// {Invalid Service Callback Entrypoint}
// The %hs service is not written correctly. The stack pointer has been left in an inconsistent state.
// The callback entrypoint should be declared as WINAPI or STDCALL. Selecting OK will cause the service to continue operation. However, the service process may operate incorrectly.
//


//
// MessageId: ERROR_IP_ADDRESS_CONFLICT1
//
// MessageText:
//
// There is an IP address conflict with another system on the network
//


//
// MessageId: ERROR_IP_ADDRESS_CONFLICT2
//
// MessageText:
//
// There is an IP address conflict with another system on the network
//


//
// MessageId: ERROR_REGISTRY_QUOTA_LIMIT
//
// MessageText:
//
// {Low On Registry Space}
// The system has reached the maximum size allowed for the system part of the registry. Additional storage requests will be ignored.
//


//
// MessageId: ERROR_NO_CALLBACK_ACTIVE
//
// MessageText:
//
// A callback return system service cannot be executed when no callback is active.
//


//
// MessageId: ERROR_PWD_TOO_SHORT
//
// MessageText:
//
// The password provided is too short to meet the policy of your user account.
// Please choose a longer password.
//


//
// MessageId: ERROR_PWD_TOO_RECENT
//
// MessageText:
//
// The policy of your user account does not allow you to change passwords too frequently.
// This is done to prevent users from changing back to a familiar, but potentially discovered, password.
// If you feel your password has been compromised then please contact your administrator immediately to have a new one assigned.
//


//
// MessageId: ERROR_PWD_HISTORY_CONFLICT
//
// MessageText:
//
// You have attempted to change your password to one that you have used in the past.
// The policy of your user account does not allow this. Please select a password that you have not previously used.
//


//
// MessageId: ERROR_UNSUPPORTED_COMPRESSION
//
// MessageText:
//
// The specified compression format is unsupported.
//


//
// MessageId: ERROR_INVALID_HW_PROFILE
//
// MessageText:
//
// The specified hardware profile configuration is invalid.
//


//
// MessageId: ERROR_INVALID_PLUGPLAY_DEVICE_PATH
//
// MessageText:
//
// The specified Plug and Play registry device path is invalid.
//


//
// MessageId: ERROR_QUOTA_LIST_INCONSISTENT
//
// MessageText:
//
// The specified quota list is internally inconsistent with its descriptor.
//


//
// MessageId: ERROR_EVALUATION_EXPIRATION
//
// MessageText:
//
// {Windows Evaluation Notification}
// The evaluation period for this installation of Windows has expired. This system will shutdown in 1 hour. To restore access to this installation of Windows, please upgrade this installation using a licensed distribution of this product.
//


//
// MessageId: ERROR_ILLEGAL_DLL_RELOCATION
//
// MessageText:
//
// {Illegal System DLL Relocation}
// The system DLL %hs was relocated in memory. The application will not run properly.
// The relocation occurred because the DLL %hs occupied an address range reserved for Windows system DLLs. The vendor supplying the DLL should be contacted for a new DLL.
//


//
// MessageId: ERROR_DLL_INIT_FAILED_LOGOFF
//
// MessageText:
//
// {DLL Initialization Failed}
// The application failed to initialize because the window station is shutting down.
//


//
// MessageId: ERROR_VALIDATE_CONTINUE
//
// MessageText:
//
// The validation process needs to continue on to the next step.
//


//
// MessageId: ERROR_NO_MORE_MATCHES
//
// MessageText:
//
// There are no more matches for the current index enumeration.
//


//
// MessageId: ERROR_RANGE_LIST_CONFLICT
//
// MessageText:
//
// The range could not be added to the range list because of a conflict.
//


//
// MessageId: ERROR_SERVER_SID_MISMATCH
//
// MessageText:
//
// The server process is running under a SID different than that required by client.
//


//
// MessageId: ERROR_CANT_ENABLE_DENY_ONLY
//
// MessageText:
//
// A group marked use for deny only cannot be enabled.
//


//
// MessageId: ERROR_FLOAT_MULTIPLE_FAULTS
//
// MessageText:
//
// {EXCEPTION}
// Multiple floating point faults.
//


//
// MessageId: ERROR_FLOAT_MULTIPLE_TRAPS
//
// MessageText:
//
// {EXCEPTION}
// Multiple floating point traps.
//


//
// MessageId: ERROR_NOINTERFACE
//
// MessageText:
//
// The requested interface is not supported.
//


//
// MessageId: ERROR_DRIVER_FAILED_SLEEP
//
// MessageText:
//
// {System Standby Failed}
// The driver %hs does not support standby mode. Updating this driver may allow the system to go to standby mode.
//


//
// MessageId: ERROR_CORRUPT_SYSTEM_FILE
//
// MessageText:
//
// The system file %1 has become corrupt and has been replaced.
//


//
// MessageId: ERROR_COMMITMENT_MINIMUM
//
// MessageText:
//
// {Virtual Memory Minimum Too Low}
// Your system is low on virtual memory. Windows is increasing the size of your virtual memory paging file.
// During this process, memory requests for some applications may be denied. For more information, see Help.
//


//
// MessageId: ERROR_PNP_RESTART_ENUMERATION
//
// MessageText:
//
// A device was removed so enumeration must be restarted.
//


//
// MessageId: ERROR_SYSTEM_IMAGE_BAD_SIGNATURE
//
// MessageText:
//
// {Fatal System Error}
// The system image %s is not properly signed.
// The file has been replaced with the signed file.
// The system has been shut down.
//


//
// MessageId: ERROR_PNP_REBOOT_REQUIRED
//
// MessageText:
//
// Device will not start without a reboot.
//


//
// MessageId: ERROR_INSUFFICIENT_POWER
//
// MessageText:
//
// There is not enough power to complete the requested operation.
//


//
// MessageId: ERROR_MULTIPLE_FAULT_VIOLATION
//
// MessageText:
//
//  ERROR_MULTIPLE_FAULT_VIOLATION
//


//
// MessageId: ERROR_SYSTEM_SHUTDOWN
//
// MessageText:
//
// The system is in the process of shutting down.
//


//
// MessageId: ERROR_PORT_NOT_SET
//
// MessageText:
//
// An attempt to remove a processes DebugPort was made, but a port was not already associated with the process.
//


//
// MessageId: ERROR_DS_VERSION_CHECK_FAILURE
//
// MessageText:
//
// This version of Windows is not compatible with the behavior version of directory forest, domain or domain controller.
//


//
// MessageId: ERROR_RANGE_NOT_FOUND
//
// MessageText:
//
// The specified range could not be found in the range list.
//


//
// MessageId: ERROR_NOT_SAFE_MODE_DRIVER
//
// MessageText:
//
// The driver was not loaded because the system is booting into safe mode.
//


//
// MessageId: ERROR_FAILED_DRIVER_ENTRY
//
// MessageText:
//
// The driver was not loaded because it failed its initialization call.
//


//
// MessageId: ERROR_DEVICE_ENUMERATION_ERROR
//
// MessageText:
//
// The "%hs" encountered an error while applying power or reading the device configuration.
// This may be caused by a failure of your hardware or by a poor connection.
//


//
// MessageId: ERROR_MOUNT_POINT_NOT_RESOLVED
//
// MessageText:
//
// The create operation failed because the name contained at least one mount point which resolves to a volume to which the specified device object is not attached.
//


//
// MessageId: ERROR_INVALID_DEVICE_OBJECT_PARAMETER
//
// MessageText:
//
// The device object parameter is either not a valid device object or is not attached to the volume specified by the file name.
//


//
// MessageId: ERROR_MCA_OCCURED
//
// MessageText:
//
// A Machine Check Error has occurred. Please check the system eventlog for additional information.
//


//
// MessageId: ERROR_DRIVER_DATABASE_ERROR
//
// MessageText:
//
// There was error [%2] processing the driver database.
//


//
// MessageId: ERROR_SYSTEM_HIVE_TOO_LARGE
//
// MessageText:
//
// System hive size has exceeded its limit.
//


//
// MessageId: ERROR_DRIVER_FAILED_PRIOR_UNLOAD
//
// MessageText:
//
// The driver could not be loaded because a previous version of the driver is still in memory.
//


//
// MessageId: ERROR_VOLSNAP_PREPARE_HIBERNATE
//
// MessageText:
//
// {Volume Shadow Copy Service}
// Please wait while the Volume Shadow Copy Service prepares volume %hs for hibernation.
//


//
// MessageId: ERROR_HIBERNATION_FAILURE
//
// MessageText:
//
// The system has failed to hibernate (The error code is %hs). Hibernation will be disabled until the system is restarted.
//


//
// MessageId: ERROR_PWD_TOO_LONG
//
// MessageText:
//
// The password provided is too long to meet the policy of your user account.
// Please choose a shorter password.
//


//
// MessageId: ERROR_FILE_SYSTEM_LIMITATION
//
// MessageText:
//
// The requested operation could not be completed due to a file system limitation
//


//
// MessageId: ERROR_ASSERTION_FAILURE
//
// MessageText:
//
// An assertion failure has occurred.
//


//
// MessageId: ERROR_ACPI_ERROR
//
// MessageText:
//
// An error occurred in the ACPI subsystem.
//


//
// MessageId: ERROR_WOW_ASSERTION
//
// MessageText:
//
// WOW Assertion Error.
//


//
// MessageId: ERROR_PNP_BAD_MPS_TABLE
//
// MessageText:
//
// A device is missing in the system BIOS MPS table. This device will not be used.
// Please contact your system vendor for system BIOS update.
//


//
// MessageId: ERROR_PNP_TRANSLATION_FAILED
//
// MessageText:
//
// A translator failed to translate resources.
//


//
// MessageId: ERROR_PNP_IRQ_TRANSLATION_FAILED
//
// MessageText:
//
// A IRQ translator failed to translate resources.
//


//
// MessageId: ERROR_PNP_INVALID_ID
//
// MessageText:
//
// Driver %2 returned invalid ID for a child device (%3).
//


//
// MessageId: ERROR_WAKE_SYSTEM_DEBUGGER
//
// MessageText:
//
// {Kernel Debugger Awakened}
// the system debugger was awakened by an interrupt.
//


//
// MessageId: ERROR_HANDLES_CLOSED
//
// MessageText:
//
// {Handles Closed}
// Handles to objects have been automatically closed as a result of the requested operation.
//


//
// MessageId: ERROR_EXTRANEOUS_INFORMATION
//
// MessageText:
//
// {Too Much Information}
// The specified access control list (ACL) contained more information than was expected.
//


//
// MessageId: ERROR_RXACT_COMMIT_NECESSARY
//
// MessageText:
//
// This warning level status indicates that the transaction state already exists for the registry sub-tree, but that a transaction commit was previously aborted.
// The commit has NOT been completed, but has not been rolled back either (so it may still be committed if desired).
//


//
// MessageId: ERROR_MEDIA_CHECK
//
// MessageText:
//
// {Media Changed}
// The media may have changed.
//


//
// MessageId: ERROR_GUID_SUBSTITUTION_MADE
//
// MessageText:
//
// {GUID Substitution}
// During the translation of a global identifier (GUID) to a Windows security ID (SID), no administratively-defined GUID prefix was found.
// A substitute prefix was used, which will not compromise system security. However, this may provide a more restrictive access than intended.
//


//
// MessageId: ERROR_STOPPED_ON_SYMLINK
//
// MessageText:
//
// The create operation stopped after reaching a symbolic link
//


//
// MessageId: ERROR_LONGJUMP
//
// MessageText:
//
// A long jump has been executed.
//


//
// MessageId: ERROR_PLUGPLAY_QUERY_VETOED
//
// MessageText:
//
// The Plug and Play query operation was not successful.
//


//
// MessageId: ERROR_UNWIND_CONSOLIDATE
//
// MessageText:
//
// A frame consolidation has been executed.
//


//
// MessageId: ERROR_REGISTRY_HIVE_RECOVERED
//
// MessageText:
//
// {Registry Hive Recovered}
// Registry hive (file):
// %hs
// was corrupted and it has been recovered. Some data might have been lost.
//


//
// MessageId: ERROR_DLL_MIGHT_BE_INSECURE
//
// MessageText:
//
// The application is attempting to run executable code from the module %hs. This may be insecure. An alternative, %hs, is available. Should the application use the secure module %hs?
//


//
// MessageId: ERROR_DLL_MIGHT_BE_INCOMPATIBLE
//
// MessageText:
//
// The application is loading executable code from the module %hs. This is secure, but may be incompatible with previous releases of the operating system. An alternative, %hs, is available. Should the application use the secure module %hs?
//


//
// MessageId: ERROR_DBG_EXCEPTION_NOT_HANDLED
//
// MessageText:
//
// Debugger did not handle the exception.
//


//
// MessageId: ERROR_DBG_REPLY_LATER
//
// MessageText:
//
// Debugger will reply later.
//


//
// MessageId: ERROR_DBG_UNABLE_TO_PROVIDE_HANDLE
//
// MessageText:
//
// Debugger cannot provide handle.
//


//
// MessageId: ERROR_DBG_TERMINATE_THREAD
//
// MessageText:
//
// Debugger terminated thread.
//


//
// MessageId: ERROR_DBG_TERMINATE_PROCESS
//
// MessageText:
//
// Debugger terminated process.
//


//
// MessageId: ERROR_DBG_CONTROL_C
//
// MessageText:
//
// Debugger got control C.
//


//
// MessageId: ERROR_DBG_PRINTEXCEPTION_C
//
// MessageText:
//
// Debugger printed exception on control C.
//


//
// MessageId: ERROR_DBG_RIPEXCEPTION
//
// MessageText:
//
// Debugger received RIP exception.
//


//
// MessageId: ERROR_DBG_CONTROL_BREAK
//
// MessageText:
//
// Debugger received control break.
//


//
// MessageId: ERROR_DBG_COMMAND_EXCEPTION
//
// MessageText:
//
// Debugger command communication exception.
//


//
// MessageId: ERROR_OBJECT_NAME_EXISTS
//
// MessageText:
//
// {Object Exists}
// An attempt was made to create an object and the object name already existed.
//


//
// MessageId: ERROR_THREAD_WAS_SUSPENDED
//
// MessageText:
//
// {Thread Suspended}
// A thread termination occurred while the thread was suspended. The thread was resumed, and termination proceeded.
//


//
// MessageId: ERROR_IMAGE_NOT_AT_BASE
//
// MessageText:
//
// {Image Relocated}
// An image file could not be mapped at the address specified in the image file. Local fixups must be performed on this image.
//


//
// MessageId: ERROR_RXACT_STATE_CREATED
//
// MessageText:
//
// This informational level status indicates that a specified registry sub-tree transaction state did not yet exist and had to be created.
//


//
// MessageId: ERROR_SEGMENT_NOTIFICATION
//
// MessageText:
//
// {Segment Load}
// A virtual DOS machine (VDM) is loading, unloading, or moving an MS-DOS or Win16 program segment image.
// An exception is raised so a debugger can load, unload or track symbols and breakpoints within these 16-bit segments.
//


//
// MessageId: ERROR_BAD_CURRENT_DIRECTORY
//
// MessageText:
//
// {Invalid Current Directory}
// The process cannot switch to the startup current directory %hs.
// Select OK to set current directory to %hs, or select CANCEL to exit.
//


//
// MessageId: ERROR_FT_READ_RECOVERY_FROM_BACKUP
//
// MessageText:
//
// {Redundant Read}
// To satisfy a read request, the NT fault-tolerant file system successfully read the requested data from a redundant copy.
// This was done because the file system encountered a failure on a member of the fault-tolerant volume, but was unable to reassign the failing area of the device.
//


//
// MessageId: ERROR_FT_WRITE_RECOVERY
//
// MessageText:
//
// {Redundant Write}
// To satisfy a write request, the NT fault-tolerant file system successfully wrote a redundant copy of the information.
// This was done because the file system encountered a failure on a member of the fault-tolerant volume, but was not able to reassign the failing area of the device.
//


//
// MessageId: ERROR_IMAGE_MACHINE_TYPE_MISMATCH
//
// MessageText:
//
// {Machine Type Mismatch}
// The image file %hs is valid, but is for a machine type other than the current machine. Select OK to continue, or CANCEL to fail the DLL load.
//


//
// MessageId: ERROR_RECEIVE_PARTIAL
//
// MessageText:
//
// {Partial Data Received}
// The network transport returned partial data to its client. The remaining data will be sent later.
//


//
// MessageId: ERROR_RECEIVE_EXPEDITED
//
// MessageText:
//
// {Expedited Data Received}
// The network transport returned data to its client that was marked as expedited by the remote system.
//


//
// MessageId: ERROR_RECEIVE_PARTIAL_EXPEDITED
//
// MessageText:
//
// {Partial Expedited Data Received}
// The network transport returned partial data to its client and this data was marked as expedited by the remote system. The remaining data will be sent later.
//


//
// MessageId: ERROR_EVENT_DONE
//
// MessageText:
//
// {TDI Event Done}
// The TDI indication has completed successfully.
//


//
// MessageId: ERROR_EVENT_PENDING
//
// MessageText:
//
// {TDI Event Pending}
// The TDI indication has entered the pending state.
//


//
// MessageId: ERROR_CHECKING_FILE_SYSTEM
//
// MessageText:
//
// Checking file system on %wZ
//


//
// MessageId: ERROR_FATAL_APP_EXIT
//
// MessageText:
//
// {Fatal Application Exit}
// %hs
//


//
// MessageId: ERROR_PREDEFINED_HANDLE
//
// MessageText:
//
// The specified registry key is referenced by a predefined handle.
//


//
// MessageId: ERROR_WAS_UNLOCKED
//
// MessageText:
//
// {Page Unlocked}
// The page protection of a locked page was changed to 'No Access' and the page was unlocked from memory and from the process.
//


//
// MessageId: ERROR_SERVICE_NOTIFICATION
//
// MessageText:
//
// %hs
//


//
// MessageId: ERROR_WAS_LOCKED
//
// MessageText:
//
// {Page Locked}
// One of the pages to lock was already locked.
//


//
// MessageId: ERROR_LOG_HARD_ERROR
//
// MessageText:
//
// Application popup: %1 : %2
//


//
// MessageId: ERROR_ALREADY_WIN32
//
// MessageText:
//
//  ERROR_ALREADY_WIN32
//


//
// MessageId: ERROR_IMAGE_MACHINE_TYPE_MISMATCH_EXE
//
// MessageText:
//
// {Machine Type Mismatch}
// The image file %hs is valid, but is for a machine type other than the current machine.
//


//
// MessageId: ERROR_NO_YIELD_PERFORMED
//
// MessageText:
//
// A yield execution was performed and no thread was available to run.
//


//
// MessageId: ERROR_TIMER_RESUME_IGNORED
//
// MessageText:
//
// The resumable flag to a timer API was ignored.
//


//
// MessageId: ERROR_ARBITRATION_UNHANDLED
//
// MessageText:
//
// The arbiter has deferred arbitration of these resources to its parent
//


//
// MessageId: ERROR_CARDBUS_NOT_SUPPORTED
//
// MessageText:
//
// The inserted CardBus device cannot be started because of a configuration error on "%hs".
//


//
// MessageId: ERROR_MP_PROCESSOR_MISMATCH
//
// MessageText:
//
// The CPUs in this multiprocessor system are not all the same revision level. To use all processors the operating system restricts itself to the features of the least capable processor in the system. Should problems occur with this system, contact the CPU manufacturer to see if this mix of processors is supported.
//


//
// MessageId: ERROR_HIBERNATED
//
// MessageText:
//
// The system was put into hibernation.
//


//
// MessageId: ERROR_RESUME_HIBERNATION
//
// MessageText:
//
// The system was resumed from hibernation.
//


//
// MessageId: ERROR_FIRMWARE_UPDATED
//
// MessageText:
//
// Windows has detected that the system firmware (BIOS) was updated [previous firmware date = %2, current firmware date %3].
//


//
// MessageId: ERROR_DRIVERS_LEAKING_LOCKED_PAGES
//
// MessageText:
//
// A device driver is leaking locked I/O pages causing system degradation. The system has automatically enabled tracking code in order to try and catch the culprit.
//


//
// MessageId: ERROR_WAKE_SYSTEM
//
// MessageText:
//
// The system has awoken
//


//
// MessageId: ERROR_WAIT_1
//
// MessageText:
//
//  ERROR_WAIT_1
//


//
// MessageId: ERROR_WAIT_2
//
// MessageText:
//
//  ERROR_WAIT_2
//


//
// MessageId: ERROR_WAIT_3
//
// MessageText:
//
//  ERROR_WAIT_3
//


//
// MessageId: ERROR_WAIT_63
//
// MessageText:
//
//  ERROR_WAIT_63
//


//
// MessageId: ERROR_ABANDONED_WAIT_0
//
// MessageText:
//
//  ERROR_ABANDONED_WAIT_0
//


//
// MessageId: ERROR_ABANDONED_WAIT_63
//
// MessageText:
//
//  ERROR_ABANDONED_WAIT_63
//


//
// MessageId: ERROR_USER_APC
//
// MessageText:
//
//  ERROR_USER_APC
//


//
// MessageId: ERROR_KERNEL_APC
//
// MessageText:
//
//  ERROR_KERNEL_APC
//


//
// MessageId: ERROR_ALERTED
//
// MessageText:
//
//  ERROR_ALERTED
//


//
// MessageId: ERROR_ELEVATION_REQUIRED
//
// MessageText:
//
// The requested operation requires elevation.
//


//
// MessageId: ERROR_REPARSE
//
// MessageText:
//
// A reparse should be performed by the Object Manager since the name of the file resulted in a symbolic link.
//


//
// MessageId: ERROR_OPLOCK_BREAK_IN_PROGRESS
//
// MessageText:
//
// An open/create operation completed while an oplock break is underway.
//


//
// MessageId: ERROR_VOLUME_MOUNTED
//
// MessageText:
//
// A new volume has been mounted by a file system.
//


//
// MessageId: ERROR_RXACT_COMMITTED
//
// MessageText:
//
// This success level status indicates that the transaction state already exists for the registry sub-tree, but that a transaction commit was previously aborted.
// The commit has now been completed.
//


//
// MessageId: ERROR_NOTIFY_CLEANUP
//
// MessageText:
//
// This indicates that a notify change request has been completed due to closing the handle which made the notify change request.
//


//
// MessageId: ERROR_PRIMARY_TRANSPORT_CONNECT_FAILED
//
// MessageText:
//
// {Connect Failure on Primary Transport}
// An attempt was made to connect to the remote server %hs on the primary transport, but the connection failed.
// The computer WAS able to connect on a secondary transport.
//


//
// MessageId: ERROR_PAGE_FAULT_TRANSITION
//
// MessageText:
//
// Page fault was a transition fault.
//


//
// MessageId: ERROR_PAGE_FAULT_DEMAND_ZERO
//
// MessageText:
//
// Page fault was a demand zero fault.
//


//
// MessageId: ERROR_PAGE_FAULT_COPY_ON_WRITE
//
// MessageText:
//
// Page fault was a demand zero fault.
//


//
// MessageId: ERROR_PAGE_FAULT_GUARD_PAGE
//
// MessageText:
//
// Page fault was a demand zero fault.
//


//
// MessageId: ERROR_PAGE_FAULT_PAGING_FILE
//
// MessageText:
//
// Page fault was satisfied by reading from a secondary storage device.
//


//
// MessageId: ERROR_CACHE_PAGE_LOCKED
//
// MessageText:
//
// Cached page was locked during operation.
//


//
// MessageId: ERROR_CRASH_DUMP
//
// MessageText:
//
// Crash dump exists in paging file.
//


//
// MessageId: ERROR_BUFFER_ALL_ZEROS
//
// MessageText:
//
// Specified buffer contains all zeros.
//


//
// MessageId: ERROR_REPARSE_OBJECT
//
// MessageText:
//
// A reparse should be performed by the Object Manager since the name of the file resulted in a symbolic link.
//


//
// MessageId: ERROR_RESOURCE_REQUIREMENTS_CHANGED
//
// MessageText:
//
// The device has succeeded a query-stop and its resource requirements have changed.
//


//
// MessageId: ERROR_TRANSLATION_COMPLETE
//
// MessageText:
//
// The translator has translated these resources into the global space and no further translations should be performed.
//


//
// MessageId: ERROR_NOTHING_TO_TERMINATE
//
// MessageText:
//
// A process being terminated has no threads to terminate.
//


//
// MessageId: ERROR_PROCESS_NOT_IN_JOB
//
// MessageText:
//
// The specified process is not part of a job.
//


//
// MessageId: ERROR_PROCESS_IN_JOB
//
// MessageText:
//
// The specified process is part of a job.
//


//
// MessageId: ERROR_VOLSNAP_HIBERNATE_READY
//
// MessageText:
//
// {Volume Shadow Copy Service}
// The system is now ready for hibernation.
//


//
// MessageId: ERROR_FSFILTER_OP_COMPLETED_SUCCESSFULLY
//
// MessageText:
//
// A file system or file system filter driver has successfully completed an FsFilter operation.
//


//
// MessageId: ERROR_INTERRUPT_VECTOR_ALREADY_CONNECTED
//
// MessageText:
//
// The specified interrupt vector was already connected.
//


//
// MessageId: ERROR_INTERRUPT_STILL_CONNECTED
//
// MessageText:
//
// The specified interrupt vector is still connected.
//


//
// MessageId: ERROR_WAIT_FOR_OPLOCK
//
// MessageText:
//
// An operation is blocked waiting for an oplock.
//


//
// MessageId: ERROR_DBG_EXCEPTION_HANDLED
//
// MessageText:
//
// Debugger handled exception
//


//
// MessageId: ERROR_DBG_CONTINUE
//
// MessageText:
//
// Debugger continued
//


//
// MessageId: ERROR_CALLBACK_POP_STACK
//
// MessageText:
//
// An exception occurred in a user mode callback and the kernel callback frame should be removed.
//


//
// MessageId: ERROR_COMPRESSION_DISABLED
//
// MessageText:
//
// Compression is disabled for this volume.
//


//
// MessageId: ERROR_CANTFETCHBACKWARDS
//
// MessageText:
//
// The data provider cannot fetch backwards through a result set.
//


//
// MessageId: ERROR_CANTSCROLLBACKWARDS
//
// MessageText:
//
// The data provider cannot scroll backwards through a result set.
//


//
// MessageId: ERROR_ROWSNOTRELEASED
//
// MessageText:
//
// The data provider requires that previously fetched data is released before asking for more data.
//


//
// MessageId: ERROR_BAD_ACCESSOR_FLAGS
//
// MessageText:
//
// The data provider was not able to interpret the flags set for a column binding in an accessor.
//


//
// MessageId: ERROR_ERRORS_ENCOUNTERED
//
// MessageText:
//
// One or more errors occurred while processing the request.
//


//
// MessageId: ERROR_NOT_CAPABLE
//
// MessageText:
//
// The implementation is not capable of performing the request.
//


//
// MessageId: ERROR_REQUEST_OUT_OF_SEQUENCE
//
// MessageText:
//
// The client of a component requested an operation which is not valid given the state of the component instance.
//


//
// MessageId: ERROR_VERSION_PARSE_ERROR
//
// MessageText:
//
// A version number could not be parsed.
//


//
// MessageId: ERROR_BADSTARTPOSITION
//
// MessageText:
//
// The iterator's start position is invalid.
//


//
// MessageId: ERROR_MEMORY_HARDWARE
//
// MessageText:
//
// The hardware has reported an uncorrectable memory error.
//


//
// MessageId: ERROR_DISK_REPAIR_DISABLED
//
// MessageText:
//
// The attempted operation required self healing to be enabled.
//


//
// MessageId: ERROR_INSUFFICIENT_RESOURCE_FOR_SPECIFIED_SHARED_SECTION_SIZE
//
// MessageText:
//
// The Desktop heap encountered an error while allocating session memory. There is more information in the system event log.
//


//
// MessageId: ERROR_SYSTEM_POWERSTATE_TRANSITION
//
// MessageText:
//
// The system power state is transitioning from %2 to %3.
//


//
// MessageId: ERROR_SYSTEM_POWERSTATE_COMPLEX_TRANSITION
//
// MessageText:
//
// The system power state is transitioning from %2 to %3 but could enter %4.
//


//
// MessageId: ERROR_MCA_EXCEPTION
//
// MessageText:
//
// A thread is getting dispatched with MCA EXCEPTION because of MCA.
//


//
// MessageId: ERROR_ACCESS_AUDIT_BY_POLICY
//
// MessageText:
//
// Access to %1 is monitored by policy rule %2.
//


//
// MessageId: ERROR_ACCESS_DISABLED_NO_SAFER_UI_BY_POLICY
//
// MessageText:
//
// Access to %1 has been restricted by your Administrator by policy rule %2.
//


//
// MessageId: ERROR_ABANDON_HIBERFILE
//
// MessageText:
//
// A valid hibernation file has been invalidated and should be abandoned.
//


//
// MessageId: ERROR_LOST_WRITEBEHIND_DATA_NETWORK_DISCONNECTED
//
// MessageText:
//
// {Delayed Write Failed}
// Windows was unable to save all the data for the file %hs; the data has been lost.
// This error may be caused by network connectivity issues. Please try to save this file elsewhere.
//


//
// MessageId: ERROR_LOST_WRITEBEHIND_DATA_NETWORK_SERVER_ERROR
//
// MessageText:
//
// {Delayed Write Failed}
// Windows was unable to save all the data for the file %hs; the data has been lost.
// This error was returned by the server on which the file exists. Please try to save this file elsewhere.
//


//
// MessageId: ERROR_LOST_WRITEBEHIND_DATA_LOCAL_DISK_ERROR
//
// MessageText:
//
// {Delayed Write Failed}
// Windows was unable to save all the data for the file %hs; the data has been lost.
// This error may be caused if the device has been removed or the media is write-protected.
//


//
// MessageId: ERROR_BAD_MCFG_TABLE
//
// MessageText:
//
// The resources required for this device conflict with the MCFG table.
//


//
// MessageId: ERROR_DISK_REPAIR_REDIRECTED
//
// MessageText:
//
// The volume repair could not be performed while it is online.
// Please schedule to take the volume offline so that it can be repaired.
//


//
// MessageId: ERROR_DISK_REPAIR_UNSUCCESSFUL
//
// MessageText:
//
// The volume repair was not successful.
//


//
// MessageId: ERROR_CORRUPT_LOG_OVERFULL
//
// MessageText:
//
// One of the volume corruption logs is full. Further corruptions that may be detected won't be logged.
//


//
// MessageId: ERROR_CORRUPT_LOG_CORRUPTED
//
// MessageText:
//
// One of the volume corruption logs is internally corrupted and needs to be recreated. The volume may contain undetected corruptions and must be scanned.
//


//
// MessageId: ERROR_CORRUPT_LOG_UNAVAILABLE
//
// MessageText:
//
// One of the volume corruption logs is unavailable for being operated on.
//


//
// MessageId: ERROR_CORRUPT_LOG_DELETED_FULL
//
// MessageText:
//
// One of the volume corruption logs was deleted while still having corruption records in them. The volume contains detected corruptions and must be scanned.
//


//
// MessageId: ERROR_CORRUPT_LOG_CLEARED
//
// MessageText:
//
// One of the volume corruption logs was cleared by chkdsk and no longer contains real corruptions.
//


//
// MessageId: ERROR_ORPHAN_NAME_EXHAUSTED
//
// MessageText:
//
// Orphaned files exist on the volume but could not be recovered because no more new names could be created in the recovery directory. Files must be moved from the recovery directory.
//


//
// MessageId: ERROR_OPLOCK_SWITCHED_TO_NEW_HANDLE
//
// MessageText:
//
// The oplock that was associated with this handle is now associated with a different handle.
//


//
// MessageId: ERROR_CANNOT_GRANT_REQUESTED_OPLOCK
//
// MessageText:
//
// An oplock of the requested level cannot be granted.  An oplock of a lower level may be available.
//


//
// MessageId: ERROR_CANNOT_BREAK_OPLOCK
//
// MessageText:
//
// The operation did not complete successfully because it would cause an oplock to be broken. The caller has requested that existing oplocks not be broken.
//


//
// MessageId: ERROR_OPLOCK_HANDLE_CLOSED
//
// MessageText:
//
// The handle with which this oplock was associated has been closed.  The oplock is now broken.
//


//
// MessageId: ERROR_NO_ACE_CONDITION
//
// MessageText:
//
// The specified access control entry (ACE) does not contain a condition.
//


//
// MessageId: ERROR_INVALID_ACE_CONDITION
//
// MessageText:
//
// The specified access control entry (ACE) contains an invalid condition.
//


//
// MessageId: ERROR_FILE_HANDLE_REVOKED
//
// MessageText:
//
// Access to the specified file handle has been revoked.
//


//
// MessageId: ERROR_IMAGE_AT_DIFFERENT_BASE
//
// MessageText:
//
// {Image Relocated}
// An image file was mapped at a different address from the one specified in the image file but fixups will still be automatically performed on the image.
//


//
// MessageId: ERROR_ENCRYPTED_IO_NOT_POSSIBLE
//
// MessageText:
//
// The read or write operation to an encrypted file could not be completed because the file has not been opened for data access.
//


//
// MessageId: ERROR_FILE_METADATA_OPTIMIZATION_IN_PROGRESS
//
// MessageText:
//
// File metadata optimization is already in progress.
//


//
// MessageId: ERROR_QUOTA_ACTIVITY
//
// MessageText:
//
// The requested operation failed due to quota operation is still in progress.
//


//
// MessageId: ERROR_HANDLE_REVOKED
//
// MessageText:
//
// Access to the specified handle has been revoked.
//


//
// MessageId: ERROR_CALLBACK_INVOKE_INLINE
//
// MessageText:
//
// The callback function must be invoked inline.
//


//
// MessageId: ERROR_CPU_SET_INVALID
//
// MessageText:
//
// The specified CPU Set IDs are invalid.
//


//
// MessageId: ERROR_ENCLAVE_NOT_TERMINATED
//
// MessageText:
//
// The specified enclave has not yet been terminated.
//


//
// MessageId: ERROR_ENCLAVE_VIOLATION
//
// MessageText:
//
// An attempt was made to access protected memory in violation of its secure access policy.
//


//
// **** Available SYSTEM error codes ****
//
//
// MessageId: ERROR_EA_ACCESS_DENIED
//
// MessageText:
//
// Access to the extended attribute was denied.
//


//
// MessageId: ERROR_OPERATION_ABORTED
//
// MessageText:
//
// The I/O operation has been aborted because of either a thread exit or an application request.
//


//
// MessageId: ERROR_IO_INCOMPLETE
//
// MessageText:
//
// Overlapped I/O event is not in a signaled state.
//


//
// MessageId: ERROR_IO_PENDING
//
// MessageText:
//
// Overlapped I/O operation is in progress.
//


//
// MessageId: ERROR_NOACCESS
//
// MessageText:
//
// Invalid access to memory location.
//


//
// MessageId: ERROR_SWAPERROR
//
// MessageText:
//
// Error performing inpage operation.
//


//
// MessageId: ERROR_STACK_OVERFLOW
//
// MessageText:
//
// Recursion too deep; the stack overflowed.
//


//
// MessageId: ERROR_INVALID_MESSAGE
//
// MessageText:
//
// The window cannot act on the sent message.
//


//
// MessageId: ERROR_CAN_NOT_COMPLETE
//
// MessageText:
//
// Cannot complete this function.
//


//
// MessageId: ERROR_INVALID_FLAGS
//
// MessageText:
//
// Invalid flags.
//


//
// MessageId: ERROR_UNRECOGNIZED_VOLUME
//
// MessageText:
//
// The volume does not contain a recognized file system.
// Please make sure that all required file system drivers are loaded and that the volume is not corrupted.
//


//
// MessageId: ERROR_FILE_INVALID
//
// MessageText:
//
// The volume for a file has been externally altered so that the opened file is no longer valid.
//


//
// MessageId: ERROR_FULLSCREEN_MODE
//
// MessageText:
//
// The requested operation cannot be performed in full-screen mode.
//


//
// MessageId: ERROR_NO_TOKEN
//
// MessageText:
//
// An attempt was made to reference a token that does not exist.
//


//
// MessageId: ERROR_BADDB
//
// MessageText:
//
// The configuration registry database is corrupt.
//


//
// MessageId: ERROR_BADKEY
//
// MessageText:
//
// The configuration registry key is invalid.
//


//
// MessageId: ERROR_CANTOPEN
//
// MessageText:
//
// The configuration registry key could not be opened.
//


//
// MessageId: ERROR_CANTREAD
//
// MessageText:
//
// The configuration registry key could not be read.
//


//
// MessageId: ERROR_CANTWRITE
//
// MessageText:
//
// The configuration registry key could not be written.
//


//
// MessageId: ERROR_REGISTRY_RECOVERED
//
// MessageText:
//
// One of the files in the registry database had to be recovered by use of a log or alternate copy. The recovery was successful.
//


//
// MessageId: ERROR_REGISTRY_CORRUPT
//
// MessageText:
//
// The registry is corrupted. The structure of one of the files containing registry data is corrupted, or the system's memory image of the file is corrupted, or the file could not be recovered because the alternate copy or log was absent or corrupted.
//


//
// MessageId: ERROR_REGISTRY_IO_FAILED
//
// MessageText:
//
// An I/O operation initiated by the registry failed unrecoverably. The registry could not read in, or write out, or flush, one of the files that contain the system's image of the registry.
//


//
// MessageId: ERROR_NOT_REGISTRY_FILE
//
// MessageText:
//
// The system has attempted to load or restore a file into the registry, but the specified file is not in a registry file format.
//


//
// MessageId: ERROR_KEY_DELETED
//
// MessageText:
//
// Illegal operation attempted on a registry key that has been marked for deletion.
//


//
// MessageId: ERROR_NO_LOG_SPACE
//
// MessageText:
//
// System could not allocate the required space in a registry log.
//


//
// MessageId: ERROR_KEY_HAS_CHILDREN
//
// MessageText:
//
// Cannot create a symbolic link in a registry key that already has subkeys or values.
//


//
// MessageId: ERROR_CHILD_MUST_BE_VOLATILE
//
// MessageText:
//
// Cannot create a stable subkey under a volatile parent key.
//


//
// MessageId: ERROR_NOTIFY_ENUM_DIR
//
// MessageText:
//
// A notify change request is being completed and the information is not being returned in the caller's buffer. The caller now needs to enumerate the files to find the changes.
//


//
// MessageId: ERROR_DEPENDENT_SERVICES_RUNNING
//
// MessageText:
//
// A stop control has been sent to a service that other running services are dependent on.
//


//
// MessageId: ERROR_INVALID_SERVICE_CONTROL
//
// MessageText:
//
// The requested control is not valid for this service.
//


//
// MessageId: ERROR_SERVICE_REQUEST_TIMEOUT
//
// MessageText:
//
// The service did not respond to the start or control request in a timely fashion.
//


//
// MessageId: ERROR_SERVICE_NO_THREAD
//
// MessageText:
//
// A thread could not be created for the service.
//


//
// MessageId: ERROR_SERVICE_DATABASE_LOCKED
//
// MessageText:
//
// The service database is locked.
//


//
// MessageId: ERROR_SERVICE_ALREADY_RUNNING
//
// MessageText:
//
// An instance of the service is already running.
//


//
// MessageId: ERROR_INVALID_SERVICE_ACCOUNT
//
// MessageText:
//
// The account name is invalid or does not exist, or the password is invalid for the account name specified.
//


//
// MessageId: ERROR_SERVICE_DISABLED
//
// MessageText:
//
// The service cannot be started, either because it is disabled or because it has no enabled devices associated with it.
//


//
// MessageId: ERROR_CIRCULAR_DEPENDENCY
//
// MessageText:
//
// Circular service dependency was specified.
//


//
// MessageId: ERROR_SERVICE_DOES_NOT_EXIST
//
// MessageText:
//
// The specified service does not exist as an installed service.
//


//
// MessageId: ERROR_SERVICE_CANNOT_ACCEPT_CTRL
//
// MessageText:
//
// The service cannot accept control messages at this time.
//


//
// MessageId: ERROR_SERVICE_NOT_ACTIVE
//
// MessageText:
//
// The service has not been started.
//


//
// MessageId: ERROR_FAILED_SERVICE_CONTROLLER_CONNECT
//
// MessageText:
//
// The service process could not connect to the service controller.
//


//
// MessageId: ERROR_EXCEPTION_IN_SERVICE
//
// MessageText:
//
// An exception occurred in the service when handling the control request.
//


//
// MessageId: ERROR_DATABASE_DOES_NOT_EXIST
//
// MessageText:
//
// The database specified does not exist.
//


//
// MessageId: ERROR_SERVICE_SPECIFIC_ERROR
//
// MessageText:
//
// The service has returned a service-specific error code.
//


//
// MessageId: ERROR_PROCESS_ABORTED
//
// MessageText:
//
// The process terminated unexpectedly.
//


//
// MessageId: ERROR_SERVICE_DEPENDENCY_FAIL
//
// MessageText:
//
// The dependency service or group failed to start.
//


//
// MessageId: ERROR_SERVICE_LOGON_FAILED
//
// MessageText:
//
// The service did not start due to a logon failure.
//


//
// MessageId: ERROR_SERVICE_START_HANG
//
// MessageText:
//
// After starting, the service hung in a start-pending state.
//


//
// MessageId: ERROR_INVALID_SERVICE_LOCK
//
// MessageText:
//
// The specified service database lock is invalid.
//


//
// MessageId: ERROR_SERVICE_MARKED_FOR_DELETE
//
// MessageText:
//
// The specified service has been marked for deletion.
//


//
// MessageId: ERROR_SERVICE_EXISTS
//
// MessageText:
//
// The specified service already exists.
//


//
// MessageId: ERROR_ALREADY_RUNNING_LKG
//
// MessageText:
//
// The system is currently running with the last-known-good configuration.
//


//
// MessageId: ERROR_SERVICE_DEPENDENCY_DELETED
//
// MessageText:
//
// The dependency service does not exist or has been marked for deletion.
//


//
// MessageId: ERROR_BOOT_ALREADY_ACCEPTED
//
// MessageText:
//
// The current boot has already been accepted for use as the last-known-good control set.
//


//
// MessageId: ERROR_SERVICE_NEVER_STARTED
//
// MessageText:
//
// No attempts to start the service have been made since the last boot.
//


//
// MessageId: ERROR_DUPLICATE_SERVICE_NAME
//
// MessageText:
//
// The name is already in use as either a service name or a service display name.
//


//
// MessageId: ERROR_DIFFERENT_SERVICE_ACCOUNT
//
// MessageText:
//
// The account specified for this service is different from the account specified for other services running in the same process.
//


//
// MessageId: ERROR_CANNOT_DETECT_DRIVER_FAILURE
//
// MessageText:
//
// Failure actions can only be set for Win32 services, not for drivers.
//


//
// MessageId: ERROR_CANNOT_DETECT_PROCESS_ABORT
//
// MessageText:
//
// This service runs in the same process as the service control manager.
// Therefore, the service control manager cannot take action if this service's process terminates unexpectedly.
//


//
// MessageId: ERROR_NO_RECOVERY_PROGRAM
//
// MessageText:
//
// No recovery program has been configured for this service.
//


//
// MessageId: ERROR_SERVICE_NOT_IN_EXE
//
// MessageText:
//
// The executable program that this service is configured to run in does not implement the service.
//


//
// MessageId: ERROR_NOT_SAFEBOOT_SERVICE
//
// MessageText:
//
// This service cannot be started in Safe Mode
//


//
// MessageId: ERROR_END_OF_MEDIA
//
// MessageText:
//
// The physical end of the tape has been reached.
//


//
// MessageId: ERROR_FILEMARK_DETECTED
//
// MessageText:
//
// A tape access reached a filemark.
//


//
// MessageId: ERROR_BEGINNING_OF_MEDIA
//
// MessageText:
//
// The beginning of the tape or a partition was encountered.
//


//
// MessageId: ERROR_SETMARK_DETECTED
//
// MessageText:
//
// A tape access reached the end of a set of files.
//


//
// MessageId: ERROR_NO_DATA_DETECTED
//
// MessageText:
//
// No more data is on the tape.
//


//
// MessageId: ERROR_PARTITION_FAILURE
//
// MessageText:
//
// Tape could not be partitioned.
//


//
// MessageId: ERROR_INVALID_BLOCK_LENGTH
//
// MessageText:
//
// When accessing a new tape of a multivolume partition, the current block size is incorrect.
//


//
// MessageId: ERROR_DEVICE_NOT_PARTITIONED
//
// MessageText:
//
// Tape partition information could not be found when loading a tape.
//


//
// MessageId: ERROR_UNABLE_TO_LOCK_MEDIA
//
// MessageText:
//
// Unable to lock the media eject mechanism.
//


//
// MessageId: ERROR_UNABLE_TO_UNLOAD_MEDIA
//
// MessageText:
//
// Unable to unload the media.
//


//
// MessageId: ERROR_MEDIA_CHANGED
//
// MessageText:
//
// The media in the drive may have changed.
//


//
// MessageId: ERROR_BUS_RESET
//
// MessageText:
//
// The I/O bus was reset.
//


//
// MessageId: ERROR_NO_MEDIA_IN_DRIVE
//
// MessageText:
//
// No media in drive.
//


//
// MessageId: ERROR_NO_UNICODE_TRANSLATION
//
// MessageText:
//
// No mapping for the Unicode character exists in the target multi-byte code page.
//


//
// MessageId: ERROR_DLL_INIT_FAILED
//
// MessageText:
//
// A dynamic link library (DLL) initialization routine failed.
//


//
// MessageId: ERROR_SHUTDOWN_IN_PROGRESS
//
// MessageText:
//
// A system shutdown is in progress.
//


//
// MessageId: ERROR_NO_SHUTDOWN_IN_PROGRESS
//
// MessageText:
//
// Unable to abort the system shutdown because no shutdown was in progress.
//


//
// MessageId: ERROR_IO_DEVICE
//
// MessageText:
//
// The request could not be performed because of an I/O device error.
//


//
// MessageId: ERROR_SERIAL_NO_DEVICE
//
// MessageText:
//
// No serial device was successfully initialized. The serial driver will unload.
//


//
// MessageId: ERROR_IRQ_BUSY
//
// MessageText:
//
// Unable to open a device that was sharing an interrupt request (IRQ) with other devices. At least one other device that uses that IRQ was already opened.
//


//
// MessageId: ERROR_MORE_WRITES
//
// MessageText:
//
// A serial I/O operation was completed by another write to the serial port.
// (The IOCTL_SERIAL_XOFF_COUNTER reached zero.)
//


//
// MessageId: ERROR_COUNTER_TIMEOUT
//
// MessageText:
//
// A serial I/O operation completed because the timeout period expired.
// (The IOCTL_SERIAL_XOFF_COUNTER did not reach zero.)
//


//
// MessageId: ERROR_FLOPPY_ID_MARK_NOT_FOUND
//
// MessageText:
//
// No ID address mark was found on the floppy disk.
//


//
// MessageId: ERROR_FLOPPY_WRONG_CYLINDER
//
// MessageText:
//
// Mismatch between the floppy disk sector ID field and the floppy disk controller track address.
//


//
// MessageId: ERROR_FLOPPY_UNKNOWN_ERROR
//
// MessageText:
//
// The floppy disk controller reported an error that is not recognized by the floppy disk driver.
//


//
// MessageId: ERROR_FLOPPY_BAD_REGISTERS
//
// MessageText:
//
// The floppy disk controller returned inconsistent results in its registers.
//


//
// MessageId: ERROR_DISK_RECALIBRATE_FAILED
//
// MessageText:
//
// While accessing the hard disk, a recalibrate operation failed, even after retries.
//


//
// MessageId: ERROR_DISK_OPERATION_FAILED
//
// MessageText:
//
// While accessing the hard disk, a disk operation failed even after retries.
//


//
// MessageId: ERROR_DISK_RESET_FAILED
//
// MessageText:
//
// While accessing the hard disk, a disk controller reset was needed, but even that failed.
//


//
// MessageId: ERROR_EOM_OVERFLOW
//
// MessageText:
//
// Physical end of tape encountered.
//


//
// MessageId: ERROR_NOT_ENOUGH_SERVER_MEMORY
//
// MessageText:
//
// Not enough server memory resources are available to process this command.
//


//
// MessageId: ERROR_POSSIBLE_DEADLOCK
//
// MessageText:
//
// A potential deadlock condition has been detected.
//


//
// MessageId: ERROR_MAPPED_ALIGNMENT
//
// MessageText:
//
// The base address or the file offset specified does not have the proper alignment.
//


//
// MessageId: ERROR_SET_POWER_STATE_VETOED
//
// MessageText:
//
// An attempt to change the system power state was vetoed by another application or driver.
//


//
// MessageId: ERROR_SET_POWER_STATE_FAILED
//
// MessageText:
//
// The system BIOS failed an attempt to change the system power state.
//


//
// MessageId: ERROR_TOO_MANY_LINKS
//
// MessageText:
//
// An attempt was made to create more links on a file than the file system supports.
//


//
// MessageId: ERROR_OLD_WIN_VERSION
//
// MessageText:
//
// The specified program requires a newer version of Windows.
//


//
// MessageId: ERROR_APP_WRONG_OS
//
// MessageText:
//
// The specified program is not a Windows or MS-DOS program.
//


//
// MessageId: ERROR_SINGLE_INSTANCE_APP
//
// MessageText:
//
// Cannot start more than one instance of the specified program.
//


//
// MessageId: ERROR_RMODE_APP
//
// MessageText:
//
// The specified program was written for an earlier version of Windows.
//


//
// MessageId: ERROR_INVALID_DLL
//
// MessageText:
//
// One of the library files needed to run this application is damaged.
//


//
// MessageId: ERROR_NO_ASSOCIATION
//
// MessageText:
//
// No application is associated with the specified file for this operation.
//


//
// MessageId: ERROR_DDE_FAIL
//
// MessageText:
//
// An error occurred in sending the command to the application.
//


//
// MessageId: ERROR_DLL_NOT_FOUND
//
// MessageText:
//
// One of the library files needed to run this application cannot be found.
//


//
// MessageId: ERROR_NO_MORE_USER_HANDLES
//
// MessageText:
//
// The current process has used all of its system allowance of handles for Window Manager objects.
//


//
// MessageId: ERROR_MESSAGE_SYNC_ONLY
//
// MessageText:
//
// The message can be used only with synchronous operations.
//


//
// MessageId: ERROR_SOURCE_ELEMENT_EMPTY
//
// MessageText:
//
// The indicated source element has no media.
//


//
// MessageId: ERROR_DESTINATION_ELEMENT_FULL
//
// MessageText:
//
// The indicated destination element already contains media.
//


//
// MessageId: ERROR_ILLEGAL_ELEMENT_ADDRESS
//
// MessageText:
//
// The indicated element does not exist.
//


//
// MessageId: ERROR_MAGAZINE_NOT_PRESENT
//
// MessageText:
//
// The indicated element is part of a magazine that is not present.
//


//
// MessageId: ERROR_DEVICE_REINITIALIZATION_NEEDED
//
// MessageText:
//
// The indicated device requires reinitialization due to hardware errors.
//


//
// MessageId: ERROR_DEVICE_REQUIRES_CLEANING
//
// MessageText:
//
// The device has indicated that cleaning is required before further operations are attempted.
//


//
// MessageId: ERROR_DEVICE_DOOR_OPEN
//
// MessageText:
//
// The device has indicated that its door is open.
//


//
// MessageId: ERROR_DEVICE_NOT_CONNECTED
//
// MessageText:
//
// The device is not connected.
//


//
// MessageId: ERROR_NOT_FOUND
//
// MessageText:
//
// Element not found.
//


//
// MessageId: ERROR_NO_MATCH
//
// MessageText:
//
// There was no match for the specified key in the index.
//


//
// MessageId: ERROR_SET_NOT_FOUND
//
// MessageText:
//
// The property set specified does not exist on the object.
//


//
// MessageId: ERROR_POINT_NOT_FOUND
//
// MessageText:
//
// The point passed to GetMouseMovePoints is not in the buffer.
//


//
// MessageId: ERROR_NO_TRACKING_SERVICE
//
// MessageText:
//
// The tracking (workstation) service is not running.
//


//
// MessageId: ERROR_NO_VOLUME_ID
//
// MessageText:
//
// The Volume ID could not be found.
//


//
// MessageId: ERROR_UNABLE_TO_REMOVE_REPLACED
//
// MessageText:
//
// Unable to remove the file to be replaced.
//


//
// MessageId: ERROR_UNABLE_TO_MOVE_REPLACEMENT
//
// MessageText:
//
// Unable to move the replacement file to the file to be replaced. The file to be replaced has retained its original name.
//


//
// MessageId: ERROR_UNABLE_TO_MOVE_REPLACEMENT_2
//
// MessageText:
//
// Unable to move the replacement file to the file to be replaced. The file to be replaced has been renamed using the backup name.
//


//
// MessageId: ERROR_JOURNAL_DELETE_IN_PROGRESS
//
// MessageText:
//
// The volume change journal is being deleted.
//


//
// MessageId: ERROR_JOURNAL_NOT_ACTIVE
//
// MessageText:
//
// The volume change journal is not active.
//


//
// MessageId: ERROR_POTENTIAL_FILE_FOUND
//
// MessageText:
//
// A file was found, but it may not be the correct file.
//


//
// MessageId: ERROR_JOURNAL_ENTRY_DELETED
//
// MessageText:
//
// The journal entry has been deleted from the journal.
//


//
// MessageId: ERROR_SHUTDOWN_IS_SCHEDULED
//
// MessageText:
//
// A system shutdown has already been scheduled.
//


//
// MessageId: ERROR_SHUTDOWN_USERS_LOGGED_ON
//
// MessageText:
//
// The system shutdown cannot be initiated because there are other users logged on to the computer.
//


//
// MessageId: ERROR_BAD_DEVICE
//
// MessageText:
//
// The specified device name is invalid.
//


//
// MessageId: ERROR_CONNECTION_UNAVAIL
//
// MessageText:
//
// The device is not currently connected but it is a remembered connection.
//


//
// MessageId: ERROR_DEVICE_ALREADY_REMEMBERED
//
// MessageText:
//
// The local device name has a remembered connection to another network resource.
//


//
// MessageId: ERROR_NO_NET_OR_BAD_PATH
//
// MessageText:
//
// The network path was either typed incorrectly, does not exist, or the network provider is not currently available. Please try retyping the path or contact your network administrator.
//


//
// MessageId: ERROR_BAD_PROVIDER
//
// MessageText:
//
// The specified network provider name is invalid.
//


//
// MessageId: ERROR_CANNOT_OPEN_PROFILE
//
// MessageText:
//
// Unable to open the network connection profile.
//


//
// MessageId: ERROR_BAD_PROFILE
//
// MessageText:
//
// The network connection profile is corrupted.
//


//
// MessageId: ERROR_NOT_CONTAINER
//
// MessageText:
//
// Cannot enumerate a noncontainer.
//


//
// MessageId: ERROR_EXTENDED_ERROR
//
// MessageText:
//
// An extended error has occurred.
//


//
// MessageId: ERROR_INVALID_GROUPNAME
//
// MessageText:
//
// The format of the specified group name is invalid.
//


//
// MessageId: ERROR_INVALID_COMPUTERNAME
//
// MessageText:
//
// The format of the specified computer name is invalid.
//


//
// MessageId: ERROR_INVALID_EVENTNAME
//
// MessageText:
//
// The format of the specified event name is invalid.
//


//
// MessageId: ERROR_INVALID_DOMAINNAME
//
// MessageText:
//
// The format of the specified domain name is invalid.
//


//
// MessageId: ERROR_INVALID_SERVICENAME
//
// MessageText:
//
// The format of the specified service name is invalid.
//


//
// MessageId: ERROR_INVALID_NETNAME
//
// MessageText:
//
// The format of the specified network name is invalid.
//


//
// MessageId: ERROR_INVALID_SHARENAME
//
// MessageText:
//
// The format of the specified share name is invalid.
//


//
// MessageId: ERROR_INVALID_PASSWORDNAME
//
// MessageText:
//
// The format of the specified password is invalid.
//


//
// MessageId: ERROR_INVALID_MESSAGENAME
//
// MessageText:
//
// The format of the specified message name is invalid.
//


//
// MessageId: ERROR_INVALID_MESSAGEDEST
//
// MessageText:
//
// The format of the specified message destination is invalid.
//


//
// MessageId: ERROR_SESSION_CREDENTIAL_CONFLICT
//
// MessageText:
//
// Multiple connections to a server or shared resource by the same user, using more than one user name, are not allowed. Disconnect all previous connections to the server or shared resource and try again.
//


//
// MessageId: ERROR_REMOTE_SESSION_LIMIT_EXCEEDED
//
// MessageText:
//
// An attempt was made to establish a session to a network server, but there are already too many sessions established to that server.
//


//
// MessageId: ERROR_DUP_DOMAINNAME
//
// MessageText:
//
// The workgroup or domain name is already in use by another computer on the network.
//


//
// MessageId: ERROR_NO_NETWORK
//
// MessageText:
//
// The network is not present or not started.
//


//
// MessageId: ERROR_CANCELLED
//
// MessageText:
//
// The operation was canceled by the user.
//


//
// MessageId: ERROR_USER_MAPPED_FILE
//
// MessageText:
//
// The requested operation cannot be performed on a file with a user-mapped section open.
//


//
// MessageId: ERROR_CONNECTION_REFUSED
//
// MessageText:
//
// The remote computer refused the network connection.
//


//
// MessageId: ERROR_GRACEFUL_DISCONNECT
//
// MessageText:
//
// The network connection was gracefully closed.
//


//
// MessageId: ERROR_ADDRESS_ALREADY_ASSOCIATED
//
// MessageText:
//
// The network transport endpoint already has an address associated with it.
//


//
// MessageId: ERROR_ADDRESS_NOT_ASSOCIATED
//
// MessageText:
//
// An address has not yet been associated with the network endpoint.
//


//
// MessageId: ERROR_CONNECTION_INVALID
//
// MessageText:
//
// An operation was attempted on a nonexistent network connection.
//


//
// MessageId: ERROR_CONNECTION_ACTIVE
//
// MessageText:
//
// An invalid operation was attempted on an active network connection.
//


//
// MessageId: ERROR_NETWORK_UNREACHABLE
//
// MessageText:
//
// The network location cannot be reached. For information about network troubleshooting, see Windows Help.
//


//
// MessageId: ERROR_HOST_UNREACHABLE
//
// MessageText:
//
// The network location cannot be reached. For information about network troubleshooting, see Windows Help.
//


//
// MessageId: ERROR_PROTOCOL_UNREACHABLE
//
// MessageText:
//
// The network location cannot be reached. For information about network troubleshooting, see Windows Help.
//


//
// MessageId: ERROR_PORT_UNREACHABLE
//
// MessageText:
//
// No service is operating at the destination network endpoint on the remote system.
//


//
// MessageId: ERROR_REQUEST_ABORTED
//
// MessageText:
//
// The request was aborted.
//


//
// MessageId: ERROR_CONNECTION_ABORTED
//
// MessageText:
//
// The network connection was aborted by the local system.
//


//
// MessageId: ERROR_RETRY
//
// MessageText:
//
// The operation could not be completed. A retry should be performed.
//


//
// MessageId: ERROR_CONNECTION_COUNT_LIMIT
//
// MessageText:
//
// A connection to the server could not be made because the limit on the number of concurrent connections for this account has been reached.
//


//
// MessageId: ERROR_LOGIN_TIME_RESTRICTION
//
// MessageText:
//
// Attempting to log in during an unauthorized time of day for this account.
//


//
// MessageId: ERROR_LOGIN_WKSTA_RESTRICTION
//
// MessageText:
//
// The account is not authorized to log in from this station.
//


//
// MessageId: ERROR_INCORRECT_ADDRESS
//
// MessageText:
//
// The network address could not be used for the operation requested.
//


//
// MessageId: ERROR_ALREADY_REGISTERED
//
// MessageText:
//
// The service is already registered.
//


//
// MessageId: ERROR_SERVICE_NOT_FOUND
//
// MessageText:
//
// The specified service does not exist.
//


//
// MessageId: ERROR_NOT_AUTHENTICATED
//
// MessageText:
//
// The operation being requested was not performed because the user has not been authenticated.
//


//
// MessageId: ERROR_NOT_LOGGED_ON
//
// MessageText:
//
// The operation being requested was not performed because the user has not logged on to the network. The specified service does not exist.
//


//
// MessageId: ERROR_CONTINUE
//
// MessageText:
//
// Continue with work in progress.
//


//
// MessageId: ERROR_ALREADY_INITIALIZED
//
// MessageText:
//
// An attempt was made to perform an initialization operation when initialization has already been completed.
//


//
// MessageId: ERROR_NO_MORE_DEVICES
//
// MessageText:
//
// No more local devices.
//


//
// MessageId: ERROR_NO_SUCH_SITE
//
// MessageText:
//
// The specified site does not exist.
//


//
// MessageId: ERROR_DOMAIN_CONTROLLER_EXISTS
//
// MessageText:
//
// A domain controller with the specified name already exists.
//


//
// MessageId: ERROR_ONLY_IF_CONNECTED
//
// MessageText:
//
// This operation is supported only when you are connected to the server.
//


//
// MessageId: ERROR_OVERRIDE_NOCHANGES
//
// MessageText:
//
// The group policy framework should call the extension even if there are no changes.
//


//
// MessageId: ERROR_BAD_USER_PROFILE
//
// MessageText:
//
// The specified user does not have a valid profile.
//


//
// MessageId: ERROR_NOT_SUPPORTED_ON_SBS
//
// MessageText:
//
// This operation is not supported on a computer running Windows Server 2003 for Small Business Server
//


//
// MessageId: ERROR_SERVER_SHUTDOWN_IN_PROGRESS
//
// MessageText:
//
// The server machine is shutting down.
//


//
// MessageId: ERROR_HOST_DOWN
//
// MessageText:
//
// The remote system is not available. For information about network troubleshooting, see Windows Help.
//


//
// MessageId: ERROR_NON_ACCOUNT_SID
//
// MessageText:
//
// The security identifier provided is not from an account domain.
//


//
// MessageId: ERROR_NON_DOMAIN_SID
//
// MessageText:
//
// The security identifier provided does not have a domain component.
//


//
// MessageId: ERROR_APPHELP_BLOCK
//
// MessageText:
//
// AppHelp dialog canceled thus preventing the application from starting.
//


//
// MessageId: ERROR_ACCESS_DISABLED_BY_POLICY
//
// MessageText:
//
// This program is blocked by group policy. For more information, contact your system administrator.
//


//
// MessageId: ERROR_REG_NAT_CONSUMPTION
//
// MessageText:
//
// A program attempt to use an invalid register value. Normally caused by an uninitialized register. This error is Itanium specific.
//


//
// MessageId: ERROR_CSCSHARE_OFFLINE
//
// MessageText:
//
// The share is currently offline or does not exist.
//


//
// MessageId: ERROR_PKINIT_FAILURE
//
// MessageText:
//
// The Kerberos protocol encountered an error while validating the KDC certificate during smartcard logon. There is more information in the system event log.
//


//
// MessageId: ERROR_SMARTCARD_SUBSYSTEM_FAILURE
//
// MessageText:
//
// The Kerberos protocol encountered an error while attempting to utilize the smartcard subsystem.
//


//
// MessageId: ERROR_DOWNGRADE_DETECTED
//
// MessageText:
//
// The system cannot contact a domain controller to service the authentication request. Please try again later.
//


//
// Do not use ID's 1266 - 1270 as the symbolicNames have been moved to SEC_E_*
//
//
// MessageId: ERROR_MACHINE_LOCKED
//
// MessageText:
//
// The machine is locked and cannot be shut down without the force option.
//


//
// MessageId: ERROR_SMB_GUEST_LOGON_BLOCKED
//
// MessageText:
//
// You can't access this shared folder because your organization's security policies block unauthenticated guest access. These policies help protect your PC from unsafe or malicious devices on the network.
//


//
// MessageId: ERROR_CALLBACK_SUPPLIED_INVALID_DATA
//
// MessageText:
//
// An application-defined callback gave invalid data when called.
//


//
// MessageId: ERROR_SYNC_FOREGROUND_REFRESH_REQUIRED
//
// MessageText:
//
// The group policy framework should call the extension in the synchronous foreground policy refresh.
//


//
// MessageId: ERROR_DRIVER_BLOCKED
//
// MessageText:
//
// This driver has been blocked from loading
//


//
// MessageId: ERROR_INVALID_IMPORT_OF_NON_DLL
//
// MessageText:
//
// A dynamic link library (DLL) referenced a module that was neither a DLL nor the process's executable image.
//


//
// MessageId: ERROR_ACCESS_DISABLED_WEBBLADE
//
// MessageText:
//
// Windows cannot open this program since it has been disabled.
//


//
// MessageId: ERROR_ACCESS_DISABLED_WEBBLADE_TAMPER
//
// MessageText:
//
// Windows cannot open this program because the license enforcement system has been tampered with or become corrupted.
//


//
// MessageId: ERROR_RECOVERY_FAILURE
//
// MessageText:
//
// A transaction recover failed.
//


//
// MessageId: ERROR_ALREADY_FIBER
//
// MessageText:
//
// The current thread has already been converted to a fiber.
//


//
// MessageId: ERROR_ALREADY_THREAD
//
// MessageText:
//
// The current thread has already been converted from a fiber.
//


//
// MessageId: ERROR_STACK_BUFFER_OVERRUN
//
// MessageText:
//
// The system detected an overrun of a stack-based buffer in this application. This overrun could potentially allow a malicious user to gain control of this application.
//


//
// MessageId: ERROR_PARAMETER_QUOTA_EXCEEDED
//
// MessageText:
//
// Data present in one of the parameters is more than the function can operate on.
//


//
// MessageId: ERROR_DEBUGGER_INACTIVE
//
// MessageText:
//
// An attempt to do an operation on a debug object failed because the object is in the process of being deleted.
//


//
// MessageId: ERROR_DELAY_LOAD_FAILED
//
// MessageText:
//
// An attempt to delay-load a .dll or get a function address in a delay-loaded .dll failed.
//


//
// MessageId: ERROR_VDM_DISALLOWED
//
// MessageText:
//
// %1 is a 16-bit application. You do not have permissions to execute 16-bit applications. Check your permissions with your system administrator.
//


//
// MessageId: ERROR_UNIDENTIFIED_ERROR
//
// MessageText:
//
// Insufficient information exists to identify the cause of failure.
//


//
// MessageId: ERROR_INVALID_CRUNTIME_PARAMETER
//
// MessageText:
//
// The parameter passed to a C runtime function is incorrect.
//


//
// MessageId: ERROR_BEYOND_VDL
//
// MessageText:
//
// The operation occurred beyond the valid data length of the file.
//


//
// MessageId: ERROR_INCOMPATIBLE_SERVICE_SID_TYPE
//
// MessageText:
//
// The service start failed since one or more services in the same process have an incompatible service SID type setting. A service with restricted service SID type can only coexist in the same process with other services with a restricted SID type. If the service SID type for this service was just configured, the hosting process must be restarted in order to start this service.
//


//
// MessageId: ERROR_DRIVER_PROCESS_TERMINATED
//
// MessageText:
//
// The process hosting the driver for this device has been terminated.
//


//
// MessageId: ERROR_IMPLEMENTATION_LIMIT
//
// MessageText:
//
// An operation attempted to exceed an implementation-defined limit.
//


//
// MessageId: ERROR_PROCESS_IS_PROTECTED
//
// MessageText:
//
// Either the target process, or the target thread's containing process, is a protected process.
//


//
// MessageId: ERROR_SERVICE_NOTIFY_CLIENT_LAGGING
//
// MessageText:
//
// The service notification client is lagging too far behind the current state of services in the machine.
//


//
// MessageId: ERROR_DISK_QUOTA_EXCEEDED
//
// MessageText:
//
// The requested file operation failed because the storage quota was exceeded.
// To free up disk space, move files to a different location or delete unnecessary files. For more information, contact your system administrator.
//


//
// MessageId: ERROR_CONTENT_BLOCKED
//
// MessageText:
//
// The requested file operation failed because the storage policy blocks that type of file. For more information, contact your system administrator.
//


//
// MessageId: ERROR_INCOMPATIBLE_SERVICE_PRIVILEGE
//
// MessageText:
//
// A privilege that the service requires to function properly does not exist in the service account configuration.
// You may use the Services Microsoft Management Console (MMC) snap-in (services.msc) and the Local Security Settings MMC snap-in (secpol.msc) to view the service configuration and the account configuration.
//


//
// MessageId: ERROR_APP_HANG
//
// MessageText:
//
// A thread involved in this operation appears to be unresponsive.
//



///////////////////////////////////////////////////
//                                               //
//             SECURITY Error codes              //
//                                               //
//                 1299 to 1399                  //
///////////////////////////////////////////////////

//
// MessageId: ERROR_INVALID_LABEL
//
// MessageText:
//
// Indicates a particular Security ID may not be assigned as the label of an object.
//


//
// MessageId: ERROR_NOT_ALL_ASSIGNED
//
// MessageText:
//
// Not all privileges or groups referenced are assigned to the caller.
//


//
// MessageId: ERROR_SOME_NOT_MAPPED
//
// MessageText:
//
// Some mapping between account names and security IDs was not done.
//


//
// MessageId: ERROR_NO_QUOTAS_FOR_ACCOUNT
//
// MessageText:
//
// No system quota limits are specifically set for this account.
//


//
// MessageId: ERROR_LOCAL_USER_SESSION_KEY
//
// MessageText:
//
// No encryption key is available. A well-known encryption key was returned.
//


//
// MessageId: ERROR_NULL_LM_PASSWORD
//
// MessageText:
//
// The password is too complex to be converted to a LAN Manager password. The LAN Manager password returned is a NULL string.
//


//
// MessageId: ERROR_UNKNOWN_REVISION
//
// MessageText:
//
// The revision level is unknown.
//


//
// MessageId: ERROR_REVISION_MISMATCH
//
// MessageText:
//
// Indicates two revision levels are incompatible.
//


//
// MessageId: ERROR_INVALID_OWNER
//
// MessageText:
//
// This security ID may not be assigned as the owner of this object.
//


//
// MessageId: ERROR_INVALID_PRIMARY_GROUP
//
// MessageText:
//
// This security ID may not be assigned as the primary group of an object.
//


//
// MessageId: ERROR_NO_IMPERSONATION_TOKEN
//
// MessageText:
//
// An attempt has been made to operate on an impersonation token by a thread that is not currently impersonating a client.
//


//
// MessageId: ERROR_CANT_DISABLE_MANDATORY
//
// MessageText:
//
// The group may not be disabled.
//


//
// MessageId: ERROR_NO_LOGON_SERVERS
//
// MessageText:
//
// We can't sign you in with this credential because your domain isn't available. Make sure your device is connected to your organization's network and try again. If you previously signed in on this device with another credential, you can sign in with that credential.
//


//
// MessageId: ERROR_NO_SUCH_LOGON_SESSION
//
// MessageText:
//
// A specified logon session does not exist. It may already have been terminated.
//


//
// MessageId: ERROR_NO_SUCH_PRIVILEGE
//
// MessageText:
//
// A specified privilege does not exist.
//


//
// MessageId: ERROR_PRIVILEGE_NOT_HELD
//
// MessageText:
//
// A required privilege is not held by the client.
//


//
// MessageId: ERROR_INVALID_ACCOUNT_NAME
//
// MessageText:
//
// The name provided is not a properly formed account name.
//


//
// MessageId: ERROR_USER_EXISTS
//
// MessageText:
//
// The specified account already exists.
//


//
// MessageId: ERROR_NO_SUCH_USER
//
// MessageText:
//
// The specified account does not exist.
//


//
// MessageId: ERROR_GROUP_EXISTS
//
// MessageText:
//
// The specified group already exists.
//


//
// MessageId: ERROR_NO_SUCH_GROUP
//
// MessageText:
//
// The specified group does not exist.
//


//
// MessageId: ERROR_MEMBER_IN_GROUP
//
// MessageText:
//
// Either the specified user account is already a member of the specified group, or the specified group cannot be deleted because it contains a member.
//


//
// MessageId: ERROR_MEMBER_NOT_IN_GROUP
//
// MessageText:
//
// The specified user account is not a member of the specified group account.
//


//
// MessageId: ERROR_LAST_ADMIN
//
// MessageText:
//
// This operation is disallowed as it could result in an administration account being disabled, deleted or unable to logon.
//


//
// MessageId: ERROR_WRONG_PASSWORD
//
// MessageText:
//
// Unable to update the password. The value provided as the current password is incorrect.
//


//
// MessageId: ERROR_ILL_FORMED_PASSWORD
//
// MessageText:
//
// Unable to update the password. The value provided for the new password contains values that are not allowed in passwords.
//


//
// MessageId: ERROR_PASSWORD_RESTRICTION
//
// MessageText:
//
// Unable to update the password. The value provided for the new password does not meet the length, complexity, or history requirements of the domain.
//


//
// MessageId: ERROR_LOGON_FAILURE
//
// MessageText:
//
// The user name or password is incorrect.
//


//
// MessageId: ERROR_ACCOUNT_RESTRICTION
//
// MessageText:
//
// Account restrictions are preventing this user from signing in. For example: blank passwords aren't allowed, sign-in times are limited, or a policy restriction has been enforced.
//


//
// MessageId: ERROR_INVALID_LOGON_HOURS
//
// MessageText:
//
// Your account has time restrictions that keep you from signing in right now.
//


//
// MessageId: ERROR_INVALID_WORKSTATION
//
// MessageText:
//
// This user isn't allowed to sign in to this computer.
//


//
// MessageId: ERROR_PASSWORD_EXPIRED
//
// MessageText:
//
// The password for this account has expired.
//


//
// MessageId: ERROR_ACCOUNT_DISABLED
//
// MessageText:
//
// This user can't sign in because this account is currently disabled.
//


//
// MessageId: ERROR_NONE_MAPPED
//
// MessageText:
//
// No mapping between account names and security IDs was done.
//


//
// MessageId: ERROR_TOO_MANY_LUIDS_REQUESTED
//
// MessageText:
//
// Too many local user identifiers (LUIDs) were requested at one time.
//


//
// MessageId: ERROR_LUIDS_EXHAUSTED
//
// MessageText:
//
// No more local user identifiers (LUIDs) are available.
//


//
// MessageId: ERROR_INVALID_SUB_AUTHORITY
//
// MessageText:
//
// The subauthority part of a security ID is invalid for this particular use.
//


//
// MessageId: ERROR_INVALID_ACL
//
// MessageText:
//
// The access control list (ACL) structure is invalid.
//


//
// MessageId: ERROR_INVALID_SID
//
// MessageText:
//
// The security ID structure is invalid.
//


//
// MessageId: ERROR_INVALID_SECURITY_DESCR
//
// MessageText:
//
// The security descriptor structure is invalid.
//


//
// MessageId: ERROR_BAD_INHERITANCE_ACL
//
// MessageText:
//
// The inherited access control list (ACL) or access control entry (ACE) could not be built.
//


//
// MessageId: ERROR_SERVER_DISABLED
//
// MessageText:
//
// The server is currently disabled.
//


//
// MessageId: ERROR_SERVER_NOT_DISABLED
//
// MessageText:
//
// The server is currently enabled.
//


//
// MessageId: ERROR_INVALID_ID_AUTHORITY
//
// MessageText:
//
// The value provided was an invalid value for an identifier authority.
//


//
// MessageId: ERROR_ALLOTTED_SPACE_EXCEEDED
//
// MessageText:
//
// No more memory is available for security information updates.
//


//
// MessageId: ERROR_INVALID_GROUP_ATTRIBUTES
//
// MessageText:
//
// The specified attributes are invalid, or incompatible with the attributes for the group as a whole.
//


//
// MessageId: ERROR_BAD_IMPERSONATION_LEVEL
//
// MessageText:
//
// Either a required impersonation level was not provided, or the provided impersonation level is invalid.
//


//
// MessageId: ERROR_CANT_OPEN_ANONYMOUS
//
// MessageText:
//
// Cannot open an anonymous level security token.
//


//
// MessageId: ERROR_BAD_VALIDATION_CLASS
//
// MessageText:
//
// The validation information class requested was invalid.
//


//
// MessageId: ERROR_BAD_TOKEN_TYPE
//
// MessageText:
//
// The type of the token is inappropriate for its attempted use.
//


//
// MessageId: ERROR_NO_SECURITY_ON_OBJECT
//
// MessageText:
//
// Unable to perform a security operation on an object that has no associated security.
//


//
// MessageId: ERROR_CANT_ACCESS_DOMAIN_INFO
//
// MessageText:
//
// Configuration information could not be read from the domain controller, either because the machine is unavailable, or access has been denied.
//


//
// MessageId: ERROR_INVALID_SERVER_STATE
//
// MessageText:
//
// The security account manager (SAM) or local security authority (LSA) server was in the wrong state to perform the security operation.
//


//
// MessageId: ERROR_INVALID_DOMAIN_STATE
//
// MessageText:
//
// The domain was in the wrong state to perform the security operation.
//


//
// MessageId: ERROR_INVALID_DOMAIN_ROLE
//
// MessageText:
//
// This operation is only allowed for the Primary Domain Controller of the domain.
//


//
// MessageId: ERROR_NO_SUCH_DOMAIN
//
// MessageText:
//
// The specified domain either does not exist or could not be contacted.
//


//
// MessageId: ERROR_DOMAIN_EXISTS
//
// MessageText:
//
// The specified domain already exists.
//


//
// MessageId: ERROR_DOMAIN_LIMIT_EXCEEDED
//
// MessageText:
//
// An attempt was made to exceed the limit on the number of domains per server.
//


//
// MessageId: ERROR_INTERNAL_DB_CORRUPTION
//
// MessageText:
//
// Unable to complete the requested operation because of either a catastrophic media failure or a data structure corruption on the disk.
//


//
// MessageId: ERROR_INTERNAL_ERROR
//
// MessageText:
//
// An internal error occurred.
//


//
// MessageId: ERROR_GENERIC_NOT_MAPPED
//
// MessageText:
//
// Generic access types were contained in an access mask which should already be mapped to nongeneric types.
//


//
// MessageId: ERROR_BAD_DESCRIPTOR_FORMAT
//
// MessageText:
//
// A security descriptor is not in the right format (absolute or self-relative).
//


//
// MessageId: ERROR_NOT_LOGON_PROCESS
//
// MessageText:
//
// The requested action is restricted for use by logon processes only. The calling process has not registered as a logon process.
//


//
// MessageId: ERROR_LOGON_SESSION_EXISTS
//
// MessageText:
//
// Cannot start a new logon session with an ID that is already in use.
//


//
// MessageId: ERROR_NO_SUCH_PACKAGE
//
// MessageText:
//
// A specified authentication package is unknown.
//


//
// MessageId: ERROR_BAD_LOGON_SESSION_STATE
//
// MessageText:
//
// The logon session is not in a state that is consistent with the requested operation.
//


//
// MessageId: ERROR_LOGON_SESSION_COLLISION
//
// MessageText:
//
// The logon session ID is already in use.
//


//
// MessageId: ERROR_INVALID_LOGON_TYPE
//
// MessageText:
//
// A logon request contained an invalid logon type value.
//


//
// MessageId: ERROR_CANNOT_IMPERSONATE
//
// MessageText:
//
// Unable to impersonate using a named pipe until data has been read from that pipe.
//


//
// MessageId: ERROR_RXACT_INVALID_STATE
//
// MessageText:
//
// The transaction state of a registry subtree is incompatible with the requested operation.
//


//
// MessageId: ERROR_RXACT_COMMIT_FAILURE
//
// MessageText:
//
// An internal security database corruption has been encountered.
//


//
// MessageId: ERROR_SPECIAL_ACCOUNT
//
// MessageText:
//
// Cannot perform this operation on built-in accounts.
//


//
// MessageId: ERROR_SPECIAL_GROUP
//
// MessageText:
//
// Cannot perform this operation on this built-in special group.
//


//
// MessageId: ERROR_SPECIAL_USER
//
// MessageText:
//
// Cannot perform this operation on this built-in special user.
//


//
// MessageId: ERROR_MEMBERS_PRIMARY_GROUP
//
// MessageText:
//
// The user cannot be removed from a group because the group is currently the user's primary group.
//


//
// MessageId: ERROR_TOKEN_ALREADY_IN_USE
//
// MessageText:
//
// The token is already in use as a primary token.
//


//
// MessageId: ERROR_NO_SUCH_ALIAS
//
// MessageText:
//
// The specified local group does not exist.
//


//
// MessageId: ERROR_MEMBER_NOT_IN_ALIAS
//
// MessageText:
//
// The specified account name is not a member of the group.
//


//
// MessageId: ERROR_MEMBER_IN_ALIAS
//
// MessageText:
//
// The specified account name is already a member of the group.
//


//
// MessageId: ERROR_ALIAS_EXISTS
//
// MessageText:
//
// The specified local group already exists.
//


//
// MessageId: ERROR_LOGON_NOT_GRANTED
//
// MessageText:
//
// Logon failure: the user has not been granted the requested logon type at this computer.
//


//
// MessageId: ERROR_TOO_MANY_SECRETS
//
// MessageText:
//
// The maximum number of secrets that may be stored in a single system has been exceeded.
//


//
// MessageId: ERROR_SECRET_TOO_LONG
//
// MessageText:
//
// The length of a secret exceeds the maximum length allowed.
//


//
// MessageId: ERROR_INTERNAL_DB_ERROR
//
// MessageText:
//
// The local security authority database contains an internal inconsistency.
//


//
// MessageId: ERROR_TOO_MANY_CONTEXT_IDS
//
// MessageText:
//
// During a logon attempt, the user's security context accumulated too many security IDs.
//


//
// MessageId: ERROR_LOGON_TYPE_NOT_GRANTED
//
// MessageText:
//
// Logon failure: the user has not been granted the requested logon type at this computer.
//


//
// MessageId: ERROR_NT_CROSS_ENCRYPTION_REQUIRED
//
// MessageText:
//
// A cross-encrypted password is necessary to change a user password.
//


//
// MessageId: ERROR_NO_SUCH_MEMBER
//
// MessageText:
//
// A member could not be added to or removed from the local group because the member does not exist.
//


//
// MessageId: ERROR_INVALID_MEMBER
//
// MessageText:
//
// A new member could not be added to a local group because the member has the wrong account type.
//


//
// MessageId: ERROR_TOO_MANY_SIDS
//
// MessageText:
//
// Too many security IDs have been specified.
//


//
// MessageId: ERROR_LM_CROSS_ENCRYPTION_REQUIRED
//
// MessageText:
//
// A cross-encrypted password is necessary to change this user password.
//


//
// MessageId: ERROR_NO_INHERITANCE
//
// MessageText:
//
// Indicates an ACL contains no inheritable components.
//


//
// MessageId: ERROR_FILE_CORRUPT
//
// MessageText:
//
// The file or directory is corrupted and unreadable.
//


//
// MessageId: ERROR_DISK_CORRUPT
//
// MessageText:
//
// The disk structure is corrupted and unreadable.
//


//
// MessageId: ERROR_NO_USER_SESSION_KEY
//
// MessageText:
//
// There is no user session key for the specified logon session.
//


//
// MessageId: ERROR_LICENSE_QUOTA_EXCEEDED
//
// MessageText:
//
// The service being accessed is licensed for a particular number of connections. No more connections can be made to the service at this time because there are already as many connections as the service can accept.
//


//
// MessageId: ERROR_WRONG_TARGET_NAME
//
// MessageText:
//
// The target account name is incorrect.
//


//
// MessageId: ERROR_MUTUAL_AUTH_FAILED
//
// MessageText:
//
// Mutual Authentication failed. The server's password is out of date at the domain controller.
//


//
// MessageId: ERROR_TIME_SKEW
//
// MessageText:
//
// There is a time and/or date difference between the client and server.
//


//
// MessageId: ERROR_CURRENT_DOMAIN_NOT_ALLOWED
//
// MessageText:
//
// This operation cannot be performed on the current domain.
//



///////////////////////////////////////////////////
//                                               //
//              WinUser Error codes              //
//                                               //
//                 1400 to 1499                  //
///////////////////////////////////////////////////

//
// MessageId: ERROR_INVALID_WINDOW_HANDLE
//
// MessageText:
//
// Invalid window handle.
//


//
// MessageId: ERROR_INVALID_MENU_HANDLE
//
// MessageText:
//
// Invalid menu handle.
//


//
// MessageId: ERROR_INVALID_CURSOR_HANDLE
//
// MessageText:
//
// Invalid cursor handle.
//


//
// MessageId: ERROR_INVALID_ACCEL_HANDLE
//
// MessageText:
//
// Invalid accelerator table handle.
//


//
// MessageId: ERROR_INVALID_HOOK_HANDLE
//
// MessageText:
//
// Invalid hook handle.
//


//
// MessageId: ERROR_INVALID_DWP_HANDLE
//
// MessageText:
//
// Invalid handle to a multiple-window position structure.
//


//
// MessageId: ERROR_TLW_WITH_WSCHILD
//
// MessageText:
//
// Cannot create a top-level child window.
//


//
// MessageId: ERROR_CANNOT_FIND_WND_CLASS
//
// MessageText:
//
// Cannot find window class.
//


//
// MessageId: ERROR_WINDOW_OF_OTHER_THREAD
//
// MessageText:
//
// Invalid window; it belongs to other thread.
//


//
// MessageId: ERROR_HOTKEY_ALREADY_REGISTERED
//
// MessageText:
//
// Hot key is already registered.
//


//
// MessageId: ERROR_CLASS_ALREADY_EXISTS
//
// MessageText:
//
// Class already exists.
//


//
// MessageId: ERROR_CLASS_DOES_NOT_EXIST
//
// MessageText:
//
// Class does not exist.
//


//
// MessageId: ERROR_CLASS_HAS_WINDOWS
//
// MessageText:
//
// Class still has open windows.
//


//
// MessageId: ERROR_INVALID_INDEX
//
// MessageText:
//
// Invalid index.
//


//
// MessageId: ERROR_INVALID_ICON_HANDLE
//
// MessageText:
//
// Invalid icon handle.
//


//
// MessageId: ERROR_PRIVATE_DIALOG_INDEX
//
// MessageText:
//
// Using private DIALOG window words.
//


//
// MessageId: ERROR_LISTBOX_ID_NOT_FOUND
//
// MessageText:
//
// The list box identifier was not found.
//


//
// MessageId: ERROR_NO_WILDCARD_CHARACTERS
//
// MessageText:
//
// No wildcards were found.
//


//
// MessageId: ERROR_CLIPBOARD_NOT_OPEN
//
// MessageText:
//
// Thread does not have a clipboard open.
//


//
// MessageId: ERROR_HOTKEY_NOT_REGISTERED
//
// MessageText:
//
// Hot key is not registered.
//


//
// MessageId: ERROR_WINDOW_NOT_DIALOG
//
// MessageText:
//
// The window is not a valid dialog window.
//


//
// MessageId: ERROR_CONTROL_ID_NOT_FOUND
//
// MessageText:
//
// Control ID not found.
//


//
// MessageId: ERROR_INVALID_COMBOBOX_MESSAGE
//
// MessageText:
//
// Invalid message for a combo box because it does not have an edit control.
//


//
// MessageId: ERROR_WINDOW_NOT_COMBOBOX
//
// MessageText:
//
// The window is not a combo box.
//


//
// MessageId: ERROR_INVALID_EDIT_HEIGHT
//
// MessageText:
//
// Height must be less than 256.
//


//
// MessageId: ERROR_DC_NOT_FOUND
//
// MessageText:
//
// Invalid device context (DC) handle.
//


//
// MessageId: ERROR_INVALID_HOOK_FILTER
//
// MessageText:
//
// Invalid hook procedure type.
//


//
// MessageId: ERROR_INVALID_FILTER_PROC
//
// MessageText:
//
// Invalid hook procedure.
//


//
// MessageId: ERROR_HOOK_NEEDS_HMOD
//
// MessageText:
//
// Cannot set nonlocal hook without a module handle.
//


//
// MessageId: ERROR_GLOBAL_ONLY_HOOK
//
// MessageText:
//
// This hook procedure can only be set globally.
//


//
// MessageId: ERROR_JOURNAL_HOOK_SET
//
// MessageText:
//
// The journal hook procedure is already installed.
//


//
// MessageId: ERROR_HOOK_NOT_INSTALLED
//
// MessageText:
//
// The hook procedure is not installed.
//


//
// MessageId: ERROR_INVALID_LB_MESSAGE
//
// MessageText:
//
// Invalid message for single-selection list box.
//


//
// MessageId: ERROR_SETCOUNT_ON_BAD_LB
//
// MessageText:
//
// LB_SETCOUNT sent to non-lazy list box.
//


//
// MessageId: ERROR_LB_WITHOUT_TABSTOPS
//
// MessageText:
//
// This list box does not support tab stops.
//


//
// MessageId: ERROR_DESTROY_OBJECT_OF_OTHER_THREAD
//
// MessageText:
//
// Cannot destroy object created by another thread.
//


//
// MessageId: ERROR_CHILD_WINDOW_MENU
//
// MessageText:
//
// Child windows cannot have menus.
//


//
// MessageId: ERROR_NO_SYSTEM_MENU
//
// MessageText:
//
// The window does not have a system menu.
//


//
// MessageId: ERROR_INVALID_MSGBOX_STYLE
//
// MessageText:
//
// Invalid message box style.
//


//
// MessageId: ERROR_INVALID_SPI_VALUE
//
// MessageText:
//
// Invalid system-wide (SPI_*) parameter.
//


//
// MessageId: ERROR_SCREEN_ALREADY_LOCKED
//
// MessageText:
//
// Screen already locked.
//


//
// MessageId: ERROR_HWNDS_HAVE_DIFF_PARENT
//
// MessageText:
//
// All handles to windows in a multiple-window position structure must have the same parent.
//


//
// MessageId: ERROR_NOT_CHILD_WINDOW
//
// MessageText:
//
// The window is not a child window.
//


//
// MessageId: ERROR_INVALID_GW_COMMAND
//
// MessageText:
//
// Invalid GW_* command.
//


//
// MessageId: ERROR_INVALID_THREAD_ID
//
// MessageText:
//
// Invalid thread identifier.
//


//
// MessageId: ERROR_NON_MDICHILD_WINDOW
//
// MessageText:
//
// Cannot process a message from a window that is not a multiple document interface (MDI) window.
//


//
// MessageId: ERROR_POPUP_ALREADY_ACTIVE
//
// MessageText:
//
// Popup menu already active.
//


//
// MessageId: ERROR_NO_SCROLLBARS
//
// MessageText:
//
// The window does not have scroll bars.
//


//
// MessageId: ERROR_INVALID_SCROLLBAR_RANGE
//
// MessageText:
//
// Scroll bar range cannot be greater than MAXLONG.
//


//
// MessageId: ERROR_INVALID_SHOWWIN_COMMAND
//
// MessageText:
//
// Cannot show or remove the window in the way specified.
//


//
// MessageId: ERROR_NO_SYSTEM_RESOURCES
//
// MessageText:
//
// Insufficient system resources exist to complete the requested service.
//


//
// MessageId: ERROR_NONPAGED_SYSTEM_RESOURCES
//
// MessageText:
//
// Insufficient system resources exist to complete the requested service.
//


//
// MessageId: ERROR_PAGED_SYSTEM_RESOURCES
//
// MessageText:
//
// Insufficient system resources exist to complete the requested service.
//


//
// MessageId: ERROR_WORKING_SET_QUOTA
//
// MessageText:
//
// Insufficient quota to complete the requested service.
//


//
// MessageId: ERROR_PAGEFILE_QUOTA
//
// MessageText:
//
// Insufficient quota to complete the requested service.
//


//
// MessageId: ERROR_COMMITMENT_LIMIT
//
// MessageText:
//
// The paging file is too small for this operation to complete.
//


//
// MessageId: ERROR_MENU_ITEM_NOT_FOUND
//
// MessageText:
//
// A menu item was not found.
//


//
// MessageId: ERROR_INVALID_KEYBOARD_HANDLE
//
// MessageText:
//
// Invalid keyboard layout handle.
//


//
// MessageId: ERROR_HOOK_TYPE_NOT_ALLOWED
//
// MessageText:
//
// Hook type not allowed.
//


//
// MessageId: ERROR_REQUIRES_INTERACTIVE_WINDOWSTATION
//
// MessageText:
//
// This operation requires an interactive window station.
//


//
// MessageId: ERROR_TIMEOUT
//
// MessageText:
//
// This operation returned because the timeout period expired.
//


//
// MessageId: ERROR_INVALID_MONITOR_HANDLE
//
// MessageText:
//
// Invalid monitor handle.
//


//
// MessageId: ERROR_INCORRECT_SIZE
//
// MessageText:
//
// Incorrect size argument.
//


//
// MessageId: ERROR_SYMLINK_CLASS_DISABLED
//
// MessageText:
//
// The symbolic link cannot be followed because its type is disabled.
//


//
// MessageId: ERROR_SYMLINK_NOT_SUPPORTED
//
// MessageText:
//
// This application does not support the current operation on symbolic links.
//


//
// MessageId: ERROR_XML_PARSE_ERROR
//
// MessageText:
//
// Windows was unable to parse the requested XML data.
//


//
// MessageId: ERROR_XMLDSIG_ERROR
//
// MessageText:
//
// An error was encountered while processing an XML digital signature.
//


//
// MessageId: ERROR_RESTART_APPLICATION
//
// MessageText:
//
// This application must be restarted.
//


//
// MessageId: ERROR_WRONG_COMPARTMENT
//
// MessageText:
//
// The caller made the connection request in the wrong routing compartment.
//


//
// MessageId: ERROR_AUTHIP_FAILURE
//
// MessageText:
//
// There was an AuthIP failure when attempting to connect to the remote host.
//


//
// MessageId: ERROR_NO_NVRAM_RESOURCES
//
// MessageText:
//
// Insufficient NVRAM resources exist to complete the requested service. A reboot might be required.
//


//
// MessageId: ERROR_NOT_GUI_PROCESS
//
// MessageText:
//
// Unable to finish the requested operation because the specified process is not a GUI process.
//



///////////////////////////////////////////////////
//                                               //
//             EventLog Error codes              //
//                                               //
//                 1500 to 1549                  //
///////////////////////////////////////////////////

//
// MessageId: ERROR_EVENTLOG_FILE_CORRUPT
//
// MessageText:
//
// The event log file is corrupted.
//


//
// MessageId: ERROR_EVENTLOG_CANT_START
//
// MessageText:
//
// No event log file could be opened, so the event logging service did not start.
//


//
// MessageId: ERROR_LOG_FILE_FULL
//
// MessageText:
//
// The event log file is full.
//


//
// MessageId: ERROR_EVENTLOG_FILE_CHANGED
//
// MessageText:
//
// The event log file has changed between read operations.
//


//
// MessageId: ERROR_CONTAINER_ASSIGNED
//
// MessageText:
//
// The specified Job already has a container assigned to it.
//


//
// MessageId: ERROR_JOB_NO_CONTAINER
//
// MessageText:
//
// The specified Job does not have a container assigned to it.
//



///////////////////////////////////////////////////
//                                               //
//            Class Scheduler Error codes        //
//                                               //
//                 1550 to 1599                  //
///////////////////////////////////////////////////

//
// MessageId: ERROR_INVALID_TASK_NAME
//
// MessageText:
//
// The specified task name is invalid.
//


//
// MessageId: ERROR_INVALID_TASK_INDEX
//
// MessageText:
//
// The specified task index is invalid.
//


//
// MessageId: ERROR_THREAD_ALREADY_IN_TASK
//
// MessageText:
//
// The specified thread is already joining a task.
//



///////////////////////////////////////////////////
//                                               //
//                MSI Error codes                //
//                                               //
//                 1600 to 1699                  //
///////////////////////////////////////////////////

//
// MessageId: ERROR_INSTALL_SERVICE_FAILURE
//
// MessageText:
//
// The Windows Installer Service could not be accessed. This can occur if the Windows Installer is not correctly installed. Contact your support personnel for assistance.
//


//
// MessageId: ERROR_INSTALL_USEREXIT
//
// MessageText:
//
// User cancelled installation.
//


//
// MessageId: ERROR_INSTALL_FAILURE
//
// MessageText:
//
// Fatal error during installation.
//


//
// MessageId: ERROR_INSTALL_SUSPEND
//
// MessageText:
//
// Installation suspended, incomplete.
//


//
// MessageId: ERROR_UNKNOWN_PRODUCT
//
// MessageText:
//
// This action is only valid for products that are currently installed.
//


//
// MessageId: ERROR_UNKNOWN_FEATURE
//
// MessageText:
//
// Feature ID not registered.
//


//
// MessageId: ERROR_UNKNOWN_COMPONENT
//
// MessageText:
//
// Component ID not registered.
//


//
// MessageId: ERROR_UNKNOWN_PROPERTY
//
// MessageText:
//
// Unknown property.
//


//
// MessageId: ERROR_INVALID_HANDLE_STATE
//
// MessageText:
//
// Handle is in an invalid state.
//


//
// MessageId: ERROR_BAD_CONFIGURATION
//
// MessageText:
//
// The configuration data for this product is corrupt. Contact your support personnel.
//


//
// MessageId: ERROR_INDEX_ABSENT
//
// MessageText:
//
// Component qualifier not present.
//


//
// MessageId: ERROR_INSTALL_SOURCE_ABSENT
//
// MessageText:
//
// The installation source for this product is not available. Verify that the source exists and that you can access it.
//


//
// MessageId: ERROR_INSTALL_PACKAGE_VERSION
//
// MessageText:
//
// This installation package cannot be installed by the Windows Installer service. You must install a Windows service pack that contains a newer version of the Windows Installer service.
//


//
// MessageId: ERROR_PRODUCT_UNINSTALLED
//
// MessageText:
//
// Product is uninstalled.
//


//
// MessageId: ERROR_BAD_QUERY_SYNTAX
//
// MessageText:
//
// SQL query syntax invalid or unsupported.
//


//
// MessageId: ERROR_INVALID_FIELD
//
// MessageText:
//
// Record field does not exist.
//


//
// MessageId: ERROR_DEVICE_REMOVED
//
// MessageText:
//
// The device has been removed.
//


//
// MessageId: ERROR_INSTALL_ALREADY_RUNNING
//
// MessageText:
//
// Another installation is already in progress. Complete that installation before proceeding with this install.
//


//
// MessageId: ERROR_INSTALL_PACKAGE_OPEN_FAILED
//
// MessageText:
//
// This installation package could not be opened. Verify that the package exists and that you can access it, or contact the application vendor to verify that this is a valid Windows Installer package.
//


//
// MessageId: ERROR_INSTALL_PACKAGE_INVALID
//
// MessageText:
//
// This installation package could not be opened. Contact the application vendor to verify that this is a valid Windows Installer package.
//


//
// MessageId: ERROR_INSTALL_UI_FAILURE
//
// MessageText:
//
// There was an error starting the Windows Installer service user interface. Contact your support personnel.
//


//
// MessageId: ERROR_INSTALL_LOG_FAILURE
//
// MessageText:
//
// Error opening installation log file. Verify that the specified log file location exists and that you can write to it.
//


//
// MessageId: ERROR_INSTALL_LANGUAGE_UNSUPPORTED
//
// MessageText:
//
// The language of this installation package is not supported by your system.
//


//
// MessageId: ERROR_INSTALL_TRANSFORM_FAILURE
//
// MessageText:
//
// Error applying transforms. Verify that the specified transform paths are valid.
//


//
// MessageId: ERROR_INSTALL_PACKAGE_REJECTED
//
// MessageText:
//
// This installation is forbidden by system policy. Contact your system administrator.
//


//
// MessageId: ERROR_FUNCTION_NOT_CALLED
//
// MessageText:
//
// Function could not be executed.
//


//
// MessageId: ERROR_FUNCTION_FAILED
//
// MessageText:
//
// Function failed during execution.
//


//
// MessageId: ERROR_INVALID_TABLE
//
// MessageText:
//
// Invalid or unknown table specified.
//


//
// MessageId: ERROR_DATATYPE_MISMATCH
//
// MessageText:
//
// Data supplied is of wrong type.
//


//
// MessageId: ERROR_UNSUPPORTED_TYPE
//
// MessageText:
//
// Data of this type is not supported.
//


//
// MessageId: ERROR_CREATE_FAILED
//
// MessageText:
//
// The Windows Installer service failed to start. Contact your support personnel.
//


//
// MessageId: ERROR_INSTALL_TEMP_UNWRITABLE
//
// MessageText:
//
// The Temp folder is on a drive that is full or is inaccessible. Free up space on the drive or verify that you have write permission on the Temp folder.
//


//
// MessageId: ERROR_INSTALL_PLATFORM_UNSUPPORTED
//
// MessageText:
//
// This installation package is not supported by this processor type. Contact your product vendor.
//


//
// MessageId: ERROR_INSTALL_NOTUSED
//
// MessageText:
//
// Component not used on this computer.
//


//
// MessageId: ERROR_PATCH_PACKAGE_OPEN_FAILED
//
// MessageText:
//
// This update package could not be opened. Verify that the update package exists and that you can access it, or contact the application vendor to verify that this is a valid Windows Installer update package.
//


//
// MessageId: ERROR_PATCH_PACKAGE_INVALID
//
// MessageText:
//
// This update package could not be opened. Contact the application vendor to verify that this is a valid Windows Installer update package.
//


//
// MessageId: ERROR_PATCH_PACKAGE_UNSUPPORTED
//
// MessageText:
//
// This update package cannot be processed by the Windows Installer service. You must install a Windows service pack that contains a newer version of the Windows Installer service.
//


//
// MessageId: ERROR_PRODUCT_VERSION
//
// MessageText:
//
// Another version of this product is already installed. Installation of this version cannot continue. To configure or remove the existing version of this product, use Add/Remove Programs on the Control Panel.
//


//
// MessageId: ERROR_INVALID_COMMAND_LINE
//
// MessageText:
//
// Invalid command line argument. Consult the Windows Installer SDK for detailed command line help.
//


//
// MessageId: ERROR_INSTALL_REMOTE_DISALLOWED
//
// MessageText:
//
// Only administrators have permission to add, remove, or configure server software during a Terminal services remote session. If you want to install or configure software on the server, contact your network administrator.
//


//
// MessageId: ERROR_SUCCESS_REBOOT_INITIATED
//
// MessageText:
//
// The requested operation completed successfully. The system will be restarted so the changes can take effect.
//


//
// MessageId: ERROR_PATCH_TARGET_NOT_FOUND
//
// MessageText:
//
// The upgrade cannot be installed by the Windows Installer service because the program to be upgraded may be missing, or the upgrade may update a different version of the program. Verify that the program to be upgraded exists on your computer and that you have the correct upgrade.
//


//
// MessageId: ERROR_PATCH_PACKAGE_REJECTED
//
// MessageText:
//
// The update package is not permitted by software restriction policy.
//


//
// MessageId: ERROR_INSTALL_TRANSFORM_REJECTED
//
// MessageText:
//
// One or more customizations are not permitted by software restriction policy.
//


//
// MessageId: ERROR_INSTALL_REMOTE_PROHIBITED
//
// MessageText:
//
// The Windows Installer does not permit installation from a Remote Desktop Connection.
//


//
// MessageId: ERROR_PATCH_REMOVAL_UNSUPPORTED
//
// MessageText:
//
// Uninstallation of the update package is not supported.
//


//
// MessageId: ERROR_UNKNOWN_PATCH
//
// MessageText:
//
// The update is not applied to this product.
//


//
// MessageId: ERROR_PATCH_NO_SEQUENCE
//
// MessageText:
//
// No valid sequence could be found for the set of updates.
//


//
// MessageId: ERROR_PATCH_REMOVAL_DISALLOWED
//
// MessageText:
//
// Update removal was disallowed by policy.
//


//
// MessageId: ERROR_INVALID_PATCH_XML
//
// MessageText:
//
// The XML update data is invalid.
//


//
// MessageId: ERROR_PATCH_MANAGED_ADVERTISED_PRODUCT
//
// MessageText:
//
// Windows Installer does not permit updating of managed advertised products. At least one feature of the product must be installed before applying the update.
//


//
// MessageId: ERROR_INSTALL_SERVICE_SAFEBOOT
//
// MessageText:
//
// The Windows Installer service is not accessible in Safe Mode. Please try again when your computer is not in Safe Mode or you can use System Restore to return your machine to a previous good state.
//


//
// MessageId: ERROR_FAIL_FAST_EXCEPTION
//
// MessageText:
//
// A fail fast exception occurred. Exception handlers will not be invoked and the process will be terminated immediately.
//


//
// MessageId: ERROR_INSTALL_REJECTED
//
// MessageText:
//
// The app that you are trying to run is not supported on this version of Windows.
//


//
// MessageId: ERROR_DYNAMIC_CODE_BLOCKED
//
// MessageText:
//
// The operation was blocked as the process prohibits dynamic code generation.
//


//
// MessageId: ERROR_NOT_SAME_OBJECT
//
// MessageText:
//
// The objects are not identical.
//


//
// MessageId: ERROR_STRICT_CFG_VIOLATION
//
// MessageText:
//
// The specified image file was blocked from loading because it does not enable a feature required by the process: Control Flow Guard.
//


//
// MessageId: ERROR_SET_CONTEXT_DENIED
//
// MessageText:
//
// The thread context could not be updated because this has been restricted for the process.
//


//
// MessageId: ERROR_CROSS_PARTITION_VIOLATION
//
// MessageText:
//
// An invalid cross-partition private file/section access was attempted.
//



///////////////////////////////////////////////////
//                                               //
//               RPC Error codes                 //
//                                               //
//                 1700 to 1999                  //
///////////////////////////////////////////////////

//
// MessageId: RPC_S_INVALID_STRING_BINDING
//
// MessageText:
//
// The string binding is invalid.
//


//
// MessageId: RPC_S_WRONG_KIND_OF_BINDING
//
// MessageText:
//
// The binding handle is not the correct type.
//


//
// MessageId: RPC_S_INVALID_BINDING
//
// MessageText:
//
// The binding handle is invalid.
//


//
// MessageId: RPC_S_PROTSEQ_NOT_SUPPORTED
//
// MessageText:
//
// The RPC protocol sequence is not supported.
//


//
// MessageId: RPC_S_INVALID_RPC_PROTSEQ
//
// MessageText:
//
// The RPC protocol sequence is invalid.
//


//
// MessageId: RPC_S_INVALID_STRING_UUID
//
// MessageText:
//
// The string universal unique identifier (UUID) is invalid.
//


//
// MessageId: RPC_S_INVALID_ENDPOINT_FORMAT
//
// MessageText:
//
// The endpoint format is invalid.
//


//
// MessageId: RPC_S_INVALID_NET_ADDR
//
// MessageText:
//
// The network address is invalid.
//


//
// MessageId: RPC_S_NO_ENDPOINT_FOUND
//
// MessageText:
//
// No endpoint was found.
//


//
// MessageId: RPC_S_INVALID_TIMEOUT
//
// MessageText:
//
// The timeout value is invalid.
//


//
// MessageId: RPC_S_OBJECT_NOT_FOUND
//
// MessageText:
//
// The object universal unique identifier (UUID) was not found.
//


//
// MessageId: RPC_S_ALREADY_REGISTERED
//
// MessageText:
//
// The object universal unique identifier (UUID) has already been registered.
//


//
// MessageId: RPC_S_TYPE_ALREADY_REGISTERED
//
// MessageText:
//
// The type universal unique identifier (UUID) has already been registered.
//


//
// MessageId: RPC_S_ALREADY_LISTENING
//
// MessageText:
//
// The RPC server is already listening.
//


//
// MessageId: RPC_S_NO_PROTSEQS_REGISTERED
//
// MessageText:
//
// No protocol sequences have been registered.
//


//
// MessageId: RPC_S_NOT_LISTENING
//
// MessageText:
//
// The RPC server is not listening.
//


//
// MessageId: RPC_S_UNKNOWN_MGR_TYPE
//
// MessageText:
//
// The manager type is unknown.
//


//
// MessageId: RPC_S_UNKNOWN_IF
//
// MessageText:
//
// The interface is unknown.
//


//
// MessageId: RPC_S_NO_BINDINGS
//
// MessageText:
//
// There are no bindings.
//


//
// MessageId: RPC_S_NO_PROTSEQS
//
// MessageText:
//
// There are no protocol sequences.
//


//
// MessageId: RPC_S_CANT_CREATE_ENDPOINT
//
// MessageText:
//
// The endpoint cannot be created.
//


//
// MessageId: RPC_S_OUT_OF_RESOURCES
//
// MessageText:
//
// Not enough resources are available to complete this operation.
//


//
// MessageId: RPC_S_SERVER_UNAVAILABLE
//
// MessageText:
//
// The RPC server is unavailable.
//


//
// MessageId: RPC_S_SERVER_TOO_BUSY
//
// MessageText:
//
// The RPC server is too busy to complete this operation.
//


//
// MessageId: RPC_S_INVALID_NETWORK_OPTIONS
//
// MessageText:
//
// The network options are invalid.
//


//
// MessageId: RPC_S_NO_CALL_ACTIVE
//
// MessageText:
//
// There are no remote procedure calls active on this thread.
//


//
// MessageId: RPC_S_CALL_FAILED
//
// MessageText:
//
// The remote procedure call failed.
//


//
// MessageId: RPC_S_CALL_FAILED_DNE
//
// MessageText:
//
// The remote procedure call failed and did not execute.
//


//
// MessageId: RPC_S_PROTOCOL_ERROR
//
// MessageText:
//
// A remote procedure call (RPC) protocol error occurred.
//


//
// MessageId: RPC_S_PROXY_ACCESS_DENIED
//
// MessageText:
//
// Access to the HTTP proxy is denied.
//


//
// MessageId: RPC_S_UNSUPPORTED_TRANS_SYN
//
// MessageText:
//
// The transfer syntax is not supported by the RPC server.
//


//
// MessageId: RPC_S_UNSUPPORTED_TYPE
//
// MessageText:
//
// The universal unique identifier (UUID) type is not supported.
//


//
// MessageId: RPC_S_INVALID_TAG
//
// MessageText:
//
// The tag is invalid.
//


//
// MessageId: RPC_S_INVALID_BOUND
//
// MessageText:
//
// The array bounds are invalid.
//


//
// MessageId: RPC_S_NO_ENTRY_NAME
//
// MessageText:
//
// The binding does not contain an entry name.
//


//
// MessageId: RPC_S_INVALID_NAME_SYNTAX
//
// MessageText:
//
// The name syntax is invalid.
//


//
// MessageId: RPC_S_UNSUPPORTED_NAME_SYNTAX
//
// MessageText:
//
// The name syntax is not supported.
//


//
// MessageId: RPC_S_UUID_NO_ADDRESS
//
// MessageText:
//
// No network address is available to use to construct a universal unique identifier (UUID).
//


//
// MessageId: RPC_S_DUPLICATE_ENDPOINT
//
// MessageText:
//
// The endpoint is a duplicate.
//


//
// MessageId: RPC_S_UNKNOWN_AUTHN_TYPE
//
// MessageText:
//
// The authentication type is unknown.
//


//
// MessageId: RPC_S_MAX_CALLS_TOO_SMALL
//
// MessageText:
//
// The maximum number of calls is too small.
//


//
// MessageId: RPC_S_STRING_TOO_LONG
//
// MessageText:
//
// The string is too long.
//


//
// MessageId: RPC_S_PROTSEQ_NOT_FOUND
//
// MessageText:
//
// The RPC protocol sequence was not found.
//


//
// MessageId: RPC_S_PROCNUM_OUT_OF_RANGE
//
// MessageText:
//
// The procedure number is out of range.
//


//
// MessageId: RPC_S_BINDING_HAS_NO_AUTH
//
// MessageText:
//
// The binding does not contain any authentication information.
//


//
// MessageId: RPC_S_UNKNOWN_AUTHN_SERVICE
//
// MessageText:
//
// The authentication service is unknown.
//


//
// MessageId: RPC_S_UNKNOWN_AUTHN_LEVEL
//
// MessageText:
//
// The authentication level is unknown.
//


//
// MessageId: RPC_S_INVALID_AUTH_IDENTITY
//
// MessageText:
//
// The security context is invalid.
//


//
// MessageId: RPC_S_UNKNOWN_AUTHZ_SERVICE
//
// MessageText:
//
// The authorization service is unknown.
//


//
// MessageId: EPT_S_INVALID_ENTRY
//
// MessageText:
//
// The entry is invalid.
//


//
// MessageId: EPT_S_CANT_PERFORM_OP
//
// MessageText:
//
// The server endpoint cannot perform the operation.
//


//
// MessageId: EPT_S_NOT_REGISTERED
//
// MessageText:
//
// There are no more endpoints available from the endpoint mapper.
//


//
// MessageId: RPC_S_NOTHING_TO_EXPORT
//
// MessageText:
//
// No interfaces have been exported.
//


//
// MessageId: RPC_S_INCOMPLETE_NAME
//
// MessageText:
//
// The entry name is incomplete.
//


//
// MessageId: RPC_S_INVALID_VERS_OPTION
//
// MessageText:
//
// The version option is invalid.
//


//
// MessageId: RPC_S_NO_MORE_MEMBERS
//
// MessageText:
//
// There are no more members.
//


//
// MessageId: RPC_S_NOT_ALL_OBJS_UNEXPORTED
//
// MessageText:
//
// There is nothing to unexport.
//


//
// MessageId: RPC_S_INTERFACE_NOT_FOUND
//
// MessageText:
//
// The interface was not found.
//


//
// MessageId: RPC_S_ENTRY_ALREADY_EXISTS
//
// MessageText:
//
// The entry already exists.
//


//
// MessageId: RPC_S_ENTRY_NOT_FOUND
//
// MessageText:
//
// The entry is not found.
//


//
// MessageId: RPC_S_NAME_SERVICE_UNAVAILABLE
//
// MessageText:
//
// The name service is unavailable.
//


//
// MessageId: RPC_S_INVALID_NAF_ID
//
// MessageText:
//
// The network address family is invalid.
//


//
// MessageId: RPC_S_CANNOT_SUPPORT
//
// MessageText:
//
// The requested operation is not supported.
//


//
// MessageId: RPC_S_NO_CONTEXT_AVAILABLE
//
// MessageText:
//
// No security context is available to allow impersonation.
//


//
// MessageId: RPC_S_INTERNAL_ERROR
//
// MessageText:
//
// An internal error occurred in a remote procedure call (RPC).
//


//
// MessageId: RPC_S_ZERO_DIVIDE
//
// MessageText:
//
// The RPC server attempted an integer division by zero.
//


//
// MessageId: RPC_S_ADDRESS_ERROR
//
// MessageText:
//
// An addressing error occurred in the RPC server.
//


//
// MessageId: RPC_S_FP_DIV_ZERO
//
// MessageText:
//
// A floating-point operation at the RPC server caused a division by zero.
//


//
// MessageId: RPC_S_FP_UNDERFLOW
//
// MessageText:
//
// A floating-point underflow occurred at the RPC server.
//


//
// MessageId: RPC_S_FP_OVERFLOW
//
// MessageText:
//
// A floating-point overflow occurred at the RPC server.
//


//
// MessageId: RPC_X_NO_MORE_ENTRIES
//
// MessageText:
//
// The list of RPC servers available for the binding of auto handles has been exhausted.
//


//
// MessageId: RPC_X_SS_CHAR_TRANS_OPEN_FAIL
//
// MessageText:
//
// Unable to open the character translation table file.
//


//
// MessageId: RPC_X_SS_CHAR_TRANS_SHORT_FILE
//
// MessageText:
//
// The file containing the character translation table has fewer than 512 bytes.
//


//
// MessageId: RPC_X_SS_IN_NULL_CONTEXT
//
// MessageText:
//
// A null context handle was passed from the client to the host during a remote procedure call.
//


//
// MessageId: RPC_X_SS_CONTEXT_DAMAGED
//
// MessageText:
//
// The context handle changed during a remote procedure call.
//


//
// MessageId: RPC_X_SS_HANDLES_MISMATCH
//
// MessageText:
//
// The binding handles passed to a remote procedure call do not match.
//


//
// MessageId: RPC_X_SS_CANNOT_GET_CALL_HANDLE
//
// MessageText:
//
// The stub is unable to get the remote procedure call handle.
//


//
// MessageId: RPC_X_NULL_REF_POINTER
//
// MessageText:
//
// A null reference pointer was passed to the stub.
//


//
// MessageId: RPC_X_ENUM_VALUE_OUT_OF_RANGE
//
// MessageText:
//
// The enumeration value is out of range.
//


//
// MessageId: RPC_X_BYTE_COUNT_TOO_SMALL
//
// MessageText:
//
// The byte count is too small.
//


//
// MessageId: RPC_X_BAD_STUB_DATA
//
// MessageText:
//
// The stub received bad data.
//


//
// MessageId: ERROR_INVALID_USER_BUFFER
//
// MessageText:
//
// The supplied user buffer is not valid for the requested operation.
//


//
// MessageId: ERROR_UNRECOGNIZED_MEDIA
//
// MessageText:
//
// The disk media is not recognized. It may not be formatted.
//


//
// MessageId: ERROR_NO_TRUST_LSA_SECRET
//
// MessageText:
//
// The workstation does not have a trust secret.
//


//
// MessageId: ERROR_NO_TRUST_SAM_ACCOUNT
//
// MessageText:
//
// The security database on the server does not have a computer account for this workstation trust relationship.
//


//
// MessageId: ERROR_TRUSTED_DOMAIN_FAILURE
//
// MessageText:
//
// The trust relationship between the primary domain and the trusted domain failed.
//


//
// MessageId: ERROR_TRUSTED_RELATIONSHIP_FAILURE
//
// MessageText:
//
// The trust relationship between this workstation and the primary domain failed.
//


//
// MessageId: ERROR_TRUST_FAILURE
//
// MessageText:
//
// The network logon failed.
//


//
// MessageId: RPC_S_CALL_IN_PROGRESS
//
// MessageText:
//
// A remote procedure call is already in progress for this thread.
//


//
// MessageId: ERROR_NETLOGON_NOT_STARTED
//
// MessageText:
//
// An attempt was made to logon, but the network logon service was not started.
//


//
// MessageId: ERROR_ACCOUNT_EXPIRED
//
// MessageText:
//
// The user's account has expired.
//


//
// MessageId: ERROR_REDIRECTOR_HAS_OPEN_HANDLES
//
// MessageText:
//
// The redirector is in use and cannot be unloaded.
//


//
// MessageId: ERROR_PRINTER_DRIVER_ALREADY_INSTALLED
//
// MessageText:
//
// The specified printer driver is already installed.
//


//
// MessageId: ERROR_UNKNOWN_PORT
//
// MessageText:
//
// The specified port is unknown.
//


//
// MessageId: ERROR_UNKNOWN_PRINTER_DRIVER
//
// MessageText:
//
// The printer driver is unknown.
//


//
// MessageId: ERROR_UNKNOWN_PRINTPROCESSOR
//
// MessageText:
//
// The print processor is unknown.
//


//
// MessageId: ERROR_INVALID_SEPARATOR_FILE
//
// MessageText:
//
// The specified separator file is invalid.
//


//
// MessageId: ERROR_INVALID_PRIORITY
//
// MessageText:
//
// The specified priority is invalid.
//


//
// MessageId: ERROR_INVALID_PRINTER_NAME
//
// MessageText:
//
// The printer name is invalid.
//


//
// MessageId: ERROR_PRINTER_ALREADY_EXISTS
//
// MessageText:
//
// The printer already exists.
//


//
// MessageId: ERROR_INVALID_PRINTER_COMMAND
//
// MessageText:
//
// The printer command is invalid.
//


//
// MessageId: ERROR_INVALID_DATATYPE
//
// MessageText:
//
// The specified datatype is invalid.
//


//
// MessageId: ERROR_INVALID_ENVIRONMENT
//
// MessageText:
//
// The environment specified is invalid.
//


//
// MessageId: RPC_S_NO_MORE_BINDINGS
//
// MessageText:
//
// There are no more bindings.
//


//
// MessageId: ERROR_NOLOGON_INTERDOMAIN_TRUST_ACCOUNT
//
// MessageText:
//
// The account used is an interdomain trust account. Use your global user account or local user account to access this server.
//


//
// MessageId: ERROR_NOLOGON_WORKSTATION_TRUST_ACCOUNT
//
// MessageText:
//
// The account used is a computer account. Use your global user account or local user account to access this server.
//


//
// MessageId: ERROR_NOLOGON_SERVER_TRUST_ACCOUNT
//
// MessageText:
//
// The account used is a server trust account. Use your global user account or local user account to access this server.
//


//
// MessageId: ERROR_DOMAIN_TRUST_INCONSISTENT
//
// MessageText:
//
// The name or security ID (SID) of the domain specified is inconsistent with the trust information for that domain.
//


//
// MessageId: ERROR_SERVER_HAS_OPEN_HANDLES
//
// MessageText:
//
// The server is in use and cannot be unloaded.
//


//
// MessageId: ERROR_RESOURCE_DATA_NOT_FOUND
//
// MessageText:
//
// The specified image file did not contain a resource section.
//


//
// MessageId: ERROR_RESOURCE_TYPE_NOT_FOUND
//
// MessageText:
//
// The specified resource type cannot be found in the image file.
//


//
// MessageId: ERROR_RESOURCE_NAME_NOT_FOUND
//
// MessageText:
//
// The specified resource name cannot be found in the image file.
//


//
// MessageId: ERROR_RESOURCE_LANG_NOT_FOUND
//
// MessageText:
//
// The specified resource language ID cannot be found in the image file.
//


//
// MessageId: ERROR_NOT_ENOUGH_QUOTA
//
// MessageText:
//
// Not enough quota is available to process this command.
//


//
// MessageId: RPC_S_NO_INTERFACES
//
// MessageText:
//
// No interfaces have been registered.
//


//
// MessageId: RPC_S_CALL_CANCELLED
//
// MessageText:
//
// The remote procedure call was cancelled.
//


//
// MessageId: RPC_S_BINDING_INCOMPLETE
//
// MessageText:
//
// The binding handle does not contain all required information.
//


//
// MessageId: RPC_S_COMM_FAILURE
//
// MessageText:
//
// A communications failure occurred during a remote procedure call.
//


//
// MessageId: RPC_S_UNSUPPORTED_AUTHN_LEVEL
//
// MessageText:
//
// The requested authentication level is not supported.
//


//
// MessageId: RPC_S_NO_PRINC_NAME
//
// MessageText:
//
// No principal name registered.
//


//
// MessageId: RPC_S_NOT_RPC_ERROR
//
// MessageText:
//
// The error specified is not a valid Windows RPC error code.
//


//
// MessageId: RPC_S_UUID_LOCAL_ONLY
//
// MessageText:
//
// A UUID that is valid only on this computer has been allocated.
//


//
// MessageId: RPC_S_SEC_PKG_ERROR
//
// MessageText:
//
// A security package specific error occurred.
//


//
// MessageId: RPC_S_NOT_CANCELLED
//
// MessageText:
//
// Thread is not canceled.
//


//
// MessageId: RPC_X_INVALID_ES_ACTION
//
// MessageText:
//
// Invalid operation on the encoding/decoding handle.
//


//
// MessageId: RPC_X_WRONG_ES_VERSION
//
// MessageText:
//
// Incompatible version of the serializing package.
//


//
// MessageId: RPC_X_WRONG_STUB_VERSION
//
// MessageText:
//
// Incompatible version of the RPC stub.
//


//
// MessageId: RPC_X_INVALID_PIPE_OBJECT
//
// MessageText:
//
// The RPC pipe object is invalid or corrupted.
//


//
// MessageId: RPC_X_WRONG_PIPE_ORDER
//
// MessageText:
//
// An invalid operation was attempted on an RPC pipe object.
//


//
// MessageId: RPC_X_WRONG_PIPE_VERSION
//
// MessageText:
//
// Unsupported RPC pipe version.
//


//
// MessageId: RPC_S_COOKIE_AUTH_FAILED
//
// MessageText:
//
// HTTP proxy server rejected the connection because the cookie authentication failed.
//


//
// MessageId: RPC_S_DO_NOT_DISTURB
//
// MessageText:
//
// The RPC server is suspended, and could not be resumed for this request. The call did not execute.
//


//
// MessageId: RPC_S_SYSTEM_HANDLE_COUNT_EXCEEDED
//
// MessageText:
//
// The RPC call contains too many handles to be transmitted in a single request.
//


//
// MessageId: RPC_S_SYSTEM_HANDLE_TYPE_MISMATCH
//
// MessageText:
//
// The RPC call contains a handle that differs from the declared handle type.
//


//
// MessageId: RPC_S_GROUP_MEMBER_NOT_FOUND
//
// MessageText:
//
// The group member was not found.
//


//
// MessageId: EPT_S_CANT_CREATE
//
// MessageText:
//
// The endpoint mapper database entry could not be created.
//


//
// MessageId: RPC_S_INVALID_OBJECT
//
// MessageText:
//
// The object universal unique identifier (UUID) is the nil UUID.
//


//
// MessageId: ERROR_INVALID_TIME
//
// MessageText:
//
// The specified time is invalid.
//


//
// MessageId: ERROR_INVALID_FORM_NAME
//
// MessageText:
//
// The specified form name is invalid.
//


//
// MessageId: ERROR_INVALID_FORM_SIZE
//
// MessageText:
//
// The specified form size is invalid.
//


//
// MessageId: ERROR_ALREADY_WAITING
//
// MessageText:
//
// The specified printer handle is already being waited on
//


//
// MessageId: ERROR_PRINTER_DELETED
//
// MessageText:
//
// The specified printer has been deleted.
//


//
// MessageId: ERROR_INVALID_PRINTER_STATE
//
// MessageText:
//
// The state of the printer is invalid.
//


//
// MessageId: ERROR_PASSWORD_MUST_CHANGE
//
// MessageText:
//
// The user's password must be changed before signing in.
//


//
// MessageId: ERROR_DOMAIN_CONTROLLER_NOT_FOUND
//
// MessageText:
//
// Could not find the domain controller for this domain.
//


//
// MessageId: ERROR_ACCOUNT_LOCKED_OUT
//
// MessageText:
//
// The referenced account is currently locked out and may not be logged on to.
//


//
// MessageId: OR_INVALID_OXID
//
// MessageText:
//
// The object exporter specified was not found.
//


//
// MessageId: OR_INVALID_OID
//
// MessageText:
//
// The object specified was not found.
//


//
// MessageId: OR_INVALID_SET
//
// MessageText:
//
// The object resolver set specified was not found.
//


//
// MessageId: RPC_S_SEND_INCOMPLETE
//
// MessageText:
//
// Some data remains to be sent in the request buffer.
//


//
// MessageId: RPC_S_INVALID_ASYNC_HANDLE
//
// MessageText:
//
// Invalid asynchronous remote procedure call handle.
//


//
// MessageId: RPC_S_INVALID_ASYNC_CALL
//
// MessageText:
//
// Invalid asynchronous RPC call handle for this operation.
//


//
// MessageId: RPC_X_PIPE_CLOSED
//
// MessageText:
//
// The RPC pipe object has already been closed.
//


//
// MessageId: RPC_X_PIPE_DISCIPLINE_ERROR
//
// MessageText:
//
// The RPC call completed before all pipes were processed.
//


//
// MessageId: RPC_X_PIPE_EMPTY
//
// MessageText:
//
// No more data is available from the RPC pipe.
//


//
// MessageId: ERROR_NO_SITENAME
//
// MessageText:
//
// No site name is available for this machine.
//


//
// MessageId: ERROR_CANT_ACCESS_FILE
//
// MessageText:
//
// The file cannot be accessed by the system.
//


//
// MessageId: ERROR_CANT_RESOLVE_FILENAME
//
// MessageText:
//
// The name of the file cannot be resolved by the system.
//


//
// MessageId: RPC_S_ENTRY_TYPE_MISMATCH
//
// MessageText:
//
// The entry is not of the expected type.
//


//
// MessageId: RPC_S_NOT_ALL_OBJS_EXPORTED
//
// MessageText:
//
// Not all object UUIDs could be exported to the specified entry.
//


//
// MessageId: RPC_S_INTERFACE_NOT_EXPORTED
//
// MessageText:
//
// Interface could not be exported to the specified entry.
//


//
// MessageId: RPC_S_PROFILE_NOT_ADDED
//
// MessageText:
//
// The specified profile entry could not be added.
//


//
// MessageId: RPC_S_PRF_ELT_NOT_ADDED
//
// MessageText:
//
// The specified profile element could not be added.
//


//
// MessageId: RPC_S_PRF_ELT_NOT_REMOVED
//
// MessageText:
//
// The specified profile element could not be removed.
//


//
// MessageId: RPC_S_GRP_ELT_NOT_ADDED
//
// MessageText:
//
// The group element could not be added.
//


//
// MessageId: RPC_S_GRP_ELT_NOT_REMOVED
//
// MessageText:
//
// The group element could not be removed.
//


//
// MessageId: ERROR_KM_DRIVER_BLOCKED
//
// MessageText:
//
// The printer driver is not compatible with a policy enabled on your computer that blocks NT 4.0 drivers.
//


//
// MessageId: ERROR_CONTEXT_EXPIRED
//
// MessageText:
//
// The context has expired and can no longer be used.
//


//
// MessageId: ERROR_PER_USER_TRUST_QUOTA_EXCEEDED
//
// MessageText:
//
// The current user's delegated trust creation quota has been exceeded.
//


//
// MessageId: ERROR_ALL_USER_TRUST_QUOTA_EXCEEDED
//
// MessageText:
//
// The total delegated trust creation quota has been exceeded.
//


//
// MessageId: ERROR_USER_DELETE_TRUST_QUOTA_EXCEEDED
//
// MessageText:
//
// The current user's delegated trust deletion quota has been exceeded.
//


//
// MessageId: ERROR_AUTHENTICATION_FIREWALL_FAILED
//
// MessageText:
//
// The computer you are signing into is protected by an authentication firewall. The specified account is not allowed to authenticate to the computer.
//


//
// MessageId: ERROR_REMOTE_PRINT_CONNECTIONS_BLOCKED
//
// MessageText:
//
// Remote connections to the Print Spooler are blocked by a policy set on your machine.
//


//
// MessageId: ERROR_NTLM_BLOCKED
//
// MessageText:
//
// Authentication failed because NTLM authentication has been disabled.
//


//
// MessageId: ERROR_PASSWORD_CHANGE_REQUIRED
//
// MessageText:
//
// Logon Failure: EAS policy requires that the user change their password before this operation can be performed.
//


//
// MessageId: ERROR_LOST_MODE_LOGON_RESTRICTION
//
// MessageText:
//
// An administrator has restricted sign in. To sign in, make sure your device is connected to the Internet, and have your administrator sign in first.
//



///////////////////////////////////////////////////
//                                               //
//              OpenGL Error codes               //
//                                               //
//                 2000 to 2009                  //
///////////////////////////////////////////////////

//
// MessageId: ERROR_INVALID_PIXEL_FORMAT
//
// MessageText:
//
// The pixel format is invalid.
//


//
// MessageId: ERROR_BAD_DRIVER
//
// MessageText:
//
// The specified driver is invalid.
//


//
// MessageId: ERROR_INVALID_WINDOW_STYLE
//
// MessageText:
//
// The window style or class attribute is invalid for this operation.
//


//
// MessageId: ERROR_METAFILE_NOT_SUPPORTED
//
// MessageText:
//
// The requested metafile operation is not supported.
//


//
// MessageId: ERROR_TRANSFORM_NOT_SUPPORTED
//
// MessageText:
//
// The requested transformation operation is not supported.
//


//
// MessageId: ERROR_CLIPPING_NOT_SUPPORTED
//
// MessageText:
//
// The requested clipping operation is not supported.
//



///////////////////////////////////////////////////
//                                               //
//       Image Color Management Error codes      //
//                                               //
//                 2010 to 2049                  //
///////////////////////////////////////////////////

//
// MessageId: ERROR_INVALID_CMM
//
// MessageText:
//
// The specified color management module is invalid.
//


//
// MessageId: ERROR_INVALID_PROFILE
//
// MessageText:
//
// The specified color profile is invalid.
//


//
// MessageId: ERROR_TAG_NOT_FOUND
//
// MessageText:
//
// The specified tag was not found.
//


//
// MessageId: ERROR_TAG_NOT_PRESENT
//
// MessageText:
//
// A required tag is not present.
//


//
// MessageId: ERROR_DUPLICATE_TAG
//
// MessageText:
//
// The specified tag is already present.
//


//
// MessageId: ERROR_PROFILE_NOT_ASSOCIATED_WITH_DEVICE
//
// MessageText:
//
// The specified color profile is not associated with the specified device.
//


//
// MessageId: ERROR_PROFILE_NOT_FOUND
//
// MessageText:
//
// The specified color profile was not found.
//


//
// MessageId: ERROR_INVALID_COLORSPACE
//
// MessageText:
//
// The specified color space is invalid.
//


//
// MessageId: ERROR_ICM_NOT_ENABLED
//
// MessageText:
//
// Image Color Management is not enabled.
//


//
// MessageId: ERROR_DELETING_ICM_XFORM
//
// MessageText:
//
// There was an error while deleting the color transform.
//


//
// MessageId: ERROR_INVALID_TRANSFORM
//
// MessageText:
//
// The specified color transform is invalid.
//


//
// MessageId: ERROR_COLORSPACE_MISMATCH
//
// MessageText:
//
// The specified transform does not match the bitmap's color space.
//


//
// MessageId: ERROR_INVALID_COLORINDEX
//
// MessageText:
//
// The specified named color index is not present in the profile.
//


//
// MessageId: ERROR_PROFILE_DOES_NOT_MATCH_DEVICE
//
// MessageText:
//
// The specified profile is intended for a device of a different type than the specified device.
//



///////////////////////////////////////////////////
//                                               //
//             Winnet32 Error codes              //
//                                               //
//                 2100 to 2999                  //
//                                               //
// The range 2100 through 2999 is reserved for   //
// network status codes. See lmerr.h for a       //
// complete listing                              //
///////////////////////////////////////////////////

//
// MessageId: ERROR_CONNECTED_OTHER_PASSWORD
//
// MessageText:
//
// The network connection was made successfully, but the user had to be prompted for a password other than the one originally specified.
//


//
// MessageId: ERROR_CONNECTED_OTHER_PASSWORD_DEFAULT
//
// MessageText:
//
// The network connection was made successfully using default credentials.
//


//
// MessageId: ERROR_BAD_USERNAME
//
// MessageText:
//
// The specified username is invalid.
//


//
// MessageId: ERROR_NOT_CONNECTED
//
// MessageText:
//
// This network connection does not exist.
//


//
// MessageId: ERROR_OPEN_FILES
//
// MessageText:
//
// This network connection has files open or requests pending.
//


//
// MessageId: ERROR_ACTIVE_CONNECTIONS
//
// MessageText:
//
// Active connections still exist.
//


//
// MessageId: ERROR_DEVICE_IN_USE
//
// MessageText:
//
// The device is in use by an active process and cannot be disconnected.
//



///////////////////////////////////////////////////
//                                               //
//           Win32 Spooler Error codes           //
//                                               //
//                 3000 to 3049                  //
///////////////////////////////////////////////////

//
// MessageId: ERROR_UNKNOWN_PRINT_MONITOR
//
// MessageText:
//
// The specified print monitor is unknown.
//


//
// MessageId: ERROR_PRINTER_DRIVER_IN_USE
//
// MessageText:
//
// The specified printer driver is currently in use.
//


//
// MessageId: ERROR_SPOOL_FILE_NOT_FOUND
//
// MessageText:
//
// The spool file was not found.
//


//
// MessageId: ERROR_SPL_NO_STARTDOC
//
// MessageText:
//
// A StartDocPrinter call was not issued.
//


//
// MessageId: ERROR_SPL_NO_ADDJOB
//
// MessageText:
//
// An AddJob call was not issued.
//


//
// MessageId: ERROR_PRINT_PROCESSOR_ALREADY_INSTALLED
//
// MessageText:
//
// The specified print processor has already been installed.
//


//
// MessageId: ERROR_PRINT_MONITOR_ALREADY_INSTALLED
//
// MessageText:
//
// The specified print monitor has already been installed.
//


//
// MessageId: ERROR_INVALID_PRINT_MONITOR
//
// MessageText:
//
// The specified print monitor does not have the required functions.
//


//
// MessageId: ERROR_PRINT_MONITOR_IN_USE
//
// MessageText:
//
// The specified print monitor is currently in use.
//


//
// MessageId: ERROR_PRINTER_HAS_JOBS_QUEUED
//
// MessageText:
//
// The requested operation is not allowed when there are jobs queued to the printer.
//


//
// MessageId: ERROR_SUCCESS_REBOOT_REQUIRED
//
// MessageText:
//
// The requested operation is successful. Changes will not be effective until the system is rebooted.
//


//
// MessageId: ERROR_SUCCESS_RESTART_REQUIRED
//
// MessageText:
//
// The requested operation is successful. Changes will not be effective until the service is restarted.
//


//
// MessageId: ERROR_PRINTER_NOT_FOUND
//
// MessageText:
//
// No printers were found.
//


//
// MessageId: ERROR_PRINTER_DRIVER_WARNED
//
// MessageText:
//
// The printer driver is known to be unreliable.
//


//
// MessageId: ERROR_PRINTER_DRIVER_BLOCKED
//
// MessageText:
//
// The printer driver is known to harm the system.
//


//
// MessageId: ERROR_PRINTER_DRIVER_PACKAGE_IN_USE
//
// MessageText:
//
// The specified printer driver package is currently in use.
//


//
// MessageId: ERROR_CORE_DRIVER_PACKAGE_NOT_FOUND
//
// MessageText:
//
// Unable to find a core driver package that is required by the printer driver package.
//


//
// MessageId: ERROR_FAIL_REBOOT_REQUIRED
//
// MessageText:
//
// The requested operation failed. A system reboot is required to roll back changes made.
//


//
// MessageId: ERROR_FAIL_REBOOT_INITIATED
//
// MessageText:
//
// The requested operation failed. A system reboot has been initiated to roll back changes made.
//


//
// MessageId: ERROR_PRINTER_DRIVER_DOWNLOAD_NEEDED
//
// MessageText:
//
// The specified printer driver was not found on the system and needs to be downloaded.
//


//
// MessageId: ERROR_PRINT_JOB_RESTART_REQUIRED
//
// MessageText:
//
// The requested print job has failed to print. A print system update requires the job to be resubmitted.
//


//
// MessageId: ERROR_INVALID_PRINTER_DRIVER_MANIFEST
//
// MessageText:
//
// The printer driver does not contain a valid manifest, or contains too many manifests.
//


//
// MessageId: ERROR_PRINTER_NOT_SHAREABLE
//
// MessageText:
//
// The specified printer cannot be shared.
//



///////////////////////////////////////////////////
//                                               //
//           CopyFile ext. Error codes           //
//                                               //
//                 3050 to 3059                  //
///////////////////////////////////////////////////

//
// MessageId: ERROR_REQUEST_PAUSED
//
// MessageText:
//
// The operation was paused.
//



///////////////////////////////////////////////////
//                                               //
//           AppExec Error codes                 //
//                                               //
//                 3060 to 3079                  //
///////////////////////////////////////////////////

//
// MessageId: ERROR_APPEXEC_CONDITION_NOT_SATISFIED
//
// MessageText:
//
// The condition supplied for the app execution request was not satisfied, so the request was not performed.
//


//
// MessageId: ERROR_APPEXEC_HANDLE_INVALIDATED
//
// MessageText:
//
// The supplied handle has been invalidated and may not be used for the requested operation.
//


//
// MessageId: ERROR_APPEXEC_INVALID_HOST_GENERATION
//
// MessageText:
//
// The supplied host generation has been invalidated and may not be used for the requested operation.
//


//
// MessageId: ERROR_APPEXEC_UNEXPECTED_PROCESS_REGISTRATION
//
// MessageText:
//
// An attempt to register a process failed because the target host was not in a valid state to receive process registrations.
//


//
// MessageId: ERROR_APPEXEC_INVALID_HOST_STATE
//
// MessageText:
//
// The host is not in a valid state to support the execution request.
//


//
// MessageId: ERROR_APPEXEC_NO_DONOR
//
// MessageText:
//
// The operation was not completed because a required resource donor was not found for the host.
//


//
// MessageId: ERROR_APPEXEC_HOST_ID_MISMATCH
//
// MessageText:
//
// The operation was not completed because an unexpected host ID was encountered.
//


//
// MessageId: ERROR_APPEXEC_UNKNOWN_USER
//
// MessageText:
//
// The operation was not completed because the specified user was not known to the service.
//



///////////////////////////////////////////////////
//                                               //
//                  Available                    //
//                                               //
//                 3080 to 3199                  //
///////////////////////////////////////////////////


//
//               the message range
//                 3200 to 3299
//      is reserved and used in isolation lib
//

///////////////////////////////////////////////////
//                                               //
//                  Available                    //
//                                               //
//                 3300 to 3899                  //
///////////////////////////////////////////////////


///////////////////////////////////////////////////
//                                               //
//                IO Error Codes                 //
//                                               //
//                 3900 to 3999                  //
///////////////////////////////////////////////////

//
// MessageId: ERROR_IO_REISSUE_AS_CACHED
//
// MessageText:
//
// Reissue the given operation as a cached IO operation
//




///////////////////////////////////////////////////
//                                               //
//                Wins Error codes               //
//                                               //
//                 4000 to 4049                  //
///////////////////////////////////////////////////

//
// MessageId: ERROR_WINS_INTERNAL
//
// MessageText:
//
// WINS encountered an error while processing the command.
//


//
// MessageId: ERROR_CAN_NOT_DEL_LOCAL_WINS
//
// MessageText:
//
// The local WINS cannot be deleted.
//


//
// MessageId: ERROR_STATIC_INIT
//
// MessageText:
//
// The importation from the file failed.
//


//
// MessageId: ERROR_INC_BACKUP
//
// MessageText:
//
// The backup failed. Was a full backup done before?
//


//
// MessageId: ERROR_FULL_BACKUP
//
// MessageText:
//
// The backup failed. Check the directory to which you are backing the database.
//


//
// MessageId: ERROR_REC_NON_EXISTENT
//
// MessageText:
//
// The name does not exist in the WINS database.
//


//
// MessageId: ERROR_RPL_NOT_ALLOWED
//
// MessageText:
//
// Replication with a nonconfigured partner is not allowed.
//



///////////////////////////////////////////////////
//                                               //
//              PeerDist Error codes             //
//                                               //
//                 4050 to 4099                  //
///////////////////////////////////////////////////

//
// MessageId: PEERDIST_ERROR_CONTENTINFO_VERSION_UNSUPPORTED
//
// MessageText:
//
// The version of the supplied content information is not supported.
//


//
// MessageId: PEERDIST_ERROR_CANNOT_PARSE_CONTENTINFO
//
// MessageText:
//
// The supplied content information is malformed.
//


//
// MessageId: PEERDIST_ERROR_MISSING_DATA
//
// MessageText:
//
// The requested data cannot be found in local or peer caches.
//


//
// MessageId: PEERDIST_ERROR_NO_MORE
//
// MessageText:
//
// No more data is available or required.
//


//
// MessageId: PEERDIST_ERROR_NOT_INITIALIZED
//
// MessageText:
//
// The supplied object has not been initialized.
//


//
// MessageId: PEERDIST_ERROR_ALREADY_INITIALIZED
//
// MessageText:
//
// The supplied object has already been initialized.
//


//
// MessageId: PEERDIST_ERROR_SHUTDOWN_IN_PROGRESS
//
// MessageText:
//
// A shutdown operation is already in progress.
//


//
// MessageId: PEERDIST_ERROR_INVALIDATED
//
// MessageText:
//
// The supplied object has already been invalidated.
//


//
// MessageId: PEERDIST_ERROR_ALREADY_EXISTS
//
// MessageText:
//
// An element already exists and was not replaced.
//


//
// MessageId: PEERDIST_ERROR_OPERATION_NOTFOUND
//
// MessageText:
//
// Can not cancel the requested operation as it has already been completed.
//


//
// MessageId: PEERDIST_ERROR_ALREADY_COMPLETED
//
// MessageText:
//
// Can not perform the requested operation because it has already been carried out.
//


//
// MessageId: PEERDIST_ERROR_OUT_OF_BOUNDS
//
// MessageText:
//
// An operation accessed data beyond the bounds of valid data.
//


//
// MessageId: PEERDIST_ERROR_VERSION_UNSUPPORTED
//
// MessageText:
//
// The requested version is not supported.
//


//
// MessageId: PEERDIST_ERROR_INVALID_CONFIGURATION
//
// MessageText:
//
// A configuration value is invalid.
//


//
// MessageId: PEERDIST_ERROR_NOT_LICENSED
//
// MessageText:
//
// The SKU is not licensed.
//


//
// MessageId: PEERDIST_ERROR_SERVICE_UNAVAILABLE
//
// MessageText:
//
// PeerDist Service is still initializing and will be available shortly.
//


//
// MessageId: PEERDIST_ERROR_TRUST_FAILURE
//
// MessageText:
//
// Communication with one or more computers will be temporarily blocked due to recent errors.
//



///////////////////////////////////////////////////
//                                               //
//               DHCP Error codes                //
//                                               //
//                 4100 to 4149                  //
///////////////////////////////////////////////////

//
// MessageId: ERROR_DHCP_ADDRESS_CONFLICT
//
// MessageText:
//
// The DHCP client has obtained an IP address that is already in use on the network. The local interface will be disabled until the DHCP client can obtain a new address.
//



///////////////////////////////////////////////////
//                                               //
//                  Available                    //
//                                               //
//                 4150 to 4199                  //
///////////////////////////////////////////////////


///////////////////////////////////////////////////
//                                               //
//               WMI Error codes                 //
//                                               //
//                 4200 to 4249                  //
///////////////////////////////////////////////////

//
// MessageId: ERROR_WMI_GUID_NOT_FOUND
//
// MessageText:
//
// The GUID passed was not recognized as valid by a WMI data provider.
//


//
// MessageId: ERROR_WMI_INSTANCE_NOT_FOUND
//
// MessageText:
//
// The instance name passed was not recognized as valid by a WMI data provider.
//


//
// MessageId: ERROR_WMI_ITEMID_NOT_FOUND
//
// MessageText:
//
// The data item ID passed was not recognized as valid by a WMI data provider.
//


//
// MessageId: ERROR_WMI_TRY_AGAIN
//
// MessageText:
//
// The WMI request could not be completed and should be retried.
//


//
// MessageId: ERROR_WMI_DP_NOT_FOUND
//
// MessageText:
//
// The WMI data provider could not be located.
//


//
// MessageId: ERROR_WMI_UNRESOLVED_INSTANCE_REF
//
// MessageText:
//
// The WMI data provider references an instance set that has not been registered.
//


//
// MessageId: ERROR_WMI_ALREADY_ENABLED
//
// MessageText:
//
// The WMI data block or event notification has already been enabled.
//


//
// MessageId: ERROR_WMI_GUID_DISCONNECTED
//
// MessageText:
//
// The WMI data block is no longer available.
//


//
// MessageId: ERROR_WMI_SERVER_UNAVAILABLE
//
// MessageText:
//
// The WMI data service is not available.
//


//
// MessageId: ERROR_WMI_DP_FAILED
//
// MessageText:
//
// The WMI data provider failed to carry out the request.
//


//
// MessageId: ERROR_WMI_INVALID_MOF
//
// MessageText:
//
// The WMI MOF information is not valid.
//


//
// MessageId: ERROR_WMI_INVALID_REGINFO
//
// MessageText:
//
// The WMI registration information is not valid.
//


//
// MessageId: ERROR_WMI_ALREADY_DISABLED
//
// MessageText:
//
// The WMI data block or event notification has already been disabled.
//


//
// MessageId: ERROR_WMI_READ_ONLY
//
// MessageText:
//
// The WMI data item or data block is read only.
//


//
// MessageId: ERROR_WMI_SET_FAILURE
//
// MessageText:
//
// The WMI data item or data block could not be changed.
//



///////////////////////////////////////////////////
//                                               //
//      app container Specific Error Codes        //
//                                               //
//                 4250 to 4299                  //
///////////////////////////////////////////////////

//
// MessageId: ERROR_NOT_APPCONTAINER
//
// MessageText:
//
// This operation is only valid in the context of an app container.
//


//
// MessageId: ERROR_APPCONTAINER_REQUIRED
//
// MessageText:
//
// This application can only run in the context of an app container.
//


//
// MessageId: ERROR_NOT_SUPPORTED_IN_APPCONTAINER
//
// MessageText:
//
// This functionality is not supported in the context of an app container.
//


//
// MessageId: ERROR_INVALID_PACKAGE_SID_LENGTH
//
// MessageText:
//
// The length of the SID supplied is not a valid length for app container SIDs.
//


///////////////////////////////////////////////////
//                                               //
//        RSM (Media Services) Error codes       //
//                                               //
//                 4300 to 4349                  //
///////////////////////////////////////////////////

//
// MessageId: ERROR_INVALID_MEDIA
//
// MessageText:
//
// The media identifier does not represent a valid medium.
//


//
// MessageId: ERROR_INVALID_LIBRARY
//
// MessageText:
//
// The library identifier does not represent a valid library.
//


//
// MessageId: ERROR_INVALID_MEDIA_POOL
//
// MessageText:
//
// The media pool identifier does not represent a valid media pool.
//


//
// MessageId: ERROR_DRIVE_MEDIA_MISMATCH
//
// MessageText:
//
// The drive and medium are not compatible or exist in different libraries.
//


//
// MessageId: ERROR_MEDIA_OFFLINE
//
// MessageText:
//
// The medium currently exists in an offline library and must be online to perform this operation.
//


//
// MessageId: ERROR_LIBRARY_OFFLINE
//
// MessageText:
//
// The operation cannot be performed on an offline library.
//


//
// MessageId: ERROR_EMPTY
//
// MessageText:
//
// The library, drive, or media pool is empty.
//


//
// MessageId: ERROR_NOT_EMPTY
//
// MessageText:
//
// The library, drive, or media pool must be empty to perform this operation.
//


//
// MessageId: ERROR_MEDIA_UNAVAILABLE
//
// MessageText:
//
// No media is currently available in this media pool or library.
//


//
// MessageId: ERROR_RESOURCE_DISABLED
//
// MessageText:
//
// A resource required for this operation is disabled.
//


//
// MessageId: ERROR_INVALID_CLEANER
//
// MessageText:
//
// The media identifier does not represent a valid cleaner.
//


//
// MessageId: ERROR_UNABLE_TO_CLEAN
//
// MessageText:
//
// The drive cannot be cleaned or does not support cleaning.
//


//
// MessageId: ERROR_OBJECT_NOT_FOUND
//
// MessageText:
//
// The object identifier does not represent a valid object.
//


//
// MessageId: ERROR_DATABASE_FAILURE
//
// MessageText:
//
// Unable to read from or write to the database.
//


//
// MessageId: ERROR_DATABASE_FULL
//
// MessageText:
//
// The database is full.
//


//
// MessageId: ERROR_MEDIA_INCOMPATIBLE
//
// MessageText:
//
// The medium is not compatible with the device or media pool.
//


//
// MessageId: ERROR_RESOURCE_NOT_PRESENT
//
// MessageText:
//
// The resource required for this operation does not exist.
//


//
// MessageId: ERROR_INVALID_OPERATION
//
// MessageText:
//
// The operation identifier is not valid.
//


//
// MessageId: ERROR_MEDIA_NOT_AVAILABLE
//
// MessageText:
//
// The media is not mounted or ready for use.
//


//
// MessageId: ERROR_DEVICE_NOT_AVAILABLE
//
// MessageText:
//
// The device is not ready for use.
//


//
// MessageId: ERROR_REQUEST_REFUSED
//
// MessageText:
//
// The operator or administrator has refused the request.
//


//
// MessageId: ERROR_INVALID_DRIVE_OBJECT
//
// MessageText:
//
// The drive identifier does not represent a valid drive.
//


//
// MessageId: ERROR_LIBRARY_FULL
//
// MessageText:
//
// Library is full. No slot is available for use.
//


//
// MessageId: ERROR_MEDIUM_NOT_ACCESSIBLE
//
// MessageText:
//
// The transport cannot access the medium.
//


//
// MessageId: ERROR_UNABLE_TO_LOAD_MEDIUM
//
// MessageText:
//
// Unable to load the medium into the drive.
//


//
// MessageId: ERROR_UNABLE_TO_INVENTORY_DRIVE
//
// MessageText:
//
// Unable to retrieve the drive status.
//


//
// MessageId: ERROR_UNABLE_TO_INVENTORY_SLOT
//
// MessageText:
//
// Unable to retrieve the slot status.
//


//
// MessageId: ERROR_UNABLE_TO_INVENTORY_TRANSPORT
//
// MessageText:
//
// Unable to retrieve status about the transport.
//


//
// MessageId: ERROR_TRANSPORT_FULL
//
// MessageText:
//
// Cannot use the transport because it is already in use.
//


//
// MessageId: ERROR_CONTROLLING_IEPORT
//
// MessageText:
//
// Unable to open or close the inject/eject port.
//


//
// MessageId: ERROR_UNABLE_TO_EJECT_MOUNTED_MEDIA
//
// MessageText:
//
// Unable to eject the medium because it is in a drive.
//


//
// MessageId: ERROR_CLEANER_SLOT_SET
//
// MessageText:
//
// A cleaner slot is already reserved.
//


//
// MessageId: ERROR_CLEANER_SLOT_NOT_SET
//
// MessageText:
//
// A cleaner slot is not reserved.
//


//
// MessageId: ERROR_CLEANER_CARTRIDGE_SPENT
//
// MessageText:
//
// The cleaner cartridge has performed the maximum number of drive cleanings.
//


//
// MessageId: ERROR_UNEXPECTED_OMID
//
// MessageText:
//
// Unexpected on-medium identifier.
//


//
// MessageId: ERROR_CANT_DELETE_LAST_ITEM
//
// MessageText:
//
// The last remaining item in this group or resource cannot be deleted.
//


//
// MessageId: ERROR_MESSAGE_EXCEEDS_MAX_SIZE
//
// MessageText:
//
// The message provided exceeds the maximum size allowed for this parameter.
//


//
// MessageId: ERROR_VOLUME_CONTAINS_SYS_FILES
//
// MessageText:
//
// The volume contains system or paging files.
//


//
// MessageId: ERROR_INDIGENOUS_TYPE
//
// MessageText:
//
// The media type cannot be removed from this library since at least one drive in the library reports it can support this media type.
//


//
// MessageId: ERROR_NO_SUPPORTING_DRIVES
//
// MessageText:
//
// This offline media cannot be mounted on this system since no enabled drives are present which can be used.
//


//
// MessageId: ERROR_CLEANER_CARTRIDGE_INSTALLED
//
// MessageText:
//
// A cleaner cartridge is present in the tape library.
//


//
// MessageId: ERROR_IEPORT_FULL
//
// MessageText:
//
// Cannot use the inject/eject port because it is not empty.
//



///////////////////////////////////////////////////
//                                               //
//       Remote Storage Service Error codes      //
//                                               //
//                 4350 to 4389                  //
///////////////////////////////////////////////////

//
// MessageId: ERROR_FILE_OFFLINE
//
// MessageText:
//
// This file is currently not available for use on this computer.
//


//
// MessageId: ERROR_REMOTE_STORAGE_NOT_ACTIVE
//
// MessageText:
//
// The remote storage service is not operational at this time.
//


//
// MessageId: ERROR_REMOTE_STORAGE_MEDIA_ERROR
//
// MessageText:
//
// The remote storage service encountered a media error.
//



///////////////////////////////////////////////////
//                                               //
//           Reparse Point Error codes           //
//                                               //
//                 4390 to 4399                  //
///////////////////////////////////////////////////

//
// MessageId: ERROR_NOT_A_REPARSE_POINT
//
// MessageText:
//
// The file or directory is not a reparse point.
//


//
// MessageId: ERROR_REPARSE_ATTRIBUTE_CONFLICT
//
// MessageText:
//
// The reparse point attribute cannot be set because it conflicts with an existing attribute.
//


//
// MessageId: ERROR_INVALID_REPARSE_DATA
//
// MessageText:
//
// The data present in the reparse point buffer is invalid.
//


//
// MessageId: ERROR_REPARSE_TAG_INVALID
//
// MessageText:
//
// The tag present in the reparse point buffer is invalid.
//


//
// MessageId: ERROR_REPARSE_TAG_MISMATCH
//
// MessageText:
//
// There is a mismatch between the tag specified in the request and the tag present in the reparse point.
//


//
// MessageId: ERROR_REPARSE_POINT_ENCOUNTERED
//
// MessageText:
//
// The object manager encountered a reparse point while retrieving an object.
//



///////////////////////////////////////////////////
//                                               //
//         Fast Cache Specific Error Codes       //
//                                               //
//                 4400 to 4419                  //
///////////////////////////////////////////////////

//
// MessageId: ERROR_APP_DATA_NOT_FOUND
//
// MessageText:
//
// Fast Cache data not found.
//


//
// MessageId: ERROR_APP_DATA_EXPIRED
//
// MessageText:
//
// Fast Cache data expired.
//


//
// MessageId: ERROR_APP_DATA_CORRUPT
//
// MessageText:
//
// Fast Cache data corrupt.
//


//
// MessageId: ERROR_APP_DATA_LIMIT_EXCEEDED
//
// MessageText:
//
// Fast Cache data has exceeded its max size and cannot be updated.
//


//
// MessageId: ERROR_APP_DATA_REBOOT_REQUIRED
//
// MessageText:
//
// Fast Cache has been ReArmed and requires a reboot until it can be updated.
//



///////////////////////////////////////////////////
//                                               //
//             SecureBoot Error codes            //
//                                               //
//                 4420 to 4439                  //
///////////////////////////////////////////////////

//
// MessageId: ERROR_SECUREBOOT_ROLLBACK_DETECTED
//
// MessageText:
//
// Secure Boot detected that rollback of protected data has been attempted.
//


//
// MessageId: ERROR_SECUREBOOT_POLICY_VIOLATION
//
// MessageText:
//
// The value is protected by Secure Boot policy and cannot be modified or deleted.
//


//
// MessageId: ERROR_SECUREBOOT_INVALID_POLICY
//
// MessageText:
//
// The Secure Boot policy is invalid.
//


//
// MessageId: ERROR_SECUREBOOT_POLICY_PUBLISHER_NOT_FOUND
//
// MessageText:
//
// A new Secure Boot policy did not contain the current publisher on its update list.
//


//
// MessageId: ERROR_SECUREBOOT_POLICY_NOT_SIGNED
//
// MessageText:
//
// The Secure Boot policy is either not signed or is signed by a non-trusted signer.
//


//
// MessageId: ERROR_SECUREBOOT_NOT_ENABLED
//
// MessageText:
//
// Secure Boot is not enabled on this machine.
//


//
// MessageId: ERROR_SECUREBOOT_FILE_REPLACED
//
// MessageText:
//
// Secure Boot requires that certain files and drivers are not replaced by other files or drivers.
//


//
// MessageId: ERROR_SECUREBOOT_POLICY_NOT_AUTHORIZED
//
// MessageText:
//
// The Secure Boot Supplemental Policy file was not authorized on this machine.
//


//
// MessageId: ERROR_SECUREBOOT_POLICY_UNKNOWN
//
// MessageText:
//
// The Supplemental Policy is not recognized on this device.
//


//
// MessageId: ERROR_SECUREBOOT_POLICY_MISSING_ANTIROLLBACKVERSION
//
// MessageText:
//
// The Antirollback version was not found in the Secure Boot Policy.
//


//
// MessageId: ERROR_SECUREBOOT_PLATFORM_ID_MISMATCH
//
// MessageText:
//
// The Platform ID specified in the Secure Boot policy does not match the Platform ID on this device.
//


//
// MessageId: ERROR_SECUREBOOT_POLICY_ROLLBACK_DETECTED
//
// MessageText:
//
// The Secure Boot policy file has an older Antirollback Version than this device.
//


//
// MessageId: ERROR_SECUREBOOT_POLICY_UPGRADE_MISMATCH
//
// MessageText:
//
// The Secure Boot policy file does not match the upgraded legacy policy.
//


//
// MessageId: ERROR_SECUREBOOT_REQUIRED_POLICY_FILE_MISSING
//
// MessageText:
//
// The Secure Boot policy file is required but could not be found.
//


//
// MessageId: ERROR_SECUREBOOT_NOT_BASE_POLICY
//
// MessageText:
//
// Supplemental Secure Boot policy file can not be loaded as a base Secure Boot policy.
//


//
// MessageId: ERROR_SECUREBOOT_NOT_SUPPLEMENTAL_POLICY
//
// MessageText:
//
// Base Secure Boot policy file can not be loaded as a Supplemental Secure Boot policy.
//



///////////////////////////////////////////////////
//                                               //
//       File System Specific Error Codes        //
//                                               //
//                 4440 to 4499                  //
///////////////////////////////////////////////////

//
// MessageId: ERROR_OFFLOAD_READ_FLT_NOT_SUPPORTED
//
// MessageText:
//
// The copy offload read operation is not supported by a filter.
//


//
// MessageId: ERROR_OFFLOAD_WRITE_FLT_NOT_SUPPORTED
//
// MessageText:
//
// The copy offload write operation is not supported by a filter.
//


//
// MessageId: ERROR_OFFLOAD_READ_FILE_NOT_SUPPORTED
//
// MessageText:
//
// The copy offload read operation is not supported for the file.
//


//
// MessageId: ERROR_OFFLOAD_WRITE_FILE_NOT_SUPPORTED
//
// MessageText:
//
// The copy offload write operation is not supported for the file.
//


//
// MessageId: ERROR_ALREADY_HAS_STREAM_ID
//
// MessageText:
//
// This file is currently associated with a different stream id.
//


//
// MessageId: ERROR_SMR_GARBAGE_COLLECTION_REQUIRED
//
// MessageText:
//
// The volume must undergo garbage collection.
//


//
// MessageId: ERROR_WOF_WIM_HEADER_CORRUPT
//
// MessageText:
//
// The WOF driver encountered a corruption in WIM image's Header.
//


//
// MessageId: ERROR_WOF_WIM_RESOURCE_TABLE_CORRUPT
//
// MessageText:
//
// The WOF driver encountered a corruption in WIM image's Resource Table.
//


//
// MessageId: ERROR_WOF_FILE_RESOURCE_TABLE_CORRUPT
//
// MessageText:
//
// The WOF driver encountered a corruption in the compressed file's Resource Table.
//



///////////////////////////////////////////////////
//                                               //
//    Single Instance Store (SIS) Error codes    //
//                                               //
//                 4500 to 4549                  //
///////////////////////////////////////////////////

//
// MessageId: ERROR_VOLUME_NOT_SIS_ENABLED
//
// MessageText:
//
// Single Instance Storage is not available on this volume.
//



///////////////////////////////////////////////////
//                                               //
//             System Integrity Error codes      //
//                                               //
//                 4550 to 4559                  //
///////////////////////////////////////////////////

//
// MessageId: ERROR_SYSTEM_INTEGRITY_ROLLBACK_DETECTED
//
// MessageText:
//
// System Integrity detected that policy rollback has been attempted.
//


//
// MessageId: ERROR_SYSTEM_INTEGRITY_POLICY_VIOLATION
//
// MessageText:
//
// Your organization used Device Guard to block this app. Contact your support person for more info.
//


//
// MessageId: ERROR_SYSTEM_INTEGRITY_INVALID_POLICY
//
// MessageText:
//
// The System Integrity policy is invalid.
//


//
// MessageId: ERROR_SYSTEM_INTEGRITY_POLICY_NOT_SIGNED
//
// MessageText:
//
// The System Integrity policy is either not signed or is signed by a non-trusted signer.
//


//
// MessageId: ERROR_SYSTEM_INTEGRITY_TOO_MANY_POLICIES
//
// MessageText:
//
// The number of System Integrity policies is out of limit.
//


//
// MessageId: ERROR_SYSTEM_INTEGRITY_SUPPLEMENTAL_POLICY_NOT_AUTHORIZED
//
// MessageText:
//
// The Code Integrity supplemental policy is not authorized by a Code Integrity base policy.
//



///////////////////////////////////////////////////
//                                               //
//             VSM Error codes                   //
//                                               //
//                 4560 to 4569                  //
///////////////////////////////////////////////////

//
// MessageId: ERROR_VSM_NOT_INITIALIZED
//
// MessageText:
//
// Virtual Secure Mode (VSM) is not initialized. The hypervisor or VSM may not be present or enabled.
//


//
// MessageId: ERROR_VSM_DMA_PROTECTION_NOT_IN_USE
//
// MessageText:
//
// The hypervisor is not protecting DMA because an IOMMU is not present or not enabled in the BIOS.
//


///////////////////////////////////////////////////
//                                               //
//         Platform Manifest Error Codes         //
//                                               //
//                 4570 to 4579                  //
///////////////////////////////////////////////////

//
// MessageId: ERROR_PLATFORM_MANIFEST_NOT_AUTHORIZED
//
// MessageText:
//
// The Platform Manifest file was not authorized on this machine.
//


//
// MessageId: ERROR_PLATFORM_MANIFEST_INVALID
//
// MessageText:
//
// The Platform Manifest file was not valid.
//


//
// MessageId: ERROR_PLATFORM_MANIFEST_FILE_NOT_AUTHORIZED
//
// MessageText:
//
// The file is not authorized on this platform because an entry was not found in the Platform Manifest.
//


//
// MessageId: ERROR_PLATFORM_MANIFEST_CATALOG_NOT_AUTHORIZED
//
// MessageText:
//
// The catalog is not authorized on this platform because an entry was not found in the Platform Manifest.
//


//
// MessageId: ERROR_PLATFORM_MANIFEST_BINARY_ID_NOT_FOUND
//
// MessageText:
//
// The file is not authorized on this platform because a Binary ID was not found in the embedded signature.
//


//
// MessageId: ERROR_PLATFORM_MANIFEST_NOT_ACTIVE
//
// MessageText:
//
// No active Platform Manifest exists on this system.
//


//
// MessageId: ERROR_PLATFORM_MANIFEST_NOT_SIGNED
//
// MessageText:
//
// The Platform Manifest file was not properly signed.
//


///////////////////////////////////////////////////
//                                               //
//                  Available                    //
//                                               //
//                 4580 to 4599                  //
///////////////////////////////////////////////////

///////////////////////////////////////////////////
//                                               //
//             Cluster Error codes               //
//                                               //
//                 5000 to 5999                  //
///////////////////////////////////////////////////

//
// MessageId: ERROR_DEPENDENT_RESOURCE_EXISTS
//
// MessageText:
//
// The operation cannot be completed because other resources are dependent on this resource.
//


//
// MessageId: ERROR_DEPENDENCY_NOT_FOUND
//
// MessageText:
//
// The cluster resource dependency cannot be found.
//


//
// MessageId: ERROR_DEPENDENCY_ALREADY_EXISTS
//
// MessageText:
//
// The cluster resource cannot be made dependent on the specified resource because it is already dependent.
//


//
// MessageId: ERROR_RESOURCE_NOT_ONLINE
//
// MessageText:
//
// The cluster resource is not online.
//


//
// MessageId: ERROR_HOST_NODE_NOT_AVAILABLE
//
// MessageText:
//
// A cluster node is not available for this operation.
//


//
// MessageId: ERROR_RESOURCE_NOT_AVAILABLE
//
// MessageText:
//
// The cluster resource is not available.
//


//
// MessageId: ERROR_RESOURCE_NOT_FOUND
//
// MessageText:
//
// The cluster resource could not be found.
//


//
// MessageId: ERROR_SHUTDOWN_CLUSTER
//
// MessageText:
//
// The cluster is being shut down.
//


//
// MessageId: ERROR_CANT_EVICT_ACTIVE_NODE
//
// MessageText:
//
// A cluster node cannot be evicted from the cluster unless the node is down or it is the last node.
//


//
// MessageId: ERROR_OBJECT_ALREADY_EXISTS
//
// MessageText:
//
// The object already exists.
//


//
// MessageId: ERROR_OBJECT_IN_LIST
//
// MessageText:
//
// The object is already in the list.
//


//
// MessageId: ERROR_GROUP_NOT_AVAILABLE
//
// MessageText:
//
// The cluster group is not available for any new requests.
//


//
// MessageId: ERROR_GROUP_NOT_FOUND
//
// MessageText:
//
// The cluster group could not be found.
//


//
// MessageId: ERROR_GROUP_NOT_ONLINE
//
// MessageText:
//
// The operation could not be completed because the cluster group is not online.
//


//
// MessageId: ERROR_HOST_NODE_NOT_RESOURCE_OWNER
//
// MessageText:
//
// The operation failed because either the specified cluster node is not the owner of the resource, or the node is not a possible owner of the resource.
//


//
// MessageId: ERROR_HOST_NODE_NOT_GROUP_OWNER
//
// MessageText:
//
// The operation failed because either the specified cluster node is not the owner of the group, or the node is not a possible owner of the group.
//


//
// MessageId: ERROR_RESMON_CREATE_FAILED
//
// MessageText:
//
// The cluster resource could not be created in the specified resource monitor.
//


//
// MessageId: ERROR_RESMON_ONLINE_FAILED
//
// MessageText:
//
// The cluster resource could not be brought online by the resource monitor.
//


//
// MessageId: ERROR_RESOURCE_ONLINE
//
// MessageText:
//
// The operation could not be completed because the cluster resource is online.
//


//
// MessageId: ERROR_QUORUM_RESOURCE
//
// MessageText:
//
// The cluster resource could not be deleted or brought offline because it is the quorum resource.
//


//
// MessageId: ERROR_NOT_QUORUM_CAPABLE
//
// MessageText:
//
// The cluster could not make the specified resource a quorum resource because it is not capable of being a quorum resource.
//


//
// MessageId: ERROR_CLUSTER_SHUTTING_DOWN
//
// MessageText:
//
// The cluster software is shutting down.
//


//
// MessageId: ERROR_INVALID_STATE
//
// MessageText:
//
// The group or resource is not in the correct state to perform the requested operation.
//


//
// MessageId: ERROR_RESOURCE_PROPERTIES_STORED
//
// MessageText:
//
// The properties were stored but not all changes will take effect until the next time the resource is brought online.
//


//
// MessageId: ERROR_NOT_QUORUM_CLASS
//
// MessageText:
//
// The cluster could not make the specified resource a quorum resource because it does not belong to a shared storage class.
//


//
// MessageId: ERROR_CORE_RESOURCE
//
// MessageText:
//
// The cluster resource could not be deleted since it is a core resource.
//


//
// MessageId: ERROR_QUORUM_RESOURCE_ONLINE_FAILED
//
// MessageText:
//
// The quorum resource failed to come online.
//


//
// MessageId: ERROR_QUORUMLOG_OPEN_FAILED
//
// MessageText:
//
// The quorum log could not be created or mounted successfully.
//


//
// MessageId: ERROR_CLUSTERLOG_CORRUPT
//
// MessageText:
//
// The cluster log is corrupt.
//


//
// MessageId: ERROR_CLUSTERLOG_RECORD_EXCEEDS_MAXSIZE
//
// MessageText:
//
// The record could not be written to the cluster log since it exceeds the maximum size.
//


//
// MessageId: ERROR_CLUSTERLOG_EXCEEDS_MAXSIZE
//
// MessageText:
//
// The cluster log exceeds its maximum size.
//


//
// MessageId: ERROR_CLUSTERLOG_CHKPOINT_NOT_FOUND
//
// MessageText:
//
// No checkpoint record was found in the cluster log.
//


//
// MessageId: ERROR_CLUSTERLOG_NOT_ENOUGH_SPACE
//
// MessageText:
//
// The minimum required disk space needed for logging is not available.
//


//
// MessageId: ERROR_QUORUM_OWNER_ALIVE
//
// MessageText:
//
// The cluster node failed to take control of the quorum resource because the resource is owned by another active node.
//


//
// MessageId: ERROR_NETWORK_NOT_AVAILABLE
//
// MessageText:
//
// A cluster network is not available for this operation.
//


//
// MessageId: ERROR_NODE_NOT_AVAILABLE
//
// MessageText:
//
// A cluster node is not available for this operation.
//


//
// MessageId: ERROR_ALL_NODES_NOT_AVAILABLE
//
// MessageText:
//
// All cluster nodes must be running to perform this operation.
//


//
// MessageId: ERROR_RESOURCE_FAILED
//
// MessageText:
//
// A cluster resource failed.
//


//
// MessageId: ERROR_CLUSTER_INVALID_NODE
//
// MessageText:
//
// The cluster node is not valid.
//


//
// MessageId: ERROR_CLUSTER_NODE_EXISTS
//
// MessageText:
//
// The cluster node already exists.
//


//
// MessageId: ERROR_CLUSTER_JOIN_IN_PROGRESS
//
// MessageText:
//
// A node is in the process of joining the cluster.
//


//
// MessageId: ERROR_CLUSTER_NODE_NOT_FOUND
//
// MessageText:
//
// The cluster node was not found.
//


//
// MessageId: ERROR_CLUSTER_LOCAL_NODE_NOT_FOUND
//
// MessageText:
//
// The cluster local node information was not found.
//


//
// MessageId: ERROR_CLUSTER_NETWORK_EXISTS
//
// MessageText:
//
// The cluster network already exists.
//


//
// MessageId: ERROR_CLUSTER_NETWORK_NOT_FOUND
//
// MessageText:
//
// The cluster network was not found.
//


//
// MessageId: ERROR_CLUSTER_NETINTERFACE_EXISTS
//
// MessageText:
//
// The cluster network interface already exists.
//


//
// MessageId: ERROR_CLUSTER_NETINTERFACE_NOT_FOUND
//
// MessageText:
//
// The cluster network interface was not found.
//


//
// MessageId: ERROR_CLUSTER_INVALID_REQUEST
//
// MessageText:
//
// The cluster request is not valid for this object.
//


//
// MessageId: ERROR_CLUSTER_INVALID_NETWORK_PROVIDER
//
// MessageText:
//
// The cluster network provider is not valid.
//


//
// MessageId: ERROR_CLUSTER_NODE_DOWN
//
// MessageText:
//
// The cluster node is down.
//


//
// MessageId: ERROR_CLUSTER_NODE_UNREACHABLE
//
// MessageText:
//
// The cluster node is not reachable.
//


//
// MessageId: ERROR_CLUSTER_NODE_NOT_MEMBER
//
// MessageText:
//
// The cluster node is not a member of the cluster.
//


//
// MessageId: ERROR_CLUSTER_JOIN_NOT_IN_PROGRESS
//
// MessageText:
//
// A cluster join operation is not in progress.
//


//
// MessageId: ERROR_CLUSTER_INVALID_NETWORK
//
// MessageText:
//
// The cluster network is not valid.
//


//
// MessageId: ERROR_CLUSTER_NODE_UP
//
// MessageText:
//
// The cluster node is up.
//


//
// MessageId: ERROR_CLUSTER_IPADDR_IN_USE
//
// MessageText:
//
// The cluster IP address is already in use.
//


//
// MessageId: ERROR_CLUSTER_NODE_NOT_PAUSED
//
// MessageText:
//
// The cluster node is not paused.
//


//
// MessageId: ERROR_CLUSTER_NO_SECURITY_CONTEXT
//
// MessageText:
//
// No cluster security context is available.
//


//
// MessageId: ERROR_CLUSTER_NETWORK_NOT_INTERNAL
//
// MessageText:
//
// The cluster network is not configured for internal cluster communication.
//


//
// MessageId: ERROR_CLUSTER_NODE_ALREADY_UP
//
// MessageText:
//
// The cluster node is already up.
//


//
// MessageId: ERROR_CLUSTER_NODE_ALREADY_DOWN
//
// MessageText:
//
// The cluster node is already down.
//


//
// MessageId: ERROR_CLUSTER_NETWORK_ALREADY_ONLINE
//
// MessageText:
//
// The cluster network is already online.
//


//
// MessageId: ERROR_CLUSTER_NETWORK_ALREADY_OFFLINE
//
// MessageText:
//
// The cluster network is already offline.
//


//
// MessageId: ERROR_CLUSTER_NODE_ALREADY_MEMBER
//
// MessageText:
//
// The cluster node is already a member of the cluster.
//


//
// MessageId: ERROR_CLUSTER_LAST_INTERNAL_NETWORK
//
// MessageText:
//
// The cluster network is the only one configured for internal cluster communication between two or more active cluster nodes. The internal communication capability cannot be removed from the network.
//


//
// MessageId: ERROR_CLUSTER_NETWORK_HAS_DEPENDENTS
//
// MessageText:
//
// One or more cluster resources depend on the network to provide service to clients. The client access capability cannot be removed from the network.
//


//
// MessageId: ERROR_INVALID_OPERATION_ON_QUORUM
//
// MessageText:
//
// This operation cannot currently be performed on the cluster group containing the quorum resource.
//


//
// MessageId: ERROR_DEPENDENCY_NOT_ALLOWED
//
// MessageText:
//
// The cluster quorum resource is not allowed to have any dependencies.
//


//
// MessageId: ERROR_CLUSTER_NODE_PAUSED
//
// MessageText:
//
// The cluster node is paused.
//


//
// MessageId: ERROR_NODE_CANT_HOST_RESOURCE
//
// MessageText:
//
// The cluster resource cannot be brought online. The owner node cannot run this resource.
//


//
// MessageId: ERROR_CLUSTER_NODE_NOT_READY
//
// MessageText:
//
// The cluster node is not ready to perform the requested operation.
//


//
// MessageId: ERROR_CLUSTER_NODE_SHUTTING_DOWN
//
// MessageText:
//
// The cluster node is shutting down.
//


//
// MessageId: ERROR_CLUSTER_JOIN_ABORTED
//
// MessageText:
//
// The cluster join operation was aborted.
//


//
// MessageId: ERROR_CLUSTER_INCOMPATIBLE_VERSIONS
//
// MessageText:
//
// The node failed to join the cluster because the joining node and other nodes in the cluster have incompatible operating system versions. To get more information about operating system versions of the cluster, run the Validate a Configuration Wizard or the Test-Cluster Windows PowerShell cmdlet.
//


//
// MessageId: ERROR_CLUSTER_MAXNUM_OF_RESOURCES_EXCEEDED
//
// MessageText:
//
// This resource cannot be created because the cluster has reached the limit on the number of resources it can monitor.
//


//
// MessageId: ERROR_CLUSTER_SYSTEM_CONFIG_CHANGED
//
// MessageText:
//
// The system configuration changed during the cluster join or form operation. The join or form operation was aborted.
//


//
// MessageId: ERROR_CLUSTER_RESOURCE_TYPE_NOT_FOUND
//
// MessageText:
//
// The specified resource type was not found.
//


//
// MessageId: ERROR_CLUSTER_RESTYPE_NOT_SUPPORTED
//
// MessageText:
//
// The specified node does not support a resource of this type. This may be due to version inconsistencies or due to the absence of the resource DLL on this node.
//


//
// MessageId: ERROR_CLUSTER_RESNAME_NOT_FOUND
//
// MessageText:
//
// The specified resource name is not supported by this resource DLL. This may be due to a bad (or changed) name supplied to the resource DLL.
//


//
// MessageId: ERROR_CLUSTER_NO_RPC_PACKAGES_REGISTERED
//
// MessageText:
//
// No authentication package could be registered with the RPC server.
//


//
// MessageId: ERROR_CLUSTER_OWNER_NOT_IN_PREFLIST
//
// MessageText:
//
// You cannot bring the group online because the owner of the group is not in the preferred list for the group. To change the owner node for the group, move the group.
//


//
// MessageId: ERROR_CLUSTER_DATABASE_SEQMISMATCH
//
// MessageText:
//
// The join operation failed because the cluster database sequence number has changed or is incompatible with the locker node. This may happen during a join operation if the cluster database was changing during the join.
//


//
// MessageId: ERROR_RESMON_INVALID_STATE
//
// MessageText:
//
// The resource monitor will not allow the fail operation to be performed while the resource is in its current state. This may happen if the resource is in a pending state.
//


//
// MessageId: ERROR_CLUSTER_GUM_NOT_LOCKER
//
// MessageText:
//
// A non locker code got a request to reserve the lock for making global updates.
//


//
// MessageId: ERROR_QUORUM_DISK_NOT_FOUND
//
// MessageText:
//
// The quorum disk could not be located by the cluster service.
//


//
// MessageId: ERROR_DATABASE_BACKUP_CORRUPT
//
// MessageText:
//
// The backed up cluster database is possibly corrupt.
//


//
// MessageId: ERROR_CLUSTER_NODE_ALREADY_HAS_DFS_ROOT
//
// MessageText:
//
// A DFS root already exists in this cluster node.
//


//
// MessageId: ERROR_RESOURCE_PROPERTY_UNCHANGEABLE
//
// MessageText:
//
// An attempt to modify a resource property failed because it conflicts with another existing property.
//


//
// MessageId: ERROR_NO_ADMIN_ACCESS_POINT
//
// MessageText:
//
// This operation is not supported on a cluster without an Administrator Access Point.
//


/*
 Codes from 4300 through 5889 overlap with codes in ds\published\inc\apperr2.w.
 Do not add any more error codes in that range.
*/
//
// MessageId: ERROR_CLUSTER_MEMBERSHIP_INVALID_STATE
//
// MessageText:
//
// An operation was attempted that is incompatible with the current membership state of the node.
//


//
// MessageId: ERROR_CLUSTER_QUORUMLOG_NOT_FOUND
//
// MessageText:
//
// The quorum resource does not contain the quorum log.
//


//
// MessageId: ERROR_CLUSTER_MEMBERSHIP_HALT
//
// MessageText:
//
// The membership engine requested shutdown of the cluster service on this node.
//


//
// MessageId: ERROR_CLUSTER_INSTANCE_ID_MISMATCH
//
// MessageText:
//
// The join operation failed because the cluster instance ID of the joining node does not match the cluster instance ID of the sponsor node.
//


//
// MessageId: ERROR_CLUSTER_NETWORK_NOT_FOUND_FOR_IP
//
// MessageText:
//
// A matching cluster network for the specified IP address could not be found.
//


//
// MessageId: ERROR_CLUSTER_PROPERTY_DATA_TYPE_MISMATCH
//
// MessageText:
//
// The actual data type of the property did not match the expected data type of the property.
//


//
// MessageId: ERROR_CLUSTER_EVICT_WITHOUT_CLEANUP
//
// MessageText:
//
// The cluster node was evicted from the cluster successfully, but the node was not cleaned up. To determine what cleanup steps failed and how to recover, see the Failover Clustering application event log using Event Viewer.
//


//
// MessageId: ERROR_CLUSTER_PARAMETER_MISMATCH
//
// MessageText:
//
// Two or more parameter values specified for a resource's properties are in conflict.
//


//
// MessageId: ERROR_NODE_CANNOT_BE_CLUSTERED
//
// MessageText:
//
// This computer cannot be made a member of a cluster.
//


//
// MessageId: ERROR_CLUSTER_WRONG_OS_VERSION
//
// MessageText:
//
// This computer cannot be made a member of a cluster because it does not have the correct version of Windows installed.
//


//
// MessageId: ERROR_CLUSTER_CANT_CREATE_DUP_CLUSTER_NAME
//
// MessageText:
//
// A cluster cannot be created with the specified cluster name because that cluster name is already in use. Specify a different name for the cluster.
//


//
// MessageId: ERROR_CLUSCFG_ALREADY_COMMITTED
//
// MessageText:
//
// The cluster configuration action has already been committed.
//


//
// MessageId: ERROR_CLUSCFG_ROLLBACK_FAILED
//
// MessageText:
//
// The cluster configuration action could not be rolled back.
//


//
// MessageId: ERROR_CLUSCFG_SYSTEM_DISK_DRIVE_LETTER_CONFLICT
//
// MessageText:
//
// The drive letter assigned to a system disk on one node conflicted with the drive letter assigned to a disk on another node.
//


//
// MessageId: ERROR_CLUSTER_OLD_VERSION
//
// MessageText:
//
// One or more nodes in the cluster are running a version of Windows that does not support this operation.
//


//
// MessageId: ERROR_CLUSTER_MISMATCHED_COMPUTER_ACCT_NAME
//
// MessageText:
//
// The name of the corresponding computer account doesn't match the Network Name for this resource.
//


//
// MessageId: ERROR_CLUSTER_NO_NET_ADAPTERS
//
// MessageText:
//
// No network adapters are available.
//


//
// MessageId: ERROR_CLUSTER_POISONED
//
// MessageText:
//
// The cluster node has been poisoned.
//


//
// MessageId: ERROR_CLUSTER_GROUP_MOVING
//
// MessageText:
//
// The group is unable to accept the request since it is moving to another node.
//


//
// MessageId: ERROR_CLUSTER_RESOURCE_TYPE_BUSY
//
// MessageText:
//
// The resource type cannot accept the request since is too busy performing another operation.
//


//
// MessageId: ERROR_RESOURCE_CALL_TIMED_OUT
//
// MessageText:
//
// The call to the cluster resource DLL timed out.
//


//
// MessageId: ERROR_INVALID_CLUSTER_IPV6_ADDRESS
//
// MessageText:
//
// The address is not valid for an IPv6 Address resource. A global IPv6 address is required, and it must match a cluster network. Compatibility addresses are not permitted.
//


//
// MessageId: ERROR_CLUSTER_INTERNAL_INVALID_FUNCTION
//
// MessageText:
//
// An internal cluster error occurred. A call to an invalid function was attempted.
//


//
// MessageId: ERROR_CLUSTER_PARAMETER_OUT_OF_BOUNDS
//
// MessageText:
//
// A parameter value is out of acceptable range.
//


//
// MessageId: ERROR_CLUSTER_PARTIAL_SEND
//
// MessageText:
//
// A network error occurred while sending data to another node in the cluster. The number of bytes transmitted was less than required.
//


//
// MessageId: ERROR_CLUSTER_REGISTRY_INVALID_FUNCTION
//
// MessageText:
//
// An invalid cluster registry operation was attempted.
//


//
// MessageId: ERROR_CLUSTER_INVALID_STRING_TERMINATION
//
// MessageText:
//
// An input string of characters is not properly terminated.
//


//
// MessageId: ERROR_CLUSTER_INVALID_STRING_FORMAT
//
// MessageText:
//
// An input string of characters is not in a valid format for the data it represents.
//


//
// MessageId: ERROR_CLUSTER_DATABASE_TRANSACTION_IN_PROGRESS
//
// MessageText:
//
// An internal cluster error occurred. A cluster database transaction was attempted while a transaction was already in progress.
//


//
// MessageId: ERROR_CLUSTER_DATABASE_TRANSACTION_NOT_IN_PROGRESS
//
// MessageText:
//
// An internal cluster error occurred. There was an attempt to commit a cluster database transaction while no transaction was in progress.
//


//
// MessageId: ERROR_CLUSTER_NULL_DATA
//
// MessageText:
//
// An internal cluster error occurred. Data was not properly initialized.
//


//
// MessageId: ERROR_CLUSTER_PARTIAL_READ
//
// MessageText:
//
// An error occurred while reading from a stream of data. An unexpected number of bytes was returned.
//


//
// MessageId: ERROR_CLUSTER_PARTIAL_WRITE
//
// MessageText:
//
// An error occurred while writing to a stream of data. The required number of bytes could not be written.
//


//
// MessageId: ERROR_CLUSTER_CANT_DESERIALIZE_DATA
//
// MessageText:
//
// An error occurred while deserializing a stream of cluster data.
//


//
// MessageId: ERROR_DEPENDENT_RESOURCE_PROPERTY_CONFLICT
//
// MessageText:
//
// One or more property values for this resource are in conflict with one or more property values associated with its dependent resource(s).
//


//
// MessageId: ERROR_CLUSTER_NO_QUORUM
//
// MessageText:
//
// A quorum of cluster nodes was not present to form a cluster.
//


//
// MessageId: ERROR_CLUSTER_INVALID_IPV6_NETWORK
//
// MessageText:
//
// The cluster network is not valid for an IPv6 Address resource, or it does not match the configured address.
//


//
// MessageId: ERROR_CLUSTER_INVALID_IPV6_TUNNEL_NETWORK
//
// MessageText:
//
// The cluster network is not valid for an IPv6 Tunnel resource. Check the configuration of the IP Address resource on which the IPv6 Tunnel resource depends.
//


//
// MessageId: ERROR_QUORUM_NOT_ALLOWED_IN_THIS_GROUP
//
// MessageText:
//
// Quorum resource cannot reside in the Available Storage group.
//


//
// MessageId: ERROR_DEPENDENCY_TREE_TOO_COMPLEX
//
// MessageText:
//
// The dependencies for this resource are nested too deeply.
//


//
// MessageId: ERROR_EXCEPTION_IN_RESOURCE_CALL
//
// MessageText:
//
// The call into the resource DLL raised an unhandled exception.
//


//
// MessageId: ERROR_CLUSTER_RHS_FAILED_INITIALIZATION
//
// MessageText:
//
// The RHS process failed to initialize.
//


//
// MessageId: ERROR_CLUSTER_NOT_INSTALLED
//
// MessageText:
//
// The Failover Clustering feature is not installed on this node.
//


//
// MessageId: ERROR_CLUSTER_RESOURCES_MUST_BE_ONLINE_ON_THE_SAME_NODE
//
// MessageText:
//
// The resources must be online on the same node for this operation
//


//
// MessageId: ERROR_CLUSTER_MAX_NODES_IN_CLUSTER
//
// MessageText:
//
// A new node can not be added since this cluster is already at its maximum number of nodes.
//


//
// MessageId: ERROR_CLUSTER_TOO_MANY_NODES
//
// MessageText:
//
// This cluster can not be created since the specified number of nodes exceeds the maximum allowed limit.
//


//
// MessageId: ERROR_CLUSTER_OBJECT_ALREADY_USED
//
// MessageText:
//
// An attempt to use the specified cluster name failed because an enabled computer object with the given name already exists in the domain.
//


//
// MessageId: ERROR_NONCORE_GROUPS_FOUND
//
// MessageText:
//
// This cluster cannot be destroyed. It has non-core application groups which must be deleted before the cluster can be destroyed.
//


//
// MessageId: ERROR_FILE_SHARE_RESOURCE_CONFLICT
//
// MessageText:
//
// File share associated with file share witness resource cannot be hosted by this cluster or any of its nodes.
//


//
// MessageId: ERROR_CLUSTER_EVICT_INVALID_REQUEST
//
// MessageText:
//
// Eviction of this node is invalid at this time. Due to quorum requirements node eviction will result in cluster shutdown.
// If it is the last node in the cluster, destroy cluster command should be used.
//


//
// MessageId: ERROR_CLUSTER_SINGLETON_RESOURCE
//
// MessageText:
//
// Only one instance of this resource type is allowed in the cluster.
//


//
// MessageId: ERROR_CLUSTER_GROUP_SINGLETON_RESOURCE
//
// MessageText:
//
// Only one instance of this resource type is allowed per resource group.
//


//
// MessageId: ERROR_CLUSTER_RESOURCE_PROVIDER_FAILED
//
// MessageText:
//
// The resource failed to come online due to the failure of one or more provider resources.
//


//
// MessageId: ERROR_CLUSTER_RESOURCE_CONFIGURATION_ERROR
//
// MessageText:
//
// The resource has indicated that it cannot come online on any node.
//


//
// MessageId: ERROR_CLUSTER_GROUP_BUSY
//
// MessageText:
//
// The current operation cannot be performed on this group at this time.
//


//
// MessageId: ERROR_CLUSTER_NOT_SHARED_VOLUME
//
// MessageText:
//
// The directory or file is not located on a cluster shared volume.
//


//
// MessageId: ERROR_CLUSTER_INVALID_SECURITY_DESCRIPTOR
//
// MessageText:
//
// The Security Descriptor does not meet the requirements for a cluster.
//


//
// MessageId: ERROR_CLUSTER_SHARED_VOLUMES_IN_USE
//
// MessageText:
//
// There is one or more shared volumes resources configured in the cluster.
// Those resources must be moved to available storage in order for operation to succeed.
//


//
// MessageId: ERROR_CLUSTER_USE_SHARED_VOLUMES_API
//
// MessageText:
//
// This group or resource cannot be directly manipulated.
// Use shared volume APIs to perform desired operation.
//


//
// MessageId: ERROR_CLUSTER_BACKUP_IN_PROGRESS
//
// MessageText:
//
// Back up is in progress. Please wait for backup completion before trying this operation again.
//


//
// MessageId: ERROR_NON_CSV_PATH
//
// MessageText:
//
// The path does not belong to a cluster shared volume.
//


//
// MessageId: ERROR_CSV_VOLUME_NOT_LOCAL
//
// MessageText:
//
// The cluster shared volume is not locally mounted on this node.
//


//
// MessageId: ERROR_CLUSTER_WATCHDOG_TERMINATING
//
// MessageText:
//
// The cluster watchdog is terminating.
//


//
// MessageId: ERROR_CLUSTER_RESOURCE_VETOED_MOVE_INCOMPATIBLE_NODES
//
// MessageText:
//
// A resource vetoed a move between two nodes because they are incompatible.
//


//
// MessageId: ERROR_CLUSTER_INVALID_NODE_WEIGHT
//
// MessageText:
//
// The request is invalid either because node weight cannot be changed while the cluster is in disk-only quorum mode, or because changing the node weight would violate the minimum cluster quorum requirements.
//


//
// MessageId: ERROR_CLUSTER_RESOURCE_VETOED_CALL
//
// MessageText:
//
// The resource vetoed the call.
//


//
// MessageId: ERROR_RESMON_SYSTEM_RESOURCES_LACKING
//
// MessageText:
//
// Resource could not start or run because it could not reserve sufficient system resources.
//


//
// MessageId: ERROR_CLUSTER_RESOURCE_VETOED_MOVE_NOT_ENOUGH_RESOURCES_ON_DESTINATION
//
// MessageText:
//
// A resource vetoed a move between two nodes because the destination currently does not have enough resources to complete the operation.
//


//
// MessageId: ERROR_CLUSTER_RESOURCE_VETOED_MOVE_NOT_ENOUGH_RESOURCES_ON_SOURCE
//
// MessageText:
//
// 
// A resource vetoed a move between two nodes because the source currently does not have enough resources to complete the operation.
//


//
// MessageId: ERROR_CLUSTER_GROUP_QUEUED
//
// MessageText:
//
// 
// The requested operation can not be completed because the group is queued for an operation.
//


//
// MessageId: ERROR_CLUSTER_RESOURCE_LOCKED_STATUS
//
// MessageText:
//
// 
// The requested operation can not be completed because a resource has locked status.
//


//
// MessageId: ERROR_CLUSTER_SHARED_VOLUME_FAILOVER_NOT_ALLOWED
//
// MessageText:
//
// 
// The resource cannot move to another node because a cluster shared volume vetoed the operation.
//


//
// MessageId: ERROR_CLUSTER_NODE_DRAIN_IN_PROGRESS
//
// MessageText:
//
// 
// A node drain is already in progress.
//


//
// MessageId: ERROR_CLUSTER_DISK_NOT_CONNECTED
//
// MessageText:
//
// 
// Clustered storage is not connected to the node.
//


//
// MessageId: ERROR_DISK_NOT_CSV_CAPABLE
//
// MessageText:
//
// 
// The disk is not configured in a way to be used with CSV. CSV disks must have at least one partition that is formatted with NTFS or REFS.
//


//
// MessageId: ERROR_RESOURCE_NOT_IN_AVAILABLE_STORAGE
//
// MessageText:
//
// 
// The resource must be part of the Available Storage group to complete this action.
//


//
// MessageId: ERROR_CLUSTER_SHARED_VOLUME_REDIRECTED
//
// MessageText:
//
// 
// CSVFS failed operation as volume is in redirected mode.
//


//
// MessageId: ERROR_CLUSTER_SHARED_VOLUME_NOT_REDIRECTED
//
// MessageText:
//
// 
// CSVFS failed operation as volume is not in redirected mode.
//


//
// MessageId: ERROR_CLUSTER_CANNOT_RETURN_PROPERTIES
//
// MessageText:
//
// 
// Cluster properties cannot be returned at this time.
//


//
// MessageId: ERROR_CLUSTER_RESOURCE_CONTAINS_UNSUPPORTED_DIFF_AREA_FOR_SHARED_VOLUMES
//
// MessageText:
//
// 
// The clustered disk resource contains software snapshot diff area that are not supported for Cluster Shared Volumes.
//


//
// MessageId: ERROR_CLUSTER_RESOURCE_IS_IN_MAINTENANCE_MODE
//
// MessageText:
//
// 
// The operation cannot be completed because the resource is in maintenance mode.
//


//
// MessageId: ERROR_CLUSTER_AFFINITY_CONFLICT
//
// MessageText:
//
// 
// The operation cannot be completed because of cluster affinity conflicts
//


//
// MessageId: ERROR_CLUSTER_RESOURCE_IS_REPLICA_VIRTUAL_MACHINE
//
// MessageText:
//
// 
// The operation cannot be completed because the resource is a replica virtual machine.
//


//
// MessageId: ERROR_CLUSTER_UPGRADE_INCOMPATIBLE_VERSIONS
//
// MessageText:
//
// 
// The Cluster Functional Level could not be increased because not all nodes in the cluster support the updated version.
//


//
// MessageId: ERROR_CLUSTER_UPGRADE_FIX_QUORUM_NOT_SUPPORTED
//
// MessageText:
//
// 
// Updating the cluster functional level failed because the cluster is running in fix quorum mode.
// Start additional nodes which are members of the cluster until the cluster reaches quorum and the cluster will automatically
// switch out of fix quorum mode, or stop and restart the cluster without the FixQuorum switch. Once the cluster is out
// of fix quorum mode retry the Update-ClusterFunctionalLevel PowerShell cmdlet to update the cluster functional level.
//


//
// MessageId: ERROR_CLUSTER_UPGRADE_RESTART_REQUIRED
//
// MessageText:
//
// 
// The cluster functional level has been successfully updated but not all features are available yet. Restart the cluster by
// using the Stop-Cluster PowerShell cmdlet followed by the Start-Cluster PowerShell cmdlet and all cluster features will
// be available.
//


//
// MessageId: ERROR_CLUSTER_UPGRADE_IN_PROGRESS
//
// MessageText:
//
// 
// The cluster is currently performing a version upgrade.
//


//
// MessageId: ERROR_CLUSTER_UPGRADE_INCOMPLETE
//
// MessageText:
//
// 
// The cluster did not successfully complete the version upgrade.
//


//
// MessageId: ERROR_CLUSTER_NODE_IN_GRACE_PERIOD
//
// MessageText:
//
// 
// The cluster node is in grace period.
//


//
// MessageId: ERROR_CLUSTER_CSV_IO_PAUSE_TIMEOUT
//
// MessageText:
//
// 
// The operation has failed because CSV volume was not able to recover in time specified on this file object.
//


//
// MessageId: ERROR_NODE_NOT_ACTIVE_CLUSTER_MEMBER
//
// MessageText:
//
// 
// The operation failed because the requested node is not currently part of active cluster membership.
//


//
// MessageId: ERROR_CLUSTER_RESOURCE_NOT_MONITORED
//
// MessageText:
//
// 
// The operation failed because the requested cluster resource is currently unmonitored.
//


//
// MessageId: ERROR_CLUSTER_RESOURCE_DOES_NOT_SUPPORT_UNMONITORED
//
// MessageText:
//
// 
// The operation failed because a resource does not support running in an unmonitored state.
//


//
// MessageId: ERROR_CLUSTER_RESOURCE_IS_REPLICATED
//
// MessageText:
//
// 
// The operation cannot be completed because a resource participates in replication.
//


//
// MessageId: ERROR_CLUSTER_NODE_ISOLATED
//
// MessageText:
//
// 
// The operation failed because the requested cluster node has been isolated
//


//
// MessageId: ERROR_CLUSTER_NODE_QUARANTINED
//
// MessageText:
//
// 
// The operation failed because the requested cluster node has been quarantined
//


//
// MessageId: ERROR_CLUSTER_DATABASE_UPDATE_CONDITION_FAILED
//
// MessageText:
//
// 
// The operation failed because the specified database update condition was not met
//


//
// MessageId: ERROR_CLUSTER_SPACE_DEGRADED
//
// MessageText:
//
// 
// A clustered space is in a degraded condition and the requested action cannot be completed at this time.
//


//
// MessageId: ERROR_CLUSTER_TOKEN_DELEGATION_NOT_SUPPORTED
//
// MessageText:
//
// 
// The operation failed because token delegation for this control is not supported.
//


//
// MessageId: ERROR_CLUSTER_CSV_INVALID_HANDLE
//
// MessageText:
//
// 
// The operation has failed because CSV has invalidated this file object.
//


//
// MessageId: ERROR_CLUSTER_CSV_SUPPORTED_ONLY_ON_COORDINATOR
//
// MessageText:
//
// 
// This operation is supported only on the CSV coordinator node.
//


//
// MessageId: ERROR_GROUPSET_NOT_AVAILABLE
//
// MessageText:
//
// 
// The cluster group set is not available for any further requests.
//


//
// MessageId: ERROR_GROUPSET_NOT_FOUND
//
// MessageText:
//
// 
// The cluster group set could not be found.
//


//
// MessageId: ERROR_GROUPSET_CANT_PROVIDE
//
// MessageText:
//
// 
// The action cannot be completed at this time because the cluster group set would fall below quorum and not be able to act as a provider.
//


//
// MessageId: ERROR_CLUSTER_FAULT_DOMAIN_PARENT_NOT_FOUND
//
// MessageText:
//
// 
// The specified parent fault domain is not found.
//


//
// MessageId: ERROR_CLUSTER_FAULT_DOMAIN_INVALID_HIERARCHY
//
// MessageText:
//
// 
// The fault domain cannot be a child of the parent specified.
//


//
// MessageId: ERROR_CLUSTER_FAULT_DOMAIN_FAILED_S2D_VALIDATION
//
// MessageText:
//
// 
// Storage Spaces Direct has rejected the proposed fault domain changes because it impacts the fault tolerance of the storage.
//


//
// MessageId: ERROR_CLUSTER_FAULT_DOMAIN_S2D_CONNECTIVITY_LOSS
//
// MessageText:
//
// 
// Storage Spaces Direct has rejected the proposed fault domain changes because it reduces the storage connected to the system.
//


//
// MessageId: ERROR_CLUSTER_INVALID_INFRASTRUCTURE_FILESERVER_NAME
//
// MessageText:
//
// 
// Cluster infrastructure file server creation failed because a valid non-empty file server name was not provided.
//


//
// MessageId: ERROR_CLUSTERSET_MANAGEMENT_CLUSTER_UNREACHABLE
//
// MessageText:
//
// 
// The action cannot be completed because the cluster set management cluster is unreachable.
//



///////////////////////////////////////////////////
//                                               //
//               EFS Error codes                 //
//                                               //
//                 6000 to 6099                  //
///////////////////////////////////////////////////

//
// MessageId: ERROR_ENCRYPTION_FAILED
//
// MessageText:
//
// The specified file could not be encrypted.
//


//
// MessageId: ERROR_DECRYPTION_FAILED
//
// MessageText:
//
// The specified file could not be decrypted.
//


//
// MessageId: ERROR_FILE_ENCRYPTED
//
// MessageText:
//
// The specified file is encrypted and the user does not have the ability to decrypt it.
//


//
// MessageId: ERROR_NO_RECOVERY_POLICY
//
// MessageText:
//
// There is no valid encryption recovery policy configured for this system.
//


//
// MessageId: ERROR_NO_EFS
//
// MessageText:
//
// The required encryption driver is not loaded for this system.
//


//
// MessageId: ERROR_WRONG_EFS
//
// MessageText:
//
// The file was encrypted with a different encryption driver than is currently loaded.
//


//
// MessageId: ERROR_NO_USER_KEYS
//
// MessageText:
//
// There are no EFS keys defined for the user.
//


//
// MessageId: ERROR_FILE_NOT_ENCRYPTED
//
// MessageText:
//
// The specified file is not encrypted.
//


//
// MessageId: ERROR_NOT_EXPORT_FORMAT
//
// MessageText:
//
// The specified file is not in the defined EFS export format.
//


//
// MessageId: ERROR_FILE_READ_ONLY
//
// MessageText:
//
// The specified file is read only.
//


//
// MessageId: ERROR_DIR_EFS_DISALLOWED
//
// MessageText:
//
// The directory has been disabled for encryption.
//


//
// MessageId: ERROR_EFS_SERVER_NOT_TRUSTED
//
// MessageText:
//
// The server is not trusted for remote encryption operation.
//


//
// MessageId: ERROR_BAD_RECOVERY_POLICY
//
// MessageText:
//
// Recovery policy configured for this system contains invalid recovery certificate.
//


//
// MessageId: ERROR_EFS_ALG_BLOB_TOO_BIG
//
// MessageText:
//
// The encryption algorithm used on the source file needs a bigger key buffer than the one on the destination file.
//


//
// MessageId: ERROR_VOLUME_NOT_SUPPORT_EFS
//
// MessageText:
//
// The disk partition does not support file encryption.
//


//
// MessageId: ERROR_EFS_DISABLED
//
// MessageText:
//
// This machine is disabled for file encryption.
//


//
// MessageId: ERROR_EFS_VERSION_NOT_SUPPORT
//
// MessageText:
//
// A newer system is required to decrypt this encrypted file.
//


//
// MessageId: ERROR_CS_ENCRYPTION_INVALID_SERVER_RESPONSE
//
// MessageText:
//
// The remote server sent an invalid response for a file being opened with Client Side Encryption.
//


//
// MessageId: ERROR_CS_ENCRYPTION_UNSUPPORTED_SERVER
//
// MessageText:
//
// Client Side Encryption is not supported by the remote server even though it claims to support it.
//


//
// MessageId: ERROR_CS_ENCRYPTION_EXISTING_ENCRYPTED_FILE
//
// MessageText:
//
// File is encrypted and should be opened in Client Side Encryption mode.
//


//
// MessageId: ERROR_CS_ENCRYPTION_NEW_ENCRYPTED_FILE
//
// MessageText:
//
// A new encrypted file is being created and a $EFS needs to be provided.
//


//
// MessageId: ERROR_CS_ENCRYPTION_FILE_NOT_CSE
//
// MessageText:
//
// The SMB client requested a CSE FSCTL on a non-CSE file.
//


//
// MessageId: ERROR_ENCRYPTION_POLICY_DENIES_OPERATION
//
// MessageText:
//
// The requested operation was blocked by policy. For more information, contact your system administrator.
//


//
// MessageId: ERROR_WIP_ENCRYPTION_FAILED
//
// MessageText:
//
// The specified file could not be encrypted with Windows Information Protection.
//



///////////////////////////////////////////////////
//                                               //
//              BROWSER Error codes              //
//                                               //
//                 6100 to 6199                  //
///////////////////////////////////////////////////

// This message number is for historical purposes and cannot be changed or re-used.
//
// MessageId: ERROR_NO_BROWSER_SERVERS_FOUND
//
// MessageText:
//
// The list of servers for this workgroup is not currently available
//



///////////////////////////////////////////////////
//                                               //
//            Task Scheduler Error codes         //
//            NET START must understand          //
//                                               //
//                 6200 to 6249                  //
///////////////////////////////////////////////////

//
// MessageId: SCHED_E_SERVICE_NOT_LOCALSYSTEM
//
// MessageText:
//
// The Task Scheduler service must be configured to run in the System account to function properly. Individual tasks may be configured to run in other accounts.
//



///////////////////////////////////////////////////
//                                               //
//                  Available                    //
//                                               //
//                 6250 to 6599                  //
///////////////////////////////////////////////////

///////////////////////////////////////////////////
//                                               //
//         Common Log (CLFS) Error codes         //
//                                               //
//                 6600 to 6699                  //
///////////////////////////////////////////////////

//
// MessageId: ERROR_LOG_SECTOR_INVALID
//
// MessageText:
//
// Log service encountered an invalid log sector.
//


//
// MessageId: ERROR_LOG_SECTOR_PARITY_INVALID
//
// MessageText:
//
// Log service encountered a log sector with invalid block parity.
//


//
// MessageId: ERROR_LOG_SECTOR_REMAPPED
//
// MessageText:
//
// Log service encountered a remapped log sector.
//


//
// MessageId: ERROR_LOG_BLOCK_INCOMPLETE
//
// MessageText:
//
// Log service encountered a partial or incomplete log block.
//


//
// MessageId: ERROR_LOG_INVALID_RANGE
//
// MessageText:
//
// Log service encountered an attempt access data outside the active log range.
//


//
// MessageId: ERROR_LOG_BLOCKS_EXHAUSTED
//
// MessageText:
//
// Log service user marshalling buffers are exhausted.
//


//
// MessageId: ERROR_LOG_READ_CONTEXT_INVALID
//
// MessageText:
//
// Log service encountered an attempt read from a marshalling area with an invalid read context.
//


//
// MessageId: ERROR_LOG_RESTART_INVALID
//
// MessageText:
//
// Log service encountered an invalid log restart area.
//


//
// MessageId: ERROR_LOG_BLOCK_VERSION
//
// MessageText:
//
// Log service encountered an invalid log block version.
//


//
// MessageId: ERROR_LOG_BLOCK_INVALID
//
// MessageText:
//
// Log service encountered an invalid log block.
//


//
// MessageId: ERROR_LOG_READ_MODE_INVALID
//
// MessageText:
//
// Log service encountered an attempt to read the log with an invalid read mode.
//


//
// MessageId: ERROR_LOG_NO_RESTART
//
// MessageText:
//
// Log service encountered a log stream with no restart area.
//


//
// MessageId: ERROR_LOG_METADATA_CORRUPT
//
// MessageText:
//
// Log service encountered a corrupted metadata file.
//


//
// MessageId: ERROR_LOG_METADATA_INVALID
//
// MessageText:
//
// Log service encountered a metadata file that could not be created by the log file system.
//


//
// MessageId: ERROR_LOG_METADATA_INCONSISTENT
//
// MessageText:
//
// Log service encountered a metadata file with inconsistent data.
//


//
// MessageId: ERROR_LOG_RESERVATION_INVALID
//
// MessageText:
//
// Log service encountered an attempt to erroneous allocate or dispose reservation space.
//


//
// MessageId: ERROR_LOG_CANT_DELETE
//
// MessageText:
//
// Log service cannot delete log file or file system container.
//


//
// MessageId: ERROR_LOG_CONTAINER_LIMIT_EXCEEDED
//
// MessageText:
//
// Log service has reached the maximum allowable containers allocated to a log file.
//


//
// MessageId: ERROR_LOG_START_OF_LOG
//
// MessageText:
//
// Log service has attempted to read or write backward past the start of the log.
//


//
// MessageId: ERROR_LOG_POLICY_ALREADY_INSTALLED
//
// MessageText:
//
// Log policy could not be installed because a policy of the same type is already present.
//


//
// MessageId: ERROR_LOG_POLICY_NOT_INSTALLED
//
// MessageText:
//
// Log policy in question was not installed at the time of the request.
//


//
// MessageId: ERROR_LOG_POLICY_INVALID
//
// MessageText:
//
// The installed set of policies on the log is invalid.
//


//
// MessageId: ERROR_LOG_POLICY_CONFLICT
//
// MessageText:
//
// A policy on the log in question prevented the operation from completing.
//


//
// MessageId: ERROR_LOG_PINNED_ARCHIVE_TAIL
//
// MessageText:
//
// Log space cannot be reclaimed because the log is pinned by the archive tail.
//


//
// MessageId: ERROR_LOG_RECORD_NONEXISTENT
//
// MessageText:
//
// Log record is not a record in the log file.
//


//
// MessageId: ERROR_LOG_RECORDS_RESERVED_INVALID
//
// MessageText:
//
// Number of reserved log records or the adjustment of the number of reserved log records is invalid.
//


//
// MessageId: ERROR_LOG_SPACE_RESERVED_INVALID
//
// MessageText:
//
// Reserved log space or the adjustment of the log space is invalid.
//


//
// MessageId: ERROR_LOG_TAIL_INVALID
//
// MessageText:
//
// An new or existing archive tail or base of the active log is invalid.
//


//
// MessageId: ERROR_LOG_FULL
//
// MessageText:
//
// Log space is exhausted.
//


//
// MessageId: ERROR_COULD_NOT_RESIZE_LOG
//
// MessageText:
//
// The log could not be set to the requested size.
//


//
// MessageId: ERROR_LOG_MULTIPLEXED
//
// MessageText:
//
// Log is multiplexed, no direct writes to the physical log is allowed.
//


//
// MessageId: ERROR_LOG_DEDICATED
//
// MessageText:
//
// The operation failed because the log is a dedicated log.
//


//
// MessageId: ERROR_LOG_ARCHIVE_NOT_IN_PROGRESS
//
// MessageText:
//
// The operation requires an archive context.
//


//
// MessageId: ERROR_LOG_ARCHIVE_IN_PROGRESS
//
// MessageText:
//
// Log archival is in progress.
//


//
// MessageId: ERROR_LOG_EPHEMERAL
//
// MessageText:
//
// The operation requires a non-ephemeral log, but the log is ephemeral.
//


//
// MessageId: ERROR_LOG_NOT_ENOUGH_CONTAINERS
//
// MessageText:
//
// The log must have at least two containers before it can be read from or written to.
//


//
// MessageId: ERROR_LOG_CLIENT_ALREADY_REGISTERED
//
// MessageText:
//
// A log client has already registered on the stream.
//


//
// MessageId: ERROR_LOG_CLIENT_NOT_REGISTERED
//
// MessageText:
//
// A log client has not been registered on the stream.
//


//
// MessageId: ERROR_LOG_FULL_HANDLER_IN_PROGRESS
//
// MessageText:
//
// A request has already been made to handle the log full condition.
//


//
// MessageId: ERROR_LOG_CONTAINER_READ_FAILED
//
// MessageText:
//
// Log service encountered an error when attempting to read from a log container.
//


//
// MessageId: ERROR_LOG_CONTAINER_WRITE_FAILED
//
// MessageText:
//
// Log service encountered an error when attempting to write to a log container.
//


//
// MessageId: ERROR_LOG_CONTAINER_OPEN_FAILED
//
// MessageText:
//
// Log service encountered an error when attempting open a log container.
//


//
// MessageId: ERROR_LOG_CONTAINER_STATE_INVALID
//
// MessageText:
//
// Log service encountered an invalid container state when attempting a requested action.
//


//
// MessageId: ERROR_LOG_STATE_INVALID
//
// MessageText:
//
// Log service is not in the correct state to perform a requested action.
//


//
// MessageId: ERROR_LOG_PINNED
//
// MessageText:
//
// Log space cannot be reclaimed because the log is pinned.
//


//
// MessageId: ERROR_LOG_METADATA_FLUSH_FAILED
//
// MessageText:
//
// Log metadata flush failed.
//


//
// MessageId: ERROR_LOG_INCONSISTENT_SECURITY
//
// MessageText:
//
// Security on the log and its containers is inconsistent.
//


//
// MessageId: ERROR_LOG_APPENDED_FLUSH_FAILED
//
// MessageText:
//
// Records were appended to the log or reservation changes were made, but the log could not be flushed.
//


//
// MessageId: ERROR_LOG_PINNED_RESERVATION
//
// MessageText:
//
// The log is pinned due to reservation consuming most of the log space. Free some reserved records to make space available.
//



///////////////////////////////////////////////////
//                                               //
//           Transaction (KTM) Error codes       //
//                                               //
//                 6700 to 6799                  //
///////////////////////////////////////////////////

//
// MessageId: ERROR_INVALID_TRANSACTION
//
// MessageText:
//
// The transaction handle associated with this operation is not valid.
//


//
// MessageId: ERROR_TRANSACTION_NOT_ACTIVE
//
// MessageText:
//
// The requested operation was made in the context of a transaction that is no longer active.
//


//
// MessageId: ERROR_TRANSACTION_REQUEST_NOT_VALID
//
// MessageText:
//
// The requested operation is not valid on the Transaction object in its current state.
//


//
// MessageId: ERROR_TRANSACTION_NOT_REQUESTED
//
// MessageText:
//
// The caller has called a response API, but the response is not expected because the TM did not issue the corresponding request to the caller.
//


//
// MessageId: ERROR_TRANSACTION_ALREADY_ABORTED
//
// MessageText:
//
// It is too late to perform the requested operation, since the Transaction has already been aborted.
//


//
// MessageId: ERROR_TRANSACTION_ALREADY_COMMITTED
//
// MessageText:
//
// It is too late to perform the requested operation, since the Transaction has already been committed.
//


//
// MessageId: ERROR_TM_INITIALIZATION_FAILED
//
// MessageText:
//
// The Transaction Manager was unable to be successfully initialized. Transacted operations are not supported.
//


//
// MessageId: ERROR_RESOURCEMANAGER_READ_ONLY
//
// MessageText:
//
// The specified ResourceManager made no changes or updates to the resource under this transaction.
//


//
// MessageId: ERROR_TRANSACTION_NOT_JOINED
//
// MessageText:
//
// The resource manager has attempted to prepare a transaction that it has not successfully joined.
//


//
// MessageId: ERROR_TRANSACTION_SUPERIOR_EXISTS
//
// MessageText:
//
// The Transaction object already has a superior enlistment, and the caller attempted an operation that would have created a new superior. Only a single superior enlistment is allow.
//


//
// MessageId: ERROR_CRM_PROTOCOL_ALREADY_EXISTS
//
// MessageText:
//
// The RM tried to register a protocol that already exists.
//


//
// MessageId: ERROR_TRANSACTION_PROPAGATION_FAILED
//
// MessageText:
//
// The attempt to propagate the Transaction failed.
//


//
// MessageId: ERROR_CRM_PROTOCOL_NOT_FOUND
//
// MessageText:
//
// The requested propagation protocol was not registered as a CRM.
//


//
// MessageId: ERROR_TRANSACTION_INVALID_MARSHALL_BUFFER
//
// MessageText:
//
// The buffer passed in to PushTransaction or PullTransaction is not in a valid format.
//


//
// MessageId: ERROR_CURRENT_TRANSACTION_NOT_VALID
//
// MessageText:
//
// The current transaction context associated with the thread is not a valid handle to a transaction object.
//


//
// MessageId: ERROR_TRANSACTION_NOT_FOUND
//
// MessageText:
//
// The specified Transaction object could not be opened, because it was not found.
//


//
// MessageId: ERROR_RESOURCEMANAGER_NOT_FOUND
//
// MessageText:
//
// The specified ResourceManager object could not be opened, because it was not found.
//


//
// MessageId: ERROR_ENLISTMENT_NOT_FOUND
//
// MessageText:
//
// The specified Enlistment object could not be opened, because it was not found.
//


//
// MessageId: ERROR_TRANSACTIONMANAGER_NOT_FOUND
//
// MessageText:
//
// The specified TransactionManager object could not be opened, because it was not found.
//


//
// MessageId: ERROR_TRANSACTIONMANAGER_NOT_ONLINE
//
// MessageText:
//
// The object specified could not be created or opened, because its associated TransactionManager is not online.  The TransactionManager must be brought fully Online by calling RecoverTransactionManager to recover to the end of its LogFile before objects in its Transaction or ResourceManager namespaces can be opened.  In addition, errors in writing records to its LogFile can cause a TransactionManager to go offline.
//


//
// MessageId: ERROR_TRANSACTIONMANAGER_RECOVERY_NAME_COLLISION
//
// MessageText:
//
// The specified TransactionManager was unable to create the objects contained in its logfile in the Ob namespace. Therefore, the TransactionManager was unable to recover.
//


//
// MessageId: ERROR_TRANSACTION_NOT_ROOT
//
// MessageText:
//
// The call to create a superior Enlistment on this Transaction object could not be completed, because the Transaction object specified for the enlistment is a subordinate branch of the Transaction. Only the root of the Transaction can be enlisted on as a superior.
//


//
// MessageId: ERROR_TRANSACTION_OBJECT_EXPIRED
//
// MessageText:
//
// Because the associated transaction manager or resource manager has been closed, the handle is no longer valid.
//


//
// MessageId: ERROR_TRANSACTION_RESPONSE_NOT_ENLISTED
//
// MessageText:
//
// The specified operation could not be performed on this Superior enlistment, because the enlistment was not created with the corresponding completion response in the NotificationMask.
//


//
// MessageId: ERROR_TRANSACTION_RECORD_TOO_LONG
//
// MessageText:
//
// The specified operation could not be performed, because the record that would be logged was too long. This can occur because of two conditions: either there are too many Enlistments on this Transaction, or the combined RecoveryInformation being logged on behalf of those Enlistments is too long.
//


//
// MessageId: ERROR_IMPLICIT_TRANSACTION_NOT_SUPPORTED
//
// MessageText:
//
// Implicit transaction are not supported.
//


//
// MessageId: ERROR_TRANSACTION_INTEGRITY_VIOLATED
//
// MessageText:
//
// The kernel transaction manager had to abort or forget the transaction because it blocked forward progress.
//


//
// MessageId: ERROR_TRANSACTIONMANAGER_IDENTITY_MISMATCH
//
// MessageText:
//
// The TransactionManager identity that was supplied did not match the one recorded in the TransactionManager's log file.
//


//
// MessageId: ERROR_RM_CANNOT_BE_FROZEN_FOR_SNAPSHOT
//
// MessageText:
//
// This snapshot operation cannot continue because a transactional resource manager cannot be frozen in its current state.  Please try again.
//


//
// MessageId: ERROR_TRANSACTION_MUST_WRITETHROUGH
//
// MessageText:
//
// The transaction cannot be enlisted on with the specified EnlistmentMask, because the transaction has already completed the PrePrepare phase.  In order to ensure correctness, the ResourceManager must switch to a write-through mode and cease caching data within this transaction.  Enlisting for only subsequent transaction phases may still succeed.
//


//
// MessageId: ERROR_TRANSACTION_NO_SUPERIOR
//
// MessageText:
//
// The transaction does not have a superior enlistment.
//


//
// MessageId: ERROR_HEURISTIC_DAMAGE_POSSIBLE
//
// MessageText:
//
// The attempt to commit the Transaction completed, but it is possible that some portion of the transaction tree did not commit successfully due to heuristics.  Therefore it is possible that some data modified in the transaction may not have committed, resulting in transactional inconsistency.  If possible, check the consistency of the associated data.
//



///////////////////////////////////////////////////
//                                               //
//        Transactional File Services (TxF)      //
//                  Error codes                  //
//                                               //
//                 6800 to 6899                  //
///////////////////////////////////////////////////

//
// MessageId: ERROR_TRANSACTIONAL_CONFLICT
//
// MessageText:
//
// The function attempted to use a name that is reserved for use by another transaction.
//


//
// MessageId: ERROR_RM_NOT_ACTIVE
//
// MessageText:
//
// Transaction support within the specified resource manager is not started or was shut down due to an error.
//


//
// MessageId: ERROR_RM_METADATA_CORRUPT
//
// MessageText:
//
// The metadata of the RM has been corrupted. The RM will not function.
//


//
// MessageId: ERROR_DIRECTORY_NOT_RM
//
// MessageText:
//
// The specified directory does not contain a resource manager.
//


//
// MessageId: ERROR_TRANSACTIONS_UNSUPPORTED_REMOTE
//
// MessageText:
//
// The remote server or share does not support transacted file operations.
//


//
// MessageId: ERROR_LOG_RESIZE_INVALID_SIZE
//
// MessageText:
//
// The requested log size is invalid.
//


//
// MessageId: ERROR_OBJECT_NO_LONGER_EXISTS
//
// MessageText:
//
// The object (file, stream, link) corresponding to the handle has been deleted by a Transaction Savepoint Rollback.
//


//
// MessageId: ERROR_STREAM_MINIVERSION_NOT_FOUND
//
// MessageText:
//
// The specified file miniversion was not found for this transacted file open.
//


//
// MessageId: ERROR_STREAM_MINIVERSION_NOT_VALID
//
// MessageText:
//
// The specified file miniversion was found but has been invalidated. Most likely cause is a transaction savepoint rollback.
//


//
// MessageId: ERROR_MINIVERSION_INACCESSIBLE_FROM_SPECIFIED_TRANSACTION
//
// MessageText:
//
// A miniversion may only be opened in the context of the transaction that created it.
//


//
// MessageId: ERROR_CANT_OPEN_MINIVERSION_WITH_MODIFY_INTENT
//
// MessageText:
//
// It is not possible to open a miniversion with modify access.
//


//
// MessageId: ERROR_CANT_CREATE_MORE_STREAM_MINIVERSIONS
//
// MessageText:
//
// It is not possible to create any more miniversions for this stream.
//


//
// MessageId: ERROR_REMOTE_FILE_VERSION_MISMATCH
//
// MessageText:
//
// The remote server sent mismatching version number or Fid for a file opened with transactions.
//


//
// MessageId: ERROR_HANDLE_NO_LONGER_VALID
//
// MessageText:
//
// The handle has been invalidated by a transaction. The most likely cause is the presence of memory mapping on a file or an open handle when the transaction ended or rolled back to savepoint.
//


//
// MessageId: ERROR_NO_TXF_METADATA
//
// MessageText:
//
// There is no transaction metadata on the file.
//


//
// MessageId: ERROR_LOG_CORRUPTION_DETECTED
//
// MessageText:
//
// The log data is corrupt.
//


//
// MessageId: ERROR_CANT_RECOVER_WITH_HANDLE_OPEN
//
// MessageText:
//
// The file can't be recovered because there is a handle still open on it.
//


//
// MessageId: ERROR_RM_DISCONNECTED
//
// MessageText:
//
// The transaction outcome is unavailable because the resource manager responsible for it has disconnected.
//


//
// MessageId: ERROR_ENLISTMENT_NOT_SUPERIOR
//
// MessageText:
//
// The request was rejected because the enlistment in question is not a superior enlistment.
//


//
// MessageId: ERROR_RECOVERY_NOT_NEEDED
//
// MessageText:
//
// The transactional resource manager is already consistent. Recovery is not needed.
//


//
// MessageId: ERROR_RM_ALREADY_STARTED
//
// MessageText:
//
// The transactional resource manager has already been started.
//


//
// MessageId: ERROR_FILE_IDENTITY_NOT_PERSISTENT
//
// MessageText:
//
// The file cannot be opened transactionally, because its identity depends on the outcome of an unresolved transaction.
//


//
// MessageId: ERROR_CANT_BREAK_TRANSACTIONAL_DEPENDENCY
//
// MessageText:
//
// The operation cannot be performed because another transaction is depending on the fact that this property will not change.
//


//
// MessageId: ERROR_CANT_CROSS_RM_BOUNDARY
//
// MessageText:
//
// The operation would involve a single file with two transactional resource managers and is therefore not allowed.
//


//
// MessageId: ERROR_TXF_DIR_NOT_EMPTY
//
// MessageText:
//
// The $Txf directory must be empty for this operation to succeed.
//


//
// MessageId: ERROR_INDOUBT_TRANSACTIONS_EXIST
//
// MessageText:
//
// The operation would leave a transactional resource manager in an inconsistent state and is therefore not allowed.
//


//
// MessageId: ERROR_TM_VOLATILE
//
// MessageText:
//
// The operation could not be completed because the transaction manager does not have a log.
//


//
// MessageId: ERROR_ROLLBACK_TIMER_EXPIRED
//
// MessageText:
//
// A rollback could not be scheduled because a previously scheduled rollback has already executed or been queued for execution.
//


//
// MessageId: ERROR_TXF_ATTRIBUTE_CORRUPT
//
// MessageText:
//
// The transactional metadata attribute on the file or directory is corrupt and unreadable.
//


//
// MessageId: ERROR_EFS_NOT_ALLOWED_IN_TRANSACTION
//
// MessageText:
//
// The encryption operation could not be completed because a transaction is active.
//


//
// MessageId: ERROR_TRANSACTIONAL_OPEN_NOT_ALLOWED
//
// MessageText:
//
// This object is not allowed to be opened in a transaction.
//


//
// MessageId: ERROR_LOG_GROWTH_FAILED
//
// MessageText:
//
// An attempt to create space in the transactional resource manager's log failed. The failure status has been recorded in the event log.
//


//
// MessageId: ERROR_TRANSACTED_MAPPING_UNSUPPORTED_REMOTE
//
// MessageText:
//
// Memory mapping (creating a mapped section) a remote file under a transaction is not supported.
//


//
// MessageId: ERROR_TXF_METADATA_ALREADY_PRESENT
//
// MessageText:
//
// Transaction metadata is already present on this file and cannot be superseded.
//


//
// MessageId: ERROR_TRANSACTION_SCOPE_CALLBACKS_NOT_SET
//
// MessageText:
//
// A transaction scope could not be entered because the scope handler has not been initialized.
//


//
// MessageId: ERROR_TRANSACTION_REQUIRED_PROMOTION
//
// MessageText:
//
// Promotion was required in order to allow the resource manager to enlist, but the transaction was set to disallow it.
//


//
// MessageId: ERROR_CANNOT_EXECUTE_FILE_IN_TRANSACTION
//
// MessageText:
//
// This file is open for modification in an unresolved transaction and may be opened for execute only by a transacted reader.
//


//
// MessageId: ERROR_TRANSACTIONS_NOT_FROZEN
//
// MessageText:
//
// The request to thaw frozen transactions was ignored because transactions had not previously been frozen.
//


//
// MessageId: ERROR_TRANSACTION_FREEZE_IN_PROGRESS
//
// MessageText:
//
// Transactions cannot be frozen because a freeze is already in progress.
//


//
// MessageId: ERROR_NOT_SNAPSHOT_VOLUME
//
// MessageText:
//
// The target volume is not a snapshot volume. This operation is only valid on a volume mounted as a snapshot.
//


//
// MessageId: ERROR_NO_SAVEPOINT_WITH_OPEN_FILES
//
// MessageText:
//
// The savepoint operation failed because files are open on the transaction. This is not permitted.
//


//
// MessageId: ERROR_DATA_LOST_REPAIR
//
// MessageText:
//
// Windows has discovered corruption in a file, and that file has since been repaired. Data loss may have occurred.
//


//
// MessageId: ERROR_SPARSE_NOT_ALLOWED_IN_TRANSACTION
//
// MessageText:
//
// The sparse operation could not be completed because a transaction is active on the file.
//


//
// MessageId: ERROR_TM_IDENTITY_MISMATCH
//
// MessageText:
//
// The call to create a TransactionManager object failed because the Tm Identity stored in the logfile does not match the Tm Identity that was passed in as an argument.
//


//
// MessageId: ERROR_FLOATED_SECTION
//
// MessageText:
//
// I/O was attempted on a section object that has been floated as a result of a transaction ending. There is no valid data.
//


//
// MessageId: ERROR_CANNOT_ACCEPT_TRANSACTED_WORK
//
// MessageText:
//
// The transactional resource manager cannot currently accept transacted work due to a transient condition such as low resources.
//


//
// MessageId: ERROR_CANNOT_ABORT_TRANSACTIONS
//
// MessageText:
//
// The transactional resource manager had too many transactions outstanding that could not be aborted. The transactional resource manger has been shut down.
//


//
// MessageId: ERROR_BAD_CLUSTERS
//
// MessageText:
//
// The operation could not be completed due to bad clusters on disk.
//


//
// MessageId: ERROR_COMPRESSION_NOT_ALLOWED_IN_TRANSACTION
//
// MessageText:
//
// The compression operation could not be completed because a transaction is active on the file.
//


//
// MessageId: ERROR_VOLUME_DIRTY
//
// MessageText:
//
// The operation could not be completed because the volume is dirty. Please run chkdsk and try again.
//


//
// MessageId: ERROR_NO_LINK_TRACKING_IN_TRANSACTION
//
// MessageText:
//
// The link tracking operation could not be completed because a transaction is active.
//


//
// MessageId: ERROR_OPERATION_NOT_SUPPORTED_IN_TRANSACTION
//
// MessageText:
//
// This operation cannot be performed in a transaction.
//


//
// MessageId: ERROR_EXPIRED_HANDLE
//
// MessageText:
//
// The handle is no longer properly associated with its transaction.  It may have been opened in a transactional resource manager that was subsequently forced to restart.  Please close the handle and open a new one.
//


//
// MessageId: ERROR_TRANSACTION_NOT_ENLISTED
//
// MessageText:
//
// The specified operation could not be performed because the resource manager is not enlisted in the transaction.
//



///////////////////////////////////////////////////
//                                               //
//                  Available                    //
//                                               //
//                 6900 to 6999                  //
///////////////////////////////////////////////////

///////////////////////////////////////////////////
//                                               //
//          Terminal Server Error codes          //
//                                               //
//                 7000 to 7099                  //
///////////////////////////////////////////////////

//
// MessageId: ERROR_CTX_WINSTATION_NAME_INVALID
//
// MessageText:
//
// The specified session name is invalid.
//


//
// MessageId: ERROR_CTX_INVALID_PD
//
// MessageText:
//
// The specified protocol driver is invalid.
//


//
// MessageId: ERROR_CTX_PD_NOT_FOUND
//
// MessageText:
//
// The specified protocol driver was not found in the system path.
//


//
// MessageId: ERROR_CTX_WD_NOT_FOUND
//
// MessageText:
//
// The specified terminal connection driver was not found in the system path.
//


//
// MessageId: ERROR_CTX_CANNOT_MAKE_EVENTLOG_ENTRY
//
// MessageText:
//
// A registry key for event logging could not be created for this session.
//


//
// MessageId: ERROR_CTX_SERVICE_NAME_COLLISION
//
// MessageText:
//
// A service with the same name already exists on the system.
//


//
// MessageId: ERROR_CTX_CLOSE_PENDING
//
// MessageText:
//
// A close operation is pending on the session.
//


//
// MessageId: ERROR_CTX_NO_OUTBUF
//
// MessageText:
//
// There are no free output buffers available.
//


//
// MessageId: ERROR_CTX_MODEM_INF_NOT_FOUND
//
// MessageText:
//
// The MODEM.INF file was not found.
//


//
// MessageId: ERROR_CTX_INVALID_MODEMNAME
//
// MessageText:
//
// The modem name was not found in MODEM.INF.
//


//
// MessageId: ERROR_CTX_MODEM_RESPONSE_ERROR
//
// MessageText:
//
// The modem did not accept the command sent to it. Verify that the configured modem name matches the attached modem.
//


//
// MessageId: ERROR_CTX_MODEM_RESPONSE_TIMEOUT
//
// MessageText:
//
// The modem did not respond to the command sent to it. Verify that the modem is properly cabled and powered on.
//


//
// MessageId: ERROR_CTX_MODEM_RESPONSE_NO_CARRIER
//
// MessageText:
//
// Carrier detect has failed or carrier has been dropped due to disconnect.
//


//
// MessageId: ERROR_CTX_MODEM_RESPONSE_NO_DIALTONE
//
// MessageText:
//
// Dial tone not detected within the required time. Verify that the phone cable is properly attached and functional.
//


//
// MessageId: ERROR_CTX_MODEM_RESPONSE_BUSY
//
// MessageText:
//
// Busy signal detected at remote site on callback.
//


//
// MessageId: ERROR_CTX_MODEM_RESPONSE_VOICE
//
// MessageText:
//
// Voice detected at remote site on callback.
//


//
// MessageId: ERROR_CTX_TD_ERROR
//
// MessageText:
//
// Transport driver error
//


//
// MessageId: ERROR_CTX_WINSTATION_NOT_FOUND
//
// MessageText:
//
// The specified session cannot be found.
//


//
// MessageId: ERROR_CTX_WINSTATION_ALREADY_EXISTS
//
// MessageText:
//
// The specified session name is already in use.
//


//
// MessageId: ERROR_CTX_WINSTATION_BUSY
//
// MessageText:
//
// The task you are trying to do can't be completed because Remote Desktop Services is currently busy. Please try again in a few minutes. Other users should still be able to log on.
//


//
// MessageId: ERROR_CTX_BAD_VIDEO_MODE
//
// MessageText:
//
// An attempt has been made to connect to a session whose video mode is not supported by the current client.
//


//
// MessageId: ERROR_CTX_GRAPHICS_INVALID
//
// MessageText:
//
// The application attempted to enable DOS graphics mode. DOS graphics mode is not supported.
//


//
// MessageId: ERROR_CTX_LOGON_DISABLED
//
// MessageText:
//
// Your interactive logon privilege has been disabled. Please contact your administrator.
//


//
// MessageId: ERROR_CTX_NOT_CONSOLE
//
// MessageText:
//
// The requested operation can be performed only on the system console. This is most often the result of a driver or system DLL requiring direct console access.
//


//
// MessageId: ERROR_CTX_CLIENT_QUERY_TIMEOUT
//
// MessageText:
//
// The client failed to respond to the server connect message.
//


//
// MessageId: ERROR_CTX_CONSOLE_DISCONNECT
//
// MessageText:
//
// Disconnecting the console session is not supported.
//


//
// MessageId: ERROR_CTX_CONSOLE_CONNECT
//
// MessageText:
//
// Reconnecting a disconnected session to the console is not supported.
//


//
// MessageId: ERROR_CTX_SHADOW_DENIED
//
// MessageText:
//
// The request to control another session remotely was denied.
//


//
// MessageId: ERROR_CTX_WINSTATION_ACCESS_DENIED
//
// MessageText:
//
// The requested session access is denied.
//


//
// MessageId: ERROR_CTX_INVALID_WD
//
// MessageText:
//
// The specified terminal connection driver is invalid.
//


//
// MessageId: ERROR_CTX_SHADOW_INVALID
//
// MessageText:
//
// The requested session cannot be controlled remotely.
// This may be because the session is disconnected or does not currently have a user logged on.
//


//
// MessageId: ERROR_CTX_SHADOW_DISABLED
//
// MessageText:
//
// The requested session is not configured to allow remote control.
//


//
// MessageId: ERROR_CTX_CLIENT_LICENSE_IN_USE
//
// MessageText:
//
// Your request to connect to this Terminal Server has been rejected. Your Terminal Server client license number is currently being used by another user. Please call your system administrator to obtain a unique license number.
//


//
// MessageId: ERROR_CTX_CLIENT_LICENSE_NOT_SET
//
// MessageText:
//
// Your request to connect to this Terminal Server has been rejected. Your Terminal Server client license number has not been entered for this copy of the Terminal Server client. Please contact your system administrator.
//


//
// MessageId: ERROR_CTX_LICENSE_NOT_AVAILABLE
//
// MessageText:
//
// The number of connections to this computer is limited and all connections are in use right now. Try connecting later or contact your system administrator.
//


//
// MessageId: ERROR_CTX_LICENSE_CLIENT_INVALID
//
// MessageText:
//
// The client you are using is not licensed to use this system. Your logon request is denied.
//


//
// MessageId: ERROR_CTX_LICENSE_EXPIRED
//
// MessageText:
//
// The system license has expired. Your logon request is denied.
//


//
// MessageId: ERROR_CTX_SHADOW_NOT_RUNNING
//
// MessageText:
//
// Remote control could not be terminated because the specified session is not currently being remotely controlled.
//


//
// MessageId: ERROR_CTX_SHADOW_ENDED_BY_MODE_CHANGE
//
// MessageText:
//
// The remote control of the console was terminated because the display mode was changed. Changing the display mode in a remote control session is not supported.
//


//
// MessageId: ERROR_ACTIVATION_COUNT_EXCEEDED
//
// MessageText:
//
// Activation has already been reset the maximum number of times for this installation. Your activation timer will not be cleared.
//


//
// MessageId: ERROR_CTX_WINSTATIONS_DISABLED
//
// MessageText:
//
// Remote logins are currently disabled.
//


//
// MessageId: ERROR_CTX_ENCRYPTION_LEVEL_REQUIRED
//
// MessageText:
//
// You do not have the proper encryption level to access this Session.
//


//
// MessageId: ERROR_CTX_SESSION_IN_USE
//
// MessageText:
//
// The user %s\\%s is currently logged on to this computer. Only the current user or an administrator can log on to this computer.
//


//
// MessageId: ERROR_CTX_NO_FORCE_LOGOFF
//
// MessageText:
//
// The user %s\\%s is already logged on to the console of this computer. You do not have permission to log in at this time. To resolve this issue, contact %s\\%s and have them log off.
//


//
// MessageId: ERROR_CTX_ACCOUNT_RESTRICTION
//
// MessageText:
//
// Unable to log you on because of an account restriction.
//


//
// MessageId: ERROR_RDP_PROTOCOL_ERROR
//
// MessageText:
//
// The RDP protocol component %2 detected an error in the protocol stream and has disconnected the client.
//


//
// MessageId: ERROR_CTX_CDM_CONNECT
//
// MessageText:
//
// The Client Drive Mapping Service Has Connected on Terminal Connection.
//


//
// MessageId: ERROR_CTX_CDM_DISCONNECT
//
// MessageText:
//
// The Client Drive Mapping Service Has Disconnected on Terminal Connection.
//


//
// MessageId: ERROR_CTX_SECURITY_LAYER_ERROR
//
// MessageText:
//
// The Terminal Server security layer detected an error in the protocol stream and has disconnected the client.
//


//
// MessageId: ERROR_TS_INCOMPATIBLE_SESSIONS
//
// MessageText:
//
// The target session is incompatible with the current session.
//


//
// MessageId: ERROR_TS_VIDEO_SUBSYSTEM_ERROR
//
// MessageText:
//
// Windows can't connect to your session because a problem occurred in the Windows video subsystem. Try connecting again later, or contact the server administrator for assistance.
//


///////////////////////////////////////////////////
//                                               //
//          Windows Fabric Error Codes           //
//                                               //
//                 7100 to 7499                  //
//                                               //
//          defined in FabricCommon.idl          //
//                                               //
///////////////////////////////////////////////////


///////////////////////////////////////////////////
//                                                /
//           Traffic Control Error Codes          /
//                                                /
//                  7500 to 7999                  /
//                                                /
//            defined in: tcerror.h               /
///////////////////////////////////////////////////


///////////////////////////////////////////////////
//                                               //
//           Active Directory Error codes        //
//                                               //
//                 8000 to 8999                  //
///////////////////////////////////////////////////

// *****************
// FACILITY_FILE_REPLICATION_SERVICE
// *****************
//
// MessageId: FRS_ERR_INVALID_API_SEQUENCE
//
// MessageText:
//
// The file replication service API was called incorrectly.
//


//
// MessageId: FRS_ERR_STARTING_SERVICE
//
// MessageText:
//
// The file replication service cannot be started.
//


//
// MessageId: FRS_ERR_STOPPING_SERVICE
//
// MessageText:
//
// The file replication service cannot be stopped.
//


//
// MessageId: FRS_ERR_INTERNAL_API
//
// MessageText:
//
// The file replication service API terminated the request. The event log may have more information.
//


//
// MessageId: FRS_ERR_INTERNAL
//
// MessageText:
//
// The file replication service terminated the request. The event log may have more information.
//


//
// MessageId: FRS_ERR_SERVICE_COMM
//
// MessageText:
//
// The file replication service cannot be contacted. The event log may have more information.
//


//
// MessageId: FRS_ERR_INSUFFICIENT_PRIV
//
// MessageText:
//
// The file replication service cannot satisfy the request because the user has insufficient privileges. The event log may have more information.
//


//
// MessageId: FRS_ERR_AUTHENTICATION
//
// MessageText:
//
// The file replication service cannot satisfy the request because authenticated RPC is not available. The event log may have more information.
//


//
// MessageId: FRS_ERR_PARENT_INSUFFICIENT_PRIV
//
// MessageText:
//
// The file replication service cannot satisfy the request because the user has insufficient privileges on the domain controller. The event log may have more information.
//


//
// MessageId: FRS_ERR_PARENT_AUTHENTICATION
//
// MessageText:
//
// The file replication service cannot satisfy the request because authenticated RPC is not available on the domain controller. The event log may have more information.
//


//
// MessageId: FRS_ERR_CHILD_TO_PARENT_COMM
//
// MessageText:
//
// The file replication service cannot communicate with the file replication service on the domain controller. The event log may have more information.
//


//
// MessageId: FRS_ERR_PARENT_TO_CHILD_COMM
//
// MessageText:
//
// The file replication service on the domain controller cannot communicate with the file replication service on this computer. The event log may have more information.
//


//
// MessageId: FRS_ERR_SYSVOL_POPULATE
//
// MessageText:
//
// The file replication service cannot populate the system volume because of an internal error. The event log may have more information.
//


//
// MessageId: FRS_ERR_SYSVOL_POPULATE_TIMEOUT
//
// MessageText:
//
// The file replication service cannot populate the system volume because of an internal timeout. The event log may have more information.
//


//
// MessageId: FRS_ERR_SYSVOL_IS_BUSY
//
// MessageText:
//
// The file replication service cannot process the request. The system volume is busy with a previous request.
//


//
// MessageId: FRS_ERR_SYSVOL_DEMOTE
//
// MessageText:
//
// The file replication service cannot stop replicating the system volume because of an internal error. The event log may have more information.
//


//
// MessageId: FRS_ERR_INVALID_SERVICE_PARAMETER
//
// MessageText:
//
// The file replication service detected an invalid parameter.
//


// *****************
// FACILITY DIRECTORY SERVICE
// *****************

//
// MessageId: ERROR_DS_NOT_INSTALLED
//
// MessageText:
//
// An error occurred while installing the directory service. For more information, see the event log.
//


//
// MessageId: ERROR_DS_MEMBERSHIP_EVALUATED_LOCALLY
//
// MessageText:
//
// The directory service evaluated group memberships locally.
//


//
// MessageId: ERROR_DS_NO_ATTRIBUTE_OR_VALUE
//
// MessageText:
//
// The specified directory service attribute or value does not exist.
//


//
// MessageId: ERROR_DS_INVALID_ATTRIBUTE_SYNTAX
//
// MessageText:
//
// The attribute syntax specified to the directory service is invalid.
//


//
// MessageId: ERROR_DS_ATTRIBUTE_TYPE_UNDEFINED
//
// MessageText:
//
// The attribute type specified to the directory service is not defined.
//


//
// MessageId: ERROR_DS_ATTRIBUTE_OR_VALUE_EXISTS
//
// MessageText:
//
// The specified directory service attribute or value already exists.
//


//
// MessageId: ERROR_DS_BUSY
//
// MessageText:
//
// The directory service is busy.
//


//
// MessageId: ERROR_DS_UNAVAILABLE
//
// MessageText:
//
// The directory service is unavailable.
//


//
// MessageId: ERROR_DS_NO_RIDS_ALLOCATED
//
// MessageText:
//
// The directory service was unable to allocate a relative identifier.
//


//
// MessageId: ERROR_DS_NO_MORE_RIDS
//
// MessageText:
//
// The directory service has exhausted the pool of relative identifiers.
//


//
// MessageId: ERROR_DS_INCORRECT_ROLE_OWNER
//
// MessageText:
//
// The requested operation could not be performed because the directory service is not the master for that type of operation.
//


//
// MessageId: ERROR_DS_RIDMGR_INIT_ERROR
//
// MessageText:
//
// The directory service was unable to initialize the subsystem that allocates relative identifiers.
//


//
// MessageId: ERROR_DS_OBJ_CLASS_VIOLATION
//
// MessageText:
//
// The requested operation did not satisfy one or more constraints associated with the class of the object.
//


//
// MessageId: ERROR_DS_CANT_ON_NON_LEAF
//
// MessageText:
//
// The directory service can perform the requested operation only on a leaf object.
//


//
// MessageId: ERROR_DS_CANT_ON_RDN
//
// MessageText:
//
// The directory service cannot perform the requested operation on the RDN attribute of an object.
//


//
// MessageId: ERROR_DS_CANT_MOD_OBJ_CLASS
//
// MessageText:
//
// The directory service detected an attempt to modify the object class of an object.
//


//
// MessageId: ERROR_DS_CROSS_DOM_MOVE_ERROR
//
// MessageText:
//
// The requested cross-domain move operation could not be performed.
//


//
// MessageId: ERROR_DS_GC_NOT_AVAILABLE
//
// MessageText:
//
// Unable to contact the global catalog server.
//


//
// MessageId: ERROR_SHARED_POLICY
//
// MessageText:
//
// The policy object is shared and can only be modified at the root.
//


//
// MessageId: ERROR_POLICY_OBJECT_NOT_FOUND
//
// MessageText:
//
// The policy object does not exist.
//


//
// MessageId: ERROR_POLICY_ONLY_IN_DS
//
// MessageText:
//
// The requested policy information is only in the directory service.
//


//
// MessageId: ERROR_PROMOTION_ACTIVE
//
// MessageText:
//
// A domain controller promotion is currently active.
//


//
// MessageId: ERROR_NO_PROMOTION_ACTIVE
//
// MessageText:
//
// A domain controller promotion is not currently active
//


// 8223 unused
//
// MessageId: ERROR_DS_OPERATIONS_ERROR
//
// MessageText:
//
// An operations error occurred.
//


//
// MessageId: ERROR_DS_PROTOCOL_ERROR
//
// MessageText:
//
// A protocol error occurred.
//


//
// MessageId: ERROR_DS_TIMELIMIT_EXCEEDED
//
// MessageText:
//
// The time limit for this request was exceeded.
//


//
// MessageId: ERROR_DS_SIZELIMIT_EXCEEDED
//
// MessageText:
//
// The size limit for this request was exceeded.
//


//
// MessageId: ERROR_DS_ADMIN_LIMIT_EXCEEDED
//
// MessageText:
//
// The administrative limit for this request was exceeded.
//


//
// MessageId: ERROR_DS_COMPARE_FALSE
//
// MessageText:
//
// The compare response was false.
//


//
// MessageId: ERROR_DS_COMPARE_TRUE
//
// MessageText:
//
// The compare response was true.
//


//
// MessageId: ERROR_DS_AUTH_METHOD_NOT_SUPPORTED
//
// MessageText:
//
// The requested authentication method is not supported by the server.
//


//
// MessageId: ERROR_DS_STRONG_AUTH_REQUIRED
//
// MessageText:
//
// A more secure authentication method is required for this server.
//


//
// MessageId: ERROR_DS_INAPPROPRIATE_AUTH
//
// MessageText:
//
// Inappropriate authentication.
//


//
// MessageId: ERROR_DS_AUTH_UNKNOWN
//
// MessageText:
//
// The authentication mechanism is unknown.
//


//
// MessageId: ERROR_DS_REFERRAL
//
// MessageText:
//
// A referral was returned from the server.
//


//
// MessageId: ERROR_DS_UNAVAILABLE_CRIT_EXTENSION
//
// MessageText:
//
// The server does not support the requested critical extension.
//


//
// MessageId: ERROR_DS_CONFIDENTIALITY_REQUIRED
//
// MessageText:
//
// This request requires a secure connection.
//


//
// MessageId: ERROR_DS_INAPPROPRIATE_MATCHING
//
// MessageText:
//
// Inappropriate matching.
//


//
// MessageId: ERROR_DS_CONSTRAINT_VIOLATION
//
// MessageText:
//
// A constraint violation occurred.
//


//
// MessageId: ERROR_DS_NO_SUCH_OBJECT
//
// MessageText:
//
// There is no such object on the server.
//


//
// MessageId: ERROR_DS_ALIAS_PROBLEM
//
// MessageText:
//
// There is an alias problem.
//


//
// MessageId: ERROR_DS_INVALID_DN_SYNTAX
//
// MessageText:
//
// An invalid dn syntax has been specified.
//


//
// MessageId: ERROR_DS_IS_LEAF
//
// MessageText:
//
// The object is a leaf object.
//


//
// MessageId: ERROR_DS_ALIAS_DEREF_PROBLEM
//
// MessageText:
//
// There is an alias dereferencing problem.
//


//
// MessageId: ERROR_DS_UNWILLING_TO_PERFORM
//
// MessageText:
//
// The server is unwilling to process the request.
//


//
// MessageId: ERROR_DS_LOOP_DETECT
//
// MessageText:
//
// A loop has been detected.
//


//
// MessageId: ERROR_DS_NAMING_VIOLATION
//
// MessageText:
//
// There is a naming violation.
//


//
// MessageId: ERROR_DS_OBJECT_RESULTS_TOO_LARGE
//
// MessageText:
//
// The result set is too large.
//


//
// MessageId: ERROR_DS_AFFECTS_MULTIPLE_DSAS
//
// MessageText:
//
// The operation affects multiple DSAs
//


//
// MessageId: ERROR_DS_SERVER_DOWN
//
// MessageText:
//
// The server is not operational.
//


//
// MessageId: ERROR_DS_LOCAL_ERROR
//
// MessageText:
//
// A local error has occurred.
//


//
// MessageId: ERROR_DS_ENCODING_ERROR
//
// MessageText:
//
// An encoding error has occurred.
//


//
// MessageId: ERROR_DS_DECODING_ERROR
//
// MessageText:
//
// A decoding error has occurred.
//


//
// MessageId: ERROR_DS_FILTER_UNKNOWN
//
// MessageText:
//
// The search filter cannot be recognized.
//


//
// MessageId: ERROR_DS_PARAM_ERROR
//
// MessageText:
//
// One or more parameters are illegal.
//


//
// MessageId: ERROR_DS_NOT_SUPPORTED
//
// MessageText:
//
// The specified method is not supported.
//


//
// MessageId: ERROR_DS_NO_RESULTS_RETURNED
//
// MessageText:
//
// No results were returned.
//


//
// MessageId: ERROR_DS_CONTROL_NOT_FOUND
//
// MessageText:
//
// The specified control is not supported by the server.
//


//
// MessageId: ERROR_DS_CLIENT_LOOP
//
// MessageText:
//
// A referral loop was detected by the client.
//


//
// MessageId: ERROR_DS_REFERRAL_LIMIT_EXCEEDED
//
// MessageText:
//
// The preset referral limit was exceeded.
//


//
// MessageId: ERROR_DS_SORT_CONTROL_MISSING
//
// MessageText:
//
// The search requires a SORT control.
//


//
// MessageId: ERROR_DS_OFFSET_RANGE_ERROR
//
// MessageText:
//
// The search results exceed the offset range specified.
//


//
// MessageId: ERROR_DS_RIDMGR_DISABLED
//
// MessageText:
//
// The directory service detected the subsystem that allocates relative identifiers is disabled. This can occur as a protective mechanism when the system determines a significant portion of relative identifiers (RIDs) have been exhausted. Please see http://go.microsoft.com/fwlink/?LinkId=228610 for recommended diagnostic steps and the procedure to re-enable account creation.
//


//
// MessageId: ERROR_DS_ROOT_MUST_BE_NC
//
// MessageText:
//
// The root object must be the head of a naming context. The root object cannot have an instantiated parent.
//


//
// MessageId: ERROR_DS_ADD_REPLICA_INHIBITED
//
// MessageText:
//
// The add replica operation cannot be performed. The naming context must be writeable in order to create the replica.
//


//
// MessageId: ERROR_DS_ATT_NOT_DEF_IN_SCHEMA
//
// MessageText:
//
// A reference to an attribute that is not defined in the schema occurred.
//


//
// MessageId: ERROR_DS_MAX_OBJ_SIZE_EXCEEDED
//
// MessageText:
//
// The maximum size of an object has been exceeded.
//


//
// MessageId: ERROR_DS_OBJ_STRING_NAME_EXISTS
//
// MessageText:
//
// An attempt was made to add an object to the directory with a name that is already in use.
//


//
// MessageId: ERROR_DS_NO_RDN_DEFINED_IN_SCHEMA
//
// MessageText:
//
// An attempt was made to add an object of a class that does not have an RDN defined in the schema.
//


//
// MessageId: ERROR_DS_RDN_DOESNT_MATCH_SCHEMA
//
// MessageText:
//
// An attempt was made to add an object using an RDN that is not the RDN defined in the schema.
//


//
// MessageId: ERROR_DS_NO_REQUESTED_ATTS_FOUND
//
// MessageText:
//
// None of the requested attributes were found on the objects.
//


//
// MessageId: ERROR_DS_USER_BUFFER_TO_SMALL
//
// MessageText:
//
// The user buffer is too small.
//


//
// MessageId: ERROR_DS_ATT_IS_NOT_ON_OBJ
//
// MessageText:
//
// The attribute specified in the operation is not present on the object.
//


//
// MessageId: ERROR_DS_ILLEGAL_MOD_OPERATION
//
// MessageText:
//
// Illegal modify operation. Some aspect of the modification is not permitted.
//


//
// MessageId: ERROR_DS_OBJ_TOO_LARGE
//
// MessageText:
//
// The specified object is too large.
//


//
// MessageId: ERROR_DS_BAD_INSTANCE_TYPE
//
// MessageText:
//
// The specified instance type is not valid.
//


//
// MessageId: ERROR_DS_MASTERDSA_REQUIRED
//
// MessageText:
//
// The operation must be performed at a master DSA.
//


//
// MessageId: ERROR_DS_OBJECT_CLASS_REQUIRED
//
// MessageText:
//
// The object class attribute must be specified.
//


//
// MessageId: ERROR_DS_MISSING_REQUIRED_ATT
//
// MessageText:
//
// A required attribute is missing.
//


//
// MessageId: ERROR_DS_ATT_NOT_DEF_FOR_CLASS
//
// MessageText:
//
// An attempt was made to modify an object to include an attribute that is not legal for its class.
//


//
// MessageId: ERROR_DS_ATT_ALREADY_EXISTS
//
// MessageText:
//
// The specified attribute is already present on the object.
//


// 8319 unused
//
// MessageId: ERROR_DS_CANT_ADD_ATT_VALUES
//
// MessageText:
//
// The specified attribute is not present, or has no values.
//


//
// MessageId: ERROR_DS_SINGLE_VALUE_CONSTRAINT
//
// MessageText:
//
// Multiple values were specified for an attribute that can have only one value.
//


//
// MessageId: ERROR_DS_RANGE_CONSTRAINT
//
// MessageText:
//
// A value for the attribute was not in the acceptable range of values.
//


//
// MessageId: ERROR_DS_ATT_VAL_ALREADY_EXISTS
//
// MessageText:
//
// The specified value already exists.
//


//
// MessageId: ERROR_DS_CANT_REM_MISSING_ATT
//
// MessageText:
//
// The attribute cannot be removed because it is not present on the object.
//


//
// MessageId: ERROR_DS_CANT_REM_MISSING_ATT_VAL
//
// MessageText:
//
// The attribute value cannot be removed because it is not present on the object.
//


//
// MessageId: ERROR_DS_ROOT_CANT_BE_SUBREF
//
// MessageText:
//
// The specified root object cannot be a subref.
//


//
// MessageId: ERROR_DS_NO_CHAINING
//
// MessageText:
//
// Chaining is not permitted.
//


//
// MessageId: ERROR_DS_NO_CHAINED_EVAL
//
// MessageText:
//
// Chained evaluation is not permitted.
//


//
// MessageId: ERROR_DS_NO_PARENT_OBJECT
//
// MessageText:
//
// The operation could not be performed because the object's parent is either uninstantiated or deleted.
//


//
// MessageId: ERROR_DS_PARENT_IS_AN_ALIAS
//
// MessageText:
//
// Having a parent that is an alias is not permitted. Aliases are leaf objects.
//


//
// MessageId: ERROR_DS_CANT_MIX_MASTER_AND_REPS
//
// MessageText:
//
// The object and parent must be of the same type, either both masters or both replicas.
//


//
// MessageId: ERROR_DS_CHILDREN_EXIST
//
// MessageText:
//
// The operation cannot be performed because child objects exist. This operation can only be performed on a leaf object.
//


//
// MessageId: ERROR_DS_OBJ_NOT_FOUND
//
// MessageText:
//
// Directory object not found.
//


//
// MessageId: ERROR_DS_ALIASED_OBJ_MISSING
//
// MessageText:
//
// The aliased object is missing.
//


//
// MessageId: ERROR_DS_BAD_NAME_SYNTAX
//
// MessageText:
//
// The object name has bad syntax.
//


//
// MessageId: ERROR_DS_ALIAS_POINTS_TO_ALIAS
//
// MessageText:
//
// It is not permitted for an alias to refer to another alias.
//


//
// MessageId: ERROR_DS_CANT_DEREF_ALIAS
//
// MessageText:
//
// The alias cannot be dereferenced.
//


//
// MessageId: ERROR_DS_OUT_OF_SCOPE
//
// MessageText:
//
// The operation is out of scope.
//


//
// MessageId: ERROR_DS_OBJECT_BEING_REMOVED
//
// MessageText:
//
// The operation cannot continue because the object is in the process of being removed.
//


//
// MessageId: ERROR_DS_CANT_DELETE_DSA_OBJ
//
// MessageText:
//
// The DSA object cannot be deleted.
//


//
// MessageId: ERROR_DS_GENERIC_ERROR
//
// MessageText:
//
// A directory service error has occurred.
//


//
// MessageId: ERROR_DS_DSA_MUST_BE_INT_MASTER
//
// MessageText:
//
// The operation can only be performed on an internal master DSA object.
//


//
// MessageId: ERROR_DS_CLASS_NOT_DSA
//
// MessageText:
//
// The object must be of class DSA.
//


//
// MessageId: ERROR_DS_INSUFF_ACCESS_RIGHTS
//
// MessageText:
//
// Insufficient access rights to perform the operation.
//


//
// MessageId: ERROR_DS_ILLEGAL_SUPERIOR
//
// MessageText:
//
// The object cannot be added because the parent is not on the list of possible superiors.
//


//
// MessageId: ERROR_DS_ATTRIBUTE_OWNED_BY_SAM
//
// MessageText:
//
// Access to the attribute is not permitted because the attribute is owned by the Security Accounts Manager (SAM).
//


//
// MessageId: ERROR_DS_NAME_TOO_MANY_PARTS
//
// MessageText:
//
// The name has too many parts.
//


//
// MessageId: ERROR_DS_NAME_TOO_LONG
//
// MessageText:
//
// The name is too long.
//


//
// MessageId: ERROR_DS_NAME_VALUE_TOO_LONG
//
// MessageText:
//
// The name value is too long.
//


//
// MessageId: ERROR_DS_NAME_UNPARSEABLE
//
// MessageText:
//
// The directory service encountered an error parsing a name.
//


//
// MessageId: ERROR_DS_NAME_TYPE_UNKNOWN
//
// MessageText:
//
// The directory service cannot get the attribute type for a name.
//


//
// MessageId: ERROR_DS_NOT_AN_OBJECT
//
// MessageText:
//
// The name does not identify an object; the name identifies a phantom.
//


//
// MessageId: ERROR_DS_SEC_DESC_TOO_SHORT
//
// MessageText:
//
// The security descriptor is too short.
//


//
// MessageId: ERROR_DS_SEC_DESC_INVALID
//
// MessageText:
//
// The security descriptor is invalid.
//


//
// MessageId: ERROR_DS_NO_DELETED_NAME
//
// MessageText:
//
// Failed to create name for deleted object.
//


//
// MessageId: ERROR_DS_SUBREF_MUST_HAVE_PARENT
//
// MessageText:
//
// The parent of a new subref must exist.
//


//
// MessageId: ERROR_DS_NCNAME_MUST_BE_NC
//
// MessageText:
//
// The object must be a naming context.
//


//
// MessageId: ERROR_DS_CANT_ADD_SYSTEM_ONLY
//
// MessageText:
//
// It is not permitted to add an attribute which is owned by the system.
//


//
// MessageId: ERROR_DS_CLASS_MUST_BE_CONCRETE
//
// MessageText:
//
// The class of the object must be structural; you cannot instantiate an abstract class.
//


//
// MessageId: ERROR_DS_INVALID_DMD
//
// MessageText:
//
// The schema object could not be found.
//


//
// MessageId: ERROR_DS_OBJ_GUID_EXISTS
//
// MessageText:
//
// A local object with this GUID (dead or alive) already exists.
//


//
// MessageId: ERROR_DS_NOT_ON_BACKLINK
//
// MessageText:
//
// The operation cannot be performed on a back link.
//


//
// MessageId: ERROR_DS_NO_CROSSREF_FOR_NC
//
// MessageText:
//
// The cross reference for the specified naming context could not be found.
//


//
// MessageId: ERROR_DS_SHUTTING_DOWN
//
// MessageText:
//
// The operation could not be performed because the directory service is shutting down.
//


//
// MessageId: ERROR_DS_UNKNOWN_OPERATION
//
// MessageText:
//
// The directory service request is invalid.
//


//
// MessageId: ERROR_DS_INVALID_ROLE_OWNER
//
// MessageText:
//
// The role owner attribute could not be read.
//


//
// MessageId: ERROR_DS_COULDNT_CONTACT_FSMO
//
// MessageText:
//
// The requested FSMO operation failed. The current FSMO holder could not be contacted.
//


//
// MessageId: ERROR_DS_CROSS_NC_DN_RENAME
//
// MessageText:
//
// Modification of a DN across a naming context is not permitted.
//


//
// MessageId: ERROR_DS_CANT_MOD_SYSTEM_ONLY
//
// MessageText:
//
// The attribute cannot be modified because it is owned by the system.
//


//
// MessageId: ERROR_DS_REPLICATOR_ONLY
//
// MessageText:
//
// Only the replicator can perform this function.
//


//
// MessageId: ERROR_DS_OBJ_CLASS_NOT_DEFINED
//
// MessageText:
//
// The specified class is not defined.
//


//
// MessageId: ERROR_DS_OBJ_CLASS_NOT_SUBCLASS
//
// MessageText:
//
// The specified class is not a subclass.
//


//
// MessageId: ERROR_DS_NAME_REFERENCE_INVALID
//
// MessageText:
//
// The name reference is invalid.
//


//
// MessageId: ERROR_DS_CROSS_REF_EXISTS
//
// MessageText:
//
// A cross reference already exists.
//


//
// MessageId: ERROR_DS_CANT_DEL_MASTER_CROSSREF
//
// MessageText:
//
// It is not permitted to delete a master cross reference.
//


//
// MessageId: ERROR_DS_SUBTREE_NOTIFY_NOT_NC_HEAD
//
// MessageText:
//
// Subtree notifications are only supported on NC heads.
//


//
// MessageId: ERROR_DS_NOTIFY_FILTER_TOO_COMPLEX
//
// MessageText:
//
// Notification filter is too complex.
//


//
// MessageId: ERROR_DS_DUP_RDN
//
// MessageText:
//
// Schema update failed: duplicate RDN.
//


//
// MessageId: ERROR_DS_DUP_OID
//
// MessageText:
//
// Schema update failed: duplicate OID.
//


//
// MessageId: ERROR_DS_DUP_MAPI_ID
//
// MessageText:
//
// Schema update failed: duplicate MAPI identifier.
//


//
// MessageId: ERROR_DS_DUP_SCHEMA_ID_GUID
//
// MessageText:
//
// Schema update failed: duplicate schema-id GUID.
//


//
// MessageId: ERROR_DS_DUP_LDAP_DISPLAY_NAME
//
// MessageText:
//
// Schema update failed: duplicate LDAP display name.
//


//
// MessageId: ERROR_DS_SEMANTIC_ATT_TEST
//
// MessageText:
//
// Schema update failed: range-lower less than range upper.
//


//
// MessageId: ERROR_DS_SYNTAX_MISMATCH
//
// MessageText:
//
// Schema update failed: syntax mismatch.
//


//
// MessageId: ERROR_DS_EXISTS_IN_MUST_HAVE
//
// MessageText:
//
// Schema deletion failed: attribute is used in must-contain.
//


//
// MessageId: ERROR_DS_EXISTS_IN_MAY_HAVE
//
// MessageText:
//
// Schema deletion failed: attribute is used in may-contain.
//


//
// MessageId: ERROR_DS_NONEXISTENT_MAY_HAVE
//
// MessageText:
//
// Schema update failed: attribute in may-contain does not exist.
//


//
// MessageId: ERROR_DS_NONEXISTENT_MUST_HAVE
//
// MessageText:
//
// Schema update failed: attribute in must-contain does not exist.
//


//
// MessageId: ERROR_DS_AUX_CLS_TEST_FAIL
//
// MessageText:
//
// Schema update failed: class in aux-class list does not exist or is not an auxiliary class.
//


//
// MessageId: ERROR_DS_NONEXISTENT_POSS_SUP
//
// MessageText:
//
// Schema update failed: class in poss-superiors does not exist.
//


//
// MessageId: ERROR_DS_SUB_CLS_TEST_FAIL
//
// MessageText:
//
// Schema update failed: class in subclassof list does not exist or does not satisfy hierarchy rules.
//


//
// MessageId: ERROR_DS_BAD_RDN_ATT_ID_SYNTAX
//
// MessageText:
//
// Schema update failed: Rdn-Att-Id has wrong syntax.
//


//
// MessageId: ERROR_DS_EXISTS_IN_AUX_CLS
//
// MessageText:
//
// Schema deletion failed: class is used as auxiliary class.
//


//
// MessageId: ERROR_DS_EXISTS_IN_SUB_CLS
//
// MessageText:
//
// Schema deletion failed: class is used as sub class.
//


//
// MessageId: ERROR_DS_EXISTS_IN_POSS_SUP
//
// MessageText:
//
// Schema deletion failed: class is used as poss superior.
//


//
// MessageId: ERROR_DS_RECALCSCHEMA_FAILED
//
// MessageText:
//
// Schema update failed in recalculating validation cache.
//


//
// MessageId: ERROR_DS_TREE_DELETE_NOT_FINISHED
//
// MessageText:
//
// The tree deletion is not finished. The request must be made again to continue deleting the tree.
//


//
// MessageId: ERROR_DS_CANT_DELETE
//
// MessageText:
//
// The requested delete operation could not be performed.
//


//
// MessageId: ERROR_DS_ATT_SCHEMA_REQ_ID
//
// MessageText:
//
// Cannot read the governs class identifier for the schema record.
//


//
// MessageId: ERROR_DS_BAD_ATT_SCHEMA_SYNTAX
//
// MessageText:
//
// The attribute schema has bad syntax.
//


//
// MessageId: ERROR_DS_CANT_CACHE_ATT
//
// MessageText:
//
// The attribute could not be cached.
//


//
// MessageId: ERROR_DS_CANT_CACHE_CLASS
//
// MessageText:
//
// The class could not be cached.
//


//
// MessageId: ERROR_DS_CANT_REMOVE_ATT_CACHE
//
// MessageText:
//
// The attribute could not be removed from the cache.
//


//
// MessageId: ERROR_DS_CANT_REMOVE_CLASS_CACHE
//
// MessageText:
//
// The class could not be removed from the cache.
//


//
// MessageId: ERROR_DS_CANT_RETRIEVE_DN
//
// MessageText:
//
// The distinguished name attribute could not be read.
//


//
// MessageId: ERROR_DS_MISSING_SUPREF
//
// MessageText:
//
// No superior reference has been configured for the directory service. The directory service is therefore unable to issue referrals to objects outside this forest.
//


//
// MessageId: ERROR_DS_CANT_RETRIEVE_INSTANCE
//
// MessageText:
//
// The instance type attribute could not be retrieved.
//


//
// MessageId: ERROR_DS_CODE_INCONSISTENCY
//
// MessageText:
//
// An internal error has occurred.
//


//
// MessageId: ERROR_DS_DATABASE_ERROR
//
// MessageText:
//
// A database error has occurred.
//


//
// MessageId: ERROR_DS_GOVERNSID_MISSING
//
// MessageText:
//
// The attribute GOVERNSID is missing.
//


//
// MessageId: ERROR_DS_MISSING_EXPECTED_ATT
//
// MessageText:
//
// An expected attribute is missing.
//


//
// MessageId: ERROR_DS_NCNAME_MISSING_CR_REF
//
// MessageText:
//
// The specified naming context is missing a cross reference.
//


//
// MessageId: ERROR_DS_SECURITY_CHECKING_ERROR
//
// MessageText:
//
// A security checking error has occurred.
//


//
// MessageId: ERROR_DS_SCHEMA_NOT_LOADED
//
// MessageText:
//
// The schema is not loaded.
//


//
// MessageId: ERROR_DS_SCHEMA_ALLOC_FAILED
//
// MessageText:
//
// Schema allocation failed. Please check if the machine is running low on memory.
//


//
// MessageId: ERROR_DS_ATT_SCHEMA_REQ_SYNTAX
//
// MessageText:
//
// Failed to obtain the required syntax for the attribute schema.
//


//
// MessageId: ERROR_DS_GCVERIFY_ERROR
//
// MessageText:
//
// The global catalog verification failed. The global catalog is not available or does not support the operation. Some part of the directory is currently not available.
//


//
// MessageId: ERROR_DS_DRA_SCHEMA_MISMATCH
//
// MessageText:
//
// The replication operation failed because of a schema mismatch between the servers involved.
//


//
// MessageId: ERROR_DS_CANT_FIND_DSA_OBJ
//
// MessageText:
//
// The DSA object could not be found.
//


//
// MessageId: ERROR_DS_CANT_FIND_EXPECTED_NC
//
// MessageText:
//
// The naming context could not be found.
//


//
// MessageId: ERROR_DS_CANT_FIND_NC_IN_CACHE
//
// MessageText:
//
// The naming context could not be found in the cache.
//


//
// MessageId: ERROR_DS_CANT_RETRIEVE_CHILD
//
// MessageText:
//
// The child object could not be retrieved.
//


//
// MessageId: ERROR_DS_SECURITY_ILLEGAL_MODIFY
//
// MessageText:
//
// The modification was not permitted for security reasons.
//


//
// MessageId: ERROR_DS_CANT_REPLACE_HIDDEN_REC
//
// MessageText:
//
// The operation cannot replace the hidden record.
//


//
// MessageId: ERROR_DS_BAD_HIERARCHY_FILE
//
// MessageText:
//
// The hierarchy file is invalid.
//


//
// MessageId: ERROR_DS_BUILD_HIERARCHY_TABLE_FAILED
//
// MessageText:
//
// The attempt to build the hierarchy table failed.
//


//
// MessageId: ERROR_DS_CONFIG_PARAM_MISSING
//
// MessageText:
//
// The directory configuration parameter is missing from the registry.
//


//
// MessageId: ERROR_DS_COUNTING_AB_INDICES_FAILED
//
// MessageText:
//
// The attempt to count the address book indices failed.
//


//
// MessageId: ERROR_DS_HIERARCHY_TABLE_MALLOC_FAILED
//
// MessageText:
//
// The allocation of the hierarchy table failed.
//


//
// MessageId: ERROR_DS_INTERNAL_FAILURE
//
// MessageText:
//
// The directory service encountered an internal failure.
//


//
// MessageId: ERROR_DS_UNKNOWN_ERROR
//
// MessageText:
//
// The directory service encountered an unknown failure.
//


//
// MessageId: ERROR_DS_ROOT_REQUIRES_CLASS_TOP
//
// MessageText:
//
// A root object requires a class of 'top'.
//


//
// MessageId: ERROR_DS_REFUSING_FSMO_ROLES
//
// MessageText:
//
// This directory server is shutting down, and cannot take ownership of new floating single-master operation roles.
//


//
// MessageId: ERROR_DS_MISSING_FSMO_SETTINGS
//
// MessageText:
//
// The directory service is missing mandatory configuration information, and is unable to determine the ownership of floating single-master operation roles.
//


//
// MessageId: ERROR_DS_UNABLE_TO_SURRENDER_ROLES
//
// MessageText:
//
// The directory service was unable to transfer ownership of one or more floating single-master operation roles to other servers.
//


//
// MessageId: ERROR_DS_DRA_GENERIC
//
// MessageText:
//
// The replication operation failed.
//


//
// MessageId: ERROR_DS_DRA_INVALID_PARAMETER
//
// MessageText:
//
// An invalid parameter was specified for this replication operation.
//


//
// MessageId: ERROR_DS_DRA_BUSY
//
// MessageText:
//
// The directory service is too busy to complete the replication operation at this time.
//


//
// MessageId: ERROR_DS_DRA_BAD_DN
//
// MessageText:
//
// The distinguished name specified for this replication operation is invalid.
//


//
// MessageId: ERROR_DS_DRA_BAD_NC
//
// MessageText:
//
// The naming context specified for this replication operation is invalid.
//


//
// MessageId: ERROR_DS_DRA_DN_EXISTS
//
// MessageText:
//
// The distinguished name specified for this replication operation already exists.
//


//
// MessageId: ERROR_DS_DRA_INTERNAL_ERROR
//
// MessageText:
//
// The replication system encountered an internal error.
//


//
// MessageId: ERROR_DS_DRA_INCONSISTENT_DIT
//
// MessageText:
//
// The replication operation encountered a database inconsistency.
//


//
// MessageId: ERROR_DS_DRA_CONNECTION_FAILED
//
// MessageText:
//
// The server specified for this replication operation could not be contacted.
//


//
// MessageId: ERROR_DS_DRA_BAD_INSTANCE_TYPE
//
// MessageText:
//
// The replication operation encountered an object with an invalid instance type.
//


//
// MessageId: ERROR_DS_DRA_OUT_OF_MEM
//
// MessageText:
//
// The replication operation failed to allocate memory.
//


//
// MessageId: ERROR_DS_DRA_MAIL_PROBLEM
//
// MessageText:
//
// The replication operation encountered an error with the mail system.
//


//
// MessageId: ERROR_DS_DRA_REF_ALREADY_EXISTS
//
// MessageText:
//
// The replication reference information for the target server already exists.
//


//
// MessageId: ERROR_DS_DRA_REF_NOT_FOUND
//
// MessageText:
//
// The replication reference information for the target server does not exist.
//


//
// MessageId: ERROR_DS_DRA_OBJ_IS_REP_SOURCE
//
// MessageText:
//
// The naming context cannot be removed because it is replicated to another server.
//


//
// MessageId: ERROR_DS_DRA_DB_ERROR
//
// MessageText:
//
// The replication operation encountered a database error.
//


//
// MessageId: ERROR_DS_DRA_NO_REPLICA
//
// MessageText:
//
// The naming context is in the process of being removed or is not replicated from the specified server.
//


//
// MessageId: ERROR_DS_DRA_ACCESS_DENIED
//
// MessageText:
//
// Replication access was denied.
//


//
// MessageId: ERROR_DS_DRA_NOT_SUPPORTED
//
// MessageText:
//
// The requested operation is not supported by this version of the directory service.
//


//
// MessageId: ERROR_DS_DRA_RPC_CANCELLED
//
// MessageText:
//
// The replication remote procedure call was cancelled.
//


//
// MessageId: ERROR_DS_DRA_SOURCE_DISABLED
//
// MessageText:
//
// The source server is currently rejecting replication requests.
//


//
// MessageId: ERROR_DS_DRA_SINK_DISABLED
//
// MessageText:
//
// The destination server is currently rejecting replication requests.
//


//
// MessageId: ERROR_DS_DRA_NAME_COLLISION
//
// MessageText:
//
// The replication operation failed due to a collision of object names.
//


//
// MessageId: ERROR_DS_DRA_SOURCE_REINSTALLED
//
// MessageText:
//
// The replication source has been reinstalled.
//


//
// MessageId: ERROR_DS_DRA_MISSING_PARENT
//
// MessageText:
//
// The replication operation failed because a required parent object is missing.
//


//
// MessageId: ERROR_DS_DRA_PREEMPTED
//
// MessageText:
//
// The replication operation was preempted.
//


//
// MessageId: ERROR_DS_DRA_ABANDON_SYNC
//
// MessageText:
//
// The replication synchronization attempt was abandoned because of a lack of updates.
//


//
// MessageId: ERROR_DS_DRA_SHUTDOWN
//
// MessageText:
//
// The replication operation was terminated because the system is shutting down.
//


//
// MessageId: ERROR_DS_DRA_INCOMPATIBLE_PARTIAL_SET
//
// MessageText:
//
// Synchronization attempt failed because the destination DC is currently waiting to synchronize new partial attributes from source. This condition is normal if a recent schema change modified the partial attribute set. The destination partial attribute set is not a subset of source partial attribute set.
//


//
// MessageId: ERROR_DS_DRA_SOURCE_IS_PARTIAL_REPLICA
//
// MessageText:
//
// The replication synchronization attempt failed because a master replica attempted to sync from a partial replica.
//


//
// MessageId: ERROR_DS_DRA_EXTN_CONNECTION_FAILED
//
// MessageText:
//
// The server specified for this replication operation was contacted, but that server was unable to contact an additional server needed to complete the operation.
//


//
// MessageId: ERROR_DS_INSTALL_SCHEMA_MISMATCH
//
// MessageText:
//
// The version of the directory service schema of the source forest is not compatible with the version of directory service on this computer.
//


//
// MessageId: ERROR_DS_DUP_LINK_ID
//
// MessageText:
//
// Schema update failed: An attribute with the same link identifier already exists.
//


//
// MessageId: ERROR_DS_NAME_ERROR_RESOLVING
//
// MessageText:
//
// Name translation: Generic processing error.
//


//
// MessageId: ERROR_DS_NAME_ERROR_NOT_FOUND
//
// MessageText:
//
// Name translation: Could not find the name or insufficient right to see name.
//


//
// MessageId: ERROR_DS_NAME_ERROR_NOT_UNIQUE
//
// MessageText:
//
// Name translation: Input name mapped to more than one output name.
//


//
// MessageId: ERROR_DS_NAME_ERROR_NO_MAPPING
//
// MessageText:
//
// Name translation: Input name found, but not the associated output format.
//


//
// MessageId: ERROR_DS_NAME_ERROR_DOMAIN_ONLY
//
// MessageText:
//
// Name translation: Unable to resolve completely, only the domain was found.
//


//
// MessageId: ERROR_DS_NAME_ERROR_NO_SYNTACTICAL_MAPPING
//
// MessageText:
//
// Name translation: Unable to perform purely syntactical mapping at the client without going out to the wire.
//


//
// MessageId: ERROR_DS_CONSTRUCTED_ATT_MOD
//
// MessageText:
//
// Modification of a constructed attribute is not allowed.
//


//
// MessageId: ERROR_DS_WRONG_OM_OBJ_CLASS
//
// MessageText:
//
// The OM-Object-Class specified is incorrect for an attribute with the specified syntax.
//


//
// MessageId: ERROR_DS_DRA_REPL_PENDING
//
// MessageText:
//
// The replication request has been posted; waiting for reply.
//


//
// MessageId: ERROR_DS_DS_REQUIRED
//
// MessageText:
//
// The requested operation requires a directory service, and none was available.
//


//
// MessageId: ERROR_DS_INVALID_LDAP_DISPLAY_NAME
//
// MessageText:
//
// The LDAP display name of the class or attribute contains non-ASCII characters.
//


//
// MessageId: ERROR_DS_NON_BASE_SEARCH
//
// MessageText:
//
// The requested search operation is only supported for base searches.
//


//
// MessageId: ERROR_DS_CANT_RETRIEVE_ATTS
//
// MessageText:
//
// The search failed to retrieve attributes from the database.
//


//
// MessageId: ERROR_DS_BACKLINK_WITHOUT_LINK
//
// MessageText:
//
// The schema update operation tried to add a backward link attribute that has no corresponding forward link.
//


//
// MessageId: ERROR_DS_EPOCH_MISMATCH
//
// MessageText:
//
// Source and destination of a cross-domain move do not agree on the object's epoch number. Either source or destination does not have the latest version of the object.
//


//
// MessageId: ERROR_DS_SRC_NAME_MISMATCH
//
// MessageText:
//
// Source and destination of a cross-domain move do not agree on the object's current name. Either source or destination does not have the latest version of the object.
//


//
// MessageId: ERROR_DS_SRC_AND_DST_NC_IDENTICAL
//
// MessageText:
//
// Source and destination for the cross-domain move operation are identical. Caller should use local move operation instead of cross-domain move operation.
//


//
// MessageId: ERROR_DS_DST_NC_MISMATCH
//
// MessageText:
//
// Source and destination for a cross-domain move are not in agreement on the naming contexts in the forest. Either source or destination does not have the latest version of the Partitions container.
//


//
// MessageId: ERROR_DS_NOT_AUTHORITIVE_FOR_DST_NC
//
// MessageText:
//
// Destination of a cross-domain move is not authoritative for the destination naming context.
//


//
// MessageId: ERROR_DS_SRC_GUID_MISMATCH
//
// MessageText:
//
// Source and destination of a cross-domain move do not agree on the identity of the source object. Either source or destination does not have the latest version of the source object.
//


//
// MessageId: ERROR_DS_CANT_MOVE_DELETED_OBJECT
//
// MessageText:
//
// Object being moved across-domains is already known to be deleted by the destination server. The source server does not have the latest version of the source object.
//


//
// MessageId: ERROR_DS_PDC_OPERATION_IN_PROGRESS
//
// MessageText:
//
// Another operation which requires exclusive access to the PDC FSMO is already in progress.
//


//
// MessageId: ERROR_DS_CROSS_DOMAIN_CLEANUP_REQD
//
// MessageText:
//
// A cross-domain move operation failed such that two versions of the moved object exist - one each in the source and destination domains. The destination object needs to be removed to restore the system to a consistent state.
//


//
// MessageId: ERROR_DS_ILLEGAL_XDOM_MOVE_OPERATION
//
// MessageText:
//
// This object may not be moved across domain boundaries either because cross-domain moves for this class are disallowed, or the object has some special characteristics, e.g.: trust account or restricted RID, which prevent its move.
//


//
// MessageId: ERROR_DS_CANT_WITH_ACCT_GROUP_MEMBERSHPS
//
// MessageText:
//
// Can't move objects with memberships across domain boundaries as once moved, this would violate the membership conditions of the account group. Remove the object from any account group memberships and retry.
//


//
// MessageId: ERROR_DS_NC_MUST_HAVE_NC_PARENT
//
// MessageText:
//
// A naming context head must be the immediate child of another naming context head, not of an interior node.
//


//
// MessageId: ERROR_DS_CR_IMPOSSIBLE_TO_VALIDATE
//
// MessageText:
//
// The directory cannot validate the proposed naming context name because it does not hold a replica of the naming context above the proposed naming context. Please ensure that the domain naming master role is held by a server that is configured as a global catalog server, and that the server is up to date with its replication partners. (Applies only to Windows 2000 Domain Naming masters)
//


//
// MessageId: ERROR_DS_DST_DOMAIN_NOT_NATIVE
//
// MessageText:
//
// Destination domain must be in native mode.
//


//
// MessageId: ERROR_DS_MISSING_INFRASTRUCTURE_CONTAINER
//
// MessageText:
//
// The operation cannot be performed because the server does not have an infrastructure container in the domain of interest.
//


//
// MessageId: ERROR_DS_CANT_MOVE_ACCOUNT_GROUP
//
// MessageText:
//
// Cross-domain move of non-empty account groups is not allowed.
//


//
// MessageId: ERROR_DS_CANT_MOVE_RESOURCE_GROUP
//
// MessageText:
//
// Cross-domain move of non-empty resource groups is not allowed.
//


//
// MessageId: ERROR_DS_INVALID_SEARCH_FLAG
//
// MessageText:
//
// The search flags for the attribute are invalid. The ANR bit is valid only on attributes of Unicode or Teletex strings.
//


//
// MessageId: ERROR_DS_NO_TREE_DELETE_ABOVE_NC
//
// MessageText:
//
// Tree deletions starting at an object which has an NC head as a descendant are not allowed.
//


//
// MessageId: ERROR_DS_COULDNT_LOCK_TREE_FOR_DELETE
//
// MessageText:
//
// The directory service failed to lock a tree in preparation for a tree deletion because the tree was in use.
//


//
// MessageId: ERROR_DS_COULDNT_IDENTIFY_OBJECTS_FOR_TREE_DELETE
//
// MessageText:
//
// The directory service failed to identify the list of objects to delete while attempting a tree deletion.
//


//
// MessageId: ERROR_DS_SAM_INIT_FAILURE
//
// MessageText:
//
// Security Accounts Manager initialization failed because of the following error: %1.
// Error Status: 0x%2. Please shutdown this system and reboot into Directory Services Restore Mode, check the event log for more detailed information.
//


//
// MessageId: ERROR_DS_SENSITIVE_GROUP_VIOLATION
//
// MessageText:
//
// Only an administrator can modify the membership list of an administrative group.
//


//
// MessageId: ERROR_DS_CANT_MOD_PRIMARYGROUPID
//
// MessageText:
//
// Cannot change the primary group ID of a domain controller account.
//


//
// MessageId: ERROR_DS_ILLEGAL_BASE_SCHEMA_MOD
//
// MessageText:
//
// An attempt is made to modify the base schema.
//


//
// MessageId: ERROR_DS_NONSAFE_SCHEMA_CHANGE
//
// MessageText:
//
// Adding a new mandatory attribute to an existing class, deleting a mandatory attribute from an existing class, or adding an optional attribute to the special class Top that is not a backlink attribute (directly or through inheritance, for example, by adding or deleting an auxiliary class) is not allowed.
//


//
// MessageId: ERROR_DS_SCHEMA_UPDATE_DISALLOWED
//
// MessageText:
//
// Schema update is not allowed on this DC because the DC is not the schema FSMO Role Owner.
//


//
// MessageId: ERROR_DS_CANT_CREATE_UNDER_SCHEMA
//
// MessageText:
//
// An object of this class cannot be created under the schema container. You can only create attribute-schema and class-schema objects under the schema container.
//


//
// MessageId: ERROR_DS_INSTALL_NO_SRC_SCH_VERSION
//
// MessageText:
//
// The replica/child install failed to get the objectVersion attribute on the schema container on the source DC. Either the attribute is missing on the schema container or the credentials supplied do not have permission to read it.
//


//
// MessageId: ERROR_DS_INSTALL_NO_SCH_VERSION_IN_INIFILE
//
// MessageText:
//
// The replica/child install failed to read the objectVersion attribute in the SCHEMA section of the file schema.ini in the system32 directory.
//


//
// MessageId: ERROR_DS_INVALID_GROUP_TYPE
//
// MessageText:
//
// The specified group type is invalid.
//


//
// MessageId: ERROR_DS_NO_NEST_GLOBALGROUP_IN_MIXEDDOMAIN
//
// MessageText:
//
// You cannot nest global groups in a mixed domain if the group is security-enabled.
//


//
// MessageId: ERROR_DS_NO_NEST_LOCALGROUP_IN_MIXEDDOMAIN
//
// MessageText:
//
// You cannot nest local groups in a mixed domain if the group is security-enabled.
//


//
// MessageId: ERROR_DS_GLOBAL_CANT_HAVE_LOCAL_MEMBER
//
// MessageText:
//
// A global group cannot have a local group as a member.
//


//
// MessageId: ERROR_DS_GLOBAL_CANT_HAVE_UNIVERSAL_MEMBER
//
// MessageText:
//
// A global group cannot have a universal group as a member.
//


//
// MessageId: ERROR_DS_UNIVERSAL_CANT_HAVE_LOCAL_MEMBER
//
// MessageText:
//
// A universal group cannot have a local group as a member.
//


//
// MessageId: ERROR_DS_GLOBAL_CANT_HAVE_CROSSDOMAIN_MEMBER
//
// MessageText:
//
// A global group cannot have a cross-domain member.
//


//
// MessageId: ERROR_DS_LOCAL_CANT_HAVE_CROSSDOMAIN_LOCAL_MEMBER
//
// MessageText:
//
// A local group cannot have another cross domain local group as a member.
//


//
// MessageId: ERROR_DS_HAVE_PRIMARY_MEMBERS
//
// MessageText:
//
// A group with primary members cannot change to a security-disabled group.
//


//
// MessageId: ERROR_DS_STRING_SD_CONVERSION_FAILED
//
// MessageText:
//
// The schema cache load failed to convert the string default SD on a class-schema object.
//


//
// MessageId: ERROR_DS_NAMING_MASTER_GC
//
// MessageText:
//
// Only DSAs configured to be Global Catalog servers should be allowed to hold the Domain Naming Master FSMO role. (Applies only to Windows 2000 servers)
//


//
// MessageId: ERROR_DS_DNS_LOOKUP_FAILURE
//
// MessageText:
//
// The DSA operation is unable to proceed because of a DNS lookup failure.
//


//
// MessageId: ERROR_DS_COULDNT_UPDATE_SPNS
//
// MessageText:
//
// While processing a change to the DNS Host Name for an object, the Service Principal Name values could not be kept in sync.
//


//
// MessageId: ERROR_DS_CANT_RETRIEVE_SD
//
// MessageText:
//
// The Security Descriptor attribute could not be read.
//


//
// MessageId: ERROR_DS_KEY_NOT_UNIQUE
//
// MessageText:
//
// The object requested was not found, but an object with that key was found.
//


//
// MessageId: ERROR_DS_WRONG_LINKED_ATT_SYNTAX
//
// MessageText:
//
// The syntax of the linked attribute being added is incorrect. Forward links can only have syntax 2.5.5.1, 2.5.5.7, and 2.5.5.14, and backlinks can only have syntax 2.5.5.1
//


//
// MessageId: ERROR_DS_SAM_NEED_BOOTKEY_PASSWORD
//
// MessageText:
//
// Security Account Manager needs to get the boot password.
//


//
// MessageId: ERROR_DS_SAM_NEED_BOOTKEY_FLOPPY
//
// MessageText:
//
// Security Account Manager needs to get the boot key from floppy disk.
//


//
// MessageId: ERROR_DS_CANT_START
//
// MessageText:
//
// Directory Service cannot start.
//


//
// MessageId: ERROR_DS_INIT_FAILURE
//
// MessageText:
//
// Directory Services could not start.
//


//
// MessageId: ERROR_DS_NO_PKT_PRIVACY_ON_CONNECTION
//
// MessageText:
//
// The connection between client and server requires packet privacy or better.
//


//
// MessageId: ERROR_DS_SOURCE_DOMAIN_IN_FOREST
//
// MessageText:
//
// The source domain may not be in the same forest as destination.
//


//
// MessageId: ERROR_DS_DESTINATION_DOMAIN_NOT_IN_FOREST
//
// MessageText:
//
// The destination domain must be in the forest.
//


//
// MessageId: ERROR_DS_DESTINATION_AUDITING_NOT_ENABLED
//
// MessageText:
//
// The operation requires that destination domain auditing be enabled.
//


//
// MessageId: ERROR_DS_CANT_FIND_DC_FOR_SRC_DOMAIN
//
// MessageText:
//
// The operation couldn't locate a DC for the source domain.
//


//
// MessageId: ERROR_DS_SRC_OBJ_NOT_GROUP_OR_USER
//
// MessageText:
//
// The source object must be a group or user.
//


//
// MessageId: ERROR_DS_SRC_SID_EXISTS_IN_FOREST
//
// MessageText:
//
// The source object's SID already exists in destination forest.
//


//
// MessageId: ERROR_DS_SRC_AND_DST_OBJECT_CLASS_MISMATCH
//
// MessageText:
//
// The source and destination object must be of the same type.
//


//
// MessageId: ERROR_SAM_INIT_FAILURE
//
// MessageText:
//
// Security Accounts Manager initialization failed because of the following error: %1.
// Error Status: 0x%2. Click OK to shut down the system and reboot into Safe Mode. Check the event log for detailed information.
//


//
// MessageId: ERROR_DS_DRA_SCHEMA_INFO_SHIP
//
// MessageText:
//
// Schema information could not be included in the replication request.
//


//
// MessageId: ERROR_DS_DRA_SCHEMA_CONFLICT
//
// MessageText:
//
// The replication operation could not be completed due to a schema incompatibility.
//


//
// MessageId: ERROR_DS_DRA_EARLIER_SCHEMA_CONFLICT
//
// MessageText:
//
// The replication operation could not be completed due to a previous schema incompatibility.
//


//
// MessageId: ERROR_DS_DRA_OBJ_NC_MISMATCH
//
// MessageText:
//
// The replication update could not be applied because either the source or the destination has not yet received information regarding a recent cross-domain move operation.
//


//
// MessageId: ERROR_DS_NC_STILL_HAS_DSAS
//
// MessageText:
//
// The requested domain could not be deleted because there exist domain controllers that still host this domain.
//


//
// MessageId: ERROR_DS_GC_REQUIRED
//
// MessageText:
//
// The requested operation can be performed only on a global catalog server.
//


//
// MessageId: ERROR_DS_LOCAL_MEMBER_OF_LOCAL_ONLY
//
// MessageText:
//
// A local group can only be a member of other local groups in the same domain.
//


//
// MessageId: ERROR_DS_NO_FPO_IN_UNIVERSAL_GROUPS
//
// MessageText:
//
// Foreign security principals cannot be members of universal groups.
//


//
// MessageId: ERROR_DS_CANT_ADD_TO_GC
//
// MessageText:
//
// The attribute is not allowed to be replicated to the GC because of security reasons.
//


//
// MessageId: ERROR_DS_NO_CHECKPOINT_WITH_PDC
//
// MessageText:
//
// The checkpoint with the PDC could not be taken because there too many modifications being processed currently.
//


//
// MessageId: ERROR_DS_SOURCE_AUDITING_NOT_ENABLED
//
// MessageText:
//
// The operation requires that source domain auditing be enabled.
//


//
// MessageId: ERROR_DS_CANT_CREATE_IN_NONDOMAIN_NC
//
// MessageText:
//
// Security principal objects can only be created inside domain naming contexts.
//


//
// MessageId: ERROR_DS_INVALID_NAME_FOR_SPN
//
// MessageText:
//
// A Service Principal Name (SPN) could not be constructed because the provided hostname is not in the necessary format.
//


//
// MessageId: ERROR_DS_FILTER_USES_CONTRUCTED_ATTRS
//
// MessageText:
//
// A Filter was passed that uses constructed attributes.
//


//
// MessageId: ERROR_DS_UNICODEPWD_NOT_IN_QUOTES
//
// MessageText:
//
// The unicodePwd attribute value must be enclosed in double quotes.
//


//
// MessageId: ERROR_DS_MACHINE_ACCOUNT_QUOTA_EXCEEDED
//
// MessageText:
//
// Your computer could not be joined to the domain. You have exceeded the maximum number of computer accounts you are allowed to create in this domain. Contact your system administrator to have this limit reset or increased.
//


//
// MessageId: ERROR_DS_MUST_BE_RUN_ON_DST_DC
//
// MessageText:
//
// For security reasons, the operation must be run on the destination DC.
//


//
// MessageId: ERROR_DS_SRC_DC_MUST_BE_SP4_OR_GREATER
//
// MessageText:
//
// For security reasons, the source DC must be NT4SP4 or greater.
//


//
// MessageId: ERROR_DS_CANT_TREE_DELETE_CRITICAL_OBJ
//
// MessageText:
//
// Critical Directory Service System objects cannot be deleted during tree delete operations. The tree delete may have been partially performed.
//


//
// MessageId: ERROR_DS_INIT_FAILURE_CONSOLE
//
// MessageText:
//
// Directory Services could not start because of the following error: %1.
// Error Status: 0x%2. Please click OK to shutdown the system. You can use the recovery console to diagnose the system further.
//


//
// MessageId: ERROR_DS_SAM_INIT_FAILURE_CONSOLE
//
// MessageText:
//
// Security Accounts Manager initialization failed because of the following error: %1.
// Error Status: 0x%2. Please click OK to shutdown the system. You can use the recovery console to diagnose the system further.
//


//
// MessageId: ERROR_DS_FOREST_VERSION_TOO_HIGH
//
// MessageText:
//
// The version of the operating system is incompatible with the current AD DS forest functional level or AD LDS Configuration Set functional level. You must upgrade to a new version of the operating system before this server can become an AD DS Domain Controller or add an AD LDS Instance in this AD DS Forest or AD LDS Configuration Set.
//


//
// MessageId: ERROR_DS_DOMAIN_VERSION_TOO_HIGH
//
// MessageText:
//
// The version of the operating system installed is incompatible with the current domain functional level. You must upgrade to a new version of the operating system before this server can become a domain controller in this domain.
//


//
// MessageId: ERROR_DS_FOREST_VERSION_TOO_LOW
//
// MessageText:
//
// The version of the operating system installed on this server no longer supports the current AD DS Forest functional level or AD LDS Configuration Set functional level. You must raise the AD DS Forest functional level or AD LDS Configuration Set functional level before this server can become an AD DS Domain Controller or an AD LDS Instance in this Forest or Configuration Set.
//


//
// MessageId: ERROR_DS_DOMAIN_VERSION_TOO_LOW
//
// MessageText:
//
// The version of the operating system installed on this server no longer supports the current domain functional level. You must raise the domain functional level before this server can become a domain controller in this domain.
//


//
// MessageId: ERROR_DS_INCOMPATIBLE_VERSION
//
// MessageText:
//
// The version of the operating system installed on this server is incompatible with the functional level of the domain or forest.
//


//
// MessageId: ERROR_DS_LOW_DSA_VERSION
//
// MessageText:
//
// The functional level of the domain (or forest) cannot be raised to the requested value, because there exist one or more domain controllers in the domain (or forest) that are at a lower incompatible functional level.
//


//
// MessageId: ERROR_DS_NO_BEHAVIOR_VERSION_IN_MIXEDDOMAIN
//
// MessageText:
//
// The forest functional level cannot be raised to the requested value since one or more domains are still in mixed domain mode. All domains in the forest must be in native mode, for you to raise the forest functional level.
//


//
// MessageId: ERROR_DS_NOT_SUPPORTED_SORT_ORDER
//
// MessageText:
//
// The sort order requested is not supported.
//


//
// MessageId: ERROR_DS_NAME_NOT_UNIQUE
//
// MessageText:
//
// The requested name already exists as a unique identifier.
//


//
// MessageId: ERROR_DS_MACHINE_ACCOUNT_CREATED_PRENT4
//
// MessageText:
//
// The machine account was created pre-NT4. The account needs to be recreated.
//


//
// MessageId: ERROR_DS_OUT_OF_VERSION_STORE
//
// MessageText:
//
// The database is out of version store.
//


//
// MessageId: ERROR_DS_INCOMPATIBLE_CONTROLS_USED
//
// MessageText:
//
// Unable to continue operation because multiple conflicting controls were used.
//


//
// MessageId: ERROR_DS_NO_REF_DOMAIN
//
// MessageText:
//
// Unable to find a valid security descriptor reference domain for this partition.
//


//
// MessageId: ERROR_DS_RESERVED_LINK_ID
//
// MessageText:
//
// Schema update failed: The link identifier is reserved.
//


//
// MessageId: ERROR_DS_LINK_ID_NOT_AVAILABLE
//
// MessageText:
//
// Schema update failed: There are no link identifiers available.
//


//
// MessageId: ERROR_DS_AG_CANT_HAVE_UNIVERSAL_MEMBER
//
// MessageText:
//
// An account group cannot have a universal group as a member.
//


//
// MessageId: ERROR_DS_MODIFYDN_DISALLOWED_BY_INSTANCE_TYPE
//
// MessageText:
//
// Rename or move operations on naming context heads or read-only objects are not allowed.
//


//
// MessageId: ERROR_DS_NO_OBJECT_MOVE_IN_SCHEMA_NC
//
// MessageText:
//
// Move operations on objects in the schema naming context are not allowed.
//


//
// MessageId: ERROR_DS_MODIFYDN_DISALLOWED_BY_FLAG
//
// MessageText:
//
// A system flag has been set on the object and does not allow the object to be moved or renamed.
//


//
// MessageId: ERROR_DS_MODIFYDN_WRONG_GRANDPARENT
//
// MessageText:
//
// This object is not allowed to change its grandparent container. Moves are not forbidden on this object, but are restricted to sibling containers.
//


//
// MessageId: ERROR_DS_NAME_ERROR_TRUST_REFERRAL
//
// MessageText:
//
// Unable to resolve completely, a referral to another forest is generated.
//


//
// MessageId: ERROR_NOT_SUPPORTED_ON_STANDARD_SERVER
//
// MessageText:
//
// The requested action is not supported on standard server.
//


//
// MessageId: ERROR_DS_CANT_ACCESS_REMOTE_PART_OF_AD
//
// MessageText:
//
// Could not access a partition of the directory service located on a remote server. Make sure at least one server is running for the partition in question.
//


//
// MessageId: ERROR_DS_CR_IMPOSSIBLE_TO_VALIDATE_V2
//
// MessageText:
//
// The directory cannot validate the proposed naming context (or partition) name because it does not hold a replica nor can it contact a replica of the naming context above the proposed naming context. Please ensure that the parent naming context is properly registered in DNS, and at least one replica of this naming context is reachable by the Domain Naming master.
//


//
// MessageId: ERROR_DS_THREAD_LIMIT_EXCEEDED
//
// MessageText:
//
// The thread limit for this request was exceeded.
//


//
// MessageId: ERROR_DS_NOT_CLOSEST
//
// MessageText:
//
// The Global catalog server is not in the closest site.
//


//
// MessageId: ERROR_DS_CANT_DERIVE_SPN_WITHOUT_SERVER_REF
//
// MessageText:
//
// The DS cannot derive a service principal name (SPN) with which to mutually authenticate the target server because the corresponding server object in the local DS database has no serverReference attribute.
//


//
// MessageId: ERROR_DS_SINGLE_USER_MODE_FAILED
//
// MessageText:
//
// The Directory Service failed to enter single user mode.
//


//
// MessageId: ERROR_DS_NTDSCRIPT_SYNTAX_ERROR
//
// MessageText:
//
// The Directory Service cannot parse the script because of a syntax error.
//


//
// MessageId: ERROR_DS_NTDSCRIPT_PROCESS_ERROR
//
// MessageText:
//
// The Directory Service cannot process the script because of an error.
//


//
// MessageId: ERROR_DS_DIFFERENT_REPL_EPOCHS
//
// MessageText:
//
// The directory service cannot perform the requested operation because the servers involved are of different replication epochs (which is usually related to a domain rename that is in progress).
//


//
// MessageId: ERROR_DS_DRS_EXTENSIONS_CHANGED
//
// MessageText:
//
// The directory service binding must be renegotiated due to a change in the server extensions information.
//


//
// MessageId: ERROR_DS_REPLICA_SET_CHANGE_NOT_ALLOWED_ON_DISABLED_CR
//
// MessageText:
//
// Operation not allowed on a disabled cross ref.
//


//
// MessageId: ERROR_DS_NO_MSDS_INTID
//
// MessageText:
//
// Schema update failed: No values for msDS-IntId are available.
//


//
// MessageId: ERROR_DS_DUP_MSDS_INTID
//
// MessageText:
//
// Schema update failed: Duplicate msDS-INtId. Retry the operation.
//


//
// MessageId: ERROR_DS_EXISTS_IN_RDNATTID
//
// MessageText:
//
// Schema deletion failed: attribute is used in rDNAttID.
//


//
// MessageId: ERROR_DS_AUTHORIZATION_FAILED
//
// MessageText:
//
// The directory service failed to authorize the request.
//


//
// MessageId: ERROR_DS_INVALID_SCRIPT
//
// MessageText:
//
// The Directory Service cannot process the script because it is invalid.
//


//
// MessageId: ERROR_DS_REMOTE_CROSSREF_OP_FAILED
//
// MessageText:
//
// The remote create cross reference operation failed on the Domain Naming Master FSMO. The operation's error is in the extended data.
//


//
// MessageId: ERROR_DS_CROSS_REF_BUSY
//
// MessageText:
//
// A cross reference is in use locally with the same name.
//


//
// MessageId: ERROR_DS_CANT_DERIVE_SPN_FOR_DELETED_DOMAIN
//
// MessageText:
//
// The DS cannot derive a service principal name (SPN) with which to mutually authenticate the target server because the server's domain has been deleted from the forest.
//


//
// MessageId: ERROR_DS_CANT_DEMOTE_WITH_WRITEABLE_NC
//
// MessageText:
//
// Writeable NCs prevent this DC from demoting.
//


//
// MessageId: ERROR_DS_DUPLICATE_ID_FOUND
//
// MessageText:
//
// The requested object has a non-unique identifier and cannot be retrieved.
//


//
// MessageId: ERROR_DS_INSUFFICIENT_ATTR_TO_CREATE_OBJECT
//
// MessageText:
//
// Insufficient attributes were given to create an object. This object may not exist because it may have been deleted and already garbage collected.
//


//
// MessageId: ERROR_DS_GROUP_CONVERSION_ERROR
//
// MessageText:
//
// The group cannot be converted due to attribute restrictions on the requested group type.
//


//
// MessageId: ERROR_DS_CANT_MOVE_APP_BASIC_GROUP
//
// MessageText:
//
// Cross-domain move of non-empty basic application groups is not allowed.
//


//
// MessageId: ERROR_DS_CANT_MOVE_APP_QUERY_GROUP
//
// MessageText:
//
// Cross-domain move of non-empty query based application groups is not allowed.
//


//
// MessageId: ERROR_DS_ROLE_NOT_VERIFIED
//
// MessageText:
//
// The FSMO role ownership could not be verified because its directory partition has not replicated successfully with at least one replication partner.
//


//
// MessageId: ERROR_DS_WKO_CONTAINER_CANNOT_BE_SPECIAL
//
// MessageText:
//
// The target container for a redirection of a well known object container cannot already be a special container.
//


//
// MessageId: ERROR_DS_DOMAIN_RENAME_IN_PROGRESS
//
// MessageText:
//
// The Directory Service cannot perform the requested operation because a domain rename operation is in progress.
//


//
// MessageId: ERROR_DS_EXISTING_AD_CHILD_NC
//
// MessageText:
//
// The directory service detected a child partition below the requested partition name. The partition hierarchy must be created in a top down method.
//


//
// MessageId: ERROR_DS_REPL_LIFETIME_EXCEEDED
//
// MessageText:
//
// The directory service cannot replicate with this server because the time since the last replication with this server has exceeded the tombstone lifetime.
//


//
// MessageId: ERROR_DS_DISALLOWED_IN_SYSTEM_CONTAINER
//
// MessageText:
//
// The requested operation is not allowed on an object under the system container.
//


//
// MessageId: ERROR_DS_LDAP_SEND_QUEUE_FULL
//
// MessageText:
//
// The LDAP servers network send queue has filled up because the client is not processing the results of its requests fast enough. No more requests will be processed until the client catches up. If the client does not catch up then it will be disconnected.
//


//
// MessageId: ERROR_DS_DRA_OUT_SCHEDULE_WINDOW
//
// MessageText:
//
// The scheduled replication did not take place because the system was too busy to execute the request within the schedule window. The replication queue is overloaded. Consider reducing the number of partners or decreasing the scheduled replication frequency.
//


//
// MessageId: ERROR_DS_POLICY_NOT_KNOWN
//
// MessageText:
//
// At this time, it cannot be determined if the branch replication policy is available on the hub domain controller. Please retry at a later time to account for replication latencies.
//


//
// MessageId: ERROR_NO_SITE_SETTINGS_OBJECT
//
// MessageText:
//
// The site settings object for the specified site does not exist.
//


//
// MessageId: ERROR_NO_SECRETS
//
// MessageText:
//
// The local account store does not contain secret material for the specified account.
//


//
// MessageId: ERROR_NO_WRITABLE_DC_FOUND
//
// MessageText:
//
// Could not find a writable domain controller in the domain.
//


//
// MessageId: ERROR_DS_NO_SERVER_OBJECT
//
// MessageText:
//
// The server object for the domain controller does not exist.
//


//
// MessageId: ERROR_DS_NO_NTDSA_OBJECT
//
// MessageText:
//
// The NTDS Settings object for the domain controller does not exist.
//


//
// MessageId: ERROR_DS_NON_ASQ_SEARCH
//
// MessageText:
//
// The requested search operation is not supported for ASQ searches.
//


//
// MessageId: ERROR_DS_AUDIT_FAILURE
//
// MessageText:
//
// A required audit event could not be generated for the operation.
//


//
// MessageId: ERROR_DS_INVALID_SEARCH_FLAG_SUBTREE
//
// MessageText:
//
// The search flags for the attribute are invalid. The subtree index bit is valid only on single valued attributes.
//


//
// MessageId: ERROR_DS_INVALID_SEARCH_FLAG_TUPLE
//
// MessageText:
//
// The search flags for the attribute are invalid. The tuple index bit is valid only on attributes of Unicode strings.
//


//
// MessageId: ERROR_DS_HIERARCHY_TABLE_TOO_DEEP
//
// MessageText:
//
// The address books are nested too deeply. Failed to build the hierarchy table.
//


//
// MessageId: ERROR_DS_DRA_CORRUPT_UTD_VECTOR
//
// MessageText:
//
// The specified up-to-date-ness vector is corrupt.
//


//
// MessageId: ERROR_DS_DRA_SECRETS_DENIED
//
// MessageText:
//
// The request to replicate secrets is denied.
//


//
// MessageId: ERROR_DS_RESERVED_MAPI_ID
//
// MessageText:
//
// Schema update failed: The MAPI identifier is reserved.
//


//
// MessageId: ERROR_DS_MAPI_ID_NOT_AVAILABLE
//
// MessageText:
//
// Schema update failed: There are no MAPI identifiers available.
//


//
// MessageId: ERROR_DS_DRA_MISSING_KRBTGT_SECRET
//
// MessageText:
//
// The replication operation failed because the required attributes of the local krbtgt object are missing.
//


//
// MessageId: ERROR_DS_DOMAIN_NAME_EXISTS_IN_FOREST
//
// MessageText:
//
// The domain name of the trusted domain already exists in the forest.
//


//
// MessageId: ERROR_DS_FLAT_NAME_EXISTS_IN_FOREST
//
// MessageText:
//
// The flat name of the trusted domain already exists in the forest.
//


//
// MessageId: ERROR_INVALID_USER_PRINCIPAL_NAME
//
// MessageText:
//
// The User Principal Name (UPN) is invalid.
//


//
// MessageId: ERROR_DS_OID_MAPPED_GROUP_CANT_HAVE_MEMBERS
//
// MessageText:
//
// OID mapped groups cannot have members.
//


//
// MessageId: ERROR_DS_OID_NOT_FOUND
//
// MessageText:
//
// The specified OID cannot be found.
//


//
// MessageId: ERROR_DS_DRA_RECYCLED_TARGET
//
// MessageText:
//
// The replication operation failed because the target object referred by a link value is recycled.
//


//
// MessageId: ERROR_DS_DISALLOWED_NC_REDIRECT
//
// MessageText:
//
// The redirect operation failed because the target object is in a NC different from the domain NC of the current domain controller.
//


//
// MessageId: ERROR_DS_HIGH_ADLDS_FFL
//
// MessageText:
//
// The functional level of the AD LDS configuration set cannot be lowered to the requested value.
//


//
// MessageId: ERROR_DS_HIGH_DSA_VERSION
//
// MessageText:
//
// The functional level of the domain (or forest) cannot be lowered to the requested value.
//


//
// MessageId: ERROR_DS_LOW_ADLDS_FFL
//
// MessageText:
//
// The functional level of the AD LDS configuration set cannot be raised to the requested value, because there exist one or more ADLDS instances that are at a lower incompatible functional level.
//


//
// MessageId: ERROR_DOMAIN_SID_SAME_AS_LOCAL_WORKSTATION
//
// MessageText:
//
// The domain join cannot be completed because the SID of the domain you attempted to join was identical to the SID of this machine. This is a symptom of an improperly cloned operating system install.  You should run sysprep on this machine in order to generate a new machine SID. Please see http://go.microsoft.com/fwlink/?LinkId=168895 for more information.
//


//
// MessageId: ERROR_DS_UNDELETE_SAM_VALIDATION_FAILED
//
// MessageText:
//
// The undelete operation failed because the Sam Account Name or Additional Sam Account Name of the object being undeleted conflicts with an existing live object.
//


//
// MessageId: ERROR_INCORRECT_ACCOUNT_TYPE
//
// MessageText:
//
// The system is not authoritative for the specified account and therefore cannot complete the operation. Please retry the operation using the provider associated with this account. If this is an online provider please use the provider's online site.
//


//
// MessageId: ERROR_DS_SPN_VALUE_NOT_UNIQUE_IN_FOREST
//
// MessageText:
//
// The operation failed because SPN value provided for addition/modification is not unique forest-wide.
//


//
// MessageId: ERROR_DS_UPN_VALUE_NOT_UNIQUE_IN_FOREST
//
// MessageText:
//
// The operation failed because UPN value provided for addition/modification is not unique forest-wide.
//


//
// MessageId: ERROR_DS_MISSING_FOREST_TRUST
//
// MessageText:
//
// The operation failed because the addition/modification referenced an inbound forest-wide trust that is not present.
//


//
// MessageId: ERROR_DS_VALUE_KEY_NOT_UNIQUE
//
// MessageText:
//
// The link value specified was not found, but a link value with that key was found.
//



///////////////////////////////////////////////////
//                                                /
//        End of Active Directory Error Codes     /
//                                                /
//                  8000 to  8999                 /
///////////////////////////////////////////////////


///////////////////////////////////////////////////
//                                               //
//               DNS Error codes                 //
//                                               //
//                 9000 to 9999                  //
///////////////////////////////////////////////////

// =============================
// Facility DNS Error Messages
// =============================

//
//  DNS response codes.
//







// DNS_ERROR_RCODE_FORMAT_ERROR          0x00002329
//
// MessageId: DNS_ERROR_RCODE_FORMAT_ERROR
//
// MessageText:
//
// DNS server unable to interpret format.
//


// DNS_ERROR_RCODE_SERVER_FAILURE        0x0000232a
//
// MessageId: DNS_ERROR_RCODE_SERVER_FAILURE
//
// MessageText:
//
// DNS server failure.
//


// DNS_ERROR_RCODE_NAME_ERROR            0x0000232b
//
// MessageId: DNS_ERROR_RCODE_NAME_ERROR
//
// MessageText:
//
// DNS name does not exist.
//


// DNS_ERROR_RCODE_NOT_IMPLEMENTED       0x0000232c
//
// MessageId: DNS_ERROR_RCODE_NOT_IMPLEMENTED
//
// MessageText:
//
// DNS request not supported by name server.
//


// DNS_ERROR_RCODE_REFUSED               0x0000232d
//
// MessageId: DNS_ERROR_RCODE_REFUSED
//
// MessageText:
//
// DNS operation refused.
//


// DNS_ERROR_RCODE_YXDOMAIN              0x0000232e
//
// MessageId: DNS_ERROR_RCODE_YXDOMAIN
//
// MessageText:
//
// DNS name that ought not exist, does exist.
//


// DNS_ERROR_RCODE_YXRRSET               0x0000232f
//
// MessageId: DNS_ERROR_RCODE_YXRRSET
//
// MessageText:
//
// DNS RR set that ought not exist, does exist.
//


// DNS_ERROR_RCODE_NXRRSET               0x00002330
//
// MessageId: DNS_ERROR_RCODE_NXRRSET
//
// MessageText:
//
// DNS RR set that ought to exist, does not exist.
//


// DNS_ERROR_RCODE_NOTAUTH               0x00002331
//
// MessageId: DNS_ERROR_RCODE_NOTAUTH
//
// MessageText:
//
// DNS server not authoritative for zone.
//


// DNS_ERROR_RCODE_NOTZONE               0x00002332
//
// MessageId: DNS_ERROR_RCODE_NOTZONE
//
// MessageText:
//
// DNS name in update or prereq is not in zone.
//


// DNS_ERROR_RCODE_BADSIG                0x00002338
//
// MessageId: DNS_ERROR_RCODE_BADSIG
//
// MessageText:
//
// DNS signature failed to verify.
//


// DNS_ERROR_RCODE_BADKEY                0x00002339
//
// MessageId: DNS_ERROR_RCODE_BADKEY
//
// MessageText:
//
// DNS bad key.
//


// DNS_ERROR_RCODE_BADTIME               0x0000233a
//
// MessageId: DNS_ERROR_RCODE_BADTIME
//
// MessageText:
//
// DNS signature validity expired.
//





//
// DNSSEC errors
//



//
// MessageId: DNS_ERROR_KEYMASTER_REQUIRED
//
// MessageText:
//
// Only the DNS server acting as the key master for the zone may perform this operation.
//


//
// MessageId: DNS_ERROR_NOT_ALLOWED_ON_SIGNED_ZONE
//
// MessageText:
//
// This operation is not allowed on a zone that is signed or has signing keys.
//


//
// MessageId: DNS_ERROR_NSEC3_INCOMPATIBLE_WITH_RSA_SHA1
//
// MessageText:
//
// NSEC3 is not compatible with the RSA-SHA-1 algorithm. Choose a different algorithm or use NSEC.
//


//
// MessageId: DNS_ERROR_NOT_ENOUGH_SIGNING_KEY_DESCRIPTORS
//
// MessageText:
//
// The zone does not have enough signing keys. There must be at least one key signing key (KSK) and at least one zone signing key (ZSK).
//


//
// MessageId: DNS_ERROR_UNSUPPORTED_ALGORITHM
//
// MessageText:
//
// The specified algorithm is not supported.
//


//
// MessageId: DNS_ERROR_INVALID_KEY_SIZE
//
// MessageText:
//
// The specified key size is not supported.
//


//
// MessageId: DNS_ERROR_SIGNING_KEY_NOT_ACCESSIBLE
//
// MessageText:
//
// One or more of the signing keys for a zone are not accessible to the DNS server. Zone signing will not be operational until this error is resolved.
//


//
// MessageId: DNS_ERROR_KSP_DOES_NOT_SUPPORT_PROTECTION
//
// MessageText:
//
// The specified key storage provider does not support DPAPI++ data protection. Zone signing will not be operational until this error is resolved.
//


//
// MessageId: DNS_ERROR_UNEXPECTED_DATA_PROTECTION_ERROR
//
// MessageText:
//
// An unexpected DPAPI++ error was encountered. Zone signing will not be operational until this error is resolved.
//


//
// MessageId: DNS_ERROR_UNEXPECTED_CNG_ERROR
//
// MessageText:
//
// An unexpected crypto error was encountered. Zone signing may not be operational until this error is resolved.
//


//
// MessageId: DNS_ERROR_UNKNOWN_SIGNING_PARAMETER_VERSION
//
// MessageText:
//
// The DNS server encountered a signing key with an unknown version. Zone signing will not be operational until this error is resolved.
//


//
// MessageId: DNS_ERROR_KSP_NOT_ACCESSIBLE
//
// MessageText:
//
// The specified key service provider cannot be opened by the DNS server.
//


//
// MessageId: DNS_ERROR_TOO_MANY_SKDS
//
// MessageText:
//
// The DNS server cannot accept any more signing keys with the specified algorithm and KSK flag value for this zone.
//


//
// MessageId: DNS_ERROR_INVALID_ROLLOVER_PERIOD
//
// MessageText:
//
// The specified rollover period is invalid.
//


//
// MessageId: DNS_ERROR_INVALID_INITIAL_ROLLOVER_OFFSET
//
// MessageText:
//
// The specified initial rollover offset is invalid.
//


//
// MessageId: DNS_ERROR_ROLLOVER_IN_PROGRESS
//
// MessageText:
//
// The specified signing key is already in process of rolling over keys.
//


//
// MessageId: DNS_ERROR_STANDBY_KEY_NOT_PRESENT
//
// MessageText:
//
// The specified signing key does not have a standby key to revoke.
//


//
// MessageId: DNS_ERROR_NOT_ALLOWED_ON_ZSK
//
// MessageText:
//
// This operation is not allowed on a zone signing key (ZSK).
//


//
// MessageId: DNS_ERROR_NOT_ALLOWED_ON_ACTIVE_SKD
//
// MessageText:
//
// This operation is not allowed on an active signing key.
//


//
// MessageId: DNS_ERROR_ROLLOVER_ALREADY_QUEUED
//
// MessageText:
//
// The specified signing key is already queued for rollover.
//


//
// MessageId: DNS_ERROR_NOT_ALLOWED_ON_UNSIGNED_ZONE
//
// MessageText:
//
// This operation is not allowed on an unsigned zone.
//


//
// MessageId: DNS_ERROR_BAD_KEYMASTER
//
// MessageText:
//
// This operation could not be completed because the DNS server listed as the current key master for this zone is down or misconfigured. Resolve the problem on the current key master for this zone or use another DNS server to seize the key master role.
//


//
// MessageId: DNS_ERROR_INVALID_SIGNATURE_VALIDITY_PERIOD
//
// MessageText:
//
// The specified signature validity period is invalid.
//


//
// MessageId: DNS_ERROR_INVALID_NSEC3_ITERATION_COUNT
//
// MessageText:
//
// The specified NSEC3 iteration count is higher than allowed by the minimum key length used in the zone.
//


//
// MessageId: DNS_ERROR_DNSSEC_IS_DISABLED
//
// MessageText:
//
// This operation could not be completed because the DNS server has been configured with DNSSEC features disabled. Enable DNSSEC on the DNS server.
//


//
// MessageId: DNS_ERROR_INVALID_XML
//
// MessageText:
//
// This operation could not be completed because the XML stream received is empty or syntactically invalid.
//


//
// MessageId: DNS_ERROR_NO_VALID_TRUST_ANCHORS
//
// MessageText:
//
// This operation completed, but no trust anchors were added because all of the trust anchors received were either invalid, unsupported, expired, or would not become valid in less than 30 days.
//


//
// MessageId: DNS_ERROR_ROLLOVER_NOT_POKEABLE
//
// MessageText:
//
// The specified signing key is not waiting for parental DS update.
//


//
// MessageId: DNS_ERROR_NSEC3_NAME_COLLISION
//
// MessageText:
//
// Hash collision detected during NSEC3 signing. Specify a different user-provided salt, or use a randomly generated salt, and attempt to sign the zone again.
//


//
// MessageId: DNS_ERROR_NSEC_INCOMPATIBLE_WITH_NSEC3_RSA_SHA1
//
// MessageText:
//
// NSEC is not compatible with the NSEC3-RSA-SHA-1 algorithm. Choose a different algorithm or use NSEC3.
//



//
// Packet format
//



// DNS_INFO_NO_RECORDS                   0x0000251d
//
// MessageId: DNS_INFO_NO_RECORDS
//
// MessageText:
//
// No records found for given DNS query.
//


// DNS_ERROR_BAD_PACKET                  0x0000251e
//
// MessageId: DNS_ERROR_BAD_PACKET
//
// MessageText:
//
// Bad DNS packet.
//


// DNS_ERROR_NO_PACKET                   0x0000251f
//
// MessageId: DNS_ERROR_NO_PACKET
//
// MessageText:
//
// No DNS packet.
//


// DNS_ERROR_RCODE                       0x00002520
//
// MessageId: DNS_ERROR_RCODE
//
// MessageText:
//
// DNS error, check rcode.
//


// DNS_ERROR_UNSECURE_PACKET             0x00002521
//
// MessageId: DNS_ERROR_UNSECURE_PACKET
//
// MessageText:
//
// Unsecured DNS packet.
//




// DNS_REQUEST_PENDING                     0x00002522
//
// MessageId: DNS_REQUEST_PENDING
//
// MessageText:
//
// DNS query request is pending.
//



//
// General API errors
//







// DNS_ERROR_INVALID_TYPE                0x0000254f
//
// MessageId: DNS_ERROR_INVALID_TYPE
//
// MessageText:
//
// Invalid DNS type.
//


// DNS_ERROR_INVALID_IP_ADDRESS          0x00002550
//
// MessageId: DNS_ERROR_INVALID_IP_ADDRESS
//
// MessageText:
//
// Invalid IP address.
//


// DNS_ERROR_INVALID_PROPERTY            0x00002551
//
// MessageId: DNS_ERROR_INVALID_PROPERTY
//
// MessageText:
//
// Invalid property.
//


// DNS_ERROR_TRY_AGAIN_LATER             0x00002552
//
// MessageId: DNS_ERROR_TRY_AGAIN_LATER
//
// MessageText:
//
// Try DNS operation again later.
//


// DNS_ERROR_NOT_UNIQUE                  0x00002553
//
// MessageId: DNS_ERROR_NOT_UNIQUE
//
// MessageText:
//
// Record for given name and type is not unique.
//


// DNS_ERROR_NON_RFC_NAME                0x00002554
//
// MessageId: DNS_ERROR_NON_RFC_NAME
//
// MessageText:
//
// DNS name does not comply with RFC specifications.
//


// DNS_STATUS_FQDN                       0x00002555
//
// MessageId: DNS_STATUS_FQDN
//
// MessageText:
//
// DNS name is a fully-qualified DNS name.
//


// DNS_STATUS_DOTTED_NAME                0x00002556
//
// MessageId: DNS_STATUS_DOTTED_NAME
//
// MessageText:
//
// DNS name is dotted (multi-label).
//


// DNS_STATUS_SINGLE_PART_NAME           0x00002557
//
// MessageId: DNS_STATUS_SINGLE_PART_NAME
//
// MessageText:
//
// DNS name is a single-part name.
//


// DNS_ERROR_INVALID_NAME_CHAR           0x00002558
//
// MessageId: DNS_ERROR_INVALID_NAME_CHAR
//
// MessageText:
//
// DNS name contains an invalid character.
//


// DNS_ERROR_NUMERIC_NAME                0x00002559
//
// MessageId: DNS_ERROR_NUMERIC_NAME
//
// MessageText:
//
// DNS name is entirely numeric.
//


// DNS_ERROR_NOT_ALLOWED_ON_ROOT_SERVER  0x0000255A
//
// MessageId: DNS_ERROR_NOT_ALLOWED_ON_ROOT_SERVER
//
// MessageText:
//
// The operation requested is not permitted on a DNS root server.
//


// DNS_ERROR_NOT_ALLOWED_UNDER_DELEGATION  0x0000255B
//
// MessageId: DNS_ERROR_NOT_ALLOWED_UNDER_DELEGATION
//
// MessageText:
//
// The record could not be created because this part of the DNS namespace has been delegated to another server.
//


// DNS_ERROR_CANNOT_FIND_ROOT_HINTS  0x0000255C
//
// MessageId: DNS_ERROR_CANNOT_FIND_ROOT_HINTS
//
// MessageText:
//
// The DNS server could not find a set of root hints.
//


// DNS_ERROR_INCONSISTENT_ROOT_HINTS  0x0000255D
//
// MessageId: DNS_ERROR_INCONSISTENT_ROOT_HINTS
//
// MessageText:
//
// The DNS server found root hints but they were not consistent across all adapters.
//


// DNS_ERROR_DWORD_VALUE_TOO_SMALL    0x0000255E
//
// MessageId: DNS_ERROR_DWORD_VALUE_TOO_SMALL
//
// MessageText:
//
// The specified value is too small for this parameter.
//


// DNS_ERROR_DWORD_VALUE_TOO_LARGE    0x0000255F
//
// MessageId: DNS_ERROR_DWORD_VALUE_TOO_LARGE
//
// MessageText:
//
// The specified value is too large for this parameter.
//


// DNS_ERROR_BACKGROUND_LOADING       0x00002560
//
// MessageId: DNS_ERROR_BACKGROUND_LOADING
//
// MessageText:
//
// This operation is not allowed while the DNS server is loading zones in the background. Please try again later.
//


// DNS_ERROR_NOT_ALLOWED_ON_RODC      0x00002561
//
// MessageId: DNS_ERROR_NOT_ALLOWED_ON_RODC
//
// MessageText:
//
// The operation requested is not permitted on against a DNS server running on a read-only DC.
//


// DNS_ERROR_NOT_ALLOWED_UNDER_DNAME   0x00002562
//
// MessageId: DNS_ERROR_NOT_ALLOWED_UNDER_DNAME
//
// MessageText:
//
// No data is allowed to exist underneath a DNAME record.
//


// DNS_ERROR_DELEGATION_REQUIRED       0x00002563
//
// MessageId: DNS_ERROR_DELEGATION_REQUIRED
//
// MessageText:
//
// This operation requires credentials delegation.
//


// DNS_ERROR_INVALID_POLICY_TABLE        0x00002564
//
// MessageId: DNS_ERROR_INVALID_POLICY_TABLE
//
// MessageText:
//
// Name resolution policy table has been corrupted. DNS resolution will fail until it is fixed. Contact your network administrator.
//


// DNS_ERROR_ADDRESS_REQUIRED        0x00002565
//
// MessageId: DNS_ERROR_ADDRESS_REQUIRED
//
// MessageText:
//
// Not allowed to remove all addresses.
//



//
// Zone errors
//



// DNS_ERROR_ZONE_DOES_NOT_EXIST         0x00002581
//
// MessageId: DNS_ERROR_ZONE_DOES_NOT_EXIST
//
// MessageText:
//
// DNS zone does not exist.
//


// DNS_ERROR_NO_ZONE_INFO                0x00002582
//
// MessageId: DNS_ERROR_NO_ZONE_INFO
//
// MessageText:
//
// DNS zone information not available.
//


// DNS_ERROR_INVALID_ZONE_OPERATION      0x00002583
//
// MessageId: DNS_ERROR_INVALID_ZONE_OPERATION
//
// MessageText:
//
// Invalid operation for DNS zone.
//


// DNS_ERROR_ZONE_CONFIGURATION_ERROR    0x00002584
//
// MessageId: DNS_ERROR_ZONE_CONFIGURATION_ERROR
//
// MessageText:
//
// Invalid DNS zone configuration.
//


// DNS_ERROR_ZONE_HAS_NO_SOA_RECORD      0x00002585
//
// MessageId: DNS_ERROR_ZONE_HAS_NO_SOA_RECORD
//
// MessageText:
//
// DNS zone has no start of authority (SOA) record.
//


// DNS_ERROR_ZONE_HAS_NO_NS_RECORDS      0x00002586
//
// MessageId: DNS_ERROR_ZONE_HAS_NO_NS_RECORDS
//
// MessageText:
//
// DNS zone has no Name Server (NS) record.
//


// DNS_ERROR_ZONE_LOCKED                 0x00002587
//
// MessageId: DNS_ERROR_ZONE_LOCKED
//
// MessageText:
//
// DNS zone is locked.
//


// DNS_ERROR_ZONE_CREATION_FAILED        0x00002588
//
// MessageId: DNS_ERROR_ZONE_CREATION_FAILED
//
// MessageText:
//
// DNS zone creation failed.
//


// DNS_ERROR_ZONE_ALREADY_EXISTS         0x00002589
//
// MessageId: DNS_ERROR_ZONE_ALREADY_EXISTS
//
// MessageText:
//
// DNS zone already exists.
//


// DNS_ERROR_AUTOZONE_ALREADY_EXISTS     0x0000258a
//
// MessageId: DNS_ERROR_AUTOZONE_ALREADY_EXISTS
//
// MessageText:
//
// DNS automatic zone already exists.
//


// DNS_ERROR_INVALID_ZONE_TYPE           0x0000258b
//
// MessageId: DNS_ERROR_INVALID_ZONE_TYPE
//
// MessageText:
//
// Invalid DNS zone type.
//


// DNS_ERROR_SECONDARY_REQUIRES_MASTER_IP 0x0000258c
//
// MessageId: DNS_ERROR_SECONDARY_REQUIRES_MASTER_IP
//
// MessageText:
//
// Secondary DNS zone requires master IP address.
//


// DNS_ERROR_ZONE_NOT_SECONDARY          0x0000258d
//
// MessageId: DNS_ERROR_ZONE_NOT_SECONDARY
//
// MessageText:
//
// DNS zone not secondary.
//


// DNS_ERROR_NEED_SECONDARY_ADDRESSES    0x0000258e
//
// MessageId: DNS_ERROR_NEED_SECONDARY_ADDRESSES
//
// MessageText:
//
// Need secondary IP address.
//


// DNS_ERROR_WINS_INIT_FAILED            0x0000258f
//
// MessageId: DNS_ERROR_WINS_INIT_FAILED
//
// MessageText:
//
// WINS initialization failed.
//


// DNS_ERROR_NEED_WINS_SERVERS           0x00002590
//
// MessageId: DNS_ERROR_NEED_WINS_SERVERS
//
// MessageText:
//
// Need WINS servers.
//


// DNS_ERROR_NBSTAT_INIT_FAILED          0x00002591
//
// MessageId: DNS_ERROR_NBSTAT_INIT_FAILED
//
// MessageText:
//
// NBTSTAT initialization call failed.
//


// DNS_ERROR_SOA_DELETE_INVALID          0x00002592
//
// MessageId: DNS_ERROR_SOA_DELETE_INVALID
//
// MessageText:
//
// Invalid delete of start of authority (SOA)
//


// DNS_ERROR_FORWARDER_ALREADY_EXISTS    0x00002593
//
// MessageId: DNS_ERROR_FORWARDER_ALREADY_EXISTS
//
// MessageText:
//
// A conditional forwarding zone already exists for that name.
//


// DNS_ERROR_ZONE_REQUIRES_MASTER_IP     0x00002594
//
// MessageId: DNS_ERROR_ZONE_REQUIRES_MASTER_IP
//
// MessageText:
//
// This zone must be configured with one or more master DNS server IP addresses.
//


// DNS_ERROR_ZONE_IS_SHUTDOWN            0x00002595
//
// MessageId: DNS_ERROR_ZONE_IS_SHUTDOWN
//
// MessageText:
//
// The operation cannot be performed because this zone is shut down.
//


// DNS_ERROR_ZONE_LOCKED_FOR_SIGNING     0x00002596
//
// MessageId: DNS_ERROR_ZONE_LOCKED_FOR_SIGNING
//
// MessageText:
//
// This operation cannot be performed because the zone is currently being signed. Please try again later.
//



//
// Datafile errors
//



// DNS                                   0x000025b3
//
// MessageId: DNS_ERROR_PRIMARY_REQUIRES_DATAFILE
//
// MessageText:
//
// Primary DNS zone requires datafile.
//


// DNS                                   0x000025b4
//
// MessageId: DNS_ERROR_INVALID_DATAFILE_NAME
//
// MessageText:
//
// Invalid datafile name for DNS zone.
//


// DNS                                   0x000025b5
//
// MessageId: DNS_ERROR_DATAFILE_OPEN_FAILURE
//
// MessageText:
//
// Failed to open datafile for DNS zone.
//


// DNS                                   0x000025b6
//
// MessageId: DNS_ERROR_FILE_WRITEBACK_FAILED
//
// MessageText:
//
// Failed to write datafile for DNS zone.
//


// DNS                                   0x000025b7
//
// MessageId: DNS_ERROR_DATAFILE_PARSING
//
// MessageText:
//
// Failure while reading datafile for DNS zone.
//



//
// Database errors
//



// DNS_ERROR_RECORD_DOES_NOT_EXIST       0x000025e5
//
// MessageId: DNS_ERROR_RECORD_DOES_NOT_EXIST
//
// MessageText:
//
// DNS record does not exist.
//


// DNS_ERROR_RECORD_FORMAT               0x000025e6
//
// MessageId: DNS_ERROR_RECORD_FORMAT
//
// MessageText:
//
// DNS record format error.
//


// DNS_ERROR_NODE_CREATION_FAILED        0x000025e7
//
// MessageId: DNS_ERROR_NODE_CREATION_FAILED
//
// MessageText:
//
// Node creation failure in DNS.
//


// DNS_ERROR_UNKNOWN_RECORD_TYPE         0x000025e8
//
// MessageId: DNS_ERROR_UNKNOWN_RECORD_TYPE
//
// MessageText:
//
// Unknown DNS record type.
//


// DNS_ERROR_RECORD_TIMED_OUT            0x000025e9
//
// MessageId: DNS_ERROR_RECORD_TIMED_OUT
//
// MessageText:
//
// DNS record timed out.
//


// DNS_ERROR_NAME_NOT_IN_ZONE            0x000025ea
//
// MessageId: DNS_ERROR_NAME_NOT_IN_ZONE
//
// MessageText:
//
// Name not in DNS zone.
//


// DNS_ERROR_CNAME_LOOP                  0x000025eb
//
// MessageId: DNS_ERROR_CNAME_LOOP
//
// MessageText:
//
// CNAME loop detected.
//


// DNS_ERROR_NODE_IS_CNAME               0x000025ec
//
// MessageId: DNS_ERROR_NODE_IS_CNAME
//
// MessageText:
//
// Node is a CNAME DNS record.
//


// DNS_ERROR_CNAME_COLLISION             0x000025ed
//
// MessageId: DNS_ERROR_CNAME_COLLISION
//
// MessageText:
//
// A CNAME record already exists for given name.
//


// DNS_ERROR_RECORD_ONLY_AT_ZONE_ROOT    0x000025ee
//
// MessageId: DNS_ERROR_RECORD_ONLY_AT_ZONE_ROOT
//
// MessageText:
//
// Record only at DNS zone root.
//


// DNS_ERROR_RECORD_ALREADY_EXISTS       0x000025ef
//
// MessageId: DNS_ERROR_RECORD_ALREADY_EXISTS
//
// MessageText:
//
// DNS record already exists.
//


// DNS_ERROR_SECONDARY_DATA              0x000025f0
//
// MessageId: DNS_ERROR_SECONDARY_DATA
//
// MessageText:
//
// Secondary DNS zone data error.
//


// DNS_ERROR_NO_CREATE_CACHE_DATA        0x000025f1
//
// MessageId: DNS_ERROR_NO_CREATE_CACHE_DATA
//
// MessageText:
//
// Could not create DNS cache data.
//


// DNS_ERROR_NAME_DOES_NOT_EXIST         0x000025f2
//
// MessageId: DNS_ERROR_NAME_DOES_NOT_EXIST
//
// MessageText:
//
// DNS name does not exist.
//


// DNS_WARNING_PTR_CREATE_FAILED         0x000025f3
//
// MessageId: DNS_WARNING_PTR_CREATE_FAILED
//
// MessageText:
//
// Could not create pointer (PTR) record.
//


// DNS_WARNING_DOMAIN_UNDELETED          0x000025f4
//
// MessageId: DNS_WARNING_DOMAIN_UNDELETED
//
// MessageText:
//
// DNS domain was undeleted.
//


// DNS_ERROR_DS_UNAVAILABLE              0x000025f5
//
// MessageId: DNS_ERROR_DS_UNAVAILABLE
//
// MessageText:
//
// The directory service is unavailable.
//


// DNS_ERROR_DS_ZONE_ALREADY_EXISTS      0x000025f6
//
// MessageId: DNS_ERROR_DS_ZONE_ALREADY_EXISTS
//
// MessageText:
//
// DNS zone already exists in the directory service.
//


// DNS_ERROR_NO_BOOTFILE_IF_DS_ZONE      0x000025f7
//
// MessageId: DNS_ERROR_NO_BOOTFILE_IF_DS_ZONE
//
// MessageText:
//
// DNS server not creating or reading the boot file for the directory service integrated DNS zone.
//


// DNS_ERROR_NODE_IS_DNAME               0x000025f8
//
// MessageId: DNS_ERROR_NODE_IS_DNAME
//
// MessageText:
//
// Node is a DNAME DNS record.
//


// DNS_ERROR_DNAME_COLLISION             0x000025f9
//
// MessageId: DNS_ERROR_DNAME_COLLISION
//
// MessageText:
//
// A DNAME record already exists for given name.
//


// DNS_ERROR_ALIAS_LOOP                  0x000025fa
//
// MessageId: DNS_ERROR_ALIAS_LOOP
//
// MessageText:
//
// An alias loop has been detected with either CNAME or DNAME records.
//



//
// Operation errors
//



// DNS_INFO_AXFR_COMPLETE                0x00002617
//
// MessageId: DNS_INFO_AXFR_COMPLETE
//
// MessageText:
//
// DNS AXFR (zone transfer) complete.
//


// DNS_ERROR_AXFR                        0x00002618
//
// MessageId: DNS_ERROR_AXFR
//
// MessageText:
//
// DNS zone transfer failed.
//


// DNS_INFO_ADDED_LOCAL_WINS             0x00002619
//
// MessageId: DNS_INFO_ADDED_LOCAL_WINS
//
// MessageText:
//
// Added local WINS server.
//



//
// Secure update
//



// DNS_STATUS_CONTINUE_NEEDED            0x00002649
//
// MessageId: DNS_STATUS_CONTINUE_NEEDED
//
// MessageText:
//
// Secure update call needs to continue update request.
//



//
// Setup errors
//



// DNS_ERROR_NO_TCPIP                    0x0000267b
//
// MessageId: DNS_ERROR_NO_TCPIP
//
// MessageText:
//
// TCP/IP network protocol not installed.
//


// DNS_ERROR_NO_DNS_SERVERS              0x0000267c
//
// MessageId: DNS_ERROR_NO_DNS_SERVERS
//
// MessageText:
//
// No DNS servers configured for local system.
//



//
// Directory partition (DP) errors
//



// DNS_ERROR_DP_DOES_NOT_EXIST           0x000026ad
//
// MessageId: DNS_ERROR_DP_DOES_NOT_EXIST
//
// MessageText:
//
// The specified directory partition does not exist.
//


// DNS_ERROR_DP_ALREADY_EXISTS           0x000026ae
//
// MessageId: DNS_ERROR_DP_ALREADY_EXISTS
//
// MessageText:
//
// The specified directory partition already exists.
//


// DNS_ERROR_DP_NOT_ENLISTED             0x000026af
//
// MessageId: DNS_ERROR_DP_NOT_ENLISTED
//
// MessageText:
//
// This DNS server is not enlisted in the specified directory partition.
//


// DNS_ERROR_DP_ALREADY_ENLISTED         0x000026b0
//
// MessageId: DNS_ERROR_DP_ALREADY_ENLISTED
//
// MessageText:
//
// This DNS server is already enlisted in the specified directory partition.
//


// DNS_ERROR_DP_NOT_AVAILABLE            0x000026b1
//
// MessageId: DNS_ERROR_DP_NOT_AVAILABLE
//
// MessageText:
//
// The directory partition is not available at this time. Please wait a few minutes and try again.
//


// DNS_ERROR_DP_FSMO_ERROR               0x000026b2
//
// MessageId: DNS_ERROR_DP_FSMO_ERROR
//
// MessageText:
//
// The operation failed because the domain naming master FSMO role could not be reached. The domain controller holding the domain naming master FSMO role is down or unable to service the request or is not running Windows Server 2003 or later.
//


//
// DNS RRL errors from 9911 to 9920
//
// DNS_ERROR_RRL_NOT_ENABLED 0x000026B7
//
// MessageId: DNS_ERROR_RRL_NOT_ENABLED
//
// MessageText:
//
// The RRL is not enabled.
//


// DNS_ERROR_RRL_INVALID_WINDOW_SIZE 0x000026B8
//
// MessageId: DNS_ERROR_RRL_INVALID_WINDOW_SIZE
//
// MessageText:
//
// The window size parameter is invalid. It should be greater than or equal to 1.
//


// DNS_ERROR_RRL_INVALID_IPV4_PREFIX 0x000026B9
//
// MessageId: DNS_ERROR_RRL_INVALID_IPV4_PREFIX
//
// MessageText:
//
// The IPv4 prefix length parameter is invalid. It should be less than or equal to 32.
//


// DNS_ERROR_RRL_INVALID_IPV6_PREFIX 0x000026BA
//
// MessageId: DNS_ERROR_RRL_INVALID_IPV6_PREFIX
//
// MessageText:
//
// The IPv6 prefix length parameter is invalid. It should be less than or equal to 128.
//


// DNS_ERROR_RRL_INVALID_TC_RATE 0x000026BB
//
// MessageId: DNS_ERROR_RRL_INVALID_TC_RATE
//
// MessageText:
//
// The TC Rate parameter is invalid. It should be less than 10.
//


// DNS_ERROR_RRL_INVALID_LEAK_RATE 0x000026BC
//
// MessageId: DNS_ERROR_RRL_INVALID_LEAK_RATE
//
// MessageText:
//
// The Leak Rate parameter is invalid. It should be either 0, or between 2 and 10.
//


// DNS_ERROR_RRL_LEAK_RATE_LESSTHAN_TC_RATE 0x000026BD
//
// MessageId: DNS_ERROR_RRL_LEAK_RATE_LESSTHAN_TC_RATE
//
// MessageText:
//
// The Leak Rate or TC Rate parameter is invalid. Leak Rate should be greater than TC Rate.
//



//
// DNS Virtualization errors from 9921 to 9950
//
// DNS_ERROR_VIRTUALIZATION_INSTANCE_ALREADY_EXISTS    0x000026c1
//
// MessageId: DNS_ERROR_VIRTUALIZATION_INSTANCE_ALREADY_EXISTS
//
// MessageText:
//
// The virtualization instance already exists.
//


// DNS_ERROR_VIRTUALIZATION_INSTANCE_DOES_NOT_EXIST    0x000026c2
//
// MessageId: DNS_ERROR_VIRTUALIZATION_INSTANCE_DOES_NOT_EXIST
//
// MessageText:
//
// The virtualization instance does not exist.
//


// DNS_ERROR_VIRTUALIZATION_TREE_LOCKED        0x000026c3
//
// MessageId: DNS_ERROR_VIRTUALIZATION_TREE_LOCKED
//
// MessageText:
//
// The virtualization tree is locked.
//


// DNS_ERROR_INVAILD_VIRTUALIZATION_INSTANCE_NAME      0x000026c4
//
// MessageId: DNS_ERROR_INVAILD_VIRTUALIZATION_INSTANCE_NAME
//
// MessageText:
//
// Invalid virtualization instance name.
//


// DNS_ERROR_DEFAULT_VIRTUALIZATION_INSTANCE   0x000026c5
//
// MessageId: DNS_ERROR_DEFAULT_VIRTUALIZATION_INSTANCE
//
// MessageText:
//
// The default virtualization instance cannot be added, removed or modified.
//



//
// DNS ZoneScope errors from 9951 to 9970
//
// DNS_ERROR_ZONESCOPE_ALREADY_EXISTS               0x000026df
//
// MessageId: DNS_ERROR_ZONESCOPE_ALREADY_EXISTS
//
// MessageText:
//
// The scope already exists for the zone.
//


// DNS_ERROR_ZONESCOPE_DOES_NOT_EXIST       0x000026e0
//
// MessageId: DNS_ERROR_ZONESCOPE_DOES_NOT_EXIST
//
// MessageText:
//
// The scope does not exist for the zone.
//


// DNS_ERROR_DEFAULT_ZONESCOPE 0x000026e1
//
// MessageId: DNS_ERROR_DEFAULT_ZONESCOPE
//
// MessageText:
//
// The scope is the same as the default zone scope.
//


// DNS_ERROR_INVALID_ZONESCOPE_NAME 0x000026e2
//
// MessageId: DNS_ERROR_INVALID_ZONESCOPE_NAME
//
// MessageText:
//
// The scope name contains invalid characters.
//


// DNS_ERROR_NOT_ALLOWED_WITH_ZONESCOPES 0x000026e3
//
// MessageId: DNS_ERROR_NOT_ALLOWED_WITH_ZONESCOPES
//
// MessageText:
//
// Operation not allowed when the zone has scopes.
//


// DNS_ERROR_LOAD_ZONESCOPE_FAILED 0x000026e4
//
// MessageId: DNS_ERROR_LOAD_ZONESCOPE_FAILED
//
// MessageText:
//
// Failed to load zone scope.
//


// DNS_ERROR_ZONESCOPE_FILE_WRITEBACK_FAILED 0x000026e5
//
// MessageId: DNS_ERROR_ZONESCOPE_FILE_WRITEBACK_FAILED
//
// MessageText:
//
// Failed to write data file for DNS zone scope. Please verify the file exists and is writable.
//


// DNS_ERROR_INVALID_SCOPE_NAME 0x000026e6
//
// MessageId: DNS_ERROR_INVALID_SCOPE_NAME
//
// MessageText:
//
// The scope name contains invalid characters.
//


// DNS_ERROR_SCOPE_DOES_NOT_EXIST       0x000026e7
//
// MessageId: DNS_ERROR_SCOPE_DOES_NOT_EXIST
//
// MessageText:
//
// The scope does not exist.
//


// DNS_ERROR_DEFAULT_SCOPE 0x000026e8
//
// MessageId: DNS_ERROR_DEFAULT_SCOPE
//
// MessageText:
//
// The scope is the same as the default scope.
//


// DNS_ERROR_INVALID_SCOPE_OPERATION 0x000026e9
//
// MessageId: DNS_ERROR_INVALID_SCOPE_OPERATION
//
// MessageText:
//
// The operation is invalid on the scope.
//


// DNS_ERROR_SCOPE_LOCKED 0x000026ea
//
// MessageId: DNS_ERROR_SCOPE_LOCKED
//
// MessageText:
//
// The scope is locked.
//


// DNS_ERROR_SCOPE_ALREADY_EXISTS 0x000026eb
//
// MessageId: DNS_ERROR_SCOPE_ALREADY_EXISTS
//
// MessageText:
//
// The scope already exists.
//



//
// DNS Policy errors from 9971 to 9999
//
// DNS_ERROR_POLICY_ALREADY_EXISTS 0x000026f3
//
// MessageId: DNS_ERROR_POLICY_ALREADY_EXISTS
//
// MessageText:
//
// A policy with the same name already exists on this level (server level or zone level) on the DNS server.
//


// DNS_ERROR_POLICY_DOES_NOT_EXIST 0x000026f4
//
// MessageId: DNS_ERROR_POLICY_DOES_NOT_EXIST
//
// MessageText:
//
// No policy with this name exists on this level (server level or zone level) on the DNS server.
//


// DNS_ERROR_POLICY_INVALID_CRITERIA 0x000026f5
//
// MessageId: DNS_ERROR_POLICY_INVALID_CRITERIA
//
// MessageText:
//
// The criteria provided in the policy are invalid.
//


// DNS_ERROR_POLICY_INVALID_SETTINGS 0x000026f6
//
// MessageId: DNS_ERROR_POLICY_INVALID_SETTINGS
//
// MessageText:
//
// At least one of the settings of this policy is invalid.
//


// DNS_ERROR_CLIENT_SUBNET_IS_ACCESSED 0x000026f7
//
// MessageId: DNS_ERROR_CLIENT_SUBNET_IS_ACCESSED
//
// MessageText:
//
// The client subnet cannot be deleted while it is being accessed by a policy.
//


// DNS_ERROR_CLIENT_SUBNET_DOES_NOT_EXIST 0x000026f8
//
// MessageId: DNS_ERROR_CLIENT_SUBNET_DOES_NOT_EXIST
//
// MessageText:
//
// The client subnet does not exist on the DNS server.
//


// DNS_ERROR_CLIENT_SUBNET_ALREADY_EXISTS 0x000026f9
//
// MessageId: DNS_ERROR_CLIENT_SUBNET_ALREADY_EXISTS
//
// MessageText:
//
// A client subnet with this name already exists on the DNS server.
//


// DNS_ERROR_SUBNET_DOES_NOT_EXIST 0x000026fa
//
// MessageId: DNS_ERROR_SUBNET_DOES_NOT_EXIST
//
// MessageText:
//
// The IP subnet specified does not exist in the client subnet.
//


// DNS_ERROR_SUBNET_ALREADY_EXISTS 0x000026fb
//
// MessageId: DNS_ERROR_SUBNET_ALREADY_EXISTS
//
// MessageText:
//
// The IP subnet that is being added, already exists in the client subnet.
//


// DNS_ERROR_POLICY_LOCKED 0x000026fc
//
// MessageId: DNS_ERROR_POLICY_LOCKED
//
// MessageText:
//
// The policy is locked.
//


// DNS_ERROR_POLICY_INVALID_WEIGHT 0x000026fd
//
// MessageId: DNS_ERROR_POLICY_INVALID_WEIGHT
//
// MessageText:
//
// The weight of the scope in the policy is invalid.
//


// DNS_ERROR_POLICY_INVALID_NAME 0x000026fe
//
// MessageId: DNS_ERROR_POLICY_INVALID_NAME
//
// MessageText:
//
// The DNS policy name is invalid.
//


// DNS_ERROR_POLICY_MISSING_CRITERIA 0x000026ff
//
// MessageId: DNS_ERROR_POLICY_MISSING_CRITERIA
//
// MessageText:
//
// The policy is missing criteria.
//


// DNS_ERROR_INVALID_CLIENT_SUBNET_NAME 0x00002700
//
// MessageId: DNS_ERROR_INVALID_CLIENT_SUBNET_NAME
//
// MessageText:
//
// The name of the the client subnet record is invalid.
//


// DNS_ERROR_POLICY_PROCESSING_ORDER_INVALID 0x00002701
//
// MessageId: DNS_ERROR_POLICY_PROCESSING_ORDER_INVALID
//
// MessageText:
//
// Invalid policy processing order.
//


// DNS_ERROR_POLICY_SCOPE_MISSING 0x00002702
//
// MessageId: DNS_ERROR_POLICY_SCOPE_MISSING
//
// MessageText:
//
// The scope information has not been provided for a policy that requires it.
//


// DNS_ERROR_POLICY_SCOPE_NOT_ALLOWED 0x00002703
//
// MessageId: DNS_ERROR_POLICY_SCOPE_NOT_ALLOWED
//
// MessageText:
//
// The scope information has been provided for a policy that does not require it.
//


// DNS_ERROR_SERVERSCOPE_IS_REFERENCED 0x00002704
//
// MessageId: DNS_ERROR_SERVERSCOPE_IS_REFERENCED
//
// MessageText:
//
// The server scope cannot be deleted because it is referenced by a DNS Policy.
//


// DNS_ERROR_ZONESCOPE_IS_REFERENCED 0x00002705
//
// MessageId: DNS_ERROR_ZONESCOPE_IS_REFERENCED
//
// MessageText:
//
// The zone scope cannot be deleted because it is referenced by a DNS Policy.
//


// DNS_ERROR_POLICY_INVALID_CRITERIA_CLIENT_SUBNET 0x00002706
//
// MessageId: DNS_ERROR_POLICY_INVALID_CRITERIA_CLIENT_SUBNET
//
// MessageText:
//
// The criterion client subnet provided in the policy is invalid.
//


// DNS_ERROR_POLICY_INVALID_CRITERIA_TRANSPORT_PROTOCOL 0x00002707
//
// MessageId: DNS_ERROR_POLICY_INVALID_CRITERIA_TRANSPORT_PROTOCOL
//
// MessageText:
//
// The criterion transport protocol provided in the policy is invalid.
//


// DNS_ERROR_POLICY_INVALID_CRITERIA_NETWORK_PROTOCOL 0x00002708
//
// MessageId: DNS_ERROR_POLICY_INVALID_CRITERIA_NETWORK_PROTOCOL
//
// MessageText:
//
// The criterion network protocol provided in the policy is invalid.
//


// DNS_ERROR_POLICY_INVALID_CRITERIA_INTERFACE 0x00002709
//
// MessageId: DNS_ERROR_POLICY_INVALID_CRITERIA_INTERFACE
//
// MessageText:
//
// The criterion interface provided in the policy is invalid.
//


// DNS_ERROR_POLICY_INVALID_CRITERIA_FQDN 0x0000270A
//
// MessageId: DNS_ERROR_POLICY_INVALID_CRITERIA_FQDN
//
// MessageText:
//
// The criterion FQDN provided in the policy is invalid.
//


// DNS_ERROR_POLICY_INVALID_CRITERIA_QUERY_TYPE 0x0000270B
//
// MessageId: DNS_ERROR_POLICY_INVALID_CRITERIA_QUERY_TYPE
//
// MessageText:
//
// The criterion query type provided in the policy is invalid.
//


// DNS_ERROR_POLICY_INVALID_CRITERIA_TIME_OF_DAY 0x0000270C
//
// MessageId: DNS_ERROR_POLICY_INVALID_CRITERIA_TIME_OF_DAY
//
// MessageText:
//
// The criterion time of day provided in the policy is invalid.
//





///////////////////////////////////////////////////
//                                               //
//             End of DNS Error Codes            //
//                                               //
//                  9000 to 9999                 //
///////////////////////////////////////////////////


///////////////////////////////////////////////////
//                                               //
//               WinSock Error Codes             //
//                                               //
//                 10000 to 11999                //
///////////////////////////////////////////////////

//
// WinSock error codes are also defined in WinSock.h
// and WinSock2.h, hence the IFDEF
//


//
// MessageId: WSAEINTR
//
// MessageText:
//
// A blocking operation was interrupted by a call to WSACancelBlockingCall.
//


//
// MessageId: WSAEBADF
//
// MessageText:
//
// The file handle supplied is not valid.
//


//
// MessageId: WSAEACCES
//
// MessageText:
//
// An attempt was made to access a socket in a way forbidden by its access permissions.
//


//
// MessageId: WSAEFAULT
//
// MessageText:
//
// The system detected an invalid pointer address in attempting to use a pointer argument in a call.
//


//
// MessageId: WSAEINVAL
//
// MessageText:
//
// An invalid argument was supplied.
//


//
// MessageId: WSAEMFILE
//
// MessageText:
//
// Too many open sockets.
//


//
// MessageId: WSAEWOULDBLOCK
//
// MessageText:
//
// A non-blocking socket operation could not be completed immediately.
//


//
// MessageId: WSAEINPROGRESS
//
// MessageText:
//
// A blocking operation is currently executing.
//


//
// MessageId: WSAEALREADY
//
// MessageText:
//
// An operation was attempted on a non-blocking socket that already had an operation in progress.
//


//
// MessageId: WSAENOTSOCK
//
// MessageText:
//
// An operation was attempted on something that is not a socket.
//


//
// MessageId: WSAEDESTADDRREQ
//
// MessageText:
//
// A required address was omitted from an operation on a socket.
//


//
// MessageId: WSAEMSGSIZE
//
// MessageText:
//
// A message sent on a datagram socket was larger than the internal message buffer or some other network limit, or the buffer used to receive a datagram into was smaller than the datagram itself.
//


//
// MessageId: WSAEPROTOTYPE
//
// MessageText:
//
// A protocol was specified in the socket function call that does not support the semantics of the socket type requested.
//


//
// MessageId: WSAENOPROTOOPT
//
// MessageText:
//
// An unknown, invalid, or unsupported option or level was specified in a getsockopt or setsockopt call.
//


//
// MessageId: WSAEPROTONOSUPPORT
//
// MessageText:
//
// The requested protocol has not been configured into the system, or no implementation for it exists.
//


//
// MessageId: WSAESOCKTNOSUPPORT
//
// MessageText:
//
// The support for the specified socket type does not exist in this address family.
//


//
// MessageId: WSAEOPNOTSUPP
//
// MessageText:
//
// The attempted operation is not supported for the type of object referenced.
//


//
// MessageId: WSAEPFNOSUPPORT
//
// MessageText:
//
// The protocol family has not been configured into the system or no implementation for it exists.
//


//
// MessageId: WSAEAFNOSUPPORT
//
// MessageText:
//
// An address incompatible with the requested protocol was used.
//


//
// MessageId: WSAEADDRINUSE
//
// MessageText:
//
// Only one usage of each socket address (protocol/network address/port) is normally permitted.
//


//
// MessageId: WSAEADDRNOTAVAIL
//
// MessageText:
//
// The requested address is not valid in its context.
//


//
// MessageId: WSAENETDOWN
//
// MessageText:
//
// A socket operation encountered a dead network.
//


//
// MessageId: WSAENETUNREACH
//
// MessageText:
//
// A socket operation was attempted to an unreachable network.
//


//
// MessageId: WSAENETRESET
//
// MessageText:
//
// The connection has been broken due to keep-alive activity detecting a failure while the operation was in progress.
//


//
// MessageId: WSAECONNABORTED
//
// MessageText:
//
// An established connection was aborted by the software in your host machine.
//


//
// MessageId: WSAECONNRESET
//
// MessageText:
//
// An existing connection was forcibly closed by the remote host.
//


//
// MessageId: WSAENOBUFS
//
// MessageText:
//
// An operation on a socket could not be performed because the system lacked sufficient buffer space or because a queue was full.
//


//
// MessageId: WSAEISCONN
//
// MessageText:
//
// A connect request was made on an already connected socket.
//


//
// MessageId: WSAENOTCONN
//
// MessageText:
//
// A request to send or receive data was disallowed because the socket is not connected and (when sending on a datagram socket using a sendto call) no address was supplied.
//


//
// MessageId: WSAESHUTDOWN
//
// MessageText:
//
// A request to send or receive data was disallowed because the socket had already been shut down in that direction with a previous shutdown call.
//


//
// MessageId: WSAETOOMANYREFS
//
// MessageText:
//
// Too many references to some kernel object.
//


//
// MessageId: WSAETIMEDOUT
//
// MessageText:
//
// A connection attempt failed because the connected party did not properly respond after a period of time, or established connection failed because connected host has failed to respond.
//


//
// MessageId: WSAECONNREFUSED
//
// MessageText:
//
// No connection could be made because the target machine actively refused it.
//


//
// MessageId: WSAELOOP
//
// MessageText:
//
// Cannot translate name.
//


//
// MessageId: WSAENAMETOOLONG
//
// MessageText:
//
// Name component or name was too long.
//


//
// MessageId: WSAEHOSTDOWN
//
// MessageText:
//
// A socket operation failed because the destination host was down.
//


//
// MessageId: WSAEHOSTUNREACH
//
// MessageText:
//
// A socket operation was attempted to an unreachable host.
//


//
// MessageId: WSAENOTEMPTY
//
// MessageText:
//
// Cannot remove a directory that is not empty.
//


//
// MessageId: WSAEPROCLIM
//
// MessageText:
//
// A Windows Sockets implementation may have a limit on the number of applications that may use it simultaneously.
//


//
// MessageId: WSAEUSERS
//
// MessageText:
//
// Ran out of quota.
//


//
// MessageId: WSAEDQUOT
//
// MessageText:
//
// Ran out of disk quota.
//


//
// MessageId: WSAESTALE
//
// MessageText:
//
// File handle reference is no longer available.
//


//
// MessageId: WSAEREMOTE
//
// MessageText:
//
// Item is not available locally.
//


//
// MessageId: WSASYSNOTREADY
//
// MessageText:
//
// WSAStartup cannot function at this time because the underlying system it uses to provide network services is currently unavailable.
//


//
// MessageId: WSAVERNOTSUPPORTED
//
// MessageText:
//
// The Windows Sockets version requested is not supported.
//


//
// MessageId: WSANOTINITIALISED
//
// MessageText:
//
// Either the application has not called WSAStartup, or WSAStartup failed.
//


//
// MessageId: WSAEDISCON
//
// MessageText:
//
// Returned by WSARecv or WSARecvFrom to indicate the remote party has initiated a graceful shutdown sequence.
//


//
// MessageId: WSAENOMORE
//
// MessageText:
//
// No more results can be returned by WSALookupServiceNext.
//


//
// MessageId: WSAECANCELLED
//
// MessageText:
//
// A call to WSALookupServiceEnd was made while this call was still processing. The call has been canceled.
//


//
// MessageId: WSAEINVALIDPROCTABLE
//
// MessageText:
//
// The procedure call table is invalid.
//


//
// MessageId: WSAEINVALIDPROVIDER
//
// MessageText:
//
// The requested service provider is invalid.
//


//
// MessageId: WSAEPROVIDERFAILEDINIT
//
// MessageText:
//
// The requested service provider could not be loaded or initialized.
//


//
// MessageId: WSASYSCALLFAILURE
//
// MessageText:
//
// A system call has failed.
//


//
// MessageId: WSASERVICE_NOT_FOUND
//
// MessageText:
//
// No such service is known. The service cannot be found in the specified name space.
//


//
// MessageId: WSATYPE_NOT_FOUND
//
// MessageText:
//
// The specified class was not found.
//


//
// MessageId: WSA_E_NO_MORE
//
// MessageText:
//
// No more results can be returned by WSALookupServiceNext.
//


//
// MessageId: WSA_E_CANCELLED
//
// MessageText:
//
// A call to WSALookupServiceEnd was made while this call was still processing. The call has been canceled.
//


//
// MessageId: WSAEREFUSED
//
// MessageText:
//
// A database query failed because it was actively refused.
//


//
// MessageId: WSAHOST_NOT_FOUND
//
// MessageText:
//
// No such host is known.
//


//
// MessageId: WSATRY_AGAIN
//
// MessageText:
//
// This is usually a temporary error during hostname resolution and means that the local server did not receive a response from an authoritative server.
//


//
// MessageId: WSANO_RECOVERY
//
// MessageText:
//
// A non-recoverable error occurred during a database lookup.
//


//
// MessageId: WSANO_DATA
//
// MessageText:
//
// The requested name is valid, but no data of the requested type was found.
//


//
// MessageId: WSA_QOS_RECEIVERS
//
// MessageText:
//
// At least one reserve has arrived.
//


//
// MessageId: WSA_QOS_SENDERS
//
// MessageText:
//
// At least one path has arrived.
//


//
// MessageId: WSA_QOS_NO_SENDERS
//
// MessageText:
//
// There are no senders.
//


//
// MessageId: WSA_QOS_NO_RECEIVERS
//
// MessageText:
//
// There are no receivers.
//


//
// MessageId: WSA_QOS_REQUEST_CONFIRMED
//
// MessageText:
//
// Reserve has been confirmed.
//


//
// MessageId: WSA_QOS_ADMISSION_FAILURE
//
// MessageText:
//
// Error due to lack of resources.
//


//
// MessageId: WSA_QOS_POLICY_FAILURE
//
// MessageText:
//
// Rejected for administrative reasons - bad credentials.
//


//
// MessageId: WSA_QOS_BAD_STYLE
//
// MessageText:
//
// Unknown or conflicting style.
//


//
// MessageId: WSA_QOS_BAD_OBJECT
//
// MessageText:
//
// Problem with some part of the filterspec or providerspecific buffer in general.
//


//
// MessageId: WSA_QOS_TRAFFIC_CTRL_ERROR
//
// MessageText:
//
// Problem with some part of the flowspec.
//


//
// MessageId: WSA_QOS_GENERIC_ERROR
//
// MessageText:
//
// General QOS error.
//


//
// MessageId: WSA_QOS_ESERVICETYPE
//
// MessageText:
//
// An invalid or unrecognized service type was found in the flowspec.
//


//
// MessageId: WSA_QOS_EFLOWSPEC
//
// MessageText:
//
// An invalid or inconsistent flowspec was found in the QOS structure.
//


//
// MessageId: WSA_QOS_EPROVSPECBUF
//
// MessageText:
//
// Invalid QOS provider-specific buffer.
//


//
// MessageId: WSA_QOS_EFILTERSTYLE
//
// MessageText:
//
// An invalid QOS filter style was used.
//


//
// MessageId: WSA_QOS_EFILTERTYPE
//
// MessageText:
//
// An invalid QOS filter type was used.
//


//
// MessageId: WSA_QOS_EFILTERCOUNT
//
// MessageText:
//
// An incorrect number of QOS FILTERSPECs were specified in the FLOWDESCRIPTOR.
//


//
// MessageId: WSA_QOS_EOBJLENGTH
//
// MessageText:
//
// An object with an invalid ObjectLength field was specified in the QOS provider-specific buffer.
//


//
// MessageId: WSA_QOS_EFLOWCOUNT
//
// MessageText:
//
// An incorrect number of flow descriptors was specified in the QOS structure.
//


//
// MessageId: WSA_QOS_EUNKOWNPSOBJ
//
// MessageText:
//
// An unrecognized object was found in the QOS provider-specific buffer.
//


//
// MessageId: WSA_QOS_EPOLICYOBJ
//
// MessageText:
//
// An invalid policy object was found in the QOS provider-specific buffer.
//


//
// MessageId: WSA_QOS_EFLOWDESC
//
// MessageText:
//
// An invalid QOS flow descriptor was found in the flow descriptor list.
//


//
// MessageId: WSA_QOS_EPSFLOWSPEC
//
// MessageText:
//
// An invalid or inconsistent flowspec was found in the QOS provider specific buffer.
//


//
// MessageId: WSA_QOS_EPSFILTERSPEC
//
// MessageText:
//
// An invalid FILTERSPEC was found in the QOS provider-specific buffer.
//


//
// MessageId: WSA_QOS_ESDMODEOBJ
//
// MessageText:
//
// An invalid shape discard mode object was found in the QOS provider specific buffer.
//


//
// MessageId: WSA_QOS_ESHAPERATEOBJ
//
// MessageText:
//
// An invalid shaping rate object was found in the QOS provider-specific buffer.
//


//
// MessageId: WSA_QOS_RESERVED_PETYPE
//
// MessageText:
//
// A reserved policy element was found in the QOS provider-specific buffer.
//


//
// MessageId: WSA_SECURE_HOST_NOT_FOUND
//
// MessageText:
//
// No such host is known securely.
//


//
// MessageId: WSA_IPSEC_NAME_POLICY_ERROR
//
// MessageText:
//
// Name based IPSEC policy could not be added.
//


#line 24295 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\shared\\winerror.h"

///////////////////////////////////////////////////
//                                               //
//           End of WinSock Error Codes          //
//                                               //
//                 10000 to 11999                //
///////////////////////////////////////////////////


///////////////////////////////////////////////////
//                                               //
//                  Available                    //
//                                               //
//                 12000 to 12999                //
///////////////////////////////////////////////////


///////////////////////////////////////////////////
//                                               //
//           Start of IPSec Error codes          //
//                                               //
//                 13000 to 13999                //
///////////////////////////////////////////////////

//
// MessageId: ERROR_IPSEC_QM_POLICY_EXISTS
//
// MessageText:
//
// The specified quick mode policy already exists.
//


//
// MessageId: ERROR_IPSEC_QM_POLICY_NOT_FOUND
//
// MessageText:
//
// The specified quick mode policy was not found.
//


//
// MessageId: ERROR_IPSEC_QM_POLICY_IN_USE
//
// MessageText:
//
// The specified quick mode policy is being used.
//


//
// MessageId: ERROR_IPSEC_MM_POLICY_EXISTS
//
// MessageText:
//
// The specified main mode policy already exists.
//


//
// MessageId: ERROR_IPSEC_MM_POLICY_NOT_FOUND
//
// MessageText:
//
// The specified main mode policy was not found
//


//
// MessageId: ERROR_IPSEC_MM_POLICY_IN_USE
//
// MessageText:
//
// The specified main mode policy is being used.
//


//
// MessageId: ERROR_IPSEC_MM_FILTER_EXISTS
//
// MessageText:
//
// The specified main mode filter already exists.
//


//
// MessageId: ERROR_IPSEC_MM_FILTER_NOT_FOUND
//
// MessageText:
//
// The specified main mode filter was not found.
//


//
// MessageId: ERROR_IPSEC_TRANSPORT_FILTER_EXISTS
//
// MessageText:
//
// The specified transport mode filter already exists.
//


//
// MessageId: ERROR_IPSEC_TRANSPORT_FILTER_NOT_FOUND
//
// MessageText:
//
// The specified transport mode filter does not exist.
//


//
// MessageId: ERROR_IPSEC_MM_AUTH_EXISTS
//
// MessageText:
//
// The specified main mode authentication list exists.
//


//
// MessageId: ERROR_IPSEC_MM_AUTH_NOT_FOUND
//
// MessageText:
//
// The specified main mode authentication list was not found.
//


//
// MessageId: ERROR_IPSEC_MM_AUTH_IN_USE
//
// MessageText:
//
// The specified main mode authentication list is being used.
//


//
// MessageId: ERROR_IPSEC_DEFAULT_MM_POLICY_NOT_FOUND
//
// MessageText:
//
// The specified default main mode policy was not found.
//


//
// MessageId: ERROR_IPSEC_DEFAULT_MM_AUTH_NOT_FOUND
//
// MessageText:
//
// The specified default main mode authentication list was not found.
//


//
// MessageId: ERROR_IPSEC_DEFAULT_QM_POLICY_NOT_FOUND
//
// MessageText:
//
// The specified default quick mode policy was not found.
//


//
// MessageId: ERROR_IPSEC_TUNNEL_FILTER_EXISTS
//
// MessageText:
//
// The specified tunnel mode filter exists.
//


//
// MessageId: ERROR_IPSEC_TUNNEL_FILTER_NOT_FOUND
//
// MessageText:
//
// The specified tunnel mode filter was not found.
//


//
// MessageId: ERROR_IPSEC_MM_FILTER_PENDING_DELETION
//
// MessageText:
//
// The Main Mode filter is pending deletion.
//


//
// MessageId: ERROR_IPSEC_TRANSPORT_FILTER_PENDING_DELETION
//
// MessageText:
//
// The transport filter is pending deletion.
//


//
// MessageId: ERROR_IPSEC_TUNNEL_FILTER_PENDING_DELETION
//
// MessageText:
//
// The tunnel filter is pending deletion.
//


//
// MessageId: ERROR_IPSEC_MM_POLICY_PENDING_DELETION
//
// MessageText:
//
// The Main Mode policy is pending deletion.
//


//
// MessageId: ERROR_IPSEC_MM_AUTH_PENDING_DELETION
//
// MessageText:
//
// The Main Mode authentication bundle is pending deletion.
//


//
// MessageId: ERROR_IPSEC_QM_POLICY_PENDING_DELETION
//
// MessageText:
//
// The Quick Mode policy is pending deletion.
//


//
// MessageId: WARNING_IPSEC_MM_POLICY_PRUNED
//
// MessageText:
//
// The Main Mode policy was successfully added, but some of the requested offers are not supported.
//


//
// MessageId: WARNING_IPSEC_QM_POLICY_PRUNED
//
// MessageText:
//
// The Quick Mode policy was successfully added, but some of the requested offers are not supported.
//


//
// MessageId: ERROR_IPSEC_IKE_NEG_STATUS_BEGIN
//
// MessageText:
//
//  ERROR_IPSEC_IKE_NEG_STATUS_BEGIN
//


//
// MessageId: ERROR_IPSEC_IKE_AUTH_FAIL
//
// MessageText:
//
// IKE authentication credentials are unacceptable
//


//
// MessageId: ERROR_IPSEC_IKE_ATTRIB_FAIL
//
// MessageText:
//
// IKE security attributes are unacceptable
//


//
// MessageId: ERROR_IPSEC_IKE_NEGOTIATION_PENDING
//
// MessageText:
//
// IKE Negotiation in progress
//


//
// MessageId: ERROR_IPSEC_IKE_GENERAL_PROCESSING_ERROR
//
// MessageText:
//
// General processing error
//


//
// MessageId: ERROR_IPSEC_IKE_TIMED_OUT
//
// MessageText:
//
// Negotiation timed out
//


//
// MessageId: ERROR_IPSEC_IKE_NO_CERT
//
// MessageText:
//
// IKE failed to find valid machine certificate. Contact your Network Security Administrator about installing a valid certificate in the appropriate Certificate Store.
//


//
// MessageId: ERROR_IPSEC_IKE_SA_DELETED
//
// MessageText:
//
// IKE SA deleted by peer before establishment completed
//


//
// MessageId: ERROR_IPSEC_IKE_SA_REAPED
//
// MessageText:
//
// IKE SA deleted before establishment completed
//


//
// MessageId: ERROR_IPSEC_IKE_MM_ACQUIRE_DROP
//
// MessageText:
//
// Negotiation request sat in Queue too long
//


//
// MessageId: ERROR_IPSEC_IKE_QM_ACQUIRE_DROP
//
// MessageText:
//
// Negotiation request sat in Queue too long
//


//
// MessageId: ERROR_IPSEC_IKE_QUEUE_DROP_MM
//
// MessageText:
//
// Negotiation request sat in Queue too long
//


//
// MessageId: ERROR_IPSEC_IKE_QUEUE_DROP_NO_MM
//
// MessageText:
//
// Negotiation request sat in Queue too long
//


//
// MessageId: ERROR_IPSEC_IKE_DROP_NO_RESPONSE
//
// MessageText:
//
// No response from peer
//


//
// MessageId: ERROR_IPSEC_IKE_MM_DELAY_DROP
//
// MessageText:
//
// Negotiation took too long
//


//
// MessageId: ERROR_IPSEC_IKE_QM_DELAY_DROP
//
// MessageText:
//
// Negotiation took too long
//


//
// MessageId: ERROR_IPSEC_IKE_ERROR
//
// MessageText:
//
// Unknown error occurred
//


//
// MessageId: ERROR_IPSEC_IKE_CRL_FAILED
//
// MessageText:
//
// Certificate Revocation Check failed
//


//
// MessageId: ERROR_IPSEC_IKE_INVALID_KEY_USAGE
//
// MessageText:
//
// Invalid certificate key usage
//


//
// MessageId: ERROR_IPSEC_IKE_INVALID_CERT_TYPE
//
// MessageText:
//
// Invalid certificate type
//


//
// MessageId: ERROR_IPSEC_IKE_NO_PRIVATE_KEY
//
// MessageText:
//
// IKE negotiation failed because the machine certificate used does not have a private key. IPsec certificates require a private key. Contact your Network Security administrator about replacing with a certificate that has a private key.
//


//
// MessageId: ERROR_IPSEC_IKE_SIMULTANEOUS_REKEY
//
// MessageText:
//
// Simultaneous rekeys were detected.
//


//
// MessageId: ERROR_IPSEC_IKE_DH_FAIL
//
// MessageText:
//
// Failure in Diffie-Hellman computation
//


//
// MessageId: ERROR_IPSEC_IKE_CRITICAL_PAYLOAD_NOT_RECOGNIZED
//
// MessageText:
//
// Don't know how to process critical payload
//


//
// MessageId: ERROR_IPSEC_IKE_INVALID_HEADER
//
// MessageText:
//
// Invalid header
//


//
// MessageId: ERROR_IPSEC_IKE_NO_POLICY
//
// MessageText:
//
// No policy configured
//


//
// MessageId: ERROR_IPSEC_IKE_INVALID_SIGNATURE
//
// MessageText:
//
// Failed to verify signature
//


//
// MessageId: ERROR_IPSEC_IKE_KERBEROS_ERROR
//
// MessageText:
//
// Failed to authenticate using Kerberos
//


//
// MessageId: ERROR_IPSEC_IKE_NO_PUBLIC_KEY
//
// MessageText:
//
// Peer's certificate did not have a public key
//


// These must stay as a unit.
//
// MessageId: ERROR_IPSEC_IKE_PROCESS_ERR
//
// MessageText:
//
// Error processing error payload
//


//
// MessageId: ERROR_IPSEC_IKE_PROCESS_ERR_SA
//
// MessageText:
//
// Error processing SA payload
//


//
// MessageId: ERROR_IPSEC_IKE_PROCESS_ERR_PROP
//
// MessageText:
//
// Error processing Proposal payload
//


//
// MessageId: ERROR_IPSEC_IKE_PROCESS_ERR_TRANS
//
// MessageText:
//
// Error processing Transform payload
//


//
// MessageId: ERROR_IPSEC_IKE_PROCESS_ERR_KE
//
// MessageText:
//
// Error processing KE payload
//


//
// MessageId: ERROR_IPSEC_IKE_PROCESS_ERR_ID
//
// MessageText:
//
// Error processing ID payload
//


//
// MessageId: ERROR_IPSEC_IKE_PROCESS_ERR_CERT
//
// MessageText:
//
// Error processing Cert payload
//


//
// MessageId: ERROR_IPSEC_IKE_PROCESS_ERR_CERT_REQ
//
// MessageText:
//
// Error processing Certificate Request payload
//


//
// MessageId: ERROR_IPSEC_IKE_PROCESS_ERR_HASH
//
// MessageText:
//
// Error processing Hash payload
//


//
// MessageId: ERROR_IPSEC_IKE_PROCESS_ERR_SIG
//
// MessageText:
//
// Error processing Signature payload
//


//
// MessageId: ERROR_IPSEC_IKE_PROCESS_ERR_NONCE
//
// MessageText:
//
// Error processing Nonce payload
//


//
// MessageId: ERROR_IPSEC_IKE_PROCESS_ERR_NOTIFY
//
// MessageText:
//
// Error processing Notify payload
//


//
// MessageId: ERROR_IPSEC_IKE_PROCESS_ERR_DELETE
//
// MessageText:
//
// Error processing Delete Payload
//


//
// MessageId: ERROR_IPSEC_IKE_PROCESS_ERR_VENDOR
//
// MessageText:
//
// Error processing VendorId payload
//


//
// MessageId: ERROR_IPSEC_IKE_INVALID_PAYLOAD
//
// MessageText:
//
// Invalid payload received
//


//
// MessageId: ERROR_IPSEC_IKE_LOAD_SOFT_SA
//
// MessageText:
//
// Soft SA loaded
//


//
// MessageId: ERROR_IPSEC_IKE_SOFT_SA_TORN_DOWN
//
// MessageText:
//
// Soft SA torn down
//


//
// MessageId: ERROR_IPSEC_IKE_INVALID_COOKIE
//
// MessageText:
//
// Invalid cookie received.
//


//
// MessageId: ERROR_IPSEC_IKE_NO_PEER_CERT
//
// MessageText:
//
// Peer failed to send valid machine certificate
//


//
// MessageId: ERROR_IPSEC_IKE_PEER_CRL_FAILED
//
// MessageText:
//
// Certification Revocation check of peer's certificate failed
//


//
// MessageId: ERROR_IPSEC_IKE_POLICY_CHANGE
//
// MessageText:
//
// New policy invalidated SAs formed with old policy
//


//
// MessageId: ERROR_IPSEC_IKE_NO_MM_POLICY
//
// MessageText:
//
// There is no available Main Mode IKE policy.
//


//
// MessageId: ERROR_IPSEC_IKE_NOTCBPRIV
//
// MessageText:
//
// Failed to enabled TCB privilege.
//


//
// MessageId: ERROR_IPSEC_IKE_SECLOADFAIL
//
// MessageText:
//
// Failed to load SECURITY.DLL.
//


//
// MessageId: ERROR_IPSEC_IKE_FAILSSPINIT
//
// MessageText:
//
// Failed to obtain security function table dispatch address from SSPI.
//


//
// MessageId: ERROR_IPSEC_IKE_FAILQUERYSSP
//
// MessageText:
//
// Failed to query Kerberos package to obtain max token size.
//


//
// MessageId: ERROR_IPSEC_IKE_SRVACQFAIL
//
// MessageText:
//
// Failed to obtain Kerberos server credentials for ISAKMP/ERROR_IPSEC_IKE service. Kerberos authentication will not function. The most likely reason for this is lack of domain membership. This is normal if your computer is a member of a workgroup.
//


//
// MessageId: ERROR_IPSEC_IKE_SRVQUERYCRED
//
// MessageText:
//
// Failed to determine SSPI principal name for ISAKMP/ERROR_IPSEC_IKE service (QueryCredentialsAttributes).
//


//
// MessageId: ERROR_IPSEC_IKE_GETSPIFAIL
//
// MessageText:
//
// Failed to obtain new SPI for the inbound SA from IPsec driver. The most common cause for this is that the driver does not have the correct filter. Check your policy to verify the filters.
//


//
// MessageId: ERROR_IPSEC_IKE_INVALID_FILTER
//
// MessageText:
//
// Given filter is invalid
//


//
// MessageId: ERROR_IPSEC_IKE_OUT_OF_MEMORY
//
// MessageText:
//
// Memory allocation failed.
//


//
// MessageId: ERROR_IPSEC_IKE_ADD_UPDATE_KEY_FAILED
//
// MessageText:
//
// Failed to add Security Association to IPsec Driver. The most common cause for this is if the IKE negotiation took too long to complete. If the problem persists, reduce the load on the faulting machine.
//


//
// MessageId: ERROR_IPSEC_IKE_INVALID_POLICY
//
// MessageText:
//
// Invalid policy
//


//
// MessageId: ERROR_IPSEC_IKE_UNKNOWN_DOI
//
// MessageText:
//
// Invalid DOI
//


//
// MessageId: ERROR_IPSEC_IKE_INVALID_SITUATION
//
// MessageText:
//
// Invalid situation
//


//
// MessageId: ERROR_IPSEC_IKE_DH_FAILURE
//
// MessageText:
//
// Diffie-Hellman failure
//


//
// MessageId: ERROR_IPSEC_IKE_INVALID_GROUP
//
// MessageText:
//
// Invalid Diffie-Hellman group
//


//
// MessageId: ERROR_IPSEC_IKE_ENCRYPT
//
// MessageText:
//
// Error encrypting payload
//


//
// MessageId: ERROR_IPSEC_IKE_DECRYPT
//
// MessageText:
//
// Error decrypting payload
//


//
// MessageId: ERROR_IPSEC_IKE_POLICY_MATCH
//
// MessageText:
//
// Policy match error
//


//
// MessageId: ERROR_IPSEC_IKE_UNSUPPORTED_ID
//
// MessageText:
//
// Unsupported ID
//


//
// MessageId: ERROR_IPSEC_IKE_INVALID_HASH
//
// MessageText:
//
// Hash verification failed
//


//
// MessageId: ERROR_IPSEC_IKE_INVALID_HASH_ALG
//
// MessageText:
//
// Invalid hash algorithm
//


//
// MessageId: ERROR_IPSEC_IKE_INVALID_HASH_SIZE
//
// MessageText:
//
// Invalid hash size
//


//
// MessageId: ERROR_IPSEC_IKE_INVALID_ENCRYPT_ALG
//
// MessageText:
//
// Invalid encryption algorithm
//


//
// MessageId: ERROR_IPSEC_IKE_INVALID_AUTH_ALG
//
// MessageText:
//
// Invalid authentication algorithm
//


//
// MessageId: ERROR_IPSEC_IKE_INVALID_SIG
//
// MessageText:
//
// Invalid certificate signature
//


//
// MessageId: ERROR_IPSEC_IKE_LOAD_FAILED
//
// MessageText:
//
// Load failed
//


//
// MessageId: ERROR_IPSEC_IKE_RPC_DELETE
//
// MessageText:
//
// Deleted via RPC call
//


//
// MessageId: ERROR_IPSEC_IKE_BENIGN_REINIT
//
// MessageText:
//
// Temporary state created to perform reinitialization. This is not a real failure.
//


//
// MessageId: ERROR_IPSEC_IKE_INVALID_RESPONDER_LIFETIME_NOTIFY
//
// MessageText:
//
// The lifetime value received in the Responder Lifetime Notify is below the Windows 2000 configured minimum value. Please fix the policy on the peer machine.
//


//
// MessageId: ERROR_IPSEC_IKE_INVALID_MAJOR_VERSION
//
// MessageText:
//
// The recipient cannot handle version of IKE specified in the header.
//


//
// MessageId: ERROR_IPSEC_IKE_INVALID_CERT_KEYLEN
//
// MessageText:
//
// Key length in certificate is too small for configured security requirements.
//


//
// MessageId: ERROR_IPSEC_IKE_MM_LIMIT
//
// MessageText:
//
// Max number of established MM SAs to peer exceeded.
//


//
// MessageId: ERROR_IPSEC_IKE_NEGOTIATION_DISABLED
//
// MessageText:
//
// IKE received a policy that disables negotiation.
//


//
// MessageId: ERROR_IPSEC_IKE_QM_LIMIT
//
// MessageText:
//
// Reached maximum quick mode limit for the main mode. New main mode will be started.
//


//
// MessageId: ERROR_IPSEC_IKE_MM_EXPIRED
//
// MessageText:
//
// Main mode SA lifetime expired or peer sent a main mode delete.
//


//
// MessageId: ERROR_IPSEC_IKE_PEER_MM_ASSUMED_INVALID
//
// MessageText:
//
// Main mode SA assumed to be invalid because peer stopped responding.
//


//
// MessageId: ERROR_IPSEC_IKE_CERT_CHAIN_POLICY_MISMATCH
//
// MessageText:
//
// Certificate doesn't chain to a trusted root in IPsec policy.
//


//
// MessageId: ERROR_IPSEC_IKE_UNEXPECTED_MESSAGE_ID
//
// MessageText:
//
// Received unexpected message ID.
//


//
// MessageId: ERROR_IPSEC_IKE_INVALID_AUTH_PAYLOAD
//
// MessageText:
//
// Received invalid authentication offers.
//


//
// MessageId: ERROR_IPSEC_IKE_DOS_COOKIE_SENT
//
// MessageText:
//
// Sent DoS cookie notify to initiator.
//


//
// MessageId: ERROR_IPSEC_IKE_SHUTTING_DOWN
//
// MessageText:
//
// IKE service is shutting down.
//


//
// MessageId: ERROR_IPSEC_IKE_CGA_AUTH_FAILED
//
// MessageText:
//
// Could not verify binding between CGA address and certificate.
//


//
// MessageId: ERROR_IPSEC_IKE_PROCESS_ERR_NATOA
//
// MessageText:
//
// Error processing NatOA payload.
//


//
// MessageId: ERROR_IPSEC_IKE_INVALID_MM_FOR_QM
//
// MessageText:
//
// Parameters of the main mode are invalid for this quick mode.
//


//
// MessageId: ERROR_IPSEC_IKE_QM_EXPIRED
//
// MessageText:
//
// Quick mode SA was expired by IPsec driver.
//


//
// MessageId: ERROR_IPSEC_IKE_TOO_MANY_FILTERS
//
// MessageText:
//
// Too many dynamically added IKEEXT filters were detected.
//


// Do NOT change this final value.  It is used in a public API structure
//
// MessageId: ERROR_IPSEC_IKE_NEG_STATUS_END
//
// MessageText:
//
//  ERROR_IPSEC_IKE_NEG_STATUS_END
//


//
// MessageId: ERROR_IPSEC_IKE_KILL_DUMMY_NAP_TUNNEL
//
// MessageText:
//
// NAP reauth succeeded and must delete the dummy NAP IKEv2 tunnel.
//


//
// MessageId: ERROR_IPSEC_IKE_INNER_IP_ASSIGNMENT_FAILURE
//
// MessageText:
//
// Error in assigning inner IP address to initiator in tunnel mode.
//


//
// MessageId: ERROR_IPSEC_IKE_REQUIRE_CP_PAYLOAD_MISSING
//
// MessageText:
//
// Require configuration payload missing.
//


//
// MessageId: ERROR_IPSEC_KEY_MODULE_IMPERSONATION_NEGOTIATION_PENDING
//
// MessageText:
//
// A negotiation running as the security principle who issued the connection is in progress
//


//
// MessageId: ERROR_IPSEC_IKE_COEXISTENCE_SUPPRESS
//
// MessageText:
//
// SA was deleted due to IKEv1/AuthIP co-existence suppress check.
//


//
// MessageId: ERROR_IPSEC_IKE_RATELIMIT_DROP
//
// MessageText:
//
// Incoming SA request was dropped due to peer IP address rate limiting.
//


//
// MessageId: ERROR_IPSEC_IKE_PEER_DOESNT_SUPPORT_MOBIKE
//
// MessageText:
//
// Peer does not support MOBIKE.
//


//
// MessageId: ERROR_IPSEC_IKE_AUTHORIZATION_FAILURE
//
// MessageText:
//
// SA establishment is not authorized.
//


//
// MessageId: ERROR_IPSEC_IKE_STRONG_CRED_AUTHORIZATION_FAILURE
//
// MessageText:
//
// SA establishment is not authorized because there is not a sufficiently strong PKINIT-based credential.
//


//
// MessageId: ERROR_IPSEC_IKE_AUTHORIZATION_FAILURE_WITH_OPTIONAL_RETRY
//
// MessageText:
//
// SA establishment is not authorized.  You may need to enter updated or different credentials such as a smartcard.
//


//
// MessageId: ERROR_IPSEC_IKE_STRONG_CRED_AUTHORIZATION_AND_CERTMAP_FAILURE
//
// MessageText:
//
// SA establishment is not authorized because there is not a sufficiently strong PKINIT-based credential. This might be related to certificate-to-account mapping failure for the SA.
//


// Extended upper bound for IKE errors to accommodate new errors
//
// MessageId: ERROR_IPSEC_IKE_NEG_STATUS_EXTENDED_END
//
// MessageText:
//
//  ERROR_IPSEC_IKE_NEG_STATUS_EXTENDED_END
//


//
// Following error codes are returned by IPsec kernel.
//
//
// MessageId: ERROR_IPSEC_BAD_SPI
//
// MessageText:
//
// The SPI in the packet does not match a valid IPsec SA.
//


//
// MessageId: ERROR_IPSEC_SA_LIFETIME_EXPIRED
//
// MessageText:
//
// Packet was received on an IPsec SA whose lifetime has expired.
//


//
// MessageId: ERROR_IPSEC_WRONG_SA
//
// MessageText:
//
// Packet was received on an IPsec SA that does not match the packet characteristics.
//


//
// MessageId: ERROR_IPSEC_REPLAY_CHECK_FAILED
//
// MessageText:
//
// Packet sequence number replay check failed.
//


//
// MessageId: ERROR_IPSEC_INVALID_PACKET
//
// MessageText:
//
// IPsec header and/or trailer in the packet is invalid.
//


//
// MessageId: ERROR_IPSEC_INTEGRITY_CHECK_FAILED
//
// MessageText:
//
// IPsec integrity check failed.
//


//
// MessageId: ERROR_IPSEC_CLEAR_TEXT_DROP
//
// MessageText:
//
// IPsec dropped a clear text packet.
//


//
// MessageId: ERROR_IPSEC_AUTH_FIREWALL_DROP
//
// MessageText:
//
// IPsec dropped an incoming ESP packet in authenticated firewall mode. This drop is benign.
//


//
// MessageId: ERROR_IPSEC_THROTTLE_DROP
//
// MessageText:
//
// IPsec dropped a packet due to DoS throttling.
//


//
// MessageId: ERROR_IPSEC_DOSP_BLOCK
//
// MessageText:
//
// IPsec DoS Protection matched an explicit block rule.
//


//
// MessageId: ERROR_IPSEC_DOSP_RECEIVED_MULTICAST
//
// MessageText:
//
// IPsec DoS Protection received an IPsec specific multicast packet which is not allowed.
//


//
// MessageId: ERROR_IPSEC_DOSP_INVALID_PACKET
//
// MessageText:
//
// IPsec DoS Protection received an incorrectly formatted packet.
//


//
// MessageId: ERROR_IPSEC_DOSP_STATE_LOOKUP_FAILED
//
// MessageText:
//
// IPsec DoS Protection failed to look up state.
//


//
// MessageId: ERROR_IPSEC_DOSP_MAX_ENTRIES
//
// MessageText:
//
// IPsec DoS Protection failed to create state because the maximum number of entries allowed by policy has been reached.
//


//
// MessageId: ERROR_IPSEC_DOSP_KEYMOD_NOT_ALLOWED
//
// MessageText:
//
// IPsec DoS Protection received an IPsec negotiation packet for a keying module which is not allowed by policy.
//


//
// MessageId: ERROR_IPSEC_DOSP_NOT_INSTALLED
//
// MessageText:
//
// IPsec DoS Protection has not been enabled.
//


//
// MessageId: ERROR_IPSEC_DOSP_MAX_PER_IP_RATELIMIT_QUEUES
//
// MessageText:
//
// IPsec DoS Protection failed to create a per internal IP rate limit queue because the maximum number of queues allowed by policy has been reached.
//



///////////////////////////////////////////////////
//                                               //
//           End of IPSec Error codes            //
//                                               //
//                 13000 to 13999                //
///////////////////////////////////////////////////


///////////////////////////////////////////////////
//                                               //
//         Start of Side By Side Error Codes     //
//                                               //
//                 14000 to 14999                //
///////////////////////////////////////////////////

//
// MessageId: ERROR_SXS_SECTION_NOT_FOUND
//
// MessageText:
//
// The requested section was not present in the activation context.
//


//
// MessageId: ERROR_SXS_CANT_GEN_ACTCTX
//
// MessageText:
//
// The application has failed to start because its side-by-side configuration is incorrect. Please see the application event log or use the command-line sxstrace.exe tool for more detail.
//


//
// MessageId: ERROR_SXS_INVALID_ACTCTXDATA_FORMAT
//
// MessageText:
//
// The application binding data format is invalid.
//


//
// MessageId: ERROR_SXS_ASSEMBLY_NOT_FOUND
//
// MessageText:
//
// The referenced assembly is not installed on your system.
//


//
// MessageId: ERROR_SXS_MANIFEST_FORMAT_ERROR
//
// MessageText:
//
// The manifest file does not begin with the required tag and format information.
//


//
// MessageId: ERROR_SXS_MANIFEST_PARSE_ERROR
//
// MessageText:
//
// The manifest file contains one or more syntax errors.
//


//
// MessageId: ERROR_SXS_ACTIVATION_CONTEXT_DISABLED
//
// MessageText:
//
// The application attempted to activate a disabled activation context.
//


//
// MessageId: ERROR_SXS_KEY_NOT_FOUND
//
// MessageText:
//
// The requested lookup key was not found in any active activation context.
//


//
// MessageId: ERROR_SXS_VERSION_CONFLICT
//
// MessageText:
//
// A component version required by the application conflicts with another component version already active.
//


//
// MessageId: ERROR_SXS_WRONG_SECTION_TYPE
//
// MessageText:
//
// The type requested activation context section does not match the query API used.
//


//
// MessageId: ERROR_SXS_THREAD_QUERIES_DISABLED
//
// MessageText:
//
// Lack of system resources has required isolated activation to be disabled for the current thread of execution.
//


//
// MessageId: ERROR_SXS_PROCESS_DEFAULT_ALREADY_SET
//
// MessageText:
//
// An attempt to set the process default activation context failed because the process default activation context was already set.
//


//
// MessageId: ERROR_SXS_UNKNOWN_ENCODING_GROUP
//
// MessageText:
//
// The encoding group identifier specified is not recognized.
//


//
// MessageId: ERROR_SXS_UNKNOWN_ENCODING
//
// MessageText:
//
// The encoding requested is not recognized.
//


//
// MessageId: ERROR_SXS_INVALID_XML_NAMESPACE_URI
//
// MessageText:
//
// The manifest contains a reference to an invalid URI.
//


//
// MessageId: ERROR_SXS_ROOT_MANIFEST_DEPENDENCY_NOT_INSTALLED
//
// MessageText:
//
// The application manifest contains a reference to a dependent assembly which is not installed
//


//
// MessageId: ERROR_SXS_LEAF_MANIFEST_DEPENDENCY_NOT_INSTALLED
//
// MessageText:
//
// The manifest for an assembly used by the application has a reference to a dependent assembly which is not installed
//


//
// MessageId: ERROR_SXS_INVALID_ASSEMBLY_IDENTITY_ATTRIBUTE
//
// MessageText:
//
// The manifest contains an attribute for the assembly identity which is not valid.
//


//
// MessageId: ERROR_SXS_MANIFEST_MISSING_REQUIRED_DEFAULT_NAMESPACE
//
// MessageText:
//
// The manifest is missing the required default namespace specification on the assembly element.
//


//
// MessageId: ERROR_SXS_MANIFEST_INVALID_REQUIRED_DEFAULT_NAMESPACE
//
// MessageText:
//
// The manifest has a default namespace specified on the assembly element but its value is not "urn:schemas-microsoft-com:asm.v1".
//


//
// MessageId: ERROR_SXS_PRIVATE_MANIFEST_CROSS_PATH_WITH_REPARSE_POINT
//
// MessageText:
//
// The private manifest probed has crossed a path with an unsupported reparse point.
//


//
// MessageId: ERROR_SXS_DUPLICATE_DLL_NAME
//
// MessageText:
//
// Two or more components referenced directly or indirectly by the application manifest have files by the same name.
//


//
// MessageId: ERROR_SXS_DUPLICATE_WINDOWCLASS_NAME
//
// MessageText:
//
// Two or more components referenced directly or indirectly by the application manifest have window classes with the same name.
//


//
// MessageId: ERROR_SXS_DUPLICATE_CLSID
//
// MessageText:
//
// Two or more components referenced directly or indirectly by the application manifest have the same COM server CLSIDs.
//


//
// MessageId: ERROR_SXS_DUPLICATE_IID
//
// MessageText:
//
// Two or more components referenced directly or indirectly by the application manifest have proxies for the same COM interface IIDs.
//


//
// MessageId: ERROR_SXS_DUPLICATE_TLBID
//
// MessageText:
//
// Two or more components referenced directly or indirectly by the application manifest have the same COM type library TLBIDs.
//


//
// MessageId: ERROR_SXS_DUPLICATE_PROGID
//
// MessageText:
//
// Two or more components referenced directly or indirectly by the application manifest have the same COM ProgIDs.
//


//
// MessageId: ERROR_SXS_DUPLICATE_ASSEMBLY_NAME
//
// MessageText:
//
// Two or more components referenced directly or indirectly by the application manifest are different versions of the same component which is not permitted.
//


//
// MessageId: ERROR_SXS_FILE_HASH_MISMATCH
//
// MessageText:
//
// A component's file does not match the verification information present in the component manifest.
//


//
// MessageId: ERROR_SXS_POLICY_PARSE_ERROR
//
// MessageText:
//
// The policy manifest contains one or more syntax errors.
//


//
// MessageId: ERROR_SXS_XML_E_MISSINGQUOTE
//
// MessageText:
//
// Manifest Parse Error : A string literal was expected, but no opening quote character was found.
//


//
// MessageId: ERROR_SXS_XML_E_COMMENTSYNTAX
//
// MessageText:
//
// Manifest Parse Error : Incorrect syntax was used in a comment.
//


//
// MessageId: ERROR_SXS_XML_E_BADSTARTNAMECHAR
//
// MessageText:
//
// Manifest Parse Error : A name was started with an invalid character.
//


//
// MessageId: ERROR_SXS_XML_E_BADNAMECHAR
//
// MessageText:
//
// Manifest Parse Error : A name contained an invalid character.
//


//
// MessageId: ERROR_SXS_XML_E_BADCHARINSTRING
//
// MessageText:
//
// Manifest Parse Error : A string literal contained an invalid character.
//


//
// MessageId: ERROR_SXS_XML_E_XMLDECLSYNTAX
//
// MessageText:
//
// Manifest Parse Error : Invalid syntax for an xml declaration.
//


//
// MessageId: ERROR_SXS_XML_E_BADCHARDATA
//
// MessageText:
//
// Manifest Parse Error : An Invalid character was found in text content.
//


//
// MessageId: ERROR_SXS_XML_E_MISSINGWHITESPACE
//
// MessageText:
//
// Manifest Parse Error : Required white space was missing.
//


//
// MessageId: ERROR_SXS_XML_E_EXPECTINGTAGEND
//
// MessageText:
//
// Manifest Parse Error : The character '>' was expected.
//


//
// MessageId: ERROR_SXS_XML_E_MISSINGSEMICOLON
//
// MessageText:
//
// Manifest Parse Error : A semi colon character was expected.
//


//
// MessageId: ERROR_SXS_XML_E_UNBALANCEDPAREN
//
// MessageText:
//
// Manifest Parse Error : Unbalanced parentheses.
//


//
// MessageId: ERROR_SXS_XML_E_INTERNALERROR
//
// MessageText:
//
// Manifest Parse Error : Internal error.
//


//
// MessageId: ERROR_SXS_XML_E_UNEXPECTED_WHITESPACE
//
// MessageText:
//
// Manifest Parse Error : Whitespace is not allowed at this location.
//


//
// MessageId: ERROR_SXS_XML_E_INCOMPLETE_ENCODING
//
// MessageText:
//
// Manifest Parse Error : End of file reached in invalid state for current encoding.
//


//
// MessageId: ERROR_SXS_XML_E_MISSING_PAREN
//
// MessageText:
//
// Manifest Parse Error : Missing parenthesis.
//


//
// MessageId: ERROR_SXS_XML_E_EXPECTINGCLOSEQUOTE
//
// MessageText:
//
// Manifest Parse Error : A single or double closing quote character (\' or \") is missing.
//


//
// MessageId: ERROR_SXS_XML_E_MULTIPLE_COLONS
//
// MessageText:
//
// Manifest Parse Error : Multiple colons are not allowed in a name.
//


//
// MessageId: ERROR_SXS_XML_E_INVALID_DECIMAL
//
// MessageText:
//
// Manifest Parse Error : Invalid character for decimal digit.
//


//
// MessageId: ERROR_SXS_XML_E_INVALID_HEXIDECIMAL
//
// MessageText:
//
// Manifest Parse Error : Invalid character for hexadecimal digit.
//


//
// MessageId: ERROR_SXS_XML_E_INVALID_UNICODE
//
// MessageText:
//
// Manifest Parse Error : Invalid unicode character value for this platform.
//


//
// MessageId: ERROR_SXS_XML_E_WHITESPACEORQUESTIONMARK
//
// MessageText:
//
// Manifest Parse Error : Expecting whitespace or '?'.
//


//
// MessageId: ERROR_SXS_XML_E_UNEXPECTEDENDTAG
//
// MessageText:
//
// Manifest Parse Error : End tag was not expected at this location.
//


//
// MessageId: ERROR_SXS_XML_E_UNCLOSEDTAG
//
// MessageText:
//
// Manifest Parse Error : The following tags were not closed: %1.
//


//
// MessageId: ERROR_SXS_XML_E_DUPLICATEATTRIBUTE
//
// MessageText:
//
// Manifest Parse Error : Duplicate attribute.
//


//
// MessageId: ERROR_SXS_XML_E_MULTIPLEROOTS
//
// MessageText:
//
// Manifest Parse Error : Only one top level element is allowed in an XML document.
//


//
// MessageId: ERROR_SXS_XML_E_INVALIDATROOTLEVEL
//
// MessageText:
//
// Manifest Parse Error : Invalid at the top level of the document.
//


//
// MessageId: ERROR_SXS_XML_E_BADXMLDECL
//
// MessageText:
//
// Manifest Parse Error : Invalid xml declaration.
//


//
// MessageId: ERROR_SXS_XML_E_MISSINGROOT
//
// MessageText:
//
// Manifest Parse Error : XML document must have a top level element.
//


//
// MessageId: ERROR_SXS_XML_E_UNEXPECTEDEOF
//
// MessageText:
//
// Manifest Parse Error : Unexpected end of file.
//


//
// MessageId: ERROR_SXS_XML_E_BADPEREFINSUBSET
//
// MessageText:
//
// Manifest Parse Error : Parameter entities cannot be used inside markup declarations in an internal subset.
//


//
// MessageId: ERROR_SXS_XML_E_UNCLOSEDSTARTTAG
//
// MessageText:
//
// Manifest Parse Error : Element was not closed.
//


//
// MessageId: ERROR_SXS_XML_E_UNCLOSEDENDTAG
//
// MessageText:
//
// Manifest Parse Error : End element was missing the character '>'.
//


//
// MessageId: ERROR_SXS_XML_E_UNCLOSEDSTRING
//
// MessageText:
//
// Manifest Parse Error : A string literal was not closed.
//


//
// MessageId: ERROR_SXS_XML_E_UNCLOSEDCOMMENT
//
// MessageText:
//
// Manifest Parse Error : A comment was not closed.
//


//
// MessageId: ERROR_SXS_XML_E_UNCLOSEDDECL
//
// MessageText:
//
// Manifest Parse Error : A declaration was not closed.
//


//
// MessageId: ERROR_SXS_XML_E_UNCLOSEDCDATA
//
// MessageText:
//
// Manifest Parse Error : A CDATA section was not closed.
//


//
// MessageId: ERROR_SXS_XML_E_RESERVEDNAMESPACE
//
// MessageText:
//
// Manifest Parse Error : The namespace prefix is not allowed to start with the reserved string "xml".
//


//
// MessageId: ERROR_SXS_XML_E_INVALIDENCODING
//
// MessageText:
//
// Manifest Parse Error : System does not support the specified encoding.
//


//
// MessageId: ERROR_SXS_XML_E_INVALIDSWITCH
//
// MessageText:
//
// Manifest Parse Error : Switch from current encoding to specified encoding not supported.
//


//
// MessageId: ERROR_SXS_XML_E_BADXMLCASE
//
// MessageText:
//
// Manifest Parse Error : The name 'xml' is reserved and must be lower case.
//


//
// MessageId: ERROR_SXS_XML_E_INVALID_STANDALONE
//
// MessageText:
//
// Manifest Parse Error : The standalone attribute must have the value 'yes' or 'no'.
//


//
// MessageId: ERROR_SXS_XML_E_UNEXPECTED_STANDALONE
//
// MessageText:
//
// Manifest Parse Error : The standalone attribute cannot be used in external entities.
//


//
// MessageId: ERROR_SXS_XML_E_INVALID_VERSION
//
// MessageText:
//
// Manifest Parse Error : Invalid version number.
//


//
// MessageId: ERROR_SXS_XML_E_MISSINGEQUALS
//
// MessageText:
//
// Manifest Parse Error : Missing equals sign between attribute and attribute value.
//


//
// MessageId: ERROR_SXS_PROTECTION_RECOVERY_FAILED
//
// MessageText:
//
// Assembly Protection Error : Unable to recover the specified assembly.
//


//
// MessageId: ERROR_SXS_PROTECTION_PUBLIC_KEY_TOO_SHORT
//
// MessageText:
//
// Assembly Protection Error : The public key for an assembly was too short to be allowed.
//


//
// MessageId: ERROR_SXS_PROTECTION_CATALOG_NOT_VALID
//
// MessageText:
//
// Assembly Protection Error : The catalog for an assembly is not valid, or does not match the assembly's manifest.
//


//
// MessageId: ERROR_SXS_UNTRANSLATABLE_HRESULT
//
// MessageText:
//
// An HRESULT could not be translated to a corresponding Win32 error code.
//


//
// MessageId: ERROR_SXS_PROTECTION_CATALOG_FILE_MISSING
//
// MessageText:
//
// Assembly Protection Error : The catalog for an assembly is missing.
//


//
// MessageId: ERROR_SXS_MISSING_ASSEMBLY_IDENTITY_ATTRIBUTE
//
// MessageText:
//
// The supplied assembly identity is missing one or more attributes which must be present in this context.
//


//
// MessageId: ERROR_SXS_INVALID_ASSEMBLY_IDENTITY_ATTRIBUTE_NAME
//
// MessageText:
//
// The supplied assembly identity has one or more attribute names that contain characters not permitted in XML names.
//


//
// MessageId: ERROR_SXS_ASSEMBLY_MISSING
//
// MessageText:
//
// The referenced assembly could not be found.
//


//
// MessageId: ERROR_SXS_CORRUPT_ACTIVATION_STACK
//
// MessageText:
//
// The activation context activation stack for the running thread of execution is corrupt.
//


//
// MessageId: ERROR_SXS_CORRUPTION
//
// MessageText:
//
// The application isolation metadata for this process or thread has become corrupt.
//


//
// MessageId: ERROR_SXS_EARLY_DEACTIVATION
//
// MessageText:
//
// The activation context being deactivated is not the most recently activated one.
//


//
// MessageId: ERROR_SXS_INVALID_DEACTIVATION
//
// MessageText:
//
// The activation context being deactivated is not active for the current thread of execution.
//


//
// MessageId: ERROR_SXS_MULTIPLE_DEACTIVATION
//
// MessageText:
//
// The activation context being deactivated has already been deactivated.
//


//
// MessageId: ERROR_SXS_PROCESS_TERMINATION_REQUESTED
//
// MessageText:
//
// A component used by the isolation facility has requested to terminate the process.
//


//
// MessageId: ERROR_SXS_RELEASE_ACTIVATION_CONTEXT
//
// MessageText:
//
// A kernel mode component is releasing a reference on an activation context.
//


//
// MessageId: ERROR_SXS_SYSTEM_DEFAULT_ACTIVATION_CONTEXT_EMPTY
//
// MessageText:
//
// The activation context of system default assembly could not be generated.
//


//
// MessageId: ERROR_SXS_INVALID_IDENTITY_ATTRIBUTE_VALUE
//
// MessageText:
//
// The value of an attribute in an identity is not within the legal range.
//


//
// MessageId: ERROR_SXS_INVALID_IDENTITY_ATTRIBUTE_NAME
//
// MessageText:
//
// The name of an attribute in an identity is not within the legal range.
//


//
// MessageId: ERROR_SXS_IDENTITY_DUPLICATE_ATTRIBUTE
//
// MessageText:
//
// An identity contains two definitions for the same attribute.
//


//
// MessageId: ERROR_SXS_IDENTITY_PARSE_ERROR
//
// MessageText:
//
// The identity string is malformed. This may be due to a trailing comma, more than two unnamed attributes, missing attribute name or missing attribute value.
//


//
// MessageId: ERROR_MALFORMED_SUBSTITUTION_STRING
//
// MessageText:
//
// A string containing localized substitutable content was malformed. Either a dollar sign ($) was followed by something other than a left parenthesis or another dollar sign or an substitution's right parenthesis was not found.
//


//
// MessageId: ERROR_SXS_INCORRECT_PUBLIC_KEY_TOKEN
//
// MessageText:
//
// The public key token does not correspond to the public key specified.
//


//
// MessageId: ERROR_UNMAPPED_SUBSTITUTION_STRING
//
// MessageText:
//
// A substitution string had no mapping.
//


//
// MessageId: ERROR_SXS_ASSEMBLY_NOT_LOCKED
//
// MessageText:
//
// The component must be locked before making the request.
//


//
// MessageId: ERROR_SXS_COMPONENT_STORE_CORRUPT
//
// MessageText:
//
// The component store has been corrupted.
//


//
// MessageId: ERROR_ADVANCED_INSTALLER_FAILED
//
// MessageText:
//
// An advanced installer failed during setup or servicing.
//


//
// MessageId: ERROR_XML_ENCODING_MISMATCH
//
// MessageText:
//
// The character encoding in the XML declaration did not match the encoding used in the document.
//


//
// MessageId: ERROR_SXS_MANIFEST_IDENTITY_SAME_BUT_CONTENTS_DIFFERENT
//
// MessageText:
//
// The identities of the manifests are identical but their contents are different.
//


//
// MessageId: ERROR_SXS_IDENTITIES_DIFFERENT
//
// MessageText:
//
// The component identities are different.
//


//
// MessageId: ERROR_SXS_ASSEMBLY_IS_NOT_A_DEPLOYMENT
//
// MessageText:
//
// The assembly is not a deployment.
//


//
// MessageId: ERROR_SXS_FILE_NOT_PART_OF_ASSEMBLY
//
// MessageText:
//
// The file is not a part of the assembly.
//


//
// MessageId: ERROR_SXS_MANIFEST_TOO_BIG
//
// MessageText:
//
// The size of the manifest exceeds the maximum allowed.
//


//
// MessageId: ERROR_SXS_SETTING_NOT_REGISTERED
//
// MessageText:
//
// The setting is not registered.
//


//
// MessageId: ERROR_SXS_TRANSACTION_CLOSURE_INCOMPLETE
//
// MessageText:
//
// One or more required members of the transaction are not present.
//


//
// MessageId: ERROR_SMI_PRIMITIVE_INSTALLER_FAILED
//
// MessageText:
//
// The SMI primitive installer failed during setup or servicing.
//


//
// MessageId: ERROR_GENERIC_COMMAND_FAILED
//
// MessageText:
//
// A generic command executable returned a result that indicates failure.
//


//
// MessageId: ERROR_SXS_FILE_HASH_MISSING
//
// MessageText:
//
// A component is missing file verification information in its manifest.
//


//
// MessageId: ERROR_SXS_DUPLICATE_ACTIVATABLE_CLASS
//
// MessageText:
//
// Two or more components referenced directly or indirectly by the application manifest have the same WinRT ActivatableClass IDs.
//



///////////////////////////////////////////////////
//                                               //
//           End of Side By Side Error Codes     //
//                                               //
//                 14000 to 14999                //
///////////////////////////////////////////////////


///////////////////////////////////////////////////
//                                               //
//           Start of WinEvt Error codes         //
//                                               //
//                 15000 to 15079                //
///////////////////////////////////////////////////

//
// MessageId: ERROR_EVT_INVALID_CHANNEL_PATH
//
// MessageText:
//
// The specified channel path is invalid.
//


//
// MessageId: ERROR_EVT_INVALID_QUERY
//
// MessageText:
//
// The specified query is invalid.
//


//
// MessageId: ERROR_EVT_PUBLISHER_METADATA_NOT_FOUND
//
// MessageText:
//
// The publisher metadata cannot be found in the resource.
//


//
// MessageId: ERROR_EVT_EVENT_TEMPLATE_NOT_FOUND
//
// MessageText:
//
// The template for an event definition cannot be found in the resource (error = %1).
//


//
// MessageId: ERROR_EVT_INVALID_PUBLISHER_NAME
//
// MessageText:
//
// The specified publisher name is invalid.
//


//
// MessageId: ERROR_EVT_INVALID_EVENT_DATA
//
// MessageText:
//
// The event data raised by the publisher is not compatible with the event template definition in the publisher's manifest.
//


//
// MessageId: ERROR_EVT_CHANNEL_NOT_FOUND
//
// MessageText:
//
// The specified channel could not be found.
//


//
// MessageId: ERROR_EVT_MALFORMED_XML_TEXT
//
// MessageText:
//
// The specified XML text was not well-formed. See Extended Error for more details.
//


//
// MessageId: ERROR_EVT_SUBSCRIPTION_TO_DIRECT_CHANNEL
//
// MessageText:
//
// The events for a direct channel go directly to a log file and cannot be subscribed to.
//


//
// MessageId: ERROR_EVT_CONFIGURATION_ERROR
//
// MessageText:
//
// Configuration error.
//


//
// MessageId: ERROR_EVT_QUERY_RESULT_STALE
//
// MessageText:
//
// The query result is stale or invalid and must be recreated. This may be due to the log being cleared or rolling over after the query result was created.
//


//
// MessageId: ERROR_EVT_QUERY_RESULT_INVALID_POSITION
//
// MessageText:
//
// The query result is currently at an invalid position.
//


//
// MessageId: ERROR_EVT_NON_VALIDATING_MSXML
//
// MessageText:
//
// Registered MSXML doesn't support validation.
//


//
// MessageId: ERROR_EVT_FILTER_ALREADYSCOPED
//
// MessageText:
//
// An expression can only be followed by a change-of-scope operation if the expression evaluates to a node set and is not already part of another change-of-scope operation.
//


//
// MessageId: ERROR_EVT_FILTER_NOTELTSET
//
// MessageText:
//
// Cannot perform a step operation from a term that does not represent an element set.
//


//
// MessageId: ERROR_EVT_FILTER_INVARG
//
// MessageText:
//
// Left-hand side arguments to binary operators must be either attributes, nodes or variables. Right-hand side arguments must be constants.
//


//
// MessageId: ERROR_EVT_FILTER_INVTEST
//
// MessageText:
//
// A step operation must involve a node test or, in the case of a predicate, an algebraic expression against which to test each node in the preceeding node set.
//


//
// MessageId: ERROR_EVT_FILTER_INVTYPE
//
// MessageText:
//
// This data type is currently unsupported.
//


//
// MessageId: ERROR_EVT_FILTER_PARSEERR
//
// MessageText:
//
// A syntax error occurred at position %1!d!
//


//
// MessageId: ERROR_EVT_FILTER_UNSUPPORTEDOP
//
// MessageText:
//
// This operator is unsupported by this implementation of the filter.
//


//
// MessageId: ERROR_EVT_FILTER_UNEXPECTEDTOKEN
//
// MessageText:
//
// An unexpected token was encountered.
//


//
// MessageId: ERROR_EVT_INVALID_OPERATION_OVER_ENABLED_DIRECT_CHANNEL
//
// MessageText:
//
// The requested operation cannot be performed over an enabled direct channel. The channel must first be disabled.
//


//
// MessageId: ERROR_EVT_INVALID_CHANNEL_PROPERTY_VALUE
//
// MessageText:
//
// Channel property %1!s! contains an invalid value. The value has an invalid type, is outside of its valid range, cannot be changed, or is not supported by this type of channel.
//


//
// MessageId: ERROR_EVT_INVALID_PUBLISHER_PROPERTY_VALUE
//
// MessageText:
//
// Publisher property %1!s! contains an invalid value. The value has an invalid type, is outside of its valid range, cannot be changed, or is not supported by this type of publisher.
//


//
// MessageId: ERROR_EVT_CHANNEL_CANNOT_ACTIVATE
//
// MessageText:
//
// The channel failed to activate.
//


//
// MessageId: ERROR_EVT_FILTER_TOO_COMPLEX
//
// MessageText:
//
// The XPath expression exceeded the supported complexity. Simplify the expression or split it into multiple expressions.
//


//
// MessageId: ERROR_EVT_MESSAGE_NOT_FOUND
//
// MessageText:
//
// The message resource is present but the message was not found in the message table.
//


//
// MessageId: ERROR_EVT_MESSAGE_ID_NOT_FOUND
//
// MessageText:
//
// The message ID for the desired message could not be found.
//


//
// MessageId: ERROR_EVT_UNRESOLVED_VALUE_INSERT
//
// MessageText:
//
// The substitution string for insert index (%1) could not be found.
//


//
// MessageId: ERROR_EVT_UNRESOLVED_PARAMETER_INSERT
//
// MessageText:
//
// The description string for parameter reference (%1) could not be found.
//


//
// MessageId: ERROR_EVT_MAX_INSERTS_REACHED
//
// MessageText:
//
// The maximum number of replacements has been reached.
//


//
// MessageId: ERROR_EVT_EVENT_DEFINITION_NOT_FOUND
//
// MessageText:
//
// The event definition could not be found for event ID (%1).
//


//
// MessageId: ERROR_EVT_MESSAGE_LOCALE_NOT_FOUND
//
// MessageText:
//
// The locale specific resource for the desired message is not present.
//


//
// MessageId: ERROR_EVT_VERSION_TOO_OLD
//
// MessageText:
//
// The resource is too old and is not supported.
//


//
// MessageId: ERROR_EVT_VERSION_TOO_NEW
//
// MessageText:
//
// The resource is too new and is not supported.
//


//
// MessageId: ERROR_EVT_CANNOT_OPEN_CHANNEL_OF_QUERY
//
// MessageText:
//
// The channel at index %1!d! of the query can't be opened.
//


//
// MessageId: ERROR_EVT_PUBLISHER_DISABLED
//
// MessageText:
//
// The publisher has been disabled and its resource is not available. This usually occurs when the publisher is in the process of being uninstalled or upgraded.
//


//
// MessageId: ERROR_EVT_FILTER_OUT_OF_RANGE
//
// MessageText:
//
// Attempted to create a numeric type that is outside of its valid range.
//



///////////////////////////////////////////////////
//                                               //
//           Start of Wecsvc Error codes         //
//                                               //
//                 15080 to 15099                //
///////////////////////////////////////////////////

//
// MessageId: ERROR_EC_SUBSCRIPTION_CANNOT_ACTIVATE
//
// MessageText:
//
// The subscription fails to activate.
//


//
// MessageId: ERROR_EC_LOG_DISABLED
//
// MessageText:
//
// The log of the subscription is in disabled state, and can not be used to forward events to. The log must first be enabled before the subscription can be activated.
//


//
// MessageId: ERROR_EC_CIRCULAR_FORWARDING
//
// MessageText:
//
// When forwarding events from local machine to itself, the query of the subscription can't contain target log of the subscription.
//


//
// MessageId: ERROR_EC_CREDSTORE_FULL
//
// MessageText:
//
// The credential store that is used to save credentials is full.
//


//
// MessageId: ERROR_EC_CRED_NOT_FOUND
//
// MessageText:
//
// The credential used by this subscription can't be found in credential store.
//


//
// MessageId: ERROR_EC_NO_ACTIVE_CHANNEL
//
// MessageText:
//
// No active channel is found for the query.
//



///////////////////////////////////////////////////
//                                               //
//           Start of MUI Error codes            //
//                                               //
//                 15100 to 15199                //
///////////////////////////////////////////////////

//
// MessageId: ERROR_MUI_FILE_NOT_FOUND
//
// MessageText:
//
// The resource loader failed to find MUI file.
//


//
// MessageId: ERROR_MUI_INVALID_FILE
//
// MessageText:
//
// The resource loader failed to load MUI file because the file fail to pass validation.
//


//
// MessageId: ERROR_MUI_INVALID_RC_CONFIG
//
// MessageText:
//
// The RC Manifest is corrupted with garbage data or unsupported version or missing required item.
//


//
// MessageId: ERROR_MUI_INVALID_LOCALE_NAME
//
// MessageText:
//
// The RC Manifest has invalid culture name.
//


//
// MessageId: ERROR_MUI_INVALID_ULTIMATEFALLBACK_NAME
//
// MessageText:
//
// The RC Manifest has invalid ultimatefallback name.
//


//
// MessageId: ERROR_MUI_FILE_NOT_LOADED
//
// MessageText:
//
// The resource loader cache doesn't have loaded MUI entry.
//


//
// MessageId: ERROR_RESOURCE_ENUM_USER_STOP
//
// MessageText:
//
// User stopped resource enumeration.
//


//
// MessageId: ERROR_MUI_INTLSETTINGS_UILANG_NOT_INSTALLED
//
// MessageText:
//
// UI language installation failed.
//


//
// MessageId: ERROR_MUI_INTLSETTINGS_INVALID_LOCALE_NAME
//
// MessageText:
//
// Locale installation failed.
//


//
// MessageId: ERROR_MRM_RUNTIME_NO_DEFAULT_OR_NEUTRAL_RESOURCE
//
// MessageText:
//
// A resource does not have default or neutral value.
//


//
// MessageId: ERROR_MRM_INVALID_PRICONFIG
//
// MessageText:
//
// Invalid PRI config file.
//


//
// MessageId: ERROR_MRM_INVALID_FILE_TYPE
//
// MessageText:
//
// Invalid file type.
//


//
// MessageId: ERROR_MRM_UNKNOWN_QUALIFIER
//
// MessageText:
//
// Unknown qualifier.
//


//
// MessageId: ERROR_MRM_INVALID_QUALIFIER_VALUE
//
// MessageText:
//
// Invalid qualifier value.
//


//
// MessageId: ERROR_MRM_NO_CANDIDATE
//
// MessageText:
//
// No Candidate found.
//


//
// MessageId: ERROR_MRM_NO_MATCH_OR_DEFAULT_CANDIDATE
//
// MessageText:
//
// The ResourceMap or NamedResource has an item that does not have default or neutral resource..
//


//
// MessageId: ERROR_MRM_RESOURCE_TYPE_MISMATCH
//
// MessageText:
//
// Invalid ResourceCandidate type.
//


//
// MessageId: ERROR_MRM_DUPLICATE_MAP_NAME
//
// MessageText:
//
// Duplicate Resource Map.
//


//
// MessageId: ERROR_MRM_DUPLICATE_ENTRY
//
// MessageText:
//
// Duplicate Entry.
//


//
// MessageId: ERROR_MRM_INVALID_RESOURCE_IDENTIFIER
//
// MessageText:
//
// Invalid Resource Identifier.
//


//
// MessageId: ERROR_MRM_FILEPATH_TOO_LONG
//
// MessageText:
//
// Filepath too long.
//


//
// MessageId: ERROR_MRM_UNSUPPORTED_DIRECTORY_TYPE
//
// MessageText:
//
// Unsupported directory type.
//


//
// MessageId: ERROR_MRM_INVALID_PRI_FILE
//
// MessageText:
//
// Invalid PRI File.
//


//
// MessageId: ERROR_MRM_NAMED_RESOURCE_NOT_FOUND
//
// MessageText:
//
// NamedResource Not Found.
//


//
// MessageId: ERROR_MRM_MAP_NOT_FOUND
//
// MessageText:
//
// ResourceMap Not Found.
//


//
// MessageId: ERROR_MRM_UNSUPPORTED_PROFILE_TYPE
//
// MessageText:
//
// Unsupported MRT profile type.
//


//
// MessageId: ERROR_MRM_INVALID_QUALIFIER_OPERATOR
//
// MessageText:
//
// Invalid qualifier operator.
//


//
// MessageId: ERROR_MRM_INDETERMINATE_QUALIFIER_VALUE
//
// MessageText:
//
// Unable to determine qualifier value or qualifier value has not been set.
//


//
// MessageId: ERROR_MRM_AUTOMERGE_ENABLED
//
// MessageText:
//
// Automerge is enabled in the PRI file.
//


//
// MessageId: ERROR_MRM_TOO_MANY_RESOURCES
//
// MessageText:
//
// Too many resources defined for package.
//


//
// MessageId: ERROR_MRM_UNSUPPORTED_FILE_TYPE_FOR_MERGE
//
// MessageText:
//
// Resource File can not be used for merge operation.
//


//
// MessageId: ERROR_MRM_UNSUPPORTED_FILE_TYPE_FOR_LOAD_UNLOAD_PRI_FILE
//
// MessageText:
//
// Load/UnloadPriFiles cannot be used with resource packages.
//


//
// MessageId: ERROR_MRM_NO_CURRENT_VIEW_ON_THREAD
//
// MessageText:
//
// Resource Contexts may not be created on threads that do not have a CoreWindow.
//


//
// MessageId: ERROR_DIFFERENT_PROFILE_RESOURCE_MANAGER_EXIST
//
// MessageText:
//
// The singleton Resource Manager with different profile is already created.
//


//
// MessageId: ERROR_OPERATION_NOT_ALLOWED_FROM_SYSTEM_COMPONENT
//
// MessageText:
//
// The system component cannot operate given API operation
//


//
// MessageId: ERROR_MRM_DIRECT_REF_TO_NON_DEFAULT_RESOURCE
//
// MessageText:
//
// The resource is a direct reference to a non-default resource candidate.
//


//
// MessageId: ERROR_MRM_GENERATION_COUNT_MISMATCH
//
// MessageText:
//
// Resource Map has been re-generated and the query string is not valid anymore.
//


//
// MessageId: ERROR_PRI_MERGE_VERSION_MISMATCH
//
// MessageText:
//
// The PRI files to be merged have incompatible versions.
//


//
// MessageId: ERROR_PRI_MERGE_MISSING_SCHEMA
//
// MessageText:
//
// The primary PRI files to be merged does not contain a schema.
//


//
// MessageId: ERROR_PRI_MERGE_LOAD_FILE_FAILED
//
// MessageText:
//
// Unable to load one of the PRI files to be merged.
//


//
// MessageId: ERROR_PRI_MERGE_ADD_FILE_FAILED
//
// MessageText:
//
// Unable to add one of the PRI files to the merged file.
//


//
// MessageId: ERROR_PRI_MERGE_WRITE_FILE_FAILED
//
// MessageText:
//
// Unable to create the merged PRI file.
//


//
// MessageId: ERROR_PRI_MERGE_MULTIPLE_PACKAGE_FAMILIES_NOT_ALLOWED
//
// MessageText:
//
// Packages for a PRI file merge must all be from the same package family.
//


//
// MessageId: ERROR_PRI_MERGE_MULTIPLE_MAIN_PACKAGES_NOT_ALLOWED
//
// MessageText:
//
// Packages for a PRI file merge must not include multiple main packages.
//


//
// MessageId: ERROR_PRI_MERGE_BUNDLE_PACKAGES_NOT_ALLOWED
//
// MessageText:
//
// Packages for a PRI file merge must not include bundle packages.
//


//
// MessageId: ERROR_PRI_MERGE_MAIN_PACKAGE_REQUIRED
//
// MessageText:
//
// Packages for a PRI file merge must include one main package.
//


//
// MessageId: ERROR_PRI_MERGE_RESOURCE_PACKAGE_REQUIRED
//
// MessageText:
//
// Packages for a PRI file merge must include at least one resource package.
//


//
// MessageId: ERROR_PRI_MERGE_INVALID_FILE_NAME
//
// MessageText:
//
// Invalid name supplied for a canonical merged PRI file.
//


//
// MessageId: ERROR_MRM_PACKAGE_NOT_FOUND
//
// MessageText:
//
// Unable to find the specified package.
//


//
// MessageId: ERROR_MRM_MISSING_DEFAULT_LANGUAGE
//
// MessageText:
//
// No default value for language was specified.
//



///////////////////////////////////////////////////
//                                               //
// Start of Monitor Configuration API error codes//
//                                               //
//                 15200 to 15249                //
///////////////////////////////////////////////////

//
// MessageId: ERROR_MCA_INVALID_CAPABILITIES_STRING
//
// MessageText:
//
// The monitor returned a DDC/CI capabilities string that did not comply with the ACCESS.bus 3.0, DDC/CI 1.1 or MCCS 2 Revision 1 specification.
//


//
// MessageId: ERROR_MCA_INVALID_VCP_VERSION
//
// MessageText:
//
// The monitor's VCP Version (0xDF) VCP code returned an invalid version value.
//


//
// MessageId: ERROR_MCA_MONITOR_VIOLATES_MCCS_SPECIFICATION
//
// MessageText:
//
// The monitor does not comply with the MCCS specification it claims to support.
//


//
// MessageId: ERROR_MCA_MCCS_VERSION_MISMATCH
//
// MessageText:
//
// The MCCS version in a monitor's mccs_ver capability does not match the MCCS version the monitor reports when the VCP Version (0xDF) VCP code is used.
//


//
// MessageId: ERROR_MCA_UNSUPPORTED_MCCS_VERSION
//
// MessageText:
//
// The Monitor Configuration API only works with monitors that support the MCCS 1.0 specification, MCCS 2.0 specification or the MCCS 2.0 Revision 1 specification.
//


//
// MessageId: ERROR_MCA_INTERNAL_ERROR
//
// MessageText:
//
// An internal Monitor Configuration API error occurred.
//


//
// MessageId: ERROR_MCA_INVALID_TECHNOLOGY_TYPE_RETURNED
//
// MessageText:
//
// The monitor returned an invalid monitor technology type. CRT, Plasma and LCD (TFT) are examples of monitor technology types. This error implies that the monitor violated the MCCS 2.0 or MCCS 2.0 Revision 1 specification.
//


//
// MessageId: ERROR_MCA_UNSUPPORTED_COLOR_TEMPERATURE
//
// MessageText:
//
// The caller of SetMonitorColorTemperature specified a color temperature that the current monitor did not support. This error implies that the monitor violated the MCCS 2.0 or MCCS 2.0 Revision 1 specification.
//



//////////////////////////////////////////////////
//                                              //
// End of Monitor Configuration API error codes //
//                                              //
//                15200 to 15249                //
//                                              //
//////////////////////////////////////////////////
//////////////////////////////////////////////////
//                                              //
//         Start of Syspart error codes         //
//                15250 - 15299                 //
//                                              //
//////////////////////////////////////////////////

//
// MessageId: ERROR_AMBIGUOUS_SYSTEM_DEVICE
//
// MessageText:
//
// The requested system device cannot be identified due to multiple indistinguishable devices potentially matching the identification criteria.
//


//
// MessageId: ERROR_SYSTEM_DEVICE_NOT_FOUND
//
// MessageText:
//
// The requested system device cannot be found.
//


//////////////////////////////////////////////////
//                                              //
//         Start of Vortex error codes          //
//                15300 - 15320                 //
//                                              //
//////////////////////////////////////////////////

//
// MessageId: ERROR_HASH_NOT_SUPPORTED
//
// MessageText:
//
// Hash generation for the specified hash version and hash type is not enabled on the server.
//


//
// MessageId: ERROR_HASH_NOT_PRESENT
//
// MessageText:
//
// The hash requested from the server is not available or no longer valid.
//


//////////////////////////////////////////////////
//                                              //
//         Start of GPIO error codes            //
//                15321 - 15340                 //
//                                              //
//////////////////////////////////////////////////

//
// MessageId: ERROR_SECONDARY_IC_PROVIDER_NOT_REGISTERED
//
// MessageText:
//
// The secondary interrupt controller instance that manages the specified interrupt is not registered.
//


//
// MessageId: ERROR_GPIO_CLIENT_INFORMATION_INVALID
//
// MessageText:
//
// The information supplied by the GPIO client driver is invalid.
//


//
// MessageId: ERROR_GPIO_VERSION_NOT_SUPPORTED
//
// MessageText:
//
// The version specified by the GPIO client driver is not supported.
//


//
// MessageId: ERROR_GPIO_INVALID_REGISTRATION_PACKET
//
// MessageText:
//
// The registration packet supplied by the GPIO client driver is not valid.
//


//
// MessageId: ERROR_GPIO_OPERATION_DENIED
//
// MessageText:
//
// The requested operation is not supported for the specified handle.
//


//
// MessageId: ERROR_GPIO_INCOMPATIBLE_CONNECT_MODE
//
// MessageText:
//
// The requested connect mode conflicts with an existing mode on one or more of the specified pins.
//


//
// MessageId: ERROR_GPIO_INTERRUPT_ALREADY_UNMASKED
//
// MessageText:
//
// The interrupt requested to be unmasked is not masked.
//


//////////////////////////////////////////////////
//                                              //
//         Start of Run Level error codes       //
//                15400 - 15500                 //
//                                              //
//////////////////////////////////////////////////

//
// MessageId: ERROR_CANNOT_SWITCH_RUNLEVEL
//
// MessageText:
//
// The requested run level switch cannot be completed successfully.
//


//
// MessageId: ERROR_INVALID_RUNLEVEL_SETTING
//
// MessageText:
//
// The service has an invalid run level setting. The run level for a service
// must not be higher than the run level of its dependent services.
//


//
// MessageId: ERROR_RUNLEVEL_SWITCH_TIMEOUT
//
// MessageText:
//
// The requested run level switch cannot be completed successfully since
// one or more services will not stop or restart within the specified timeout.
//


//
// MessageId: ERROR_RUNLEVEL_SWITCH_AGENT_TIMEOUT
//
// MessageText:
//
// A run level switch agent did not respond within the specified timeout.
//


//
// MessageId: ERROR_RUNLEVEL_SWITCH_IN_PROGRESS
//
// MessageText:
//
// A run level switch is currently in progress.
//


//
// MessageId: ERROR_SERVICES_FAILED_AUTOSTART
//
// MessageText:
//
// One or more services failed to start during the service startup phase of a run level switch.
//


//////////////////////////////////////////////////
//                                              //
//         Start of Com Task error codes        //
//                15501 - 15510                 //
//                                              //
//////////////////////////////////////////////////

//
// MessageId: ERROR_COM_TASK_STOP_PENDING
//
// MessageText:
//
// The task stop request cannot be completed immediately since
// task needs more time to shutdown.
//


////////////////////////////////////////
//                                    //
// APPX Caller Visible Error Codes    //
//          15600-15699               //
////////////////////////////////////////
//
// MessageId: ERROR_INSTALL_OPEN_PACKAGE_FAILED
//
// MessageText:
//
// Package could not be opened.
//


//
// MessageId: ERROR_INSTALL_PACKAGE_NOT_FOUND
//
// MessageText:
//
// Package was not found.
//


//
// MessageId: ERROR_INSTALL_INVALID_PACKAGE
//
// MessageText:
//
// Package data is invalid.
//


//
// MessageId: ERROR_INSTALL_RESOLVE_DEPENDENCY_FAILED
//
// MessageText:
//
// Package failed updates, dependency or conflict validation.
//


//
// MessageId: ERROR_INSTALL_OUT_OF_DISK_SPACE
//
// MessageText:
//
// There is not enough disk space on your computer. Please free up some space and try again.
//


//
// MessageId: ERROR_INSTALL_NETWORK_FAILURE
//
// MessageText:
//
// There was a problem downloading your product.
//


//
// MessageId: ERROR_INSTALL_REGISTRATION_FAILURE
//
// MessageText:
//
// Package could not be registered.
//


//
// MessageId: ERROR_INSTALL_DEREGISTRATION_FAILURE
//
// MessageText:
//
// Package could not be unregistered.
//


//
// MessageId: ERROR_INSTALL_CANCEL
//
// MessageText:
//
// User cancelled the install request.
//


//
// MessageId: ERROR_INSTALL_FAILED
//
// MessageText:
//
// Install failed. Please contact your software vendor.
//


//
// MessageId: ERROR_REMOVE_FAILED
//
// MessageText:
//
// Removal failed. Please contact your software vendor.
//


//
// MessageId: ERROR_PACKAGE_ALREADY_EXISTS
//
// MessageText:
//
// The provided package is already installed, and reinstallation of the package was blocked. Check the AppXDeployment-Server event log for details.
//


//
// MessageId: ERROR_NEEDS_REMEDIATION
//
// MessageText:
//
// The application cannot be started. Try reinstalling the application to fix the problem.
//


//
// MessageId: ERROR_INSTALL_PREREQUISITE_FAILED
//
// MessageText:
//
// A Prerequisite for an install could not be satisfied.
//


//
// MessageId: ERROR_PACKAGE_REPOSITORY_CORRUPTED
//
// MessageText:
//
// The package repository is corrupted.
//


//
// MessageId: ERROR_INSTALL_POLICY_FAILURE
//
// MessageText:
//
// To install this application you need either a Windows developer license or a sideloading-enabled system.
//


//
// MessageId: ERROR_PACKAGE_UPDATING
//
// MessageText:
//
// The application cannot be started because it is currently updating.
//


//
// MessageId: ERROR_DEPLOYMENT_BLOCKED_BY_POLICY
//
// MessageText:
//
// The package deployment operation is blocked by policy. Please contact your system administrator.
//


//
// MessageId: ERROR_PACKAGES_IN_USE
//
// MessageText:
//
// The package could not be installed because resources it modifies are currently in use.
//


//
// MessageId: ERROR_RECOVERY_FILE_CORRUPT
//
// MessageText:
//
// The package could not be recovered because necessary data for recovery have been corrupted.
//


//
// MessageId: ERROR_INVALID_STAGED_SIGNATURE
//
// MessageText:
//
// The signature is invalid. To register in developer mode, AppxSignature.p7x and AppxBlockMap.xml must be valid or should not be present.
//


//
// MessageId: ERROR_DELETING_EXISTING_APPLICATIONDATA_STORE_FAILED
//
// MessageText:
//
// An error occurred while deleting the package's previously existing application data.
//


//
// MessageId: ERROR_INSTALL_PACKAGE_DOWNGRADE
//
// MessageText:
//
// The package could not be installed because a higher version of this package is already installed.
//


//
// MessageId: ERROR_SYSTEM_NEEDS_REMEDIATION
//
// MessageText:
//
// An error in a system binary was detected. Try refreshing the PC to fix the problem.
//


//
// MessageId: ERROR_APPX_INTEGRITY_FAILURE_CLR_NGEN
//
// MessageText:
//
// A corrupted CLR NGEN binary was detected on the system.
//


//
// MessageId: ERROR_RESILIENCY_FILE_CORRUPT
//
// MessageText:
//
// The operation could not be resumed because necessary data for recovery have been corrupted.
//


//
// MessageId: ERROR_INSTALL_FIREWALL_SERVICE_NOT_RUNNING
//
// MessageText:
//
// The package could not be installed because the Windows Firewall service is not running. Enable the Windows Firewall service and try again.
//


//
// MessageId: ERROR_PACKAGE_MOVE_FAILED
//
// MessageText:
//
// Package move failed.
//


//
// MessageId: ERROR_INSTALL_VOLUME_NOT_EMPTY
//
// MessageText:
//
// The deployment operation failed because the volume is not empty.
//


//
// MessageId: ERROR_INSTALL_VOLUME_OFFLINE
//
// MessageText:
//
// The deployment operation failed because the volume is offline.
//


//
// MessageId: ERROR_INSTALL_VOLUME_CORRUPT
//
// MessageText:
//
// The deployment operation failed because the specified volume is corrupt.
//


//
// MessageId: ERROR_NEEDS_REGISTRATION
//
// MessageText:
//
// The deployment operation failed because the specified application needs to be registered first.
//


//
// MessageId: ERROR_INSTALL_WRONG_PROCESSOR_ARCHITECTURE
//
// MessageText:
//
// The deployment operation failed because the package targets the wrong processor architecture.
//


//
// MessageId: ERROR_DEV_SIDELOAD_LIMIT_EXCEEDED
//
// MessageText:
//
// You have reached the maximum number of developer sideloaded packages allowed on this device. Please uninstall a sideloaded package and try again.
//


//
// MessageId: ERROR_INSTALL_OPTIONAL_PACKAGE_REQUIRES_MAIN_PACKAGE
//
// MessageText:
//
// A main app package is required to install this optional package.  Install the main package first and try again.
//


//
// MessageId: ERROR_PACKAGE_NOT_SUPPORTED_ON_FILESYSTEM
//
// MessageText:
//
// This app package type is not supported on this filesystem
//


//
// MessageId: ERROR_PACKAGE_MOVE_BLOCKED_BY_STREAMING
//
// MessageText:
//
// Package move operation is blocked until the application has finished streaming
//


//
// MessageId: ERROR_INSTALL_OPTIONAL_PACKAGE_APPLICATIONID_NOT_UNIQUE
//
// MessageText:
//
// A main or another optional app package has the same application ID as this optional package.  Change the application ID for the optional package to avoid conflicts.
//


//
// MessageId: ERROR_PACKAGE_STAGING_ONHOLD
//
// MessageText:
//
// This staging session has been held to allow another staging operation to be prioritized.
//


//
// MessageId: ERROR_INSTALL_INVALID_RELATED_SET_UPDATE
//
// MessageText:
//
// A related set cannot be updated because the updated set is invalid. All packages in the related set must be updated at the same time.
//


//
// MessageId: ERROR_INSTALL_OPTIONAL_PACKAGE_REQUIRES_MAIN_PACKAGE_FULLTRUST_CAPABILITY
//
// MessageText:
//
// An optional package with a FullTrust entry point requires the main package to have the runFullTrust capability.
//


//
// MessageId: ERROR_DEPLOYMENT_BLOCKED_BY_USER_LOG_OFF
//
// MessageText:
//
// An error occurred because a user was logged off.
//


//
// MessageId: ERROR_PROVISION_OPTIONAL_PACKAGE_REQUIRES_MAIN_PACKAGE_PROVISIONED
//
// MessageText:
//
// An optional package provision requires the dependency main package to also be provisioned.
//


//
// MessageId: ERROR_PACKAGES_REPUTATION_CHECK_FAILED
//
// MessageText:
//
// The packages failed the SmartScreen reputation check.
//


//
// MessageId: ERROR_PACKAGES_REPUTATION_CHECK_TIMEDOUT
//
// MessageText:
//
// The SmartScreen reputation check operation timed out.
//


//
// MessageId: ERROR_DEPLOYMENT_OPTION_NOT_SUPPORTED
//
// MessageText:
//
// The current deployment option is not supported.
//


//
// MessageId: ERROR_APPINSTALLER_ACTIVATION_BLOCKED
//
// MessageText:
//
// Activation is blocked due to the .appinstaller update settings for this app.
//


//
// MessageId: ERROR_REGISTRATION_FROM_REMOTE_DRIVE_NOT_SUPPORTED
//
// MessageText:
//
// Remote drives are not supported; use \\server\share to register a remote package.
//


//
// MessageId: ERROR_APPX_RAW_DATA_WRITE_FAILED
//
// MessageText:
//
// Failed to process and write downloaded APPX package data to disk.
//


//
// MessageId: ERROR_DEPLOYMENT_BLOCKED_BY_VOLUME_POLICY_PACKAGE
//
// MessageText:
//
// The deployment operation was blocked due to a per-package-family policy restricting deployments on a non-system volume. Per policy, this app must be installed to the system drive, but that's not set as the default. In Storage Settings, make the system drive the default location to save new content, then retry the install.
//


//
// MessageId: ERROR_DEPLOYMENT_BLOCKED_BY_VOLUME_POLICY_MACHINE
//
// MessageText:
//
// The deployment operation was blocked due to a machine-wide policy restricting deployments on a non-system volume. Per policy, this app must be installed to the system drive, but that's not set as the default. In Storage Settings, make the system drive the default location to save new content, then retry the install.
//


//
// MessageId: ERROR_DEPLOYMENT_BLOCKED_BY_PROFILE_POLICY
//
// MessageText:
//
// The deployment operation was blocked because Special profile deployment is not allowed. Please try logging into an account that is not a Special profile. You can try logging out and logging back into the current account, or try logging into a different account.
//


//
// MessageId: ERROR_DEPLOYMENT_FAILED_CONFLICTING_MUTABLE_PACKAGE_DIRECTORY
//
// MessageText:
//
// The deployment operation failed due to a conflicting package's mutable package directory. To install this package remove the existing package with the conflicting mutable package directory.
//


//
// MessageId: ERROR_SINGLETON_RESOURCE_INSTALLED_IN_ACTIVE_USER
//
// MessageText:
//
// The package installation failed because a singleton resource was specified and another user with that package installed is logged in. Please make sure that all active users with the package installed are logged out and retry installation.
//


//
// MessageId: ERROR_DIFFERENT_VERSION_OF_PACKAGED_SERVICE_INSTALLED
//
// MessageText:
//
// The package installation failed because a different version of the service is installed. Try installing a newer version of the package.
//


//
// MessageId: ERROR_SERVICE_EXISTS_AS_NON_PACKAGED_SERVICE
//
// MessageText:
//
// The package installation failed because a version of the service exists outside of APPX packaging. Please contact your software vendor.
//


//
// MessageId: ERROR_PACKAGED_SERVICE_REQUIRES_ADMIN_PRIVILEGES
//
// MessageText:
//
// The package installation failed because administrator privileges are required. Please contact an administrator to install this package.
//


//////////////////////////
//                      //
// AppModel Error Codes //
//     15700-15720      //
//                      //
//////////////////////////
//
// MessageId: APPMODEL_ERROR_NO_PACKAGE
//
// MessageText:
//
// The process has no package identity.
//


//
// MessageId: APPMODEL_ERROR_PACKAGE_RUNTIME_CORRUPT
//
// MessageText:
//
// The package runtime information is corrupted.
//


//
// MessageId: APPMODEL_ERROR_PACKAGE_IDENTITY_CORRUPT
//
// MessageText:
//
// The package identity is corrupted.
//


//
// MessageId: APPMODEL_ERROR_NO_APPLICATION
//
// MessageText:
//
// The process has no application identity.
//


//
// MessageId: APPMODEL_ERROR_DYNAMIC_PROPERTY_READ_FAILED
//
// MessageText:
//
// One or more AppModel Runtime group policy values could not be read. Please contact your system administrator with the contents of your AppModel Runtime event log.
//


//
// MessageId: APPMODEL_ERROR_DYNAMIC_PROPERTY_INVALID
//
// MessageText:
//
// One or more AppModel Runtime group policy values are invalid. Please contact your system administrator with the contents of your AppModel Runtime event log.
//


//
// MessageId: APPMODEL_ERROR_PACKAGE_NOT_AVAILABLE
//
// MessageText:
//
// The package is currently not available.
//


//
// MessageId: APPMODEL_ERROR_NO_MUTABLE_DIRECTORY
//
// MessageText:
//
// The package does not have a mutable directory.
//


/////////////////////////////
//                         //
// Appx StateManager Codes //
//     15800-15840         //
//                         //
/////////////////////////////
//
// MessageId: ERROR_STATE_LOAD_STORE_FAILED
//
// MessageText:
//
// Loading the state store failed.
//


//
// MessageId: ERROR_STATE_GET_VERSION_FAILED
//
// MessageText:
//
// Retrieving the state version for the application failed.
//


//
// MessageId: ERROR_STATE_SET_VERSION_FAILED
//
// MessageText:
//
// Setting the state version for the application failed.
//


//
// MessageId: ERROR_STATE_STRUCTURED_RESET_FAILED
//
// MessageText:
//
// Resetting the structured state of the application failed.
//


//
// MessageId: ERROR_STATE_OPEN_CONTAINER_FAILED
//
// MessageText:
//
// State Manager failed to open the container.
//


//
// MessageId: ERROR_STATE_CREATE_CONTAINER_FAILED
//
// MessageText:
//
// State Manager failed to create the container.
//


//
// MessageId: ERROR_STATE_DELETE_CONTAINER_FAILED
//
// MessageText:
//
// State Manager failed to delete the container.
//


//
// MessageId: ERROR_STATE_READ_SETTING_FAILED
//
// MessageText:
//
// State Manager failed to read the setting.
//


//
// MessageId: ERROR_STATE_WRITE_SETTING_FAILED
//
// MessageText:
//
// State Manager failed to write the setting.
//


//
// MessageId: ERROR_STATE_DELETE_SETTING_FAILED
//
// MessageText:
//
// State Manager failed to delete the setting.
//


//
// MessageId: ERROR_STATE_QUERY_SETTING_FAILED
//
// MessageText:
//
// State Manager failed to query the setting.
//


//
// MessageId: ERROR_STATE_READ_COMPOSITE_SETTING_FAILED
//
// MessageText:
//
// State Manager failed to read the composite setting.
//


//
// MessageId: ERROR_STATE_WRITE_COMPOSITE_SETTING_FAILED
//
// MessageText:
//
// State Manager failed to write the composite setting.
//


//
// MessageId: ERROR_STATE_ENUMERATE_CONTAINER_FAILED
//
// MessageText:
//
// State Manager failed to enumerate the containers.
//


//
// MessageId: ERROR_STATE_ENUMERATE_SETTINGS_FAILED
//
// MessageText:
//
// State Manager failed to enumerate the settings.
//


//
// MessageId: ERROR_STATE_COMPOSITE_SETTING_VALUE_SIZE_LIMIT_EXCEEDED
//
// MessageText:
//
// The size of the state manager composite setting value has exceeded the limit.
//


//
// MessageId: ERROR_STATE_SETTING_VALUE_SIZE_LIMIT_EXCEEDED
//
// MessageText:
//
// The size of the state manager setting value has exceeded the limit.
//


//
// MessageId: ERROR_STATE_SETTING_NAME_SIZE_LIMIT_EXCEEDED
//
// MessageText:
//
// The length of the state manager setting name has exceeded the limit.
//


//
// MessageId: ERROR_STATE_CONTAINER_NAME_SIZE_LIMIT_EXCEEDED
//
// MessageText:
//
// The length of the state manager container name has exceeded the limit.
//


/////////////////////////////////
//                             //
// Application Partition Codes //
//     15841-15860             //
//                             //
/////////////////////////////////
//
// MessageId: ERROR_API_UNAVAILABLE
//
// MessageText:
//
// This API cannot be used in the context of the caller's application type.
//


/////////////////////////////////
//                             //
// Windows Store Codes         //
//     15861-15880             //
//                             //
/////////////////////////////////
//
// MessageId: STORE_ERROR_UNLICENSED
//
// MessageText:
//
// This PC does not have a valid license for the application or product.
//


//
// MessageId: STORE_ERROR_UNLICENSED_USER
//
// MessageText:
//
// The authenticated user does not have a valid license for the application or product.
//


//
// MessageId: STORE_ERROR_PENDING_COM_TRANSACTION
//
// MessageText:
//
// The commerce transaction associated with this license is still pending verification.
//


//
// MessageId: STORE_ERROR_LICENSE_REVOKED
//
// MessageText:
//
// The license has been revoked for this user.
//


////////////////////////////////////
//                                //
//     COM Error Codes            //
//                                //
////////////////////////////////////


//
// The return value of COM functions and methods is an HRESULT.
// This is not a handle to anything, but is merely a 32-bit value
// with several fields encoded in the value. The parts of an
// HRESULT are shown below.
//
// Many of the macros and functions below were originally defined to
// operate on SCODEs. SCODEs are no longer used. The macros are
// still present for compatibility and easy porting of Win16 code.
// Newly written code should use the HRESULT macros and functions.
//

//
//  HRESULTs are 32 bit values laid out as follows:
//
//   3 3 2 2 2 2 2 2 2 2 2 2 1 1 1 1 1 1 1 1 1 1
//   1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0
//  +-+-+-+-+-+---------------------+-------------------------------+
//  |S|R|C|N|r|    Facility         |               Code            |
//  +-+-+-+-+-+---------------------+-------------------------------+
//
//  where
//
//      S - Severity - indicates success/fail
//
//          0 - Success
//          1 - Fail (COERROR)
//
//      R - reserved portion of the facility code, corresponds to NT's
//              second severity bit.
//
//      C - reserved portion of the facility code, corresponds to NT's
//              C field.
//
//      N - reserved portion of the facility code. Used to indicate a
//              mapped NT status value.
//
//      r - reserved portion of the facility code. Reserved for internal
//              use. Used to indicate HRESULT values that are not status
//              values, but are instead message ids for display strings.
//
//      Facility - is the facility code
//
//      Code - is the facility's status code
//

//
// Severity values
//





//
// Generic test for success on any status value (non-negative numbers
// indicate success).
//



//
// and the inverse
//




//
// Generic test for error on any status value.
//



//
// Return the code
//




//
//  Return the facility
//




//
//  Return the severity
//




//
// Create an HRESULT value from component pieces
//







//
// Map a WIN32 error value into a HRESULT
// Note: This assumes that WIN32 errors fall in the range -32k to 32k.
//
// Define bits here so macros are guaranteed to work



//
// HRESULT_FROM_WIN32(x) used to be a macro, however we now run it as an inline function
// to prevent double evaluation of 'x'. If you still need the macro, you can use __HRESULT_FROM_WIN32(x)
//





#line 28852 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\shared\\winerror.h"



constexpr
#line 28857 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\shared\\winerror.h"
__forceinline  HRESULT HRESULT_FROM_WIN32(unsigned long x) { return (HRESULT)(x) <= 0 ? (HRESULT)(x) : (HRESULT) (((x) & 0x0000FFFF) | (7 << 16) | 0x80000000);}


#line 28861 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\shared\\winerror.h"

//
// Map an NT status value into a HRESULT
//




// ****** OBSOLETE functions

// HRESULT functions
// As noted above, these functions are obsolete and should not be used.


// Extract the SCODE from a HRESULT



// Convert an SCODE into an HRESULT.




// PropagateResult is a noop



// ****** End of OBSOLETE functions.







// ---------------------- HRESULT value definitions -----------------
//
// HRESULT definitions
//





#line 28906 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\shared\\winerror.h"



//
// Error definitions follow
//

//
// Codes 0x4000-0x40ff are reserved for OLE
//
//
// Error codes
//
//
// MessageId: E_UNEXPECTED
//
// MessageText:
//
// Catastrophic failure
//



//
// MessageId: E_NOTIMPL
//
// MessageText:
//
// Not implemented
//


//
// MessageId: E_OUTOFMEMORY
//
// MessageText:
//
// Ran out of memory
//


//
// MessageId: E_INVALIDARG
//
// MessageText:
//
// One or more arguments are invalid
//


//
// MessageId: E_NOINTERFACE
//
// MessageText:
//
// No such interface supported
//


//
// MessageId: E_POINTER
//
// MessageText:
//
// Invalid pointer
//


//
// MessageId: E_HANDLE
//
// MessageText:
//
// Invalid handle
//


//
// MessageId: E_ABORT
//
// MessageText:
//
// Operation aborted
//


//
// MessageId: E_FAIL
//
// MessageText:
//
// Unspecified error
//


//
// MessageId: E_ACCESSDENIED
//
// MessageText:
//
// General access denied error
//




















































































#line 29093 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\shared\\winerror.h"
//
// MessageId: E_PENDING
//
// MessageText:
//
// The data necessary to complete this operation is not yet available.
//


//
// MessageId: E_BOUNDS
//
// MessageText:
//
// The operation attempted to access data outside the valid range
//


//
// MessageId: E_CHANGED_STATE
//
// MessageText:
//
// A concurrent or interleaved operation changed the state of the object, invalidating this operation.
//


//
// MessageId: E_ILLEGAL_STATE_CHANGE
//
// MessageText:
//
// An illegal state change was requested.
//


//
// MessageId: E_ILLEGAL_METHOD_CALL
//
// MessageText:
//
// A method was called at an unexpected time.
//


//
// MessageId: RO_E_METADATA_NAME_NOT_FOUND
//
// MessageText:
//
// Typename or Namespace was not found in metadata file.
//


//
// MessageId: RO_E_METADATA_NAME_IS_NAMESPACE
//
// MessageText:
//
// Name is an existing namespace rather than a typename.
//


//
// MessageId: RO_E_METADATA_INVALID_TYPE_FORMAT
//
// MessageText:
//
// Typename has an invalid format.
//


//
// MessageId: RO_E_INVALID_METADATA_FILE
//
// MessageText:
//
// Metadata file is invalid or corrupted.
//


//
// MessageId: RO_E_CLOSED
//
// MessageText:
//
// The object has been closed.
//


//
// MessageId: RO_E_EXCLUSIVE_WRITE
//
// MessageText:
//
// Only one thread may access the object during a write operation.
//


//
// MessageId: RO_E_CHANGE_NOTIFICATION_IN_PROGRESS
//
// MessageText:
//
// Operation is prohibited during change notification.
//


//
// MessageId: RO_E_ERROR_STRING_NOT_FOUND
//
// MessageText:
//
// The text associated with this error code could not be found.
//


//
// MessageId: E_STRING_NOT_NULL_TERMINATED
//
// MessageText:
//
// String not null terminated.
//


//
// MessageId: E_ILLEGAL_DELEGATE_ASSIGNMENT
//
// MessageText:
//
// A delegate was assigned when not allowed.
//


//
// MessageId: E_ASYNC_OPERATION_NOT_STARTED
//
// MessageText:
//
// An async operation was not properly started.
//


//
// MessageId: E_APPLICATION_EXITING
//
// MessageText:
//
// The application is exiting and cannot service this request
//


//
// MessageId: E_APPLICATION_VIEW_EXITING
//
// MessageText:
//
// The application view is exiting and cannot service this request
//


//
// MessageId: RO_E_MUST_BE_AGILE
//
// MessageText:
//
// The object must support the IAgileObject interface
//


//
// MessageId: RO_E_UNSUPPORTED_FROM_MTA
//
// MessageText:
//
// Activating a single-threaded class from MTA is not supported
//


//
// MessageId: RO_E_COMMITTED
//
// MessageText:
//
// The object has been committed.
//


//
// MessageId: RO_E_BLOCKED_CROSS_ASTA_CALL
//
// MessageText:
//
// A COM call to an ASTA was blocked because the call chain originated in or passed through another ASTA. This call pattern is deadlock-prone and disallowed by apartment call control.
//


//
// MessageId: RO_E_CANNOT_ACTIVATE_FULL_TRUST_SERVER
//
// MessageText:
//
// A universal application process cannot activate a packaged WinRT server that is declared to run full trust.
//


//
// MessageId: RO_E_CANNOT_ACTIVATE_UNIVERSAL_APPLICATION_SERVER
//
// MessageText:
//
// A full trust packaged application process cannot activate a packaged WinRT server unless it is also declared to run full trust.
//


//
// MessageId: CO_E_INIT_TLS
//
// MessageText:
//
// Thread local storage failure
//


//
// MessageId: CO_E_INIT_SHARED_ALLOCATOR
//
// MessageText:
//
// Get shared memory allocator failure
//


//
// MessageId: CO_E_INIT_MEMORY_ALLOCATOR
//
// MessageText:
//
// Get memory allocator failure
//


//
// MessageId: CO_E_INIT_CLASS_CACHE
//
// MessageText:
//
// Unable to initialize class cache
//


//
// MessageId: CO_E_INIT_RPC_CHANNEL
//
// MessageText:
//
// Unable to initialize RPC services
//


//
// MessageId: CO_E_INIT_TLS_SET_CHANNEL_CONTROL
//
// MessageText:
//
// Cannot set thread local storage channel control
//


//
// MessageId: CO_E_INIT_TLS_CHANNEL_CONTROL
//
// MessageText:
//
// Could not allocate thread local storage channel control
//


//
// MessageId: CO_E_INIT_UNACCEPTED_USER_ALLOCATOR
//
// MessageText:
//
// The user supplied memory allocator is unacceptable
//


//
// MessageId: CO_E_INIT_SCM_MUTEX_EXISTS
//
// MessageText:
//
// The OLE service mutex already exists
//


//
// MessageId: CO_E_INIT_SCM_FILE_MAPPING_EXISTS
//
// MessageText:
//
// The OLE service file mapping already exists
//


//
// MessageId: CO_E_INIT_SCM_MAP_VIEW_OF_FILE
//
// MessageText:
//
// Unable to map view of file for OLE service
//


//
// MessageId: CO_E_INIT_SCM_EXEC_FAILURE
//
// MessageText:
//
// Failure attempting to launch OLE service
//


//
// MessageId: CO_E_INIT_ONLY_SINGLE_THREADED
//
// MessageText:
//
// There was an attempt to call CoInitialize a second time while single threaded
//


//
// MessageId: CO_E_CANT_REMOTE
//
// MessageText:
//
// A Remote activation was necessary but was not allowed
//


//
// MessageId: CO_E_BAD_SERVER_NAME
//
// MessageText:
//
// A Remote activation was necessary but the server name provided was invalid
//


//
// MessageId: CO_E_WRONG_SERVER_IDENTITY
//
// MessageText:
//
// The class is configured to run as a security id different from the caller
//


//
// MessageId: CO_E_OLE1DDE_DISABLED
//
// MessageText:
//
// Use of Ole1 services requiring DDE windows is disabled
//


//
// MessageId: CO_E_RUNAS_SYNTAX
//
// MessageText:
//
// A RunAs specification must be <domain name>\<user name> or simply <user name>
//


//
// MessageId: CO_E_CREATEPROCESS_FAILURE
//
// MessageText:
//
// The server process could not be started. The pathname may be incorrect.
//


//
// MessageId: CO_E_RUNAS_CREATEPROCESS_FAILURE
//
// MessageText:
//
// The server process could not be started as the configured identity. The pathname may be incorrect or unavailable.
//


//
// MessageId: CO_E_RUNAS_LOGON_FAILURE
//
// MessageText:
//
// The server process could not be started because the configured identity is incorrect. Check the username and password.
//


//
// MessageId: CO_E_LAUNCH_PERMSSION_DENIED
//
// MessageText:
//
// The client is not allowed to launch this server.
//


//
// MessageId: CO_E_START_SERVICE_FAILURE
//
// MessageText:
//
// The service providing this server could not be started.
//


//
// MessageId: CO_E_REMOTE_COMMUNICATION_FAILURE
//
// MessageText:
//
// This computer was unable to communicate with the computer providing the server.
//


//
// MessageId: CO_E_SERVER_START_TIMEOUT
//
// MessageText:
//
// The server did not respond after being launched.
//


//
// MessageId: CO_E_CLSREG_INCONSISTENT
//
// MessageText:
//
// The registration information for this server is inconsistent or incomplete.
//


//
// MessageId: CO_E_IIDREG_INCONSISTENT
//
// MessageText:
//
// The registration information for this interface is inconsistent or incomplete.
//


//
// MessageId: CO_E_NOT_SUPPORTED
//
// MessageText:
//
// The operation attempted is not supported.
//


//
// MessageId: CO_E_RELOAD_DLL
//
// MessageText:
//
// A dll must be loaded.
//


//
// MessageId: CO_E_MSI_ERROR
//
// MessageText:
//
// A Microsoft Software Installer error was encountered.
//


//
// MessageId: CO_E_ATTEMPT_TO_CREATE_OUTSIDE_CLIENT_CONTEXT
//
// MessageText:
//
// The specified activation could not occur in the client context as specified.
//


//
// MessageId: CO_E_SERVER_PAUSED
//
// MessageText:
//
// Activations on the server are paused.
//


//
// MessageId: CO_E_SERVER_NOT_PAUSED
//
// MessageText:
//
// Activations on the server are not paused.
//


//
// MessageId: CO_E_CLASS_DISABLED
//
// MessageText:
//
// The component or application containing the component has been disabled.
//


//
// MessageId: CO_E_CLRNOTAVAILABLE
//
// MessageText:
//
// The common language runtime is not available
//


//
// MessageId: CO_E_ASYNC_WORK_REJECTED
//
// MessageText:
//
// The thread-pool rejected the submitted asynchronous work.
//


//
// MessageId: CO_E_SERVER_INIT_TIMEOUT
//
// MessageText:
//
// The server started, but did not finish initializing in a timely fashion.
//


//
// MessageId: CO_E_NO_SECCTX_IN_ACTIVATE
//
// MessageText:
//
// Unable to complete the call since there is no COM+ security context inside IObjectControl.Activate.
//


//
// MessageId: CO_E_TRACKER_CONFIG
//
// MessageText:
//
// The provided tracker configuration is invalid
//


//
// MessageId: CO_E_THREADPOOL_CONFIG
//
// MessageText:
//
// The provided thread pool configuration is invalid
//


//
// MessageId: CO_E_SXS_CONFIG
//
// MessageText:
//
// The provided side-by-side configuration is invalid
//


//
// MessageId: CO_E_MALFORMED_SPN
//
// MessageText:
//
// The server principal name (SPN) obtained during security negotiation is malformed.
//


//
// MessageId: CO_E_UNREVOKED_REGISTRATION_ON_APARTMENT_SHUTDOWN
//
// MessageText:
//
// The caller failed to revoke a per-apartment registration before apartment shutdown.
//


//
// MessageId: CO_E_PREMATURE_STUB_RUNDOWN
//
// MessageText:
//
// The object has been rundown by the stub manager while there are external clients.
//



//
// Success codes
//



// ******************
// FACILITY_ITF
// ******************

//
// Codes 0x0-0x01ff are reserved for the OLE group of
// interfaces.
//


//
// Generic OLE errors that may be returned by many interfaces
//






//
// Old OLE errors
//
//
// MessageId: OLE_E_OLEVERB
//
// MessageText:
//
// Invalid OLEVERB structure
//


//
// MessageId: OLE_E_ADVF
//
// MessageText:
//
// Invalid advise flags
//


//
// MessageId: OLE_E_ENUM_NOMORE
//
// MessageText:
//
// Can't enumerate any more, because the associated data is missing
//


//
// MessageId: OLE_E_ADVISENOTSUPPORTED
//
// MessageText:
//
// This implementation doesn't take advises
//


//
// MessageId: OLE_E_NOCONNECTION
//
// MessageText:
//
// There is no connection for this connection ID
//


//
// MessageId: OLE_E_NOTRUNNING
//
// MessageText:
//
// Need to run the object to perform this operation
//


//
// MessageId: OLE_E_NOCACHE
//
// MessageText:
//
// There is no cache to operate on
//


//
// MessageId: OLE_E_BLANK
//
// MessageText:
//
// Uninitialized object
//


//
// MessageId: OLE_E_CLASSDIFF
//
// MessageText:
//
// Linked object's source class has changed
//


//
// MessageId: OLE_E_CANT_GETMONIKER
//
// MessageText:
//
// Not able to get the moniker of the object
//


//
// MessageId: OLE_E_CANT_BINDTOSOURCE
//
// MessageText:
//
// Not able to bind to the source
//


//
// MessageId: OLE_E_STATIC
//
// MessageText:
//
// Object is static; operation not allowed
//


//
// MessageId: OLE_E_PROMPTSAVECANCELLED
//
// MessageText:
//
// User canceled out of save dialog
//


//
// MessageId: OLE_E_INVALIDRECT
//
// MessageText:
//
// Invalid rectangle
//


//
// MessageId: OLE_E_WRONGCOMPOBJ
//
// MessageText:
//
// compobj.dll is too old for the ole2.dll initialized
//


//
// MessageId: OLE_E_INVALIDHWND
//
// MessageText:
//
// Invalid window handle
//


//
// MessageId: OLE_E_NOT_INPLACEACTIVE
//
// MessageText:
//
// Object is not in any of the inplace active states
//


//
// MessageId: OLE_E_CANTCONVERT
//
// MessageText:
//
// Not able to convert object
//


//
// MessageId: OLE_E_NOSTORAGE
//
// MessageText:
//
// Not able to perform the operation because object is not given storage yet
//


//
// MessageId: DV_E_FORMATETC
//
// MessageText:
//
// Invalid FORMATETC structure
//


//
// MessageId: DV_E_DVTARGETDEVICE
//
// MessageText:
//
// Invalid DVTARGETDEVICE structure
//


//
// MessageId: DV_E_STGMEDIUM
//
// MessageText:
//
// Invalid STDGMEDIUM structure
//


//
// MessageId: DV_E_STATDATA
//
// MessageText:
//
// Invalid STATDATA structure
//


//
// MessageId: DV_E_LINDEX
//
// MessageText:
//
// Invalid lindex
//


//
// MessageId: DV_E_TYMED
//
// MessageText:
//
// Invalid tymed
//


//
// MessageId: DV_E_CLIPFORMAT
//
// MessageText:
//
// Invalid clipboard format
//


//
// MessageId: DV_E_DVASPECT
//
// MessageText:
//
// Invalid aspect(s)
//


//
// MessageId: DV_E_DVTARGETDEVICE_SIZE
//
// MessageText:
//
// tdSize parameter of the DVTARGETDEVICE structure is invalid
//


//
// MessageId: DV_E_NOIVIEWOBJECT
//
// MessageText:
//
// Object doesn't support IViewObject interface
//






//
// MessageId: DRAGDROP_E_NOTREGISTERED
//
// MessageText:
//
// Trying to revoke a drop target that has not been registered
//


//
// MessageId: DRAGDROP_E_ALREADYREGISTERED
//
// MessageText:
//
// This window has already been registered as a drop target
//


//
// MessageId: DRAGDROP_E_INVALIDHWND
//
// MessageText:
//
// Invalid window handle
//


//
// MessageId: DRAGDROP_E_CONCURRENT_DRAG_ATTEMPTED
//
// MessageText:
//
// A drag operation is already in progress
//






//
// MessageId: CLASS_E_NOAGGREGATION
//
// MessageText:
//
// Class does not support aggregation (or class object is remote)
//


//
// MessageId: CLASS_E_CLASSNOTAVAILABLE
//
// MessageText:
//
// ClassFactory cannot supply requested class
//


//
// MessageId: CLASS_E_NOTLICENSED
//
// MessageText:
//
// Class is not licensed for use
//














//
// MessageId: VIEW_E_DRAW
//
// MessageText:
//
// Error drawing view
//






//
// MessageId: REGDB_E_READREGDB
//
// MessageText:
//
// Could not read key from registry
//


//
// MessageId: REGDB_E_WRITEREGDB
//
// MessageText:
//
// Could not write key to registry
//


//
// MessageId: REGDB_E_KEYMISSING
//
// MessageText:
//
// Could not find the key in the registry
//


//
// MessageId: REGDB_E_INVALIDVALUE
//
// MessageText:
//
// Invalid value for registry
//


//
// MessageId: REGDB_E_CLASSNOTREG
//
// MessageText:
//
// Class not registered
//


//
// MessageId: REGDB_E_IIDNOTREG
//
// MessageText:
//
// Interface not registered
//


//
// MessageId: REGDB_E_BADTHREADINGMODEL
//
// MessageText:
//
// Threading model entry is not valid
//


//
// MessageId: REGDB_E_PACKAGEPOLICYVIOLATION
//
// MessageText:
//
// A registration in a package violates package-specific policies
//




//
// MessageId: CAT_E_CATIDNOEXIST
//
// MessageText:
//
// CATID does not exist
//


//
// MessageId: CAT_E_NODESCRIPTION
//
// MessageText:
//
// Description not found
//


////////////////////////////////////
//                                //
//     Class Store Error Codes    //
//                                //
////////////////////////////////////


//
// MessageId: CS_E_PACKAGE_NOTFOUND
//
// MessageText:
//
// No package in the software installation data in the Active Directory meets this criteria.
//


//
// MessageId: CS_E_NOT_DELETABLE
//
// MessageText:
//
// Deleting this will break the referential integrity of the software installation data in the Active Directory.
//


//
// MessageId: CS_E_CLASS_NOTFOUND
//
// MessageText:
//
// The CLSID was not found in the software installation data in the Active Directory.
//


//
// MessageId: CS_E_INVALID_VERSION
//
// MessageText:
//
// The software installation data in the Active Directory is corrupt.
//


//
// MessageId: CS_E_NO_CLASSSTORE
//
// MessageText:
//
// There is no software installation data in the Active Directory.
//


//
// MessageId: CS_E_OBJECT_NOTFOUND
//
// MessageText:
//
// There is no software installation data object in the Active Directory.
//


//
// MessageId: CS_E_OBJECT_ALREADY_EXISTS
//
// MessageText:
//
// The software installation data object in the Active Directory already exists.
//


//
// MessageId: CS_E_INVALID_PATH
//
// MessageText:
//
// The path to the software installation data in the Active Directory is not correct.
//


//
// MessageId: CS_E_NETWORK_ERROR
//
// MessageText:
//
// A network error interrupted the operation.
//


//
// MessageId: CS_E_ADMIN_LIMIT_EXCEEDED
//
// MessageText:
//
// The size of this object exceeds the maximum size set by the Administrator.
//


//
// MessageId: CS_E_SCHEMA_MISMATCH
//
// MessageText:
//
// The schema for the software installation data in the Active Directory does not match the required schema.
//


//
// MessageId: CS_E_INTERNAL_ERROR
//
// MessageText:
//
// An error occurred in the software installation data in the Active Directory.
//






//
// MessageId: CACHE_E_NOCACHE_UPDATED
//
// MessageText:
//
// Cache not updated
//






//
// MessageId: OLEOBJ_E_NOVERBS
//
// MessageText:
//
// No verbs for OLE object
//


//
// MessageId: OLEOBJ_E_INVALIDVERB
//
// MessageText:
//
// Invalid verb for OLE object
//






//
// MessageId: INPLACE_E_NOTUNDOABLE
//
// MessageText:
//
// Undo is not available
//


//
// MessageId: INPLACE_E_NOTOOLSPACE
//
// MessageText:
//
// Space for tools is not available
//














//
// MessageId: CONVERT10_E_OLESTREAM_GET
//
// MessageText:
//
// OLESTREAM Get method failed
//


//
// MessageId: CONVERT10_E_OLESTREAM_PUT
//
// MessageText:
//
// OLESTREAM Put method failed
//


//
// MessageId: CONVERT10_E_OLESTREAM_FMT
//
// MessageText:
//
// Contents of the OLESTREAM not in correct format
//


//
// MessageId: CONVERT10_E_OLESTREAM_BITMAP_TO_DIB
//
// MessageText:
//
// There was an error in a Windows GDI call while converting the bitmap to a DIB
//


//
// MessageId: CONVERT10_E_STG_FMT
//
// MessageText:
//
// Contents of the IStorage not in correct format
//


//
// MessageId: CONVERT10_E_STG_NO_STD_STREAM
//
// MessageText:
//
// Contents of IStorage is missing one of the standard streams
//


//
// MessageId: CONVERT10_E_STG_DIB_TO_BITMAP
//
// MessageText:
//
// There was an error in a Windows GDI call while converting the DIB to a bitmap.
//






//
// MessageId: CLIPBRD_E_CANT_OPEN
//
// MessageText:
//
// OpenClipboard Failed
//


//
// MessageId: CLIPBRD_E_CANT_EMPTY
//
// MessageText:
//
// EmptyClipboard Failed
//


//
// MessageId: CLIPBRD_E_CANT_SET
//
// MessageText:
//
// SetClipboard Failed
//


//
// MessageId: CLIPBRD_E_BAD_DATA
//
// MessageText:
//
// Data on clipboard is invalid
//


//
// MessageId: CLIPBRD_E_CANT_CLOSE
//
// MessageText:
//
// CloseClipboard Failed
//






//
// MessageId: MK_E_CONNECTMANUALLY
//
// MessageText:
//
// Moniker needs to be connected manually
//


//
// MessageId: MK_E_EXCEEDEDDEADLINE
//
// MessageText:
//
// Operation exceeded deadline
//


//
// MessageId: MK_E_NEEDGENERIC
//
// MessageText:
//
// Moniker needs to be generic
//


//
// MessageId: MK_E_UNAVAILABLE
//
// MessageText:
//
// Operation unavailable
//


//
// MessageId: MK_E_SYNTAX
//
// MessageText:
//
// Invalid syntax
//


//
// MessageId: MK_E_NOOBJECT
//
// MessageText:
//
// No object for moniker
//


//
// MessageId: MK_E_INVALIDEXTENSION
//
// MessageText:
//
// Bad extension for file
//


//
// MessageId: MK_E_INTERMEDIATEINTERFACENOTSUPPORTED
//
// MessageText:
//
// Intermediate operation failed
//


//
// MessageId: MK_E_NOTBINDABLE
//
// MessageText:
//
// Moniker is not bindable
//


//
// MessageId: MK_E_NOTBOUND
//
// MessageText:
//
// Moniker is not bound
//


//
// MessageId: MK_E_CANTOPENFILE
//
// MessageText:
//
// Moniker cannot open file
//


//
// MessageId: MK_E_MUSTBOTHERUSER
//
// MessageText:
//
// User input required for operation to succeed
//


//
// MessageId: MK_E_NOINVERSE
//
// MessageText:
//
// Moniker class has no inverse
//


//
// MessageId: MK_E_NOSTORAGE
//
// MessageText:
//
// Moniker does not refer to storage
//


//
// MessageId: MK_E_NOPREFIX
//
// MessageText:
//
// No common prefix
//


//
// MessageId: MK_E_ENUMERATION_FAILED
//
// MessageText:
//
// Moniker could not be enumerated
//






//
// MessageId: CO_E_NOTINITIALIZED
//
// MessageText:
//
// CoInitialize has not been called.
//


//
// MessageId: CO_E_ALREADYINITIALIZED
//
// MessageText:
//
// CoInitialize has already been called.
//


//
// MessageId: CO_E_CANTDETERMINECLASS
//
// MessageText:
//
// Class of object cannot be determined
//


//
// MessageId: CO_E_CLASSSTRING
//
// MessageText:
//
// Invalid class string
//


//
// MessageId: CO_E_IIDSTRING
//
// MessageText:
//
// Invalid interface string
//


//
// MessageId: CO_E_APPNOTFOUND
//
// MessageText:
//
// Application not found
//


//
// MessageId: CO_E_APPSINGLEUSE
//
// MessageText:
//
// Application cannot be run more than once
//


//
// MessageId: CO_E_ERRORINAPP
//
// MessageText:
//
// Some error in application program
//


//
// MessageId: CO_E_DLLNOTFOUND
//
// MessageText:
//
// DLL for class not found
//


//
// MessageId: CO_E_ERRORINDLL
//
// MessageText:
//
// Error in the DLL
//


//
// MessageId: CO_E_WRONGOSFORAPP
//
// MessageText:
//
// Wrong OS or OS version for application
//


//
// MessageId: CO_E_OBJNOTREG
//
// MessageText:
//
// Object is not registered
//


//
// MessageId: CO_E_OBJISREG
//
// MessageText:
//
// Object is already registered
//


//
// MessageId: CO_E_OBJNOTCONNECTED
//
// MessageText:
//
// Object is not connected to server
//


//
// MessageId: CO_E_APPDIDNTREG
//
// MessageText:
//
// Application was launched but it didn't register a class factory
//


//
// MessageId: CO_E_RELEASED
//
// MessageText:
//
// Object has been released
//






//
// MessageId: EVENT_S_SOME_SUBSCRIBERS_FAILED
//
// MessageText:
//
// An event was able to invoke some but not all of the subscribers
//


//
// MessageId: EVENT_E_ALL_SUBSCRIBERS_FAILED
//
// MessageText:
//
// An event was unable to invoke any of the subscribers
//


//
// MessageId: EVENT_S_NOSUBSCRIBERS
//
// MessageText:
//
// An event was delivered but there were no subscribers
//


//
// MessageId: EVENT_E_QUERYSYNTAX
//
// MessageText:
//
// A syntax error occurred trying to evaluate a query string
//


//
// MessageId: EVENT_E_QUERYFIELD
//
// MessageText:
//
// An invalid field name was used in a query string
//


//
// MessageId: EVENT_E_INTERNALEXCEPTION
//
// MessageText:
//
// An unexpected exception was raised
//


//
// MessageId: EVENT_E_INTERNALERROR
//
// MessageText:
//
// An unexpected internal error was detected
//


//
// MessageId: EVENT_E_INVALID_PER_USER_SID
//
// MessageText:
//
// The owner SID on a per-user subscription doesn't exist
//


//
// MessageId: EVENT_E_USER_EXCEPTION
//
// MessageText:
//
// A user-supplied component or subscriber raised an exception
//


//
// MessageId: EVENT_E_TOO_MANY_METHODS
//
// MessageText:
//
// An interface has too many methods to fire events from
//


//
// MessageId: EVENT_E_MISSING_EVENTCLASS
//
// MessageText:
//
// A subscription cannot be stored unless its event class already exists
//


//
// MessageId: EVENT_E_NOT_ALL_REMOVED
//
// MessageText:
//
// Not all the objects requested could be removed
//


//
// MessageId: EVENT_E_COMPLUS_NOT_INSTALLED
//
// MessageText:
//
// COM+ is required for this operation, but is not installed
//


//
// MessageId: EVENT_E_CANT_MODIFY_OR_DELETE_UNCONFIGURED_OBJECT
//
// MessageText:
//
// Cannot modify or delete an object that was not added using the COM+ Admin SDK
//


//
// MessageId: EVENT_E_CANT_MODIFY_OR_DELETE_CONFIGURED_OBJECT
//
// MessageText:
//
// Cannot modify or delete an object that was added using the COM+ Admin SDK
//


//
// MessageId: EVENT_E_INVALID_EVENT_CLASS_PARTITION
//
// MessageText:
//
// The event class for this subscription is in an invalid partition
//


//
// MessageId: EVENT_E_PER_USER_SID_NOT_LOGGED_ON
//
// MessageText:
//
// The owner of the PerUser subscription is not logged on to the system specified
//


//
// MessageId: TPC_E_INVALID_PROPERTY
//
// MessageText:
//
// TabletPC inking error code. The property was not found, or supported by the recognizer
//


//
// MessageId: TPC_E_NO_DEFAULT_TABLET
//
// MessageText:
//
// TabletPC inking error code. No default tablet
//


//
// MessageId: TPC_E_UNKNOWN_PROPERTY
//
// MessageText:
//
// TabletPC inking error code. Unknown property specified
//


//
// MessageId: TPC_E_INVALID_INPUT_RECT
//
// MessageText:
//
// TabletPC inking error code. An invalid input rectangle was specified
//


//
// MessageId: TPC_E_INVALID_STROKE
//
// MessageText:
//
// TabletPC inking error code. The stroke object was deleted
//


//
// MessageId: TPC_E_INITIALIZE_FAIL
//
// MessageText:
//
// TabletPC inking error code. Initialization failure
//


//
// MessageId: TPC_E_NOT_RELEVANT
//
// MessageText:
//
// TabletPC inking error code. The data required for the operation was not supplied
//


//
// MessageId: TPC_E_INVALID_PACKET_DESCRIPTION
//
// MessageText:
//
// TabletPC inking error code. Invalid packet description
//


//
// MessageId: TPC_E_RECOGNIZER_NOT_REGISTERED
//
// MessageText:
//
// TabletPC inking error code. There are no handwriting recognizers registered
//


//
// MessageId: TPC_E_INVALID_RIGHTS
//
// MessageText:
//
// TabletPC inking error code. User does not have the necessary rights to read recognizer information
//


//
// MessageId: TPC_E_OUT_OF_ORDER_CALL
//
// MessageText:
//
// TabletPC inking error code. API calls were made in an incorrect order
//


//
// MessageId: TPC_E_QUEUE_FULL
//
// MessageText:
//
// TabletPC inking error code. Queue is full
//


//
// MessageId: TPC_E_INVALID_CONFIGURATION
//
// MessageText:
//
// TabletPC inking error code. RtpEnabled called multiple times
//


//
// MessageId: TPC_E_INVALID_DATA_FROM_RECOGNIZER
//
// MessageText:
//
// TabletPC inking error code. A recognizer returned invalid data
//


//
// MessageId: TPC_S_TRUNCATED
//
// MessageText:
//
// TabletPC inking error code. String was truncated
//


//
// MessageId: TPC_S_INTERRUPTED
//
// MessageText:
//
// TabletPC inking error code. Recognition or training was interrupted
//


//
// MessageId: TPC_S_NO_DATA_TO_PROCESS
//
// MessageText:
//
// TabletPC inking error code. No personalization update to the recognizer because no training data found
//






//
// MessageId: XACT_E_ALREADYOTHERSINGLEPHASE
//
// MessageText:
//
// Another single phase resource manager has already been enlisted in this transaction.
//


//
// MessageId: XACT_E_CANTRETAIN
//
// MessageText:
//
// A retaining commit or abort is not supported
//


//
// MessageId: XACT_E_COMMITFAILED
//
// MessageText:
//
// The transaction failed to commit for an unknown reason. The transaction was aborted.
//


//
// MessageId: XACT_E_COMMITPREVENTED
//
// MessageText:
//
// Cannot call commit on this transaction object because the calling application did not initiate the transaction.
//


//
// MessageId: XACT_E_HEURISTICABORT
//
// MessageText:
//
// Instead of committing, the resource heuristically aborted.
//


//
// MessageId: XACT_E_HEURISTICCOMMIT
//
// MessageText:
//
// Instead of aborting, the resource heuristically committed.
//


//
// MessageId: XACT_E_HEURISTICDAMAGE
//
// MessageText:
//
// Some of the states of the resource were committed while others were aborted, likely because of heuristic decisions.
//


//
// MessageId: XACT_E_HEURISTICDANGER
//
// MessageText:
//
// Some of the states of the resource may have been committed while others may have been aborted, likely because of heuristic decisions.
//


//
// MessageId: XACT_E_ISOLATIONLEVEL
//
// MessageText:
//
// The requested isolation level is not valid or supported.
//


//
// MessageId: XACT_E_NOASYNC
//
// MessageText:
//
// The transaction manager doesn't support an asynchronous operation for this method.
//


//
// MessageId: XACT_E_NOENLIST
//
// MessageText:
//
// Unable to enlist in the transaction.
//


//
// MessageId: XACT_E_NOISORETAIN
//
// MessageText:
//
// The requested semantics of retention of isolation across retaining commit and abort boundaries cannot be supported by this transaction implementation, or isoFlags was not equal to zero.
//


//
// MessageId: XACT_E_NORESOURCE
//
// MessageText:
//
// There is no resource presently associated with this enlistment
//


//
// MessageId: XACT_E_NOTCURRENT
//
// MessageText:
//
// The transaction failed to commit due to the failure of optimistic concurrency control in at least one of the resource managers.
//


//
// MessageId: XACT_E_NOTRANSACTION
//
// MessageText:
//
// The transaction has already been implicitly or explicitly committed or aborted
//


//
// MessageId: XACT_E_NOTSUPPORTED
//
// MessageText:
//
// An invalid combination of flags was specified
//


//
// MessageId: XACT_E_UNKNOWNRMGRID
//
// MessageText:
//
// The resource manager id is not associated with this transaction or the transaction manager.
//


//
// MessageId: XACT_E_WRONGSTATE
//
// MessageText:
//
// This method was called in the wrong state
//


//
// MessageId: XACT_E_WRONGUOW
//
// MessageText:
//
// The indicated unit of work does not match the unit of work expected by the resource manager.
//


//
// MessageId: XACT_E_XTIONEXISTS
//
// MessageText:
//
// An enlistment in a transaction already exists.
//


//
// MessageId: XACT_E_NOIMPORTOBJECT
//
// MessageText:
//
// An import object for the transaction could not be found.
//


//
// MessageId: XACT_E_INVALIDCOOKIE
//
// MessageText:
//
// The transaction cookie is invalid.
//


//
// MessageId: XACT_E_INDOUBT
//
// MessageText:
//
// The transaction status is in doubt. A communication failure occurred, or a transaction manager or resource manager has failed
//


//
// MessageId: XACT_E_NOTIMEOUT
//
// MessageText:
//
// A time-out was specified, but time-outs are not supported.
//


//
// MessageId: XACT_E_ALREADYINPROGRESS
//
// MessageText:
//
// The requested operation is already in progress for the transaction.
//


//
// MessageId: XACT_E_ABORTED
//
// MessageText:
//
// The transaction has already been aborted.
//


//
// MessageId: XACT_E_LOGFULL
//
// MessageText:
//
// The Transaction Manager returned a log full error.
//


//
// MessageId: XACT_E_TMNOTAVAILABLE
//
// MessageText:
//
// The Transaction Manager is not available.
//


//
// MessageId: XACT_E_CONNECTION_DOWN
//
// MessageText:
//
// A connection with the transaction manager was lost.
//


//
// MessageId: XACT_E_CONNECTION_DENIED
//
// MessageText:
//
// A request to establish a connection with the transaction manager was denied.
//


//
// MessageId: XACT_E_REENLISTTIMEOUT
//
// MessageText:
//
// Resource manager reenlistment to determine transaction status timed out.
//


//
// MessageId: XACT_E_TIP_CONNECT_FAILED
//
// MessageText:
//
// This transaction manager failed to establish a connection with another TIP transaction manager.
//


//
// MessageId: XACT_E_TIP_PROTOCOL_ERROR
//
// MessageText:
//
// This transaction manager encountered a protocol error with another TIP transaction manager.
//


//
// MessageId: XACT_E_TIP_PULL_FAILED
//
// MessageText:
//
// This transaction manager could not propagate a transaction from another TIP transaction manager.
//


//
// MessageId: XACT_E_DEST_TMNOTAVAILABLE
//
// MessageText:
//
// The Transaction Manager on the destination machine is not available.
//


//
// MessageId: XACT_E_TIP_DISABLED
//
// MessageText:
//
// The Transaction Manager has disabled its support for TIP.
//


//
// MessageId: XACT_E_NETWORK_TX_DISABLED
//
// MessageText:
//
// The transaction manager has disabled its support for remote/network transactions.
//


//
// MessageId: XACT_E_PARTNER_NETWORK_TX_DISABLED
//
// MessageText:
//
// The partner transaction manager has disabled its support for remote/network transactions.
//


//
// MessageId: XACT_E_XA_TX_DISABLED
//
// MessageText:
//
// The transaction manager has disabled its support for XA transactions.
//


//
// MessageId: XACT_E_UNABLE_TO_READ_DTC_CONFIG
//
// MessageText:
//
// MSDTC was unable to read its configuration information.
//


//
// MessageId: XACT_E_UNABLE_TO_LOAD_DTC_PROXY
//
// MessageText:
//
// MSDTC was unable to load the dtc proxy dll.
//


//
// MessageId: XACT_E_ABORTING
//
// MessageText:
//
// The local transaction has aborted.
//


//
// MessageId: XACT_E_PUSH_COMM_FAILURE
//
// MessageText:
//
// The MSDTC transaction manager was unable to push the transaction to the destination transaction manager due to communication problems. Possible causes are: a firewall is present and it doesn't have an exception for the MSDTC process, the two machines cannot find each other by their NetBIOS names, or the support for network transactions is not enabled for one of the two transaction managers.
//


//
// MessageId: XACT_E_PULL_COMM_FAILURE
//
// MessageText:
//
// The MSDTC transaction manager was unable to pull the transaction from the source transaction manager due to communication problems. Possible causes are: a firewall is present and it doesn't have an exception for the MSDTC process, the two machines cannot find each other by their NetBIOS names, or the support for network transactions is not enabled for one of the two transaction managers.
//


//
// MessageId: XACT_E_LU_TX_DISABLED
//
// MessageText:
//
// The MSDTC transaction manager has disabled its support for SNA LU 6.2 transactions.
//


//
// TXF & CRM errors start 4d080.
//
// MessageId: XACT_E_CLERKNOTFOUND
//
// MessageText:
//
//  XACT_E_CLERKNOTFOUND
//


//
// MessageId: XACT_E_CLERKEXISTS
//
// MessageText:
//
//  XACT_E_CLERKEXISTS
//


//
// MessageId: XACT_E_RECOVERYINPROGRESS
//
// MessageText:
//
//  XACT_E_RECOVERYINPROGRESS
//


//
// MessageId: XACT_E_TRANSACTIONCLOSED
//
// MessageText:
//
//  XACT_E_TRANSACTIONCLOSED
//


//
// MessageId: XACT_E_INVALIDLSN
//
// MessageText:
//
//  XACT_E_INVALIDLSN
//


//
// MessageId: XACT_E_REPLAYREQUEST
//
// MessageText:
//
//  XACT_E_REPLAYREQUEST
//


// Begin XACT_DTC_CONSTANTS enumerated values defined in txdtc.h

// SymbolicName=XACT_E_CONNECTION_REQUEST_DENIED
//
// MessageId: 0x8004D100L (No symbolic name defined)
//
// MessageText:
//
// The request to connect to the specified transaction coordinator was denied.
//


// SymbolicName=XACT_E_TOOMANY_ENLISTMENTS
//
// MessageId: 0x8004D101L (No symbolic name defined)
//
// MessageText:
//
// The maximum number of enlistments for the specified transaction has been reached.
//


// SymbolicName=XACT_E_DUPLICATE_GUID
//
// MessageId: 0x8004D102L (No symbolic name defined)
//
// MessageText:
//
// A resource manager with the same identifier is already registered with the specified transaction coordinator.
//


// SymbolicName=XACT_E_NOTSINGLEPHASE
//
// MessageId: 0x8004D103L (No symbolic name defined)
//
// MessageText:
//
// The prepare request given was not eligible for single phase optimizations.
//


// SymbolicName=XACT_E_RECOVERYALREADYDONE
//
// MessageId: 0x8004D104L (No symbolic name defined)
//
// MessageText:
//
// RecoveryComplete has already been called for the given resource manager.
//


// SymbolicName=XACT_E_PROTOCOL
//
// MessageId: 0x8004D105L (No symbolic name defined)
//
// MessageText:
//
// The interface call made was incorrect for the current state of the protocol.
//


// SymbolicName=XACT_E_RM_FAILURE
//
// MessageId: 0x8004D106L (No symbolic name defined)
//
// MessageText:
//
// xa_open call failed for the XA resource.
//


// SymbolicName=XACT_E_RECOVERY_FAILED
//
// MessageId: 0x8004D107L (No symbolic name defined)
//
// MessageText:
//
// xa_recover call failed for the XA resource.
//


// SymbolicName=XACT_E_LU_NOT_FOUND
//
// MessageId: 0x8004D108L (No symbolic name defined)
//
// MessageText:
//
// The Logical Unit of Work specified cannot be found.
//


// SymbolicName=XACT_E_DUPLICATE_LU
//
// MessageId: 0x8004D109L (No symbolic name defined)
//
// MessageText:
//
// The specified Logical Unit of Work already exists.
//


// SymbolicName=XACT_E_LU_NOT_CONNECTED
//
// MessageId: 0x8004D10AL (No symbolic name defined)
//
// MessageText:
//
// Subordinate creation failed. The specified Logical Unit of Work was not connected.
//


// SymbolicName=XACT_E_DUPLICATE_TRANSID
//
// MessageId: 0x8004D10BL (No symbolic name defined)
//
// MessageText:
//
// A transaction with the given identifier already exists.
//


// SymbolicName=XACT_E_LU_BUSY
//
// MessageId: 0x8004D10CL (No symbolic name defined)
//
// MessageText:
//
// The resource is in use.
//


// SymbolicName=XACT_E_LU_NO_RECOVERY_PROCESS
//
// MessageId: 0x8004D10DL (No symbolic name defined)
//
// MessageText:
//
// The LU Recovery process is down.
//


// SymbolicName=XACT_E_LU_DOWN
//
// MessageId: 0x8004D10EL (No symbolic name defined)
//
// MessageText:
//
// The remote session was lost.
//


// SymbolicName=XACT_E_LU_RECOVERING
//
// MessageId: 0x8004D10FL (No symbolic name defined)
//
// MessageText:
//
// The resource is currently recovering.
//


// SymbolicName=XACT_E_LU_RECOVERY_MISMATCH
//
// MessageId: 0x8004D110L (No symbolic name defined)
//
// MessageText:
//
// There was a mismatch in driving recovery.
//


// SymbolicName=XACT_E_RM_UNAVAILABLE
//
// MessageId: 0x8004D111L (No symbolic name defined)
//
// MessageText:
//
// An error occurred with the XA resource.
//


// End XACT_DTC_CONSTANTS enumerated values defined in txdtc.h

//
// OleTx Success codes.
//
//
// MessageId: XACT_S_ASYNC
//
// MessageText:
//
// An asynchronous operation was specified. The operation has begun, but its outcome is not known yet.
//


//
// MessageId: XACT_S_DEFECT
//
// MessageText:
//
//  XACT_S_DEFECT
//


//
// MessageId: XACT_S_READONLY
//
// MessageText:
//
// The method call succeeded because the transaction was read-only.
//


//
// MessageId: XACT_S_SOMENORETAIN
//
// MessageText:
//
// The transaction was successfully aborted. However, this is a coordinated transaction, and some number of enlisted resources were aborted outright because they could not support abort-retaining semantics
//


//
// MessageId: XACT_S_OKINFORM
//
// MessageText:
//
// No changes were made during this call, but the sink wants another chance to look if any other sinks make further changes.
//


//
// MessageId: XACT_S_MADECHANGESCONTENT
//
// MessageText:
//
// The sink is content and wishes the transaction to proceed. Changes were made to one or more resources during this call.
//


//
// MessageId: XACT_S_MADECHANGESINFORM
//
// MessageText:
//
// The sink is for the moment and wishes the transaction to proceed, but if other changes are made following this return by other event sinks then this sink wants another chance to look
//


//
// MessageId: XACT_S_ALLNORETAIN
//
// MessageText:
//
// The transaction was successfully aborted. However, the abort was non-retaining.
//


//
// MessageId: XACT_S_ABORTING
//
// MessageText:
//
// An abort operation was already in progress.
//


//
// MessageId: XACT_S_SINGLEPHASE
//
// MessageText:
//
// The resource manager has performed a single-phase commit of the transaction.
//


//
// MessageId: XACT_S_LOCALLY_OK
//
// MessageText:
//
// The local transaction has not aborted.
//


//
// MessageId: XACT_S_LASTRESOURCEMANAGER
//
// MessageText:
//
// The resource manager has requested to be the coordinator (last resource manager) for the transaction.
//






//
// MessageId: CONTEXT_E_ABORTED
//
// MessageText:
//
// The root transaction wanted to commit, but transaction aborted
//


//
// MessageId: CONTEXT_E_ABORTING
//
// MessageText:
//
// You made a method call on a COM+ component that has a transaction that has already aborted or in the process of aborting.
//


//
// MessageId: CONTEXT_E_NOCONTEXT
//
// MessageText:
//
// There is no MTS object context
//


//
// MessageId: CONTEXT_E_WOULD_DEADLOCK
//
// MessageText:
//
// The component is configured to use synchronization and this method call would cause a deadlock to occur.
//


//
// MessageId: CONTEXT_E_SYNCH_TIMEOUT
//
// MessageText:
//
// The component is configured to use synchronization and a thread has timed out waiting to enter the context.
//


//
// MessageId: CONTEXT_E_OLDREF
//
// MessageText:
//
// You made a method call on a COM+ component that has a transaction that has already committed or aborted.
//


//
// MessageId: CONTEXT_E_ROLENOTFOUND
//
// MessageText:
//
// The specified role was not configured for the application
//


//
// MessageId: CONTEXT_E_TMNOTAVAILABLE
//
// MessageText:
//
// COM+ was unable to talk to the Microsoft Distributed Transaction Coordinator
//


//
// MessageId: CO_E_ACTIVATIONFAILED
//
// MessageText:
//
// An unexpected error occurred during COM+ Activation.
//


//
// MessageId: CO_E_ACTIVATIONFAILED_EVENTLOGGED
//
// MessageText:
//
// COM+ Activation failed. Check the event log for more information
//


//
// MessageId: CO_E_ACTIVATIONFAILED_CATALOGERROR
//
// MessageText:
//
// COM+ Activation failed due to a catalog or configuration error.
//


//
// MessageId: CO_E_ACTIVATIONFAILED_TIMEOUT
//
// MessageText:
//
// COM+ activation failed because the activation could not be completed in the specified amount of time.
//


//
// MessageId: CO_E_INITIALIZATIONFAILED
//
// MessageText:
//
// COM+ Activation failed because an initialization function failed. Check the event log for more information.
//


//
// MessageId: CONTEXT_E_NOJIT
//
// MessageText:
//
// The requested operation requires that JIT be in the current context and it is not
//


//
// MessageId: CONTEXT_E_NOTRANSACTION
//
// MessageText:
//
// The requested operation requires that the current context have a Transaction, and it does not
//


//
// MessageId: CO_E_THREADINGMODEL_CHANGED
//
// MessageText:
//
// The components threading model has changed after install into a COM+ Application. Please re-install component.
//


//
// MessageId: CO_E_NOIISINTRINSICS
//
// MessageText:
//
// IIS intrinsics not available. Start your work with IIS.
//


//
// MessageId: CO_E_NOCOOKIES
//
// MessageText:
//
// An attempt to write a cookie failed.
//


//
// MessageId: CO_E_DBERROR
//
// MessageText:
//
// An attempt to use a database generated a database specific error.
//


//
// MessageId: CO_E_NOTPOOLED
//
// MessageText:
//
// The COM+ component you created must use object pooling to work.
//


//
// MessageId: CO_E_NOTCONSTRUCTED
//
// MessageText:
//
// The COM+ component you created must use object construction to work correctly.
//


//
// MessageId: CO_E_NOSYNCHRONIZATION
//
// MessageText:
//
// The COM+ component requires synchronization, and it is not configured for it.
//


//
// MessageId: CO_E_ISOLEVELMISMATCH
//
// MessageText:
//
// The TxIsolation Level property for the COM+ component being created is stronger than the TxIsolationLevel for the "root" component for the transaction. The creation failed.
//


//
// MessageId: CO_E_CALL_OUT_OF_TX_SCOPE_NOT_ALLOWED
//
// MessageText:
//
// The component attempted to make a cross-context call between invocations of EnterTransactionScopeand ExitTransactionScope. This is not allowed. Cross-context calls cannot be made while inside of a transaction scope.
//


//
// MessageId: CO_E_EXIT_TRANSACTION_SCOPE_NOT_CALLED
//
// MessageText:
//
// The component made a call to EnterTransactionScope, but did not make a corresponding call to ExitTransactionScope before returning.
//


//
// Old OLE Success Codes
//
//
// MessageId: OLE_S_USEREG
//
// MessageText:
//
// Use the registry database to provide the requested information
//


//
// MessageId: OLE_S_STATIC
//
// MessageText:
//
// Success, but static
//


//
// MessageId: OLE_S_MAC_CLIPFORMAT
//
// MessageText:
//
// Macintosh clipboard format
//


//
// MessageId: DRAGDROP_S_DROP
//
// MessageText:
//
// Successful drop took place
//


//
// MessageId: DRAGDROP_S_CANCEL
//
// MessageText:
//
// Drag-drop operation canceled
//


//
// MessageId: DRAGDROP_S_USEDEFAULTCURSORS
//
// MessageText:
//
// Use the default cursor
//


//
// MessageId: DATA_S_SAMEFORMATETC
//
// MessageText:
//
// Data has same FORMATETC
//


//
// MessageId: VIEW_S_ALREADY_FROZEN
//
// MessageText:
//
// View is already frozen
//


//
// MessageId: CACHE_S_FORMATETC_NOTSUPPORTED
//
// MessageText:
//
// FORMATETC not supported
//


//
// MessageId: CACHE_S_SAMECACHE
//
// MessageText:
//
// Same cache
//


//
// MessageId: CACHE_S_SOMECACHES_NOTUPDATED
//
// MessageText:
//
// Some cache(s) not updated
//


//
// MessageId: OLEOBJ_S_INVALIDVERB
//
// MessageText:
//
// Invalid verb for OLE object
//


//
// MessageId: OLEOBJ_S_CANNOT_DOVERB_NOW
//
// MessageText:
//
// Verb number is valid but verb cannot be done now
//


//
// MessageId: OLEOBJ_S_INVALIDHWND
//
// MessageText:
//
// Invalid window handle passed
//


//
// MessageId: INPLACE_S_TRUNCATED
//
// MessageText:
//
// Message is too long; some of it had to be truncated before displaying
//


//
// MessageId: CONVERT10_S_NO_PRESENTATION
//
// MessageText:
//
// Unable to convert OLESTREAM to IStorage
//


//
// MessageId: MK_S_REDUCED_TO_SELF
//
// MessageText:
//
// Moniker reduced to itself
//


//
// MessageId: MK_S_ME
//
// MessageText:
//
// Common prefix is this moniker
//


//
// MessageId: MK_S_HIM
//
// MessageText:
//
// Common prefix is input moniker
//


//
// MessageId: MK_S_US
//
// MessageText:
//
// Common prefix is both monikers
//


//
// MessageId: MK_S_MONIKERALREADYREGISTERED
//
// MessageText:
//
// Moniker is already registered in running object table
//


//
// Task Scheduler errors
//
//
// MessageId: SCHED_S_TASK_READY
//
// MessageText:
//
// The task is ready to run at its next scheduled time.
//


//
// MessageId: SCHED_S_TASK_RUNNING
//
// MessageText:
//
// The task is currently running.
//


//
// MessageId: SCHED_S_TASK_DISABLED
//
// MessageText:
//
// The task will not run at the scheduled times because it has been disabled.
//


//
// MessageId: SCHED_S_TASK_HAS_NOT_RUN
//
// MessageText:
//
// The task has not yet run.
//


//
// MessageId: SCHED_S_TASK_NO_MORE_RUNS
//
// MessageText:
//
// There are no more runs scheduled for this task.
//


//
// MessageId: SCHED_S_TASK_NOT_SCHEDULED
//
// MessageText:
//
// One or more of the properties that are needed to run this task on a schedule have not been set.
//


//
// MessageId: SCHED_S_TASK_TERMINATED
//
// MessageText:
//
// The last run of the task was terminated by the user.
//


//
// MessageId: SCHED_S_TASK_NO_VALID_TRIGGERS
//
// MessageText:
//
// Either the task has no triggers or the existing triggers are disabled or not set.
//


//
// MessageId: SCHED_S_EVENT_TRIGGER
//
// MessageText:
//
// Event triggers don't have set run times.
//


//
// MessageId: SCHED_E_TRIGGER_NOT_FOUND
//
// MessageText:
//
// Trigger not found.
//


//
// MessageId: SCHED_E_TASK_NOT_READY
//
// MessageText:
//
// One or more of the properties that are needed to run this task have not been set.
//


//
// MessageId: SCHED_E_TASK_NOT_RUNNING
//
// MessageText:
//
// There is no running instance of the task.
//


//
// MessageId: SCHED_E_SERVICE_NOT_INSTALLED
//
// MessageText:
//
// The Task Scheduler Service is not installed on this computer.
//


//
// MessageId: SCHED_E_CANNOT_OPEN_TASK
//
// MessageText:
//
// The task object could not be opened.
//


//
// MessageId: SCHED_E_INVALID_TASK
//
// MessageText:
//
// The object is either an invalid task object or is not a task object.
//


//
// MessageId: SCHED_E_ACCOUNT_INFORMATION_NOT_SET
//
// MessageText:
//
// No account information could be found in the Task Scheduler security database for the task indicated.
//


//
// MessageId: SCHED_E_ACCOUNT_NAME_NOT_FOUND
//
// MessageText:
//
// Unable to establish existence of the account specified.
//


//
// MessageId: SCHED_E_ACCOUNT_DBASE_CORRUPT
//
// MessageText:
//
// Corruption was detected in the Task Scheduler security database; the database has been reset.
//


//
// MessageId: SCHED_E_NO_SECURITY_SERVICES
//
// MessageText:
//
// Task Scheduler security services are available only on Windows NT.
//


//
// MessageId: SCHED_E_UNKNOWN_OBJECT_VERSION
//
// MessageText:
//
// The task object version is either unsupported or invalid.
//


//
// MessageId: SCHED_E_UNSUPPORTED_ACCOUNT_OPTION
//
// MessageText:
//
// The task has been configured with an unsupported combination of account settings and run time options.
//


//
// MessageId: SCHED_E_SERVICE_NOT_RUNNING
//
// MessageText:
//
// The Task Scheduler Service is not running.
//


//
// MessageId: SCHED_E_UNEXPECTEDNODE
//
// MessageText:
//
// The task XML contains an unexpected node.
//


//
// MessageId: SCHED_E_NAMESPACE
//
// MessageText:
//
// The task XML contains an element or attribute from an unexpected namespace.
//


//
// MessageId: SCHED_E_INVALIDVALUE
//
// MessageText:
//
// The task XML contains a value which is incorrectly formatted or out of range.
//


//
// MessageId: SCHED_E_MISSINGNODE
//
// MessageText:
//
// The task XML is missing a required element or attribute.
//


//
// MessageId: SCHED_E_MALFORMEDXML
//
// MessageText:
//
// The task XML is malformed.
//


//
// MessageId: SCHED_S_SOME_TRIGGERS_FAILED
//
// MessageText:
//
// The task is registered, but not all specified triggers will start the task, check task scheduler event log for detailed information.
//


//
// MessageId: SCHED_S_BATCH_LOGON_PROBLEM
//
// MessageText:
//
// The task is registered, but may fail to start. Batch logon privilege needs to be enabled for the task principal.
//


//
// MessageId: SCHED_E_TOO_MANY_NODES
//
// MessageText:
//
// The task XML contains too many nodes of the same type.
//


//
// MessageId: SCHED_E_PAST_END_BOUNDARY
//
// MessageText:
//
// The task cannot be started after the trigger's end boundary.
//


//
// MessageId: SCHED_E_ALREADY_RUNNING
//
// MessageText:
//
// An instance of this task is already running.
//


//
// MessageId: SCHED_E_USER_NOT_LOGGED_ON
//
// MessageText:
//
// The task will not run because the user is not logged on.
//


//
// MessageId: SCHED_E_INVALID_TASK_HASH
//
// MessageText:
//
// The task image is corrupt or has been tampered with.
//


//
// MessageId: SCHED_E_SERVICE_NOT_AVAILABLE
//
// MessageText:
//
// The Task Scheduler service is not available.
//


//
// MessageId: SCHED_E_SERVICE_TOO_BUSY
//
// MessageText:
//
// The Task Scheduler service is too busy to handle your request. Please try again later.
//


//
// MessageId: SCHED_E_TASK_ATTEMPTED
//
// MessageText:
//
// The Task Scheduler service attempted to run the task, but the task did not run due to one of the constraints in the task definition.
//


//
// MessageId: SCHED_S_TASK_QUEUED
//
// MessageText:
//
// The Task Scheduler service has asked the task to run.
//


//
// MessageId: SCHED_E_TASK_DISABLED
//
// MessageText:
//
// The task is disabled.
//


//
// MessageId: SCHED_E_TASK_NOT_V1_COMPAT
//
// MessageText:
//
// The task has properties that are not compatible with previous versions of Windows.
//


//
// MessageId: SCHED_E_START_ON_DEMAND
//
// MessageText:
//
// The task settings do not allow the task to start on demand.
//


//
// MessageId: SCHED_E_TASK_NOT_UBPM_COMPAT
//
// MessageText:
//
// The combination of properties that task is using is not compatible with the scheduling engine.
//


//
// MessageId: SCHED_E_DEPRECATED_FEATURE_USED
//
// MessageText:
//
// The task definition uses a deprecated feature.
//


// ******************
// FACILITY_WINDOWS
// ******************
//
// Codes 0x0-0x01ff are reserved for the OLE group of
// interfaces.
//
//
// MessageId: CO_E_CLASS_CREATE_FAILED
//
// MessageText:
//
// Attempt to create a class object failed
//


//
// MessageId: CO_E_SCM_ERROR
//
// MessageText:
//
// OLE service could not bind object
//


//
// MessageId: CO_E_SCM_RPC_FAILURE
//
// MessageText:
//
// RPC communication failed with OLE service
//


//
// MessageId: CO_E_BAD_PATH
//
// MessageText:
//
// Bad path to object
//


//
// MessageId: CO_E_SERVER_EXEC_FAILURE
//
// MessageText:
//
// Server execution failed
//


//
// MessageId: CO_E_OBJSRV_RPC_FAILURE
//
// MessageText:
//
// OLE service could not communicate with the object server
//


//
// MessageId: MK_E_NO_NORMALIZED
//
// MessageText:
//
// Moniker path could not be normalized
//


//
// MessageId: CO_E_SERVER_STOPPING
//
// MessageText:
//
// Object server is stopping when OLE service contacts it
//


//
// MessageId: MEM_E_INVALID_ROOT
//
// MessageText:
//
// An invalid root block pointer was specified
//


//
// MessageId: MEM_E_INVALID_LINK
//
// MessageText:
//
// An allocation chain contained an invalid link pointer
//


//
// MessageId: MEM_E_INVALID_SIZE
//
// MessageText:
//
// The requested allocation size was too large
//


//
// MessageId: CO_S_NOTALLINTERFACES
//
// MessageText:
//
// Not all the requested interfaces were available
//


//
// MessageId: CO_S_MACHINENAMENOTFOUND
//
// MessageText:
//
// The specified machine name was not found in the cache.
//


//
// MessageId: CO_E_MISSING_DISPLAYNAME
//
// MessageText:
//
// The activation requires a display name to be present under the CLSID key.
//


//
// MessageId: CO_E_RUNAS_VALUE_MUST_BE_AAA
//
// MessageText:
//
// The activation requires that the RunAs value for the application is Activate As Activator.
//


//
// MessageId: CO_E_ELEVATION_DISABLED
//
// MessageText:
//
// The class is not configured to support Elevated activation.
//


//
// Codes 0x0200-0x02ff are reserved for the APPX errors
//
//
// MessageId: APPX_E_PACKAGING_INTERNAL
//
// MessageText:
//
// Appx packaging API has encountered an internal error.
//


//
// MessageId: APPX_E_INTERLEAVING_NOT_ALLOWED
//
// MessageText:
//
// The file is not a valid Appx package because its contents are interleaved.
//


//
// MessageId: APPX_E_RELATIONSHIPS_NOT_ALLOWED
//
// MessageText:
//
// The file is not a valid Appx package because it contains OPC relationships.
//


//
// MessageId: APPX_E_MISSING_REQUIRED_FILE
//
// MessageText:
//
// The file is not a valid Appx package because it is missing a manifest or block map, or missing a signature file when the code integrity file is present.
//


//
// MessageId: APPX_E_INVALID_MANIFEST
//
// MessageText:
//
// The Appx package's manifest is invalid.
//


//
// MessageId: APPX_E_INVALID_BLOCKMAP
//
// MessageText:
//
// The Appx package's block map is invalid.
//


//
// MessageId: APPX_E_CORRUPT_CONTENT
//
// MessageText:
//
// The Appx package's content cannot be read because it is corrupt.
//


//
// MessageId: APPX_E_BLOCK_HASH_INVALID
//
// MessageText:
//
// The computed hash value of the block does not match the one stored in the block map.
//


//
// MessageId: APPX_E_REQUESTED_RANGE_TOO_LARGE
//
// MessageText:
//
// The requested byte range is over 4GB when translated to byte range of blocks.
//


//
// MessageId: APPX_E_INVALID_SIP_CLIENT_DATA
//
// MessageText:
//
// The SIP_SUBJECTINFO structure used to sign the package didn't contain the required data.
//


//
// MessageId: APPX_E_INVALID_KEY_INFO
//
// MessageText:
//
// The APPX_KEY_INFO structure used to encrypt or decrypt the package contains invalid data.
//


//
// MessageId: APPX_E_INVALID_CONTENTGROUPMAP
//
// MessageText:
//
// The Appx package's content group map is invalid.
//


//
// MessageId: APPX_E_INVALID_APPINSTALLER
//
// MessageText:
//
// The .appinstaller file is invalid.
//


//
// MessageId: APPX_E_DELTA_BASELINE_VERSION_MISMATCH
//
// MessageText:
//
// The baseline package version in delta package does not match the version in the baseline package to be updated.
//


//
// MessageId: APPX_E_DELTA_PACKAGE_MISSING_FILE
//
// MessageText:
//
// The delta package is missing a file from the updated package.
//


//
// MessageId: APPX_E_INVALID_DELTA_PACKAGE
//
// MessageText:
//
// The delta package is invalid.
//


//
// MessageId: APPX_E_DELTA_APPENDED_PACKAGE_NOT_ALLOWED
//
// MessageText:
//
// The delta appended package is not allowed for the current operation.
//


//
// MessageId: APPX_E_INVALID_PACKAGING_LAYOUT
//
// MessageText:
//
// The packaging layout file is invalid.
//


//
// MessageId: APPX_E_INVALID_PACKAGESIGNCONFIG
//
// MessageText:
//
// The packageSignConfig file is invalid.
//


//
// MessageId: APPX_E_RESOURCESPRI_NOT_ALLOWED
//
// MessageText:
//
// The resources.pri file is not allowed when there are no resource elements in the package manifest.
//


//
// MessageId: APPX_E_FILE_COMPRESSION_MISMATCH
//
// MessageText:
//
// The compression state of file in baseline and updated package does not match.
//


//
// MessageId: APPX_E_INVALID_PAYLOAD_PACKAGE_EXTENSION
//
// MessageText:
//
// Non appx extensions are not allowed for payload packages targeting older platforms.
//


//
// MessageId: APPX_E_INVALID_ENCRYPTION_EXCLUSION_FILE_LIST
//
// MessageText:
//
// The encryptionExclusionFileList file is invalid.
//


//
// Codes 0x0300-0x030f are reserved for background task error codes.
//
//
// MessageId: BT_E_SPURIOUS_ACTIVATION
//
// MessageText:
//
// The background task activation is spurious.
//


// ******************
// FACILITY_DISPATCH
// ******************
//
// MessageId: DISP_E_UNKNOWNINTERFACE
//
// MessageText:
//
// Unknown interface.
//


//
// MessageId: DISP_E_MEMBERNOTFOUND
//
// MessageText:
//
// Member not found.
//


//
// MessageId: DISP_E_PARAMNOTFOUND
//
// MessageText:
//
// Parameter not found.
//


//
// MessageId: DISP_E_TYPEMISMATCH
//
// MessageText:
//
// Type mismatch.
//


//
// MessageId: DISP_E_UNKNOWNNAME
//
// MessageText:
//
// Unknown name.
//


//
// MessageId: DISP_E_NONAMEDARGS
//
// MessageText:
//
// No named arguments.
//


//
// MessageId: DISP_E_BADVARTYPE
//
// MessageText:
//
// Bad variable type.
//


//
// MessageId: DISP_E_EXCEPTION
//
// MessageText:
//
// Exception occurred.
//


//
// MessageId: DISP_E_OVERFLOW
//
// MessageText:
//
// Out of present range.
//


//
// MessageId: DISP_E_BADINDEX
//
// MessageText:
//
// Invalid index.
//


//
// MessageId: DISP_E_UNKNOWNLCID
//
// MessageText:
//
// Unknown language.
//


//
// MessageId: DISP_E_ARRAYISLOCKED
//
// MessageText:
//
// Memory is locked.
//


//
// MessageId: DISP_E_BADPARAMCOUNT
//
// MessageText:
//
// Invalid number of parameters.
//


//
// MessageId: DISP_E_PARAMNOTOPTIONAL
//
// MessageText:
//
// Parameter not optional.
//


//
// MessageId: DISP_E_BADCALLEE
//
// MessageText:
//
// Invalid callee.
//


//
// MessageId: DISP_E_NOTACOLLECTION
//
// MessageText:
//
// Does not support a collection.
//


//
// MessageId: DISP_E_DIVBYZERO
//
// MessageText:
//
// Division by zero.
//


//
// MessageId: DISP_E_BUFFERTOOSMALL
//
// MessageText:
//
// Buffer too small
//


//
// MessageId: TYPE_E_BUFFERTOOSMALL
//
// MessageText:
//
// Buffer too small.
//


//
// MessageId: TYPE_E_FIELDNOTFOUND
//
// MessageText:
//
// Field name not defined in the record.
//


//
// MessageId: TYPE_E_INVDATAREAD
//
// MessageText:
//
// Old format or invalid type library.
//


//
// MessageId: TYPE_E_UNSUPFORMAT
//
// MessageText:
//
// Old format or invalid type library.
//


//
// MessageId: TYPE_E_REGISTRYACCESS
//
// MessageText:
//
// Error accessing the OLE registry.
//


//
// MessageId: TYPE_E_LIBNOTREGISTERED
//
// MessageText:
//
// Library not registered.
//


//
// MessageId: TYPE_E_UNDEFINEDTYPE
//
// MessageText:
//
// Bound to unknown type.
//


//
// MessageId: TYPE_E_QUALIFIEDNAMEDISALLOWED
//
// MessageText:
//
// Qualified name disallowed.
//


//
// MessageId: TYPE_E_INVALIDSTATE
//
// MessageText:
//
// Invalid forward reference, or reference to uncompiled type.
//


//
// MessageId: TYPE_E_WRONGTYPEKIND
//
// MessageText:
//
// Type mismatch.
//


//
// MessageId: TYPE_E_ELEMENTNOTFOUND
//
// MessageText:
//
// Element not found.
//


//
// MessageId: TYPE_E_AMBIGUOUSNAME
//
// MessageText:
//
// Ambiguous name.
//


//
// MessageId: TYPE_E_NAMECONFLICT
//
// MessageText:
//
// Name already exists in the library.
//


//
// MessageId: TYPE_E_UNKNOWNLCID
//
// MessageText:
//
// Unknown LCID.
//


//
// MessageId: TYPE_E_DLLFUNCTIONNOTFOUND
//
// MessageText:
//
// Function not defined in specified DLL.
//


//
// MessageId: TYPE_E_BADMODULEKIND
//
// MessageText:
//
// Wrong module kind for the operation.
//


//
// MessageId: TYPE_E_SIZETOOBIG
//
// MessageText:
//
// Size may not exceed 64K.
//


//
// MessageId: TYPE_E_DUPLICATEID
//
// MessageText:
//
// Duplicate ID in inheritance hierarchy.
//


//
// MessageId: TYPE_E_INVALIDID
//
// MessageText:
//
// Incorrect inheritance depth in standard OLE hmember.
//


//
// MessageId: TYPE_E_TYPEMISMATCH
//
// MessageText:
//
// Type mismatch.
//


//
// MessageId: TYPE_E_OUTOFBOUNDS
//
// MessageText:
//
// Invalid number of arguments.
//


//
// MessageId: TYPE_E_IOERROR
//
// MessageText:
//
// I/O Error.
//


//
// MessageId: TYPE_E_CANTCREATETMPFILE
//
// MessageText:
//
// Error creating unique tmp file.
//


//
// MessageId: TYPE_E_CANTLOADLIBRARY
//
// MessageText:
//
// Error loading type library/DLL.
//


//
// MessageId: TYPE_E_INCONSISTENTPROPFUNCS
//
// MessageText:
//
// Inconsistent property functions.
//


//
// MessageId: TYPE_E_CIRCULARTYPE
//
// MessageText:
//
// Circular dependency between types/modules.
//


// ******************
// FACILITY_STORAGE
// ******************
//
// MessageId: STG_E_INVALIDFUNCTION
//
// MessageText:
//
// Unable to perform requested operation.
//


//
// MessageId: STG_E_FILENOTFOUND
//
// MessageText:
//
// %1 could not be found.
//


//
// MessageId: STG_E_PATHNOTFOUND
//
// MessageText:
//
// The path %1 could not be found.
//


//
// MessageId: STG_E_TOOMANYOPENFILES
//
// MessageText:
//
// There are insufficient resources to open another file.
//


//
// MessageId: STG_E_ACCESSDENIED
//
// MessageText:
//
// Access Denied.
//


//
// MessageId: STG_E_INVALIDHANDLE
//
// MessageText:
//
// Attempted an operation on an invalid object.
//


//
// MessageId: STG_E_INSUFFICIENTMEMORY
//
// MessageText:
//
// There is insufficient memory available to complete operation.
//


//
// MessageId: STG_E_INVALIDPOINTER
//
// MessageText:
//
// Invalid pointer error.
//


//
// MessageId: STG_E_NOMOREFILES
//
// MessageText:
//
// There are no more entries to return.
//


//
// MessageId: STG_E_DISKISWRITEPROTECTED
//
// MessageText:
//
// Disk is write-protected.
//


//
// MessageId: STG_E_SEEKERROR
//
// MessageText:
//
// An error occurred during a seek operation.
//


//
// MessageId: STG_E_WRITEFAULT
//
// MessageText:
//
// A disk error occurred during a write operation.
//


//
// MessageId: STG_E_READFAULT
//
// MessageText:
//
// A disk error occurred during a read operation.
//


//
// MessageId: STG_E_SHAREVIOLATION
//
// MessageText:
//
// A share violation has occurred.
//


//
// MessageId: STG_E_LOCKVIOLATION
//
// MessageText:
//
// A lock violation has occurred.
//


//
// MessageId: STG_E_FILEALREADYEXISTS
//
// MessageText:
//
// %1 already exists.
//


//
// MessageId: STG_E_INVALIDPARAMETER
//
// MessageText:
//
// Invalid parameter error.
//


//
// MessageId: STG_E_MEDIUMFULL
//
// MessageText:
//
// There is insufficient disk space to complete operation.
//


//
// MessageId: STG_E_PROPSETMISMATCHED
//
// MessageText:
//
// Illegal write of non-simple property to simple property set.
//


//
// MessageId: STG_E_ABNORMALAPIEXIT
//
// MessageText:
//
// An API call exited abnormally.
//


//
// MessageId: STG_E_INVALIDHEADER
//
// MessageText:
//
// The file %1 is not a valid compound file.
//


//
// MessageId: STG_E_INVALIDNAME
//
// MessageText:
//
// The name %1 is not valid.
//


//
// MessageId: STG_E_UNKNOWN
//
// MessageText:
//
// An unexpected error occurred.
//


//
// MessageId: STG_E_UNIMPLEMENTEDFUNCTION
//
// MessageText:
//
// That function is not implemented.
//


//
// MessageId: STG_E_INVALIDFLAG
//
// MessageText:
//
// Invalid flag error.
//


//
// MessageId: STG_E_INUSE
//
// MessageText:
//
// Attempted to use an object that is busy.
//


//
// MessageId: STG_E_NOTCURRENT
//
// MessageText:
//
// The storage has been changed since the last commit.
//


//
// MessageId: STG_E_REVERTED
//
// MessageText:
//
// Attempted to use an object that has ceased to exist.
//


//
// MessageId: STG_E_CANTSAVE
//
// MessageText:
//
// Can't save.
//


//
// MessageId: STG_E_OLDFORMAT
//
// MessageText:
//
// The compound file %1 was produced with an incompatible version of storage.
//


//
// MessageId: STG_E_OLDDLL
//
// MessageText:
//
// The compound file %1 was produced with a newer version of storage.
//


//
// MessageId: STG_E_SHAREREQUIRED
//
// MessageText:
//
// Share.exe or equivalent is required for operation.
//


//
// MessageId: STG_E_NOTFILEBASEDSTORAGE
//
// MessageText:
//
// Illegal operation called on non-file based storage.
//


//
// MessageId: STG_E_EXTANTMARSHALLINGS
//
// MessageText:
//
// Illegal operation called on object with extant marshallings.
//


//
// MessageId: STG_E_DOCFILECORRUPT
//
// MessageText:
//
// The docfile has been corrupted.
//


//
// MessageId: STG_E_BADBASEADDRESS
//
// MessageText:
//
// OLE32.DLL has been loaded at the wrong address.
//


//
// MessageId: STG_E_DOCFILETOOLARGE
//
// MessageText:
//
// The compound file is too large for the current implementation
//


//
// MessageId: STG_E_NOTSIMPLEFORMAT
//
// MessageText:
//
// The compound file was not created with the STGM_SIMPLE flag
//


//
// MessageId: STG_E_INCOMPLETE
//
// MessageText:
//
// The file download was aborted abnormally. The file is incomplete.
//


//
// MessageId: STG_E_TERMINATED
//
// MessageText:
//
// The file download has been terminated.
//


//
// MessageId: STG_S_CONVERTED
//
// MessageText:
//
// The underlying file was converted to compound file format.
//


//
// MessageId: STG_S_BLOCK
//
// MessageText:
//
// The storage operation should block until more data is available.
//


//
// MessageId: STG_S_RETRYNOW
//
// MessageText:
//
// The storage operation should retry immediately.
//


//
// MessageId: STG_S_MONITORING
//
// MessageText:
//
// The notified event sink will not influence the storage operation.
//


//
// MessageId: STG_S_MULTIPLEOPENS
//
// MessageText:
//
// Multiple opens prevent consolidated. (commit succeeded).
//


//
// MessageId: STG_S_CONSOLIDATIONFAILED
//
// MessageText:
//
// Consolidation of the storage file failed. (commit succeeded).
//


//
// MessageId: STG_S_CANNOTCONSOLIDATE
//
// MessageText:
//
// Consolidation of the storage file is inappropriate. (commit succeeded).
//


//
// MessageId: STG_S_POWER_CYCLE_REQUIRED
//
// MessageText:
//
// The device needs to be power cycled. (commit succeeded).
//


//
// MessageId: STG_E_FIRMWARE_SLOT_INVALID
//
// MessageText:
//
// The specified firmware slot is invalid.
//


//
// MessageId: STG_E_FIRMWARE_IMAGE_INVALID
//
// MessageText:
//
// The specified firmware image is invalid.
//


//
// MessageId: STG_E_DEVICE_UNRESPONSIVE
//
// MessageText:
//
// The storage device is unresponsive.
//


/*++

 MessageId's 0x0305 - 0x031f (inclusive) are reserved for **STORAGE**
 copy protection errors.

--*/
//
// MessageId: STG_E_STATUS_COPY_PROTECTION_FAILURE
//
// MessageText:
//
// Generic Copy Protection Error.
//


//
// MessageId: STG_E_CSS_AUTHENTICATION_FAILURE
//
// MessageText:
//
// Copy Protection Error - DVD CSS Authentication failed.
//


//
// MessageId: STG_E_CSS_KEY_NOT_PRESENT
//
// MessageText:
//
// Copy Protection Error - The given sector does not have a valid CSS key.
//


//
// MessageId: STG_E_CSS_KEY_NOT_ESTABLISHED
//
// MessageText:
//
// Copy Protection Error - DVD session key not established.
//


//
// MessageId: STG_E_CSS_SCRAMBLED_SECTOR
//
// MessageText:
//
// Copy Protection Error - The read failed because the sector is encrypted.
//


//
// MessageId: STG_E_CSS_REGION_MISMATCH
//
// MessageText:
//
// Copy Protection Error - The current DVD's region does not correspond to the region setting of the drive.
//


//
// MessageId: STG_E_RESETS_EXHAUSTED
//
// MessageText:
//
// Copy Protection Error - The drive's region setting may be permanent or the number of user resets has been exhausted.
//


/*++

 MessageId's 0x0305 - 0x031f (inclusive) are reserved for **STORAGE**
 copy protection errors.

--*/
// ******************
// FACILITY_RPC
// ******************
//
// Codes 0x0-0x11 are propagated from 16 bit OLE.
//
//
// MessageId: RPC_E_CALL_REJECTED
//
// MessageText:
//
// Call was rejected by callee.
//


//
// MessageId: RPC_E_CALL_CANCELED
//
// MessageText:
//
// Call was canceled by the message filter.
//


//
// MessageId: RPC_E_CANTPOST_INSENDCALL
//
// MessageText:
//
// The caller is dispatching an intertask SendMessage call and cannot call out via PostMessage.
//


//
// MessageId: RPC_E_CANTCALLOUT_INASYNCCALL
//
// MessageText:
//
// The caller is dispatching an asynchronous call and cannot make an outgoing call on behalf of this call.
//


//
// MessageId: RPC_E_CANTCALLOUT_INEXTERNALCALL
//
// MessageText:
//
// It is illegal to call out while inside message filter.
//


//
// MessageId: RPC_E_CONNECTION_TERMINATED
//
// MessageText:
//
// The connection terminated or is in a bogus state and cannot be used any more. Other connections are still valid.
//


//
// MessageId: RPC_E_SERVER_DIED
//
// MessageText:
//
// The callee (server [not server application]) is not available and disappeared; all connections are invalid. The call may have executed.
//


//
// MessageId: RPC_E_CLIENT_DIED
//
// MessageText:
//
// The caller (client) disappeared while the callee (server) was processing a call.
//


//
// MessageId: RPC_E_INVALID_DATAPACKET
//
// MessageText:
//
// The data packet with the marshalled parameter data is incorrect.
//


//
// MessageId: RPC_E_CANTTRANSMIT_CALL
//
// MessageText:
//
// The call was not transmitted properly; the message queue was full and was not emptied after yielding.
//


//
// MessageId: RPC_E_CLIENT_CANTMARSHAL_DATA
//
// MessageText:
//
// The client (caller) cannot marshall the parameter data - low memory, etc.
//


//
// MessageId: RPC_E_CLIENT_CANTUNMARSHAL_DATA
//
// MessageText:
//
// The client (caller) cannot unmarshall the return data - low memory, etc.
//


//
// MessageId: RPC_E_SERVER_CANTMARSHAL_DATA
//
// MessageText:
//
// The server (callee) cannot marshall the return data - low memory, etc.
//


//
// MessageId: RPC_E_SERVER_CANTUNMARSHAL_DATA
//
// MessageText:
//
// The server (callee) cannot unmarshall the parameter data - low memory, etc.
//


//
// MessageId: RPC_E_INVALID_DATA
//
// MessageText:
//
// Received data is invalid; could be server or client data.
//


//
// MessageId: RPC_E_INVALID_PARAMETER
//
// MessageText:
//
// A particular parameter is invalid and cannot be (un)marshalled.
//


//
// MessageId: RPC_E_CANTCALLOUT_AGAIN
//
// MessageText:
//
// There is no second outgoing call on same channel in DDE conversation.
//


//
// MessageId: RPC_E_SERVER_DIED_DNE
//
// MessageText:
//
// The callee (server [not server application]) is not available and disappeared; all connections are invalid. The call did not execute.
//


//
// MessageId: RPC_E_SYS_CALL_FAILED
//
// MessageText:
//
// System call failed.
//


//
// MessageId: RPC_E_OUT_OF_RESOURCES
//
// MessageText:
//
// Could not allocate some required resource (memory, events, ...)
//


//
// MessageId: RPC_E_ATTEMPTED_MULTITHREAD
//
// MessageText:
//
// Attempted to make calls on more than one thread in single threaded mode.
//


//
// MessageId: RPC_E_NOT_REGISTERED
//
// MessageText:
//
// The requested interface is not registered on the server object.
//


//
// MessageId: RPC_E_FAULT
//
// MessageText:
//
// RPC could not call the server or could not return the results of calling the server.
//


//
// MessageId: RPC_E_SERVERFAULT
//
// MessageText:
//
// The server threw an exception.
//


//
// MessageId: RPC_E_CHANGED_MODE
//
// MessageText:
//
// Cannot change thread mode after it is set.
//


//
// MessageId: RPC_E_INVALIDMETHOD
//
// MessageText:
//
// The method called does not exist on the server.
//


//
// MessageId: RPC_E_DISCONNECTED
//
// MessageText:
//
// The object invoked has disconnected from its clients.
//


//
// MessageId: RPC_E_RETRY
//
// MessageText:
//
// The object invoked chose not to process the call now. Try again later.
//


//
// MessageId: RPC_E_SERVERCALL_RETRYLATER
//
// MessageText:
//
// The message filter indicated that the application is busy.
//


//
// MessageId: RPC_E_SERVERCALL_REJECTED
//
// MessageText:
//
// The message filter rejected the call.
//


//
// MessageId: RPC_E_INVALID_CALLDATA
//
// MessageText:
//
// A call control interfaces was called with invalid data.
//


//
// MessageId: RPC_E_CANTCALLOUT_ININPUTSYNCCALL
//
// MessageText:
//
// An outgoing call cannot be made since the application is dispatching an input-synchronous call.
//


//
// MessageId: RPC_E_WRONG_THREAD
//
// MessageText:
//
// The application called an interface that was marshalled for a different thread.
//


//
// MessageId: RPC_E_THREAD_NOT_INIT
//
// MessageText:
//
// CoInitialize has not been called on the current thread.
//


//
// MessageId: RPC_E_VERSION_MISMATCH
//
// MessageText:
//
// The version of OLE on the client and server machines does not match.
//


//
// MessageId: RPC_E_INVALID_HEADER
//
// MessageText:
//
// OLE received a packet with an invalid header.
//


//
// MessageId: RPC_E_INVALID_EXTENSION
//
// MessageText:
//
// OLE received a packet with an invalid extension.
//


//
// MessageId: RPC_E_INVALID_IPID
//
// MessageText:
//
// The requested object or interface does not exist.
//


//
// MessageId: RPC_E_INVALID_OBJECT
//
// MessageText:
//
// The requested object does not exist.
//


//
// MessageId: RPC_S_CALLPENDING
//
// MessageText:
//
// OLE has sent a request and is waiting for a reply.
//


//
// MessageId: RPC_S_WAITONTIMER
//
// MessageText:
//
// OLE is waiting before retrying a request.
//


//
// MessageId: RPC_E_CALL_COMPLETE
//
// MessageText:
//
// Call context cannot be accessed after call completed.
//


//
// MessageId: RPC_E_UNSECURE_CALL
//
// MessageText:
//
// Impersonate on unsecure calls is not supported.
//


//
// MessageId: RPC_E_TOO_LATE
//
// MessageText:
//
// Security must be initialized before any interfaces are marshalled or unmarshalled. It cannot be changed once initialized.
//


//
// MessageId: RPC_E_NO_GOOD_SECURITY_PACKAGES
//
// MessageText:
//
// No security packages are installed on this machine or the user is not logged on or there are no compatible security packages between the client and server.
//


//
// MessageId: RPC_E_ACCESS_DENIED
//
// MessageText:
//
// Access is denied.
//


//
// MessageId: RPC_E_REMOTE_DISABLED
//
// MessageText:
//
// Remote calls are not allowed for this process.
//


//
// MessageId: RPC_E_INVALID_OBJREF
//
// MessageText:
//
// The marshaled interface data packet (OBJREF) has an invalid or unknown format.
//


//
// MessageId: RPC_E_NO_CONTEXT
//
// MessageText:
//
// No context is associated with this call. This happens for some custom marshalled calls and on the client side of the call.
//


//
// MessageId: RPC_E_TIMEOUT
//
// MessageText:
//
// This operation returned because the timeout period expired.
//


//
// MessageId: RPC_E_NO_SYNC
//
// MessageText:
//
// There are no synchronize objects to wait on.
//


//
// MessageId: RPC_E_FULLSIC_REQUIRED
//
// MessageText:
//
// Full subject issuer chain SSL principal name expected from the server.
//


//
// MessageId: RPC_E_INVALID_STD_NAME
//
// MessageText:
//
// Principal name is not a valid MSSTD name.
//


//
// MessageId: CO_E_FAILEDTOIMPERSONATE
//
// MessageText:
//
// Unable to impersonate DCOM client
//


//
// MessageId: CO_E_FAILEDTOGETSECCTX
//
// MessageText:
//
// Unable to obtain server's security context
//


//
// MessageId: CO_E_FAILEDTOOPENTHREADTOKEN
//
// MessageText:
//
// Unable to open the access token of the current thread
//


//
// MessageId: CO_E_FAILEDTOGETTOKENINFO
//
// MessageText:
//
// Unable to obtain user info from an access token
//


//
// MessageId: CO_E_TRUSTEEDOESNTMATCHCLIENT
//
// MessageText:
//
// The client who called IAccessControl::IsAccessPermitted was not the trustee provided to the method
//


//
// MessageId: CO_E_FAILEDTOQUERYCLIENTBLANKET
//
// MessageText:
//
// Unable to obtain the client's security blanket
//


//
// MessageId: CO_E_FAILEDTOSETDACL
//
// MessageText:
//
// Unable to set a discretionary ACL into a security descriptor
//


//
// MessageId: CO_E_ACCESSCHECKFAILED
//
// MessageText:
//
// The system function, AccessCheck, returned false
//


//
// MessageId: CO_E_NETACCESSAPIFAILED
//
// MessageText:
//
// Either NetAccessDel or NetAccessAdd returned an error code.
//


//
// MessageId: CO_E_WRONGTRUSTEENAMESYNTAX
//
// MessageText:
//
// One of the trustee strings provided by the user did not conform to the <Domain>\<Name> syntax and it was not the "*" string
//


//
// MessageId: CO_E_INVALIDSID
//
// MessageText:
//
// One of the security identifiers provided by the user was invalid
//


//
// MessageId: CO_E_CONVERSIONFAILED
//
// MessageText:
//
// Unable to convert a wide character trustee string to a multibyte trustee string
//


//
// MessageId: CO_E_NOMATCHINGSIDFOUND
//
// MessageText:
//
// Unable to find a security identifier that corresponds to a trustee string provided by the user
//


//
// MessageId: CO_E_LOOKUPACCSIDFAILED
//
// MessageText:
//
// The system function, LookupAccountSID, failed
//


//
// MessageId: CO_E_NOMATCHINGNAMEFOUND
//
// MessageText:
//
// Unable to find a trustee name that corresponds to a security identifier provided by the user
//


//
// MessageId: CO_E_LOOKUPACCNAMEFAILED
//
// MessageText:
//
// The system function, LookupAccountName, failed
//


//
// MessageId: CO_E_SETSERLHNDLFAILED
//
// MessageText:
//
// Unable to set or reset a serialization handle
//


//
// MessageId: CO_E_FAILEDTOGETWINDIR
//
// MessageText:
//
// Unable to obtain the Windows directory
//


//
// MessageId: CO_E_PATHTOOLONG
//
// MessageText:
//
// Path too long
//


//
// MessageId: CO_E_FAILEDTOGENUUID
//
// MessageText:
//
// Unable to generate a uuid.
//


//
// MessageId: CO_E_FAILEDTOCREATEFILE
//
// MessageText:
//
// Unable to create file
//


//
// MessageId: CO_E_FAILEDTOCLOSEHANDLE
//
// MessageText:
//
// Unable to close a serialization handle or a file handle.
//


//
// MessageId: CO_E_EXCEEDSYSACLLIMIT
//
// MessageText:
//
// The number of ACEs in an ACL exceeds the system limit.
//


//
// MessageId: CO_E_ACESINWRONGORDER
//
// MessageText:
//
// Not all the DENY_ACCESS ACEs are arranged in front of the GRANT_ACCESS ACEs in the stream.
//


//
// MessageId: CO_E_INCOMPATIBLESTREAMVERSION
//
// MessageText:
//
// The version of ACL format in the stream is not supported by this implementation of IAccessControl
//


//
// MessageId: CO_E_FAILEDTOOPENPROCESSTOKEN
//
// MessageText:
//
// Unable to open the access token of the server process
//


//
// MessageId: CO_E_DECODEFAILED
//
// MessageText:
//
// Unable to decode the ACL in the stream provided by the user
//


//
// MessageId: CO_E_ACNOTINITIALIZED
//
// MessageText:
//
// The COM IAccessControl object is not initialized
//


//
// MessageId: CO_E_CANCEL_DISABLED
//
// MessageText:
//
// Call Cancellation is disabled
//


//
// MessageId: RPC_E_UNEXPECTED
//
// MessageText:
//
// An internal error occurred.
//




//////////////////////////////////////
//                                  //
// Additional Security Status Codes //
//                                  //
// Facility=Security                //
//                                  //
//////////////////////////////////////


//
// MessageId: ERROR_AUDITING_DISABLED
//
// MessageText:
//
// The specified event is currently not being audited.
//


//
// MessageId: ERROR_ALL_SIDS_FILTERED
//
// MessageText:
//
// The SID filtering operation removed all SIDs.
//


//
// MessageId: ERROR_BIZRULES_NOT_ENABLED
//
// MessageText:
//
// Business rule scripts are disabled for the calling application.
//




/////////////////////////////////////////////
//                                         //
// end of Additional Security Status Codes //
//                                         //
/////////////////////////////////////////////



 /////////////////
 //
 //  FACILITY_SSPI
 //
 /////////////////

//
// MessageId: NTE_BAD_UID
//
// MessageText:
//
// Bad UID.
//


//
// MessageId: NTE_BAD_HASH
//
// MessageText:
//
// Bad Hash.
//


//
// MessageId: NTE_BAD_KEY
//
// MessageText:
//
// Bad Key.
//


//
// MessageId: NTE_BAD_LEN
//
// MessageText:
//
// Bad Length.
//


//
// MessageId: NTE_BAD_DATA
//
// MessageText:
//
// Bad Data.
//


//
// MessageId: NTE_BAD_SIGNATURE
//
// MessageText:
//
// Invalid Signature.
//


//
// MessageId: NTE_BAD_VER
//
// MessageText:
//
// Bad Version of provider.
//


//
// MessageId: NTE_BAD_ALGID
//
// MessageText:
//
// Invalid algorithm specified.
//


//
// MessageId: NTE_BAD_FLAGS
//
// MessageText:
//
// Invalid flags specified.
//


//
// MessageId: NTE_BAD_TYPE
//
// MessageText:
//
// Invalid type specified.
//


//
// MessageId: NTE_BAD_KEY_STATE
//
// MessageText:
//
// Key not valid for use in specified state.
//


//
// MessageId: NTE_BAD_HASH_STATE
//
// MessageText:
//
// Hash not valid for use in specified state.
//


//
// MessageId: NTE_NO_KEY
//
// MessageText:
//
// Key does not exist.
//


//
// MessageId: NTE_NO_MEMORY
//
// MessageText:
//
// Insufficient memory available for the operation.
//


//
// MessageId: NTE_EXISTS
//
// MessageText:
//
// Object already exists.
//


//
// MessageId: NTE_PERM
//
// MessageText:
//
// Access denied.
//


//
// MessageId: NTE_NOT_FOUND
//
// MessageText:
//
// Object was not found.
//


//
// MessageId: NTE_DOUBLE_ENCRYPT
//
// MessageText:
//
// Data already encrypted.
//


//
// MessageId: NTE_BAD_PROVIDER
//
// MessageText:
//
// Invalid provider specified.
//


//
// MessageId: NTE_BAD_PROV_TYPE
//
// MessageText:
//
// Invalid provider type specified.
//


//
// MessageId: NTE_BAD_PUBLIC_KEY
//
// MessageText:
//
// Provider's public key is invalid.
//


//
// MessageId: NTE_BAD_KEYSET
//
// MessageText:
//
// Keyset does not exist
//


//
// MessageId: NTE_PROV_TYPE_NOT_DEF
//
// MessageText:
//
// Provider type not defined.
//


//
// MessageId: NTE_PROV_TYPE_ENTRY_BAD
//
// MessageText:
//
// Provider type as registered is invalid.
//


//
// MessageId: NTE_KEYSET_NOT_DEF
//
// MessageText:
//
// The keyset is not defined.
//


//
// MessageId: NTE_KEYSET_ENTRY_BAD
//
// MessageText:
//
// Keyset as registered is invalid.
//


//
// MessageId: NTE_PROV_TYPE_NO_MATCH
//
// MessageText:
//
// Provider type does not match registered value.
//


//
// MessageId: NTE_SIGNATURE_FILE_BAD
//
// MessageText:
//
// The digital signature file is corrupt.
//


//
// MessageId: NTE_PROVIDER_DLL_FAIL
//
// MessageText:
//
// Provider DLL failed to initialize correctly.
//


//
// MessageId: NTE_PROV_DLL_NOT_FOUND
//
// MessageText:
//
// Provider DLL could not be found.
//


//
// MessageId: NTE_BAD_KEYSET_PARAM
//
// MessageText:
//
// The Keyset parameter is invalid.
//


//
// MessageId: NTE_FAIL
//
// MessageText:
//
// An internal error occurred.
//


//
// MessageId: NTE_SYS_ERR
//
// MessageText:
//
// A base error occurred.
//


//
// MessageId: NTE_SILENT_CONTEXT
//
// MessageText:
//
// Provider could not perform the action since the context was acquired as silent.
//


//
// MessageId: NTE_TOKEN_KEYSET_STORAGE_FULL
//
// MessageText:
//
// The security token does not have storage space available for an additional container.
//


//
// MessageId: NTE_TEMPORARY_PROFILE
//
// MessageText:
//
// The profile for the user is a temporary profile.
//


//
// MessageId: NTE_FIXEDPARAMETER
//
// MessageText:
//
// The key parameters could not be set because the CSP uses fixed parameters.
//


//
// MessageId: NTE_INVALID_HANDLE
//
// MessageText:
//
// The supplied handle is invalid.
//


//
// MessageId: NTE_INVALID_PARAMETER
//
// MessageText:
//
// The parameter is incorrect.
//


//
// MessageId: NTE_BUFFER_TOO_SMALL
//
// MessageText:
//
// The buffer supplied to a function was too small.
//


//
// MessageId: NTE_NOT_SUPPORTED
//
// MessageText:
//
// The requested operation is not supported.
//


//
// MessageId: NTE_NO_MORE_ITEMS
//
// MessageText:
//
// No more data is available.
//


//
// MessageId: NTE_BUFFERS_OVERLAP
//
// MessageText:
//
// The supplied buffers overlap incorrectly.
//


//
// MessageId: NTE_DECRYPTION_FAILURE
//
// MessageText:
//
// The specified data could not be decrypted.
//


//
// MessageId: NTE_INTERNAL_ERROR
//
// MessageText:
//
// An internal consistency check failed.
//


//
// MessageId: NTE_UI_REQUIRED
//
// MessageText:
//
// This operation requires input from the user.
//


//
// MessageId: NTE_HMAC_NOT_SUPPORTED
//
// MessageText:
//
// The cryptographic provider does not support HMAC.
//


//
// MessageId: NTE_DEVICE_NOT_READY
//
// MessageText:
//
// The device that is required by this cryptographic provider is not ready for use.
//


//
// MessageId: NTE_AUTHENTICATION_IGNORED
//
// MessageText:
//
// The dictionary attack mitigation is triggered and the provided authorization was ignored by the provider.
//


//
// MessageId: NTE_VALIDATION_FAILED
//
// MessageText:
//
// The validation of the provided data failed the integrity or signature validation.
//


//
// MessageId: NTE_INCORRECT_PASSWORD
//
// MessageText:
//
// Incorrect password.
//


//
// MessageId: NTE_ENCRYPTION_FAILURE
//
// MessageText:
//
// Encryption failed.
//


//
// MessageId: NTE_DEVICE_NOT_FOUND
//
// MessageText:
//
// The device that is required by this cryptographic provider is not found on this platform.
//


//
// MessageId: NTE_USER_CANCELLED
//
// MessageText:
//
// The action was cancelled by the user.
//


//
// MessageId: NTE_PASSWORD_CHANGE_REQUIRED
//
// MessageText:
//
// The password is no longer valid and must be changed.
//


//
// MessageId: NTE_NOT_ACTIVE_CONSOLE
//
// MessageText:
//
// The operation cannot be completed from Terminal Server client sessions.
//


//
// MessageId: SEC_E_INSUFFICIENT_MEMORY
//
// MessageText:
//
// Not enough memory is available to complete this request
//


//
// MessageId: SEC_E_INVALID_HANDLE
//
// MessageText:
//
// The handle specified is invalid
//


//
// MessageId: SEC_E_UNSUPPORTED_FUNCTION
//
// MessageText:
//
// The function requested is not supported
//


//
// MessageId: SEC_E_TARGET_UNKNOWN
//
// MessageText:
//
// The specified target is unknown or unreachable
//


//
// MessageId: SEC_E_INTERNAL_ERROR
//
// MessageText:
//
// The Local Security Authority cannot be contacted
//


//
// MessageId: SEC_E_SECPKG_NOT_FOUND
//
// MessageText:
//
// The requested security package does not exist
//


//
// MessageId: SEC_E_NOT_OWNER
//
// MessageText:
//
// The caller is not the owner of the desired credentials
//


//
// MessageId: SEC_E_CANNOT_INSTALL
//
// MessageText:
//
// The security package failed to initialize, and cannot be installed
//


//
// MessageId: SEC_E_INVALID_TOKEN
//
// MessageText:
//
// The token supplied to the function is invalid
//


//
// MessageId: SEC_E_CANNOT_PACK
//
// MessageText:
//
// The security package is not able to marshall the logon buffer, so the logon attempt has failed
//


//
// MessageId: SEC_E_QOP_NOT_SUPPORTED
//
// MessageText:
//
// The per-message Quality of Protection is not supported by the security package
//


//
// MessageId: SEC_E_NO_IMPERSONATION
//
// MessageText:
//
// The security context does not allow impersonation of the client
//


//
// MessageId: SEC_E_LOGON_DENIED
//
// MessageText:
//
// The logon attempt failed
//


//
// MessageId: SEC_E_UNKNOWN_CREDENTIALS
//
// MessageText:
//
// The credentials supplied to the package were not recognized
//


//
// MessageId: SEC_E_NO_CREDENTIALS
//
// MessageText:
//
// No credentials are available in the security package
//


//
// MessageId: SEC_E_MESSAGE_ALTERED
//
// MessageText:
//
// The message or signature supplied for verification has been altered
//


//
// MessageId: SEC_E_OUT_OF_SEQUENCE
//
// MessageText:
//
// The message supplied for verification is out of sequence
//


//
// MessageId: SEC_E_NO_AUTHENTICATING_AUTHORITY
//
// MessageText:
//
// No authority could be contacted for authentication.
//


//
// MessageId: SEC_I_CONTINUE_NEEDED
//
// MessageText:
//
// The function completed successfully, but must be called again to complete the context
//


//
// MessageId: SEC_I_COMPLETE_NEEDED
//
// MessageText:
//
// The function completed successfully, but CompleteToken must be called
//


//
// MessageId: SEC_I_COMPLETE_AND_CONTINUE
//
// MessageText:
//
// The function completed successfully, but both CompleteToken and this function must be called to complete the context
//


//
// MessageId: SEC_I_LOCAL_LOGON
//
// MessageText:
//
// The logon was completed, but no network authority was available. The logon was made using locally known information
//


//
// MessageId: SEC_I_GENERIC_EXTENSION_RECEIVED
//
// MessageText:
//
// Schannel has received a TLS extension the SSPI caller subscribed to.
//


//
// MessageId: SEC_E_BAD_PKGID
//
// MessageText:
//
// The requested security package does not exist
//


//
// MessageId: SEC_E_CONTEXT_EXPIRED
//
// MessageText:
//
// The context has expired and can no longer be used.
//


//
// MessageId: SEC_I_CONTEXT_EXPIRED
//
// MessageText:
//
// The context has expired and can no longer be used.
//


//
// MessageId: SEC_E_INCOMPLETE_MESSAGE
//
// MessageText:
//
// The supplied message is incomplete. The signature was not verified.
//


//
// MessageId: SEC_E_INCOMPLETE_CREDENTIALS
//
// MessageText:
//
// The credentials supplied were not complete, and could not be verified. The context could not be initialized.
//


//
// MessageId: SEC_E_BUFFER_TOO_SMALL
//
// MessageText:
//
// The buffers supplied to a function was too small.
//


//
// MessageId: SEC_I_INCOMPLETE_CREDENTIALS
//
// MessageText:
//
// The credentials supplied were not complete, and could not be verified. Additional information can be returned from the context.
//


//
// MessageId: SEC_I_RENEGOTIATE
//
// MessageText:
//
// The context data must be renegotiated with the peer.
//


//
// MessageId: SEC_E_WRONG_PRINCIPAL
//
// MessageText:
//
// The target principal name is incorrect.
//


//
// MessageId: SEC_I_NO_LSA_CONTEXT
//
// MessageText:
//
// There is no LSA mode context associated with this context.
//


//
// MessageId: SEC_E_TIME_SKEW
//
// MessageText:
//
// The clocks on the client and server machines are skewed.
//


//
// MessageId: SEC_E_UNTRUSTED_ROOT
//
// MessageText:
//
// The certificate chain was issued by an authority that is not trusted.
//


//
// MessageId: SEC_E_ILLEGAL_MESSAGE
//
// MessageText:
//
// The message received was unexpected or badly formatted.
//


//
// MessageId: SEC_E_CERT_UNKNOWN
//
// MessageText:
//
// An unknown error occurred while processing the certificate.
//


//
// MessageId: SEC_E_CERT_EXPIRED
//
// MessageText:
//
// The received certificate has expired.
//


//
// MessageId: SEC_E_ENCRYPT_FAILURE
//
// MessageText:
//
// The specified data could not be encrypted.
//


//
// MessageId: SEC_E_DECRYPT_FAILURE
//
// MessageText:
//
// The specified data could not be decrypted.
// 
//


//
// MessageId: SEC_E_ALGORITHM_MISMATCH
//
// MessageText:
//
// The client and server cannot communicate, because they do not possess a common algorithm.
//


//
// MessageId: SEC_E_SECURITY_QOS_FAILED
//
// MessageText:
//
// The security context could not be established due to a failure in the requested quality of service (e.g. mutual authentication or delegation).
//


//
// MessageId: SEC_E_UNFINISHED_CONTEXT_DELETED
//
// MessageText:
//
// A security context was deleted before the context was completed. This is considered a logon failure.
//


//
// MessageId: SEC_E_NO_TGT_REPLY
//
// MessageText:
//
// The client is trying to negotiate a context and the server requires user-to-user but didn't send a TGT reply.
//


//
// MessageId: SEC_E_NO_IP_ADDRESSES
//
// MessageText:
//
// Unable to accomplish the requested task because the local machine does not have any IP addresses.
//


//
// MessageId: SEC_E_WRONG_CREDENTIAL_HANDLE
//
// MessageText:
//
// The supplied credential handle does not match the credential associated with the security context.
//


//
// MessageId: SEC_E_CRYPTO_SYSTEM_INVALID
//
// MessageText:
//
// The crypto system or checksum function is invalid because a required function is unavailable.
//


//
// MessageId: SEC_E_MAX_REFERRALS_EXCEEDED
//
// MessageText:
//
// The number of maximum ticket referrals has been exceeded.
//


//
// MessageId: SEC_E_MUST_BE_KDC
//
// MessageText:
//
// The local machine must be a Kerberos KDC (domain controller) and it is not.
//


//
// MessageId: SEC_E_STRONG_CRYPTO_NOT_SUPPORTED
//
// MessageText:
//
// The other end of the security negotiation is requires strong crypto but it is not supported on the local machine.
//


//
// MessageId: SEC_E_TOO_MANY_PRINCIPALS
//
// MessageText:
//
// The KDC reply contained more than one principal name.
//


//
// MessageId: SEC_E_NO_PA_DATA
//
// MessageText:
//
// Expected to find PA data for a hint of what etype to use, but it was not found.
//


//
// MessageId: SEC_E_PKINIT_NAME_MISMATCH
//
// MessageText:
//
// The client certificate does not contain a valid UPN, or does not match the client name in the logon request. Please contact your administrator.
//


//
// MessageId: SEC_E_SMARTCARD_LOGON_REQUIRED
//
// MessageText:
//
// Smartcard logon is required and was not used.
//


//
// MessageId: SEC_E_SHUTDOWN_IN_PROGRESS
//
// MessageText:
//
// A system shutdown is in progress.
//


//
// MessageId: SEC_E_KDC_INVALID_REQUEST
//
// MessageText:
//
// An invalid request was sent to the KDC.
//


//
// MessageId: SEC_E_KDC_UNABLE_TO_REFER
//
// MessageText:
//
// The KDC was unable to generate a referral for the service requested.
//


//
// MessageId: SEC_E_KDC_UNKNOWN_ETYPE
//
// MessageText:
//
// The encryption type requested is not supported by the KDC.
//


//
// MessageId: SEC_E_UNSUPPORTED_PREAUTH
//
// MessageText:
//
// An unsupported preauthentication mechanism was presented to the Kerberos package.
//


//
// MessageId: SEC_E_DELEGATION_REQUIRED
//
// MessageText:
//
// The requested operation cannot be completed. The computer must be trusted for delegation and the current user account must be configured to allow delegation.
//


//
// MessageId: SEC_E_BAD_BINDINGS
//
// MessageText:
//
// Client's supplied SSPI channel bindings were incorrect.
//


//
// MessageId: SEC_E_MULTIPLE_ACCOUNTS
//
// MessageText:
//
// The received certificate was mapped to multiple accounts.
//


//
// MessageId: SEC_E_NO_KERB_KEY
//
// MessageText:
//
//  SEC_E_NO_KERB_KEY
//


//
// MessageId: SEC_E_CERT_WRONG_USAGE
//
// MessageText:
//
// The certificate is not valid for the requested usage.
//


//
// MessageId: SEC_E_DOWNGRADE_DETECTED
//
// MessageText:
//
// The system cannot contact a domain controller to service the authentication request. Please try again later.
//


//
// MessageId: SEC_E_SMARTCARD_CERT_REVOKED
//
// MessageText:
//
// The smartcard certificate used for authentication has been revoked. Please contact your system administrator. There may be additional information in the event log.
//


//
// MessageId: SEC_E_ISSUING_CA_UNTRUSTED
//
// MessageText:
//
// An untrusted certificate authority was detected while processing the smartcard certificate used for authentication. Please contact your system administrator.
//


//
// MessageId: SEC_E_REVOCATION_OFFLINE_C
//
// MessageText:
//
// The revocation status of the smartcard certificate used for authentication could not be determined. Please contact your system administrator.
//


//
// MessageId: SEC_E_PKINIT_CLIENT_FAILURE
//
// MessageText:
//
// The smartcard certificate used for authentication was not trusted. Please contact your system administrator.
//


//
// MessageId: SEC_E_SMARTCARD_CERT_EXPIRED
//
// MessageText:
//
// The smartcard certificate used for authentication has expired. Please contact your system administrator.
//


//
// MessageId: SEC_E_NO_S4U_PROT_SUPPORT
//
// MessageText:
//
// The Kerberos subsystem encountered an error. A service for user protocol request was made against a domain controller which does not support service for user.
//


//
// MessageId: SEC_E_CROSSREALM_DELEGATION_FAILURE
//
// MessageText:
//
// An attempt was made by this server to make a Kerberos constrained delegation request for a target outside of the server's realm. This is not supported, and indicates a misconfiguration on this server's allowed to delegate to list. Please contact your administrator.
//


//
// MessageId: SEC_E_REVOCATION_OFFLINE_KDC
//
// MessageText:
//
// The revocation status of the domain controller certificate used for smartcard authentication could not be determined. There is additional information in the system event log. Please contact your system administrator.
//


//
// MessageId: SEC_E_ISSUING_CA_UNTRUSTED_KDC
//
// MessageText:
//
// An untrusted certificate authority was detected while processing the domain controller certificate used for authentication. There is additional information in the system event log. Please contact your system administrator.
//


//
// MessageId: SEC_E_KDC_CERT_EXPIRED
//
// MessageText:
//
// The domain controller certificate used for smartcard logon has expired. Please contact your system administrator with the contents of your system event log.
//


//
// MessageId: SEC_E_KDC_CERT_REVOKED
//
// MessageText:
//
// The domain controller certificate used for smartcard logon has been revoked. Please contact your system administrator with the contents of your system event log.
//


//
// MessageId: SEC_I_SIGNATURE_NEEDED
//
// MessageText:
//
// A signature operation must be performed before the user can authenticate.
//


//
// MessageId: SEC_E_INVALID_PARAMETER
//
// MessageText:
//
// One or more of the parameters passed to the function was invalid.
//


//
// MessageId: SEC_E_DELEGATION_POLICY
//
// MessageText:
//
// Client policy does not allow credential delegation to target server.
//


//
// MessageId: SEC_E_POLICY_NLTM_ONLY
//
// MessageText:
//
// Client policy does not allow credential delegation to target server with NLTM only authentication.
//


//
// MessageId: SEC_I_NO_RENEGOTIATION
//
// MessageText:
//
// The recipient rejected the renegotiation request.
//


//
// MessageId: SEC_E_NO_CONTEXT
//
// MessageText:
//
// The required security context does not exist.
//


//
// MessageId: SEC_E_PKU2U_CERT_FAILURE
//
// MessageText:
//
// The PKU2U protocol encountered an error while attempting to utilize the associated certificates.
//


//
// MessageId: SEC_E_MUTUAL_AUTH_FAILED
//
// MessageText:
//
// The identity of the server computer could not be verified.
//


//
// MessageId: SEC_I_MESSAGE_FRAGMENT
//
// MessageText:
//
// The returned buffer is only a fragment of the message.  More fragments need to be returned.
//


//
// MessageId: SEC_E_ONLY_HTTPS_ALLOWED
//
// MessageText:
//
// Only https scheme is allowed.
//


//
// MessageId: SEC_I_CONTINUE_NEEDED_MESSAGE_OK
//
// MessageText:
//
// The function completed successfully, but must be called again to complete the context.  Early start can be used.
//


//
// MessageId: SEC_E_APPLICATION_PROTOCOL_MISMATCH
//
// MessageText:
//
// No common application protocol exists between the client and the server. Application protocol negotiation failed.
//


//
// MessageId: SEC_I_ASYNC_CALL_PENDING
//
// MessageText:
//
// An asynchronous SSPI routine has been called and the work is pending completion.
//


//
// MessageId: SEC_E_INVALID_UPN_NAME
//
// MessageText:
//
// You can't sign in with a user ID in this format. Try using your email address instead.
//


//
// MessageId: SEC_E_EXT_BUFFER_TOO_SMALL
//
// MessageText:
//
// The buffer supplied by the SSPI caller to receive generic extensions is too small.
//


//
// MessageId: SEC_E_INSUFFICIENT_BUFFERS
//
// MessageText:
//
// Not enough secbuffers were supplied to generate a token.
//


//
// Provided for backwards compatibility
//




//
// MessageId: CRYPT_E_MSG_ERROR
//
// MessageText:
//
// An error occurred while performing an operation on a cryptographic message.
//


//
// MessageId: CRYPT_E_UNKNOWN_ALGO
//
// MessageText:
//
// Unknown cryptographic algorithm.
//


//
// MessageId: CRYPT_E_OID_FORMAT
//
// MessageText:
//
// The object identifier is poorly formatted.
//


//
// MessageId: CRYPT_E_INVALID_MSG_TYPE
//
// MessageText:
//
// Invalid cryptographic message type.
//


//
// MessageId: CRYPT_E_UNEXPECTED_ENCODING
//
// MessageText:
//
// Unexpected cryptographic message encoding.
//


//
// MessageId: CRYPT_E_AUTH_ATTR_MISSING
//
// MessageText:
//
// The cryptographic message does not contain an expected authenticated attribute.
//


//
// MessageId: CRYPT_E_HASH_VALUE
//
// MessageText:
//
// The hash value is not correct.
//


//
// MessageId: CRYPT_E_INVALID_INDEX
//
// MessageText:
//
// The index value is not valid.
//


//
// MessageId: CRYPT_E_ALREADY_DECRYPTED
//
// MessageText:
//
// The content of the cryptographic message has already been decrypted.
//


//
// MessageId: CRYPT_E_NOT_DECRYPTED
//
// MessageText:
//
// The content of the cryptographic message has not been decrypted yet.
//


//
// MessageId: CRYPT_E_RECIPIENT_NOT_FOUND
//
// MessageText:
//
// The enveloped-data message does not contain the specified recipient.
//


//
// MessageId: CRYPT_E_CONTROL_TYPE
//
// MessageText:
//
// Invalid control type.
//


//
// MessageId: CRYPT_E_ISSUER_SERIALNUMBER
//
// MessageText:
//
// Invalid issuer and/or serial number.
//


//
// MessageId: CRYPT_E_SIGNER_NOT_FOUND
//
// MessageText:
//
// Cannot find the original signer.
//


//
// MessageId: CRYPT_E_ATTRIBUTES_MISSING
//
// MessageText:
//
// The cryptographic message does not contain all of the requested attributes.
//


//
// MessageId: CRYPT_E_STREAM_MSG_NOT_READY
//
// MessageText:
//
// The streamed cryptographic message is not ready to return data.
//


//
// MessageId: CRYPT_E_STREAM_INSUFFICIENT_DATA
//
// MessageText:
//
// The streamed cryptographic message requires more data to complete the decode operation.
//


//
// MessageId: CRYPT_I_NEW_PROTECTION_REQUIRED
//
// MessageText:
//
// The protected data needs to be re-protected.
//


//
// MessageId: CRYPT_E_BAD_LEN
//
// MessageText:
//
// The length specified for the output data was insufficient.
//


//
// MessageId: CRYPT_E_BAD_ENCODE
//
// MessageText:
//
// An error occurred during encode or decode operation.
//


//
// MessageId: CRYPT_E_FILE_ERROR
//
// MessageText:
//
// An error occurred while reading or writing to a file.
//


//
// MessageId: CRYPT_E_NOT_FOUND
//
// MessageText:
//
// Cannot find object or property.
//


//
// MessageId: CRYPT_E_EXISTS
//
// MessageText:
//
// The object or property already exists.
//


//
// MessageId: CRYPT_E_NO_PROVIDER
//
// MessageText:
//
// No provider was specified for the store or object.
//


//
// MessageId: CRYPT_E_SELF_SIGNED
//
// MessageText:
//
// The specified certificate is self signed.
//


//
// MessageId: CRYPT_E_DELETED_PREV
//
// MessageText:
//
// The previous certificate or CRL context was deleted.
//


//
// MessageId: CRYPT_E_NO_MATCH
//
// MessageText:
//
// Cannot find the requested object.
//


//
// MessageId: CRYPT_E_UNEXPECTED_MSG_TYPE
//
// MessageText:
//
// The certificate does not have a property that references a private key.
//


//
// MessageId: CRYPT_E_NO_KEY_PROPERTY
//
// MessageText:
//
// Cannot find the certificate and private key for decryption.
//


//
// MessageId: CRYPT_E_NO_DECRYPT_CERT
//
// MessageText:
//
// Cannot find the certificate and private key to use for decryption.
//


//
// MessageId: CRYPT_E_BAD_MSG
//
// MessageText:
//
// Not a cryptographic message or the cryptographic message is not formatted correctly.
//


//
// MessageId: CRYPT_E_NO_SIGNER
//
// MessageText:
//
// The signed cryptographic message does not have a signer for the specified signer index.
//


//
// MessageId: CRYPT_E_PENDING_CLOSE
//
// MessageText:
//
// Final closure is pending until additional frees or closes.
//


//
// MessageId: CRYPT_E_REVOKED
//
// MessageText:
//
// The certificate is revoked.
//


//
// MessageId: CRYPT_E_NO_REVOCATION_DLL
//
// MessageText:
//
// No Dll or exported function was found to verify revocation.
//


//
// MessageId: CRYPT_E_NO_REVOCATION_CHECK
//
// MessageText:
//
// The revocation function was unable to check revocation for the certificate.
//


//
// MessageId: CRYPT_E_REVOCATION_OFFLINE
//
// MessageText:
//
// The revocation function was unable to check revocation because the revocation server was offline.
//


//
// MessageId: CRYPT_E_NOT_IN_REVOCATION_DATABASE
//
// MessageText:
//
// The certificate is not in the revocation server's database.
//


//
// MessageId: CRYPT_E_INVALID_NUMERIC_STRING
//
// MessageText:
//
// The string contains a non-numeric character.
//


//
// MessageId: CRYPT_E_INVALID_PRINTABLE_STRING
//
// MessageText:
//
// The string contains a non-printable character.
//


//
// MessageId: CRYPT_E_INVALID_IA5_STRING
//
// MessageText:
//
// The string contains a character not in the 7 bit ASCII character set.
//


//
// MessageId: CRYPT_E_INVALID_X500_STRING
//
// MessageText:
//
// The string contains an invalid X500 name attribute key, oid, value or delimiter.
//


//
// MessageId: CRYPT_E_NOT_CHAR_STRING
//
// MessageText:
//
// The dwValueType for the CERT_NAME_VALUE is not one of the character strings. Most likely it is either a CERT_RDN_ENCODED_BLOB or CERT_RDN_OCTET_STRING.
//


//
// MessageId: CRYPT_E_FILERESIZED
//
// MessageText:
//
// The Put operation cannot continue. The file needs to be resized. However, there is already a signature present. A complete signing operation must be done.
//


//
// MessageId: CRYPT_E_SECURITY_SETTINGS
//
// MessageText:
//
// The cryptographic operation failed due to a local security option setting.
//


//
// MessageId: CRYPT_E_NO_VERIFY_USAGE_DLL
//
// MessageText:
//
// No DLL or exported function was found to verify subject usage.
//


//
// MessageId: CRYPT_E_NO_VERIFY_USAGE_CHECK
//
// MessageText:
//
// The called function was unable to do a usage check on the subject.
//


//
// MessageId: CRYPT_E_VERIFY_USAGE_OFFLINE
//
// MessageText:
//
// Since the server was offline, the called function was unable to complete the usage check.
//


//
// MessageId: CRYPT_E_NOT_IN_CTL
//
// MessageText:
//
// The subject was not found in a Certificate Trust List (CTL).
//


//
// MessageId: CRYPT_E_NO_TRUSTED_SIGNER
//
// MessageText:
//
// None of the signers of the cryptographic message or certificate trust list is trusted.
//


//
// MessageId: CRYPT_E_MISSING_PUBKEY_PARA
//
// MessageText:
//
// The public key's algorithm parameters are missing.
//


//
// MessageId: CRYPT_E_OBJECT_LOCATOR_OBJECT_NOT_FOUND
//
// MessageText:
//
// An object could not be located using the object locator infrastructure with the given name.
//


//
// MessageId: CRYPT_E_OSS_ERROR
//
// MessageText:
//
// OSS Certificate encode/decode error code base
// 
// See asn1code.h for a definition of the OSS runtime errors. The OSS error values are offset by CRYPT_E_OSS_ERROR.
//


//
// MessageId: OSS_MORE_BUF
//
// MessageText:
//
// OSS ASN.1 Error: Output Buffer is too small.
//


//
// MessageId: OSS_NEGATIVE_UINTEGER
//
// MessageText:
//
// OSS ASN.1 Error: Signed integer is encoded as a unsigned integer.
//


//
// MessageId: OSS_PDU_RANGE
//
// MessageText:
//
// OSS ASN.1 Error: Unknown ASN.1 data type.
//


//
// MessageId: OSS_MORE_INPUT
//
// MessageText:
//
// OSS ASN.1 Error: Output buffer is too small, the decoded data has been truncated.
//


//
// MessageId: OSS_DATA_ERROR
//
// MessageText:
//
// OSS ASN.1 Error: Invalid data.
//


//
// MessageId: OSS_BAD_ARG
//
// MessageText:
//
// OSS ASN.1 Error: Invalid argument.
//


//
// MessageId: OSS_BAD_VERSION
//
// MessageText:
//
// OSS ASN.1 Error: Encode/Decode version mismatch.
//


//
// MessageId: OSS_OUT_MEMORY
//
// MessageText:
//
// OSS ASN.1 Error: Out of memory.
//


//
// MessageId: OSS_PDU_MISMATCH
//
// MessageText:
//
// OSS ASN.1 Error: Encode/Decode Error.
//


//
// MessageId: OSS_LIMITED
//
// MessageText:
//
// OSS ASN.1 Error: Internal Error.
//


//
// MessageId: OSS_BAD_PTR
//
// MessageText:
//
// OSS ASN.1 Error: Invalid data.
//


//
// MessageId: OSS_BAD_TIME
//
// MessageText:
//
// OSS ASN.1 Error: Invalid data.
//


//
// MessageId: OSS_INDEFINITE_NOT_SUPPORTED
//
// MessageText:
//
// OSS ASN.1 Error: Unsupported BER indefinite-length encoding.
//


//
// MessageId: OSS_MEM_ERROR
//
// MessageText:
//
// OSS ASN.1 Error: Access violation.
//


//
// MessageId: OSS_BAD_TABLE
//
// MessageText:
//
// OSS ASN.1 Error: Invalid data.
//


//
// MessageId: OSS_TOO_LONG
//
// MessageText:
//
// OSS ASN.1 Error: Invalid data.
//


//
// MessageId: OSS_CONSTRAINT_VIOLATED
//
// MessageText:
//
// OSS ASN.1 Error: Invalid data.
//


//
// MessageId: OSS_FATAL_ERROR
//
// MessageText:
//
// OSS ASN.1 Error: Internal Error.
//


//
// MessageId: OSS_ACCESS_SERIALIZATION_ERROR
//
// MessageText:
//
// OSS ASN.1 Error: Multi-threading conflict.
//


//
// MessageId: OSS_NULL_TBL
//
// MessageText:
//
// OSS ASN.1 Error: Invalid data.
//


//
// MessageId: OSS_NULL_FCN
//
// MessageText:
//
// OSS ASN.1 Error: Invalid data.
//


//
// MessageId: OSS_BAD_ENCRULES
//
// MessageText:
//
// OSS ASN.1 Error: Invalid data.
//


//
// MessageId: OSS_UNAVAIL_ENCRULES
//
// MessageText:
//
// OSS ASN.1 Error: Encode/Decode function not implemented.
//


//
// MessageId: OSS_CANT_OPEN_TRACE_WINDOW
//
// MessageText:
//
// OSS ASN.1 Error: Trace file error.
//


//
// MessageId: OSS_UNIMPLEMENTED
//
// MessageText:
//
// OSS ASN.1 Error: Function not implemented.
//


//
// MessageId: OSS_OID_DLL_NOT_LINKED
//
// MessageText:
//
// OSS ASN.1 Error: Program link error.
//


//
// MessageId: OSS_CANT_OPEN_TRACE_FILE
//
// MessageText:
//
// OSS ASN.1 Error: Trace file error.
//


//
// MessageId: OSS_TRACE_FILE_ALREADY_OPEN
//
// MessageText:
//
// OSS ASN.1 Error: Trace file error.
//


//
// MessageId: OSS_TABLE_MISMATCH
//
// MessageText:
//
// OSS ASN.1 Error: Invalid data.
//


//
// MessageId: OSS_TYPE_NOT_SUPPORTED
//
// MessageText:
//
// OSS ASN.1 Error: Invalid data.
//


//
// MessageId: OSS_REAL_DLL_NOT_LINKED
//
// MessageText:
//
// OSS ASN.1 Error: Program link error.
//


//
// MessageId: OSS_REAL_CODE_NOT_LINKED
//
// MessageText:
//
// OSS ASN.1 Error: Program link error.
//


//
// MessageId: OSS_OUT_OF_RANGE
//
// MessageText:
//
// OSS ASN.1 Error: Program link error.
//


//
// MessageId: OSS_COPIER_DLL_NOT_LINKED
//
// MessageText:
//
// OSS ASN.1 Error: Program link error.
//


//
// MessageId: OSS_CONSTRAINT_DLL_NOT_LINKED
//
// MessageText:
//
// OSS ASN.1 Error: Program link error.
//


//
// MessageId: OSS_COMPARATOR_DLL_NOT_LINKED
//
// MessageText:
//
// OSS ASN.1 Error: Program link error.
//


//
// MessageId: OSS_COMPARATOR_CODE_NOT_LINKED
//
// MessageText:
//
// OSS ASN.1 Error: Program link error.
//


//
// MessageId: OSS_MEM_MGR_DLL_NOT_LINKED
//
// MessageText:
//
// OSS ASN.1 Error: Program link error.
//


//
// MessageId: OSS_PDV_DLL_NOT_LINKED
//
// MessageText:
//
// OSS ASN.1 Error: Program link error.
//


//
// MessageId: OSS_PDV_CODE_NOT_LINKED
//
// MessageText:
//
// OSS ASN.1 Error: Program link error.
//


//
// MessageId: OSS_API_DLL_NOT_LINKED
//
// MessageText:
//
// OSS ASN.1 Error: Program link error.
//


//
// MessageId: OSS_BERDER_DLL_NOT_LINKED
//
// MessageText:
//
// OSS ASN.1 Error: Program link error.
//


//
// MessageId: OSS_PER_DLL_NOT_LINKED
//
// MessageText:
//
// OSS ASN.1 Error: Program link error.
//


//
// MessageId: OSS_OPEN_TYPE_ERROR
//
// MessageText:
//
// OSS ASN.1 Error: Program link error.
//


//
// MessageId: OSS_MUTEX_NOT_CREATED
//
// MessageText:
//
// OSS ASN.1 Error: System resource error.
//


//
// MessageId: OSS_CANT_CLOSE_TRACE_FILE
//
// MessageText:
//
// OSS ASN.1 Error: Trace file error.
//


//
// MessageId: CRYPT_E_ASN1_ERROR
//
// MessageText:
//
// ASN1 Certificate encode/decode error code base. The ASN1 error values are offset by CRYPT_E_ASN1_ERROR.
//


//
// MessageId: CRYPT_E_ASN1_INTERNAL
//
// MessageText:
//
// ASN1 internal encode or decode error.
//


//
// MessageId: CRYPT_E_ASN1_EOD
//
// MessageText:
//
// ASN1 unexpected end of data.
//


//
// MessageId: CRYPT_E_ASN1_CORRUPT
//
// MessageText:
//
// ASN1 corrupted data.
//


//
// MessageId: CRYPT_E_ASN1_LARGE
//
// MessageText:
//
// ASN1 value too large.
//


//
// MessageId: CRYPT_E_ASN1_CONSTRAINT
//
// MessageText:
//
// ASN1 constraint violated.
//


//
// MessageId: CRYPT_E_ASN1_MEMORY
//
// MessageText:
//
// ASN1 out of memory.
//


//
// MessageId: CRYPT_E_ASN1_OVERFLOW
//
// MessageText:
//
// ASN1 buffer overflow.
//


//
// MessageId: CRYPT_E_ASN1_BADPDU
//
// MessageText:
//
// ASN1 function not supported for this PDU.
//


//
// MessageId: CRYPT_E_ASN1_BADARGS
//
// MessageText:
//
// ASN1 bad arguments to function call.
//


//
// MessageId: CRYPT_E_ASN1_BADREAL
//
// MessageText:
//
// ASN1 bad real value.
//


//
// MessageId: CRYPT_E_ASN1_BADTAG
//
// MessageText:
//
// ASN1 bad tag value met.
//


//
// MessageId: CRYPT_E_ASN1_CHOICE
//
// MessageText:
//
// ASN1 bad choice value.
//


//
// MessageId: CRYPT_E_ASN1_RULE
//
// MessageText:
//
// ASN1 bad encoding rule.
//


//
// MessageId: CRYPT_E_ASN1_UTF8
//
// MessageText:
//
// ASN1 bad unicode (UTF8).
//


//
// MessageId: CRYPT_E_ASN1_PDU_TYPE
//
// MessageText:
//
// ASN1 bad PDU type.
//


//
// MessageId: CRYPT_E_ASN1_NYI
//
// MessageText:
//
// ASN1 not yet implemented.
//


//
// MessageId: CRYPT_E_ASN1_EXTENDED
//
// MessageText:
//
// ASN1 skipped unknown extension(s).
//


//
// MessageId: CRYPT_E_ASN1_NOEOD
//
// MessageText:
//
// ASN1 end of data expected
//


//
// MessageId: CERTSRV_E_BAD_REQUESTSUBJECT
//
// MessageText:
//
// The request subject name is invalid or too long.
//


//
// MessageId: CERTSRV_E_NO_REQUEST
//
// MessageText:
//
// The request does not exist.
//


//
// MessageId: CERTSRV_E_BAD_REQUESTSTATUS
//
// MessageText:
//
// The request's current status does not allow this operation.
//


//
// MessageId: CERTSRV_E_PROPERTY_EMPTY
//
// MessageText:
//
// The requested property value is empty.
//


//
// MessageId: CERTSRV_E_INVALID_CA_CERTIFICATE
//
// MessageText:
//
// The certification authority's certificate contains invalid data.
//


//
// MessageId: CERTSRV_E_SERVER_SUSPENDED
//
// MessageText:
//
// Certificate service has been suspended for a database restore operation.
//


//
// MessageId: CERTSRV_E_ENCODING_LENGTH
//
// MessageText:
//
// The certificate contains an encoded length that is potentially incompatible with older enrollment software.
//


//
// MessageId: CERTSRV_E_ROLECONFLICT
//
// MessageText:
//
// The operation is denied. The user has multiple roles assigned and the certification authority is configured to enforce role separation.
//


//
// MessageId: CERTSRV_E_RESTRICTEDOFFICER
//
// MessageText:
//
// The operation is denied. It can only be performed by a certificate manager that is allowed to manage certificates for the current requester.
//


//
// MessageId: CERTSRV_E_KEY_ARCHIVAL_NOT_CONFIGURED
//
// MessageText:
//
// Cannot archive private key. The certification authority is not configured for key archival.
//


//
// MessageId: CERTSRV_E_NO_VALID_KRA
//
// MessageText:
//
// Cannot archive private key. The certification authority could not verify one or more key recovery certificates.
//


//
// MessageId: CERTSRV_E_BAD_REQUEST_KEY_ARCHIVAL
//
// MessageText:
//
// The request is incorrectly formatted. The encrypted private key must be in an unauthenticated attribute in an outermost signature.
//


//
// MessageId: CERTSRV_E_NO_CAADMIN_DEFINED
//
// MessageText:
//
// At least one security principal must have the permission to manage this CA.
//


//
// MessageId: CERTSRV_E_BAD_RENEWAL_CERT_ATTRIBUTE
//
// MessageText:
//
// The request contains an invalid renewal certificate attribute.
//


//
// MessageId: CERTSRV_E_NO_DB_SESSIONS
//
// MessageText:
//
// An attempt was made to open a Certification Authority database session, but there are already too many active sessions. The server may need to be configured to allow additional sessions.
//


//
// MessageId: CERTSRV_E_ALIGNMENT_FAULT
//
// MessageText:
//
// A memory reference caused a data alignment fault.
//


//
// MessageId: CERTSRV_E_ENROLL_DENIED
//
// MessageText:
//
// The permissions on this certification authority do not allow the current user to enroll for certificates.
//


//
// MessageId: CERTSRV_E_TEMPLATE_DENIED
//
// MessageText:
//
// The permissions on the certificate template do not allow the current user to enroll for this type of certificate.
//


//
// MessageId: CERTSRV_E_DOWNLEVEL_DC_SSL_OR_UPGRADE
//
// MessageText:
//
// The contacted domain controller cannot support signed LDAP traffic. Update the domain controller or configure Certificate Services to use SSL for Active Directory access.
//


//
// MessageId: CERTSRV_E_ADMIN_DENIED_REQUEST
//
// MessageText:
//
// The request was denied by a certificate manager or CA administrator.
//


//
// MessageId: CERTSRV_E_NO_POLICY_SERVER
//
// MessageText:
//
// An enrollment policy server cannot be located.
//


//
// MessageId: CERTSRV_E_WEAK_SIGNATURE_OR_KEY
//
// MessageText:
//
// A signature algorithm or public key length does not meet the system's minimum required strength.
//


//
// MessageId: CERTSRV_E_KEY_ATTESTATION_NOT_SUPPORTED
//
// MessageText:
//
// Failed to create an attested key.  This computer or the cryptographic provider may not meet the hardware requirements to support key attestation.
//


//
// MessageId: CERTSRV_E_ENCRYPTION_CERT_REQUIRED
//
// MessageText:
//
// No encryption certificate was specified.
//


//
// MessageId: CERTSRV_E_UNSUPPORTED_CERT_TYPE
//
// MessageText:
//
// The requested certificate template is not supported by this CA.
//


//
// MessageId: CERTSRV_E_NO_CERT_TYPE
//
// MessageText:
//
// The request contains no certificate template information.
//


//
// MessageId: CERTSRV_E_TEMPLATE_CONFLICT
//
// MessageText:
//
// The request contains conflicting template information.
//


//
// MessageId: CERTSRV_E_SUBJECT_ALT_NAME_REQUIRED
//
// MessageText:
//
// The request is missing a required Subject Alternate name extension.
//


//
// MessageId: CERTSRV_E_ARCHIVED_KEY_REQUIRED
//
// MessageText:
//
// The request is missing a required private key for archival by the server.
//


//
// MessageId: CERTSRV_E_SMIME_REQUIRED
//
// MessageText:
//
// The request is missing a required SMIME capabilities extension.
//


//
// MessageId: CERTSRV_E_BAD_RENEWAL_SUBJECT
//
// MessageText:
//
// The request was made on behalf of a subject other than the caller. The certificate template must be configured to require at least one signature to authorize the request.
//


//
// MessageId: CERTSRV_E_BAD_TEMPLATE_VERSION
//
// MessageText:
//
// The request template version is newer than the supported template version.
//


//
// MessageId: CERTSRV_E_TEMPLATE_POLICY_REQUIRED
//
// MessageText:
//
// The template is missing a required signature policy attribute.
//


//
// MessageId: CERTSRV_E_SIGNATURE_POLICY_REQUIRED
//
// MessageText:
//
// The request is missing required signature policy information.
//


//
// MessageId: CERTSRV_E_SIGNATURE_COUNT
//
// MessageText:
//
// The request is missing one or more required signatures.
//


//
// MessageId: CERTSRV_E_SIGNATURE_REJECTED
//
// MessageText:
//
// One or more signatures did not include the required application or issuance policies. The request is missing one or more required valid signatures.
//


//
// MessageId: CERTSRV_E_ISSUANCE_POLICY_REQUIRED
//
// MessageText:
//
// The request is missing one or more required signature issuance policies.
//


//
// MessageId: CERTSRV_E_SUBJECT_UPN_REQUIRED
//
// MessageText:
//
// The UPN is unavailable and cannot be added to the Subject Alternate name.
//


//
// MessageId: CERTSRV_E_SUBJECT_DIRECTORY_GUID_REQUIRED
//
// MessageText:
//
// The Active Directory GUID is unavailable and cannot be added to the Subject Alternate name.
//


//
// MessageId: CERTSRV_E_SUBJECT_DNS_REQUIRED
//
// MessageText:
//
// The DNS name is unavailable and cannot be added to the Subject Alternate name.
//


//
// MessageId: CERTSRV_E_ARCHIVED_KEY_UNEXPECTED
//
// MessageText:
//
// The request includes a private key for archival by the server, but key archival is not enabled for the specified certificate template.
//


//
// MessageId: CERTSRV_E_KEY_LENGTH
//
// MessageText:
//
// The public key does not meet the minimum size required by the specified certificate template.
//


//
// MessageId: CERTSRV_E_SUBJECT_EMAIL_REQUIRED
//
// MessageText:
//
// The EMail name is unavailable and cannot be added to the Subject or Subject Alternate name.
//


//
// MessageId: CERTSRV_E_UNKNOWN_CERT_TYPE
//
// MessageText:
//
// One or more certificate templates to be enabled on this certification authority could not be found.
//


//
// MessageId: CERTSRV_E_CERT_TYPE_OVERLAP
//
// MessageText:
//
// The certificate template renewal period is longer than the certificate validity period. The template should be reconfigured or the CA certificate renewed.
//


//
// MessageId: CERTSRV_E_TOO_MANY_SIGNATURES
//
// MessageText:
//
// The certificate template requires too many RA signatures. Only one RA signature is allowed.
//


//
// MessageId: CERTSRV_E_RENEWAL_BAD_PUBLIC_KEY
//
// MessageText:
//
// The certificate template requires renewal with the same public key, but the request uses a different public key.
//


//
// MessageId: CERTSRV_E_INVALID_EK
//
// MessageText:
//
// The certification authority cannot interpret or verify the endorsement key information supplied in the request, or the information is inconsistent.
//


//
// MessageId: CERTSRV_E_INVALID_IDBINDING
//
// MessageText:
//
// The certification authority cannot validate the Attestation Identity Key Id Binding.
//


//
// MessageId: CERTSRV_E_INVALID_ATTESTATION
//
// MessageText:
//
// The certification authority cannot validate the private key attestation data.
//


//
// MessageId: CERTSRV_E_KEY_ATTESTATION
//
// MessageText:
//
// The request does not support private key attestation as defined in the certificate template.
//


//
// MessageId: CERTSRV_E_CORRUPT_KEY_ATTESTATION
//
// MessageText:
//
// The request public key is not consistent with the private key attestation data.
//


//
// MessageId: CERTSRV_E_EXPIRED_CHALLENGE
//
// MessageText:
//
// The private key attestation challenge cannot be validated because the encryption certificate has expired, or the certificate or key is unavailable.
//


//
// MessageId: CERTSRV_E_INVALID_RESPONSE
//
// MessageText:
//
// The client's response could not be validated. It is either unexpected or incorrect.
//


//
// MessageId: CERTSRV_E_INVALID_REQUESTID
//
// MessageText:
//
// A valid Request ID was not detected in the request attributes, or an invalid one was submitted.
//


//
// MessageId: CERTSRV_E_REQUEST_PRECERTIFICATE_MISMATCH
//
// MessageText:
//
// The request is not consistent with the previously generated precertificate.
//


//
// MessageId: CERTSRV_E_PENDING_CLIENT_RESPONSE
//
// MessageText:
//
// The request is locked against edits until a response is received from the client.
//


//
// The range 0x5000-0x51ff is reserved for XENROLL errors.
//
//
// MessageId: XENROLL_E_KEY_NOT_EXPORTABLE
//
// MessageText:
//
// The key is not exportable.
//


//
// MessageId: XENROLL_E_CANNOT_ADD_ROOT_CERT
//
// MessageText:
//
// You cannot add the root CA certificate into your local store.
//


//
// MessageId: XENROLL_E_RESPONSE_KA_HASH_NOT_FOUND
//
// MessageText:
//
// The key archival hash attribute was not found in the response.
//


//
// MessageId: XENROLL_E_RESPONSE_UNEXPECTED_KA_HASH
//
// MessageText:
//
// An unexpected key archival hash attribute was found in the response.
//


//
// MessageId: XENROLL_E_RESPONSE_KA_HASH_MISMATCH
//
// MessageText:
//
// There is a key archival hash mismatch between the request and the response.
//


//
// MessageId: XENROLL_E_KEYSPEC_SMIME_MISMATCH
//
// MessageText:
//
// Signing certificate cannot include SMIME extension.
//


//
// MessageId: TRUST_E_SYSTEM_ERROR
//
// MessageText:
//
// A system-level error occurred while verifying trust.
//


//
// MessageId: TRUST_E_NO_SIGNER_CERT
//
// MessageText:
//
// The certificate for the signer of the message is invalid or not found.
//


//
// MessageId: TRUST_E_COUNTER_SIGNER
//
// MessageText:
//
// One of the counter signatures was invalid.
//


//
// MessageId: TRUST_E_CERT_SIGNATURE
//
// MessageText:
//
// The signature of the certificate cannot be verified.
//


//
// MessageId: TRUST_E_TIME_STAMP
//
// MessageText:
//
// The timestamp signature and/or certificate could not be verified or is malformed.
//


//
// MessageId: TRUST_E_BAD_DIGEST
//
// MessageText:
//
// The digital signature of the object did not verify.
//


//
// MessageId: TRUST_E_MALFORMED_SIGNATURE
//
// MessageText:
//
// The digital signature of the object is malformed. For technical detail, see security bulletin MS13-098.
//


//
// MessageId: TRUST_E_BASIC_CONSTRAINTS
//
// MessageText:
//
// A certificate's basic constraint extension has not been observed.
//


//
// MessageId: TRUST_E_FINANCIAL_CRITERIA
//
// MessageText:
//
// The certificate does not meet or contain the Authenticode(tm) financial extensions.
//


//
// Error codes for mssipotf.dll
// Most of the error codes can only occur when an error occurs
//    during font file signing
//
//
//
// MessageId: MSSIPOTF_E_OUTOFMEMRANGE
//
// MessageText:
//
// Tried to reference a part of the file outside the proper range.
//


//
// MessageId: MSSIPOTF_E_CANTGETOBJECT
//
// MessageText:
//
// Could not retrieve an object from the file.
//


//
// MessageId: MSSIPOTF_E_NOHEADTABLE
//
// MessageText:
//
// Could not find the head table in the file.
//


//
// MessageId: MSSIPOTF_E_BAD_MAGICNUMBER
//
// MessageText:
//
// The magic number in the head table is incorrect.
//


//
// MessageId: MSSIPOTF_E_BAD_OFFSET_TABLE
//
// MessageText:
//
// The offset table has incorrect values.
//


//
// MessageId: MSSIPOTF_E_TABLE_TAGORDER
//
// MessageText:
//
// Duplicate table tags or tags out of alphabetical order.
//


//
// MessageId: MSSIPOTF_E_TABLE_LONGWORD
//
// MessageText:
//
// A table does not start on a long word boundary.
//


//
// MessageId: MSSIPOTF_E_BAD_FIRST_TABLE_PLACEMENT
//
// MessageText:
//
// First table does not appear after header information.
//


//
// MessageId: MSSIPOTF_E_TABLES_OVERLAP
//
// MessageText:
//
// Two or more tables overlap.
//


//
// MessageId: MSSIPOTF_E_TABLE_PADBYTES
//
// MessageText:
//
// Too many pad bytes between tables or pad bytes are not 0.
//


//
// MessageId: MSSIPOTF_E_FILETOOSMALL
//
// MessageText:
//
// File is too small to contain the last table.
//


//
// MessageId: MSSIPOTF_E_TABLE_CHECKSUM
//
// MessageText:
//
// A table checksum is incorrect.
//


//
// MessageId: MSSIPOTF_E_FILE_CHECKSUM
//
// MessageText:
//
// The file checksum is incorrect.
//


//
// MessageId: MSSIPOTF_E_FAILED_POLICY
//
// MessageText:
//
// The signature does not have the correct attributes for the policy.
//


//
// MessageId: MSSIPOTF_E_FAILED_HINTS_CHECK
//
// MessageText:
//
// The file did not pass the hints check.
//


//
// MessageId: MSSIPOTF_E_NOT_OPENTYPE
//
// MessageText:
//
// The file is not an OpenType file.
//


//
// MessageId: MSSIPOTF_E_FILE
//
// MessageText:
//
// Failed on a file operation (open, map, read, write).
//


//
// MessageId: MSSIPOTF_E_CRYPT
//
// MessageText:
//
// A call to a CryptoAPI function failed.
//


//
// MessageId: MSSIPOTF_E_BADVERSION
//
// MessageText:
//
// There is a bad version number in the file.
//


//
// MessageId: MSSIPOTF_E_DSIG_STRUCTURE
//
// MessageText:
//
// The structure of the DSIG table is incorrect.
//


//
// MessageId: MSSIPOTF_E_PCONST_CHECK
//
// MessageText:
//
// A check failed in a partially constant table.
//


//
// MessageId: MSSIPOTF_E_STRUCTURE
//
// MessageText:
//
// Some kind of structural error.
//


//
// MessageId: ERROR_CRED_REQUIRES_CONFIRMATION
//
// MessageText:
//
// The requested credential requires confirmation.
//




//
// Note that additional FACILITY_SSPI errors are in issperr.h
//
// ******************
// FACILITY_CERT
// ******************
//
// MessageId: TRUST_E_PROVIDER_UNKNOWN
//
// MessageText:
//
// Unknown trust provider.
//


//
// MessageId: TRUST_E_ACTION_UNKNOWN
//
// MessageText:
//
// The trust verification action specified is not supported by the specified trust provider.
//


//
// MessageId: TRUST_E_SUBJECT_FORM_UNKNOWN
//
// MessageText:
//
// The form specified for the subject is not one supported or known by the specified trust provider.
//


//
// MessageId: TRUST_E_SUBJECT_NOT_TRUSTED
//
// MessageText:
//
// The subject is not trusted for the specified action.
//


//
// MessageId: DIGSIG_E_ENCODE
//
// MessageText:
//
// Error due to problem in ASN.1 encoding process.
//


//
// MessageId: DIGSIG_E_DECODE
//
// MessageText:
//
// Error due to problem in ASN.1 decoding process.
//


//
// MessageId: DIGSIG_E_EXTENSIBILITY
//
// MessageText:
//
// Reading / writing Extensions where Attributes are appropriate, and vice versa.
//


//
// MessageId: DIGSIG_E_CRYPTO
//
// MessageText:
//
// Unspecified cryptographic failure.
//


//
// MessageId: PERSIST_E_SIZEDEFINITE
//
// MessageText:
//
// The size of the data could not be determined.
//


//
// MessageId: PERSIST_E_SIZEINDEFINITE
//
// MessageText:
//
// The size of the indefinite-sized data could not be determined.
//


//
// MessageId: PERSIST_E_NOTSELFSIZING
//
// MessageText:
//
// This object does not read and write self-sizing data.
//


//
// MessageId: TRUST_E_NOSIGNATURE
//
// MessageText:
//
// No signature was present in the subject.
//


//
// MessageId: CERT_E_EXPIRED
//
// MessageText:
//
// A required certificate is not within its validity period when verifying against the current system clock or the timestamp in the signed file.
//


//
// MessageId: CERT_E_VALIDITYPERIODNESTING
//
// MessageText:
//
// The validity periods of the certification chain do not nest correctly.
//


//
// MessageId: CERT_E_ROLE
//
// MessageText:
//
// A certificate that can only be used as an end-entity is being used as a CA or vice versa.
//


//
// MessageId: CERT_E_PATHLENCONST
//
// MessageText:
//
// A path length constraint in the certification chain has been violated.
//


//
// MessageId: CERT_E_CRITICAL
//
// MessageText:
//
// A certificate contains an unknown extension that is marked 'critical'.
//


//
// MessageId: CERT_E_PURPOSE
//
// MessageText:
//
// A certificate being used for a purpose other than the ones specified by its CA.
//


//
// MessageId: CERT_E_ISSUERCHAINING
//
// MessageText:
//
// A parent of a given certificate in fact did not issue that child certificate.
//


//
// MessageId: CERT_E_MALFORMED
//
// MessageText:
//
// A certificate is missing or has an empty value for an important field, such as a subject or issuer name.
//


//
// MessageId: CERT_E_UNTRUSTEDROOT
//
// MessageText:
//
// A certificate chain processed, but terminated in a root certificate which is not trusted by the trust provider.
//


//
// MessageId: CERT_E_CHAINING
//
// MessageText:
//
// A certificate chain could not be built to a trusted root authority.
//


//
// MessageId: TRUST_E_FAIL
//
// MessageText:
//
// Generic trust failure.
//


//
// MessageId: CERT_E_REVOKED
//
// MessageText:
//
// A certificate was explicitly revoked by its issuer.
//


//
// MessageId: CERT_E_UNTRUSTEDTESTROOT
//
// MessageText:
//
// The certification path terminates with the test root which is not trusted with the current policy settings.
//


//
// MessageId: CERT_E_REVOCATION_FAILURE
//
// MessageText:
//
// The revocation process could not continue - the certificate(s) could not be checked.
//


//
// MessageId: CERT_E_CN_NO_MATCH
//
// MessageText:
//
// The certificate's CN name does not match the passed value.
//


//
// MessageId: CERT_E_WRONG_USAGE
//
// MessageText:
//
// The certificate is not valid for the requested usage.
//


//
// MessageId: TRUST_E_EXPLICIT_DISTRUST
//
// MessageText:
//
// The certificate was explicitly marked as untrusted by the user.
//


//
// MessageId: CERT_E_UNTRUSTEDCA
//
// MessageText:
//
// A certification chain processed correctly, but one of the CA certificates is not trusted by the policy provider.
//


//
// MessageId: CERT_E_INVALID_POLICY
//
// MessageText:
//
// The certificate has invalid policy.
//


//
// MessageId: CERT_E_INVALID_NAME
//
// MessageText:
//
// The certificate has an invalid name. The name is not included in the permitted list or is explicitly excluded.
//


// *****************
// FACILITY_MEDIASERVER
// *****************
//
// Also known as FACILITY_MF and FACILITY_NS
//
// The error codes are defined in mferror.mc, dlnaerror.mc, nserror.mc, and neterror.mc
//
// *****************
// FACILITY_SETUPAPI
// *****************
//
// Since these error codes aren't in the standard Win32 range (i.e., 0-64K), define a
// macro to map either Win32 or SetupAPI error codes into an HRESULT.
//



//
// MessageId: SPAPI_E_EXPECTED_SECTION_NAME
//
// MessageText:
//
// A non-empty line was encountered in the INF before the start of a section.
//


//
// MessageId: SPAPI_E_BAD_SECTION_NAME_LINE
//
// MessageText:
//
// A section name marker in the INF is not complete, or does not exist on a line by itself.
//


//
// MessageId: SPAPI_E_SECTION_NAME_TOO_LONG
//
// MessageText:
//
// An INF section was encountered whose name exceeds the maximum section name length.
//


//
// MessageId: SPAPI_E_GENERAL_SYNTAX
//
// MessageText:
//
// The syntax of the INF is invalid.
//


//
// MessageId: SPAPI_E_WRONG_INF_STYLE
//
// MessageText:
//
// The style of the INF is different than what was requested.
//


//
// MessageId: SPAPI_E_SECTION_NOT_FOUND
//
// MessageText:
//
// The required section was not found in the INF.
//


//
// MessageId: SPAPI_E_LINE_NOT_FOUND
//
// MessageText:
//
// The required line was not found in the INF.
//


//
// MessageId: SPAPI_E_NO_BACKUP
//
// MessageText:
//
// The files affected by the installation of this file queue have not been backed up for uninstall.
//


//
// MessageId: SPAPI_E_NO_ASSOCIATED_CLASS
//
// MessageText:
//
// The INF or the device information set or element does not have an associated install class.
//


//
// MessageId: SPAPI_E_CLASS_MISMATCH
//
// MessageText:
//
// The INF or the device information set or element does not match the specified install class.
//


//
// MessageId: SPAPI_E_DUPLICATE_FOUND
//
// MessageText:
//
// An existing device was found that is a duplicate of the device being manually installed.
//


//
// MessageId: SPAPI_E_NO_DRIVER_SELECTED
//
// MessageText:
//
// There is no driver selected for the device information set or element.
//


//
// MessageId: SPAPI_E_KEY_DOES_NOT_EXIST
//
// MessageText:
//
// The requested device registry key does not exist.
//


//
// MessageId: SPAPI_E_INVALID_DEVINST_NAME
//
// MessageText:
//
// The device instance name is invalid.
//


//
// MessageId: SPAPI_E_INVALID_CLASS
//
// MessageText:
//
// The install class is not present or is invalid.
//


//
// MessageId: SPAPI_E_DEVINST_ALREADY_EXISTS
//
// MessageText:
//
// The device instance cannot be created because it already exists.
//


//
// MessageId: SPAPI_E_DEVINFO_NOT_REGISTERED
//
// MessageText:
//
// The operation cannot be performed on a device information element that has not been registered.
//


//
// MessageId: SPAPI_E_INVALID_REG_PROPERTY
//
// MessageText:
//
// The device property code is invalid.
//


//
// MessageId: SPAPI_E_NO_INF
//
// MessageText:
//
// The INF from which a driver list is to be built does not exist.
//


//
// MessageId: SPAPI_E_NO_SUCH_DEVINST
//
// MessageText:
//
// The device instance does not exist in the hardware tree.
//


//
// MessageId: SPAPI_E_CANT_LOAD_CLASS_ICON
//
// MessageText:
//
// The icon representing this install class cannot be loaded.
//


//
// MessageId: SPAPI_E_INVALID_CLASS_INSTALLER
//
// MessageText:
//
// The class installer registry entry is invalid.
//


//
// MessageId: SPAPI_E_DI_DO_DEFAULT
//
// MessageText:
//
// The class installer has indicated that the default action should be performed for this installation request.
//


//
// MessageId: SPAPI_E_DI_NOFILECOPY
//
// MessageText:
//
// The operation does not require any files to be copied.
//


//
// MessageId: SPAPI_E_INVALID_HWPROFILE
//
// MessageText:
//
// The specified hardware profile does not exist.
//


//
// MessageId: SPAPI_E_NO_DEVICE_SELECTED
//
// MessageText:
//
// There is no device information element currently selected for this device information set.
//


//
// MessageId: SPAPI_E_DEVINFO_LIST_LOCKED
//
// MessageText:
//
// The operation cannot be performed because the device information set is locked.
//


//
// MessageId: SPAPI_E_DEVINFO_DATA_LOCKED
//
// MessageText:
//
// The operation cannot be performed because the device information element is locked.
//


//
// MessageId: SPAPI_E_DI_BAD_PATH
//
// MessageText:
//
// The specified path does not contain any applicable device INFs.
//


//
// MessageId: SPAPI_E_NO_CLASSINSTALL_PARAMS
//
// MessageText:
//
// No class installer parameters have been set for the device information set or element.
//


//
// MessageId: SPAPI_E_FILEQUEUE_LOCKED
//
// MessageText:
//
// The operation cannot be performed because the file queue is locked.
//


//
// MessageId: SPAPI_E_BAD_SERVICE_INSTALLSECT
//
// MessageText:
//
// A service installation section in this INF is invalid.
//


//
// MessageId: SPAPI_E_NO_CLASS_DRIVER_LIST
//
// MessageText:
//
// There is no class driver list for the device information element.
//


//
// MessageId: SPAPI_E_NO_ASSOCIATED_SERVICE
//
// MessageText:
//
// The installation failed because a function driver was not specified for this device instance.
//


//
// MessageId: SPAPI_E_NO_DEFAULT_DEVICE_INTERFACE
//
// MessageText:
//
// There is presently no default device interface designated for this interface class.
//


//
// MessageId: SPAPI_E_DEVICE_INTERFACE_ACTIVE
//
// MessageText:
//
// The operation cannot be performed because the device interface is currently active.
//


//
// MessageId: SPAPI_E_DEVICE_INTERFACE_REMOVED
//
// MessageText:
//
// The operation cannot be performed because the device interface has been removed from the system.
//


//
// MessageId: SPAPI_E_BAD_INTERFACE_INSTALLSECT
//
// MessageText:
//
// An interface installation section in this INF is invalid.
//


//
// MessageId: SPAPI_E_NO_SUCH_INTERFACE_CLASS
//
// MessageText:
//
// This interface class does not exist in the system.
//


//
// MessageId: SPAPI_E_INVALID_REFERENCE_STRING
//
// MessageText:
//
// The reference string supplied for this interface device is invalid.
//


//
// MessageId: SPAPI_E_INVALID_MACHINENAME
//
// MessageText:
//
// The specified machine name does not conform to UNC naming conventions.
//


//
// MessageId: SPAPI_E_REMOTE_COMM_FAILURE
//
// MessageText:
//
// A general remote communication error occurred.
//


//
// MessageId: SPAPI_E_MACHINE_UNAVAILABLE
//
// MessageText:
//
// The machine selected for remote communication is not available at this time.
//


//
// MessageId: SPAPI_E_NO_CONFIGMGR_SERVICES
//
// MessageText:
//
// The Plug and Play service is not available on the remote machine.
//


//
// MessageId: SPAPI_E_INVALID_PROPPAGE_PROVIDER
//
// MessageText:
//
// The property page provider registry entry is invalid.
//


//
// MessageId: SPAPI_E_NO_SUCH_DEVICE_INTERFACE
//
// MessageText:
//
// The requested device interface is not present in the system.
//


//
// MessageId: SPAPI_E_DI_POSTPROCESSING_REQUIRED
//
// MessageText:
//
// The device's co-installer has additional work to perform after installation is complete.
//


//
// MessageId: SPAPI_E_INVALID_COINSTALLER
//
// MessageText:
//
// The device's co-installer is invalid.
//


//
// MessageId: SPAPI_E_NO_COMPAT_DRIVERS
//
// MessageText:
//
// There are no compatible drivers for this device.
//


//
// MessageId: SPAPI_E_NO_DEVICE_ICON
//
// MessageText:
//
// There is no icon that represents this device or device type.
//


//
// MessageId: SPAPI_E_INVALID_INF_LOGCONFIG
//
// MessageText:
//
// A logical configuration specified in this INF is invalid.
//


//
// MessageId: SPAPI_E_DI_DONT_INSTALL
//
// MessageText:
//
// The class installer has denied the request to install or upgrade this device.
//


//
// MessageId: SPAPI_E_INVALID_FILTER_DRIVER
//
// MessageText:
//
// One of the filter drivers installed for this device is invalid.
//


//
// MessageId: SPAPI_E_NON_WINDOWS_NT_DRIVER
//
// MessageText:
//
// The driver selected for this device does not support this version of Windows.
//


//
// MessageId: SPAPI_E_NON_WINDOWS_DRIVER
//
// MessageText:
//
// The driver selected for this device does not support Windows.
//


//
// MessageId: SPAPI_E_NO_CATALOG_FOR_OEM_INF
//
// MessageText:
//
// The third-party INF does not contain digital signature information.
//


//
// MessageId: SPAPI_E_DEVINSTALL_QUEUE_NONNATIVE
//
// MessageText:
//
// An invalid attempt was made to use a device installation file queue for verification of digital signatures relative to other platforms.
//


//
// MessageId: SPAPI_E_NOT_DISABLEABLE
//
// MessageText:
//
// The device cannot be disabled.
//


//
// MessageId: SPAPI_E_CANT_REMOVE_DEVINST
//
// MessageText:
//
// The device could not be dynamically removed.
//


//
// MessageId: SPAPI_E_INVALID_TARGET
//
// MessageText:
//
// Cannot copy to specified target.
//


//
// MessageId: SPAPI_E_DRIVER_NONNATIVE
//
// MessageText:
//
// Driver is not intended for this platform.
//


//
// MessageId: SPAPI_E_IN_WOW64
//
// MessageText:
//
// Operation not allowed in WOW64.
//


//
// MessageId: SPAPI_E_SET_SYSTEM_RESTORE_POINT
//
// MessageText:
//
// The operation involving unsigned file copying was rolled back, so that a system restore point could be set.
//


//
// MessageId: SPAPI_E_INCORRECTLY_COPIED_INF
//
// MessageText:
//
// An INF was copied into the Windows INF directory in an improper manner.
//


//
// MessageId: SPAPI_E_SCE_DISABLED
//
// MessageText:
//
// The Security Configuration Editor (SCE) APIs have been disabled on this Embedded product.
//


//
// MessageId: SPAPI_E_UNKNOWN_EXCEPTION
//
// MessageText:
//
// An unknown exception was encountered.
//


//
// MessageId: SPAPI_E_PNP_REGISTRY_ERROR
//
// MessageText:
//
// A problem was encountered when accessing the Plug and Play registry database.
//


//
// MessageId: SPAPI_E_REMOTE_REQUEST_UNSUPPORTED
//
// MessageText:
//
// The requested operation is not supported for a remote machine.
//


//
// MessageId: SPAPI_E_NOT_AN_INSTALLED_OEM_INF
//
// MessageText:
//
// The specified file is not an installed OEM INF.
//


//
// MessageId: SPAPI_E_INF_IN_USE_BY_DEVICES
//
// MessageText:
//
// One or more devices are presently installed using the specified INF.
//


//
// MessageId: SPAPI_E_DI_FUNCTION_OBSOLETE
//
// MessageText:
//
// The requested device install operation is obsolete.
//


//
// MessageId: SPAPI_E_NO_AUTHENTICODE_CATALOG
//
// MessageText:
//
// A file could not be verified because it does not have an associated catalog signed via Authenticode(tm).
//


//
// MessageId: SPAPI_E_AUTHENTICODE_DISALLOWED
//
// MessageText:
//
// Authenticode(tm) signature verification is not supported for the specified INF.
//


//
// MessageId: SPAPI_E_AUTHENTICODE_TRUSTED_PUBLISHER
//
// MessageText:
//
// The INF was signed with an Authenticode(tm) catalog from a trusted publisher.
//


//
// MessageId: SPAPI_E_AUTHENTICODE_TRUST_NOT_ESTABLISHED
//
// MessageText:
//
// The publisher of an Authenticode(tm) signed catalog has not yet been established as trusted.
//


//
// MessageId: SPAPI_E_AUTHENTICODE_PUBLISHER_NOT_TRUSTED
//
// MessageText:
//
// The publisher of an Authenticode(tm) signed catalog was not established as trusted.
//


//
// MessageId: SPAPI_E_SIGNATURE_OSATTRIBUTE_MISMATCH
//
// MessageText:
//
// The software was tested for compliance with Windows Logo requirements on a different version of Windows, and may not be compatible with this version.
//


//
// MessageId: SPAPI_E_ONLY_VALIDATE_VIA_AUTHENTICODE
//
// MessageText:
//
// The file may only be validated by a catalog signed via Authenticode(tm).
//


//
// MessageId: SPAPI_E_DEVICE_INSTALLER_NOT_READY
//
// MessageText:
//
// One of the installers for this device cannot perform the installation at this time.
//


//
// MessageId: SPAPI_E_DRIVER_STORE_ADD_FAILED
//
// MessageText:
//
// A problem was encountered while attempting to add the driver to the store.
//


//
// MessageId: SPAPI_E_DEVICE_INSTALL_BLOCKED
//
// MessageText:
//
// The installation of this device is forbidden by system policy. Contact your system administrator.
//


//
// MessageId: SPAPI_E_DRIVER_INSTALL_BLOCKED
//
// MessageText:
//
// The installation of this driver is forbidden by system policy. Contact your system administrator.
//


//
// MessageId: SPAPI_E_WRONG_INF_TYPE
//
// MessageText:
//
// The specified INF is the wrong type for this operation.
//


//
// MessageId: SPAPI_E_FILE_HASH_NOT_IN_CATALOG
//
// MessageText:
//
// The hash for the file is not present in the specified catalog file. The file is likely corrupt or the victim of tampering.
//


//
// MessageId: SPAPI_E_DRIVER_STORE_DELETE_FAILED
//
// MessageText:
//
// A problem was encountered while attempting to delete the driver from the store.
//


//
// MessageId: SPAPI_E_UNRECOVERABLE_STACK_OVERFLOW
//
// MessageText:
//
// An unrecoverable stack overflow was encountered.
//


//
// MessageId: SPAPI_E_ERROR_NOT_INSTALLED
//
// MessageText:
//
// No installed components were detected.
//


// *****************
// FACILITY_SCARD
// *****************
//
// =============================
// Facility SCARD Error Messages
// =============================
//

//
// MessageId: SCARD_F_INTERNAL_ERROR
//
// MessageText:
//
// An internal consistency check failed.
//


//
// MessageId: SCARD_E_CANCELLED
//
// MessageText:
//
// The action was cancelled by an SCardCancel request.
//


//
// MessageId: SCARD_E_INVALID_HANDLE
//
// MessageText:
//
// The supplied handle was invalid.
//


//
// MessageId: SCARD_E_INVALID_PARAMETER
//
// MessageText:
//
// One or more of the supplied parameters could not be properly interpreted.
//


//
// MessageId: SCARD_E_INVALID_TARGET
//
// MessageText:
//
// Registry startup information is missing or invalid.
//


//
// MessageId: SCARD_E_NO_MEMORY
//
// MessageText:
//
// Not enough memory available to complete this command.
//


//
// MessageId: SCARD_F_WAITED_TOO_LONG
//
// MessageText:
//
// An internal consistency timer has expired.
//


//
// MessageId: SCARD_E_INSUFFICIENT_BUFFER
//
// MessageText:
//
// The data buffer to receive returned data is too small for the returned data.
//


//
// MessageId: SCARD_E_UNKNOWN_READER
//
// MessageText:
//
// The specified reader name is not recognized.
//


//
// MessageId: SCARD_E_TIMEOUT
//
// MessageText:
//
// The user-specified timeout value has expired.
//


//
// MessageId: SCARD_E_SHARING_VIOLATION
//
// MessageText:
//
// The smart card cannot be accessed because of other connections outstanding.
//


//
// MessageId: SCARD_E_NO_SMARTCARD
//
// MessageText:
//
// The operation requires a smart card, but no smart card is currently in the device.
//


//
// MessageId: SCARD_E_UNKNOWN_CARD
//
// MessageText:
//
// The specified smart card name is not recognized.
//


//
// MessageId: SCARD_E_CANT_DISPOSE
//
// MessageText:
//
// The system could not dispose of the media in the requested manner.
//


//
// MessageId: SCARD_E_PROTO_MISMATCH
//
// MessageText:
//
// The requested protocols are incompatible with the protocol currently in use with the smart card.
//


//
// MessageId: SCARD_E_NOT_READY
//
// MessageText:
//
// The reader or smart card is not ready to accept commands.
//


//
// MessageId: SCARD_E_INVALID_VALUE
//
// MessageText:
//
// One or more of the supplied parameters values could not be properly interpreted.
//


//
// MessageId: SCARD_E_SYSTEM_CANCELLED
//
// MessageText:
//
// The action was cancelled by the system, presumably to log off or shut down.
//


//
// MessageId: SCARD_F_COMM_ERROR
//
// MessageText:
//
// An internal communications error has been detected.
//


//
// MessageId: SCARD_F_UNKNOWN_ERROR
//
// MessageText:
//
// An internal error has been detected, but the source is unknown.
//


//
// MessageId: SCARD_E_INVALID_ATR
//
// MessageText:
//
// An ATR obtained from the registry is not a valid ATR string.
//


//
// MessageId: SCARD_E_NOT_TRANSACTED
//
// MessageText:
//
// An attempt was made to end a non-existent transaction.
//


//
// MessageId: SCARD_E_READER_UNAVAILABLE
//
// MessageText:
//
// The specified reader is not currently available for use.
//


//
// MessageId: SCARD_P_SHUTDOWN
//
// MessageText:
//
// The operation has been aborted to allow the server application to exit.
//


//
// MessageId: SCARD_E_PCI_TOO_SMALL
//
// MessageText:
//
// The PCI Receive buffer was too small.
//


//
// MessageId: SCARD_E_READER_UNSUPPORTED
//
// MessageText:
//
// The reader driver does not meet minimal requirements for support.
//


//
// MessageId: SCARD_E_DUPLICATE_READER
//
// MessageText:
//
// The reader driver did not produce a unique reader name.
//


//
// MessageId: SCARD_E_CARD_UNSUPPORTED
//
// MessageText:
//
// The smart card does not meet minimal requirements for support.
//


//
// MessageId: SCARD_E_NO_SERVICE
//
// MessageText:
//
// The Smart Card Resource Manager is not running.
//


//
// MessageId: SCARD_E_SERVICE_STOPPED
//
// MessageText:
//
// The Smart Card Resource Manager has shut down.
//


//
// MessageId: SCARD_E_UNEXPECTED
//
// MessageText:
//
// An unexpected card error has occurred.
//


//
// MessageId: SCARD_E_ICC_INSTALLATION
//
// MessageText:
//
// No Primary Provider can be found for the smart card.
//


//
// MessageId: SCARD_E_ICC_CREATEORDER
//
// MessageText:
//
// The requested order of object creation is not supported.
//


//
// MessageId: SCARD_E_UNSUPPORTED_FEATURE
//
// MessageText:
//
// This smart card does not support the requested feature.
//


//
// MessageId: SCARD_E_DIR_NOT_FOUND
//
// MessageText:
//
// The identified directory does not exist in the smart card.
//


//
// MessageId: SCARD_E_FILE_NOT_FOUND
//
// MessageText:
//
// The identified file does not exist in the smart card.
//


//
// MessageId: SCARD_E_NO_DIR
//
// MessageText:
//
// The supplied path does not represent a smart card directory.
//


//
// MessageId: SCARD_E_NO_FILE
//
// MessageText:
//
// The supplied path does not represent a smart card file.
//


//
// MessageId: SCARD_E_NO_ACCESS
//
// MessageText:
//
// Access is denied to this file.
//


//
// MessageId: SCARD_E_WRITE_TOO_MANY
//
// MessageText:
//
// The smart card does not have enough memory to store the information.
//


//
// MessageId: SCARD_E_BAD_SEEK
//
// MessageText:
//
// There was an error trying to set the smart card file object pointer.
//


//
// MessageId: SCARD_E_INVALID_CHV
//
// MessageText:
//
// The supplied PIN is incorrect.
//


//
// MessageId: SCARD_E_UNKNOWN_RES_MNG
//
// MessageText:
//
// An unrecognized error code was returned from a layered component.
//


//
// MessageId: SCARD_E_NO_SUCH_CERTIFICATE
//
// MessageText:
//
// The requested certificate does not exist.
//


//
// MessageId: SCARD_E_CERTIFICATE_UNAVAILABLE
//
// MessageText:
//
// The requested certificate could not be obtained.
//


//
// MessageId: SCARD_E_NO_READERS_AVAILABLE
//
// MessageText:
//
// Cannot find a smart card reader.
//


//
// MessageId: SCARD_E_COMM_DATA_LOST
//
// MessageText:
//
// A communications error with the smart card has been detected. Retry the operation.
//


//
// MessageId: SCARD_E_NO_KEY_CONTAINER
//
// MessageText:
//
// The requested key container does not exist on the smart card.
//


//
// MessageId: SCARD_E_SERVER_TOO_BUSY
//
// MessageText:
//
// The Smart Card Resource Manager is too busy to complete this operation.
//


//
// MessageId: SCARD_E_PIN_CACHE_EXPIRED
//
// MessageText:
//
// The smart card PIN cache has expired.
//


//
// MessageId: SCARD_E_NO_PIN_CACHE
//
// MessageText:
//
// The smart card PIN cannot be cached.
//


//
// MessageId: SCARD_E_READ_ONLY_CARD
//
// MessageText:
//
// The smart card is read only and cannot be written to.
//


//
// These are warning codes.
//
//
// MessageId: SCARD_W_UNSUPPORTED_CARD
//
// MessageText:
//
// The reader cannot communicate with the smart card, due to ATR configuration conflicts.
//


//
// MessageId: SCARD_W_UNRESPONSIVE_CARD
//
// MessageText:
//
// The smart card is not responding to a reset.
//


//
// MessageId: SCARD_W_UNPOWERED_CARD
//
// MessageText:
//
// Power has been removed from the smart card, so that further communication is not possible.
//


//
// MessageId: SCARD_W_RESET_CARD
//
// MessageText:
//
// The smart card has been reset, so any shared state information is invalid.
//


//
// MessageId: SCARD_W_REMOVED_CARD
//
// MessageText:
//
// The smart card has been removed, so that further communication is not possible.
//


//
// MessageId: SCARD_W_SECURITY_VIOLATION
//
// MessageText:
//
// Access was denied because of a security violation.
//


//
// MessageId: SCARD_W_WRONG_CHV
//
// MessageText:
//
// The card cannot be accessed because the wrong PIN was presented.
//


//
// MessageId: SCARD_W_CHV_BLOCKED
//
// MessageText:
//
// The card cannot be accessed because the maximum number of PIN entry attempts has been reached.
//


//
// MessageId: SCARD_W_EOF
//
// MessageText:
//
// The end of the smart card file has been reached.
//


//
// MessageId: SCARD_W_CANCELLED_BY_USER
//
// MessageText:
//
// The action was cancelled by the user.
//


//
// MessageId: SCARD_W_CARD_NOT_AUTHENTICATED
//
// MessageText:
//
// No PIN was presented to the smart card.
//


//
// MessageId: SCARD_W_CACHE_ITEM_NOT_FOUND
//
// MessageText:
//
// The requested item could not be found in the cache.
//


//
// MessageId: SCARD_W_CACHE_ITEM_STALE
//
// MessageText:
//
// The requested cache item is too old and was deleted from the cache.
//


//
// MessageId: SCARD_W_CACHE_ITEM_TOO_BIG
//
// MessageText:
//
// The new cache item exceeds the maximum per-item size defined for the cache.
//


// *****************
// FACILITY_COMPLUS
// *****************
//
// ===============================
// Facility COMPLUS Error Messages
// ===============================
//
//
// The following are the subranges  within the COMPLUS facility
// 0x400 - 0x4ff               COMADMIN_E_CAT
// 0x600 - 0x6ff               COMQC errors
// 0x700 - 0x7ff               MSDTC errors
// 0x800 - 0x8ff               Other COMADMIN errors
//
// COMPLUS Admin errors
//
//
// MessageId: COMADMIN_E_OBJECTERRORS
//
// MessageText:
//
// Errors occurred accessing one or more objects - the ErrorInfo collection may have more detail
//


//
// MessageId: COMADMIN_E_OBJECTINVALID
//
// MessageText:
//
// One or more of the object's properties are missing or invalid
//


//
// MessageId: COMADMIN_E_KEYMISSING
//
// MessageText:
//
// The object was not found in the catalog
//


//
// MessageId: COMADMIN_E_ALREADYINSTALLED
//
// MessageText:
//
// The object is already registered
//


//
// MessageId: COMADMIN_E_APP_FILE_WRITEFAIL
//
// MessageText:
//
// Error occurred writing to the application file
//


//
// MessageId: COMADMIN_E_APP_FILE_READFAIL
//
// MessageText:
//
// Error occurred reading the application file
//


//
// MessageId: COMADMIN_E_APP_FILE_VERSION
//
// MessageText:
//
// Invalid version number in application file
//


//
// MessageId: COMADMIN_E_BADPATH
//
// MessageText:
//
// The file path is invalid
//


//
// MessageId: COMADMIN_E_APPLICATIONEXISTS
//
// MessageText:
//
// The application is already installed
//


//
// MessageId: COMADMIN_E_ROLEEXISTS
//
// MessageText:
//
// The role already exists
//


//
// MessageId: COMADMIN_E_CANTCOPYFILE
//
// MessageText:
//
// An error occurred copying the file
//


//
// MessageId: COMADMIN_E_NOUSER
//
// MessageText:
//
// One or more users are not valid
//


//
// MessageId: COMADMIN_E_INVALIDUSERIDS
//
// MessageText:
//
// One or more users in the application file are not valid
//


//
// MessageId: COMADMIN_E_NOREGISTRYCLSID
//
// MessageText:
//
// The component's CLSID is missing or corrupt
//


//
// MessageId: COMADMIN_E_BADREGISTRYPROGID
//
// MessageText:
//
// The component's progID is missing or corrupt
//


//
// MessageId: COMADMIN_E_AUTHENTICATIONLEVEL
//
// MessageText:
//
// Unable to set required authentication level for update request
//


//
// MessageId: COMADMIN_E_USERPASSWDNOTVALID
//
// MessageText:
//
// The identity or password set on the application is not valid
//


//
// MessageId: COMADMIN_E_CLSIDORIIDMISMATCH
//
// MessageText:
//
// Application file CLSIDs or IIDs do not match corresponding DLLs
//


//
// MessageId: COMADMIN_E_REMOTEINTERFACE
//
// MessageText:
//
// Interface information is either missing or changed
//


//
// MessageId: COMADMIN_E_DLLREGISTERSERVER
//
// MessageText:
//
// DllRegisterServer failed on component install
//


//
// MessageId: COMADMIN_E_NOSERVERSHARE
//
// MessageText:
//
// No server file share available
//


//
// MessageId: COMADMIN_E_DLLLOADFAILED
//
// MessageText:
//
// DLL could not be loaded
//


//
// MessageId: COMADMIN_E_BADREGISTRYLIBID
//
// MessageText:
//
// The registered TypeLib ID is not valid
//


//
// MessageId: COMADMIN_E_APPDIRNOTFOUND
//
// MessageText:
//
// Application install directory not found
//


//
// MessageId: COMADMIN_E_REGISTRARFAILED
//
// MessageText:
//
// Errors occurred while in the component registrar
//


//
// MessageId: COMADMIN_E_COMPFILE_DOESNOTEXIST
//
// MessageText:
//
// The file does not exist
//


//
// MessageId: COMADMIN_E_COMPFILE_LOADDLLFAIL
//
// MessageText:
//
// The DLL could not be loaded
//


//
// MessageId: COMADMIN_E_COMPFILE_GETCLASSOBJ
//
// MessageText:
//
// GetClassObject failed in the DLL
//


//
// MessageId: COMADMIN_E_COMPFILE_CLASSNOTAVAIL
//
// MessageText:
//
// The DLL does not support the components listed in the TypeLib
//


//
// MessageId: COMADMIN_E_COMPFILE_BADTLB
//
// MessageText:
//
// The TypeLib could not be loaded
//


//
// MessageId: COMADMIN_E_COMPFILE_NOTINSTALLABLE
//
// MessageText:
//
// The file does not contain components or component information
//


//
// MessageId: COMADMIN_E_NOTCHANGEABLE
//
// MessageText:
//
// Changes to this object and its sub-objects have been disabled
//


//
// MessageId: COMADMIN_E_NOTDELETEABLE
//
// MessageText:
//
// The delete function has been disabled for this object
//


//
// MessageId: COMADMIN_E_SESSION
//
// MessageText:
//
// The server catalog version is not supported
//


//
// MessageId: COMADMIN_E_COMP_MOVE_LOCKED
//
// MessageText:
//
// The component move was disallowed, because the source or destination application is either a system application or currently locked against changes
//


//
// MessageId: COMADMIN_E_COMP_MOVE_BAD_DEST
//
// MessageText:
//
// The component move failed because the destination application no longer exists
//


//
// MessageId: COMADMIN_E_REGISTERTLB
//
// MessageText:
//
// The system was unable to register the TypeLib
//


//
// MessageId: COMADMIN_E_SYSTEMAPP
//
// MessageText:
//
// This operation cannot be performed on the system application
//


//
// MessageId: COMADMIN_E_COMPFILE_NOREGISTRAR
//
// MessageText:
//
// The component registrar referenced in this file is not available
//


//
// MessageId: COMADMIN_E_COREQCOMPINSTALLED
//
// MessageText:
//
// A component in the same DLL is already installed
//


//
// MessageId: COMADMIN_E_SERVICENOTINSTALLED
//
// MessageText:
//
// The service is not installed
//


//
// MessageId: COMADMIN_E_PROPERTYSAVEFAILED
//
// MessageText:
//
// One or more property settings are either invalid or in conflict with each other
//


//
// MessageId: COMADMIN_E_OBJECTEXISTS
//
// MessageText:
//
// The object you are attempting to add or rename already exists
//


//
// MessageId: COMADMIN_E_COMPONENTEXISTS
//
// MessageText:
//
// The component already exists
//


//
// MessageId: COMADMIN_E_REGFILE_CORRUPT
//
// MessageText:
//
// The registration file is corrupt
//


//
// MessageId: COMADMIN_E_PROPERTY_OVERFLOW
//
// MessageText:
//
// The property value is too large
//


//
// MessageId: COMADMIN_E_NOTINREGISTRY
//
// MessageText:
//
// Object was not found in registry
//


//
// MessageId: COMADMIN_E_OBJECTNOTPOOLABLE
//
// MessageText:
//
// This object is not poolable
//


//
// MessageId: COMADMIN_E_APPLID_MATCHES_CLSID
//
// MessageText:
//
// A CLSID with the same GUID as the new application ID is already installed on this machine
//


//
// MessageId: COMADMIN_E_ROLE_DOES_NOT_EXIST
//
// MessageText:
//
// A role assigned to a component, interface, or method did not exist in the application
//


//
// MessageId: COMADMIN_E_START_APP_NEEDS_COMPONENTS
//
// MessageText:
//
// You must have components in an application in order to start the application
//


//
// MessageId: COMADMIN_E_REQUIRES_DIFFERENT_PLATFORM
//
// MessageText:
//
// This operation is not enabled on this platform
//


//
// MessageId: COMADMIN_E_CAN_NOT_EXPORT_APP_PROXY
//
// MessageText:
//
// Application Proxy is not exportable
//


//
// MessageId: COMADMIN_E_CAN_NOT_START_APP
//
// MessageText:
//
// Failed to start application because it is either a library application or an application proxy
//


//
// MessageId: COMADMIN_E_CAN_NOT_EXPORT_SYS_APP
//
// MessageText:
//
// System application is not exportable
//


//
// MessageId: COMADMIN_E_CANT_SUBSCRIBE_TO_COMPONENT
//
// MessageText:
//
// Cannot subscribe to this component (the component may have been imported)
//


//
// MessageId: COMADMIN_E_EVENTCLASS_CANT_BE_SUBSCRIBER
//
// MessageText:
//
// An event class cannot also be a subscriber component
//


//
// MessageId: COMADMIN_E_LIB_APP_PROXY_INCOMPATIBLE
//
// MessageText:
//
// Library applications and application proxies are incompatible
//


//
// MessageId: COMADMIN_E_BASE_PARTITION_ONLY
//
// MessageText:
//
// This function is valid for the base partition only
//


//
// MessageId: COMADMIN_E_START_APP_DISABLED
//
// MessageText:
//
// You cannot start an application that has been disabled
//


//
// MessageId: COMADMIN_E_CAT_DUPLICATE_PARTITION_NAME
//
// MessageText:
//
// The specified partition name is already in use on this computer
//


//
// MessageId: COMADMIN_E_CAT_INVALID_PARTITION_NAME
//
// MessageText:
//
// The specified partition name is invalid. Check that the name contains at least one visible character
//


//
// MessageId: COMADMIN_E_CAT_PARTITION_IN_USE
//
// MessageText:
//
// The partition cannot be deleted because it is the default partition for one or more users
//


//
// MessageId: COMADMIN_E_FILE_PARTITION_DUPLICATE_FILES
//
// MessageText:
//
// The partition cannot be exported, because one or more components in the partition have the same file name
//


//
// MessageId: COMADMIN_E_CAT_IMPORTED_COMPONENTS_NOT_ALLOWED
//
// MessageText:
//
// Applications that contain one or more imported components cannot be installed into a non-base partition
//


//
// MessageId: COMADMIN_E_AMBIGUOUS_APPLICATION_NAME
//
// MessageText:
//
// The application name is not unique and cannot be resolved to an application id
//


//
// MessageId: COMADMIN_E_AMBIGUOUS_PARTITION_NAME
//
// MessageText:
//
// The partition name is not unique and cannot be resolved to a partition id
//


//
// MessageId: COMADMIN_E_REGDB_NOTINITIALIZED
//
// MessageText:
//
// The COM+ registry database has not been initialized
//


//
// MessageId: COMADMIN_E_REGDB_NOTOPEN
//
// MessageText:
//
// The COM+ registry database is not open
//


//
// MessageId: COMADMIN_E_REGDB_SYSTEMERR
//
// MessageText:
//
// The COM+ registry database detected a system error
//


//
// MessageId: COMADMIN_E_REGDB_ALREADYRUNNING
//
// MessageText:
//
// The COM+ registry database is already running
//


//
// MessageId: COMADMIN_E_MIG_VERSIONNOTSUPPORTED
//
// MessageText:
//
// This version of the COM+ registry database cannot be migrated
//


//
// MessageId: COMADMIN_E_MIG_SCHEMANOTFOUND
//
// MessageText:
//
// The schema version to be migrated could not be found in the COM+ registry database
//


//
// MessageId: COMADMIN_E_CAT_BITNESSMISMATCH
//
// MessageText:
//
// There was a type mismatch between binaries
//


//
// MessageId: COMADMIN_E_CAT_UNACCEPTABLEBITNESS
//
// MessageText:
//
// A binary of unknown or invalid type was provided
//


//
// MessageId: COMADMIN_E_CAT_WRONGAPPBITNESS
//
// MessageText:
//
// There was a type mismatch between a binary and an application
//


//
// MessageId: COMADMIN_E_CAT_PAUSE_RESUME_NOT_SUPPORTED
//
// MessageText:
//
// The application cannot be paused or resumed
//


//
// MessageId: COMADMIN_E_CAT_SERVERFAULT
//
// MessageText:
//
// The COM+ Catalog Server threw an exception during execution
//


//
// COMPLUS Queued component errors
//
//
// MessageId: COMQC_E_APPLICATION_NOT_QUEUED
//
// MessageText:
//
// Only COM+ Applications marked "queued" can be invoked using the "queue" moniker
//


//
// MessageId: COMQC_E_NO_QUEUEABLE_INTERFACES
//
// MessageText:
//
// At least one interface must be marked "queued" in order to create a queued component instance with the "queue" moniker
//


//
// MessageId: COMQC_E_QUEUING_SERVICE_NOT_AVAILABLE
//
// MessageText:
//
// MSMQ is required for the requested operation and is not installed
//


//
// MessageId: COMQC_E_NO_IPERSISTSTREAM
//
// MessageText:
//
// Unable to marshal an interface that does not support IPersistStream
//


//
// MessageId: COMQC_E_BAD_MESSAGE
//
// MessageText:
//
// The message is improperly formatted or was damaged in transit
//


//
// MessageId: COMQC_E_UNAUTHENTICATED
//
// MessageText:
//
// An unauthenticated message was received by an application that accepts only authenticated messages
//


//
// MessageId: COMQC_E_UNTRUSTED_ENQUEUER
//
// MessageText:
//
// The message was requeued or moved by a user not in the "QC Trusted User" role
//


//
// The range 0x700-0x7ff is reserved for MSDTC errors.
//
//
// MessageId: MSDTC_E_DUPLICATE_RESOURCE
//
// MessageText:
//
// Cannot create a duplicate resource of type Distributed Transaction Coordinator
//


//
// More COMADMIN errors from 0x8**
//
//
// MessageId: COMADMIN_E_OBJECT_PARENT_MISSING
//
// MessageText:
//
// One of the objects being inserted or updated does not belong to a valid parent collection
//


//
// MessageId: COMADMIN_E_OBJECT_DOES_NOT_EXIST
//
// MessageText:
//
// One of the specified objects cannot be found
//


//
// MessageId: COMADMIN_E_APP_NOT_RUNNING
//
// MessageText:
//
// The specified application is not currently running
//


//
// MessageId: COMADMIN_E_INVALID_PARTITION
//
// MessageText:
//
// The partition(s) specified are not valid.
//


//
// MessageId: COMADMIN_E_SVCAPP_NOT_POOLABLE_OR_RECYCLABLE
//
// MessageText:
//
// COM+ applications that run as NT service may not be pooled or recycled
//


//
// MessageId: COMADMIN_E_USER_IN_SET
//
// MessageText:
//
// One or more users are already assigned to a local partition set.
//


//
// MessageId: COMADMIN_E_CANTRECYCLELIBRARYAPPS
//
// MessageText:
//
// Library applications may not be recycled.
//


//
// MessageId: COMADMIN_E_CANTRECYCLESERVICEAPPS
//
// MessageText:
//
// Applications running as NT services may not be recycled.
//


//
// MessageId: COMADMIN_E_PROCESSALREADYRECYCLED
//
// MessageText:
//
// The process has already been recycled.
//


//
// MessageId: COMADMIN_E_PAUSEDPROCESSMAYNOTBERECYCLED
//
// MessageText:
//
// A paused process may not be recycled.
//


//
// MessageId: COMADMIN_E_CANTMAKEINPROCSERVICE
//
// MessageText:
//
// Library applications may not be NT services.
//


//
// MessageId: COMADMIN_E_PROGIDINUSEBYCLSID
//
// MessageText:
//
// The ProgID provided to the copy operation is invalid. The ProgID is in use by another registered CLSID.
//


//
// MessageId: COMADMIN_E_DEFAULT_PARTITION_NOT_IN_SET
//
// MessageText:
//
// The partition specified as default is not a member of the partition set.
//


//
// MessageId: COMADMIN_E_RECYCLEDPROCESSMAYNOTBEPAUSED
//
// MessageText:
//
// A recycled process may not be paused.
//


//
// MessageId: COMADMIN_E_PARTITION_ACCESSDENIED
//
// MessageText:
//
// Access to the specified partition is denied.
//


//
// MessageId: COMADMIN_E_PARTITION_MSI_ONLY
//
// MessageText:
//
// Only Application Files (*.MSI files) can be installed into partitions.
//


//
// MessageId: COMADMIN_E_LEGACYCOMPS_NOT_ALLOWED_IN_1_0_FORMAT
//
// MessageText:
//
// Applications containing one or more legacy components may not be exported to 1.0 format.
//


//
// MessageId: COMADMIN_E_LEGACYCOMPS_NOT_ALLOWED_IN_NONBASE_PARTITIONS
//
// MessageText:
//
// Legacy components may not exist in non-base partitions.
//


//
// MessageId: COMADMIN_E_COMP_MOVE_SOURCE
//
// MessageText:
//
// A component cannot be moved (or copied) from the System Application, an application proxy or a non-changeable application
//


//
// MessageId: COMADMIN_E_COMP_MOVE_DEST
//
// MessageText:
//
// A component cannot be moved (or copied) to the System Application, an application proxy or a non-changeable application
//


//
// MessageId: COMADMIN_E_COMP_MOVE_PRIVATE
//
// MessageText:
//
// A private component cannot be moved (or copied) to a library application or to the base partition
//


//
// MessageId: COMADMIN_E_BASEPARTITION_REQUIRED_IN_SET
//
// MessageText:
//
// The Base Application Partition exists in all partition sets and cannot be removed.
//


//
// MessageId: COMADMIN_E_CANNOT_ALIAS_EVENTCLASS
//
// MessageText:
//
// Alas, Event Class components cannot be aliased.
//


//
// MessageId: COMADMIN_E_PRIVATE_ACCESSDENIED
//
// MessageText:
//
// Access is denied because the component is private.
//


//
// MessageId: COMADMIN_E_SAFERINVALID
//
// MessageText:
//
// The specified SAFER level is invalid.
//


//
// MessageId: COMADMIN_E_REGISTRY_ACCESSDENIED
//
// MessageText:
//
// The specified user cannot write to the system registry
//


//
// MessageId: COMADMIN_E_PARTITIONS_DISABLED
//
// MessageText:
//
// COM+ partitions are currently disabled.
//


//
// FACILITY_WER
//
//
// MessageId: WER_S_REPORT_DEBUG
//
// MessageText:
//
// Debugger was attached.
//


//
// MessageId: WER_S_REPORT_UPLOADED
//
// MessageText:
//
// Report was uploaded.
//


//
// MessageId: WER_S_REPORT_QUEUED
//
// MessageText:
//
// Report was queued.
//


//
// MessageId: WER_S_DISABLED
//
// MessageText:
//
// Reporting was disabled.
//


//
// MessageId: WER_S_SUSPENDED_UPLOAD
//
// MessageText:
//
// Reporting was temporarily suspended.
//


//
// MessageId: WER_S_DISABLED_QUEUE
//
// MessageText:
//
// Report was not queued to queuing being disabled.
//


//
// MessageId: WER_S_DISABLED_ARCHIVE
//
// MessageText:
//
// Report was uploaded, but not archived due to archiving being disabled.
//


//
// MessageId: WER_S_REPORT_ASYNC
//
// MessageText:
//
// Reporting was successfully spun off as an asynchronous operation.
//


//
// MessageId: WER_S_IGNORE_ASSERT_INSTANCE
//
// MessageText:
//
// The assertion was handled.
//


//
// MessageId: WER_S_IGNORE_ALL_ASSERTS
//
// MessageText:
//
// The assertion was handled and added to a permanent ignore list.
//


//
// MessageId: WER_S_ASSERT_CONTINUE
//
// MessageText:
//
// The assertion was resumed as unhandled.
//


//
// MessageId: WER_S_THROTTLED
//
// MessageText:
//
// Report was throttled.
//


//
// MessageId: WER_S_REPORT_UPLOADED_CAB
//
// MessageText:
//
// Report was uploaded with cab.
//


//
// MessageId: WER_E_CRASH_FAILURE
//
// MessageText:
//
// Crash reporting failed.
//


//
// MessageId: WER_E_CANCELED
//
// MessageText:
//
// Report aborted due to user cancellation.
//


//
// MessageId: WER_E_NETWORK_FAILURE
//
// MessageText:
//
// Report aborted due to network failure.
//


//
// MessageId: WER_E_NOT_INITIALIZED
//
// MessageText:
//
// Report not initialized.
//


//
// MessageId: WER_E_ALREADY_REPORTING
//
// MessageText:
//
// Reporting is already in progress for the specified process.
//


//
// MessageId: WER_E_DUMP_THROTTLED
//
// MessageText:
//
// Dump not generated due to a throttle.
//


//
// MessageId: WER_E_INSUFFICIENT_CONSENT
//
// MessageText:
//
// Operation failed due to insufficient user consent.
//


//
// MessageId: WER_E_TOO_HEAVY
//
// MessageText:
//
// Report aborted due to performance criteria.
//


// ***********************
// FACILITY_USERMODE_FILTER_MANAGER
// ***********************
//
// Translation macro for converting FilterManager error codes only from:
//     NTSTATUS  --> HRESULT
//

//
// MessageId: ERROR_FLT_IO_COMPLETE
//
// MessageText:
//
// The IO was completed by a filter.
//


//
// MessageId: ERROR_FLT_NO_HANDLER_DEFINED
//
// MessageText:
//
// A handler was not defined by the filter for this operation.
//


//
// MessageId: ERROR_FLT_CONTEXT_ALREADY_DEFINED
//
// MessageText:
//
// A context is already defined for this object.
//


//
// MessageId: ERROR_FLT_INVALID_ASYNCHRONOUS_REQUEST
//
// MessageText:
//
// Asynchronous requests are not valid for this operation.
//


//
// MessageId: ERROR_FLT_DISALLOW_FAST_IO
//
// MessageText:
//
// Disallow the Fast IO path for this operation.
//


//
// MessageId: ERROR_FLT_INVALID_NAME_REQUEST
//
// MessageText:
//
// An invalid name request was made. The name requested cannot be retrieved at this time.
//


//
// MessageId: ERROR_FLT_NOT_SAFE_TO_POST_OPERATION
//
// MessageText:
//
// Posting this operation to a worker thread for further processing is not safe at this time because it could lead to a system deadlock.
//


//
// MessageId: ERROR_FLT_NOT_INITIALIZED
//
// MessageText:
//
// The Filter Manager was not initialized when a filter tried to register. Make sure that the Filter Manager is getting loaded as a driver.
//


//
// MessageId: ERROR_FLT_FILTER_NOT_READY
//
// MessageText:
//
// The filter is not ready for attachment to volumes because it has not finished initializing (FltStartFiltering has not been called).
//


//
// MessageId: ERROR_FLT_POST_OPERATION_CLEANUP
//
// MessageText:
//
// The filter must cleanup any operation specific context at this time because it is being removed from the system before the operation is completed by the lower drivers.
//


//
// MessageId: ERROR_FLT_INTERNAL_ERROR
//
// MessageText:
//
// The Filter Manager had an internal error from which it cannot recover, therefore the operation has been failed. This is usually the result of a filter returning an invalid value from a pre-operation callback.
//


//
// MessageId: ERROR_FLT_DELETING_OBJECT
//
// MessageText:
//
// The object specified for this action is in the process of being deleted, therefore the action requested cannot be completed at this time.
//


//
// MessageId: ERROR_FLT_MUST_BE_NONPAGED_POOL
//
// MessageText:
//
// Non-paged pool must be used for this type of context.
//


//
// MessageId: ERROR_FLT_DUPLICATE_ENTRY
//
// MessageText:
//
// A duplicate handler definition has been provided for an operation.
//


//
// MessageId: ERROR_FLT_CBDQ_DISABLED
//
// MessageText:
//
// The callback data queue has been disabled.
//


//
// MessageId: ERROR_FLT_DO_NOT_ATTACH
//
// MessageText:
//
// Do not attach the filter to the volume at this time.
//


//
// MessageId: ERROR_FLT_DO_NOT_DETACH
//
// MessageText:
//
// Do not detach the filter from the volume at this time.
//


//
// MessageId: ERROR_FLT_INSTANCE_ALTITUDE_COLLISION
//
// MessageText:
//
// An instance already exists at this altitude on the volume specified.
//


//
// MessageId: ERROR_FLT_INSTANCE_NAME_COLLISION
//
// MessageText:
//
// An instance already exists with this name on the volume specified.
//


//
// MessageId: ERROR_FLT_FILTER_NOT_FOUND
//
// MessageText:
//
// The system could not find the filter specified.
//


//
// MessageId: ERROR_FLT_VOLUME_NOT_FOUND
//
// MessageText:
//
// The system could not find the volume specified.
//


//
// MessageId: ERROR_FLT_INSTANCE_NOT_FOUND
//
// MessageText:
//
// The system could not find the instance specified.
//


//
// MessageId: ERROR_FLT_CONTEXT_ALLOCATION_NOT_FOUND
//
// MessageText:
//
// No registered context allocation definition was found for the given request.
//


//
// MessageId: ERROR_FLT_INVALID_CONTEXT_REGISTRATION
//
// MessageText:
//
// An invalid parameter was specified during context registration.
//


//
// MessageId: ERROR_FLT_NAME_CACHE_MISS
//
// MessageText:
//
// The name requested was not found in Filter Manager's name cache and could not be retrieved from the file system.
//


//
// MessageId: ERROR_FLT_NO_DEVICE_OBJECT
//
// MessageText:
//
// The requested device object does not exist for the given volume.
//


//
// MessageId: ERROR_FLT_VOLUME_ALREADY_MOUNTED
//
// MessageText:
//
// The specified volume is already mounted.
//


//
// MessageId: ERROR_FLT_ALREADY_ENLISTED
//
// MessageText:
//
// The specified Transaction Context is already enlisted in a transaction
//


//
// MessageId: ERROR_FLT_CONTEXT_ALREADY_LINKED
//
// MessageText:
//
// The specified context is already attached to another object
//


//
// MessageId: ERROR_FLT_NO_WAITER_FOR_REPLY
//
// MessageText:
//
// No waiter is present for the filter's reply to this message.
//


//
// MessageId: ERROR_FLT_REGISTRATION_BUSY
//
// MessageText:
//
// The filesystem database resource is in use. Registration cannot complete at this time.
//


//
// ===============================
// Facility Graphics Error Messages
// ===============================
//
//
// The following are the subranges within the Graphics facility
//
// 0x0000 - 0x0fff     Display Driver Loader driver & Video Port errors (displdr.sys, videoprt.sys)
// 0x1000 - 0x1fff     Monitor Class Function driver errors             (monitor.sys)
// 0x2000 - 0x2fff     Windows Graphics Kernel Subsystem errors         (dxgkrnl.sys)
// 0x3000 - 0x3fff               Desktop Window Manager errors
//   0x2000 - 0x20ff      Common errors
//   0x2100 - 0x21ff      Video Memory Manager (VidMM) subsystem errors
//   0x2200 - 0x22ff      Video GPU Scheduler (VidSch) subsystem errors
//   0x2300 - 0x23ff      Video Display Mode Management (VidDMM) subsystem errors
//
// Display Driver Loader driver & Video Port errors {0x0000..0x0fff}
//
//
// MessageId: ERROR_HUNG_DISPLAY_DRIVER_THREAD
//
// MessageText:
//
// {Display Driver Stopped Responding}
// The %hs display driver has stopped working normally. Save your work and reboot the system to restore full display functionality.
// The next time you reboot the machine a dialog will be displayed giving you a chance to report this failure to Microsoft.
//


//
// Desktop Window Manager errors {0x3000..0x3fff}
//
//
// MessageId: DWM_E_COMPOSITIONDISABLED
//
// MessageText:
//
// {Desktop composition is disabled}
// The operation could not be completed because desktop composition is disabled.
//


//
// MessageId: DWM_E_REMOTING_NOT_SUPPORTED
//
// MessageText:
//
// {Some desktop composition APIs are not supported while remoting}
// The operation is not supported while running in a remote session.
//


//
// MessageId: DWM_E_NO_REDIRECTION_SURFACE_AVAILABLE
//
// MessageText:
//
// {No DWM redirection surface is available}
// The DWM was unable to provide a redirection surface to complete the DirectX present.
//


//
// MessageId: DWM_E_NOT_QUEUING_PRESENTS
//
// MessageText:
//
// {DWM is not queuing presents for the specified window}
// The window specified is not currently using queued presents.
//


//
// MessageId: DWM_E_ADAPTER_NOT_FOUND
//
// MessageText:
//
// {The adapter specified by the LUID is not found}
// DWM can not find the adapter specified by the LUID.
//


//
// MessageId: DWM_S_GDI_REDIRECTION_SURFACE
//
// MessageText:
//
// {GDI redirection surface was returned}
// GDI redirection surface of the top level window was returned.
//


//
// MessageId: DWM_E_TEXTURE_TOO_LARGE
//
// MessageText:
//
// {Redirection surface can not be created.  The size of the surface is larger than what is supported on this machine}
// Redirection surface can not be created.  The size of the surface is larger than what is supported on this machine.
//


//
// MessageId: DWM_S_GDI_REDIRECTION_SURFACE_BLT_VIA_GDI
//
// MessageText:
//
// {GDI redirection surface is either on a different adapter or in system memory. Perform blt via GDI}
// GDI redirection surface is either on a different adapter or in system memory. Perform blt via GDI.
//


//
// Monitor class function driver errors {0x1000..0x1fff}
//
//
// MessageId: ERROR_MONITOR_NO_DESCRIPTOR
//
// MessageText:
//
// Monitor descriptor could not be obtained.
//


//
// MessageId: ERROR_MONITOR_UNKNOWN_DESCRIPTOR_FORMAT
//
// MessageText:
//
// Format of the obtained monitor descriptor is not supported by this release.
//


//
// MessageId: ERROR_MONITOR_INVALID_DESCRIPTOR_CHECKSUM
//
// MessageText:
//
// Checksum of the obtained monitor descriptor is invalid.
//


//
// MessageId: ERROR_MONITOR_INVALID_STANDARD_TIMING_BLOCK
//
// MessageText:
//
// Monitor descriptor contains an invalid standard timing block.
//


//
// MessageId: ERROR_MONITOR_WMI_DATABLOCK_REGISTRATION_FAILED
//
// MessageText:
//
// WMI data block registration failed for one of the MSMonitorClass WMI subclasses.
//


//
// MessageId: ERROR_MONITOR_INVALID_SERIAL_NUMBER_MONDSC_BLOCK
//
// MessageText:
//
// Provided monitor descriptor block is either corrupted or does not contain monitor's detailed serial number.
//


//
// MessageId: ERROR_MONITOR_INVALID_USER_FRIENDLY_MONDSC_BLOCK
//
// MessageText:
//
// Provided monitor descriptor block is either corrupted or does not contain monitor's user friendly name.
//


//
// MessageId: ERROR_MONITOR_NO_MORE_DESCRIPTOR_DATA
//
// MessageText:
//
// There is no monitor descriptor data at the specified (offset, size) region.
//


//
// MessageId: ERROR_MONITOR_INVALID_DETAILED_TIMING_BLOCK
//
// MessageText:
//
// Monitor descriptor contains an invalid detailed timing block.
//


//
// MessageId: ERROR_MONITOR_INVALID_MANUFACTURE_DATE
//
// MessageText:
//
// Monitor descriptor contains invalid manufacture date.
//


//
// Windows Graphics Kernel Subsystem errors {0x2000..0x2fff}
//
// TODO: Add DXG Win32 errors here
//
// Common errors {0x2000..0x20ff}
//
//
// MessageId: ERROR_GRAPHICS_NOT_EXCLUSIVE_MODE_OWNER
//
// MessageText:
//
// Exclusive mode ownership is needed to create unmanaged primary allocation.
//


//
// MessageId: ERROR_GRAPHICS_INSUFFICIENT_DMA_BUFFER
//
// MessageText:
//
// The driver needs more DMA buffer space in order to complete the requested operation.
//


//
// MessageId: ERROR_GRAPHICS_INVALID_DISPLAY_ADAPTER
//
// MessageText:
//
// Specified display adapter handle is invalid.
//


//
// MessageId: ERROR_GRAPHICS_ADAPTER_WAS_RESET
//
// MessageText:
//
// Specified display adapter and all of its state has been reset.
//


//
// MessageId: ERROR_GRAPHICS_INVALID_DRIVER_MODEL
//
// MessageText:
//
// The driver stack doesn't match the expected driver model.
//


//
// MessageId: ERROR_GRAPHICS_PRESENT_MODE_CHANGED
//
// MessageText:
//
// Present happened but ended up into the changed desktop mode
//


//
// MessageId: ERROR_GRAPHICS_PRESENT_OCCLUDED
//
// MessageText:
//
// Nothing to present due to desktop occlusion
//


//
// MessageId: ERROR_GRAPHICS_PRESENT_DENIED
//
// MessageText:
//
// Not able to present due to denial of desktop access
//


//
// MessageId: ERROR_GRAPHICS_CANNOTCOLORCONVERT
//
// MessageText:
//
// Not able to present with color conversion
//


//
// MessageId: ERROR_GRAPHICS_DRIVER_MISMATCH
//
// MessageText:
//
// The kernel driver detected a version mismatch between it and the user mode driver.
//


//
// MessageId: ERROR_GRAPHICS_PARTIAL_DATA_POPULATED
//
// MessageText:
//
// Specified buffer is not big enough to contain entire requested dataset. Partial data populated up to the size of the buffer. Caller needs to provide buffer of size as specified in the partially populated buffer's content (interface specific).
//


//
// MessageId: ERROR_GRAPHICS_PRESENT_REDIRECTION_DISABLED
//
// MessageText:
//
// Present redirection is disabled (desktop windowing management subsystem is off).
//


//
// MessageId: ERROR_GRAPHICS_PRESENT_UNOCCLUDED
//
// MessageText:
//
// Previous exclusive VidPn source owner has released its ownership
//


//
// MessageId: ERROR_GRAPHICS_WINDOWDC_NOT_AVAILABLE
//
// MessageText:
//
// Window DC is not available for presentation
//


//
// MessageId: ERROR_GRAPHICS_WINDOWLESS_PRESENT_DISABLED
//
// MessageText:
//
// Windowless present is disabled (desktop windowing management subsystem is off).
//


//
// MessageId: ERROR_GRAPHICS_PRESENT_INVALID_WINDOW
//
// MessageText:
//
// Window handle is invalid
//


//
// MessageId: ERROR_GRAPHICS_PRESENT_BUFFER_NOT_BOUND
//
// MessageText:
//
// No buffer is bound to composition surface
//


//
// MessageId: ERROR_GRAPHICS_VAIL_STATE_CHANGED
//
// MessageText:
//
// Vail state has been changed
//


//
// MessageId: ERROR_GRAPHICS_INDIRECT_DISPLAY_ABANDON_SWAPCHAIN
//
// MessageText:
//
// Notifying indirect display UMDF class driver to abandon current swapchain.
//


//
// MessageId: ERROR_GRAPHICS_INDIRECT_DISPLAY_DEVICE_STOPPED
//
// MessageText:
//
// Notifying indirect display UMDF class driver that indirect display device has been stopped.
//


//
// Video Memory Manager (VidMM) subsystem errors {0x2100..0x21ff}
//
//
// MessageId: ERROR_GRAPHICS_NO_VIDEO_MEMORY
//
// MessageText:
//
// Not enough video memory available to complete the operation.
//


//
// MessageId: ERROR_GRAPHICS_CANT_LOCK_MEMORY
//
// MessageText:
//
// Couldn't probe and lock the underlying memory of an allocation.
//


//
// MessageId: ERROR_GRAPHICS_ALLOCATION_BUSY
//
// MessageText:
//
// The allocation is currently busy.
//


//
// MessageId: ERROR_GRAPHICS_TOO_MANY_REFERENCES
//
// MessageText:
//
// An object being referenced has reach the maximum reference count already and can't be reference further.
//


//
// MessageId: ERROR_GRAPHICS_TRY_AGAIN_LATER
//
// MessageText:
//
// A problem couldn't be solved due to some currently existing condition. The problem should be tried again later.
//


//
// MessageId: ERROR_GRAPHICS_TRY_AGAIN_NOW
//
// MessageText:
//
// A problem couldn't be solved due to some currently existing condition. The problem should be tried again immediately.
//


//
// MessageId: ERROR_GRAPHICS_ALLOCATION_INVALID
//
// MessageText:
//
// The allocation is invalid.
//


//
// MessageId: ERROR_GRAPHICS_UNSWIZZLING_APERTURE_UNAVAILABLE
//
// MessageText:
//
// No more unswizzling aperture are currently available.
//


//
// MessageId: ERROR_GRAPHICS_UNSWIZZLING_APERTURE_UNSUPPORTED
//
// MessageText:
//
// The current allocation can't be unswizzled by an aperture.
//


//
// MessageId: ERROR_GRAPHICS_CANT_EVICT_PINNED_ALLOCATION
//
// MessageText:
//
// The request failed because a pinned allocation can't be evicted.
//


//
// MessageId: ERROR_GRAPHICS_INVALID_ALLOCATION_USAGE
//
// MessageText:
//
// The allocation can't be used from its current segment location for the specified operation.
//


//
// MessageId: ERROR_GRAPHICS_CANT_RENDER_LOCKED_ALLOCATION
//
// MessageText:
//
// A locked allocation can't be used in the current command buffer.
//


//
// MessageId: ERROR_GRAPHICS_ALLOCATION_CLOSED
//
// MessageText:
//
// The allocation being referenced has been closed permanently.
//


//
// MessageId: ERROR_GRAPHICS_INVALID_ALLOCATION_INSTANCE
//
// MessageText:
//
// An invalid allocation instance is being referenced.
//


//
// MessageId: ERROR_GRAPHICS_INVALID_ALLOCATION_HANDLE
//
// MessageText:
//
// An invalid allocation handle is being referenced.
//


//
// MessageId: ERROR_GRAPHICS_WRONG_ALLOCATION_DEVICE
//
// MessageText:
//
// The allocation being referenced doesn't belong to the current device.
//


//
// MessageId: ERROR_GRAPHICS_ALLOCATION_CONTENT_LOST
//
// MessageText:
//
// The specified allocation lost its content.
//


//
// Video GPU Scheduler (VidSch) subsystem errors {0x2200..0x22ff}
//
//
// MessageId: ERROR_GRAPHICS_GPU_EXCEPTION_ON_DEVICE
//
// MessageText:
//
// GPU exception is detected on the given device. The device is not able to be scheduled.
//


//
// MessageId: ERROR_GRAPHICS_SKIP_ALLOCATION_PREPARATION
//
// MessageText:
//
// Skip preparation of allocations referenced by the DMA buffer.
//


//
// Video Present Network Management (VidPNMgr) subsystem errors {0x2300..0x23ff}
//
//
// MessageId: ERROR_GRAPHICS_INVALID_VIDPN_TOPOLOGY
//
// MessageText:
//
// Specified VidPN topology is invalid.
//


//
// MessageId: ERROR_GRAPHICS_VIDPN_TOPOLOGY_NOT_SUPPORTED
//
// MessageText:
//
// Specified VidPN topology is valid but is not supported by this model of the display adapter.
//


//
// MessageId: ERROR_GRAPHICS_VIDPN_TOPOLOGY_CURRENTLY_NOT_SUPPORTED
//
// MessageText:
//
// Specified VidPN topology is valid but is not supported by the display adapter at this time, due to current allocation of its resources.
//


//
// MessageId: ERROR_GRAPHICS_INVALID_VIDPN
//
// MessageText:
//
// Specified VidPN handle is invalid.
//


//
// MessageId: ERROR_GRAPHICS_INVALID_VIDEO_PRESENT_SOURCE
//
// MessageText:
//
// Specified video present source is invalid.
//


//
// MessageId: ERROR_GRAPHICS_INVALID_VIDEO_PRESENT_TARGET
//
// MessageText:
//
// Specified video present target is invalid.
//


//
// MessageId: ERROR_GRAPHICS_VIDPN_MODALITY_NOT_SUPPORTED
//
// MessageText:
//
// Specified VidPN modality is not supported (e.g. at least two of the pinned modes are not cofunctional).
//


//
// MessageId: ERROR_GRAPHICS_MODE_NOT_PINNED
//
// MessageText:
//
// No mode is pinned on the specified VidPN source/target.
//


//
// MessageId: ERROR_GRAPHICS_INVALID_VIDPN_SOURCEMODESET
//
// MessageText:
//
// Specified VidPN source mode set is invalid.
//


//
// MessageId: ERROR_GRAPHICS_INVALID_VIDPN_TARGETMODESET
//
// MessageText:
//
// Specified VidPN target mode set is invalid.
//


//
// MessageId: ERROR_GRAPHICS_INVALID_FREQUENCY
//
// MessageText:
//
// Specified video signal frequency is invalid.
//


//
// MessageId: ERROR_GRAPHICS_INVALID_ACTIVE_REGION
//
// MessageText:
//
// Specified video signal active region is invalid.
//


//
// MessageId: ERROR_GRAPHICS_INVALID_TOTAL_REGION
//
// MessageText:
//
// Specified video signal total region is invalid.
//


//
// MessageId: ERROR_GRAPHICS_INVALID_VIDEO_PRESENT_SOURCE_MODE
//
// MessageText:
//
// Specified video present source mode is invalid.
//


//
// MessageId: ERROR_GRAPHICS_INVALID_VIDEO_PRESENT_TARGET_MODE
//
// MessageText:
//
// Specified video present target mode is invalid.
//


//
// MessageId: ERROR_GRAPHICS_PINNED_MODE_MUST_REMAIN_IN_SET
//
// MessageText:
//
// Pinned mode must remain in the set on VidPN's cofunctional modality enumeration.
//


//
// MessageId: ERROR_GRAPHICS_PATH_ALREADY_IN_TOPOLOGY
//
// MessageText:
//
// Specified video present path is already in VidPN's topology.
//


//
// MessageId: ERROR_GRAPHICS_MODE_ALREADY_IN_MODESET
//
// MessageText:
//
// Specified mode is already in the mode set.
//


//
// MessageId: ERROR_GRAPHICS_INVALID_VIDEOPRESENTSOURCESET
//
// MessageText:
//
// Specified video present source set is invalid.
//


//
// MessageId: ERROR_GRAPHICS_INVALID_VIDEOPRESENTTARGETSET
//
// MessageText:
//
// Specified video present target set is invalid.
//


//
// MessageId: ERROR_GRAPHICS_SOURCE_ALREADY_IN_SET
//
// MessageText:
//
// Specified video present source is already in the video present source set.
//


//
// MessageId: ERROR_GRAPHICS_TARGET_ALREADY_IN_SET
//
// MessageText:
//
// Specified video present target is already in the video present target set.
//


//
// MessageId: ERROR_GRAPHICS_INVALID_VIDPN_PRESENT_PATH
//
// MessageText:
//
// Specified VidPN present path is invalid.
//


//
// MessageId: ERROR_GRAPHICS_NO_RECOMMENDED_VIDPN_TOPOLOGY
//
// MessageText:
//
// Miniport has no recommendation for augmentation of the specified VidPN's topology.
//


//
// MessageId: ERROR_GRAPHICS_INVALID_MONITOR_FREQUENCYRANGESET
//
// MessageText:
//
// Specified monitor frequency range set is invalid.
//


//
// MessageId: ERROR_GRAPHICS_INVALID_MONITOR_FREQUENCYRANGE
//
// MessageText:
//
// Specified monitor frequency range is invalid.
//


//
// MessageId: ERROR_GRAPHICS_FREQUENCYRANGE_NOT_IN_SET
//
// MessageText:
//
// Specified frequency range is not in the specified monitor frequency range set.
//


//
// MessageId: ERROR_GRAPHICS_NO_PREFERRED_MODE
//
// MessageText:
//
// Specified mode set does not specify preference for one of its modes.
//


//
// MessageId: ERROR_GRAPHICS_FREQUENCYRANGE_ALREADY_IN_SET
//
// MessageText:
//
// Specified frequency range is already in the specified monitor frequency range set.
//


//
// MessageId: ERROR_GRAPHICS_STALE_MODESET
//
// MessageText:
//
// Specified mode set is stale. Please reacquire the new mode set.
//


//
// MessageId: ERROR_GRAPHICS_INVALID_MONITOR_SOURCEMODESET
//
// MessageText:
//
// Specified monitor source mode set is invalid.
//


//
// MessageId: ERROR_GRAPHICS_INVALID_MONITOR_SOURCE_MODE
//
// MessageText:
//
// Specified monitor source mode is invalid.
//


//
// MessageId: ERROR_GRAPHICS_NO_RECOMMENDED_FUNCTIONAL_VIDPN
//
// MessageText:
//
// Miniport does not have any recommendation regarding the request to provide a functional VidPN given the current display adapter configuration.
//


//
// MessageId: ERROR_GRAPHICS_MODE_ID_MUST_BE_UNIQUE
//
// MessageText:
//
// ID of the specified mode is already used by another mode in the set.
//


//
// MessageId: ERROR_GRAPHICS_EMPTY_ADAPTER_MONITOR_MODE_SUPPORT_INTERSECTION
//
// MessageText:
//
// System failed to determine a mode that is supported by both the display adapter and the monitor connected to it.
//


//
// MessageId: ERROR_GRAPHICS_VIDEO_PRESENT_TARGETS_LESS_THAN_SOURCES
//
// MessageText:
//
// Number of video present targets must be greater than or equal to the number of video present sources.
//


//
// MessageId: ERROR_GRAPHICS_PATH_NOT_IN_TOPOLOGY
//
// MessageText:
//
// Specified present path is not in VidPN's topology.
//


//
// MessageId: ERROR_GRAPHICS_ADAPTER_MUST_HAVE_AT_LEAST_ONE_SOURCE
//
// MessageText:
//
// Display adapter must have at least one video present source.
//


//
// MessageId: ERROR_GRAPHICS_ADAPTER_MUST_HAVE_AT_LEAST_ONE_TARGET
//
// MessageText:
//
// Display adapter must have at least one video present target.
//


//
// MessageId: ERROR_GRAPHICS_INVALID_MONITORDESCRIPTORSET
//
// MessageText:
//
// Specified monitor descriptor set is invalid.
//


//
// MessageId: ERROR_GRAPHICS_INVALID_MONITORDESCRIPTOR
//
// MessageText:
//
// Specified monitor descriptor is invalid.
//


//
// MessageId: ERROR_GRAPHICS_MONITORDESCRIPTOR_NOT_IN_SET
//
// MessageText:
//
// Specified descriptor is not in the specified monitor descriptor set.
//


//
// MessageId: ERROR_GRAPHICS_MONITORDESCRIPTOR_ALREADY_IN_SET
//
// MessageText:
//
// Specified descriptor is already in the specified monitor descriptor set.
//


//
// MessageId: ERROR_GRAPHICS_MONITORDESCRIPTOR_ID_MUST_BE_UNIQUE
//
// MessageText:
//
// ID of the specified monitor descriptor is already used by another descriptor in the set.
//


//
// MessageId: ERROR_GRAPHICS_INVALID_VIDPN_TARGET_SUBSET_TYPE
//
// MessageText:
//
// Specified video present target subset type is invalid.
//


//
// MessageId: ERROR_GRAPHICS_RESOURCES_NOT_RELATED
//
// MessageText:
//
// Two or more of the specified resources are not related to each other, as defined by the interface semantics.
//


//
// MessageId: ERROR_GRAPHICS_SOURCE_ID_MUST_BE_UNIQUE
//
// MessageText:
//
// ID of the specified video present source is already used by another source in the set.
//


//
// MessageId: ERROR_GRAPHICS_TARGET_ID_MUST_BE_UNIQUE
//
// MessageText:
//
// ID of the specified video present target is already used by another target in the set.
//


//
// MessageId: ERROR_GRAPHICS_NO_AVAILABLE_VIDPN_TARGET
//
// MessageText:
//
// Specified VidPN source cannot be used because there is no available VidPN target to connect it to.
//


//
// MessageId: ERROR_GRAPHICS_MONITOR_COULD_NOT_BE_ASSOCIATED_WITH_ADAPTER
//
// MessageText:
//
// Newly arrived monitor could not be associated with a display adapter.
//


//
// MessageId: ERROR_GRAPHICS_NO_VIDPNMGR
//
// MessageText:
//
// Display adapter in question does not have an associated VidPN manager.
//


//
// MessageId: ERROR_GRAPHICS_NO_ACTIVE_VIDPN
//
// MessageText:
//
// VidPN manager of the display adapter in question does not have an active VidPN.
//


//
// MessageId: ERROR_GRAPHICS_STALE_VIDPN_TOPOLOGY
//
// MessageText:
//
// Specified VidPN topology is stale. Please reacquire the new topology.
//


//
// MessageId: ERROR_GRAPHICS_MONITOR_NOT_CONNECTED
//
// MessageText:
//
// There is no monitor connected on the specified video present target.
//


//
// MessageId: ERROR_GRAPHICS_SOURCE_NOT_IN_TOPOLOGY
//
// MessageText:
//
// Specified source is not part of the specified VidPN's topology.
//


//
// MessageId: ERROR_GRAPHICS_INVALID_PRIMARYSURFACE_SIZE
//
// MessageText:
//
// Specified primary surface size is invalid.
//


//
// MessageId: ERROR_GRAPHICS_INVALID_VISIBLEREGION_SIZE
//
// MessageText:
//
// Specified visible region size is invalid.
//


//
// MessageId: ERROR_GRAPHICS_INVALID_STRIDE
//
// MessageText:
//
// Specified stride is invalid.
//


//
// MessageId: ERROR_GRAPHICS_INVALID_PIXELFORMAT
//
// MessageText:
//
// Specified pixel format is invalid.
//


//
// MessageId: ERROR_GRAPHICS_INVALID_COLORBASIS
//
// MessageText:
//
// Specified color basis is invalid.
//


//
// MessageId: ERROR_GRAPHICS_INVALID_PIXELVALUEACCESSMODE
//
// MessageText:
//
// Specified pixel value access mode is invalid.
//


//
// MessageId: ERROR_GRAPHICS_TARGET_NOT_IN_TOPOLOGY
//
// MessageText:
//
// Specified target is not part of the specified VidPN's topology.
//


//
// MessageId: ERROR_GRAPHICS_NO_DISPLAY_MODE_MANAGEMENT_SUPPORT
//
// MessageText:
//
// Failed to acquire display mode management interface.
//


//
// MessageId: ERROR_GRAPHICS_VIDPN_SOURCE_IN_USE
//
// MessageText:
//
// Specified VidPN source is already owned by a DMM client and cannot be used until that client releases it.
//


//
// MessageId: ERROR_GRAPHICS_CANT_ACCESS_ACTIVE_VIDPN
//
// MessageText:
//
// Specified VidPN is active and cannot be accessed.
//


//
// MessageId: ERROR_GRAPHICS_INVALID_PATH_IMPORTANCE_ORDINAL
//
// MessageText:
//
// Specified VidPN present path importance ordinal is invalid.
//


//
// MessageId: ERROR_GRAPHICS_INVALID_PATH_CONTENT_GEOMETRY_TRANSFORMATION
//
// MessageText:
//
// Specified VidPN present path content geometry transformation is invalid.
//


//
// MessageId: ERROR_GRAPHICS_PATH_CONTENT_GEOMETRY_TRANSFORMATION_NOT_SUPPORTED
//
// MessageText:
//
// Specified content geometry transformation is not supported on the respective VidPN present path.
//


//
// MessageId: ERROR_GRAPHICS_INVALID_GAMMA_RAMP
//
// MessageText:
//
// Specified gamma ramp is invalid.
//


//
// MessageId: ERROR_GRAPHICS_GAMMA_RAMP_NOT_SUPPORTED
//
// MessageText:
//
// Specified gamma ramp is not supported on the respective VidPN present path.
//


//
// MessageId: ERROR_GRAPHICS_MULTISAMPLING_NOT_SUPPORTED
//
// MessageText:
//
// Multi-sampling is not supported on the respective VidPN present path.
//


//
// MessageId: ERROR_GRAPHICS_MODE_NOT_IN_MODESET
//
// MessageText:
//
// Specified mode is not in the specified mode set.
//


//
// MessageId: ERROR_GRAPHICS_DATASET_IS_EMPTY
//
// MessageText:
//
// Specified data set (e.g. mode set, frequency range set, descriptor set, topology, etc.) is empty.
//


//
// MessageId: ERROR_GRAPHICS_NO_MORE_ELEMENTS_IN_DATASET
//
// MessageText:
//
// Specified data set (e.g. mode set, frequency range set, descriptor set, topology, etc.) does not contain any more elements.
//


//
// MessageId: ERROR_GRAPHICS_INVALID_VIDPN_TOPOLOGY_RECOMMENDATION_REASON
//
// MessageText:
//
// Specified VidPN topology recommendation reason is invalid.
//


//
// MessageId: ERROR_GRAPHICS_INVALID_PATH_CONTENT_TYPE
//
// MessageText:
//
// Specified VidPN present path content type is invalid.
//


//
// MessageId: ERROR_GRAPHICS_INVALID_COPYPROTECTION_TYPE
//
// MessageText:
//
// Specified VidPN present path copy protection type is invalid.
//


//
// MessageId: ERROR_GRAPHICS_UNASSIGNED_MODESET_ALREADY_EXISTS
//
// MessageText:
//
// No more than one unassigned mode set can exist at any given time for a given VidPN source/target.
//


//
// MessageId: ERROR_GRAPHICS_PATH_CONTENT_GEOMETRY_TRANSFORMATION_NOT_PINNED
//
// MessageText:
//
// Specified content transformation is not pinned on the specified VidPN present path.
//


//
// MessageId: ERROR_GRAPHICS_INVALID_SCANLINE_ORDERING
//
// MessageText:
//
// Specified scanline ordering type is invalid.
//


//
// MessageId: ERROR_GRAPHICS_TOPOLOGY_CHANGES_NOT_ALLOWED
//
// MessageText:
//
// Topology changes are not allowed for the specified VidPN.
//


//
// MessageId: ERROR_GRAPHICS_NO_AVAILABLE_IMPORTANCE_ORDINALS
//
// MessageText:
//
// All available importance ordinals are already used in specified topology.
//


//
// MessageId: ERROR_GRAPHICS_INCOMPATIBLE_PRIVATE_FORMAT
//
// MessageText:
//
// Specified primary surface has a different private format attribute than the current primary surface
//


//
// MessageId: ERROR_GRAPHICS_INVALID_MODE_PRUNING_ALGORITHM
//
// MessageText:
//
// Specified mode pruning algorithm is invalid
//


//
// MessageId: ERROR_GRAPHICS_INVALID_MONITOR_CAPABILITY_ORIGIN
//
// MessageText:
//
// Specified monitor capability origin is invalid.
//


//
// MessageId: ERROR_GRAPHICS_INVALID_MONITOR_FREQUENCYRANGE_CONSTRAINT
//
// MessageText:
//
// Specified monitor frequency range constraint is invalid.
//


//
// MessageId: ERROR_GRAPHICS_MAX_NUM_PATHS_REACHED
//
// MessageText:
//
// Maximum supported number of present paths has been reached.
//


//
// MessageId: ERROR_GRAPHICS_CANCEL_VIDPN_TOPOLOGY_AUGMENTATION
//
// MessageText:
//
// Miniport requested that augmentation be cancelled for the specified source of the specified VidPN's topology.
//


//
// MessageId: ERROR_GRAPHICS_INVALID_CLIENT_TYPE
//
// MessageText:
//
// Specified client type was not recognized.
//


//
// MessageId: ERROR_GRAPHICS_CLIENTVIDPN_NOT_SET
//
// MessageText:
//
// Client VidPN is not set on this adapter (e.g. no user mode initiated mode changes took place on this adapter yet).
//


//
// Port specific status codes {0x2400..0x24ff}
//
//
// MessageId: ERROR_GRAPHICS_SPECIFIED_CHILD_ALREADY_CONNECTED
//
// MessageText:
//
// Specified display adapter child device already has an external device connected to it.
//


//
// MessageId: ERROR_GRAPHICS_CHILD_DESCRIPTOR_NOT_SUPPORTED
//
// MessageText:
//
// Specified display adapter child device does not support descriptor exposure.
//


//
// MessageId: ERROR_GRAPHICS_UNKNOWN_CHILD_STATUS
//
// MessageText:
//
// Child device presence was not reliably detected.
//


//
// MessageId: ERROR_GRAPHICS_NOT_A_LINKED_ADAPTER
//
// MessageText:
//
// The display adapter is not linked to any other adapters.
//


//
// MessageId: ERROR_GRAPHICS_LEADLINK_NOT_ENUMERATED
//
// MessageText:
//
// Lead adapter in a linked configuration was not enumerated yet.
//


//
// MessageId: ERROR_GRAPHICS_CHAINLINKS_NOT_ENUMERATED
//
// MessageText:
//
// Some chain adapters in a linked configuration were not enumerated yet.
//


//
// MessageId: ERROR_GRAPHICS_ADAPTER_CHAIN_NOT_READY
//
// MessageText:
//
// The chain of linked adapters is not ready to start because of an unknown failure.
//


//
// MessageId: ERROR_GRAPHICS_CHAINLINKS_NOT_STARTED
//
// MessageText:
//
// An attempt was made to start a lead link display adapter when the chain links were not started yet.
//


//
// MessageId: ERROR_GRAPHICS_CHAINLINKS_NOT_POWERED_ON
//
// MessageText:
//
// An attempt was made to power up a lead link display adapter when the chain links were powered down.
//


//
// MessageId: ERROR_GRAPHICS_INCONSISTENT_DEVICE_LINK_STATE
//
// MessageText:
//
// The adapter link was found to be in an inconsistent state. Not all adapters are in an expected PNP/Power state.
//


//
// MessageId: ERROR_GRAPHICS_LEADLINK_START_DEFERRED
//
// MessageText:
//
// Starting the leadlink adapter has been deferred temporarily.
//


//
// MessageId: ERROR_GRAPHICS_NOT_POST_DEVICE_DRIVER
//
// MessageText:
//
// The driver trying to start is not the same as the driver for the POSTed display adapter.
//


//
// MessageId: ERROR_GRAPHICS_POLLING_TOO_FREQUENTLY
//
// MessageText:
//
// The display adapter is being polled for children too frequently at the same polling level.
//


//
// MessageId: ERROR_GRAPHICS_START_DEFERRED
//
// MessageText:
//
// Starting the adapter has been deferred temporarily.
//


//
// MessageId: ERROR_GRAPHICS_ADAPTER_ACCESS_NOT_EXCLUDED
//
// MessageText:
//
// An operation is being attempted that requires the display adapter to be in a quiescent state.
//


//
// MessageId: ERROR_GRAPHICS_DEPENDABLE_CHILD_STATUS
//
// MessageText:
//
// We can depend on the child device presence returned by the driver.
//


//
// OPM, UAB and PVP specific error codes {0x2500..0x257f}
//
//
// MessageId: ERROR_GRAPHICS_OPM_NOT_SUPPORTED
//
// MessageText:
//
// The driver does not support OPM.
//


//
// MessageId: ERROR_GRAPHICS_COPP_NOT_SUPPORTED
//
// MessageText:
//
// The driver does not support COPP.
//


//
// MessageId: ERROR_GRAPHICS_UAB_NOT_SUPPORTED
//
// MessageText:
//
// The driver does not support UAB.
//


//
// MessageId: ERROR_GRAPHICS_OPM_INVALID_ENCRYPTED_PARAMETERS
//
// MessageText:
//
// The specified encrypted parameters are invalid.
//


//
// MessageId: ERROR_GRAPHICS_OPM_NO_VIDEO_OUTPUTS_EXIST
//
// MessageText:
//
// The GDI display device passed to this function does not have any active video outputs.
//


//
// MessageId: ERROR_GRAPHICS_OPM_INTERNAL_ERROR
//
// MessageText:
//
// An internal error caused this operation to fail.
//


//
// MessageId: ERROR_GRAPHICS_OPM_INVALID_HANDLE
//
// MessageText:
//
// The function failed because the caller passed in an invalid OPM user mode handle.
//


//
// MessageId: ERROR_GRAPHICS_PVP_INVALID_CERTIFICATE_LENGTH
//
// MessageText:
//
// A certificate could not be returned because the certificate buffer passed to the function was too small.
//


//
// MessageId: ERROR_GRAPHICS_OPM_SPANNING_MODE_ENABLED
//
// MessageText:
//
// A video output could not be created because the frame buffer is in spanning mode.
//


//
// MessageId: ERROR_GRAPHICS_OPM_THEATER_MODE_ENABLED
//
// MessageText:
//
// A video output could not be created because the frame buffer is in theater mode.
//


//
// MessageId: ERROR_GRAPHICS_PVP_HFS_FAILED
//
// MessageText:
//
// The function failed because the display adapter's Hardware Functionality Scan failed to validate the graphics hardware.
//


//
// MessageId: ERROR_GRAPHICS_OPM_INVALID_SRM
//
// MessageText:
//
// The HDCP System Renewability Message passed to this function did not comply with section 5 of the HDCP 1.1 specification.
//


//
// MessageId: ERROR_GRAPHICS_OPM_OUTPUT_DOES_NOT_SUPPORT_HDCP
//
// MessageText:
//
// The video output cannot enable the High-bandwidth Digital Content Protection (HDCP) System because it does not support HDCP.
//


//
// MessageId: ERROR_GRAPHICS_OPM_OUTPUT_DOES_NOT_SUPPORT_ACP
//
// MessageText:
//
// The video output cannot enable Analogue Copy Protection (ACP) because it does not support ACP.
//


//
// MessageId: ERROR_GRAPHICS_OPM_OUTPUT_DOES_NOT_SUPPORT_CGMSA
//
// MessageText:
//
// The video output cannot enable the Content Generation Management System Analogue (CGMS-A) protection technology because it does not support CGMS-A.
//


//
// MessageId: ERROR_GRAPHICS_OPM_HDCP_SRM_NEVER_SET
//
// MessageText:
//
// The IOPMVideoOutput::GetInformation method cannot return the version of the SRM being used because the application never successfully passed an SRM to the video output.
//


//
// MessageId: ERROR_GRAPHICS_OPM_RESOLUTION_TOO_HIGH
//
// MessageText:
//
// The IOPMVideoOutput::Configure method cannot enable the specified output protection technology because the output's screen resolution is too high.
//


//
// MessageId: ERROR_GRAPHICS_OPM_ALL_HDCP_HARDWARE_ALREADY_IN_USE
//
// MessageText:
//
// The IOPMVideoOutput::Configure method cannot enable HDCP because the display adapter's HDCP hardware is already being used by other physical outputs.
//


//
// MessageId: ERROR_GRAPHICS_OPM_VIDEO_OUTPUT_NO_LONGER_EXISTS
//
// MessageText:
//
// The operating system asynchronously destroyed this OPM video output because the operating system's state changed. This error typically occurs because the monitor PDO associated with this video output was removed, the monitor PDO associated with this video output was stopped, the video output's session became a non-console session or the video output's desktop became an inactive desktop.
//


//
// MessageId: ERROR_GRAPHICS_OPM_SESSION_TYPE_CHANGE_IN_PROGRESS
//
// MessageText:
//
// The method failed because the session is changing its type. No IOPMVideoOutput methods can be called when a session is changing its type. There are currently three types of sessions: console, disconnected and remote.
//


//
// MessageId: ERROR_GRAPHICS_OPM_VIDEO_OUTPUT_DOES_NOT_HAVE_COPP_SEMANTICS
//
// MessageText:
//
// Either the IOPMVideoOutput::COPPCompatibleGetInformation, IOPMVideoOutput::GetInformation, or IOPMVideoOutput::Configure method failed. This error is returned when the caller tries to use a COPP specific command while the video output has OPM semantics only.
//


//
// MessageId: ERROR_GRAPHICS_OPM_INVALID_INFORMATION_REQUEST
//
// MessageText:
//
// The IOPMVideoOutput::GetInformation and IOPMVideoOutput::COPPCompatibleGetInformation methods return this error if the passed in sequence number is not the expected sequence number or the passed in OMAC value is invalid.
//


//
// MessageId: ERROR_GRAPHICS_OPM_DRIVER_INTERNAL_ERROR
//
// MessageText:
//
// The method failed because an unexpected error occurred inside of a display driver.
//


//
// MessageId: ERROR_GRAPHICS_OPM_VIDEO_OUTPUT_DOES_NOT_HAVE_OPM_SEMANTICS
//
// MessageText:
//
// Either the IOPMVideoOutput::COPPCompatibleGetInformation, IOPMVideoOutput::GetInformation, or IOPMVideoOutput::Configure method failed. This error is returned when the caller tries to use an OPM specific command while the video output has COPP semantics only.
//


//
// MessageId: ERROR_GRAPHICS_OPM_SIGNALING_NOT_SUPPORTED
//
// MessageText:
//
// The IOPMVideoOutput::COPPCompatibleGetInformation or IOPMVideoOutput::Configure method failed because the display driver does not support the OPM_GET_ACP_AND_CGMSA_SIGNALING and OPM_SET_ACP_AND_CGMSA_SIGNALING GUIDs.
//


//
// MessageId: ERROR_GRAPHICS_OPM_INVALID_CONFIGURATION_REQUEST
//
// MessageText:
//
// The IOPMVideoOutput::Configure function returns this error code if the passed in sequence number is not the expected sequence number or the passed in OMAC value is invalid.
//


//
// Monitor Configuration API error codes {0x2580..0x25DF}
//
//
// MessageId: ERROR_GRAPHICS_I2C_NOT_SUPPORTED
//
// MessageText:
//
// The monitor connected to the specified video output does not have an I2C bus.
//


//
// MessageId: ERROR_GRAPHICS_I2C_DEVICE_DOES_NOT_EXIST
//
// MessageText:
//
// No device on the I2C bus has the specified address.
//


//
// MessageId: ERROR_GRAPHICS_I2C_ERROR_TRANSMITTING_DATA
//
// MessageText:
//
// An error occurred while transmitting data to the device on the I2C bus.
//


//
// MessageId: ERROR_GRAPHICS_I2C_ERROR_RECEIVING_DATA
//
// MessageText:
//
// An error occurred while receiving data from the device on the I2C bus.
//


//
// MessageId: ERROR_GRAPHICS_DDCCI_VCP_NOT_SUPPORTED
//
// MessageText:
//
// The monitor does not support the specified VCP code.
//


//
// MessageId: ERROR_GRAPHICS_DDCCI_INVALID_DATA
//
// MessageText:
//
// The data received from the monitor is invalid.
//


//
// MessageId: ERROR_GRAPHICS_DDCCI_MONITOR_RETURNED_INVALID_TIMING_STATUS_BYTE
//
// MessageText:
//
// The function failed because a monitor returned an invalid Timing Status byte when the operating system used the DDC/CI Get Timing Report & Timing Message command to get a timing report from a monitor.
//


//
// MessageId: ERROR_GRAPHICS_MCA_INVALID_CAPABILITIES_STRING
//
// MessageText:
//
// The monitor returned a DDC/CI capabilities string which did not comply with the ACCESS.bus 3.0, DDC/CI 1.1, or MCCS 2 Revision 1 specification.
//


//
// MessageId: ERROR_GRAPHICS_MCA_INTERNAL_ERROR
//
// MessageText:
//
// An internal Monitor Configuration API error occurred.
//


//
// MessageId: ERROR_GRAPHICS_DDCCI_INVALID_MESSAGE_COMMAND
//
// MessageText:
//
// An operation failed because a DDC/CI message had an invalid value in its command field.
//


//
// MessageId: ERROR_GRAPHICS_DDCCI_INVALID_MESSAGE_LENGTH
//
// MessageText:
//
// An error occurred because the field length of a DDC/CI message contained an invalid value.
//


//
// MessageId: ERROR_GRAPHICS_DDCCI_INVALID_MESSAGE_CHECKSUM
//
// MessageText:
//
// An error occurred because the checksum field in a DDC/CI message did not match the message's computed checksum value. This error implies that the data was corrupted while it was being transmitted from a monitor to a computer.
//


//
// MessageId: ERROR_GRAPHICS_INVALID_PHYSICAL_MONITOR_HANDLE
//
// MessageText:
//
// This function failed because an invalid monitor handle was passed to it.
//


//
// MessageId: ERROR_GRAPHICS_MONITOR_NO_LONGER_EXISTS
//
// MessageText:
//
// The operating system asynchronously destroyed the monitor which corresponds to this handle because the operating system's state changed. This error typically occurs because the monitor PDO associated with this handle was removed, the monitor PDO associated with this handle was stopped, or a display mode change occurred. A display mode change occurs when windows sends a WM_DISPLAYCHANGE windows message to applications.
//


//
// MessageId: ERROR_GRAPHICS_DDCCI_CURRENT_CURRENT_VALUE_GREATER_THAN_MAXIMUM_VALUE
//
// MessageText:
//
// A continuous VCP code's current value is greater than its maximum value. This error code indicates that a monitor returned an invalid value.
//


//
// MessageId: ERROR_GRAPHICS_MCA_INVALID_VCP_VERSION
//
// MessageText:
//
// The monitor's VCP Version (0xDF) VCP code returned an invalid version value.
//


//
// MessageId: ERROR_GRAPHICS_MCA_MONITOR_VIOLATES_MCCS_SPECIFICATION
//
// MessageText:
//
// The monitor does not comply with the MCCS specification it claims to support.
//


//
// MessageId: ERROR_GRAPHICS_MCA_MCCS_VERSION_MISMATCH
//
// MessageText:
//
// The MCCS version in a monitor's mccs_ver capability does not match the MCCS version the monitor reports when the VCP Version (0xDF) VCP code is used.
//


//
// MessageId: ERROR_GRAPHICS_MCA_UNSUPPORTED_MCCS_VERSION
//
// MessageText:
//
// The Monitor Configuration API only works with monitors which support the MCCS 1.0 specification, MCCS 2.0 specification or the MCCS 2.0 Revision 1 specification.
//


//
// MessageId: ERROR_GRAPHICS_MCA_INVALID_TECHNOLOGY_TYPE_RETURNED
//
// MessageText:
//
// The monitor returned an invalid monitor technology type. CRT, Plasma and LCD (TFT) are examples of monitor technology types. This error implies that the monitor violated the MCCS 2.0 or MCCS 2.0 Revision 1 specification.
//


//
// MessageId: ERROR_GRAPHICS_MCA_UNSUPPORTED_COLOR_TEMPERATURE
//
// MessageText:
//
// SetMonitorColorTemperature()'s caller passed a color temperature to it which the current monitor did not support. This error implies that the monitor violated the MCCS 2.0 or MCCS 2.0 Revision 1 specification.
//


//
// OPM, UAB, PVP and DDC/CI shared error codes {0x25E0..0x25ff}
//
//
// MessageId: ERROR_GRAPHICS_ONLY_CONSOLE_SESSION_SUPPORTED
//
// MessageText:
//
// This function can only be used if a program is running in the local console session. It cannot be used if the program is running on a remote desktop session or on a terminal server session.
//


//
// MessageId: ERROR_GRAPHICS_NO_DISPLAY_DEVICE_CORRESPONDS_TO_NAME
//
// MessageText:
//
// This function cannot find an actual GDI display device which corresponds to the specified GDI display device name.
//


//
// MessageId: ERROR_GRAPHICS_DISPLAY_DEVICE_NOT_ATTACHED_TO_DESKTOP
//
// MessageText:
//
// The function failed because the specified GDI display device was not attached to the Windows desktop.
//


//
// MessageId: ERROR_GRAPHICS_MIRRORING_DEVICES_NOT_SUPPORTED
//
// MessageText:
//
// This function does not support GDI mirroring display devices because GDI mirroring display devices do not have any physical monitors associated with them.
//


//
// MessageId: ERROR_GRAPHICS_INVALID_POINTER
//
// MessageText:
//
// The function failed because an invalid pointer parameter was passed to it. A pointer parameter is invalid if it is NULL, points to an invalid address, points to a kernel mode address, or is not correctly aligned.
//


//
// MessageId: ERROR_GRAPHICS_NO_MONITORS_CORRESPOND_TO_DISPLAY_DEVICE
//
// MessageText:
//
// The function failed because the specified GDI device did not have any monitors associated with it.
//


//
// MessageId: ERROR_GRAPHICS_PARAMETER_ARRAY_TOO_SMALL
//
// MessageText:
//
// An array passed to the function cannot hold all of the data that the function must copy into the array.
//


//
// MessageId: ERROR_GRAPHICS_INTERNAL_ERROR
//
// MessageText:
//
// An internal error caused an operation to fail.
//


//
// MessageId: ERROR_GRAPHICS_SESSION_TYPE_CHANGE_IN_PROGRESS
//
// MessageText:
//
// The function failed because the current session is changing its type. This function cannot be called when the current session is changing its type. There are currently three types of sessions: console, disconnected and remote.
//



// FACILITY_NAP

//
// MessageId: NAP_E_INVALID_PACKET
//
// MessageText:
//
// The NAP SoH packet is invalid.
//


//
// MessageId: NAP_E_MISSING_SOH
//
// MessageText:
//
// An SoH was missing from the NAP packet.
//


//
// MessageId: NAP_E_CONFLICTING_ID
//
// MessageText:
//
// The entity ID conflicts with an already registered id.
//


//
// MessageId: NAP_E_NO_CACHED_SOH
//
// MessageText:
//
// No cached SoH is present.
//


//
// MessageId: NAP_E_STILL_BOUND
//
// MessageText:
//
// The entity is still bound to the NAP system.
//


//
// MessageId: NAP_E_NOT_REGISTERED
//
// MessageText:
//
// The entity is not registered with the NAP system.
//


//
// MessageId: NAP_E_NOT_INITIALIZED
//
// MessageText:
//
// The entity is not initialized with the NAP system.
//


//
// MessageId: NAP_E_MISMATCHED_ID
//
// MessageText:
//
// The correlation id in the SoH-Request and SoH-Response do not match up.
//


//
// MessageId: NAP_E_NOT_PENDING
//
// MessageText:
//
// Completion was indicated on a request that is not currently pending.
//


//
// MessageId: NAP_E_ID_NOT_FOUND
//
// MessageText:
//
// The NAP component's id was not found.
//


//
// MessageId: NAP_E_MAXSIZE_TOO_SMALL
//
// MessageText:
//
// The maximum size of the connection is too small for an SoH packet.
//


//
// MessageId: NAP_E_SERVICE_NOT_RUNNING
//
// MessageText:
//
// The NapAgent service is not running.
//


//
// MessageId: NAP_S_CERT_ALREADY_PRESENT
//
// MessageText:
//
// A certificate is already present in the cert store.
//


//
// MessageId: NAP_E_ENTITY_DISABLED
//
// MessageText:
//
// The entity is disabled with the NapAgent service.
//


//
// MessageId: NAP_E_NETSH_GROUPPOLICY_ERROR
//
// MessageText:
//
// Group Policy is not configured.
//


//
// MessageId: NAP_E_TOO_MANY_CALLS
//
// MessageText:
//
// Too many simultaneous calls.
//


//
// MessageId: NAP_E_SHV_CONFIG_EXISTED
//
// MessageText:
//
// SHV configuration already existed.
//


//
// MessageId: NAP_E_SHV_CONFIG_NOT_FOUND
//
// MessageText:
//
// SHV configuration is not found.
//


//
// MessageId: NAP_E_SHV_TIMEOUT
//
// MessageText:
//
// SHV timed out on the request.
//


//
// ===============================
// TPM Services and TPM Software Error Messages
// ===============================
//
// The TPM services and TPM software facilities are used by the various
// TPM software components. There are two facilities because the services
// errors are within the TCG-defined error space and the software errors
// are not.
//
// The following are the subranges within the TPM Services facility.
// The TPM hardware errors are defined in the document
// TPM Main Specification 1.2 Part 2 TPM Structures.
// The TBS errors are slotted into the TCG error namespace at the TBS layer.
//
// 0x0000 - 0x08ff     TPM hardware errors
// 0x4000 - 0x40ff     TPM Base Services errors (tbssvc.dll)
//
// The following are the subranges within the TPM Software facility. The TBS
// has two classes of errors - those that can be returned (the public errors,
// defined in the TBS spec), which are in the TPM services facility,  and
// those that are internal or implementation specific, which are here in the
// TPM software facility.
//
// 0x0000 - 0x00ff     TPM device driver errors (tpm.sys)
// 0x0100 - 0x01ff     TPM API errors (tpmapi.lib)
// 0x0200 - 0x02ff     TBS internal errors (tbssvc.dll)
// 0x0300 - 0x03ff     TPM Physical Presence errors
//
//
// TPM hardware error codes {0x0000..0x08ff}
// This space is further subdivided into hardware errors, vendor-specific
// errors, and non-fatal errors.
//
//
// TPM hardware errors {0x0000..0x003ff}
//
//
// MessageId: TPM_E_ERROR_MASK
//
// MessageText:
//
// This is an error mask to convert TPM hardware errors to win errors.
//


//
// MessageId: TPM_E_AUTHFAIL
//
// MessageText:
//
// TPM 1.2: Authentication failed.
//


//
// MessageId: TPM_E_BADINDEX
//
// MessageText:
//
// TPM 1.2: The index to a PCR, DIR or other register is incorrect.
//


//
// MessageId: TPM_E_BAD_PARAMETER
//
// MessageText:
//
// TPM 1.2: One or more parameter is bad.
//


//
// MessageId: TPM_E_AUDITFAILURE
//
// MessageText:
//
// TPM 1.2: An operation completed successfully but the auditing of that operation failed.
//


//
// MessageId: TPM_E_CLEAR_DISABLED
//
// MessageText:
//
// TPM 1.2: The clear disable flag is set and all clear operations now require physical access.
//


//
// MessageId: TPM_E_DEACTIVATED
//
// MessageText:
//
// TPM 1.2: Activate the Trusted Platform Module (TPM).
//


//
// MessageId: TPM_E_DISABLED
//
// MessageText:
//
// TPM 1.2: Enable the Trusted Platform Module (TPM).
//


//
// MessageId: TPM_E_DISABLED_CMD
//
// MessageText:
//
// TPM 1.2: The target command has been disabled.
//


//
// MessageId: TPM_E_FAIL
//
// MessageText:
//
// TPM 1.2: The operation failed.
//


//
// MessageId: TPM_E_BAD_ORDINAL
//
// MessageText:
//
// TPM 1.2: The ordinal was unknown or inconsistent.
//


//
// MessageId: TPM_E_INSTALL_DISABLED
//
// MessageText:
//
// TPM 1.2: The ability to install an owner is disabled.
//


//
// MessageId: TPM_E_INVALID_KEYHANDLE
//
// MessageText:
//
// TPM 1.2: The key handle cannot be interpreted.
//


//
// MessageId: TPM_E_KEYNOTFOUND
//
// MessageText:
//
// TPM 1.2: The key handle points to an invalid key.
//


//
// MessageId: TPM_E_INAPPROPRIATE_ENC
//
// MessageText:
//
// TPM 1.2: Unacceptable encryption scheme.
//


//
// MessageId: TPM_E_MIGRATEFAIL
//
// MessageText:
//
// TPM 1.2: Migration authorization failed.
//


//
// MessageId: TPM_E_INVALID_PCR_INFO
//
// MessageText:
//
// TPM 1.2: PCR information could not be interpreted.
//


//
// MessageId: TPM_E_NOSPACE
//
// MessageText:
//
// TPM 1.2: No room to load key.
//


//
// MessageId: TPM_E_NOSRK
//
// MessageText:
//
// TPM 1.2: There is no Storage Root Key (SRK) set.
//


//
// MessageId: TPM_E_NOTSEALED_BLOB
//
// MessageText:
//
// TPM 1.2: An encrypted blob is invalid or was not created by this TPM.
//


//
// MessageId: TPM_E_OWNER_SET
//
// MessageText:
//
// TPM 1.2: The Trusted Platform Module (TPM) already has an owner.
//


//
// MessageId: TPM_E_RESOURCES
//
// MessageText:
//
// TPM 1.2: The TPM has insufficient internal resources to perform the requested action.
//


//
// MessageId: TPM_E_SHORTRANDOM
//
// MessageText:
//
// TPM 1.2: A random string was too short.
//


//
// MessageId: TPM_E_SIZE
//
// MessageText:
//
// TPM 1.2: The TPM does not have the space to perform the operation.
//


//
// MessageId: TPM_E_WRONGPCRVAL
//
// MessageText:
//
// TPM 1.2: The named PCR value does not match the current PCR value.
//


//
// MessageId: TPM_E_BAD_PARAM_SIZE
//
// MessageText:
//
// TPM 1.2: The paramSize argument to the command has the incorrect value .
//


//
// MessageId: TPM_E_SHA_THREAD
//
// MessageText:
//
// TPM 1.2: There is no existing SHA-1 thread.
//


//
// MessageId: TPM_E_SHA_ERROR
//
// MessageText:
//
// TPM 1.2: The calculation is unable to proceed because the existing SHA-1 thread has already encountered an error.
//


//
// MessageId: TPM_E_FAILEDSELFTEST
//
// MessageText:
//
// TPM 1.2: The TPM hardware device reported a failure during its internal self test. Try restarting the computer to resolve the problem. If the problem continues, check for the latest BIOS or firmware update for your TPM hardware. Consult the computer manufacturer's documentation for instructions.
//


//
// MessageId: TPM_E_AUTH2FAIL
//
// MessageText:
//
// TPM 1.2: The authorization for the second key in a 2 key function failed authorization.
//


//
// MessageId: TPM_E_BADTAG
//
// MessageText:
//
// TPM 1.2: The tag value sent to for a command is invalid.
//


//
// MessageId: TPM_E_IOERROR
//
// MessageText:
//
// TPM 1.2: An IO error occurred transmitting information to the TPM.
//


//
// MessageId: TPM_E_ENCRYPT_ERROR
//
// MessageText:
//
// TPM 1.2: The encryption process had a problem.
//


//
// MessageId: TPM_E_DECRYPT_ERROR
//
// MessageText:
//
// TPM 1.2: The decryption process did not complete.
//


//
// MessageId: TPM_E_INVALID_AUTHHANDLE
//
// MessageText:
//
// TPM 1.2: An invalid handle was used.
//


//
// MessageId: TPM_E_NO_ENDORSEMENT
//
// MessageText:
//
// TPM 1.2: The TPM does not have an Endorsement Key (EK) installed.
//


//
// MessageId: TPM_E_INVALID_KEYUSAGE
//
// MessageText:
//
// TPM 1.2: The usage of a key is not allowed.
//


//
// MessageId: TPM_E_WRONG_ENTITYTYPE
//
// MessageText:
//
// TPM 1.2: The submitted entity type is not allowed.
//


//
// MessageId: TPM_E_INVALID_POSTINIT
//
// MessageText:
//
// TPM 1.2: The command was received in the wrong sequence relative to TPM_Init and a subsequent TPM_Startup.
//


//
// MessageId: TPM_E_INAPPROPRIATE_SIG
//
// MessageText:
//
// TPM 1.2: Signed data cannot include additional DER information.
//


//
// MessageId: TPM_E_BAD_KEY_PROPERTY
//
// MessageText:
//
// TPM 1.2: The key properties in TPM_KEY_PARMs are not supported by this TPM.
//


//
// MessageId: TPM_E_BAD_MIGRATION
//
// MessageText:
//
// TPM 1.2: The migration properties of this key are incorrect.
//


//
// MessageId: TPM_E_BAD_SCHEME
//
// MessageText:
//
// TPM 1.2: The signature or encryption scheme for this key is incorrect or not permitted in this situation.
//


//
// MessageId: TPM_E_BAD_DATASIZE
//
// MessageText:
//
// TPM 1.2: The size of the data (or blob) parameter is bad or inconsistent with the referenced key.
//


//
// MessageId: TPM_E_BAD_MODE
//
// MessageText:
//
// TPM 1.2: A mode parameter is bad, such as capArea or subCapArea for TPM_GetCapability, phsicalPresence parameter for TPM_PhysicalPresence, or migrationType for TPM_CreateMigrationBlob.
//


//
// MessageId: TPM_E_BAD_PRESENCE
//
// MessageText:
//
// TPM 1.2: Either the physicalPresence or physicalPresenceLock bits have the wrong value.
//


//
// MessageId: TPM_E_BAD_VERSION
//
// MessageText:
//
// TPM 1.2: The TPM cannot perform this version of the capability.
//


//
// MessageId: TPM_E_NO_WRAP_TRANSPORT
//
// MessageText:
//
// TPM 1.2: The TPM does not allow for wrapped transport sessions.
//


//
// MessageId: TPM_E_AUDITFAIL_UNSUCCESSFUL
//
// MessageText:
//
// TPM 1.2: TPM audit construction failed and the underlying command was returning a failure code also.
//


//
// MessageId: TPM_E_AUDITFAIL_SUCCESSFUL
//
// MessageText:
//
// TPM 1.2: TPM audit construction failed and the underlying command was returning success.
//


//
// MessageId: TPM_E_NOTRESETABLE
//
// MessageText:
//
// TPM 1.2: Attempt to reset a PCR register that does not have the resettable attribute.
//


//
// MessageId: TPM_E_NOTLOCAL
//
// MessageText:
//
// TPM 1.2: Attempt to reset a PCR register that requires locality and locality modifier not part of command transport.
//


//
// MessageId: TPM_E_BAD_TYPE
//
// MessageText:
//
// TPM 1.2: Make identity blob not properly typed.
//


//
// MessageId: TPM_E_INVALID_RESOURCE
//
// MessageText:
//
// TPM 1.2: When saving context identified resource type does not match actual resource.
//


//
// MessageId: TPM_E_NOTFIPS
//
// MessageText:
//
// TPM 1.2: The TPM is attempting to execute a command only available when in FIPS mode.
//


//
// MessageId: TPM_E_INVALID_FAMILY
//
// MessageText:
//
// TPM 1.2: The command is attempting to use an invalid family ID.
//


//
// MessageId: TPM_E_NO_NV_PERMISSION
//
// MessageText:
//
// TPM 1.2: The permission to manipulate the NV storage is not available.
//


//
// MessageId: TPM_E_REQUIRES_SIGN
//
// MessageText:
//
// TPM 1.2: The operation requires a signed command.
//


//
// MessageId: TPM_E_KEY_NOTSUPPORTED
//
// MessageText:
//
// TPM 1.2: Wrong operation to load an NV key.
//


//
// MessageId: TPM_E_AUTH_CONFLICT
//
// MessageText:
//
// TPM 1.2: NV_LoadKey blob requires both owner and blob authorization.
//


//
// MessageId: TPM_E_AREA_LOCKED
//
// MessageText:
//
// TPM 1.2: The NV area is locked and not writable.
//


//
// MessageId: TPM_E_BAD_LOCALITY
//
// MessageText:
//
// TPM 1.2: The locality is incorrect for the attempted operation.
//


//
// MessageId: TPM_E_READ_ONLY
//
// MessageText:
//
// TPM 1.2: The NV area is read only and can't be written to.
//


//
// MessageId: TPM_E_PER_NOWRITE
//
// MessageText:
//
// TPM 1.2: There is no protection on the write to the NV area.
//


//
// MessageId: TPM_E_FAMILYCOUNT
//
// MessageText:
//
// TPM 1.2: The family count value does not match.
//


//
// MessageId: TPM_E_WRITE_LOCKED
//
// MessageText:
//
// TPM 1.2: The NV area has already been written to.
//


//
// MessageId: TPM_E_BAD_ATTRIBUTES
//
// MessageText:
//
// TPM 1.2: The NV area attributes conflict.
//


//
// MessageId: TPM_E_INVALID_STRUCTURE
//
// MessageText:
//
// TPM 1.2: The structure tag and version are invalid or inconsistent.
//


//
// MessageId: TPM_E_KEY_OWNER_CONTROL
//
// MessageText:
//
// TPM 1.2: The key is under control of the TPM Owner and can only be evicted by the TPM Owner.
//


//
// MessageId: TPM_E_BAD_COUNTER
//
// MessageText:
//
// TPM 1.2: The counter handle is incorrect.
//


//
// MessageId: TPM_E_NOT_FULLWRITE
//
// MessageText:
//
// TPM 1.2: The write is not a complete write of the area.
//


//
// MessageId: TPM_E_CONTEXT_GAP
//
// MessageText:
//
// TPM 1.2: The gap between saved context counts is too large.
//


//
// MessageId: TPM_E_MAXNVWRITES
//
// MessageText:
//
// TPM 1.2: The maximum number of NV writes without an owner has been exceeded.
//


//
// MessageId: TPM_E_NOOPERATOR
//
// MessageText:
//
// TPM 1.2: No operator AuthData value is set.
//


//
// MessageId: TPM_E_RESOURCEMISSING
//
// MessageText:
//
// TPM 1.2: The resource pointed to by context is not loaded.
//


//
// MessageId: TPM_E_DELEGATE_LOCK
//
// MessageText:
//
// TPM 1.2: The delegate administration is locked.
//


//
// MessageId: TPM_E_DELEGATE_FAMILY
//
// MessageText:
//
// TPM 1.2: Attempt to manage a family other then the delegated family.
//


//
// MessageId: TPM_E_DELEGATE_ADMIN
//
// MessageText:
//
// TPM 1.2: Delegation table management not enabled.
//


//
// MessageId: TPM_E_TRANSPORT_NOTEXCLUSIVE
//
// MessageText:
//
// TPM 1.2: There was a command executed outside of an exclusive transport session.
//


//
// MessageId: TPM_E_OWNER_CONTROL
//
// MessageText:
//
// TPM 1.2: Attempt to context save a owner evict controlled key.
//


//
// MessageId: TPM_E_DAA_RESOURCES
//
// MessageText:
//
// TPM 1.2: The DAA command has no resources available to execute the command.
//


//
// MessageId: TPM_E_DAA_INPUT_DATA0
//
// MessageText:
//
// TPM 1.2: The consistency check on DAA parameter inputData0 has failed.
//


//
// MessageId: TPM_E_DAA_INPUT_DATA1
//
// MessageText:
//
// TPM 1.2: The consistency check on DAA parameter inputData1 has failed.
//


//
// MessageId: TPM_E_DAA_ISSUER_SETTINGS
//
// MessageText:
//
// TPM 1.2: The consistency check on DAA_issuerSettings has failed.
//


//
// MessageId: TPM_E_DAA_TPM_SETTINGS
//
// MessageText:
//
// TPM 1.2: The consistency check on DAA_tpmSpecific has failed.
//


//
// MessageId: TPM_E_DAA_STAGE
//
// MessageText:
//
// TPM 1.2: The atomic process indicated by the submitted DAA command is not the expected process.
//


//
// MessageId: TPM_E_DAA_ISSUER_VALIDITY
//
// MessageText:
//
// TPM 1.2: The issuer's validity check has detected an inconsistency.
//


//
// MessageId: TPM_E_DAA_WRONG_W
//
// MessageText:
//
// TPM 1.2: The consistency check on w has failed.
//


//
// MessageId: TPM_E_BAD_HANDLE
//
// MessageText:
//
// TPM 1.2: The handle is incorrect.
//


//
// MessageId: TPM_E_BAD_DELEGATE
//
// MessageText:
//
// TPM 1.2: Delegation is not correct.
//


//
// MessageId: TPM_E_BADCONTEXT
//
// MessageText:
//
// TPM 1.2: The context blob is invalid.
//


//
// MessageId: TPM_E_TOOMANYCONTEXTS
//
// MessageText:
//
// TPM 1.2: Too many contexts held by the TPM.
//


//
// MessageId: TPM_E_MA_TICKET_SIGNATURE
//
// MessageText:
//
// TPM 1.2: Migration authority signature validation failure.
//


//
// MessageId: TPM_E_MA_DESTINATION
//
// MessageText:
//
// TPM 1.2: Migration destination not authenticated.
//


//
// MessageId: TPM_E_MA_SOURCE
//
// MessageText:
//
// TPM 1.2: Migration source incorrect.
//


//
// MessageId: TPM_E_MA_AUTHORITY
//
// MessageText:
//
// TPM 1.2: Incorrect migration authority.
//


//
// MessageId: TPM_E_PERMANENTEK
//
// MessageText:
//
// TPM 1.2: Attempt to revoke the EK and the EK is not revocable.
//


//
// MessageId: TPM_E_BAD_SIGNATURE
//
// MessageText:
//
// TPM 1.2: Bad signature of CMK ticket.
//


//
// MessageId: TPM_E_NOCONTEXTSPACE
//
// MessageText:
//
// TPM 1.2: There is no room in the context list for additional contexts.
//


//
// MessageId: TPM_20_E_ASYMMETRIC
//
// MessageText:
//
// TPM 2.0: Asymmetric algorithm not supported or not correct.
//


//
// MessageId: TPM_20_E_ATTRIBUTES
//
// MessageText:
//
// TPM 2.0: Inconsistent attributes.
//


//
// MessageId: TPM_20_E_HASH
//
// MessageText:
//
// TPM 2.0: Hash algorithm not supported or not appropriate.
//


//
// MessageId: TPM_20_E_VALUE
//
// MessageText:
//
// TPM 2.0: Value is out of range or is not correct for the context.
//


//
// MessageId: TPM_20_E_HIERARCHY
//
// MessageText:
//
// TPM 2.0: Hierarchy is not enabled or is not correct for the use.
//


//
// MessageId: TPM_20_E_KEY_SIZE
//
// MessageText:
//
// TPM 2.0: Key size is not supported.
//


//
// MessageId: TPM_20_E_MGF
//
// MessageText:
//
// TPM 2.0: Mask generation function not supported.
//


//
// MessageId: TPM_20_E_MODE
//
// MessageText:
//
// TPM 2.0: Mode of operation not supported.
//


//
// MessageId: TPM_20_E_TYPE
//
// MessageText:
//
// TPM 2.0: The type of the value is not appropriate for the use.
//


//
// MessageId: TPM_20_E_HANDLE
//
// MessageText:
//
// TPM 2.0: The Handle is not correct for the use.
//


//
// MessageId: TPM_20_E_KDF
//
// MessageText:
//
// TPM 2.0: Unsupported key derivation function or function not appropriate for use.
//


//
// MessageId: TPM_20_E_RANGE
//
// MessageText:
//
// TPM 2.0: Value was out of allowed range.
//


//
// MessageId: TPM_20_E_AUTH_FAIL
//
// MessageText:
//
// TPM 2.0: The authorization HMAC check failed and DA counter incremented.
//


//
// MessageId: TPM_20_E_NONCE
//
// MessageText:
//
// TPM 2.0: Invalid nonce size.
//


//
// MessageId: TPM_20_E_PP
//
// MessageText:
//
// TPM 2.0: Authorization requires assertion of PP.
//


//
// MessageId: TPM_20_E_SCHEME
//
// MessageText:
//
// TPM 2.0: Unsupported or incompatible scheme.
//


//
// MessageId: TPM_20_E_SIZE
//
// MessageText:
//
// TPM 2.0: Structure is wrong size.
//


//
// MessageId: TPM_20_E_SYMMETRIC
//
// MessageText:
//
// TPM 2.0: Unsupported symmetric algorithm or key size, or not appropriate for instance.
//


//
// MessageId: TPM_20_E_TAG
//
// MessageText:
//
// TPM 2.0: Incorrect structure tag.
//


//
// MessageId: TPM_20_E_SELECTOR
//
// MessageText:
//
// TPM 2.0: Union selector is incorrect.
//


//
// MessageId: TPM_20_E_INSUFFICIENT
//
// MessageText:
//
// TPM 2.0: The TPM was unable to unmarshal a value because there were not enough octets in the input buffer.
//


//
// MessageId: TPM_20_E_SIGNATURE
//
// MessageText:
//
// TPM 2.0: The signature is not valid.
//


//
// MessageId: TPM_20_E_KEY
//
// MessageText:
//
// TPM 2.0: Key fields are not compatible with the selected use.
//


//
// MessageId: TPM_20_E_POLICY_FAIL
//
// MessageText:
//
// TPM 2.0: A policy check failed.
//


//
// MessageId: TPM_20_E_INTEGRITY
//
// MessageText:
//
// TPM 2.0: Integrity check failed.
//


//
// MessageId: TPM_20_E_TICKET
//
// MessageText:
//
// TPM 2.0: Invalid ticket.
//


//
// MessageId: TPM_20_E_RESERVED_BITS
//
// MessageText:
//
// TPM 2.0: Reserved bits not set to zero as required.
//


//
// MessageId: TPM_20_E_BAD_AUTH
//
// MessageText:
//
// TPM 2.0: Authorization failure without DA implications.
//


//
// MessageId: TPM_20_E_EXPIRED
//
// MessageText:
//
// TPM 2.0: The policy has expired.
//


//
// MessageId: TPM_20_E_POLICY_CC
//
// MessageText:
//
// TPM 2.0: The command code in the policy is not the command code of the command or the command code in a policy command references a command that is not implemented.
//


//
// MessageId: TPM_20_E_BINDING
//
// MessageText:
//
// TPM 2.0: Public and sensitive portions of an object are not cryptographically bound.
//


//
// MessageId: TPM_20_E_CURVE
//
// MessageText:
//
// TPM 2.0: Curve not supported.
//


//
// MessageId: TPM_20_E_ECC_POINT
//
// MessageText:
//
// TPM 2.0: Point is not on the required curve.
//


//
// MessageId: TPM_20_E_INITIALIZE
//
// MessageText:
//
// TPM 2.0: TPM not initialized.
//


//
// MessageId: TPM_20_E_FAILURE
//
// MessageText:
//
// TPM 2.0: Commands not being accepted because of a TPM failure.
//


//
// MessageId: TPM_20_E_SEQUENCE
//
// MessageText:
//
// TPM 2.0: Improper use of a sequence handle.
//


//
// MessageId: TPM_20_E_PRIVATE
//
// MessageText:
//
// TPM 2.0: TPM_RC_PRIVATE error.
//


//
// MessageId: TPM_20_E_HMAC
//
// MessageText:
//
// TPM 2.0: TPM_RC_HMAC.
//


//
// MessageId: TPM_20_E_DISABLED
//
// MessageText:
//
// TPM 2.0: TPM_RC_DISABLED.
//


//
// MessageId: TPM_20_E_EXCLUSIVE
//
// MessageText:
//
// TPM 2.0: Command failed because audit sequence required exclusivity.
//


//
// MessageId: TPM_20_E_ECC_CURVE
//
// MessageText:
//
// TPM 2.0: Unsupported ECC curve.
//


//
// MessageId: TPM_20_E_AUTH_TYPE
//
// MessageText:
//
// TPM 2.0: Authorization handle is not correct for command.
//


//
// MessageId: TPM_20_E_AUTH_MISSING
//
// MessageText:
//
// TPM 2.0: Command requires an authorization session for handle and is not present.
//


//
// MessageId: TPM_20_E_POLICY
//
// MessageText:
//
// TPM 2.0: Policy failure in Math Operation or an invalid authPolicy value.
//


//
// MessageId: TPM_20_E_PCR
//
// MessageText:
//
// TPM 2.0: PCR check fail.
//


//
// MessageId: TPM_20_E_PCR_CHANGED
//
// MessageText:
//
// TPM 2.0: PCR have changed since checked.
//


//
// MessageId: TPM_20_E_UPGRADE
//
// MessageText:
//
// TPM 2.0: The TPM is not in the right mode for upgrade.
//


//
// MessageId: TPM_20_E_TOO_MANY_CONTEXTS
//
// MessageText:
//
// TPM 2.0: Context ID counter is at maximum.
//


//
// MessageId: TPM_20_E_AUTH_UNAVAILABLE
//
// MessageText:
//
// TPM 2.0: authValue or authPolicy is not available for selected entity.
//


//
// MessageId: TPM_20_E_REBOOT
//
// MessageText:
//
// TPM 2.0: A _TPM_Init and Startup(CLEAR) is required before the TPM can resume operation.
//


//
// MessageId: TPM_20_E_UNBALANCED
//
// MessageText:
//
// TPM 2.0: The protection algorithms (hash and symmetric) are not reasonably balanced. The digest size of the hash must be larger than the key size of the symmetric algorithm.
//


//
// MessageId: TPM_20_E_COMMAND_SIZE
//
// MessageText:
//
// TPM 2.0: The TPM command's commandSize value is inconsistent with contents of the command buffer; either the size is not the same as the bytes loaded by the hardware interface layer or the value is not large enough to hold a command header.
//


//
// MessageId: TPM_20_E_COMMAND_CODE
//
// MessageText:
//
// TPM 2.0: Command code not supported.
//


//
// MessageId: TPM_20_E_AUTHSIZE
//
// MessageText:
//
// TPM 2.0: The value of authorizationSize is out of range or the number of octets in the authorization Area is greater than required.
//


//
// MessageId: TPM_20_E_AUTH_CONTEXT
//
// MessageText:
//
// TPM 2.0: Use of an authorization session with a context command or another command that cannot have an authorization session.
//


//
// MessageId: TPM_20_E_NV_RANGE
//
// MessageText:
//
// TPM 2.0: NV offset+size is out of range.
//


//
// MessageId: TPM_20_E_NV_SIZE
//
// MessageText:
//
// TPM 2.0: Requested allocation size is larger than allowed.
//


//
// MessageId: TPM_20_E_NV_LOCKED
//
// MessageText:
//
// TPM 2.0: NV access locked.
//


//
// MessageId: TPM_20_E_NV_AUTHORIZATION
//
// MessageText:
//
// TPM 2.0: NV access authorization fails in command actions
//


//
// MessageId: TPM_20_E_NV_UNINITIALIZED
//
// MessageText:
//
// TPM 2.0: An NV index is used before being initialized or the state saved by TPM2_Shutdown(STATE) could not be restored.
//


//
// MessageId: TPM_20_E_NV_SPACE
//
// MessageText:
//
// TPM 2.0: Insufficient space for NV allocation.
//


//
// MessageId: TPM_20_E_NV_DEFINED
//
// MessageText:
//
// TPM 2.0: NV index or persistent object already defined.
//


//
// MessageId: TPM_20_E_BAD_CONTEXT
//
// MessageText:
//
// TPM 2.0: Context in TPM2_ContextLoad() is not valid.
//


//
// MessageId: TPM_20_E_CPHASH
//
// MessageText:
//
// TPM 2.0: chHash value already set or not correct for use.
//


//
// MessageId: TPM_20_E_PARENT
//
// MessageText:
//
// TPM 2.0: Handle for parent is not a valid parent.
//


//
// MessageId: TPM_20_E_NEEDS_TEST
//
// MessageText:
//
// TPM 2.0: Some function needs testing.
//


//
// MessageId: TPM_20_E_NO_RESULT
//
// MessageText:
//
// TPM 2.0: returned when an internal function cannot process a request due to an unspecified problem. This code is usually related to invalid parameters that are not properly filtered by the input unmarshaling code.
//


//
// MessageId: TPM_20_E_SENSITIVE
//
// MessageText:
//
// TPM 2.0: The sensitive area did not unmarshal correctly after decryption - this code is used in lieu of the other unmarshaling errors so that an attacker cannot determine where the unmarshaling error occurred.
//


//
// TPM vendor specific hardware errors {0x0400..0x04ff}
//
//
// MessageId: TPM_E_COMMAND_BLOCKED
//
// MessageText:
//
// The command was blocked.
//


//
// MessageId: TPM_E_INVALID_HANDLE
//
// MessageText:
//
// The specified handle was not found.
//


//
// MessageId: TPM_E_DUPLICATE_VHANDLE
//
// MessageText:
//
// The TPM returned a duplicate handle and the command needs to be resubmitted.
//


//
// MessageId: TPM_E_EMBEDDED_COMMAND_BLOCKED
//
// MessageText:
//
// The command within the transport was blocked.
//


//
// MessageId: TPM_E_EMBEDDED_COMMAND_UNSUPPORTED
//
// MessageText:
//
// The command within the transport is not supported.
//


//
// TPM non-fatal hardware errors {0x0800..0x08ff}
//
//
// MessageId: TPM_E_RETRY
//
// MessageText:
//
// The TPM is too busy to respond to the command immediately, but the command could be resubmitted at a later time.
//


//
// MessageId: TPM_E_NEEDS_SELFTEST
//
// MessageText:
//
// SelfTestFull has not been run.
//


//
// MessageId: TPM_E_DOING_SELFTEST
//
// MessageText:
//
// The TPM is currently executing a full selftest.
//


//
// MessageId: TPM_E_DEFEND_LOCK_RUNNING
//
// MessageText:
//
// The TPM is defending against dictionary attacks and is in a time-out period.
//


//
// MessageId: TPM_20_E_CONTEXT_GAP
//
// MessageText:
//
// TPM 2.0: Gap for context ID is too large.
//


//
// MessageId: TPM_20_E_OBJECT_MEMORY
//
// MessageText:
//
// TPM 2.0: Out of memory for object contexts.
//


//
// MessageId: TPM_20_E_SESSION_MEMORY
//
// MessageText:
//
// TPM 2.0: Out of memory for session contexts.
//


//
// MessageId: TPM_20_E_MEMORY
//
// MessageText:
//
// TPM 2.0: Out of shared object/session memory or need space for internal operations.
//


//
// MessageId: TPM_20_E_SESSION_HANDLES
//
// MessageText:
//
// TPM 2.0: Out of session handles - a session must be flushed before a nes session may be created.
//


//
// MessageId: TPM_20_E_OBJECT_HANDLES
//
// MessageText:
//
// TPM 2.0: Out of object handles - the handle space for objects is depleted and a reboot is required.
//


//
// MessageId: TPM_20_E_LOCALITY
//
// MessageText:
//
// TPM 2.0: Bad locality.
//


//
// MessageId: TPM_20_E_YIELDED
//
// MessageText:
//
// TPM 2.0: The TPM has suspended operation on the command; forward progress was made and the command may be retried.
//


//
// MessageId: TPM_20_E_CANCELED
//
// MessageText:
//
// TPM 2.0: The command was canceled.
//


//
// MessageId: TPM_20_E_TESTING
//
// MessageText:
//
// TPM 2.0: TPM is performing self-tests.
//


//
// MessageId: TPM_20_E_NV_RATE
//
// MessageText:
//
// TPM 2.0: The TPM is rate-limiting accesses to prevent wearout of NV
//


//
// MessageId: TPM_20_E_LOCKOUT
//
// MessageText:
//
// TPM 2.0: Authorization for objects subject to DA protection are not allowed at this time because the TPM is in DA lockout mode.
//


//
// MessageId: TPM_20_E_RETRY
//
// MessageText:
//
// TPM 2.0: The TPM was not able to start the command.
//


//
// MessageId: TPM_20_E_NV_UNAVAILABLE
//
// MessageText:
//
// TPM 2.0: the command may require writing of NV and NV is not current accessible.
//


//
// TPM Base Services error codes {0x4000..0x40ff}
//
//
// MessageId: TBS_E_INTERNAL_ERROR
//
// MessageText:
//
// An internal error has occurred within the Trusted Platform Module support program.
//


//
// MessageId: TBS_E_BAD_PARAMETER
//
// MessageText:
//
// One or more input parameters is bad.
//


//
// MessageId: TBS_E_INVALID_OUTPUT_POINTER
//
// MessageText:
//
// A specified output pointer is bad.
//


//
// MessageId: TBS_E_INVALID_CONTEXT
//
// MessageText:
//
// The specified context handle does not refer to a valid context.
//


//
// MessageId: TBS_E_INSUFFICIENT_BUFFER
//
// MessageText:
//
// A specified output buffer is too small.
//


//
// MessageId: TBS_E_IOERROR
//
// MessageText:
//
// An error occurred while communicating with the TPM.
//


//
// MessageId: TBS_E_INVALID_CONTEXT_PARAM
//
// MessageText:
//
// One or more context parameters is invalid.
//


//
// MessageId: TBS_E_SERVICE_NOT_RUNNING
//
// MessageText:
//
// The TBS service is not running and could not be started.
//


//
// MessageId: TBS_E_TOO_MANY_TBS_CONTEXTS
//
// MessageText:
//
// A new context could not be created because there are too many open contexts.
//


//
// MessageId: TBS_E_TOO_MANY_RESOURCES
//
// MessageText:
//
// A new virtual resource could not be created because there are too many open virtual resources.
//


//
// MessageId: TBS_E_SERVICE_START_PENDING
//
// MessageText:
//
// The TBS service has been started but is not yet running.
//


//
// MessageId: TBS_E_PPI_NOT_SUPPORTED
//
// MessageText:
//
// The physical presence interface is not supported.
//


//
// MessageId: TBS_E_COMMAND_CANCELED
//
// MessageText:
//
// The command was canceled.
//


//
// MessageId: TBS_E_BUFFER_TOO_LARGE
//
// MessageText:
//
// The input or output buffer is too large.
//


//
// MessageId: TBS_E_TPM_NOT_FOUND
//
// MessageText:
//
// A compatible Trusted Platform Module (TPM) Security Device cannot be found on this computer.
//


//
// MessageId: TBS_E_SERVICE_DISABLED
//
// MessageText:
//
// The TBS service has been disabled.
//


//
// MessageId: TBS_E_NO_EVENT_LOG
//
// MessageText:
//
// No TCG event log is available.
//


//
// MessageId: TBS_E_ACCESS_DENIED
//
// MessageText:
//
// The caller does not have the appropriate rights to perform the requested operation.
//


//
// MessageId: TBS_E_PROVISIONING_NOT_ALLOWED
//
// MessageText:
//
// The TPM provisioning action is not allowed by the specified flags.  For provisioning to be successful, one of several actions may be required.  The TPM management console (tpm.msc) action to make the TPM Ready may help.  For further information, see the documentation for the Win32_Tpm WMI method 'Provision'.  (The actions that may be required include importing the TPM Owner Authorization value into the system, calling the Win32_Tpm WMI method for provisioning the TPM and specifying TRUE for either 'ForceClear_Allowed' or 'PhysicalPresencePrompts_Allowed' (as indicated by the value returned in the Additional Information), or enabling the TPM in the system BIOS.)
//


//
// MessageId: TBS_E_PPI_FUNCTION_UNSUPPORTED
//
// MessageText:
//
// The Physical Presence Interface of this firmware does not support the requested method.
//


//
// MessageId: TBS_E_OWNERAUTH_NOT_FOUND
//
// MessageText:
//
// The requested TPM OwnerAuth value was not found.
//


//
// MessageId: TBS_E_PROVISIONING_INCOMPLETE
//
// MessageText:
//
// The TPM provisioning did not complete.  For more information on completing the provisioning, call the Win32_Tpm WMI method for provisioning the TPM ('Provision') and check the returned Information.
//


//
// TPM API error codes {0x0100..0x01ff}
//
//
// MessageId: TPMAPI_E_INVALID_STATE
//
// MessageText:
//
// The command buffer is not in the correct state.
//


//
// MessageId: TPMAPI_E_NOT_ENOUGH_DATA
//
// MessageText:
//
// The command buffer does not contain enough data to satisfy the request.
//


//
// MessageId: TPMAPI_E_TOO_MUCH_DATA
//
// MessageText:
//
// The command buffer cannot contain any more data.
//


//
// MessageId: TPMAPI_E_INVALID_OUTPUT_POINTER
//
// MessageText:
//
// One or more output parameters was NULL or invalid.
//


//
// MessageId: TPMAPI_E_INVALID_PARAMETER
//
// MessageText:
//
// One or more input parameters is invalid.
//


//
// MessageId: TPMAPI_E_OUT_OF_MEMORY
//
// MessageText:
//
// Not enough memory was available to satisfy the request.
//


//
// MessageId: TPMAPI_E_BUFFER_TOO_SMALL
//
// MessageText:
//
// The specified buffer was too small.
//


//
// MessageId: TPMAPI_E_INTERNAL_ERROR
//
// MessageText:
//
// An internal error was detected.
//


//
// MessageId: TPMAPI_E_ACCESS_DENIED
//
// MessageText:
//
// The caller does not have the appropriate rights to perform the requested operation.
//


//
// MessageId: TPMAPI_E_AUTHORIZATION_FAILED
//
// MessageText:
//
// The specified authorization information was invalid.
//


//
// MessageId: TPMAPI_E_INVALID_CONTEXT_HANDLE
//
// MessageText:
//
// The specified context handle was not valid.
//


//
// MessageId: TPMAPI_E_TBS_COMMUNICATION_ERROR
//
// MessageText:
//
// An error occurred while communicating with the TBS.
//


//
// MessageId: TPMAPI_E_TPM_COMMAND_ERROR
//
// MessageText:
//
// The TPM returned an unexpected result.
//


//
// MessageId: TPMAPI_E_MESSAGE_TOO_LARGE
//
// MessageText:
//
// The message was too large for the encoding scheme.
//


//
// MessageId: TPMAPI_E_INVALID_ENCODING
//
// MessageText:
//
// The encoding in the blob was not recognized.
//


//
// MessageId: TPMAPI_E_INVALID_KEY_SIZE
//
// MessageText:
//
// The key size is not valid.
//


//
// MessageId: TPMAPI_E_ENCRYPTION_FAILED
//
// MessageText:
//
// The encryption operation failed.
//


//
// MessageId: TPMAPI_E_INVALID_KEY_PARAMS
//
// MessageText:
//
// The key parameters structure was not valid
//


//
// MessageId: TPMAPI_E_INVALID_MIGRATION_AUTHORIZATION_BLOB
//
// MessageText:
//
// The requested supplied data does not appear to be a valid migration authorization blob.
//


//
// MessageId: TPMAPI_E_INVALID_PCR_INDEX
//
// MessageText:
//
// The specified PCR index was invalid
//


//
// MessageId: TPMAPI_E_INVALID_DELEGATE_BLOB
//
// MessageText:
//
// The data given does not appear to be a valid delegate blob.
//


//
// MessageId: TPMAPI_E_INVALID_CONTEXT_PARAMS
//
// MessageText:
//
// One or more of the specified context parameters was not valid.
//


//
// MessageId: TPMAPI_E_INVALID_KEY_BLOB
//
// MessageText:
//
// The data given does not appear to be a valid key blob
//


//
// MessageId: TPMAPI_E_INVALID_PCR_DATA
//
// MessageText:
//
// The specified PCR data was invalid.
//


//
// MessageId: TPMAPI_E_INVALID_OWNER_AUTH
//
// MessageText:
//
// The format of the owner auth data was invalid.
//


//
// MessageId: TPMAPI_E_FIPS_RNG_CHECK_FAILED
//
// MessageText:
//
// The random number generated did not pass FIPS RNG check.
//


//
// MessageId: TPMAPI_E_EMPTY_TCG_LOG
//
// MessageText:
//
// The TCG Event Log does not contain any data.
//


//
// MessageId: TPMAPI_E_INVALID_TCG_LOG_ENTRY
//
// MessageText:
//
// An entry in the TCG Event Log was invalid.
//


//
// MessageId: TPMAPI_E_TCG_SEPARATOR_ABSENT
//
// MessageText:
//
// A TCG Separator was not found.
//


//
// MessageId: TPMAPI_E_TCG_INVALID_DIGEST_ENTRY
//
// MessageText:
//
// A digest value in a TCG Log entry did not match hashed data.
//


//
// MessageId: TPMAPI_E_POLICY_DENIES_OPERATION
//
// MessageText:
//
// The requested operation was blocked by current TPM policy. Please contact your system administrator for assistance.
//


//
// MessageId: TPMAPI_E_NV_BITS_NOT_DEFINED
//
// MessageText:
//
// The Windows TPM NV Bits index is not defined.
//


//
// MessageId: TPMAPI_E_NV_BITS_NOT_READY
//
// MessageText:
//
// The Windows TPM NV Bits index is not ready for use.
//


//
// MessageId: TPMAPI_E_SEALING_KEY_NOT_AVAILABLE
//
// MessageText:
//
// The TPM key that was used to seal the data is no longer available.
//


//
// MessageId: TPMAPI_E_NO_AUTHORIZATION_CHAIN_FOUND
//
// MessageText:
//
// An authorization chain could not be found that authorizes the PolicyAuthorize unseal.
//


//
// MessageId: TPMAPI_E_SVN_COUNTER_NOT_AVAILABLE
//
// MessageText:
//
// The SVN counter to which the authorization was bound is not available.
//


//
// MessageId: TPMAPI_E_OWNER_AUTH_NOT_NULL
//
// MessageText:
//
// The TPM Storage hierarchy (Owner) auth value is required to be NULL for this operation.
//


//
// MessageId: TPMAPI_E_ENDORSEMENT_AUTH_NOT_NULL
//
// MessageText:
//
// The TPM Endorsement hierarchy auth value is required to be NULL for this operation.
//


//
// MessageId: TPMAPI_E_AUTHORIZATION_REVOKED
//
// MessageText:
//
// The authorization to perform this operation has been revoked.
//


//
// MessageId: TPMAPI_E_MALFORMED_AUTHORIZATION_KEY
//
// MessageText:
//
// The authorization public key is malformed.
//


//
// MessageId: TPMAPI_E_AUTHORIZING_KEY_NOT_SUPPORTED
//
// MessageText:
//
// The authorization public key is not supported.
//


//
// MessageId: TPMAPI_E_INVALID_AUTHORIZATION_SIGNATURE
//
// MessageText:
//
// The authorization signature is invalid.
//


//
// MessageId: TPMAPI_E_MALFORMED_AUTHORIZATION_POLICY
//
// MessageText:
//
// The authorization policy is malformed.
//


//
// MessageId: TPMAPI_E_MALFORMED_AUTHORIZATION_OTHER
//
// MessageText:
//
// The authorization data is malformed.
//


//
// MessageId: TPMAPI_E_SEALING_KEY_CHANGED
//
// MessageText:
//
// The key used to unseal this data has changed since sealing the data. This may be the result of a TPM clear.
//


//
// TBS implementation error codes {0x0200..0x02ff}
//
//
// MessageId: TBSIMP_E_BUFFER_TOO_SMALL
//
// MessageText:
//
// The specified buffer was too small.
//


//
// MessageId: TBSIMP_E_CLEANUP_FAILED
//
// MessageText:
//
// The context could not be cleaned up.
//


//
// MessageId: TBSIMP_E_INVALID_CONTEXT_HANDLE
//
// MessageText:
//
// The specified context handle is invalid.
//


//
// MessageId: TBSIMP_E_INVALID_CONTEXT_PARAM
//
// MessageText:
//
// An invalid context parameter was specified.
//


//
// MessageId: TBSIMP_E_TPM_ERROR
//
// MessageText:
//
// An error occurred while communicating with the TPM
//


//
// MessageId: TBSIMP_E_HASH_BAD_KEY
//
// MessageText:
//
// No entry with the specified key was found.
//


//
// MessageId: TBSIMP_E_DUPLICATE_VHANDLE
//
// MessageText:
//
// The specified virtual handle matches a virtual handle already in use.
//


//
// MessageId: TBSIMP_E_INVALID_OUTPUT_POINTER
//
// MessageText:
//
// The pointer to the returned handle location was NULL or invalid
//


//
// MessageId: TBSIMP_E_INVALID_PARAMETER
//
// MessageText:
//
// One or more parameters is invalid
//


//
// MessageId: TBSIMP_E_RPC_INIT_FAILED
//
// MessageText:
//
// The RPC subsystem could not be initialized.
//


//
// MessageId: TBSIMP_E_SCHEDULER_NOT_RUNNING
//
// MessageText:
//
// The TBS scheduler is not running.
//


//
// MessageId: TBSIMP_E_COMMAND_CANCELED
//
// MessageText:
//
// The command was canceled.
//


//
// MessageId: TBSIMP_E_OUT_OF_MEMORY
//
// MessageText:
//
// There was not enough memory to fulfill the request
//


//
// MessageId: TBSIMP_E_LIST_NO_MORE_ITEMS
//
// MessageText:
//
// The specified list is empty, or the iteration has reached the end of the list.
//


//
// MessageId: TBSIMP_E_LIST_NOT_FOUND
//
// MessageText:
//
// The specified item was not found in the list.
//


//
// MessageId: TBSIMP_E_NOT_ENOUGH_SPACE
//
// MessageText:
//
// The TPM does not have enough space to load the requested resource.
//


//
// MessageId: TBSIMP_E_NOT_ENOUGH_TPM_CONTEXTS
//
// MessageText:
//
// There are too many TPM contexts in use.
//


//
// MessageId: TBSIMP_E_COMMAND_FAILED
//
// MessageText:
//
// The TPM command failed.
//


//
// MessageId: TBSIMP_E_UNKNOWN_ORDINAL
//
// MessageText:
//
// The TBS does not recognize the specified ordinal.
//


//
// MessageId: TBSIMP_E_RESOURCE_EXPIRED
//
// MessageText:
//
// The requested resource is no longer available.
//


//
// MessageId: TBSIMP_E_INVALID_RESOURCE
//
// MessageText:
//
// The resource type did not match.
//


//
// MessageId: TBSIMP_E_NOTHING_TO_UNLOAD
//
// MessageText:
//
// No resources can be unloaded.
//


//
// MessageId: TBSIMP_E_HASH_TABLE_FULL
//
// MessageText:
//
// No new entries can be added to the hash table.
//


//
// MessageId: TBSIMP_E_TOO_MANY_TBS_CONTEXTS
//
// MessageText:
//
// A new TBS context could not be created because there are too many open contexts.
//


//
// MessageId: TBSIMP_E_TOO_MANY_RESOURCES
//
// MessageText:
//
// A new virtual resource could not be created because there are too many open virtual resources.
//


//
// MessageId: TBSIMP_E_PPI_NOT_SUPPORTED
//
// MessageText:
//
// The physical presence interface is not supported.
//


//
// MessageId: TBSIMP_E_TPM_INCOMPATIBLE
//
// MessageText:
//
// TBS is not compatible with the version of TPM found on the system.
//


//
// MessageId: TBSIMP_E_NO_EVENT_LOG
//
// MessageText:
//
// No TCG event log is available.
//


//
// TPM Physical Presence implementation error codes {0x0300..0x03ff}
//
//
// MessageId: TPM_E_PPI_ACPI_FAILURE
//
// MessageText:
//
// A general error was detected when attempting to acquire the BIOS's response to a Physical Presence command.
//


//
// MessageId: TPM_E_PPI_USER_ABORT
//
// MessageText:
//
// The user failed to confirm the TPM operation request.
//


//
// MessageId: TPM_E_PPI_BIOS_FAILURE
//
// MessageText:
//
// The BIOS failure prevented the successful execution of the requested TPM operation (e.g. invalid TPM operation request, BIOS communication error with the TPM).
//


//
// MessageId: TPM_E_PPI_NOT_SUPPORTED
//
// MessageText:
//
// The BIOS does not support the physical presence interface.
//


//
// MessageId: TPM_E_PPI_BLOCKED_IN_BIOS
//
// MessageText:
//
// The Physical Presence command was blocked by current BIOS settings. The system owner may be able to reconfigure the BIOS settings to allow the command.
//


//
// Platform Crypto Provider (PCPTPM12.dll and future platform crypto providers)  error codes {0x0400..0x04ff}
//
//
// MessageId: TPM_E_PCP_ERROR_MASK
//
// MessageText:
//
// This is an error mask to convert Platform Crypto Provider errors to win errors.
//


//
// MessageId: TPM_E_PCP_DEVICE_NOT_READY
//
// MessageText:
//
// The Platform Crypto Device is currently not ready. It needs to be fully provisioned to be operational.
//


//
// MessageId: TPM_E_PCP_INVALID_HANDLE
//
// MessageText:
//
// The handle provided to the Platform Crypto Provider is invalid.
//


//
// MessageId: TPM_E_PCP_INVALID_PARAMETER
//
// MessageText:
//
// A parameter provided to the Platform Crypto Provider is invalid.
//


//
// MessageId: TPM_E_PCP_FLAG_NOT_SUPPORTED
//
// MessageText:
//
// A provided flag to the Platform Crypto Provider is not supported.
//


//
// MessageId: TPM_E_PCP_NOT_SUPPORTED
//
// MessageText:
//
// The requested operation is not supported by this Platform Crypto Provider.
//


//
// MessageId: TPM_E_PCP_BUFFER_TOO_SMALL
//
// MessageText:
//
// The buffer is too small to contain all data. No information has been written to the buffer.
//


//
// MessageId: TPM_E_PCP_INTERNAL_ERROR
//
// MessageText:
//
// An unexpected internal error has occurred in the Platform Crypto Provider.
//


//
// MessageId: TPM_E_PCP_AUTHENTICATION_FAILED
//
// MessageText:
//
// The authorization to use a provider object has failed.
//


//
// MessageId: TPM_E_PCP_AUTHENTICATION_IGNORED
//
// MessageText:
//
// The Platform Crypto Device has ignored the authorization for the provider object, to mitigate against a dictionary attack.
//


//
// MessageId: TPM_E_PCP_POLICY_NOT_FOUND
//
// MessageText:
//
// The referenced policy was not found.
//


//
// MessageId: TPM_E_PCP_PROFILE_NOT_FOUND
//
// MessageText:
//
// The referenced profile was not found.
//


//
// MessageId: TPM_E_PCP_VALIDATION_FAILED
//
// MessageText:
//
// The validation was not succesful.
//


//
// MessageId: TPM_E_PCP_WRONG_PARENT
//
// MessageText:
//
// An attempt was made to import or load a key under an incorrect storage parent.
//


//
// MessageId: TPM_E_KEY_NOT_LOADED
//
// MessageText:
//
// The TPM key is not loaded.
//


//
// MessageId: TPM_E_NO_KEY_CERTIFICATION
//
// MessageText:
//
// The TPM key certification has not been generated.
//


//
// MessageId: TPM_E_KEY_NOT_FINALIZED
//
// MessageText:
//
// The TPM key is not yet finalized.
//


//
// MessageId: TPM_E_ATTESTATION_CHALLENGE_NOT_SET
//
// MessageText:
//
// The TPM attestation challenge is not set.
//


//
// MessageId: TPM_E_NOT_PCR_BOUND
//
// MessageText:
//
// The TPM PCR info is not available.
//


//
// MessageId: TPM_E_KEY_ALREADY_FINALIZED
//
// MessageText:
//
// The TPM key is already finalized.
//


//
// MessageId: TPM_E_KEY_USAGE_POLICY_NOT_SUPPORTED
//
// MessageText:
//
// The TPM key usage policy is not supported.
//


//
// MessageId: TPM_E_KEY_USAGE_POLICY_INVALID
//
// MessageText:
//
// The TPM key usage policy is invalid.
//


//
// MessageId: TPM_E_SOFT_KEY_ERROR
//
// MessageText:
//
// There was a problem with the software key being imported into the TPM.
//


//
// MessageId: TPM_E_KEY_NOT_AUTHENTICATED
//
// MessageText:
//
// The TPM key is not authenticated.
//


//
// MessageId: TPM_E_PCP_KEY_NOT_AIK
//
// MessageText:
//
// The TPM key is not an AIK.
//


//
// MessageId: TPM_E_KEY_NOT_SIGNING_KEY
//
// MessageText:
//
// The TPM key is not a signing key.
//


//
// MessageId: TPM_E_LOCKED_OUT
//
// MessageText:
//
// The TPM is locked out.
//


//
// MessageId: TPM_E_CLAIM_TYPE_NOT_SUPPORTED
//
// MessageText:
//
// The claim type requested is not supported.
//


//
// MessageId: TPM_E_VERSION_NOT_SUPPORTED
//
// MessageText:
//
// TPM version is not supported.
//


//
// MessageId: TPM_E_BUFFER_LENGTH_MISMATCH
//
// MessageText:
//
// The buffer lengths do not match.
//


//
// MessageId: TPM_E_PCP_IFX_RSA_KEY_CREATION_BLOCKED
//
// MessageText:
//
// The RSA key creation is blocked on this TPM due to known security vulnerabilities.
//


//
// MessageId: TPM_E_PCP_TICKET_MISSING
//
// MessageText:
//
// A ticket required to use a key was not provided.
//


//
// MessageId: TPM_E_PCP_RAW_POLICY_NOT_SUPPORTED
//
// MessageText:
//
// This key has a raw policy so the KSP can't authenticate against it.
//


//
// MessageId: TPM_E_PCP_KEY_HANDLE_INVALIDATED
//
// MessageText:
//
// The TPM key's handle was unexpectedly invalidated due to a hardware or firmware issue.
//


//
// MessageId: TPM_E_PCP_UNSUPPORTED_PSS_SALT
//
// MessageText:
//
// The requested salt size for signing with RSAPSS does not match what the TPM uses.
//


//
// Misc error codes in TPM code {0x0500..0x05ff}
//
//
// MessageId: TPM_E_ZERO_EXHAUST_ENABLED
//
// MessageText:
//
// TPM related network operations are blocked as Zero Exhaust mode is enabled on client.
//


//
// If the application is designed to use TCG defined TPM return codes
// then undefine the Windows defined codes for the same symbols. The application
// declares usage of TCG return codes by defining WIN_OMIT_TSS_TPM_RETURN_CODES
// before including windows.h
//









































































































//
// =======================================================
// Facility Performance Logs & Alerts (PLA) Error Messages
// =======================================================
//
//
// MessageId: PLA_E_DCS_NOT_FOUND
//
// MessageText:
//
// Data Collector Set was not found.
//


//
// MessageId: PLA_E_DCS_IN_USE
//
// MessageText:
//
// The Data Collector Set or one of its dependencies is already in use.
//


//
// MessageId: PLA_E_TOO_MANY_FOLDERS
//
// MessageText:
//
// Unable to start Data Collector Set because there are too many folders.
//


//
// MessageId: PLA_E_NO_MIN_DISK
//
// MessageText:
//
// Not enough free disk space to start Data Collector Set.
//


//
// MessageId: PLA_E_DCS_ALREADY_EXISTS
//
// MessageText:
//
// Data Collector Set already exists.
//


//
// MessageId: PLA_S_PROPERTY_IGNORED
//
// MessageText:
//
// Property value will be ignored.
//


//
// MessageId: PLA_E_PROPERTY_CONFLICT
//
// MessageText:
//
// Property value conflict.
//


//
// MessageId: PLA_E_DCS_SINGLETON_REQUIRED
//
// MessageText:
//
// The current configuration for this Data Collector Set requires that it contain exactly one Data Collector.
//


//
// MessageId: PLA_E_CREDENTIALS_REQUIRED
//
// MessageText:
//
// A user account is required in order to commit the current Data Collector Set properties.
//


//
// MessageId: PLA_E_DCS_NOT_RUNNING
//
// MessageText:
//
// Data Collector Set is not running.
//


//
// MessageId: PLA_E_CONFLICT_INCL_EXCL_API
//
// MessageText:
//
// A conflict was detected in the list of include/exclude APIs. Do not specify the same API in both the include list and the exclude list.
//


//
// MessageId: PLA_E_NETWORK_EXE_NOT_VALID
//
// MessageText:
//
// The executable path you have specified refers to a network share or UNC path.
//


//
// MessageId: PLA_E_EXE_ALREADY_CONFIGURED
//
// MessageText:
//
// The executable path you have specified is already configured for API tracing.
//


//
// MessageId: PLA_E_EXE_PATH_NOT_VALID
//
// MessageText:
//
// The executable path you have specified does not exist. Verify that the specified path is correct.
//


//
// MessageId: PLA_E_DC_ALREADY_EXISTS
//
// MessageText:
//
// Data Collector already exists.
//


//
// MessageId: PLA_E_DCS_START_WAIT_TIMEOUT
//
// MessageText:
//
// The wait for the Data Collector Set start notification has timed out.
//


//
// MessageId: PLA_E_DC_START_WAIT_TIMEOUT
//
// MessageText:
//
// The wait for the Data Collector to start has timed out.
//


//
// MessageId: PLA_E_REPORT_WAIT_TIMEOUT
//
// MessageText:
//
// The wait for the report generation tool to finish has timed out.
//


//
// MessageId: PLA_E_NO_DUPLICATES
//
// MessageText:
//
// Duplicate items are not allowed.
//


//
// MessageId: PLA_E_EXE_FULL_PATH_REQUIRED
//
// MessageText:
//
// When specifying the executable that you want to trace, you must specify a full path to the executable and not just a filename.
//


//
// MessageId: PLA_E_INVALID_SESSION_NAME
//
// MessageText:
//
// The session name provided is invalid.
//


//
// MessageId: PLA_E_PLA_CHANNEL_NOT_ENABLED
//
// MessageText:
//
// The Event Log channel Microsoft-Windows-Diagnosis-PLA/Operational must be enabled to perform this operation.
//


//
// MessageId: PLA_E_TASKSCHED_CHANNEL_NOT_ENABLED
//
// MessageText:
//
// The Event Log channel Microsoft-Windows-TaskScheduler must be enabled to perform this operation.
//


//
// MessageId: PLA_E_RULES_MANAGER_FAILED
//
// MessageText:
//
// The execution of the Rules Manager failed.
//


//
// MessageId: PLA_E_CABAPI_FAILURE
//
// MessageText:
//
// An error occurred while attempting to compress or extract the data.
//


//
// =======================================================
// Full Volume Encryption Error Messages
// =======================================================
//
//
// MessageId: FVE_E_LOCKED_VOLUME
//
// MessageText:
//
// This drive is locked by BitLocker Drive Encryption. You must unlock this drive from Control Panel.
//


//
// MessageId: FVE_E_NOT_ENCRYPTED
//
// MessageText:
//
// This drive is not encrypted.
//


//
// MessageId: FVE_E_NO_TPM_BIOS
//
// MessageText:
//
// The BIOS did not correctly communicate with the Trusted Platform Module (TPM). Contact the computer manufacturer for BIOS upgrade instructions.
//


//
// MessageId: FVE_E_NO_MBR_METRIC
//
// MessageText:
//
// The BIOS did not correctly communicate with the master boot record (MBR). Contact the computer manufacturer for BIOS upgrade instructions.
//


//
// MessageId: FVE_E_NO_BOOTSECTOR_METRIC
//
// MessageText:
//
// A required TPM measurement is missing. If there is a bootable CD or DVD in your computer, remove it, restart the computer, and turn on BitLocker again. If the problem persists, ensure the master boot record is up to date.
//


//
// MessageId: FVE_E_NO_BOOTMGR_METRIC
//
// MessageText:
//
// The boot sector of this drive is not compatible with BitLocker Drive Encryption. Use the Bootrec.exe tool in the Windows Recovery Environment to update or repair the boot manager (BOOTMGR).
//


//
// MessageId: FVE_E_WRONG_BOOTMGR
//
// MessageText:
//
// The boot manager of this operating system is not compatible with BitLocker Drive Encryption. Use the Bootrec.exe tool in the Windows Recovery Environment to update or repair the boot manager (BOOTMGR).
//


//
// MessageId: FVE_E_SECURE_KEY_REQUIRED
//
// MessageText:
//
// At least one secure key protector is required for this operation to be performed.
//


//
// MessageId: FVE_E_NOT_ACTIVATED
//
// MessageText:
//
// BitLocker Drive Encryption is not enabled on this drive. Turn on BitLocker.
//


//
// MessageId: FVE_E_ACTION_NOT_ALLOWED
//
// MessageText:
//
// BitLocker Drive Encryption cannot perform the requested action. This condition may occur when two requests are issued at the same time. Wait a few moments and then try the action again.
//


//
// MessageId: FVE_E_AD_SCHEMA_NOT_INSTALLED
//
// MessageText:
//
// The Active Directory Domain Services forest does not contain the required attributes and classes to host BitLocker Drive Encryption or Trusted Platform Module information. Contact your domain administrator to verify that any required BitLocker Active Directory schema extensions have been installed.
//


//
// MessageId: FVE_E_AD_INVALID_DATATYPE
//
// MessageText:
//
// The type of the data obtained from Active Directory was not expected. The BitLocker recovery information may be missing or corrupted.
//


//
// MessageId: FVE_E_AD_INVALID_DATASIZE
//
// MessageText:
//
// The size of the data obtained from Active Directory was not expected. The BitLocker recovery information may be missing or corrupted.
//


//
// MessageId: FVE_E_AD_NO_VALUES
//
// MessageText:
//
// The attribute read from Active Directory does not contain any values. The BitLocker recovery information may be missing or corrupted.
//


//
// MessageId: FVE_E_AD_ATTR_NOT_SET
//
// MessageText:
//
// The attribute was not set. Verify that you are logged on with a domain account that has the ability to write information to Active Directory objects.
//


//
// MessageId: FVE_E_AD_GUID_NOT_FOUND
//
// MessageText:
//
// The specified attribute cannot be found in Active Directory Domain Services. Contact your domain administrator to verify that any required BitLocker Active Directory schema extensions have been installed.
//


//
// MessageId: FVE_E_BAD_INFORMATION
//
// MessageText:
//
// The BitLocker metadata for the encrypted drive is not valid. You can attempt to repair the drive to restore access.
//


//
// MessageId: FVE_E_TOO_SMALL
//
// MessageText:
//
// The drive cannot be encrypted because it does not have enough free space. Delete any unnecessary data on the drive to create additional free space and then try again.
//


//
// MessageId: FVE_E_SYSTEM_VOLUME
//
// MessageText:
//
// The drive cannot be encrypted because it contains system boot information. Create a separate partition for use as the system drive that contains the boot information and a second partition for use as the operating system drive and then encrypt the operating system drive.
//


//
// MessageId: FVE_E_FAILED_WRONG_FS
//
// MessageText:
//
// The drive cannot be encrypted because the file system is not supported.
//


//
// MessageId: FVE_E_BAD_PARTITION_SIZE
//
// MessageText:
//
// The file system size is larger than the partition size in the partition table. This drive may be corrupt or may have been tampered with. To use it with BitLocker, you must reformat the partition.
//


//
// MessageId: FVE_E_NOT_SUPPORTED
//
// MessageText:
//
// This drive cannot be encrypted.
//


//
// MessageId: FVE_E_BAD_DATA
//
// MessageText:
//
// The data is not valid.
//


//
// MessageId: FVE_E_VOLUME_NOT_BOUND
//
// MessageText:
//
// The data drive specified is not set to automatically unlock on the current computer and cannot be unlocked automatically.
//


//
// MessageId: FVE_E_TPM_NOT_OWNED
//
// MessageText:
//
// You must initialize the Trusted Platform Module (TPM) before you can use BitLocker Drive Encryption.
//


//
// MessageId: FVE_E_NOT_DATA_VOLUME
//
// MessageText:
//
// The operation attempted cannot be performed on an operating system drive.
//


//
// MessageId: FVE_E_AD_INSUFFICIENT_BUFFER
//
// MessageText:
//
// The buffer supplied to a function was insufficient to contain the returned data. Increase the buffer size before running the function again.
//


//
// MessageId: FVE_E_CONV_READ
//
// MessageText:
//
// A read operation failed while converting the drive. The drive was not converted. Please re-enable BitLocker.
//


//
// MessageId: FVE_E_CONV_WRITE
//
// MessageText:
//
// A write operation failed while converting the drive. The drive was not converted. Please re-enable BitLocker.
//


//
// MessageId: FVE_E_KEY_REQUIRED
//
// MessageText:
//
// One or more BitLocker key protectors are required. You cannot delete the last key on this drive.
//


//
// MessageId: FVE_E_CLUSTERING_NOT_SUPPORTED
//
// MessageText:
//
// Cluster configurations are not supported by BitLocker Drive Encryption.
//


//
// MessageId: FVE_E_VOLUME_BOUND_ALREADY
//
// MessageText:
//
// The drive specified is already configured to be automatically unlocked on the current computer.
//


//
// MessageId: FVE_E_OS_NOT_PROTECTED
//
// MessageText:
//
// The operating system drive is not protected by BitLocker Drive Encryption.
//


//
// MessageId: FVE_E_PROTECTION_DISABLED
//
// MessageText:
//
// BitLocker Drive Encryption has been suspended on this drive. All BitLocker key protectors configured for this drive are effectively disabled, and the drive will be automatically unlocked using an unencrypted (clear) key.
//


//
// MessageId: FVE_E_RECOVERY_KEY_REQUIRED
//
// MessageText:
//
// The drive you are attempting to lock does not have any key protectors available for encryption because BitLocker protection is currently suspended. Re-enable BitLocker to lock this drive.
//


//
// MessageId: FVE_E_FOREIGN_VOLUME
//
// MessageText:
//
// BitLocker cannot use the Trusted Platform Module (TPM) to protect a data drive. TPM protection can only be used with the operating system drive.
//


//
// MessageId: FVE_E_OVERLAPPED_UPDATE
//
// MessageText:
//
// The BitLocker metadata for the encrypted drive cannot be updated because it was locked for updating by another process. Please try this process again.
//


//
// MessageId: FVE_E_TPM_SRK_AUTH_NOT_ZERO
//
// MessageText:
//
// The authorization data for the storage root key (SRK) of the Trusted Platform Module (TPM) is not zero and is therefore incompatible with BitLocker. Please initialize the TPM before attempting to use it with BitLocker.
//


//
// MessageId: FVE_E_FAILED_SECTOR_SIZE
//
// MessageText:
//
// The drive encryption algorithm cannot be used on this sector size.
//


//
// MessageId: FVE_E_FAILED_AUTHENTICATION
//
// MessageText:
//
// The drive cannot be unlocked with the key provided. Confirm that you have provided the correct key and try again.
//


//
// MessageId: FVE_E_NOT_OS_VOLUME
//
// MessageText:
//
// The drive specified is not the operating system drive.
//


//
// MessageId: FVE_E_AUTOUNLOCK_ENABLED
//
// MessageText:
//
// BitLocker Drive Encryption cannot be turned off on the operating system drive until the auto unlock feature has been disabled for the fixed data drives and removable data drives associated with this computer.
//


//
// MessageId: FVE_E_WRONG_BOOTSECTOR
//
// MessageText:
//
// The system partition boot sector does not perform Trusted Platform Module (TPM) measurements. Use the Bootrec.exe tool in the Windows Recovery Environment to update or repair the boot sector.
//


//
// MessageId: FVE_E_WRONG_SYSTEM_FS
//
// MessageText:
//
// BitLocker Drive Encryption operating system drives must be formatted with the NTFS file system in order to be encrypted. Convert the drive to NTFS, and then turn on BitLocker.
//


//
// MessageId: FVE_E_POLICY_PASSWORD_REQUIRED
//
// MessageText:
//
// Group Policy settings require that a recovery password be specified before encrypting the drive.
//


//
// MessageId: FVE_E_CANNOT_SET_FVEK_ENCRYPTED
//
// MessageText:
//
// The drive encryption algorithm and key cannot be set on a previously encrypted drive. To encrypt this drive with BitLocker Drive Encryption, remove the previous encryption and then turn on BitLocker.
//


//
// MessageId: FVE_E_CANNOT_ENCRYPT_NO_KEY
//
// MessageText:
//
// BitLocker Drive Encryption cannot encrypt the specified drive because an encryption key is not available. Add a key protector to encrypt this drive.
//


//
// MessageId: FVE_E_BOOTABLE_CDDVD
//
// MessageText:
//
// BitLocker Drive Encryption detected bootable media (CD or DVD) in the computer. Remove the media and restart the computer before configuring BitLocker.
//


//
// MessageId: FVE_E_PROTECTOR_EXISTS
//
// MessageText:
//
// This key protector cannot be added. Only one key protector of this type is allowed for this drive.
//


//
// MessageId: FVE_E_RELATIVE_PATH
//
// MessageText:
//
// The recovery password file was not found because a relative path was specified. Recovery passwords must be saved to a fully qualified path. Environment variables configured on the computer can be used in the path.
//


//
// MessageId: FVE_E_PROTECTOR_NOT_FOUND
//
// MessageText:
//
// The specified key protector was not found on the drive. Try another key protector.
//


//
// MessageId: FVE_E_INVALID_KEY_FORMAT
//
// MessageText:
//
// The recovery key provided is corrupt and cannot be used to access the drive. An alternative recovery method, such as recovery password, a data recovery agent, or a backup version of the recovery key must be used to recover access to the drive.
//


//
// MessageId: FVE_E_INVALID_PASSWORD_FORMAT
//
// MessageText:
//
// The format of the recovery password provided is invalid. BitLocker recovery passwords are 48 digits. Verify that the recovery password is in the correct format and then try again.
//


//
// MessageId: FVE_E_FIPS_RNG_CHECK_FAILED
//
// MessageText:
//
// The random number generator check test failed.
//


//
// MessageId: FVE_E_FIPS_PREVENTS_RECOVERY_PASSWORD
//
// MessageText:
//
// The Group Policy setting requiring FIPS compliance prevents a local recovery password from being generated or used by BitLocker Drive Encryption. When operating in FIPS-compliant mode, BitLocker recovery options can be either a recovery key stored on a USB drive or recovery through a data recovery agent.
//


//
// MessageId: FVE_E_FIPS_PREVENTS_EXTERNAL_KEY_EXPORT
//
// MessageText:
//
// The Group Policy setting requiring FIPS compliance prevents the recovery password from being saved to Active Directory. When operating in FIPS-compliant mode, BitLocker recovery options can be either a recovery key stored on a USB drive or recovery through a data recovery agent. Check your Group Policy settings configuration.
//


//
// MessageId: FVE_E_NOT_DECRYPTED
//
// MessageText:
//
// The drive must be fully decrypted to complete this operation.
//


//
// MessageId: FVE_E_INVALID_PROTECTOR_TYPE
//
// MessageText:
//
// The key protector specified cannot be used for this operation.
//


//
// MessageId: FVE_E_NO_PROTECTORS_TO_TEST
//
// MessageText:
//
// No key protectors exist on the drive to perform the hardware test.
//


//
// MessageId: FVE_E_KEYFILE_NOT_FOUND
//
// MessageText:
//
// The BitLocker startup key or recovery password cannot be found on the USB device. Verify that you have the correct USB device, that the USB device is plugged into the computer on an active USB port, restart the computer, and then try again. If the problem persists, contact the computer manufacturer for BIOS upgrade instructions.
//


//
// MessageId: FVE_E_KEYFILE_INVALID
//
// MessageText:
//
// The BitLocker startup key or recovery password file provided is corrupt or invalid. Verify that you have the correct startup key or recovery password file and try again.
//


//
// MessageId: FVE_E_KEYFILE_NO_VMK
//
// MessageText:
//
// The BitLocker encryption key cannot be obtained from the startup key or recovery password. Verify that you have the correct startup key or recovery password and try again.
//


//
// MessageId: FVE_E_TPM_DISABLED
//
// MessageText:
//
// The Trusted Platform Module (TPM) is disabled. The TPM must be enabled, initialized, and have valid ownership before it can be used with BitLocker Drive Encryption.
//


//
// MessageId: FVE_E_NOT_ALLOWED_IN_SAFE_MODE
//
// MessageText:
//
// The BitLocker configuration of the specified drive cannot be managed because this computer is currently operating in Safe Mode. While in Safe Mode, BitLocker Drive Encryption can only be used for recovery purposes.
//


//
// MessageId: FVE_E_TPM_INVALID_PCR
//
// MessageText:
//
// The Trusted Platform Module (TPM) was unable to unlock the drive. Either the system boot information changed after choosing BitLocker settings or the PIN did not match. If the problem persists after several tries, there may be a hardware or firmware problem.
//


//
// MessageId: FVE_E_TPM_NO_VMK
//
// MessageText:
//
// The BitLocker encryption key cannot be obtained from the Trusted Platform Module (TPM).
//


//
// MessageId: FVE_E_PIN_INVALID
//
// MessageText:
//
// The BitLocker encryption key cannot be obtained from the Trusted Platform Module (TPM) and PIN.
//


//
// MessageId: FVE_E_AUTH_INVALID_APPLICATION
//
// MessageText:
//
// A boot application has changed since BitLocker Drive Encryption was enabled.
//


//
// MessageId: FVE_E_AUTH_INVALID_CONFIG
//
// MessageText:
//
// The Boot Configuration Data (BCD) settings have changed since BitLocker Drive Encryption was enabled.
//


//
// MessageId: FVE_E_FIPS_DISABLE_PROTECTION_NOT_ALLOWED
//
// MessageText:
//
// The Group Policy setting requiring FIPS compliance prohibits the use of unencrypted keys, which prevents BitLocker from being suspended on this drive. Please contact your domain administrator for more information.
//


//
// MessageId: FVE_E_FS_NOT_EXTENDED
//
// MessageText:
//
// This drive cannot be encrypted by BitLocker Drive Encryption because the file system does not extend to the end of the drive. Repartition this drive and then try again.
//


//
// MessageId: FVE_E_FIRMWARE_TYPE_NOT_SUPPORTED
//
// MessageText:
//
// BitLocker Drive Encryption cannot be enabled on the operating system drive. Contact the computer manufacturer for BIOS upgrade instructions.
//


//
// MessageId: FVE_E_NO_LICENSE
//
// MessageText:
//
// This version of Windows does not include BitLocker Drive Encryption. To use BitLocker Drive Encryption, please upgrade the operating system.
//


//
// MessageId: FVE_E_NOT_ON_STACK
//
// MessageText:
//
// BitLocker Drive Encryption cannot be used because critical BitLocker system files are missing or corrupted. Use Windows Startup Repair to restore these files to your computer.
//


//
// MessageId: FVE_E_FS_MOUNTED
//
// MessageText:
//
// The drive cannot be locked when the drive is in use.
//


//
// MessageId: FVE_E_TOKEN_NOT_IMPERSONATED
//
// MessageText:
//
// The access token associated with the current thread is not an impersonated token.
//


//
// MessageId: FVE_E_DRY_RUN_FAILED
//
// MessageText:
//
// The BitLocker encryption key cannot be obtained. Verify that the Trusted Platform Module (TPM) is enabled and ownership has been taken. If this computer does not have a TPM, verify that the USB drive is inserted and available.
//


//
// MessageId: FVE_E_REBOOT_REQUIRED
//
// MessageText:
//
// You must restart your computer before continuing with BitLocker Drive Encryption.
//


//
// MessageId: FVE_E_DEBUGGER_ENABLED
//
// MessageText:
//
// Drive encryption cannot occur while boot debugging is enabled. Use the bcdedit command-line tool to turn off boot debugging.
//


//
// MessageId: FVE_E_RAW_ACCESS
//
// MessageText:
//
// No action was taken as BitLocker Drive Encryption is in raw access mode.
//


//
// MessageId: FVE_E_RAW_BLOCKED
//
// MessageText:
//
// BitLocker Drive Encryption cannot enter raw access mode for this drive because the drive is currently in use.
//


//
// MessageId: FVE_E_BCD_APPLICATIONS_PATH_INCORRECT
//
// MessageText:
//
// The path specified in the Boot Configuration Data (BCD) for a BitLocker Drive Encryption integrity-protected application is incorrect. Please verify and correct your BCD settings and try again.
//


//
// MessageId: FVE_E_NOT_ALLOWED_IN_VERSION
//
// MessageText:
//
// BitLocker Drive Encryption can only be used for limited provisioning or recovery purposes when the computer is running in pre-installation or recovery environments.
//


//
// MessageId: FVE_E_NO_AUTOUNLOCK_MASTER_KEY
//
// MessageText:
//
// The auto-unlock master key was not available from the operating system drive.
//


//
// MessageId: FVE_E_MOR_FAILED
//
// MessageText:
//
// The system firmware failed to enable clearing of system memory when the computer was restarted.
//


//
// MessageId: FVE_E_HIDDEN_VOLUME
//
// MessageText:
//
// The hidden drive cannot be encrypted.
//


//
// MessageId: FVE_E_TRANSIENT_STATE
//
// MessageText:
//
// BitLocker encryption keys were ignored because the drive was in a transient state.
//


//
// MessageId: FVE_E_PUBKEY_NOT_ALLOWED
//
// MessageText:
//
// Public key based protectors are not allowed on this drive.
//


//
// MessageId: FVE_E_VOLUME_HANDLE_OPEN
//
// MessageText:
//
// BitLocker Drive Encryption is already performing an operation on this drive. Please complete all operations before continuing.
//


//
// MessageId: FVE_E_NO_FEATURE_LICENSE
//
// MessageText:
//
// This version of Windows does not support this feature of BitLocker Drive Encryption. To use this feature, upgrade the operating system.
//


//
// MessageId: FVE_E_INVALID_STARTUP_OPTIONS
//
// MessageText:
//
// The Group Policy settings for BitLocker startup options are in conflict and cannot be applied. Contact your system administrator for more information.
//


//
// MessageId: FVE_E_POLICY_RECOVERY_PASSWORD_NOT_ALLOWED
//
// MessageText:
//
// Group Policy settings do not permit the creation of a recovery password.
//


//
// MessageId: FVE_E_POLICY_RECOVERY_PASSWORD_REQUIRED
//
// MessageText:
//
// Group Policy settings require the creation of a recovery password.
//


//
// MessageId: FVE_E_POLICY_RECOVERY_KEY_NOT_ALLOWED
//
// MessageText:
//
// Group Policy settings do not permit the creation of a recovery key.
//


//
// MessageId: FVE_E_POLICY_RECOVERY_KEY_REQUIRED
//
// MessageText:
//
// Group Policy settings require the creation of a recovery key.
//


//
// MessageId: FVE_E_POLICY_STARTUP_PIN_NOT_ALLOWED
//
// MessageText:
//
// Group Policy settings do not permit the use of a PIN at startup. Please choose a different BitLocker startup option.
//


//
// MessageId: FVE_E_POLICY_STARTUP_PIN_REQUIRED
//
// MessageText:
//
// Group Policy settings require the use of a PIN at startup. Please choose this BitLocker startup option.
//


//
// MessageId: FVE_E_POLICY_STARTUP_KEY_NOT_ALLOWED
//
// MessageText:
//
// Group Policy settings do not permit the use of a startup key. Please choose a different BitLocker startup option.
//


//
// MessageId: FVE_E_POLICY_STARTUP_KEY_REQUIRED
//
// MessageText:
//
// Group Policy settings require the use of a startup key. Please choose this BitLocker startup option.
//


//
// MessageId: FVE_E_POLICY_STARTUP_PIN_KEY_NOT_ALLOWED
//
// MessageText:
//
// Group Policy settings do not permit the use of a startup key and PIN. Please choose a different BitLocker startup option.
//


//
// MessageId: FVE_E_POLICY_STARTUP_PIN_KEY_REQUIRED
//
// MessageText:
//
// Group Policy settings require the use of a startup key and PIN. Please choose this BitLocker startup option.
//


//
// MessageId: FVE_E_POLICY_STARTUP_TPM_NOT_ALLOWED
//
// MessageText:
//
// Group policy does not permit the use of TPM-only at startup. Please choose a different BitLocker startup option.
//


//
// MessageId: FVE_E_POLICY_STARTUP_TPM_REQUIRED
//
// MessageText:
//
// Group Policy settings require the use of TPM-only at startup. Please choose this BitLocker startup option.
//


//
// MessageId: FVE_E_POLICY_INVALID_PIN_LENGTH
//
// MessageText:
//
// The PIN provided does not meet minimum or maximum length requirements.
//


//
// MessageId: FVE_E_KEY_PROTECTOR_NOT_SUPPORTED
//
// MessageText:
//
// The key protector is not supported by the version of BitLocker Drive Encryption currently on the drive. Upgrade the drive to add the key protector.
//


//
// MessageId: FVE_E_POLICY_PASSPHRASE_NOT_ALLOWED
//
// MessageText:
//
// Group Policy settings do not permit the creation of a password.
//


//
// MessageId: FVE_E_POLICY_PASSPHRASE_REQUIRED
//
// MessageText:
//
// Group Policy settings require the creation of a password.
//


//
// MessageId: FVE_E_FIPS_PREVENTS_PASSPHRASE
//
// MessageText:
//
// The Group Policy setting requiring FIPS compliance prevents passwords from being generated or used. Please contact your system administrator for more information.
//


//
// MessageId: FVE_E_OS_VOLUME_PASSPHRASE_NOT_ALLOWED
//
// MessageText:
//
// A password cannot be added to the operating system drive.
//


//
// MessageId: FVE_E_INVALID_BITLOCKER_OID
//
// MessageText:
//
// The BitLocker object identifier (OID) on the drive appears to be invalid or corrupt. Use manage-BDE to reset the OID on this drive.
//


//
// MessageId: FVE_E_VOLUME_TOO_SMALL
//
// MessageText:
//
// The drive is too small to be protected using BitLocker Drive Encryption.
//


//
// MessageId: FVE_E_DV_NOT_SUPPORTED_ON_FS
//
// MessageText:
//
// The selected discovery drive type is incompatible with the file system on the drive. BitLocker To Go discovery drives must be created on FAT formatted drives.
//


//
// MessageId: FVE_E_DV_NOT_ALLOWED_BY_GP
//
// MessageText:
//
// The selected discovery drive type is not allowed by the computer's Group Policy settings. Verify that Group Policy settings allow the creation of discovery drives for use with BitLocker To Go.
//


//
// MessageId: FVE_E_POLICY_USER_CERTIFICATE_NOT_ALLOWED
//
// MessageText:
//
// Group Policy settings do not permit user certificates such as smart cards to be used with BitLocker Drive Encryption.
//


//
// MessageId: FVE_E_POLICY_USER_CERTIFICATE_REQUIRED
//
// MessageText:
//
// Group Policy settings require that you have a valid user certificate, such as a smart card, to be used with BitLocker Drive Encryption.
//


//
// MessageId: FVE_E_POLICY_USER_CERT_MUST_BE_HW
//
// MessageText:
//
// Group Policy settings requires that you use a smart card-based key protector with BitLocker Drive Encryption.
//


//
// MessageId: FVE_E_POLICY_USER_CONFIGURE_FDV_AUTOUNLOCK_NOT_ALLOWED
//
// MessageText:
//
// Group Policy settings do not permit BitLocker-protected fixed data drives to be automatically unlocked.
//


//
// MessageId: FVE_E_POLICY_USER_CONFIGURE_RDV_AUTOUNLOCK_NOT_ALLOWED
//
// MessageText:
//
// Group Policy settings do not permit BitLocker-protected removable data drives to be automatically unlocked.
//


//
// MessageId: FVE_E_POLICY_USER_CONFIGURE_RDV_NOT_ALLOWED
//
// MessageText:
//
// Group Policy settings do not permit you to configure BitLocker Drive Encryption on removable data drives.
//


//
// MessageId: FVE_E_POLICY_USER_ENABLE_RDV_NOT_ALLOWED
//
// MessageText:
//
// Group Policy settings do not permit you to turn on BitLocker Drive Encryption on removable data drives. Please contact your system administrator if you need to turn on BitLocker.
//


//
// MessageId: FVE_E_POLICY_USER_DISABLE_RDV_NOT_ALLOWED
//
// MessageText:
//
// Group Policy settings do not permit turning off BitLocker Drive Encryption on removable data drives. Please contact your system administrator if you need to turn off BitLocker.
//


//
// MessageId: FVE_E_POLICY_INVALID_PASSPHRASE_LENGTH
//
// MessageText:
//
// Your password does not meet minimum password length requirements. By default, passwords must be at least 8 characters in length. Check with your system administrator for the password length requirement in your organization.
//


//
// MessageId: FVE_E_POLICY_PASSPHRASE_TOO_SIMPLE
//
// MessageText:
//
// Your password does not meet the complexity requirements set by your system administrator. Try adding upper and lowercase characters, numbers, and symbols.
//


//
// MessageId: FVE_E_RECOVERY_PARTITION
//
// MessageText:
//
// This drive cannot be encrypted because it is reserved for Windows System Recovery Options.
//


//
// MessageId: FVE_E_POLICY_CONFLICT_FDV_RK_OFF_AUK_ON
//
// MessageText:
//
// BitLocker Drive Encryption cannot be applied to this drive because of conflicting Group Policy settings. BitLocker cannot be configured to automatically unlock fixed data drives when user recovery options are disabled. If you want BitLocker-protected fixed data drives to be automatically unlocked after key validation has occurred, please ask your system administrator to resolve the settings conflict before enabling BitLocker.
//


//
// MessageId: FVE_E_POLICY_CONFLICT_RDV_RK_OFF_AUK_ON
//
// MessageText:
//
// BitLocker Drive Encryption cannot be applied to this drive because of conflicting Group Policy settings. BitLocker cannot be configured to automatically unlock removable data drives when user recovery option are disabled. If you want BitLocker-protected removable data drives to be automatically unlocked after key validation has occurred, please ask your system administrator to resolve the settings conflict before enabling BitLocker.
//


//
// MessageId: FVE_E_NON_BITLOCKER_OID
//
// MessageText:
//
// The Enhanced Key Usage (EKU) attribute of the specified certificate does not permit it to be used for BitLocker Drive Encryption. BitLocker does not require that a certificate have an EKU attribute, but if one is configured it must be set to an object identifier (OID) that matches the OID configured for BitLocker.
//


//
// MessageId: FVE_E_POLICY_PROHIBITS_SELFSIGNED
//
// MessageText:
//
// BitLocker Drive Encryption cannot be applied to this drive as currently configured because of Group Policy settings. The certificate you provided for drive encryption is self-signed. Current Group Policy settings do not permit the use of self-signed certificates. Obtain a new certificate from your certification authority before attempting to enable BitLocker.
//


//
// MessageId: FVE_E_POLICY_CONFLICT_RO_AND_STARTUP_KEY_REQUIRED
//
// MessageText:
//
// BitLocker Encryption cannot be applied to this drive because of conflicting Group Policy settings. When write access to drives not protected by BitLocker is denied, the use of a USB startup key cannot be required. Please have your system administrator resolve these policy conflicts before attempting to enable BitLocker.
//


//
// MessageId: FVE_E_CONV_RECOVERY_FAILED
//
// MessageText:
//
// BitLocker Drive Encryption failed to recover from an abruptly terminated conversion. This could be due to either all conversion logs being corrupted or the media being write-protected.
//


//
// MessageId: FVE_E_VIRTUALIZED_SPACE_TOO_BIG
//
// MessageText:
//
// The requested virtualization size is too big.
//


//
// MessageId: FVE_E_POLICY_CONFLICT_OSV_RP_OFF_ADB_ON
//
// MessageText:
//
// BitLocker Drive Encryption cannot be applied to this drive because there are conflicting Group Policy settings for recovery options on operating system drives. Storing recovery information to Active Directory Domain Services cannot be required when the generation of recovery passwords is not permitted. Please have your system administrator resolve these policy conflicts before attempting to enable BitLocker.
//


//
// MessageId: FVE_E_POLICY_CONFLICT_FDV_RP_OFF_ADB_ON
//
// MessageText:
//
// BitLocker Drive Encryption cannot be applied to this drive because there are conflicting Group Policy settings for recovery options on fixed data drives. Storing recovery information to Active Directory Domain Services cannot be required when the generation of recovery passwords is not permitted. Please have your system administrator resolve these policy conflicts before attempting to enable BitLocker.
//


//
// MessageId: FVE_E_POLICY_CONFLICT_RDV_RP_OFF_ADB_ON
//
// MessageText:
//
// BitLocker Drive Encryption cannot be applied to this drive because there are conflicting Group Policy settings for recovery options on removable data drives. Storing recovery information to Active Directory Domain Services cannot be required when the generation of recovery passwords is not permitted. Please have your system administrator resolve these policy conflicts before attempting to enable BitLocker.
//


//
// MessageId: FVE_E_NON_BITLOCKER_KU
//
// MessageText:
//
// The Key Usage (KU) attribute of the specified certificate does not permit it to be used for BitLocker Drive Encryption. BitLocker does not require that a certificate have a KU attribute, but if one is configured it must be set to either Key Encipherment or Key Agreement.
//


//
// MessageId: FVE_E_PRIVATEKEY_AUTH_FAILED
//
// MessageText:
//
// The private key associated with the specified certificate cannot be authorized. The private key authorization was either not provided or the provided authorization was invalid.
//


//
// MessageId: FVE_E_REMOVAL_OF_DRA_FAILED
//
// MessageText:
//
// Removal of the data recovery agent certificate must be done using the Certificates snap-in.
//


//
// MessageId: FVE_E_OPERATION_NOT_SUPPORTED_ON_VISTA_VOLUME
//
// MessageText:
//
// This drive was encrypted using the version of BitLocker Drive Encryption included with Windows Vista and Windows Server 2008 which does not support organizational identifiers. To specify organizational identifiers for this drive upgrade the drive encryption to the latest version using the "manage-bde -upgrade" command.
//


//
// MessageId: FVE_E_CANT_LOCK_AUTOUNLOCK_ENABLED_VOLUME
//
// MessageText:
//
// The drive cannot be locked because it is automatically unlocked on this computer.  Remove the automatic unlock protector to lock this drive.
//


//
// MessageId: FVE_E_FIPS_HASH_KDF_NOT_ALLOWED
//
// MessageText:
//
// The default BitLocker Key Derivation Function SP800-56A for ECC smart cards is not supported by your smart card. The Group Policy setting requiring FIPS-compliance prevents BitLocker from using any other key derivation function for encryption. You have to use a FIPS compliant smart card in FIPS restricted environments.
//


//
// MessageId: FVE_E_ENH_PIN_INVALID
//
// MessageText:
//
// The BitLocker encryption key could not be obtained from the Trusted Platform Module (TPM) and enhanced PIN. Try using a PIN containing only numerals.
//


//
// MessageId: FVE_E_INVALID_PIN_CHARS
//
// MessageText:
//
// The requested TPM PIN contains invalid characters.
//


//
// MessageId: FVE_E_INVALID_DATUM_TYPE
//
// MessageText:
//
// The management information stored on the drive contained an unknown type. If you are using an old version of Windows, try accessing the drive from the latest version.
//


//
// MessageId: FVE_E_EFI_ONLY
//
// MessageText:
//
// The feature is only supported on EFI systems.
//


//
// MessageId: FVE_E_MULTIPLE_NKP_CERTS
//
// MessageText:
//
// More than one Network Key Protector certificate has been found on the system.
//


//
// MessageId: FVE_E_REMOVAL_OF_NKP_FAILED
//
// MessageText:
//
// Removal of the Network Key Protector certificate must be done using the Certificates snap-in.
//


//
// MessageId: FVE_E_INVALID_NKP_CERT
//
// MessageText:
//
// An invalid certificate has been found in the Network Key Protector certificate store.
//


//
// MessageId: FVE_E_NO_EXISTING_PIN
//
// MessageText:
//
// This drive isn't protected with a PIN.
//


//
// MessageId: FVE_E_PROTECTOR_CHANGE_PIN_MISMATCH
//
// MessageText:
//
// Please enter the correct current PIN.
//


//
// MessageId: FVE_E_PIN_PROTECTOR_CHANGE_BY_STD_USER_DISALLOWED
//
// MessageText:
//
// You must be logged on with an administrator account to change the PIN. Click the link to reset the PIN as an administrator.
//


//
// MessageId: FVE_E_PROTECTOR_CHANGE_MAX_PIN_CHANGE_ATTEMPTS_REACHED
//
// MessageText:
//
// BitLocker has disabled PIN changes after too many failed requests. Click the link to reset the PIN as an administrator.
//


//
// MessageId: FVE_E_POLICY_PASSPHRASE_REQUIRES_ASCII
//
// MessageText:
//
// Your system administrator requires that passwords contain only printable ASCII characters. This includes unaccented letters (A-Z, a-z), numbers (0-9), space, arithmetic signs, common punctuation, separators, and the following symbols: # $ & @ ^ _ ~ .
//


//
// MessageId: FVE_E_FULL_ENCRYPTION_NOT_ALLOWED_ON_TP_STORAGE
//
// MessageText:
//
// BitLocker Drive Encryption only supports Used Space Only encryption on thin provisioned storage.
//


//
// MessageId: FVE_E_WIPE_NOT_ALLOWED_ON_TP_STORAGE
//
// MessageText:
//
// BitLocker Drive Encryption does not support wiping free space on thin provisioned storage.
//


//
// MessageId: FVE_E_KEY_LENGTH_NOT_SUPPORTED_BY_EDRIVE
//
// MessageText:
//
// The required authentication key length is not supported by the drive.
//


//
// MessageId: FVE_E_NO_EXISTING_PASSPHRASE
//
// MessageText:
//
// This drive isn't protected with a password.
//


//
// MessageId: FVE_E_PROTECTOR_CHANGE_PASSPHRASE_MISMATCH
//
// MessageText:
//
// Please enter the correct current password.
//


//
// MessageId: FVE_E_PASSPHRASE_TOO_LONG
//
// MessageText:
//
// The password cannot exceed 256 characters.
//


//
// MessageId: FVE_E_NO_PASSPHRASE_WITH_TPM
//
// MessageText:
//
// A password key protector cannot be added because a TPM protector exists on the drive.
//


//
// MessageId: FVE_E_NO_TPM_WITH_PASSPHRASE
//
// MessageText:
//
// A TPM key protector cannot be added because a password protector exists on the drive.
//


//
// MessageId: FVE_E_NOT_ALLOWED_ON_CSV_STACK
//
// MessageText:
//
// This command can only be performed from the coordinator node for the specified CSV volume.
//


//
// MessageId: FVE_E_NOT_ALLOWED_ON_CLUSTER
//
// MessageText:
//
// This command cannot be performed on a volume when it is part of a cluster.
//


//
// MessageId: FVE_E_EDRIVE_NO_FAILOVER_TO_SW
//
// MessageText:
//
// BitLocker did not revert to using BitLocker software encryption due to group policy configuration.
//


//
// MessageId: FVE_E_EDRIVE_BAND_IN_USE
//
// MessageText:
//
// The drive cannot be managed by BitLocker because the drive's hardware encryption feature is already in use.
//


//
// MessageId: FVE_E_EDRIVE_DISALLOWED_BY_GP
//
// MessageText:
//
// Group Policy settings do not allow the use of hardware-based encryption.
//


//
// MessageId: FVE_E_EDRIVE_INCOMPATIBLE_VOLUME
//
// MessageText:
//
// The drive specified does not support hardware-based encryption.
//


//
// MessageId: FVE_E_NOT_ALLOWED_TO_UPGRADE_WHILE_CONVERTING
//
// MessageText:
//
// BitLocker cannot be upgraded during disk encryption or decryption.
//


//
// MessageId: FVE_E_EDRIVE_DV_NOT_SUPPORTED
//
// MessageText:
//
// Discovery Volumes are not supported for volumes using hardware encryption.
//


//
// MessageId: FVE_E_NO_PREBOOT_KEYBOARD_DETECTED
//
// MessageText:
//
// No pre-boot keyboard detected. The user may not be able to provide required input to unlock the volume.
//


//
// MessageId: FVE_E_NO_PREBOOT_KEYBOARD_OR_WINRE_DETECTED
//
// MessageText:
//
// No pre-boot keyboard or Windows Recovery Environment detected. The user may not be able to provide required input to unlock the volume.
//


//
// MessageId: FVE_E_POLICY_REQUIRES_STARTUP_PIN_ON_TOUCH_DEVICE
//
// MessageText:
//
// Group Policy settings require the creation of a startup PIN, but a pre-boot keyboard is not available on this device. The user may not be able to provide required input to unlock the volume.
//


//
// MessageId: FVE_E_POLICY_REQUIRES_RECOVERY_PASSWORD_ON_TOUCH_DEVICE
//
// MessageText:
//
// Group Policy settings require the creation of a recovery password, but neither a pre-boot keyboard nor Windows Recovery Environment is available on this device. The user may not be able to provide required input to unlock the volume.
//


//
// MessageId: FVE_E_WIPE_CANCEL_NOT_APPLICABLE
//
// MessageText:
//
// Wipe of free space is not currently taking place.
//


//
// MessageId: FVE_E_SECUREBOOT_DISABLED
//
// MessageText:
//
// BitLocker cannot use Secure Boot for platform integrity because Secure Boot has been disabled.
//


//
// MessageId: FVE_E_SECUREBOOT_CONFIGURATION_INVALID
//
// MessageText:
//
// BitLocker cannot use Secure Boot for platform integrity because the Secure Boot configuration does not meet the requirements for BitLocker.
//


//
// MessageId: FVE_E_EDRIVE_DRY_RUN_FAILED
//
// MessageText:
//
// Your computer doesn't support BitLocker hardware-based encryption. Check with your computer manufacturer for firmware updates.
//


//
// MessageId: FVE_E_SHADOW_COPY_PRESENT
//
// MessageText:
//
// BitLocker cannot be enabled on the volume because it contains a Volume Shadow Copy. Remove all Volume Shadow Copies before encrypting the volume.
//


//
// MessageId: FVE_E_POLICY_INVALID_ENHANCED_BCD_SETTINGS
//
// MessageText:
//
// BitLocker Drive Encryption cannot be applied to this drive because the Group Policy setting for Enhanced Boot Configuration Data contains invalid data. Please have your system administrator resolve this invalid configuration before attempting to enable BitLocker.
//


//
// MessageId: FVE_E_EDRIVE_INCOMPATIBLE_FIRMWARE
//
// MessageText:
//
// This PC's firmware is not capable of supporting hardware encryption.
//


//
// MessageId: FVE_E_PROTECTOR_CHANGE_MAX_PASSPHRASE_CHANGE_ATTEMPTS_REACHED
//
// MessageText:
//
// BitLocker has disabled password changes after too many failed requests. Click the link to reset the password as an administrator.
//


//
// MessageId: FVE_E_PASSPHRASE_PROTECTOR_CHANGE_BY_STD_USER_DISALLOWED
//
// MessageText:
//
// You must be logged on with an administrator account to change the password. Click the link to reset the password as an administrator.
//


//
// MessageId: FVE_E_LIVEID_ACCOUNT_SUSPENDED
//
// MessageText:
//
// BitLocker cannot save the recovery password because the specified Microsoft account is Suspended.
//


//
// MessageId: FVE_E_LIVEID_ACCOUNT_BLOCKED
//
// MessageText:
//
// BitLocker cannot save the recovery password because the specified Microsoft account is Blocked.
//


//
// MessageId: FVE_E_NOT_PROVISIONED_ON_ALL_VOLUMES
//
// MessageText:
//
// This PC is not provisioned to support device encryption. Please enable BitLocker on all volumes to comply with device encryption policy.
//


//
// MessageId: FVE_E_DE_FIXED_DATA_NOT_SUPPORTED
//
// MessageText:
//
// This PC cannot support device encryption because unencrypted fixed data volumes are present.
//


//
// MessageId: FVE_E_DE_HARDWARE_NOT_COMPLIANT
//
// MessageText:
//
// This PC does not meet the hardware requirements to support device encryption.
//


//
// MessageId: FVE_E_DE_WINRE_NOT_CONFIGURED
//
// MessageText:
//
// This PC cannot support device encryption because WinRE is not properly configured.
//


//
// MessageId: FVE_E_DE_PROTECTION_SUSPENDED
//
// MessageText:
//
// Protection is enabled on the volume but has been suspended. This is likely to have happened due to an update being applied to your system. Please try again after a reboot.
//


//
// MessageId: FVE_E_DE_OS_VOLUME_NOT_PROTECTED
//
// MessageText:
//
// This PC is not provisioned to support device encryption.
//


//
// MessageId: FVE_E_DE_DEVICE_LOCKEDOUT
//
// MessageText:
//
// Device Lock has been triggered due to too many incorrect password attempts.
//


//
// MessageId: FVE_E_DE_PROTECTION_NOT_YET_ENABLED
//
// MessageText:
//
// Protection has not been enabled on the volume. Enabling protection requires a connected account. If you already have a connected account and are seeing this error, please refer to the event log for more information.
//


//
// MessageId: FVE_E_INVALID_PIN_CHARS_DETAILED
//
// MessageText:
//
// Your PIN can only contain numbers from 0 to 9.
//


//
// MessageId: FVE_E_DEVICE_LOCKOUT_COUNTER_UNAVAILABLE
//
// MessageText:
//
// BitLocker cannot use hardware replay protection because no counter is available on your PC.
//


//
// MessageId: FVE_E_DEVICELOCKOUT_COUNTER_MISMATCH
//
// MessageText:
//
// Device Lockout state validation failed due to counter mismatch.
//


//
// MessageId: FVE_E_BUFFER_TOO_LARGE
//
// MessageText:
//
// The input buffer is too large.
//


//
// MessageId: FVE_E_NO_SUCH_CAPABILITY_ON_TARGET
//
// MessageText:
//
// The target of an invocation does not support requested capability.
//


//
// MessageId: FVE_E_DE_PREVENTED_FOR_OS
//
// MessageText:
//
// Device encryption is currently blocked by this PC's configuration.
//


//
// MessageId: FVE_E_DE_VOLUME_OPTED_OUT
//
// MessageText:
//
// This drive has been opted out of device encryption.
//


//
// MessageId: FVE_E_DE_VOLUME_NOT_SUPPORTED
//
// MessageText:
//
// Device encryption isn't available for this drive.
//


//
// MessageId: FVE_E_EOW_NOT_SUPPORTED_IN_VERSION
//
// MessageText:
//
// The encrypt on write mode for BitLocker is not supported in this version of Windows. You can turn on BitLocker without using the encrypt on write mode.
//


//
// MessageId: FVE_E_ADBACKUP_NOT_ENABLED
//
// MessageText:
//
// Group policy prevents you from backing up your recovery password to Active Directory for this drive type. For more info, contact your system administrator.
//


//
// MessageId: FVE_E_VOLUME_EXTEND_PREVENTS_EOW_DECRYPT
//
// MessageText:
//
// Device encryption can't be turned off while this drive is being encrypted. Please try again later.
//


//
// MessageId: FVE_E_NOT_DE_VOLUME
//
// MessageText:
//
// This action isn't supported because this drive isn't automatically managed with device encryption.
//


//
// MessageId: FVE_E_PROTECTION_CANNOT_BE_DISABLED
//
// MessageText:
//
// BitLocker can't be suspended on this drive until the next restart.
//


//
// MessageId: FVE_E_OSV_KSR_NOT_ALLOWED
//
// MessageText:
//
// BitLocker Drive Encryption policy does not allow KSR operation with protected OS volume.
//


//
// MessageId: FVE_E_AD_BACKUP_REQUIRED_POLICY_NOT_SET_OS_DRIVE
//
// MessageText:
//
// Recovery Password Rotation cannot be performed because Active Directory Backup policy is not set to Required for OS drive.
//


//
// MessageId: FVE_E_AD_BACKUP_REQUIRED_POLICY_NOT_SET_FIXED_DRIVE
//
// MessageText:
//
// Recovery Password Rotation cannot be performed because Active Directory Backup policy is not set to Required for Fixed drive.
//


//
// MessageId: FVE_E_AD_BACKUP_REQUIRED_POLICY_NOT_SET_REMOVABLE_DRIVE
//
// MessageText:
//
// Recovery Password Rotation cannot be performed because Active Directory Backup policy is not set to Required for Removable drive.
//


//
// MessageId: FVE_E_KEY_ROTATION_NOT_SUPPORTED
//
// MessageText:
//
// Bitlocker Recovery Password rotation not supported.
//


//
// MessageId: FVE_E_EXECUTE_REQUEST_SENT_TOO_SOON
//
// MessageText:
//
// An Instance of Server issued recovery password rotation already in Progress. No second RotateRecoveryPasswords request allowed within 1 hour interval.
//


//
// MessageId: FVE_E_KEY_ROTATION_NOT_ENABLED
//
// MessageText:
//
// Recovery Passwords Key Rotation is not Enabled.
//


//
// MessageId: FVE_E_DEVICE_NOT_JOINED
//
// MessageText:
//
// Recovery Passwords Rotation could not be performed because the device is not joined to AAD or Hybrid.
//


//
// =======================================================
// Windows Filtering Platform Error Messages
// =======================================================
//
//
// MessageId: FWP_E_CALLOUT_NOT_FOUND
//
// MessageText:
//
// The callout does not exist.
//


//
// MessageId: FWP_E_CONDITION_NOT_FOUND
//
// MessageText:
//
// The filter condition does not exist.
//


//
// MessageId: FWP_E_FILTER_NOT_FOUND
//
// MessageText:
//
// The filter does not exist.
//


//
// MessageId: FWP_E_LAYER_NOT_FOUND
//
// MessageText:
//
// The layer does not exist.
//


//
// MessageId: FWP_E_PROVIDER_NOT_FOUND
//
// MessageText:
//
// The provider does not exist.
//


//
// MessageId: FWP_E_PROVIDER_CONTEXT_NOT_FOUND
//
// MessageText:
//
// The provider context does not exist.
//


//
// MessageId: FWP_E_SUBLAYER_NOT_FOUND
//
// MessageText:
//
// The sublayer does not exist.
//


//
// MessageId: FWP_E_NOT_FOUND
//
// MessageText:
//
// The object does not exist.
//


//
// MessageId: FWP_E_ALREADY_EXISTS
//
// MessageText:
//
// An object with that GUID or LUID already exists.
//


//
// MessageId: FWP_E_IN_USE
//
// MessageText:
//
// The object is referenced by other objects so cannot be deleted.
//


//
// MessageId: FWP_E_DYNAMIC_SESSION_IN_PROGRESS
//
// MessageText:
//
// The call is not allowed from within a dynamic session.
//


//
// MessageId: FWP_E_WRONG_SESSION
//
// MessageText:
//
// The call was made from the wrong session so cannot be completed.
//


//
// MessageId: FWP_E_NO_TXN_IN_PROGRESS
//
// MessageText:
//
// The call must be made from within an explicit transaction.
//


//
// MessageId: FWP_E_TXN_IN_PROGRESS
//
// MessageText:
//
// The call is not allowed from within an explicit transaction.
//


//
// MessageId: FWP_E_TXN_ABORTED
//
// MessageText:
//
// The explicit transaction has been forcibly cancelled.
//


//
// MessageId: FWP_E_SESSION_ABORTED
//
// MessageText:
//
// The session has been cancelled.
//


//
// MessageId: FWP_E_INCOMPATIBLE_TXN
//
// MessageText:
//
// The call is not allowed from within a read-only transaction.
//


//
// MessageId: FWP_E_TIMEOUT
//
// MessageText:
//
// The call timed out while waiting to acquire the transaction lock.
//


//
// MessageId: FWP_E_NET_EVENTS_DISABLED
//
// MessageText:
//
// Collection of network diagnostic events is disabled.
//


//
// MessageId: FWP_E_INCOMPATIBLE_LAYER
//
// MessageText:
//
// The operation is not supported by the specified layer.
//


//
// MessageId: FWP_E_KM_CLIENTS_ONLY
//
// MessageText:
//
// The call is allowed for kernel-mode callers only.
//


//
// MessageId: FWP_E_LIFETIME_MISMATCH
//
// MessageText:
//
// The call tried to associate two objects with incompatible lifetimes.
//


//
// MessageId: FWP_E_BUILTIN_OBJECT
//
// MessageText:
//
// The object is built in so cannot be deleted.
//


//
// MessageId: FWP_E_TOO_MANY_CALLOUTS
//
// MessageText:
//
// The maximum number of callouts has been reached.
//


//
// MessageId: FWP_E_NOTIFICATION_DROPPED
//
// MessageText:
//
// A notification could not be delivered because a message queue is at its maximum capacity.
//


//
// MessageId: FWP_E_TRAFFIC_MISMATCH
//
// MessageText:
//
// The traffic parameters do not match those for the security association context.
//


//
// MessageId: FWP_E_INCOMPATIBLE_SA_STATE
//
// MessageText:
//
// The call is not allowed for the current security association state.
//


//
// MessageId: FWP_E_NULL_POINTER
//
// MessageText:
//
// A required pointer is null.
//


//
// MessageId: FWP_E_INVALID_ENUMERATOR
//
// MessageText:
//
// An enumerator is not valid.
//


//
// MessageId: FWP_E_INVALID_FLAGS
//
// MessageText:
//
// The flags field contains an invalid value.
//


//
// MessageId: FWP_E_INVALID_NET_MASK
//
// MessageText:
//
// A network mask is not valid.
//


//
// MessageId: FWP_E_INVALID_RANGE
//
// MessageText:
//
// An FWP_RANGE is not valid.
//


//
// MessageId: FWP_E_INVALID_INTERVAL
//
// MessageText:
//
// The time interval is not valid.
//


//
// MessageId: FWP_E_ZERO_LENGTH_ARRAY
//
// MessageText:
//
// An array that must contain at least one element is zero length.
//


//
// MessageId: FWP_E_NULL_DISPLAY_NAME
//
// MessageText:
//
// The displayData.name field cannot be null.
//


//
// MessageId: FWP_E_INVALID_ACTION_TYPE
//
// MessageText:
//
// The action type is not one of the allowed action types for a filter.
//


//
// MessageId: FWP_E_INVALID_WEIGHT
//
// MessageText:
//
// The filter weight is not valid.
//


//
// MessageId: FWP_E_MATCH_TYPE_MISMATCH
//
// MessageText:
//
// A filter condition contains a match type that is not compatible with the operands.
//


//
// MessageId: FWP_E_TYPE_MISMATCH
//
// MessageText:
//
// An FWP_VALUE or FWPM_CONDITION_VALUE is of the wrong type.
//


//
// MessageId: FWP_E_OUT_OF_BOUNDS
//
// MessageText:
//
// An integer value is outside the allowed range.
//


//
// MessageId: FWP_E_RESERVED
//
// MessageText:
//
// A reserved field is non-zero.
//


//
// MessageId: FWP_E_DUPLICATE_CONDITION
//
// MessageText:
//
// A filter cannot contain multiple conditions operating on a single field.
//


//
// MessageId: FWP_E_DUPLICATE_KEYMOD
//
// MessageText:
//
// A policy cannot contain the same keying module more than once.
//


//
// MessageId: FWP_E_ACTION_INCOMPATIBLE_WITH_LAYER
//
// MessageText:
//
// The action type is not compatible with the layer.
//


//
// MessageId: FWP_E_ACTION_INCOMPATIBLE_WITH_SUBLAYER
//
// MessageText:
//
// The action type is not compatible with the sublayer.
//


//
// MessageId: FWP_E_CONTEXT_INCOMPATIBLE_WITH_LAYER
//
// MessageText:
//
// The raw context or the provider context is not compatible with the layer.
//


//
// MessageId: FWP_E_CONTEXT_INCOMPATIBLE_WITH_CALLOUT
//
// MessageText:
//
// The raw context or the provider context is not compatible with the callout.
//


//
// MessageId: FWP_E_INCOMPATIBLE_AUTH_METHOD
//
// MessageText:
//
// The authentication method is not compatible with the policy type.
//


//
// MessageId: FWP_E_INCOMPATIBLE_DH_GROUP
//
// MessageText:
//
// The Diffie-Hellman group is not compatible with the policy type.
//


//
// MessageId: FWP_E_EM_NOT_SUPPORTED
//
// MessageText:
//
// An IKE policy cannot contain an Extended Mode policy.
//


//
// MessageId: FWP_E_NEVER_MATCH
//
// MessageText:
//
// The enumeration template or subscription will never match any objects.
//


//
// MessageId: FWP_E_PROVIDER_CONTEXT_MISMATCH
//
// MessageText:
//
// The provider context is of the wrong type.
//


//
// MessageId: FWP_E_INVALID_PARAMETER
//
// MessageText:
//
// The parameter is incorrect.
//


//
// MessageId: FWP_E_TOO_MANY_SUBLAYERS
//
// MessageText:
//
// The maximum number of sublayers has been reached.
//


//
// MessageId: FWP_E_CALLOUT_NOTIFICATION_FAILED
//
// MessageText:
//
// The notification function for a callout returned an error.
//


//
// MessageId: FWP_E_INVALID_AUTH_TRANSFORM
//
// MessageText:
//
// The IPsec authentication transform is not valid.
//


//
// MessageId: FWP_E_INVALID_CIPHER_TRANSFORM
//
// MessageText:
//
// The IPsec cipher transform is not valid.
//


//
// MessageId: FWP_E_INCOMPATIBLE_CIPHER_TRANSFORM
//
// MessageText:
//
// The IPsec cipher transform is not compatible with the policy.
//


//
// MessageId: FWP_E_INVALID_TRANSFORM_COMBINATION
//
// MessageText:
//
// The combination of IPsec transform types is not valid.
//


//
// MessageId: FWP_E_DUPLICATE_AUTH_METHOD
//
// MessageText:
//
// A policy cannot contain the same auth method more than once.
//


//
// MessageId: FWP_E_INVALID_TUNNEL_ENDPOINT
//
// MessageText:
//
// A tunnel endpoint configuration is invalid.
//


//
// MessageId: FWP_E_L2_DRIVER_NOT_READY
//
// MessageText:
//
// The WFP MAC Layers are not ready.
//


//
// MessageId: FWP_E_KEY_DICTATOR_ALREADY_REGISTERED
//
// MessageText:
//
// A key manager capable of key dictation is already registered
//


//
// MessageId: FWP_E_KEY_DICTATION_INVALID_KEYING_MATERIAL
//
// MessageText:
//
// A key manager dictated invalid keys
//


//
// MessageId: FWP_E_CONNECTIONS_DISABLED
//
// MessageText:
//
// The BFE IPsec Connection Tracking is disabled.
//


//
// MessageId: FWP_E_INVALID_DNS_NAME
//
// MessageText:
//
// The DNS name is invalid.
//


//
// MessageId: FWP_E_STILL_ON
//
// MessageText:
//
// The engine option is still enabled due to other configuration settings.
//


//
// MessageId: FWP_E_IKEEXT_NOT_RUNNING
//
// MessageText:
//
// The IKEEXT service is not running.  This service only runs when there is IPsec policy applied to the machine.
//


//
// MessageId: FWP_E_DROP_NOICMP
//
// MessageText:
//
// The packet should be dropped, no ICMP should be sent.
//



///////////////////////////////////////////////////
//                                               //
//       Web Services Platform Error Codes       //
//                                               //
///////////////////////////////////////////////////

//
// MessageId: WS_S_ASYNC
//
// MessageText:
//
// The function call is completing asynchronously.
//


//
// MessageId: WS_S_END
//
// MessageText:
//
// There are no more messages available on the channel.
//


//
// MessageId: WS_E_INVALID_FORMAT
//
// MessageText:
//
// The input data was not in the expected format or did not have the expected value.
//


//
// MessageId: WS_E_OBJECT_FAULTED
//
// MessageText:
//
// The operation could not be completed because the object is in a faulted state due to a previous error.
//


//
// MessageId: WS_E_NUMERIC_OVERFLOW
//
// MessageText:
//
// The operation could not be completed because it would lead to numeric overflow.
//


//
// MessageId: WS_E_INVALID_OPERATION
//
// MessageText:
//
// The operation is not allowed due to the current state of the object.
//


//
// MessageId: WS_E_OPERATION_ABORTED
//
// MessageText:
//
// The operation was aborted.
//


//
// MessageId: WS_E_ENDPOINT_ACCESS_DENIED
//
// MessageText:
//
// Access was denied by the remote endpoint.
//


//
// MessageId: WS_E_OPERATION_TIMED_OUT
//
// MessageText:
//
// The operation did not complete within the time allotted.
//


//
// MessageId: WS_E_OPERATION_ABANDONED
//
// MessageText:
//
// The operation was abandoned.
//


//
// MessageId: WS_E_QUOTA_EXCEEDED
//
// MessageText:
//
// A quota was exceeded.
//


//
// MessageId: WS_E_NO_TRANSLATION_AVAILABLE
//
// MessageText:
//
// The information was not available in the specified language.
//


//
// MessageId: WS_E_SECURITY_VERIFICATION_FAILURE
//
// MessageText:
//
// Security verification was not successful for the received data.
//


//
// MessageId: WS_E_ADDRESS_IN_USE
//
// MessageText:
//
// The address is already being used.
//


//
// MessageId: WS_E_ADDRESS_NOT_AVAILABLE
//
// MessageText:
//
// The address is not valid for this context.
//


//
// MessageId: WS_E_ENDPOINT_NOT_FOUND
//
// MessageText:
//
// The remote endpoint does not exist or could not be located.
//


//
// MessageId: WS_E_ENDPOINT_NOT_AVAILABLE
//
// MessageText:
//
// The remote endpoint is not currently in service at this location.
//


//
// MessageId: WS_E_ENDPOINT_FAILURE
//
// MessageText:
//
// The remote endpoint could not process the request.
//


//
// MessageId: WS_E_ENDPOINT_UNREACHABLE
//
// MessageText:
//
// The remote endpoint was not reachable.
//


//
// MessageId: WS_E_ENDPOINT_ACTION_NOT_SUPPORTED
//
// MessageText:
//
// The operation was not supported by the remote endpoint.
//


//
// MessageId: WS_E_ENDPOINT_TOO_BUSY
//
// MessageText:
//
// The remote endpoint is unable to process the request due to being overloaded.
//


//
// MessageId: WS_E_ENDPOINT_FAULT_RECEIVED
//
// MessageText:
//
// A message containing a fault was received from the remote endpoint.
//


//
// MessageId: WS_E_ENDPOINT_DISCONNECTED
//
// MessageText:
//
// The connection with the remote endpoint was terminated.
//


//
// MessageId: WS_E_PROXY_FAILURE
//
// MessageText:
//
// The HTTP proxy server could not process the request.
//


//
// MessageId: WS_E_PROXY_ACCESS_DENIED
//
// MessageText:
//
// Access was denied by the HTTP proxy server.
//


//
// MessageId: WS_E_NOT_SUPPORTED
//
// MessageText:
//
// The requested feature is not available on this platform.
//


//
// MessageId: WS_E_PROXY_REQUIRES_BASIC_AUTH
//
// MessageText:
//
// The HTTP proxy server requires HTTP authentication scheme 'basic'.
//


//
// MessageId: WS_E_PROXY_REQUIRES_DIGEST_AUTH
//
// MessageText:
//
// The HTTP proxy server requires HTTP authentication scheme 'digest'.
//


//
// MessageId: WS_E_PROXY_REQUIRES_NTLM_AUTH
//
// MessageText:
//
// The HTTP proxy server requires HTTP authentication scheme 'NTLM'.
//


//
// MessageId: WS_E_PROXY_REQUIRES_NEGOTIATE_AUTH
//
// MessageText:
//
// The HTTP proxy server requires HTTP authentication scheme 'negotiate'.
//


//
// MessageId: WS_E_SERVER_REQUIRES_BASIC_AUTH
//
// MessageText:
//
// The remote endpoint requires HTTP authentication scheme 'basic'.
//


//
// MessageId: WS_E_SERVER_REQUIRES_DIGEST_AUTH
//
// MessageText:
//
// The remote endpoint requires HTTP authentication scheme 'digest'.
//


//
// MessageId: WS_E_SERVER_REQUIRES_NTLM_AUTH
//
// MessageText:
//
// The remote endpoint requires HTTP authentication scheme 'NTLM'.
//


//
// MessageId: WS_E_SERVER_REQUIRES_NEGOTIATE_AUTH
//
// MessageText:
//
// The remote endpoint requires HTTP authentication scheme 'negotiate'.
//


//
// MessageId: WS_E_INVALID_ENDPOINT_URL
//
// MessageText:
//
// The endpoint address URL is invalid.
//


//
// MessageId: WS_E_OTHER
//
// MessageText:
//
// Unrecognized error occurred in the Windows Web Services framework.
//


//
// MessageId: WS_E_SECURITY_TOKEN_EXPIRED
//
// MessageText:
//
// A security token was rejected by the server because it has expired.
//


//
// MessageId: WS_E_SECURITY_SYSTEM_FAILURE
//
// MessageText:
//
// A security operation failed in the Windows Web Services framework.
//



//
// NDIS error codes (ndis.sys)
//






#line 49717 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\shared\\winerror.h"

//
// MessageId: ERROR_NDIS_INTERFACE_CLOSING
//
// MessageText:
//
// The binding to the network interface is being closed.
//


//
// MessageId: ERROR_NDIS_BAD_VERSION
//
// MessageText:
//
// An invalid version was specified.
//


//
// MessageId: ERROR_NDIS_BAD_CHARACTERISTICS
//
// MessageText:
//
// An invalid characteristics table was used.
//


//
// MessageId: ERROR_NDIS_ADAPTER_NOT_FOUND
//
// MessageText:
//
// Failed to find the network interface or network interface is not ready.
//


//
// MessageId: ERROR_NDIS_OPEN_FAILED
//
// MessageText:
//
// Failed to open the network interface.
//


//
// MessageId: ERROR_NDIS_DEVICE_FAILED
//
// MessageText:
//
// Network interface has encountered an internal unrecoverable failure.
//


//
// MessageId: ERROR_NDIS_MULTICAST_FULL
//
// MessageText:
//
// The multicast list on the network interface is full.
//


//
// MessageId: ERROR_NDIS_MULTICAST_EXISTS
//
// MessageText:
//
// An attempt was made to add a duplicate multicast address to the list.
//


//
// MessageId: ERROR_NDIS_MULTICAST_NOT_FOUND
//
// MessageText:
//
// At attempt was made to remove a multicast address that was never added.
//


//
// MessageId: ERROR_NDIS_REQUEST_ABORTED
//
// MessageText:
//
// Netowork interface aborted the request.
//


//
// MessageId: ERROR_NDIS_RESET_IN_PROGRESS
//
// MessageText:
//
// Network interface can not process the request because it is being reset.
//


//
// MessageId: ERROR_NDIS_NOT_SUPPORTED
//
// MessageText:
//
// Netword interface does not support this request.
//


//
// MessageId: ERROR_NDIS_INVALID_PACKET
//
// MessageText:
//
// An attempt was made to send an invalid packet on a network interface.
//


//
// MessageId: ERROR_NDIS_ADAPTER_NOT_READY
//
// MessageText:
//
// Network interface is not ready to complete this operation.
//


//
// MessageId: ERROR_NDIS_INVALID_LENGTH
//
// MessageText:
//
// The length of the buffer submitted for this operation is not valid.
//


//
// MessageId: ERROR_NDIS_INVALID_DATA
//
// MessageText:
//
// The data used for this operation is not valid.
//


//
// MessageId: ERROR_NDIS_BUFFER_TOO_SHORT
//
// MessageText:
//
// The length of buffer submitted for this operation is too small.
//


//
// MessageId: ERROR_NDIS_INVALID_OID
//
// MessageText:
//
// Network interface does not support this OID (Object Identifier)
//


//
// MessageId: ERROR_NDIS_ADAPTER_REMOVED
//
// MessageText:
//
// The network interface has been removed.
//


//
// MessageId: ERROR_NDIS_UNSUPPORTED_MEDIA
//
// MessageText:
//
// Network interface does not support this media type.
//


//
// MessageId: ERROR_NDIS_GROUP_ADDRESS_IN_USE
//
// MessageText:
//
// An attempt was made to remove a token ring group address that is in use by other components.
//


//
// MessageId: ERROR_NDIS_FILE_NOT_FOUND
//
// MessageText:
//
// An attempt was made to map a file that can not be found.
//


//
// MessageId: ERROR_NDIS_ERROR_READING_FILE
//
// MessageText:
//
// An error occurred while NDIS tried to map the file.
//


//
// MessageId: ERROR_NDIS_ALREADY_MAPPED
//
// MessageText:
//
// An attempt was made to map a file that is alreay mapped.
//


//
// MessageId: ERROR_NDIS_RESOURCE_CONFLICT
//
// MessageText:
//
// An attempt to allocate a hardware resource failed because the resource is used by another component.
//


//
// MessageId: ERROR_NDIS_MEDIA_DISCONNECTED
//
// MessageText:
//
// The I/O operation failed because network media is disconnected or wireless access point is out of range.
//


//
// MessageId: ERROR_NDIS_INVALID_ADDRESS
//
// MessageText:
//
// The network address used in the request is invalid.
//


//
// MessageId: ERROR_NDIS_INVALID_DEVICE_REQUEST
//
// MessageText:
//
// The specified request is not a valid operation for the target device.
//


//
// MessageId: ERROR_NDIS_PAUSED
//
// MessageText:
//
// The offload operation on the network interface has been paused.
//


//
// MessageId: ERROR_NDIS_INTERFACE_NOT_FOUND
//
// MessageText:
//
// Network interface was not found.
//


//
// MessageId: ERROR_NDIS_UNSUPPORTED_REVISION
//
// MessageText:
//
// The revision number specified in the structure is not supported.
//


//
// MessageId: ERROR_NDIS_INVALID_PORT
//
// MessageText:
//
// The specified port does not exist on this network interface.
//


//
// MessageId: ERROR_NDIS_INVALID_PORT_STATE
//
// MessageText:
//
// The current state of the specified port on this network interface does not support the requested operation.
//


//
// MessageId: ERROR_NDIS_LOW_POWER_STATE
//
// MessageText:
//
// The miniport adapter is in low power state.
//


//
// MessageId: ERROR_NDIS_REINIT_REQUIRED
//
// MessageText:
//
// This operation requires the miniport adapter to be reinitialized.
//


//
// MessageId: ERROR_NDIS_NO_QUEUES
//
// MessageText:
//
// There are not enough queues to complete the operation.
//



//
// NDIS error codes (802.11 wireless LAN)
//

//
// MessageId: ERROR_NDIS_DOT11_AUTO_CONFIG_ENABLED
//
// MessageText:
//
// The wireless local area network interface is in auto configuration mode and doesn't support the requested parameter change operation.
//


//
// MessageId: ERROR_NDIS_DOT11_MEDIA_IN_USE
//
// MessageText:
//
// The wireless local area network interface is busy and can not perform the requested operation.
//


//
// MessageId: ERROR_NDIS_DOT11_POWER_STATE_INVALID
//
// MessageText:
//
// The wireless local area network interface is powered down and doesn't support the requested operation.
//


//
// MessageId: ERROR_NDIS_PM_WOL_PATTERN_LIST_FULL
//
// MessageText:
//
// The list of wake on LAN patterns is full.
//


//
// MessageId: ERROR_NDIS_PM_PROTOCOL_OFFLOAD_LIST_FULL
//
// MessageText:
//
// The list of low power protocol offloads is full.
//


//
// MessageId: ERROR_NDIS_DOT11_AP_CHANNEL_CURRENTLY_NOT_AVAILABLE
//
// MessageText:
//
// The wireless local area network interface cannot start an AP on the specified channel right now.
//


//
// MessageId: ERROR_NDIS_DOT11_AP_BAND_CURRENTLY_NOT_AVAILABLE
//
// MessageText:
//
// The wireless local area network interface cannot start an AP on the specified band right now.
//


//
// MessageId: ERROR_NDIS_DOT11_AP_CHANNEL_NOT_ALLOWED
//
// MessageText:
//
// The wireless local area network interface cannot start an AP on this channel due to regulatory reasons.
//


//
// MessageId: ERROR_NDIS_DOT11_AP_BAND_NOT_ALLOWED
//
// MessageText:
//
// The wireless local area network interface cannot start an AP on this band due to regulatory reasons.
//


//
// NDIS informational code (ndis.sys)
//

//
// MessageId: ERROR_NDIS_INDICATION_REQUIRED
//
// MessageText:
//
// The request will be completed later by NDIS status indication.
//


//
// NDIS Chimney Offload codes (ndis.sys)
//

//
// MessageId: ERROR_NDIS_OFFLOAD_POLICY
//
// MessageText:
//
// The TCP connection is not offloadable because of a local policy setting.
//


//
// MessageId: ERROR_NDIS_OFFLOAD_CONNECTION_REJECTED
//
// MessageText:
//
// The TCP connection is not offloadable by the Chimney Offload target.
//


//
// MessageId: ERROR_NDIS_OFFLOAD_PATH_REJECTED
//
// MessageText:
//
// The IP Path object is not in an offloadable state.
//


//
// Hypervisor error codes
//

//
// MessageId: ERROR_HV_INVALID_HYPERCALL_CODE
//
// MessageText:
//
// The hypervisor does not support the operation because the specified hypercall code is not supported.
//


//
// MessageId: ERROR_HV_INVALID_HYPERCALL_INPUT
//
// MessageText:
//
// The hypervisor does not support the operation because the encoding for the hypercall input register is not supported.
//


//
// MessageId: ERROR_HV_INVALID_ALIGNMENT
//
// MessageText:
//
// The hypervisor could not perform the operation because a parameter has an invalid alignment.
//


//
// MessageId: ERROR_HV_INVALID_PARAMETER
//
// MessageText:
//
// The hypervisor could not perform the operation because an invalid parameter was specified.
//


//
// MessageId: ERROR_HV_ACCESS_DENIED
//
// MessageText:
//
// Access to the specified object was denied.
//


//
// MessageId: ERROR_HV_INVALID_PARTITION_STATE
//
// MessageText:
//
// The hypervisor could not perform the operation because the partition is entering or in an invalid state.
//


//
// MessageId: ERROR_HV_OPERATION_DENIED
//
// MessageText:
//
// The operation is not allowed in the current state.
//


//
// MessageId: ERROR_HV_UNKNOWN_PROPERTY
//
// MessageText:
//
// The hypervisor does not recognize the specified partition property.
//


//
// MessageId: ERROR_HV_PROPERTY_VALUE_OUT_OF_RANGE
//
// MessageText:
//
// The specified value of a partition property is out of range or violates an invariant.
//


//
// MessageId: ERROR_HV_INSUFFICIENT_MEMORY
//
// MessageText:
//
// There is not enough memory in the hypervisor pool to complete the operation.
//


//
// MessageId: ERROR_HV_PARTITION_TOO_DEEP
//
// MessageText:
//
// The maximum partition depth has been exceeded for the partition hierarchy.
//


//
// MessageId: ERROR_HV_INVALID_PARTITION_ID
//
// MessageText:
//
// A partition with the specified partition Id does not exist.
//


//
// MessageId: ERROR_HV_INVALID_VP_INDEX
//
// MessageText:
//
// The hypervisor could not perform the operation because the specified VP index is invalid.
//


//
// MessageId: ERROR_HV_INVALID_PORT_ID
//
// MessageText:
//
// The hypervisor could not perform the operation because the specified port identifier is invalid.
//


//
// MessageId: ERROR_HV_INVALID_CONNECTION_ID
//
// MessageText:
//
// The hypervisor could not perform the operation because the specified connection identifier is invalid.
//


//
// MessageId: ERROR_HV_INSUFFICIENT_BUFFERS
//
// MessageText:
//
// Not enough buffers were supplied to send a message.
//


//
// MessageId: ERROR_HV_NOT_ACKNOWLEDGED
//
// MessageText:
//
// The previous virtual interrupt has not been acknowledged.
//


//
// MessageId: ERROR_HV_INVALID_VP_STATE
//
// MessageText:
//
// A virtual processor is not in the correct state for the indicated operation.
//


//
// MessageId: ERROR_HV_ACKNOWLEDGED
//
// MessageText:
//
// The previous virtual interrupt has already been acknowledged.
//


//
// MessageId: ERROR_HV_INVALID_SAVE_RESTORE_STATE
//
// MessageText:
//
// The indicated partition is not in a valid state for saving or restoring.
//


//
// MessageId: ERROR_HV_INVALID_SYNIC_STATE
//
// MessageText:
//
// The hypervisor could not complete the operation because a required feature of the synthetic interrupt controller (SynIC) was disabled.
//


//
// MessageId: ERROR_HV_OBJECT_IN_USE
//
// MessageText:
//
// The hypervisor could not perform the operation because the object or value was either already in use or being used for a purpose that would not permit completing the operation.
//


//
// MessageId: ERROR_HV_INVALID_PROXIMITY_DOMAIN_INFO
//
// MessageText:
//
// The proximity domain information is invalid.
//


//
// MessageId: ERROR_HV_NO_DATA
//
// MessageText:
//
// An attempt to retrieve debugging data failed because none was available.
//


//
// MessageId: ERROR_HV_INACTIVE
//
// MessageText:
//
// The physical connection being used for debugging has not recorded any receive activity since the last operation.
//


//
// MessageId: ERROR_HV_NO_RESOURCES
//
// MessageText:
//
// There are not enough resources to complete the operation.
//


//
// MessageId: ERROR_HV_FEATURE_UNAVAILABLE
//
// MessageText:
//
// A hypervisor feature is not available to the user.
//


//
// MessageId: ERROR_HV_INSUFFICIENT_BUFFER
//
// MessageText:
//
// The specified buffer was too small to contain all of the requested data.
//


//
// MessageId: ERROR_HV_INSUFFICIENT_DEVICE_DOMAINS
//
// MessageText:
//
// The maximum number of domains supported by the platform I/O remapping hardware is currently in use. No domains are available to assign this device to this partition.
//


//
// MessageId: ERROR_HV_CPUID_FEATURE_VALIDATION
//
// MessageText:
//
// Validation of CPUID data of the processor failed.
//


//
// MessageId: ERROR_HV_CPUID_XSAVE_FEATURE_VALIDATION
//
// MessageText:
//
// Validation of XSAVE CPUID data of the processor failed.
//


//
// MessageId: ERROR_HV_PROCESSOR_STARTUP_TIMEOUT
//
// MessageText:
//
// Processor did not respond within the timeout period.
//


//
// MessageId: ERROR_HV_SMX_ENABLED
//
// MessageText:
//
// SMX has been enabled in the BIOS.
//


//
// MessageId: ERROR_HV_INVALID_LP_INDEX
//
// MessageText:
//
// The hypervisor could not perform the operation because the specified LP index is invalid.
//


//
// MessageId: ERROR_HV_INVALID_REGISTER_VALUE
//
// MessageText:
//
// The supplied register value is invalid.
//


//
// MessageId: ERROR_HV_INVALID_VTL_STATE
//
// MessageText:
//
// The supplied virtual trust level is not in the correct state to perform the requested operation.
//


//
// MessageId: ERROR_HV_NX_NOT_DETECTED
//
// MessageText:
//
// No execute feature (NX) is not present or not enabled in the BIOS.
//


//
// MessageId: ERROR_HV_INVALID_DEVICE_ID
//
// MessageText:
//
// The supplied device ID is invalid.
//


//
// MessageId: ERROR_HV_INVALID_DEVICE_STATE
//
// MessageText:
//
// The operation is not allowed in the current device state.
//


//
// MessageId: ERROR_HV_PENDING_PAGE_REQUESTS
//
// MessageText:
//
// The device had pending page requests which were discarded.
//


//
// MessageId: ERROR_HV_PAGE_REQUEST_INVALID
//
// MessageText:
//
// The supplied page request specifies a memory access that the guest does not have permissions to perform.
//


//
// MessageId: ERROR_HV_INVALID_CPU_GROUP_ID
//
// MessageText:
//
// A CPU group with the specified CPU group Id does not exist.
//


//
// MessageId: ERROR_HV_INVALID_CPU_GROUP_STATE
//
// MessageText:
//
// The hypervisor could not perform the operation because the CPU group is entering or in an invalid state.
//


//
// MessageId: ERROR_HV_OPERATION_FAILED
//
// MessageText:
//
// The requested operation failed.
//


//
// MessageId: ERROR_HV_NOT_ALLOWED_WITH_NESTED_VIRT_ACTIVE
//
// MessageText:
//
// The hypervisor could not perform the operation because it is not allowed with nested virtualization active.
//


//
// MessageId: ERROR_HV_INSUFFICIENT_ROOT_MEMORY
//
// MessageText:
//
// There is not enough memory in the root partition's pool to complete the operation.
//


//
// MessageId: ERROR_HV_NOT_PRESENT
//
// MessageText:
//
// No hypervisor is present on this system.
//


//
// Virtualization error codes - these codes are used by the Virtualization Infrastructure Driver (VID) and other components
//                              of the virtualization stack.
//
// VID errors (0x0001 - 0x00ff)
//

//
// MessageId: ERROR_VID_DUPLICATE_HANDLER
//
// MessageText:
//
// The handler for the virtualization infrastructure driver is already registered. Restarting the virtual machine may fix the problem. If the problem persists, try restarting the physical computer.
//


//
// MessageId: ERROR_VID_TOO_MANY_HANDLERS
//
// MessageText:
//
// The number of registered handlers for the virtualization infrastructure driver exceeded the maximum. Restarting the virtual machine may fix the problem. If the problem persists, try restarting the physical computer.
//


//
// MessageId: ERROR_VID_QUEUE_FULL
//
// MessageText:
//
// The message queue for the virtualization infrastructure driver is full and cannot accept new messages. Restarting the virtual machine may fix the problem. If the problem persists, try restarting the physical computer.
//


//
// MessageId: ERROR_VID_HANDLER_NOT_PRESENT
//
// MessageText:
//
// No handler exists to handle the message for the virtualization infrastructure driver. Restarting the virtual machine may fix the problem. If the problem persists, try restarting the physical computer.
//


//
// MessageId: ERROR_VID_INVALID_OBJECT_NAME
//
// MessageText:
//
// The name of the partition or message queue for the virtualization infrastructure driver is invalid. Restarting the virtual machine may fix the problem. If the problem persists, try restarting the physical computer.
//


//
// MessageId: ERROR_VID_PARTITION_NAME_TOO_LONG
//
// MessageText:
//
// The partition name of the virtualization infrastructure driver exceeds the maximum.
//


//
// MessageId: ERROR_VID_MESSAGE_QUEUE_NAME_TOO_LONG
//
// MessageText:
//
// The message queue name of the virtualization infrastructure driver exceeds the maximum.
//


//
// MessageId: ERROR_VID_PARTITION_ALREADY_EXISTS
//
// MessageText:
//
// Cannot create the partition for the virtualization infrastructure driver because another partition with the same name already exists.
//


//
// MessageId: ERROR_VID_PARTITION_DOES_NOT_EXIST
//
// MessageText:
//
// The virtualization infrastructure driver has encountered an error. The requested partition does not exist. Restarting the virtual machine may fix the problem. If the problem persists, try restarting the physical computer.
//


//
// MessageId: ERROR_VID_PARTITION_NAME_NOT_FOUND
//
// MessageText:
//
// The virtualization infrastructure driver has encountered an error. Could not find the requested partition. Restarting the virtual machine may fix the problem. If the problem persists, try restarting the physical computer.
//


//
// MessageId: ERROR_VID_MESSAGE_QUEUE_ALREADY_EXISTS
//
// MessageText:
//
// A message queue with the same name already exists for the virtualization infrastructure driver.
//


//
// MessageId: ERROR_VID_EXCEEDED_MBP_ENTRY_MAP_LIMIT
//
// MessageText:
//
// The memory block page for the virtualization infrastructure driver cannot be mapped because the page map limit has been reached. Restarting the virtual machine may fix the problem. If the problem persists, try restarting the physical computer.
//


//
// MessageId: ERROR_VID_MB_STILL_REFERENCED
//
// MessageText:
//
// The memory block for the virtualization infrastructure driver is still being used and cannot be destroyed.
//


//
// MessageId: ERROR_VID_CHILD_GPA_PAGE_SET_CORRUPTED
//
// MessageText:
//
// Cannot unlock the page array for the guest operating system memory address because it does not match a previous lock request. Restarting the virtual machine may fix the problem. If the problem persists, try restarting the physical computer.
//


//
// MessageId: ERROR_VID_INVALID_NUMA_SETTINGS
//
// MessageText:
//
// The non-uniform memory access (NUMA) node settings do not match the system NUMA topology. In order to start the virtual machine, you will need to modify the NUMA configuration.
//


//
// MessageId: ERROR_VID_INVALID_NUMA_NODE_INDEX
//
// MessageText:
//
// The non-uniform memory access (NUMA) node index does not match a valid index in the system NUMA topology.
//


//
// MessageId: ERROR_VID_NOTIFICATION_QUEUE_ALREADY_ASSOCIATED
//
// MessageText:
//
// The memory block for the virtualization infrastructure driver is already associated with a message queue.
//


//
// MessageId: ERROR_VID_INVALID_MEMORY_BLOCK_HANDLE
//
// MessageText:
//
// The handle is not a valid memory block handle for the virtualization infrastructure driver.
//


//
// MessageId: ERROR_VID_PAGE_RANGE_OVERFLOW
//
// MessageText:
//
// The request exceeded the memory block page limit for the virtualization infrastructure driver. Restarting the virtual machine may fix the problem. If the problem persists, try restarting the physical computer.
//


//
// MessageId: ERROR_VID_INVALID_MESSAGE_QUEUE_HANDLE
//
// MessageText:
//
// The handle is not a valid message queue handle for the virtualization infrastructure driver.
//


//
// MessageId: ERROR_VID_INVALID_GPA_RANGE_HANDLE
//
// MessageText:
//
// The handle is not a valid page range handle for the virtualization infrastructure driver.
//


//
// MessageId: ERROR_VID_NO_MEMORY_BLOCK_NOTIFICATION_QUEUE
//
// MessageText:
//
// Cannot install client notifications because no message queue for the virtualization infrastructure driver is associated with the memory block.
//


//
// MessageId: ERROR_VID_MEMORY_BLOCK_LOCK_COUNT_EXCEEDED
//
// MessageText:
//
// The request to lock or map a memory block page failed because the virtualization infrastructure driver memory block limit has been reached. Restarting the virtual machine may fix the problem. If the problem persists, try restarting the physical computer.
//


//
// MessageId: ERROR_VID_INVALID_PPM_HANDLE
//
// MessageText:
//
// The handle is not a valid parent partition mapping handle for the virtualization infrastructure driver.
//


//
// MessageId: ERROR_VID_MBPS_ARE_LOCKED
//
// MessageText:
//
// Notifications cannot be created on the memory block because it is use.
//


//
// MessageId: ERROR_VID_MESSAGE_QUEUE_CLOSED
//
// MessageText:
//
// The message queue for the virtualization infrastructure driver has been closed. Restarting the virtual machine may fix the problem. If the problem persists, try restarting the physical computer.
//


//
// MessageId: ERROR_VID_VIRTUAL_PROCESSOR_LIMIT_EXCEEDED
//
// MessageText:
//
// Cannot add a virtual processor to the partition because the maximum has been reached.
//


//
// MessageId: ERROR_VID_STOP_PENDING
//
// MessageText:
//
// Cannot stop the virtual processor immediately because of a pending intercept.
//


//
// MessageId: ERROR_VID_INVALID_PROCESSOR_STATE
//
// MessageText:
//
// Invalid state for the virtual processor. Restarting the virtual machine may fix the problem. If the problem persists, try restarting the physical computer.
//


//
// MessageId: ERROR_VID_EXCEEDED_KM_CONTEXT_COUNT_LIMIT
//
// MessageText:
//
// The maximum number of kernel mode clients for the virtualization infrastructure driver has been reached. Restarting the virtual machine may fix the problem. If the problem persists, try restarting the physical computer.
//


//
// MessageId: ERROR_VID_KM_INTERFACE_ALREADY_INITIALIZED
//
// MessageText:
//
// This kernel mode interface for the virtualization infrastructure driver has already been initialized. Restarting the virtual machine may fix the problem. If the problem persists, try restarting the physical computer.
//


//
// MessageId: ERROR_VID_MB_PROPERTY_ALREADY_SET_RESET
//
// MessageText:
//
// Cannot set or reset the memory block property more than once for the virtualization infrastructure driver. Restarting the virtual machine may fix the problem. If the problem persists, try restarting the physical computer.
//


//
// MessageId: ERROR_VID_MMIO_RANGE_DESTROYED
//
// MessageText:
//
// The memory mapped I/O for this page range no longer exists. Restarting the virtual machine may fix the problem. If the problem persists, try restarting the physical computer.
//


//
// MessageId: ERROR_VID_INVALID_CHILD_GPA_PAGE_SET
//
// MessageText:
//
// The lock or unlock request uses an invalid guest operating system memory address. Restarting the virtual machine may fix the problem. If the problem persists, try restarting the physical computer.
//


//
// MessageId: ERROR_VID_RESERVE_PAGE_SET_IS_BEING_USED
//
// MessageText:
//
// Cannot destroy or reuse the reserve page set for the virtualization infrastructure driver because it is in use. Restarting the virtual machine may fix the problem. If the problem persists, try restarting the physical computer.
//


//
// MessageId: ERROR_VID_RESERVE_PAGE_SET_TOO_SMALL
//
// MessageText:
//
// The reserve page set for the virtualization infrastructure driver is too small to use in the lock request. Restarting the virtual machine may fix the problem. If the problem persists, try restarting the physical computer.
//


//
// MessageId: ERROR_VID_MBP_ALREADY_LOCKED_USING_RESERVED_PAGE
//
// MessageText:
//
// Cannot lock or map the memory block page for the virtualization infrastructure driver because it has already been locked using a reserve page set page. Restarting the virtual machine may fix the problem. If the problem persists, try restarting the physical computer.
//


//
// MessageId: ERROR_VID_MBP_COUNT_EXCEEDED_LIMIT
//
// MessageText:
//
// Cannot create the memory block for the virtualization infrastructure driver because the requested number of pages exceeded the limit. Restarting the virtual machine may fix the problem. If the problem persists, try restarting the physical computer.
//


//
// MessageId: ERROR_VID_SAVED_STATE_CORRUPT
//
// MessageText:
//
// Cannot restore this virtual machine because the saved state data cannot be read. Delete the saved state data and then try to start the virtual machine.
//


//
// MessageId: ERROR_VID_SAVED_STATE_UNRECOGNIZED_ITEM
//
// MessageText:
//
// Cannot restore this virtual machine because an item read from the saved state data is not recognized. Delete the saved state data and then try to start the virtual machine.
//


//
// MessageId: ERROR_VID_SAVED_STATE_INCOMPATIBLE
//
// MessageText:
//
// Cannot restore this virtual machine to the saved state because of hypervisor incompatibility. Delete the saved state data and then try to start the virtual machine.
//


//
// MessageId: ERROR_VID_VTL_ACCESS_DENIED
//
// MessageText:
//
// The specified VTL does not have the permission to access the resource.
//


//
// Host compute service errors (0x0100-0x01ff)
//
//
// MessageId: ERROR_VMCOMPUTE_TERMINATED_DURING_START
//
// MessageText:
//
// The virtual machine or container exited unexpectedly while starting.
//


//
// MessageId: ERROR_VMCOMPUTE_IMAGE_MISMATCH
//
// MessageText:
//
// The container operating system does not match the host operating system.
//


//
// MessageId: ERROR_VMCOMPUTE_HYPERV_NOT_INSTALLED
//
// MessageText:
//
// The virtual machine could not be started because a required feature is not installed.
//


//
// MessageId: ERROR_VMCOMPUTE_OPERATION_PENDING
//
// MessageText:
//
// The call to start an asynchronous operation succeeded and the operation is performed in the background.
//


//
// MessageId: ERROR_VMCOMPUTE_TOO_MANY_NOTIFICATIONS
//
// MessageText:
//
// The supported number of notification callbacks has been exceeded.
//


//
// MessageId: ERROR_VMCOMPUTE_INVALID_STATE
//
// MessageText:
//
// The requested virtual machine or container operation is not valid in the current state.
//


//
// MessageId: ERROR_VMCOMPUTE_UNEXPECTED_EXIT
//
// MessageText:
//
// The virtual machine or container exited unexpectedly.
//


//
// MessageId: ERROR_VMCOMPUTE_TERMINATED
//
// MessageText:
//
// The virtual machine or container was forcefully exited.
//


//
// MessageId: ERROR_VMCOMPUTE_CONNECT_FAILED
//
// MessageText:
//
// A connection could not be established with the container or virtual machine.
//


//
// MessageId: ERROR_VMCOMPUTE_TIMEOUT
//
// MessageText:
//
// The operation timed out because a response was not received from the virtual machine or container.
//


//
// MessageId: ERROR_VMCOMPUTE_CONNECTION_CLOSED
//
// MessageText:
//
// The connection with the virtual machine or container was closed.
//


//
// MessageId: ERROR_VMCOMPUTE_UNKNOWN_MESSAGE
//
// MessageText:
//
// An unknown internal message was received by the virtual machine or container.
//


//
// MessageId: ERROR_VMCOMPUTE_UNSUPPORTED_PROTOCOL_VERSION
//
// MessageText:
//
// The virtual machine or container does not support an available version of the communication protocol with the host.
//


//
// MessageId: ERROR_VMCOMPUTE_INVALID_JSON
//
// MessageText:
//
// The virtual machine or container JSON document is invalid.
//


//
// MessageId: ERROR_VMCOMPUTE_SYSTEM_NOT_FOUND
//
// MessageText:
//
// A virtual machine or container with the specified identifier does not exist.
//


//
// MessageId: ERROR_VMCOMPUTE_SYSTEM_ALREADY_EXISTS
//
// MessageText:
//
// A virtual machine or container with the specified identifier already exists.
//


//
// MessageId: ERROR_VMCOMPUTE_SYSTEM_ALREADY_STOPPED
//
// MessageText:
//
// The virtual machine or container with the specified identifier is not running.
//


//
// MessageId: ERROR_VMCOMPUTE_PROTOCOL_ERROR
//
// MessageText:
//
// A communication protocol error has occurred between the virtual machine or container and the host.
//


//
// MessageId: ERROR_VMCOMPUTE_INVALID_LAYER
//
// MessageText:
//
// The container image contains a layer with an unrecognized format.
//


//
// MessageId: ERROR_VMCOMPUTE_WINDOWS_INSIDER_REQUIRED
//
// MessageText:
//
// To use this container image, you must join the Windows Insider Program. Please see https://go.microsoft.com/fwlink/?linkid=850659 for more information.
//


//
// Host Compute System error codes (0x0100-0x01ff HRESULT codes)
//
//
// MessageId: HCS_E_TERMINATED_DURING_START
//
// MessageText:
//
// The virtual machine or container exited unexpectedly while starting.
//


//
// MessageId: HCS_E_IMAGE_MISMATCH
//
// MessageText:
//
// The container operating system does not match the host operating system.
//


//
// MessageId: HCS_E_HYPERV_NOT_INSTALLED
//
// MessageText:
//
// The virtual machine could not be started because a required feature is not installed.
//


//
// MessageId: HCS_E_INVALID_STATE
//
// MessageText:
//
// The requested virtual machine or container operation is not valid in the current state.
//


//
// MessageId: HCS_E_UNEXPECTED_EXIT
//
// MessageText:
//
// The virtual machine or container exited unexpectedly.
//


//
// MessageId: HCS_E_TERMINATED
//
// MessageText:
//
// The virtual machine or container was forcefully exited.
//


//
// MessageId: HCS_E_CONNECT_FAILED
//
// MessageText:
//
// A connection could not be established with the container or virtual machine.
//


//
// MessageId: HCS_E_CONNECTION_TIMEOUT
//
// MessageText:
//
// The operation timed out because a response was not received from the virtual machine or container.
//


//
// MessageId: HCS_E_CONNECTION_CLOSED
//
// MessageText:
//
// The connection with the virtual machine or container was closed.
//


//
// MessageId: HCS_E_UNKNOWN_MESSAGE
//
// MessageText:
//
// An unknown internal message was received by the virtual machine or container.
//


//
// MessageId: HCS_E_UNSUPPORTED_PROTOCOL_VERSION
//
// MessageText:
//
// The virtual machine or container does not support an available version of the communication protocol with the host.
//


//
// MessageId: HCS_E_INVALID_JSON
//
// MessageText:
//
// The virtual machine or container JSON document is invalid.
//


//
// MessageId: HCS_E_SYSTEM_NOT_FOUND
//
// MessageText:
//
// A virtual machine or container with the specified identifier does not exist.
//


//
// MessageId: HCS_E_SYSTEM_ALREADY_EXISTS
//
// MessageText:
//
// A virtual machine or container with the specified identifier already exists.
//


//
// MessageId: HCS_E_SYSTEM_ALREADY_STOPPED
//
// MessageText:
//
// The virtual machine or container with the specified identifier is not running.
//


//
// MessageId: HCS_E_PROTOCOL_ERROR
//
// MessageText:
//
// A communication protocol error has occurred between the virtual machine or container and the host.
//


//
// MessageId: HCS_E_INVALID_LAYER
//
// MessageText:
//
// The container image contains a layer with an unrecognized format.
//


//
// MessageId: HCS_E_WINDOWS_INSIDER_REQUIRED
//
// MessageText:
//
// To use this container image, you must join the Windows Insider Program. Please see https://go.microsoft.com/fwlink/?linkid=850659 for more information.
//


//
// MessageId: HCS_E_SERVICE_NOT_AVAILABLE
//
// MessageText:
//
// The operation could not be started because a required feature is not installed.
//


//
// MessageId: HCS_E_OPERATION_NOT_STARTED
//
// MessageText:
//
// The operation has not started.
//


//
// MessageId: HCS_E_OPERATION_ALREADY_STARTED
//
// MessageText:
//
// The operation is already running.
//


//
// MessageId: HCS_E_OPERATION_PENDING
//
// MessageText:
//
// The operation is still running.
//


//
// MessageId: HCS_E_OPERATION_TIMEOUT
//
// MessageText:
//
// The operation did not complete in time.
//


//
// MessageId: HCS_E_OPERATION_SYSTEM_CALLBACK_ALREADY_SET
//
// MessageText:
//
// An event callback has already been registered on this handle.
//


//
// MessageId: HCS_E_OPERATION_RESULT_ALLOCATION_FAILED
//
// MessageText:
//
// Not enough memory available to return the result of the operation.
//


//
// MessageId: HCS_E_ACCESS_DENIED
//
// MessageText:
//
// Insufficient privileges. Only administrators or users that are members of the Hyper-V Administrators user group are permitted to access virtual machines or containers. To add yourself to the Hyper-V Administrators user group, please see https://aka.ms/hcsadmin for more information.
//


//
// MessageId: HCS_E_GUEST_CRITICAL_ERROR
//
// MessageText:
//
// The virtual machine or container reported a critical error and was stopped or restarted.
//


//
// Virtual networking errors (0x0200-0x02ff)
//
//
// MessageId: ERROR_VNET_VIRTUAL_SWITCH_NAME_NOT_FOUND
//
// MessageText:
//
// A virtual switch with the given name was not found.
//


//
// VID warnings (0x0000 - 0x00ff):
//
//
// MessageId: ERROR_VID_REMOTE_NODE_PARENT_GPA_PAGES_USED
//
// MessageText:
//
// A virtual machine is running with its memory allocated across multiple NUMA nodes. This does not indicate a problem unless the performance of your virtual machine is unusually slow. If you are experiencing performance problems, you may need to modify the NUMA configuration.
//


//
// User-mode Hypervisor API error codes (0x0300-0x03ff)
//
//
// MessageId: WHV_E_UNKNOWN_CAPABILITY
//
// MessageText:
//
// The specified capability does not exist.
//


//
// MessageId: WHV_E_INSUFFICIENT_BUFFER
//
// MessageText:
//
// The specified buffer is too small for the requested data.
//


//
// MessageId: WHV_E_UNKNOWN_PROPERTY
//
// MessageText:
//
// The specified property does not exist.
//


//
// MessageId: WHV_E_UNSUPPORTED_HYPERVISOR_CONFIG
//
// MessageText:
//
// The configuration of the hypervisor on this system is not supported.
//


//
// MessageId: WHV_E_INVALID_PARTITION_CONFIG
//
// MessageText:
//
// The configuration of the partition is not valid.
//


//
// MessageId: WHV_E_GPA_RANGE_NOT_FOUND
//
// MessageText:
//
// The specified GPA range was not found.
//


//
// MessageId: WHV_E_VP_ALREADY_EXISTS
//
// MessageText:
//
// A virtual processor with the specified index already exists.
//


//
// MessageId: WHV_E_VP_DOES_NOT_EXIST
//
// MessageText:
//
// A virtual processor with the specified index does not exist.
//


//
// MessageId: WHV_E_INVALID_VP_STATE
//
// MessageText:
//
// The virtual processor is not in the correct state to perform the requested operation.
//


//
// MessageId: WHV_E_INVALID_VP_REGISTER_NAME
//
// MessageText:
//
// A virtual processor register with the specified name does not exist.
//


//
// Virtual storage error codes (0x0400-0x04ff)
//
//
// MessageId: ERROR_VSMB_SAVED_STATE_FILE_NOT_FOUND
//
// MessageText:
//
// Cannot restore this virtual machine because a file read from the vSMB saved state data could not be found. Delete the saved state data and then try to start the virtual machine.
//


//
// MessageId: ERROR_VSMB_SAVED_STATE_CORRUPT
//
// MessageText:
//
// Cannot restore this virtual machine because the vSMB saved state data cannot be read. Delete the saved state data and then try to start the virtual machine.
//



//
// Volume manager error codes mapped from status codes
//

//
// WARNINGS
//
//
// MessageId: ERROR_VOLMGR_INCOMPLETE_REGENERATION
//
// MessageText:
//
// The regeneration operation was not able to copy all data from the active plexes due to bad sectors.
//


//
// MessageId: ERROR_VOLMGR_INCOMPLETE_DISK_MIGRATION
//
// MessageText:
//
// One or more disks were not fully migrated to the target pack. They may or may not require reimport after fixing the hardware problems.
//


//
// ERRORS
//
//
// MessageId: ERROR_VOLMGR_DATABASE_FULL
//
// MessageText:
//
// The configuration database is full.
//


//
// MessageId: ERROR_VOLMGR_DISK_CONFIGURATION_CORRUPTED
//
// MessageText:
//
// The configuration data on the disk is corrupted.
//


//
// MessageId: ERROR_VOLMGR_DISK_CONFIGURATION_NOT_IN_SYNC
//
// MessageText:
//
// The configuration on the disk is not insync with the in-memory configuration.
//


//
// MessageId: ERROR_VOLMGR_PACK_CONFIG_UPDATE_FAILED
//
// MessageText:
//
// A majority of disks failed to be updated with the new configuration.
//


//
// MessageId: ERROR_VOLMGR_DISK_CONTAINS_NON_SIMPLE_VOLUME
//
// MessageText:
//
// The disk contains non-simple volumes.
//


//
// MessageId: ERROR_VOLMGR_DISK_DUPLICATE
//
// MessageText:
//
// The same disk was specified more than once in the migration list.
//


//
// MessageId: ERROR_VOLMGR_DISK_DYNAMIC
//
// MessageText:
//
// The disk is already dynamic.
//


//
// MessageId: ERROR_VOLMGR_DISK_ID_INVALID
//
// MessageText:
//
// The specified disk id is invalid. There are no disks with the specified disk id.
//


//
// MessageId: ERROR_VOLMGR_DISK_INVALID
//
// MessageText:
//
// The specified disk is an invalid disk. Operation cannot complete on an invalid disk.
//


//
// MessageId: ERROR_VOLMGR_DISK_LAST_VOTER
//
// MessageText:
//
// The specified disk(s) cannot be removed since it is the last remaining voter.
//


//
// MessageId: ERROR_VOLMGR_DISK_LAYOUT_INVALID
//
// MessageText:
//
// The specified disk has an invalid disk layout.
//


//
// MessageId: ERROR_VOLMGR_DISK_LAYOUT_NON_BASIC_BETWEEN_BASIC_PARTITIONS
//
// MessageText:
//
// The disk layout contains non-basic partitions which appear after basic partitions. This is an invalid disk layout.
//


//
// MessageId: ERROR_VOLMGR_DISK_LAYOUT_NOT_CYLINDER_ALIGNED
//
// MessageText:
//
// The disk layout contains partitions which are not cylinder aligned.
//


//
// MessageId: ERROR_VOLMGR_DISK_LAYOUT_PARTITIONS_TOO_SMALL
//
// MessageText:
//
// The disk layout contains partitions which are smaller than the minimum size.
//


//
// MessageId: ERROR_VOLMGR_DISK_LAYOUT_PRIMARY_BETWEEN_LOGICAL_PARTITIONS
//
// MessageText:
//
// The disk layout contains primary partitions in between logical drives. This is an invalid disk layout.
//


//
// MessageId: ERROR_VOLMGR_DISK_LAYOUT_TOO_MANY_PARTITIONS
//
// MessageText:
//
// The disk layout contains more than the maximum number of supported partitions.
//


//
// MessageId: ERROR_VOLMGR_DISK_MISSING
//
// MessageText:
//
// The specified disk is missing. The operation cannot complete on a missing disk.
//


//
// MessageId: ERROR_VOLMGR_DISK_NOT_EMPTY
//
// MessageText:
//
// The specified disk is not empty.
//


//
// MessageId: ERROR_VOLMGR_DISK_NOT_ENOUGH_SPACE
//
// MessageText:
//
// There is not enough usable space for this operation.
//


//
// MessageId: ERROR_VOLMGR_DISK_REVECTORING_FAILED
//
// MessageText:
//
// The force revectoring of bad sectors failed.
//


//
// MessageId: ERROR_VOLMGR_DISK_SECTOR_SIZE_INVALID
//
// MessageText:
//
// The specified disk has an invalid sector size.
//


//
// MessageId: ERROR_VOLMGR_DISK_SET_NOT_CONTAINED
//
// MessageText:
//
// The specified disk set contains volumes which exist on disks outside of the set.
//


//
// MessageId: ERROR_VOLMGR_DISK_USED_BY_MULTIPLE_MEMBERS
//
// MessageText:
//
// A disk in the volume layout provides extents to more than one member of a plex.
//


//
// MessageId: ERROR_VOLMGR_DISK_USED_BY_MULTIPLE_PLEXES
//
// MessageText:
//
// A disk in the volume layout provides extents to more than one plex.
//


//
// MessageId: ERROR_VOLMGR_DYNAMIC_DISK_NOT_SUPPORTED
//
// MessageText:
//
// Dynamic disks are not supported on this system.
//


//
// MessageId: ERROR_VOLMGR_EXTENT_ALREADY_USED
//
// MessageText:
//
// The specified extent is already used by other volumes.
//


//
// MessageId: ERROR_VOLMGR_EXTENT_NOT_CONTIGUOUS
//
// MessageText:
//
// The specified volume is retained and can only be extended into a contiguous extent. The specified extent to grow the volume is not contiguous with the specified volume.
//


//
// MessageId: ERROR_VOLMGR_EXTENT_NOT_IN_PUBLIC_REGION
//
// MessageText:
//
// The specified volume extent is not within the public region of the disk.
//


//
// MessageId: ERROR_VOLMGR_EXTENT_NOT_SECTOR_ALIGNED
//
// MessageText:
//
// The specified volume extent is not sector aligned.
//


//
// MessageId: ERROR_VOLMGR_EXTENT_OVERLAPS_EBR_PARTITION
//
// MessageText:
//
// The specified partition overlaps an EBR (the first track of an extended partition on an MBR disk).
//


//
// MessageId: ERROR_VOLMGR_EXTENT_VOLUME_LENGTHS_DO_NOT_MATCH
//
// MessageText:
//
// The specified extent lengths cannot be used to construct a volume with specified length.
//


//
// MessageId: ERROR_VOLMGR_FAULT_TOLERANT_NOT_SUPPORTED
//
// MessageText:
//
// The system does not support fault tolerant volumes.
//


//
// MessageId: ERROR_VOLMGR_INTERLEAVE_LENGTH_INVALID
//
// MessageText:
//
// The specified interleave length is invalid.
//


//
// MessageId: ERROR_VOLMGR_MAXIMUM_REGISTERED_USERS
//
// MessageText:
//
// There is already a maximum number of registered users.
//


//
// MessageId: ERROR_VOLMGR_MEMBER_IN_SYNC
//
// MessageText:
//
// The specified member is already in-sync with the other active members. It does not need to be regenerated.
//


//
// MessageId: ERROR_VOLMGR_MEMBER_INDEX_DUPLICATE
//
// MessageText:
//
// The same member index was specified more than once.
//


//
// MessageId: ERROR_VOLMGR_MEMBER_INDEX_INVALID
//
// MessageText:
//
// The specified member index is greater or equal than the number of members in the volume plex.
//


//
// MessageId: ERROR_VOLMGR_MEMBER_MISSING
//
// MessageText:
//
// The specified member is missing. It cannot be regenerated.
//


//
// MessageId: ERROR_VOLMGR_MEMBER_NOT_DETACHED
//
// MessageText:
//
// The specified member is not detached. Cannot replace a member which is not detached.
//


//
// MessageId: ERROR_VOLMGR_MEMBER_REGENERATING
//
// MessageText:
//
// The specified member is already regenerating.
//


//
// MessageId: ERROR_VOLMGR_ALL_DISKS_FAILED
//
// MessageText:
//
// All disks belonging to the pack failed.
//


//
// MessageId: ERROR_VOLMGR_NO_REGISTERED_USERS
//
// MessageText:
//
// There are currently no registered users for notifications. The task number is irrelevant unless there are registered users.
//


//
// MessageId: ERROR_VOLMGR_NO_SUCH_USER
//
// MessageText:
//
// The specified notification user does not exist. Failed to unregister user for notifications.
//


//
// MessageId: ERROR_VOLMGR_NOTIFICATION_RESET
//
// MessageText:
//
// The notifications have been reset. Notifications for the current user are invalid. Unregister and re-register for notifications.
//


//
// MessageId: ERROR_VOLMGR_NUMBER_OF_MEMBERS_INVALID
//
// MessageText:
//
// The specified number of members is invalid.
//


//
// MessageId: ERROR_VOLMGR_NUMBER_OF_PLEXES_INVALID
//
// MessageText:
//
// The specified number of plexes is invalid.
//


//
// MessageId: ERROR_VOLMGR_PACK_DUPLICATE
//
// MessageText:
//
// The specified source and target packs are identical.
//


//
// MessageId: ERROR_VOLMGR_PACK_ID_INVALID
//
// MessageText:
//
// The specified pack id is invalid. There are no packs with the specified pack id.
//


//
// MessageId: ERROR_VOLMGR_PACK_INVALID
//
// MessageText:
//
// The specified pack is the invalid pack. The operation cannot complete with the invalid pack.
//


//
// MessageId: ERROR_VOLMGR_PACK_NAME_INVALID
//
// MessageText:
//
// The specified pack name is invalid.
//


//
// MessageId: ERROR_VOLMGR_PACK_OFFLINE
//
// MessageText:
//
// The specified pack is offline.
//


//
// MessageId: ERROR_VOLMGR_PACK_HAS_QUORUM
//
// MessageText:
//
// The specified pack already has a quorum of healthy disks.
//


//
// MessageId: ERROR_VOLMGR_PACK_WITHOUT_QUORUM
//
// MessageText:
//
// The pack does not have a quorum of healthy disks.
//


//
// MessageId: ERROR_VOLMGR_PARTITION_STYLE_INVALID
//
// MessageText:
//
// The specified disk has an unsupported partition style. Only MBR and GPT partition styles are supported.
//


//
// MessageId: ERROR_VOLMGR_PARTITION_UPDATE_FAILED
//
// MessageText:
//
// Failed to update the disk's partition layout.
//


//
// MessageId: ERROR_VOLMGR_PLEX_IN_SYNC
//
// MessageText:
//
// The specified plex is already in-sync with the other active plexes. It does not need to be regenerated.
//


//
// MessageId: ERROR_VOLMGR_PLEX_INDEX_DUPLICATE
//
// MessageText:
//
// The same plex index was specified more than once.
//


//
// MessageId: ERROR_VOLMGR_PLEX_INDEX_INVALID
//
// MessageText:
//
// The specified plex index is greater or equal than the number of plexes in the volume.
//


//
// MessageId: ERROR_VOLMGR_PLEX_LAST_ACTIVE
//
// MessageText:
//
// The specified plex is the last active plex in the volume. The plex cannot be removed or else the volume will go offline.
//


//
// MessageId: ERROR_VOLMGR_PLEX_MISSING
//
// MessageText:
//
// The specified plex is missing.
//


//
// MessageId: ERROR_VOLMGR_PLEX_REGENERATING
//
// MessageText:
//
// The specified plex is currently regenerating.
//


//
// MessageId: ERROR_VOLMGR_PLEX_TYPE_INVALID
//
// MessageText:
//
// The specified plex type is invalid.
//


//
// MessageId: ERROR_VOLMGR_PLEX_NOT_RAID5
//
// MessageText:
//
// The operation is only supported on RAID-5 plexes.
//


//
// MessageId: ERROR_VOLMGR_PLEX_NOT_SIMPLE
//
// MessageText:
//
// The operation is only supported on simple plexes.
//


//
// MessageId: ERROR_VOLMGR_STRUCTURE_SIZE_INVALID
//
// MessageText:
//
// The Size fields in the VM_VOLUME_LAYOUT input structure are incorrectly set.
//


//
// MessageId: ERROR_VOLMGR_TOO_MANY_NOTIFICATION_REQUESTS
//
// MessageText:
//
// There is already a pending request for notifications. Wait for the existing request to return before requesting for more notifications.
//


//
// MessageId: ERROR_VOLMGR_TRANSACTION_IN_PROGRESS
//
// MessageText:
//
// There is currently a transaction in process.
//


//
// MessageId: ERROR_VOLMGR_UNEXPECTED_DISK_LAYOUT_CHANGE
//
// MessageText:
//
// An unexpected layout change occurred outside of the volume manager.
//


//
// MessageId: ERROR_VOLMGR_VOLUME_CONTAINS_MISSING_DISK
//
// MessageText:
//
// The specified volume contains a missing disk.
//


//
// MessageId: ERROR_VOLMGR_VOLUME_ID_INVALID
//
// MessageText:
//
// The specified volume id is invalid. There are no volumes with the specified volume id.
//


//
// MessageId: ERROR_VOLMGR_VOLUME_LENGTH_INVALID
//
// MessageText:
//
// The specified volume length is invalid.
//


//
// MessageId: ERROR_VOLMGR_VOLUME_LENGTH_NOT_SECTOR_SIZE_MULTIPLE
//
// MessageText:
//
// The specified size for the volume is not a multiple of the sector size.
//


//
// MessageId: ERROR_VOLMGR_VOLUME_NOT_MIRRORED
//
// MessageText:
//
// The operation is only supported on mirrored volumes.
//


//
// MessageId: ERROR_VOLMGR_VOLUME_NOT_RETAINED
//
// MessageText:
//
// The specified volume does not have a retain partition.
//


//
// MessageId: ERROR_VOLMGR_VOLUME_OFFLINE
//
// MessageText:
//
// The specified volume is offline.
//


//
// MessageId: ERROR_VOLMGR_VOLUME_RETAINED
//
// MessageText:
//
// The specified volume already has a retain partition.
//


//
// MessageId: ERROR_VOLMGR_NUMBER_OF_EXTENTS_INVALID
//
// MessageText:
//
// The specified number of extents is invalid.
//


//
// MessageId: ERROR_VOLMGR_DIFFERENT_SECTOR_SIZE
//
// MessageText:
//
// All disks participating to the volume must have the same sector size.
//


//
// MessageId: ERROR_VOLMGR_BAD_BOOT_DISK
//
// MessageText:
//
// The boot disk experienced failures.
//


//
// MessageId: ERROR_VOLMGR_PACK_CONFIG_OFFLINE
//
// MessageText:
//
// The configuration of the pack is offline.
//


//
// MessageId: ERROR_VOLMGR_PACK_CONFIG_ONLINE
//
// MessageText:
//
// The configuration of the pack is online.
//


//
// MessageId: ERROR_VOLMGR_NOT_PRIMARY_PACK
//
// MessageText:
//
// The specified pack is not the primary pack.
//


//
// MessageId: ERROR_VOLMGR_PACK_LOG_UPDATE_FAILED
//
// MessageText:
//
// All disks failed to be updated with the new content of the log.
//


//
// MessageId: ERROR_VOLMGR_NUMBER_OF_DISKS_IN_PLEX_INVALID
//
// MessageText:
//
// The specified number of disks in a plex is invalid.
//


//
// MessageId: ERROR_VOLMGR_NUMBER_OF_DISKS_IN_MEMBER_INVALID
//
// MessageText:
//
// The specified number of disks in a plex member is invalid.
//


//
// MessageId: ERROR_VOLMGR_VOLUME_MIRRORED
//
// MessageText:
//
// The operation is not supported on mirrored volumes.
//


//
// MessageId: ERROR_VOLMGR_PLEX_NOT_SIMPLE_SPANNED
//
// MessageText:
//
// The operation is only supported on simple and spanned plexes.
//


//
// MessageId: ERROR_VOLMGR_NO_VALID_LOG_COPIES
//
// MessageText:
//
// The pack has no valid log copies.
//


//
// MessageId: ERROR_VOLMGR_PRIMARY_PACK_PRESENT
//
// MessageText:
//
// A primary pack is already present.
//


//
// MessageId: ERROR_VOLMGR_NUMBER_OF_DISKS_INVALID
//
// MessageText:
//
// The specified number of disks is invalid.
//


//
// MessageId: ERROR_VOLMGR_MIRROR_NOT_SUPPORTED
//
// MessageText:
//
// The system does not support mirrored volumes.
//


//
// MessageId: ERROR_VOLMGR_RAID5_NOT_SUPPORTED
//
// MessageText:
//
// The system does not support RAID-5 volumes.
//



//
// Boot Code Data (BCD) error codes
//

//
// MessageId: ERROR_BCD_NOT_ALL_ENTRIES_IMPORTED
//
// MessageText:
//
// Some BCD entries were not imported correctly from the BCD store.
//


//
// MessageId: ERROR_BCD_TOO_MANY_ELEMENTS
//
// MessageText:
//
// Entries enumerated have exceeded the allowed threshold.
//


//
// MessageId: ERROR_BCD_NOT_ALL_ENTRIES_SYNCHRONIZED
//
// MessageText:
//
// Some BCD entries were not synchronized correctly with the firmware.
//


//
// Vhd error codes - These codes are used by the virtual hard diskparser component.
//
//
// Errors:
//

//
// MessageId: ERROR_VHD_DRIVE_FOOTER_MISSING
//
// MessageText:
//
// The virtual hard disk is corrupted. The virtual hard disk drive footer is missing.
//


//
// MessageId: ERROR_VHD_DRIVE_FOOTER_CHECKSUM_MISMATCH
//
// MessageText:
//
// The virtual hard disk is corrupted. The virtual hard disk drive footer checksum does not match the on-disk checksum.
//


//
// MessageId: ERROR_VHD_DRIVE_FOOTER_CORRUPT
//
// MessageText:
//
// The virtual hard disk is corrupted. The virtual hard disk drive footer in the virtual hard disk is corrupted.
//


//
// MessageId: ERROR_VHD_FORMAT_UNKNOWN
//
// MessageText:
//
// The system does not recognize the file format of this virtual hard disk.
//


//
// MessageId: ERROR_VHD_FORMAT_UNSUPPORTED_VERSION
//
// MessageText:
//
// The version does not support this version of the file format.
//


//
// MessageId: ERROR_VHD_SPARSE_HEADER_CHECKSUM_MISMATCH
//
// MessageText:
//
// The virtual hard disk is corrupted. The sparse header checksum does not match the on-disk checksum.
//


//
// MessageId: ERROR_VHD_SPARSE_HEADER_UNSUPPORTED_VERSION
//
// MessageText:
//
// The system does not support this version of the virtual hard disk.This version of the sparse header is not supported.
//


//
// MessageId: ERROR_VHD_SPARSE_HEADER_CORRUPT
//
// MessageText:
//
// The virtual hard disk is corrupted. The sparse header in the virtual hard disk is corrupt.
//


//
// MessageId: ERROR_VHD_BLOCK_ALLOCATION_FAILURE
//
// MessageText:
//
// Failed to write to the virtual hard disk failed because the system failed to allocate a new block in the virtual hard disk.
//


//
// MessageId: ERROR_VHD_BLOCK_ALLOCATION_TABLE_CORRUPT
//
// MessageText:
//
// The virtual hard disk is corrupted. The block allocation table in the virtual hard disk is corrupt.
//


//
// MessageId: ERROR_VHD_INVALID_BLOCK_SIZE
//
// MessageText:
//
// The system does not support this version of the virtual hard disk. The block size is invalid.
//


//
// MessageId: ERROR_VHD_BITMAP_MISMATCH
//
// MessageText:
//
// The virtual hard disk is corrupted. The block bitmap does not match with the block data present in the virtual hard disk.
//


//
// MessageId: ERROR_VHD_PARENT_VHD_NOT_FOUND
//
// MessageText:
//
// The chain of virtual hard disks is broken. The system cannot locate the parent virtual hard disk for the differencing disk.
//


//
// MessageId: ERROR_VHD_CHILD_PARENT_ID_MISMATCH
//
// MessageText:
//
// The chain of virtual hard disks is corrupted. There is a mismatch in the identifiers of the parent virtual hard disk and differencing disk.
//


//
// MessageId: ERROR_VHD_CHILD_PARENT_TIMESTAMP_MISMATCH
//
// MessageText:
//
// The chain of virtual hard disks is corrupted. The time stamp of the parent virtual hard disk does not match the time stamp of the differencing disk.
//


//
// MessageId: ERROR_VHD_METADATA_READ_FAILURE
//
// MessageText:
//
// Failed to read the metadata of the virtual hard disk.
//


//
// MessageId: ERROR_VHD_METADATA_WRITE_FAILURE
//
// MessageText:
//
// Failed to write to the metadata of the virtual hard disk.
//


//
// MessageId: ERROR_VHD_INVALID_SIZE
//
// MessageText:
//
// The size of the virtual hard disk is not valid.
//


//
// MessageId: ERROR_VHD_INVALID_FILE_SIZE
//
// MessageText:
//
// The file size of this virtual hard disk is not valid.
//


//
// MessageId: ERROR_VIRTDISK_PROVIDER_NOT_FOUND
//
// MessageText:
//
// A virtual disk support provider for the specified file was not found.
//


//
// MessageId: ERROR_VIRTDISK_NOT_VIRTUAL_DISK
//
// MessageText:
//
// The specified disk is not a virtual disk.
//


//
// MessageId: ERROR_VHD_PARENT_VHD_ACCESS_DENIED
//
// MessageText:
//
// The chain of virtual hard disks is inaccessible. The process has not been granted access rights to the parent virtual hard disk for the differencing disk.
//


//
// MessageId: ERROR_VHD_CHILD_PARENT_SIZE_MISMATCH
//
// MessageText:
//
// The chain of virtual hard disks is corrupted. There is a mismatch in the virtual sizes of the parent virtual hard disk and differencing disk.
//


//
// MessageId: ERROR_VHD_DIFFERENCING_CHAIN_CYCLE_DETECTED
//
// MessageText:
//
// The chain of virtual hard disks is corrupted. A differencing disk is indicated in its own parent chain.
//


//
// MessageId: ERROR_VHD_DIFFERENCING_CHAIN_ERROR_IN_PARENT
//
// MessageText:
//
// The chain of virtual hard disks is inaccessible. There was an error opening a virtual hard disk further up the chain.
//


//
// MessageId: ERROR_VIRTUAL_DISK_LIMITATION
//
// MessageText:
//
// The requested operation could not be completed due to a virtual disk system limitation.  Virtual hard disk files must be uncompressed and unencrypted and must not be sparse.
//


//
// MessageId: ERROR_VHD_INVALID_TYPE
//
// MessageText:
//
// The requested operation cannot be performed on a virtual disk of this type.
//


//
// MessageId: ERROR_VHD_INVALID_STATE
//
// MessageText:
//
// The requested operation cannot be performed on the virtual disk in its current state.
//


//
// MessageId: ERROR_VIRTDISK_UNSUPPORTED_DISK_SECTOR_SIZE
//
// MessageText:
//
// The sector size of the physical disk on which the virtual disk resides is not supported.
//


//
// MessageId: ERROR_VIRTDISK_DISK_ALREADY_OWNED
//
// MessageText:
//
// The disk is already owned by a different owner.
//


//
// MessageId: ERROR_VIRTDISK_DISK_ONLINE_AND_WRITABLE
//
// MessageText:
//
// The disk must be offline or read-only.
//


//
// MessageId: ERROR_CTLOG_TRACKING_NOT_INITIALIZED
//
// MessageText:
//
// Change Tracking is not initialized for this virtual disk.
//


//
// MessageId: ERROR_CTLOG_LOGFILE_SIZE_EXCEEDED_MAXSIZE
//
// MessageText:
//
// Size of change tracking file exceeded the maximum size limit.
//


//
// MessageId: ERROR_CTLOG_VHD_CHANGED_OFFLINE
//
// MessageText:
//
// VHD file is changed due to compaction, expansion, or offline updates.
//


//
// MessageId: ERROR_CTLOG_INVALID_TRACKING_STATE
//
// MessageText:
//
// Change Tracking for the virtual disk is not in a valid state to perform this request.  Change tracking could be discontinued or already in the requested state.
//


//
// MessageId: ERROR_CTLOG_INCONSISTENT_TRACKING_FILE
//
// MessageText:
//
// Change Tracking file for the virtual disk is not in a valid state.
//


//
// MessageId: ERROR_VHD_RESIZE_WOULD_TRUNCATE_DATA
//
// MessageText:
//
// The requested resize operation could not be completed because it might truncate user data residing on the virtual disk.
//


//
// MessageId: ERROR_VHD_COULD_NOT_COMPUTE_MINIMUM_VIRTUAL_SIZE
//
// MessageText:
//
// The requested operation could not be completed because the virtual disk's minimum safe size could not be determined.
// This may be due to a missing or corrupt partition table.
//


//
// MessageId: ERROR_VHD_ALREADY_AT_OR_BELOW_MINIMUM_VIRTUAL_SIZE
//
// MessageText:
//
// The requested operation could not be completed because the virtual disk's size cannot be safely reduced further.
//


//
// MessageId: ERROR_VHD_METADATA_FULL
//
// MessageText:
//
// There is not enough space in the virtual disk file for the provided metadata item.
//


//
// MessageId: ERROR_VHD_INVALID_CHANGE_TRACKING_ID
//
// MessageText:
//
// The specified change tracking identifier is not valid.
//


//
// MessageId: ERROR_VHD_CHANGE_TRACKING_DISABLED
//
// MessageText:
//
// Change tracking is disabled for the specified virtual hard disk, so no change tracking information is available.
//


//
// MessageId: ERROR_VHD_MISSING_CHANGE_TRACKING_INFORMATION
//
// MessageText:
//
// There is no change tracking data available associated with the specified change tracking identifier.
//


//
// Warnings:
//
//
// MessageId: ERROR_QUERY_STORAGE_ERROR
//
// MessageText:
//
// The virtualization storage subsystem has generated an error.
//


//
// =======================================================
// Host Network Service (HNS/GNS) Error Messages
// =======================================================
//
//
// MessageId: HCN_E_NETWORK_NOT_FOUND
//
// MessageText:
//
// The network was not found.
//


//
// MessageId: HCN_E_ENDPOINT_NOT_FOUND
//
// MessageText:
//
// The endpoint was not found.
//


//
// MessageId: HCN_E_LAYER_NOT_FOUND
//
// MessageText:
//
// The network's underlying layer was not found.
//


//
// MessageId: HCN_E_SWITCH_NOT_FOUND
//
// MessageText:
//
// The virtual switch was not found.
//


//
// MessageId: HCN_E_SUBNET_NOT_FOUND
//
// MessageText:
//
// The network does not have a subnet for this endpoint.
//


//
// MessageId: HCN_E_ADAPTER_NOT_FOUND
//
// MessageText:
//
// An adapter was not found.
//


//
// MessageId: HCN_E_PORT_NOT_FOUND
//
// MessageText:
//
// The switch-port was not found.
//


//
// MessageId: HCN_E_POLICY_NOT_FOUND
//
// MessageText:
//
// An expected policy was not found.
//


//
// MessageId: HCN_E_VFP_PORTSETTING_NOT_FOUND
//
// MessageText:
//
// A required VFP port setting was not found.
//


//
// MessageId: HCN_E_INVALID_NETWORK
//
// MessageText:
//
// The provided network configuration is invalid or missing parameters.
//


//
// MessageId: HCN_E_INVALID_NETWORK_TYPE
//
// MessageText:
//
// Invalid network type.
//


//
// MessageId: HCN_E_INVALID_ENDPOINT
//
// MessageText:
//
// The provided endpoint configuration is invalid or missing parameters.
//


//
// MessageId: HCN_E_INVALID_POLICY
//
// MessageText:
//
// The provided policy configuration is invalid or missing parameters.
//


//
// MessageId: HCN_E_INVALID_POLICY_TYPE
//
// MessageText:
//
// Invalid policy type.
//


//
// MessageId: HCN_E_INVALID_REMOTE_ENDPOINT_OPERATION
//
// MessageText:
//
// This requested operation is invalid for a remote endpoint.
//


//
// MessageId: HCN_E_NETWORK_ALREADY_EXISTS
//
// MessageText:
//
// A network with this name already exists.
//


//
// MessageId: HCN_E_LAYER_ALREADY_EXISTS
//
// MessageText:
//
// A network with this name already exists.
//


//
// MessageId: HCN_E_POLICY_ALREADY_EXISTS
//
// MessageText:
//
// Policy information already exists on this object.
//


//
// MessageId: HCN_E_PORT_ALREADY_EXISTS
//
// MessageText:
//
// The specified port already exists.
//


//
// MessageId: HCN_E_ENDPOINT_ALREADY_ATTACHED
//
// MessageText:
//
// This endpoint is already attached to the switch.
//


//
// MessageId: HCN_E_REQUEST_UNSUPPORTED
//
// MessageText:
//
// The specified request is unsupported.
//


//
// MessageId: HCN_E_MAPPING_NOT_SUPPORTED
//
// MessageText:
//
// Port mapping is not supported on the given network.
//


//
// MessageId: HCN_E_DEGRADED_OPERATION
//
// MessageText:
//
// There was an operation attempted on a degraded object.
//


//
// MessageId: HCN_E_SHARED_SWITCH_MODIFICATION
//
// MessageText:
//
// Cannot modify a switch shared by multiple networks.
//


//
// MessageId: HCN_E_GUID_CONVERSION_FAILURE
//
// MessageText:
//
// Failed to interpret a parameter as a GUID.
//


//
// MessageId: HCN_E_REGKEY_FAILURE
//
// MessageText:
//
// Failed to process registry key.
//


//
// MessageId: HCN_E_INVALID_JSON
//
// MessageText:
//
// Invalid JSON document string.
//


//
// MessageId: HCN_E_INVALID_JSON_REFERENCE
//
// MessageText:
//
// The reference is invalid in the JSON document.
//


//
// MessageId: HCN_E_ENDPOINT_SHARING_DISABLED
//
// MessageText:
//
// Endpoint sharing is disabled.
//


//
// MessageId: HCN_E_INVALID_IP
//
// MessageText:
//
// IP address is either invalid or not part of any configured subnet(s).
//


//
// MessageId: HCN_E_SWITCH_EXTENSION_NOT_FOUND
//
// MessageText:
//
// The specified switch extension does not exist on this switch.
//


//
// MessageId: HCN_E_MANAGER_STOPPED
//
// MessageText:
//
// Operation cannot be performed while service is stopping.
//


//
// MessageId: GCN_E_MODULE_NOT_FOUND
//
// MessageText:
//
// Operation cannot be performed while service module not found.
//


//
// MessageId: GCN_E_NO_REQUEST_HANDLERS
//
// MessageText:
//
// Request Handlers not present to handle the JSON request.
//


//
// MessageId: GCN_E_REQUEST_UNSUPPORTED
//
// MessageText:
//
// The specified request is unsupported.
//


//
// MessageId: GCN_E_RUNTIMEKEYS_FAILED
//
// MessageText:
//
// Add runtime keys to container failed.
//


//
// MessageId: GCN_E_NETADAPTER_TIMEOUT
//
// MessageText:
//
// Timeout while waiting for network adapter with the given instance id
//


//
// MessageId: GCN_E_NETADAPTER_NOT_FOUND
//
// MessageText:
//
// Network adapter not found for the given instance id
//


//
// MessageId: GCN_E_NETCOMPARTMENT_NOT_FOUND
//
// MessageText:
//
// Network compartment not found for the given  id
//


//
// MessageId: GCN_E_NETINTERFACE_NOT_FOUND
//
// MessageText:
//
// Network interface not found for the given  id
//


//
// MessageId: GCN_E_DEFAULTNAMESPACE_EXISTS
//
// MessageText:
//
// Default Namespace already exists
//


//
// MessageId: HCN_E_ICS_DISABLED
//
// MessageText:
//
// Internet Connection Sharing service (SharedAccess) is disabled and cannot be started
//


//
// MessageId: HCN_E_ENDPOINT_NAMESPACE_ALREADY_EXISTS
//
// MessageText:
//
// This requested operation is invalid as endpoint is already part of a network namespace.
//


//
// MessageId: HCN_E_ENTITY_HAS_REFERENCES
//
// MessageText:
//
// The specified entity cannot be removed while it still has references.
//


//
// MessageId: HCN_E_INVALID_INTERNAL_PORT
//
// MessageText:
//
// The internal port must exist and cannot be zero.
//


//
// MessageId: HCN_E_NAMESPACE_ATTACH_FAILED
//
// MessageText:
//
// The requested operation for attach namespace failed.
//


//
// MessageId: HCN_E_ADDR_INVALID_OR_RESERVED
//
// MessageText:
//
// An address provided is invalid or reserved.
//


//
// =======================================================
// Facility Scripted Diagnostics (SDIAG) Error Messages
// =======================================================
//
//
// MessageId: SDIAG_E_CANCELLED
//
// MessageText:
//
// The operation was cancelled.
//


//
// MessageId: SDIAG_E_SCRIPT
//
// MessageText:
//
// An error occurred when running a PowerShell script.
//


//
// MessageId: SDIAG_E_POWERSHELL
//
// MessageText:
//
// An error occurred when interacting with PowerShell runtime.
//


//
// MessageId: SDIAG_E_MANAGEDHOST
//
// MessageText:
//
// An error occurred in the Scripted Diagnostic Managed Host.
//


//
// MessageId: SDIAG_E_NOVERIFIER
//
// MessageText:
//
// The troubleshooting pack does not contain a required verifier to complete the verification.
//


//
// MessageId: SDIAG_S_CANNOTRUN
//
// MessageText:
//
// The troubleshooting pack cannot be executed on this system.
//


//
// MessageId: SDIAG_E_DISABLED
//
// MessageText:
//
// Scripted diagnostics is disabled by group policy.
//


//
// MessageId: SDIAG_E_TRUST
//
// MessageText:
//
// Trust validation of the troubleshooting pack failed.
//


//
// MessageId: SDIAG_E_CANNOTRUN
//
// MessageText:
//
// The troubleshooting pack cannot be executed on this system.
//


//
// MessageId: SDIAG_E_VERSION
//
// MessageText:
//
// This version of the troubleshooting pack is not supported.
//


//
// MessageId: SDIAG_E_RESOURCE
//
// MessageText:
//
// A required resource cannot be loaded.
//


//
// MessageId: SDIAG_E_ROOTCAUSE
//
// MessageText:
//
// The troubleshooting pack reported information for a root cause without adding the root cause.
//


//
// =======================================================
// Facility Windows Push Notifications (WPN) Error Messages
// =======================================================
//
//
// MessageId: WPN_E_CHANNEL_CLOSED
//
// MessageText:
//
// The notification channel has already been closed.
//


//
// MessageId: WPN_E_CHANNEL_REQUEST_NOT_COMPLETE
//
// MessageText:
//
// The notification channel request did not complete successfully.
//


//
// MessageId: WPN_E_INVALID_APP
//
// MessageText:
//
// The application identifier provided is invalid.
//


//
// MessageId: WPN_E_OUTSTANDING_CHANNEL_REQUEST
//
// MessageText:
//
// A notification channel request for the provided application identifier is in progress.
//


//
// MessageId: WPN_E_DUPLICATE_CHANNEL
//
// MessageText:
//
// The channel identifier is already tied to another application endpoint.
//


//
// MessageId: WPN_E_PLATFORM_UNAVAILABLE
//
// MessageText:
//
// The notification platform is unavailable.
//


//
// MessageId: WPN_E_NOTIFICATION_POSTED
//
// MessageText:
//
// The notification has already been posted.
//


//
// MessageId: WPN_E_NOTIFICATION_HIDDEN
//
// MessageText:
//
// The notification has already been hidden.
//


//
// MessageId: WPN_E_NOTIFICATION_NOT_POSTED
//
// MessageText:
//
// The notification cannot be hidden until it has been shown.
//


//
// MessageId: WPN_E_CLOUD_DISABLED
//
// MessageText:
//
// Cloud notifications have been turned off.
//


//
// MessageId: WPN_E_CLOUD_INCAPABLE
//
// MessageText:
//
// The application does not have the cloud notification capability.
//


//
// MessageId: WPN_E_CLOUD_AUTH_UNAVAILABLE
//
// MessageText:
//
// The notification platform is unable to retrieve the authentication credentials required to connect to the cloud notification service.
//


//
// MessageId: WPN_E_CLOUD_SERVICE_UNAVAILABLE
//
// MessageText:
//
// The notification platform is unable to connect to the cloud notification service.
//


//
// MessageId: WPN_E_FAILED_LOCK_SCREEN_UPDATE_INTIALIZATION
//
// MessageText:
//
// The notification platform is unable to initialize a callback for lock screen updates.
//


//
// MessageId: WPN_E_NOTIFICATION_DISABLED
//
// MessageText:
//
// Settings prevent the notification from being delivered.
//


//
// MessageId: WPN_E_NOTIFICATION_INCAPABLE
//
// MessageText:
//
// Application capabilities prevent the notification from being delivered.
//


//
// MessageId: WPN_E_INTERNET_INCAPABLE
//
// MessageText:
//
// The application does not have the internet access capability.
//


//
// MessageId: WPN_E_NOTIFICATION_TYPE_DISABLED
//
// MessageText:
//
// Settings prevent the notification type from being delivered.
//


//
// MessageId: WPN_E_NOTIFICATION_SIZE
//
// MessageText:
//
// The size of the notification content is too large.
//


//
// MessageId: WPN_E_TAG_SIZE
//
// MessageText:
//
// The size of the notification tag is too large.
//


//
// MessageId: WPN_E_ACCESS_DENIED
//
// MessageText:
//
// The notification platform doesn't have appropriate privilege on resources.
//


//
// MessageId: WPN_E_DUPLICATE_REGISTRATION
//
// MessageText:
//
// The notification platform found application is already registered.
//


//
// MessageId: WPN_E_PUSH_NOTIFICATION_INCAPABLE
//
// MessageText:
//
// The application background task does not have the push notification capability.
//


//
// MessageId: WPN_E_DEV_ID_SIZE
//
// MessageText:
//
// The size of the developer id for scheduled notification is too large.
//


//
// MessageId: WPN_E_TAG_ALPHANUMERIC
//
// MessageText:
//
// The notification tag is not alphanumeric.
//


//
// MessageId: WPN_E_INVALID_HTTP_STATUS_CODE
//
// MessageText:
//
// The notification platform has received invalid HTTP status code other than 2xx for polling.
//


//
// MessageId: WPN_E_OUT_OF_SESSION
//
// MessageText:
//
// The notification platform has run out of presentation layer sessions.
//


//
// MessageId: WPN_E_POWER_SAVE
//
// MessageText:
//
// The notification platform rejects image download request due to system in power save mode.
//


//
// MessageId: WPN_E_IMAGE_NOT_FOUND_IN_CACHE
//
// MessageText:
//
// The notification platform doesn't have the requested image in its cache.
//


//
// MessageId: WPN_E_ALL_URL_NOT_COMPLETED
//
// MessageText:
//
// The notification platform cannot complete all of requested image.
//


//
// MessageId: WPN_E_INVALID_CLOUD_IMAGE
//
// MessageText:
//
// A cloud image downloaded from the notification platform is invalid.
//


//
// MessageId: WPN_E_NOTIFICATION_ID_MATCHED
//
// MessageText:
//
// Notification Id provided as filter is matched with what the notification platform maintains.
//


//
// MessageId: WPN_E_CALLBACK_ALREADY_REGISTERED
//
// MessageText:
//
// Notification callback interface is already registered.
//


//
// MessageId: WPN_E_TOAST_NOTIFICATION_DROPPED
//
// MessageText:
//
// Toast Notification was dropped without being displayed to the user.
//


//
// MessageId: WPN_E_STORAGE_LOCKED
//
// MessageText:
//
// The notification platform does not have the proper privileges to complete the request.
//


//
// MessageId: WPN_E_GROUP_SIZE
//
// MessageText:
//
// The size of the notification group is too large.
//


//
// MessageId: WPN_E_GROUP_ALPHANUMERIC
//
// MessageText:
//
// The notification group is not alphanumeric.
//


//
// MessageId: WPN_E_CLOUD_DISABLED_FOR_APP
//
// MessageText:
//
// Cloud notifications have been disabled for the application due to a policy setting.
//



//
// MBN error codes
//

//
// MessageId: E_MBN_CONTEXT_NOT_ACTIVATED
//
// MessageText:
//
// Context is not activated.
//


//
// MessageId: E_MBN_BAD_SIM
//
// MessageText:
//
// Bad SIM is inserted.
//


//
// MessageId: E_MBN_DATA_CLASS_NOT_AVAILABLE
//
// MessageText:
//
// Requested data class is not available.
//


//
// MessageId: E_MBN_INVALID_ACCESS_STRING
//
// MessageText:
//
// Access point name (APN) or Access string is incorrect.
//


//
// MessageId: E_MBN_MAX_ACTIVATED_CONTEXTS
//
// MessageText:
//
// Max activated contexts have reached.
//


//
// MessageId: E_MBN_PACKET_SVC_DETACHED
//
// MessageText:
//
// Device is in packet detach state.
//


//
// MessageId: E_MBN_PROVIDER_NOT_VISIBLE
//
// MessageText:
//
// Provider is not visible.
//


//
// MessageId: E_MBN_RADIO_POWER_OFF
//
// MessageText:
//
// Radio is powered off.
//


//
// MessageId: E_MBN_SERVICE_NOT_ACTIVATED
//
// MessageText:
//
// MBN subscription is not activated.
//


//
// MessageId: E_MBN_SIM_NOT_INSERTED
//
// MessageText:
//
// SIM is not inserted.
//


//
// MessageId: E_MBN_VOICE_CALL_IN_PROGRESS
//
// MessageText:
//
// Voice call in progress.
//


//
// MessageId: E_MBN_INVALID_CACHE
//
// MessageText:
//
// Visible provider cache is invalid.
//


//
// MessageId: E_MBN_NOT_REGISTERED
//
// MessageText:
//
// Device is not registered.
//


//
// MessageId: E_MBN_PROVIDERS_NOT_FOUND
//
// MessageText:
//
// Providers not found.
//


//
// MessageId: E_MBN_PIN_NOT_SUPPORTED
//
// MessageText:
//
// Pin is not supported.
//


//
// MessageId: E_MBN_PIN_REQUIRED
//
// MessageText:
//
// Pin is required.
//


//
// MessageId: E_MBN_PIN_DISABLED
//
// MessageText:
//
// PIN is disabled.
//


//
// MessageId: E_MBN_FAILURE
//
// MessageText:
//
// Generic Failure.
//


// Profile related error messages
//
// MessageId: E_MBN_INVALID_PROFILE
//
// MessageText:
//
// Profile is invalid.
//


//
// MessageId: E_MBN_DEFAULT_PROFILE_EXIST
//
// MessageText:
//
// Default profile exist.
//


// SMS related error messages
//
// MessageId: E_MBN_SMS_ENCODING_NOT_SUPPORTED
//
// MessageText:
//
// SMS encoding is not supported.
//


//
// MessageId: E_MBN_SMS_FILTER_NOT_SUPPORTED
//
// MessageText:
//
// SMS filter is not supported.
//


//
// MessageId: E_MBN_SMS_INVALID_MEMORY_INDEX
//
// MessageText:
//
// Invalid SMS memory index is used.
//


//
// MessageId: E_MBN_SMS_LANG_NOT_SUPPORTED
//
// MessageText:
//
// SMS language is not supported.
//


//
// MessageId: E_MBN_SMS_MEMORY_FAILURE
//
// MessageText:
//
// SMS memory failure occurred.
//


//
// MessageId: E_MBN_SMS_NETWORK_TIMEOUT
//
// MessageText:
//
// SMS network timeout happened.
//


//
// MessageId: E_MBN_SMS_UNKNOWN_SMSC_ADDRESS
//
// MessageText:
//
// Unknown SMSC address is used.
//


//
// MessageId: E_MBN_SMS_FORMAT_NOT_SUPPORTED
//
// MessageText:
//
// SMS format is not supported.
//


//
// MessageId: E_MBN_SMS_OPERATION_NOT_ALLOWED
//
// MessageText:
//
// SMS operation is not allowed.
//


//
// MessageId: E_MBN_SMS_MEMORY_FULL
//
// MessageText:
//
// Device SMS memory is full.
//



//
// P2P error codes
//

//
// MessageId: PEER_E_IPV6_NOT_INSTALLED
//
// MessageText:
//
// The IPv6 protocol is not installed.
//


//
// MessageId: PEER_E_NOT_INITIALIZED
//
// MessageText:
//
// The component has not been initialized.
//


//
// MessageId: PEER_E_CANNOT_START_SERVICE
//
// MessageText:
//
// The required service cannot be started.
//


//
// MessageId: PEER_E_NOT_LICENSED
//
// MessageText:
//
// The P2P protocol is not licensed to run on this OS.
//


//
// MessageId: PEER_E_INVALID_GRAPH
//
// MessageText:
//
// The graph handle is invalid.
//


//
// MessageId: PEER_E_DBNAME_CHANGED
//
// MessageText:
//
// The graph database name has changed.
//


//
// MessageId: PEER_E_DUPLICATE_GRAPH
//
// MessageText:
//
// A graph with the same ID already exists.
//


//
// MessageId: PEER_E_GRAPH_NOT_READY
//
// MessageText:
//
// The graph is not ready.
//


//
// MessageId: PEER_E_GRAPH_SHUTTING_DOWN
//
// MessageText:
//
// The graph is shutting down.
//


//
// MessageId: PEER_E_GRAPH_IN_USE
//
// MessageText:
//
// The graph is still in use.
//


//
// MessageId: PEER_E_INVALID_DATABASE
//
// MessageText:
//
// The graph database is corrupt.
//


//
// MessageId: PEER_E_TOO_MANY_ATTRIBUTES
//
// MessageText:
//
// Too many attributes have been used.
//


//
// MessageId: PEER_E_CONNECTION_NOT_FOUND
//
// MessageText:
//
// The connection can not be found.
//


//
// MessageId: PEER_E_CONNECT_SELF
//
// MessageText:
//
// The peer attempted to connect to itself.
//


//
// MessageId: PEER_E_ALREADY_LISTENING
//
// MessageText:
//
// The peer is already listening for connections.
//


//
// MessageId: PEER_E_NODE_NOT_FOUND
//
// MessageText:
//
// The node was not found.
//


//
// MessageId: PEER_E_CONNECTION_FAILED
//
// MessageText:
//
// The Connection attempt failed.
//


//
// MessageId: PEER_E_CONNECTION_NOT_AUTHENTICATED
//
// MessageText:
//
// The peer connection could not be authenticated.
//


//
// MessageId: PEER_E_CONNECTION_REFUSED
//
// MessageText:
//
// The connection was refused.
//


//
// MessageId: PEER_E_CLASSIFIER_TOO_LONG
//
// MessageText:
//
// The peer name classifier is too long.
//


//
// MessageId: PEER_E_TOO_MANY_IDENTITIES
//
// MessageText:
//
// The maximum number of identities have been created.
//


//
// MessageId: PEER_E_NO_KEY_ACCESS
//
// MessageText:
//
// Unable to access a key.
//


//
// MessageId: PEER_E_GROUPS_EXIST
//
// MessageText:
//
// The group already exists.
//


// record error codes
//
// MessageId: PEER_E_RECORD_NOT_FOUND
//
// MessageText:
//
// The requested record could not be found.
//


//
// MessageId: PEER_E_DATABASE_ACCESSDENIED
//
// MessageText:
//
// Access to the database was denied.
//


//
// MessageId: PEER_E_DBINITIALIZATION_FAILED
//
// MessageText:
//
// The Database could not be initialized.
//


//
// MessageId: PEER_E_MAX_RECORD_SIZE_EXCEEDED
//
// MessageText:
//
// The record is too big.
//


//
// MessageId: PEER_E_DATABASE_ALREADY_PRESENT
//
// MessageText:
//
// The database already exists.
//


//
// MessageId: PEER_E_DATABASE_NOT_PRESENT
//
// MessageText:
//
// The database could not be found.
//


//
// MessageId: PEER_E_IDENTITY_NOT_FOUND
//
// MessageText:
//
// The identity could not be found.
//


// eventing error
//
// MessageId: PEER_E_EVENT_HANDLE_NOT_FOUND
//
// MessageText:
//
// The event handle could not be found.
//


// searching error
//
// MessageId: PEER_E_INVALID_SEARCH
//
// MessageText:
//
// Invalid search.
//


//
// MessageId: PEER_E_INVALID_ATTRIBUTES
//
// MessageText:
//
// The search attributes are invalid.
//



// certificate verification error codes
//
// MessageId: PEER_E_INVITATION_NOT_TRUSTED
//
// MessageText:
//
// The invitation is not trusted.
//


//
// MessageId: PEER_E_CHAIN_TOO_LONG
//
// MessageText:
//
// The certchain is too long.
//


//
// MessageId: PEER_E_INVALID_TIME_PERIOD
//
// MessageText:
//
// The time period is invalid.
//


//
// MessageId: PEER_E_CIRCULAR_CHAIN_DETECTED
//
// MessageText:
//
// A circular cert chain was detected.
//


//
// MessageId: PEER_E_CERT_STORE_CORRUPTED
//
// MessageText:
//
// The certstore is corrupted.
//


//
// MessageId: PEER_E_NO_CLOUD
//
// MessageText:
//
// The specified PNRP cloud does not exist.
//


//
// MessageId: PEER_E_CLOUD_NAME_AMBIGUOUS
//
// MessageText:
//
// The cloud name is ambiguous.
//


//
// MessageId: PEER_E_INVALID_RECORD
//
// MessageText:
//
// The record is invalid.
//


//
// MessageId: PEER_E_NOT_AUTHORIZED
//
// MessageText:
//
// Not authorized.
//


//
// MessageId: PEER_E_PASSWORD_DOES_NOT_MEET_POLICY
//
// MessageText:
//
// The password does not meet policy requirements.
//


//
// MessageId: PEER_E_DEFERRED_VALIDATION
//
// MessageText:
//
// The record validation has been deferred.
//


//
// MessageId: PEER_E_INVALID_GROUP_PROPERTIES
//
// MessageText:
//
// The group properties are invalid.
//


//
// MessageId: PEER_E_INVALID_PEER_NAME
//
// MessageText:
//
// The peername is invalid.
//


//
// MessageId: PEER_E_INVALID_CLASSIFIER
//
// MessageText:
//
// The classifier is invalid.
//


//
// MessageId: PEER_E_INVALID_FRIENDLY_NAME
//
// MessageText:
//
// The friendly name is invalid.
//


//
// MessageId: PEER_E_INVALID_ROLE_PROPERTY
//
// MessageText:
//
// Invalid role property.
//


//
// MessageId: PEER_E_INVALID_CLASSIFIER_PROPERTY
//
// MessageText:
//
// Invalid classifier property.
//


//
// MessageId: PEER_E_INVALID_RECORD_EXPIRATION
//
// MessageText:
//
// Invalid record expiration.
//


//
// MessageId: PEER_E_INVALID_CREDENTIAL_INFO
//
// MessageText:
//
// Invalid credential info.
//


//
// MessageId: PEER_E_INVALID_CREDENTIAL
//
// MessageText:
//
// Invalid credential.
//


//
// MessageId: PEER_E_INVALID_RECORD_SIZE
//
// MessageText:
//
// Invalid record size.
//


//
// MessageId: PEER_E_UNSUPPORTED_VERSION
//
// MessageText:
//
// Unsupported version.
//


//
// MessageId: PEER_E_GROUP_NOT_READY
//
// MessageText:
//
// The group is not ready.
//


//
// MessageId: PEER_E_GROUP_IN_USE
//
// MessageText:
//
// The group is still in use.
//


//
// MessageId: PEER_E_INVALID_GROUP
//
// MessageText:
//
// The group is invalid.
//


//
// MessageId: PEER_E_NO_MEMBERS_FOUND
//
// MessageText:
//
// No members were found.
//


//
// MessageId: PEER_E_NO_MEMBER_CONNECTIONS
//
// MessageText:
//
// There are no member connections.
//


//
// MessageId: PEER_E_UNABLE_TO_LISTEN
//
// MessageText:
//
// Unable to listen.
//


//
// MessageId: PEER_E_IDENTITY_DELETED
//
// MessageText:
//
// The identity does not exist.
//


//
// MessageId: PEER_E_SERVICE_NOT_AVAILABLE
//
// MessageText:
//
// The service is not available.
//


// Contacts APIs error code
//
// MessageId: PEER_E_CONTACT_NOT_FOUND
//
// MessageText:
//
// THe contact could not be found.
//


// Special success codes
//
// MessageId: PEER_S_GRAPH_DATA_CREATED
//
// MessageText:
//
// The graph data was created.
//


//
// MessageId: PEER_S_NO_EVENT_DATA
//
// MessageText:
//
// There is not more event data.
//


//
// MessageId: PEER_S_ALREADY_CONNECTED
//
// MessageText:
//
// The graph is already connect.
//


//
// MessageId: PEER_S_SUBSCRIPTION_EXISTS
//
// MessageText:
//
// The subscription already exists.
//


//
// MessageId: PEER_S_NO_CONNECTIVITY
//
// MessageText:
//
// No connectivity.
//


//
// MessageId: PEER_S_ALREADY_A_MEMBER
//
// MessageText:
//
// Already a member.
//


// Pnrp helpers errors
//
// MessageId: PEER_E_CANNOT_CONVERT_PEER_NAME
//
// MessageText:
//
// The peername could not be converted to a DNS pnrp name.
//


//
// MessageId: PEER_E_INVALID_PEER_HOST_NAME
//
// MessageText:
//
// Invalid peer host name.
//


//
// MessageId: PEER_E_NO_MORE
//
// MessageText:
//
// No more data could be found.
//


//
// MessageId: PEER_E_PNRP_DUPLICATE_PEER_NAME
//
// MessageText:
//
// The existing peer name is already registered.
//


// AppInvite APIs error code
//
// MessageId: PEER_E_INVITE_CANCELLED
//
// MessageText:
//
// The app invite request was cancelled by the user.
//


//
// MessageId: PEER_E_INVITE_RESPONSE_NOT_AVAILABLE
//
// MessageText:
//
// No response of the invite was received.
//


// Serverless presence error codes
//
// MessageId: PEER_E_NOT_SIGNED_IN
//
// MessageText:
//
// User is not signed into serverless presence.
//


//
// MessageId: PEER_E_PRIVACY_DECLINED
//
// MessageText:
//
// The user declined the privacy policy prompt.
//


//
// MessageId: PEER_E_TIMEOUT
//
// MessageText:
//
// A timeout occurred.
//


//
// MessageId: PEER_E_INVALID_ADDRESS
//
// MessageText:
//
// The address is invalid.
//


//
// MessageId: PEER_E_FW_EXCEPTION_DISABLED
//
// MessageText:
//
// A required firewall exception is disabled.
//


//
// MessageId: PEER_E_FW_BLOCKED_BY_POLICY
//
// MessageText:
//
// The service is blocked by a firewall policy.
//


//
// MessageId: PEER_E_FW_BLOCKED_BY_SHIELDS_UP
//
// MessageText:
//
// Firewall exceptions are disabled.
//


//
// MessageId: PEER_E_FW_DECLINED
//
// MessageText:
//
// The user declined to enable the firewall exceptions.
//



//
// UI error codes
//

//
// MessageId: UI_E_CREATE_FAILED
//
// MessageText:
//
// The object could not be created.
//


//
// MessageId: UI_E_SHUTDOWN_CALLED
//
// MessageText:
//
// Shutdown was already called on this object or the object that owns it.
//


//
// MessageId: UI_E_ILLEGAL_REENTRANCY
//
// MessageText:
//
// This method cannot be called during this type of callback.
//


//
// MessageId: UI_E_OBJECT_SEALED
//
// MessageText:
//
// This object has been sealed, so this change is no longer allowed.
//


//
// MessageId: UI_E_VALUE_NOT_SET
//
// MessageText:
//
// The requested value was never set.
//


//
// MessageId: UI_E_VALUE_NOT_DETERMINED
//
// MessageText:
//
// The requested value cannot be determined.
//


//
// MessageId: UI_E_INVALID_OUTPUT
//
// MessageText:
//
// A callback returned an invalid output parameter.
//


//
// MessageId: UI_E_BOOLEAN_EXPECTED
//
// MessageText:
//
// A callback returned a success code other than S_OK or S_FALSE.
//


//
// MessageId: UI_E_DIFFERENT_OWNER
//
// MessageText:
//
// A parameter that should be owned by this object is owned by a different object.
//


//
// MessageId: UI_E_AMBIGUOUS_MATCH
//
// MessageText:
//
// More than one item matched the search criteria.
//


//
// MessageId: UI_E_FP_OVERFLOW
//
// MessageText:
//
// A floating-point overflow occurred.
//


//
// MessageId: UI_E_WRONG_THREAD
//
// MessageText:
//
// This method can only be called from the thread that created the object.
//


//
// MessageId: UI_E_STORYBOARD_ACTIVE
//
// MessageText:
//
// The storyboard is currently in the schedule.
//


//
// MessageId: UI_E_STORYBOARD_NOT_PLAYING
//
// MessageText:
//
// The storyboard is not playing.
//


//
// MessageId: UI_E_START_KEYFRAME_AFTER_END
//
// MessageText:
//
// The start keyframe might occur after the end keyframe.
//


//
// MessageId: UI_E_END_KEYFRAME_NOT_DETERMINED
//
// MessageText:
//
// It might not be possible to determine the end keyframe time when the start keyframe is reached.
//


//
// MessageId: UI_E_LOOPS_OVERLAP
//
// MessageText:
//
// Two repeated portions of a storyboard might overlap.
//


//
// MessageId: UI_E_TRANSITION_ALREADY_USED
//
// MessageText:
//
// The transition has already been added to a storyboard.
//


//
// MessageId: UI_E_TRANSITION_NOT_IN_STORYBOARD
//
// MessageText:
//
// The transition has not been added to a storyboard.
//


//
// MessageId: UI_E_TRANSITION_ECLIPSED
//
// MessageText:
//
// The transition might eclipse the beginning of another transition in the storyboard.
//


//
// MessageId: UI_E_TIME_BEFORE_LAST_UPDATE
//
// MessageText:
//
// The given time is earlier than the time passed to the last update.
//


//
// MessageId: UI_E_TIMER_CLIENT_ALREADY_CONNECTED
//
// MessageText:
//
// This client is already connected to a timer.
//


//
// MessageId: UI_E_INVALID_DIMENSION
//
// MessageText:
//
// The passed dimension is invalid or does not match the object's dimension.
//


//
// MessageId: UI_E_PRIMITIVE_OUT_OF_BOUNDS
//
// MessageText:
//
// The added primitive begins at or beyond the duration of the interpolator.
//


//
// MessageId: UI_E_WINDOW_CLOSED
//
// MessageText:
//
// The operation cannot be completed because the window is being closed.
//



//
// Bluetooth Attribute Protocol Warnings
//

//
// MessageId: E_BLUETOOTH_ATT_INVALID_HANDLE
//
// MessageText:
//
// The attribute handle given was not valid on this server.
//


//
// MessageId: E_BLUETOOTH_ATT_READ_NOT_PERMITTED
//
// MessageText:
//
// The attribute cannot be read.
//


//
// MessageId: E_BLUETOOTH_ATT_WRITE_NOT_PERMITTED
//
// MessageText:
//
// The attribute cannot be written.
//


//
// MessageId: E_BLUETOOTH_ATT_INVALID_PDU
//
// MessageText:
//
// The attribute PDU was invalid.
//


//
// MessageId: E_BLUETOOTH_ATT_INSUFFICIENT_AUTHENTICATION
//
// MessageText:
//
// The attribute requires authentication before it can be read or written.
//


//
// MessageId: E_BLUETOOTH_ATT_REQUEST_NOT_SUPPORTED
//
// MessageText:
//
// Attribute server does not support the request received from the client.
//


//
// MessageId: E_BLUETOOTH_ATT_INVALID_OFFSET
//
// MessageText:
//
// Offset specified was past the end of the attribute.
//


//
// MessageId: E_BLUETOOTH_ATT_INSUFFICIENT_AUTHORIZATION
//
// MessageText:
//
// The attribute requires authorization before it can be read or written.
//


//
// MessageId: E_BLUETOOTH_ATT_PREPARE_QUEUE_FULL
//
// MessageText:
//
// Too many prepare writes have been queued.
//


//
// MessageId: E_BLUETOOTH_ATT_ATTRIBUTE_NOT_FOUND
//
// MessageText:
//
// No attribute found within the given attribute handle range.
//


//
// MessageId: E_BLUETOOTH_ATT_ATTRIBUTE_NOT_LONG
//
// MessageText:
//
// The attribute cannot be read or written using the Read Blob Request.
//


//
// MessageId: E_BLUETOOTH_ATT_INSUFFICIENT_ENCRYPTION_KEY_SIZE
//
// MessageText:
//
// The Encryption Key Size used for encrypting this link is insufficient.
//


//
// MessageId: E_BLUETOOTH_ATT_INVALID_ATTRIBUTE_VALUE_LENGTH
//
// MessageText:
//
// The attribute value length is invalid for the operation.
//


//
// MessageId: E_BLUETOOTH_ATT_UNLIKELY
//
// MessageText:
//
// The attribute request that was requested has encountered an error that was unlikely, and therefore could not be completed as requested.
//


//
// MessageId: E_BLUETOOTH_ATT_INSUFFICIENT_ENCRYPTION
//
// MessageText:
//
// The attribute requires encryption before it can be read or written.
//


//
// MessageId: E_BLUETOOTH_ATT_UNSUPPORTED_GROUP_TYPE
//
// MessageText:
//
// The attribute type is not a supported grouping attribute as defined by a higher layer specification.
//


//
// MessageId: E_BLUETOOTH_ATT_INSUFFICIENT_RESOURCES
//
// MessageText:
//
// Insufficient Resources to complete the request.
//


//
// MessageId: E_BLUETOOTH_ATT_UNKNOWN_ERROR
//
// MessageText:
//
// An error that lies in the reserved range has been received.
//



//
// Audio errors
//

//
// MessageId: E_AUDIO_ENGINE_NODE_NOT_FOUND
//
// MessageText:
//
// PortCls could not find an audio engine node exposed by a miniport driver claiming support for IMiniportAudioEngineNode.
//


//
// MessageId: E_HDAUDIO_EMPTY_CONNECTION_LIST
//
// MessageText:
//
// HD Audio widget encountered an unexpected empty connection list.
//


//
// MessageId: E_HDAUDIO_CONNECTION_LIST_NOT_SUPPORTED
//
// MessageText:
//
// HD Audio widget does not support the connection list parameter.
//


//
// MessageId: E_HDAUDIO_NO_LOGICAL_DEVICES_CREATED
//
// MessageText:
//
// No HD Audio subdevices were successfully created.
//


//
// MessageId: E_HDAUDIO_NULL_LINKED_LIST_ENTRY
//
// MessageText:
//
// An unexpected NULL pointer was encountered in a linked list.
//


//
// StateRepository errors
//
//
// MessageId: STATEREPOSITORY_E_CONCURRENCY_LOCKING_FAILURE
//
// MessageText:
//
// Optimistic locking failure. Data cannot be updated if it has changed since it was read.
//


//
// MessageId: STATEREPOSITORY_E_STATEMENT_INPROGRESS
//
// MessageText:
//
// A prepared statement has been stepped at least once but not run to completion or reset. This may result in busy waits.
//


//
// MessageId: STATEREPOSITORY_E_CONFIGURATION_INVALID
//
// MessageText:
//
// The StateRepository configuration is not valid.
//


//
// MessageId: STATEREPOSITORY_E_UNKNOWN_SCHEMA_VERSION
//
// MessageText:
//
// The StateRepository schema version is not known.
//


//
// MessageId: STATEREPOSITORY_ERROR_DICTIONARY_CORRUPTED
//
// MessageText:
//
// A StateRepository dictionary is not valid.
//


//
// MessageId: STATEREPOSITORY_E_BLOCKED
//
// MessageText:
//
// The request failed because the StateRepository is actively blocking requests.
//


//
// MessageId: STATEREPOSITORY_E_BUSY_RETRY
//
// MessageText:
//
// The database file is locked. The request will be retried.
//


//
// MessageId: STATEREPOSITORY_E_BUSY_RECOVERY_RETRY
//
// MessageText:
//
// The database file is locked because another process is busy recovering the database. The request will be retried.
//


//
// MessageId: STATEREPOSITORY_E_LOCKED_RETRY
//
// MessageText:
//
// A table in the database is locked. The request will be retried.
//


//
// MessageId: STATEREPOSITORY_E_LOCKED_SHAREDCACHE_RETRY
//
// MessageText:
//
// The shared cache for the database is locked by another connection. The request will be retried.
//


//
// MessageId: STATEREPOSITORY_E_TRANSACTION_REQUIRED
//
// MessageText:
//
// A transaction is required to perform the request operation.
//


//
// MessageId: STATEREPOSITORY_E_BUSY_TIMEOUT_EXCEEDED
//
// MessageText:
//
// The database file is locked. The request has exceeded the allowed threshold.
//


//
// MessageId: STATEREPOSITORY_E_BUSY_RECOVERY_TIMEOUT_EXCEEDED
//
// MessageText:
//
// The database file is locked because another process is busy recovering the database. The request has exceeded the allowed threshold.
//


//
// MessageId: STATEREPOSITORY_E_LOCKED_TIMEOUT_EXCEEDED
//
// MessageText:
//
// A table in the database is locked. The request has exceeded the allowed threshold.
//


//
// MessageId: STATEREPOSITORY_E_LOCKED_SHAREDCACHE_TIMEOUT_EXCEEDED
//
// MessageText:
//
// The shared cache for the database is locked by another connection. The request has exceeded the allowed threshold.
//


//
// MessageId: STATEREPOSITORY_E_SERVICE_STOP_IN_PROGRESS
//
// MessageText:
//
// The StateRepository service Stop event is in progress.
//


//
// MessageId: STATEREPOSTORY_E_NESTED_TRANSACTION_NOT_SUPPORTED
//
// MessageText:
//
// Nested transactions are not supported.
//


//
// MessageId: STATEREPOSITORY_ERROR_CACHE_CORRUPTED
//
// MessageText:
//
// The StateRepository cache is not valid.
//


//
// MessageId: STATEREPOSITORY_TRANSACTION_CALLER_ID_CHANGED
//
// MessageText:
//
// The transaction caller id has changed.
//


//
// MessageId: STATEREPOSITORY_TRANSACTION_IN_PROGRESS
//
// MessageText:
//
// A transaction is in progress for the database connection.
//


//
// Spaceport errors
//
// Success
//
// MessageId: ERROR_SPACES_POOL_WAS_DELETED
//
// MessageText:
//
// The storage pool was deleted by the driver. The object cache should be updated.
//


// Errors
//
// MessageId: ERROR_SPACES_FAULT_DOMAIN_TYPE_INVALID
//
// MessageText:
//
// The specified fault domain type or combination of minimum / maximum fault domain type is not valid.
//


//
// MessageId: ERROR_SPACES_INTERNAL_ERROR
//
// MessageText:
//
// A Storage Spaces internal error occurred.
//


//
// MessageId: ERROR_SPACES_RESILIENCY_TYPE_INVALID
//
// MessageText:
//
// The specified resiliency type is not valid.
//


//
// MessageId: ERROR_SPACES_DRIVE_SECTOR_SIZE_INVALID
//
// MessageText:
//
// The physical disk's sector size is not supported by the storage pool.
//


//
// MessageId: ERROR_SPACES_DRIVE_REDUNDANCY_INVALID
//
// MessageText:
//
// The requested redundancy is outside of the supported range of values.
//


//
// MessageId: ERROR_SPACES_NUMBER_OF_DATA_COPIES_INVALID
//
// MessageText:
//
// The number of data copies requested is outside of the supported range of values.
//


//
// MessageId: ERROR_SPACES_PARITY_LAYOUT_INVALID
//
// MessageText:
//
// The value for ParityLayout is outside of the supported range of values.
//


//
// MessageId: ERROR_SPACES_INTERLEAVE_LENGTH_INVALID
//
// MessageText:
//
// The value for interleave length is outside of the supported range of values or is not a power of 2.
//


//
// MessageId: ERROR_SPACES_NUMBER_OF_COLUMNS_INVALID
//
// MessageText:
//
// The number of columns specified is outside of the supported range of values.
//


//
// MessageId: ERROR_SPACES_NOT_ENOUGH_DRIVES
//
// MessageText:
//
// There were not enough physical disks to complete the requested operation.
//


//
// MessageId: ERROR_SPACES_EXTENDED_ERROR
//
// MessageText:
//
// Extended error information is available.
//


//
// MessageId: ERROR_SPACES_PROVISIONING_TYPE_INVALID
//
// MessageText:
//
// The specified provisioning type is not valid.
//


//
// MessageId: ERROR_SPACES_ALLOCATION_SIZE_INVALID
//
// MessageText:
//
// The allocation size is outside of the supported range of values.
//


//
// MessageId: ERROR_SPACES_ENCLOSURE_AWARE_INVALID
//
// MessageText:
//
// Enclosure awareness is not supported for this virtual disk.
//


//
// MessageId: ERROR_SPACES_WRITE_CACHE_SIZE_INVALID
//
// MessageText:
//
// The write cache size is outside of the supported range of values.
//


//
// MessageId: ERROR_SPACES_NUMBER_OF_GROUPS_INVALID
//
// MessageText:
//
// The value for number of groups is outside of the supported range of values.
//


//
// MessageId: ERROR_SPACES_DRIVE_OPERATIONAL_STATE_INVALID
//
// MessageText:
//
// The OperationalState of the physical disk is invalid for this operation.
//


//
// MessageId: ERROR_SPACES_ENTRY_INCOMPLETE
//
// MessageText:
//
// The specified log entry is not complete.
//


//
// MessageId: ERROR_SPACES_ENTRY_INVALID
//
// MessageText:
//
// The specified log entry is not valid.
//


//
// Volsnap errors
//
// Success
//
// MessageId: ERROR_VOLSNAP_BOOTFILE_NOT_VALID
//
// MessageText:
//
// The bootfile is too small to support persistent snapshots.
//


//
// MessageId: ERROR_VOLSNAP_ACTIVATION_TIMEOUT
//
// MessageText:
//
// Activation of persistent snapshots on this volume took longer than was allowed.
//


//
// Tiering errors
//
// Errors
//
// MessageId: ERROR_TIERING_NOT_SUPPORTED_ON_VOLUME
//
// MessageText:
//
// The specified volume does not support storage tiers.
//


//
// MessageId: ERROR_TIERING_VOLUME_DISMOUNT_IN_PROGRESS
//
// MessageText:
//
// The Storage Tiers Management service detected that the specified volume is in the process of being dismounted.
//


//
// MessageId: ERROR_TIERING_STORAGE_TIER_NOT_FOUND
//
// MessageText:
//
// The specified storage tier could not be found on the volume. Confirm that the storage tier name is valid.
//


//
// MessageId: ERROR_TIERING_INVALID_FILE_ID
//
// MessageText:
//
// The file identifier specified is not valid on the volume.
//


//
// MessageId: ERROR_TIERING_WRONG_CLUSTER_NODE
//
// MessageText:
//
// Storage tier operations must be called on the clustering node that owns the metadata volume.
//


//
// MessageId: ERROR_TIERING_ALREADY_PROCESSING
//
// MessageText:
//
// The Storage Tiers Management service is already optimizing the storage tiers on the specified volume.
//


//
// MessageId: ERROR_TIERING_CANNOT_PIN_OBJECT
//
// MessageText:
//
// The requested object type cannot be assigned to a storage tier.
//


//
// MessageId: ERROR_TIERING_FILE_IS_NOT_PINNED
//
// MessageText:
//
// The requested file is not pinned to a tier.
//


//
// MessageId: ERROR_NOT_A_TIERED_VOLUME
//
// MessageText:
//
// The volume is not a tiered volume.
//


//
// MessageId: ERROR_ATTRIBUTE_NOT_PRESENT
//
// MessageText:
//
// The requested attribute is not present on the specified file or directory.
//


//
// Embedded Security Core
//
// Reserved id values 0x0001 - 0x00FF
//                    0x8xxx
//                    0x4xxx
//
// MessageId: ERROR_SECCORE_INVALID_COMMAND
//
// MessageText:
//
// The command was not recognized by the security core
//


//
// Clip modern app and windows licensing error messages.
//
//
// MessageId: ERROR_NO_APPLICABLE_APP_LICENSES_FOUND
//
// MessageText:
//
// No applicable app licenses found.
//


//
// MessageId: ERROR_CLIP_LICENSE_NOT_FOUND
//
// MessageText:
//
// CLiP license not found.
//


//
// MessageId: ERROR_CLIP_DEVICE_LICENSE_MISSING
//
// MessageText:
//
// CLiP device license not found.
//


//
// MessageId: ERROR_CLIP_LICENSE_INVALID_SIGNATURE
//
// MessageText:
//
// CLiP license has an invalid signature.
//


//
// MessageId: ERROR_CLIP_KEYHOLDER_LICENSE_MISSING_OR_INVALID
//
// MessageText:
//
// CLiP keyholder license is invalid or missing.
//


//
// MessageId: ERROR_CLIP_LICENSE_EXPIRED
//
// MessageText:
//
// CLiP license has expired.
//


//
// MessageId: ERROR_CLIP_LICENSE_SIGNED_BY_UNKNOWN_SOURCE
//
// MessageText:
//
// CLiP license is signed by an unknown source.
//


//
// MessageId: ERROR_CLIP_LICENSE_NOT_SIGNED
//
// MessageText:
//
// CLiP license is not signed.
//


//
// MessageId: ERROR_CLIP_LICENSE_HARDWARE_ID_OUT_OF_TOLERANCE
//
// MessageText:
//
// CLiP license hardware ID is out of tolerance.
//


//
// MessageId: ERROR_CLIP_LICENSE_DEVICE_ID_MISMATCH
//
// MessageText:
//
// CLiP license device ID does not match the device ID in the bound device license.
//


//
// ===============================
// Facility Direct* Error Messages
// ===============================
//
//

//
// DXGI status (success) codes
//

//
// MessageId: DXGI_STATUS_OCCLUDED
//
// MessageText:
//
// The Present operation was invisible to the user.
//


//
// MessageId: DXGI_STATUS_CLIPPED
//
// MessageText:
//
// The Present operation was partially invisible to the user.
//


//
// MessageId: DXGI_STATUS_NO_REDIRECTION
//
// MessageText:
//
// The driver is requesting that the DXGI runtime not use shared resources to communicate with the Desktop Window Manager.
//


//
// MessageId: DXGI_STATUS_NO_DESKTOP_ACCESS
//
// MessageText:
//
// The Present operation was not visible because the Windows session has switched to another desktop (for example, ctrl-alt-del).
//


//
// MessageId: DXGI_STATUS_GRAPHICS_VIDPN_SOURCE_IN_USE
//
// MessageText:
//
// The Present operation was not visible because the target monitor was being used for some other purpose.
//


//
// MessageId: DXGI_STATUS_MODE_CHANGED
//
// MessageText:
//
// The Present operation was not visible because the display mode changed. DXGI will have re-attempted the presentation.
//


//
// MessageId: DXGI_STATUS_MODE_CHANGE_IN_PROGRESS
//
// MessageText:
//
// The Present operation was not visible because another Direct3D device was attempting to take fullscreen mode at the time.
//



//
// DXGI error codes
//

//
// MessageId: DXGI_ERROR_INVALID_CALL
//
// MessageText:
//
// The application made a call that is invalid. Either the parameters of the call or the state of some object was incorrect.
// Enable the D3D debug layer in order to see details via debug messages.
//


//
// MessageId: DXGI_ERROR_NOT_FOUND
//
// MessageText:
//
// The object was not found. If calling IDXGIFactory::EnumAdaptes, there is no adapter with the specified ordinal.
//


//
// MessageId: DXGI_ERROR_MORE_DATA
//
// MessageText:
//
// The caller did not supply a sufficiently large buffer.
//


//
// MessageId: DXGI_ERROR_UNSUPPORTED
//
// MessageText:
//
// The specified device interface or feature level is not supported on this system.
//


//
// MessageId: DXGI_ERROR_DEVICE_REMOVED
//
// MessageText:
//
// The GPU device instance has been suspended. Use GetDeviceRemovedReason to determine the appropriate action.
//


//
// MessageId: DXGI_ERROR_DEVICE_HUNG
//
// MessageText:
//
// The GPU will not respond to more commands, most likely because of an invalid command passed by the calling application.
//


//
// MessageId: DXGI_ERROR_DEVICE_RESET
//
// MessageText:
//
// The GPU will not respond to more commands, most likely because some other application submitted invalid commands.
// The calling application should re-create the device and continue.
//


//
// MessageId: DXGI_ERROR_WAS_STILL_DRAWING
//
// MessageText:
//
// The GPU was busy at the moment when the call was made, and the call was neither executed nor scheduled.
//


//
// MessageId: DXGI_ERROR_FRAME_STATISTICS_DISJOINT
//
// MessageText:
//
// An event (such as power cycle) interrupted the gathering of presentation statistics. Any previous statistics should be
// considered invalid.
//


//
// MessageId: DXGI_ERROR_GRAPHICS_VIDPN_SOURCE_IN_USE
//
// MessageText:
//
// Fullscreen mode could not be achieved because the specified output was already in use.
//


//
// MessageId: DXGI_ERROR_DRIVER_INTERNAL_ERROR
//
// MessageText:
//
// An internal issue prevented the driver from carrying out the specified operation. The driver's state is probably suspect,
// and the application should not continue.
//


//
// MessageId: DXGI_ERROR_NONEXCLUSIVE
//
// MessageText:
//
// A global counter resource was in use, and the specified counter cannot be used by this Direct3D device at this time.
//


//
// MessageId: DXGI_ERROR_NOT_CURRENTLY_AVAILABLE
//
// MessageText:
//
// A resource is not available at the time of the call, but may become available later.
//


//
// MessageId: DXGI_ERROR_REMOTE_CLIENT_DISCONNECTED
//
// MessageText:
//
// The application's remote device has been removed due to session disconnect or network disconnect.
// The application should call IDXGIFactory1::IsCurrent to find out when the remote device becomes available again.
//


//
// MessageId: DXGI_ERROR_REMOTE_OUTOFMEMORY
//
// MessageText:
//
// The device has been removed during a remote session because the remote computer ran out of memory.
//


//
// MessageId: DXGI_ERROR_ACCESS_LOST
//
// MessageText:
//
// The keyed mutex was abandoned.
//


//
// MessageId: DXGI_ERROR_WAIT_TIMEOUT
//
// MessageText:
//
// The timeout value has elapsed and the resource is not yet available.
//


//
// MessageId: DXGI_ERROR_SESSION_DISCONNECTED
//
// MessageText:
//
// The output duplication has been turned off because the Windows session ended or was disconnected.
// This happens when a remote user disconnects, or when "switch user" is used locally.
//


//
// MessageId: DXGI_ERROR_RESTRICT_TO_OUTPUT_STALE
//
// MessageText:
//
// The DXGI output (monitor) to which the swapchain content was restricted, has been disconnected or changed.
//


//
// MessageId: DXGI_ERROR_CANNOT_PROTECT_CONTENT
//
// MessageText:
//
// DXGI is unable to provide content protection on the swapchain. This is typically caused by an older driver,
// or by the application using a swapchain that is incompatible with content protection.
//


//
// MessageId: DXGI_ERROR_ACCESS_DENIED
//
// MessageText:
//
// The application is trying to use a resource to which it does not have the required access privileges.
// This is most commonly caused by writing to a shared resource with read-only access.
//


//
// MessageId: DXGI_ERROR_NAME_ALREADY_EXISTS
//
// MessageText:
//
// The application is trying to create a shared handle using a name that is already associated with some other resource.
//


//
// MessageId: DXGI_ERROR_SDK_COMPONENT_MISSING
//
// MessageText:
//
// The application requested an operation that depends on an SDK component that is missing or mismatched.
//


//
// MessageId: DXGI_ERROR_NOT_CURRENT
//
// MessageText:
//
// The DXGI objects that the application has created are no longer current & need to be recreated for this operation to be performed.
//


//
// MessageId: DXGI_ERROR_HW_PROTECTION_OUTOFMEMORY
//
// MessageText:
//
// Insufficient HW protected memory exits for proper function.
//


//
// MessageId: DXGI_ERROR_DYNAMIC_CODE_POLICY_VIOLATION
//
// MessageText:
//
// Creating this device would violate the process's dynamic code policy.
//


//
// MessageId: DXGI_ERROR_NON_COMPOSITED_UI
//
// MessageText:
//
// The operation failed because the compositor is not in control of the output.
//



//
// DXGI errors that are internal to the Desktop Window Manager
//

//
// MessageId: DXGI_STATUS_UNOCCLUDED
//
// MessageText:
//
// The swapchain has become unoccluded.
//


//
// MessageId: DXGI_STATUS_DDA_WAS_STILL_DRAWING
//
// MessageText:
//
// The adapter did not have access to the required resources to complete the Desktop Duplication Present() call, the Present() call needs to be made again
//


//
// MessageId: DXGI_ERROR_MODE_CHANGE_IN_PROGRESS
//
// MessageText:
//
// An on-going mode change prevented completion of the call. The call may succeed if attempted later.
//


//
// MessageId: DXGI_STATUS_PRESENT_REQUIRED
//
// MessageText:
//
// The present succeeded but the caller should present again on the next V-sync, even if there are no changes to the content.
//



//
// DXGI errors that are produced by the D3D Shader Cache component
//

//
// MessageId: DXGI_ERROR_CACHE_CORRUPT
//
// MessageText:
//
// The cache is corrupt and either could not be opened or could not be reset.
//


//
// MessageId: DXGI_ERROR_CACHE_FULL
//
// MessageText:
//
// This entry would cause the cache to exceed its quota. On a load operation, this may indicate exceeding the maximum in-memory size.
//


//
// MessageId: DXGI_ERROR_CACHE_HASH_COLLISION
//
// MessageText:
//
// A cache entry was found, but the key provided does not match the key stored in the entry.
//


//
// MessageId: DXGI_ERROR_ALREADY_EXISTS
//
// MessageText:
//
// The desired element already exists.
//



//
// DXGI DDI
//

//
// MessageId: DXGI_DDI_ERR_WASSTILLDRAWING
//
// MessageText:
//
// The GPU was busy when the operation was requested.
//


//
// MessageId: DXGI_DDI_ERR_UNSUPPORTED
//
// MessageText:
//
// The driver has rejected the creation of this resource.
//


//
// MessageId: DXGI_DDI_ERR_NONEXCLUSIVE
//
// MessageText:
//
// The GPU counter was in use by another process or d3d device when application requested access to it.
//



//
// Direct3D10
//

//
// MessageId: D3D10_ERROR_TOO_MANY_UNIQUE_STATE_OBJECTS
//
// MessageText:
//
// The application has exceeded the maximum number of unique state objects per Direct3D device.
// The limit is 4096 for feature levels up to 11.1.
//


//
// MessageId: D3D10_ERROR_FILE_NOT_FOUND
//
// MessageText:
//
// The specified file was not found.
//



//
// Direct3D11
//

//
// MessageId: D3D11_ERROR_TOO_MANY_UNIQUE_STATE_OBJECTS
//
// MessageText:
//
// The application has exceeded the maximum number of unique state objects per Direct3D device.
// The limit is 4096 for feature levels up to 11.1.
//


//
// MessageId: D3D11_ERROR_FILE_NOT_FOUND
//
// MessageText:
//
// The specified file was not found.
//


//
// MessageId: D3D11_ERROR_TOO_MANY_UNIQUE_VIEW_OBJECTS
//
// MessageText:
//
// The application has exceeded the maximum number of unique view objects per Direct3D device.
// The limit is 2^20 for feature levels up to 11.1.
//


//
// MessageId: D3D11_ERROR_DEFERRED_CONTEXT_MAP_WITHOUT_INITIAL_DISCARD
//
// MessageText:
//
// The application's first call per command list to Map on a deferred context did not use D3D11_MAP_WRITE_DISCARD.
//



//
// Direct3D12
//

//
// MessageId: D3D12_ERROR_ADAPTER_NOT_FOUND
//
// MessageText:
//
// The blob provided does not match the adapter that the device was created on.
//


//
// MessageId: D3D12_ERROR_DRIVER_VERSION_MISMATCH
//
// MessageText:
//
// The blob provided was created for a different version of the driver, and must be re-created.
//



//
// Direct2D
//

//
// MessageId: D2DERR_WRONG_STATE
//
// MessageText:
//
// The object was not in the correct state to process the method.
//


//
// MessageId: D2DERR_NOT_INITIALIZED
//
// MessageText:
//
// The object has not yet been initialized.
//


//
// MessageId: D2DERR_UNSUPPORTED_OPERATION
//
// MessageText:
//
// The requested operation is not supported.
//


//
// MessageId: D2DERR_SCANNER_FAILED
//
// MessageText:
//
// The geometry scanner failed to process the data.
//


//
// MessageId: D2DERR_SCREEN_ACCESS_DENIED
//
// MessageText:
//
// Direct2D could not access the screen.
//


//
// MessageId: D2DERR_DISPLAY_STATE_INVALID
//
// MessageText:
//
// A valid display state could not be determined.
//


//
// MessageId: D2DERR_ZERO_VECTOR
//
// MessageText:
//
// The supplied vector is zero.
//


//
// MessageId: D2DERR_INTERNAL_ERROR
//
// MessageText:
//
// An internal error (Direct2D bug) occurred. On checked builds, we would assert. The application should close this instance of Direct2D and should consider restarting its process.
//


//
// MessageId: D2DERR_DISPLAY_FORMAT_NOT_SUPPORTED
//
// MessageText:
//
// The display format Direct2D needs to render is not supported by the hardware device.
//


//
// MessageId: D2DERR_INVALID_CALL
//
// MessageText:
//
// A call to this method is invalid.
//


//
// MessageId: D2DERR_NO_HARDWARE_DEVICE
//
// MessageText:
//
// No hardware rendering device is available for this operation.
//


//
// MessageId: D2DERR_RECREATE_TARGET
//
// MessageText:
//
// There has been a presentation error that may be recoverable. The caller needs to recreate, rerender the entire frame, and reattempt present.
//


//
// MessageId: D2DERR_TOO_MANY_SHADER_ELEMENTS
//
// MessageText:
//
// Shader construction failed because it was too complex.
//


//
// MessageId: D2DERR_SHADER_COMPILE_FAILED
//
// MessageText:
//
// Shader compilation failed.
//


//
// MessageId: D2DERR_MAX_TEXTURE_SIZE_EXCEEDED
//
// MessageText:
//
// Requested DirectX surface size exceeded maximum texture size.
//


//
// MessageId: D2DERR_UNSUPPORTED_VERSION
//
// MessageText:
//
// The requested Direct2D version is not supported.
//


//
// MessageId: D2DERR_BAD_NUMBER
//
// MessageText:
//
// Invalid number.
//


//
// MessageId: D2DERR_WRONG_FACTORY
//
// MessageText:
//
// Objects used together must be created from the same factory instance.
//


//
// MessageId: D2DERR_LAYER_ALREADY_IN_USE
//
// MessageText:
//
// A layer resource can only be in use once at any point in time.
//


//
// MessageId: D2DERR_POP_CALL_DID_NOT_MATCH_PUSH
//
// MessageText:
//
// The pop call did not match the corresponding push call.
//


//
// MessageId: D2DERR_WRONG_RESOURCE_DOMAIN
//
// MessageText:
//
// The resource was realized on the wrong render target.
//


//
// MessageId: D2DERR_PUSH_POP_UNBALANCED
//
// MessageText:
//
// The push and pop calls were unbalanced.
//


//
// MessageId: D2DERR_RENDER_TARGET_HAS_LAYER_OR_CLIPRECT
//
// MessageText:
//
// Attempt to copy from a render target while a layer or clip rect is applied.
//


//
// MessageId: D2DERR_INCOMPATIBLE_BRUSH_TYPES
//
// MessageText:
//
// The brush types are incompatible for the call.
//


//
// MessageId: D2DERR_WIN32_ERROR
//
// MessageText:
//
// An unknown win32 failure occurred.
//


//
// MessageId: D2DERR_TARGET_NOT_GDI_COMPATIBLE
//
// MessageText:
//
// The render target is not compatible with GDI.
//


//
// MessageId: D2DERR_TEXT_EFFECT_IS_WRONG_TYPE
//
// MessageText:
//
// A text client drawing effect object is of the wrong type.
//


//
// MessageId: D2DERR_TEXT_RENDERER_NOT_RELEASED
//
// MessageText:
//
// The application is holding a reference to the IDWriteTextRenderer interface after the corresponding DrawText or DrawTextLayout call has returned. The IDWriteTextRenderer instance will be invalid.
//


//
// MessageId: D2DERR_EXCEEDS_MAX_BITMAP_SIZE
//
// MessageText:
//
// The requested size is larger than the guaranteed supported texture size at the Direct3D device's current feature level.
//


//
// MessageId: D2DERR_INVALID_GRAPH_CONFIGURATION
//
// MessageText:
//
// There was a configuration error in the graph.
//


//
// MessageId: D2DERR_INVALID_INTERNAL_GRAPH_CONFIGURATION
//
// MessageText:
//
// There was a internal configuration error in the graph.
//


//
// MessageId: D2DERR_CYCLIC_GRAPH
//
// MessageText:
//
// There was a cycle in the graph.
//


//
// MessageId: D2DERR_BITMAP_CANNOT_DRAW
//
// MessageText:
//
// Cannot draw with a bitmap that has the D2D1_BITMAP_OPTIONS_CANNOT_DRAW option.
//


//
// MessageId: D2DERR_OUTSTANDING_BITMAP_REFERENCES
//
// MessageText:
//
// The operation cannot complete while there are outstanding references to the target bitmap.
//


//
// MessageId: D2DERR_ORIGINAL_TARGET_NOT_BOUND
//
// MessageText:
//
// The operation failed because the original target is not currently bound as a target.
//


//
// MessageId: D2DERR_INVALID_TARGET
//
// MessageText:
//
// Cannot set the image as a target because it is either an effect or is a bitmap that does not have the D2D1_BITMAP_OPTIONS_TARGET flag set.
//


//
// MessageId: D2DERR_BITMAP_BOUND_AS_TARGET
//
// MessageText:
//
// Cannot draw with a bitmap that is currently bound as the target bitmap.
//


//
// MessageId: D2DERR_INSUFFICIENT_DEVICE_CAPABILITIES
//
// MessageText:
//
// D3D Device does not have sufficient capabilities to perform the requested action.
//


//
// MessageId: D2DERR_INTERMEDIATE_TOO_LARGE
//
// MessageText:
//
// The graph could not be rendered with the context's current tiling settings.
//


//
// MessageId: D2DERR_EFFECT_IS_NOT_REGISTERED
//
// MessageText:
//
// The CLSID provided to Unregister did not correspond to a registered effect.
//


//
// MessageId: D2DERR_INVALID_PROPERTY
//
// MessageText:
//
// The specified property does not exist.
//


//
// MessageId: D2DERR_NO_SUBPROPERTIES
//
// MessageText:
//
// The specified sub-property does not exist.
//


//
// MessageId: D2DERR_PRINT_JOB_CLOSED
//
// MessageText:
//
// AddPage or Close called after print job is already closed.
//


//
// MessageId: D2DERR_PRINT_FORMAT_NOT_SUPPORTED
//
// MessageText:
//
// Error during print control creation. Indicates that none of the package target types (representing printer formats) are supported by Direct2D print control.
//


//
// MessageId: D2DERR_TOO_MANY_TRANSFORM_INPUTS
//
// MessageText:
//
// An effect attempted to use a transform with too many inputs.
//


//
// MessageId: D2DERR_INVALID_GLYPH_IMAGE
//
// MessageText:
//
// An error was encountered while decoding or parsing the requested glyph image.
//



//
// DirectWrite
//

//
// MessageId: DWRITE_E_FILEFORMAT
//
// MessageText:
//
// Indicates an error in an input file such as a font file.
//


//
// MessageId: DWRITE_E_UNEXPECTED
//
// MessageText:
//
// Indicates an error originating in DirectWrite code, which is not expected to occur but is safe to recover from.
//


//
// MessageId: DWRITE_E_NOFONT
//
// MessageText:
//
// Indicates the specified font does not exist.
//


//
// MessageId: DWRITE_E_FILENOTFOUND
//
// MessageText:
//
// A font file could not be opened because the file, directory, network location, drive, or other storage location does not exist or is unavailable.
//


//
// MessageId: DWRITE_E_FILEACCESS
//
// MessageText:
//
// A font file exists but could not be opened due to access denied, sharing violation, or similar error.
//


//
// MessageId: DWRITE_E_FONTCOLLECTIONOBSOLETE
//
// MessageText:
//
// A font collection is obsolete due to changes in the system.
//


//
// MessageId: DWRITE_E_ALREADYREGISTERED
//
// MessageText:
//
// The given interface is already registered.
//


//
// MessageId: DWRITE_E_CACHEFORMAT
//
// MessageText:
//
// The font cache contains invalid data.
//


//
// MessageId: DWRITE_E_CACHEVERSION
//
// MessageText:
//
// A font cache file corresponds to a different version of DirectWrite.
//


//
// MessageId: DWRITE_E_UNSUPPORTEDOPERATION
//
// MessageText:
//
// The operation is not supported for this type of font.
//


//
// MessageId: DWRITE_E_TEXTRENDERERINCOMPATIBLE
//
// MessageText:
//
// The version of the text renderer interface is not compatible.
//


//
// MessageId: DWRITE_E_FLOWDIRECTIONCONFLICTS
//
// MessageText:
//
// The flow direction conflicts with the reading direction. They must be perpendicular to each other.
//


//
// MessageId: DWRITE_E_NOCOLOR
//
// MessageText:
//
// The font or glyph run does not contain any colored glyphs.
//


//
// MessageId: DWRITE_E_REMOTEFONT
//
// MessageText:
//
// A font resource could not be accessed because it is remote.
//


//
// MessageId: DWRITE_E_DOWNLOADCANCELLED
//
// MessageText:
//
// A font download was canceled.
//


//
// MessageId: DWRITE_E_DOWNLOADFAILED
//
// MessageText:
//
// A font download failed.
//


//
// MessageId: DWRITE_E_TOOMANYDOWNLOADS
//
// MessageText:
//
// A font download request was not added or a download failed because there are too many active downloads.
//



//
// Windows Codecs
//

//
// MessageId: WINCODEC_ERR_WRONGSTATE
//
// MessageText:
//
// The codec is in the wrong state.
//


//
// MessageId: WINCODEC_ERR_VALUEOUTOFRANGE
//
// MessageText:
//
// The value is out of range.
//


//
// MessageId: WINCODEC_ERR_UNKNOWNIMAGEFORMAT
//
// MessageText:
//
// The image format is unknown.
//


//
// MessageId: WINCODEC_ERR_UNSUPPORTEDVERSION
//
// MessageText:
//
// The SDK version is unsupported.
//


//
// MessageId: WINCODEC_ERR_NOTINITIALIZED
//
// MessageText:
//
// The component is not initialized.
//


//
// MessageId: WINCODEC_ERR_ALREADYLOCKED
//
// MessageText:
//
// There is already an outstanding read or write lock.
//


//
// MessageId: WINCODEC_ERR_PROPERTYNOTFOUND
//
// MessageText:
//
// The specified bitmap property cannot be found.
//


//
// MessageId: WINCODEC_ERR_PROPERTYNOTSUPPORTED
//
// MessageText:
//
// The bitmap codec does not support the bitmap property.
//


//
// MessageId: WINCODEC_ERR_PROPERTYSIZE
//
// MessageText:
//
// The bitmap property size is invalid.
//


//
// MessageId: WINCODEC_ERR_CODECPRESENT
//
// MessageText:
//
// An unknown error has occurred.
//


//
// MessageId: WINCODEC_ERR_CODECNOTHUMBNAIL
//
// MessageText:
//
// The bitmap codec does not support a thumbnail.
//


//
// MessageId: WINCODEC_ERR_PALETTEUNAVAILABLE
//
// MessageText:
//
// The bitmap palette is unavailable.
//


//
// MessageId: WINCODEC_ERR_CODECTOOMANYSCANLINES
//
// MessageText:
//
// Too many scanlines were requested.
//


//
// MessageId: WINCODEC_ERR_INTERNALERROR
//
// MessageText:
//
// An internal error occurred.
//


//
// MessageId: WINCODEC_ERR_SOURCERECTDOESNOTMATCHDIMENSIONS
//
// MessageText:
//
// The bitmap bounds do not match the bitmap dimensions.
//


//
// MessageId: WINCODEC_ERR_COMPONENTNOTFOUND
//
// MessageText:
//
// The component cannot be found.
//


//
// MessageId: WINCODEC_ERR_IMAGESIZEOUTOFRANGE
//
// MessageText:
//
// The bitmap size is outside the valid range.
//


//
// MessageId: WINCODEC_ERR_TOOMUCHMETADATA
//
// MessageText:
//
// There is too much metadata to be written to the bitmap.
//


//
// MessageId: WINCODEC_ERR_BADIMAGE
//
// MessageText:
//
// The image is unrecognized.
//


//
// MessageId: WINCODEC_ERR_BADHEADER
//
// MessageText:
//
// The image header is unrecognized.
//


//
// MessageId: WINCODEC_ERR_FRAMEMISSING
//
// MessageText:
//
// The bitmap frame is missing.
//


//
// MessageId: WINCODEC_ERR_BADMETADATAHEADER
//
// MessageText:
//
// The image metadata header is unrecognized.
//


//
// MessageId: WINCODEC_ERR_BADSTREAMDATA
//
// MessageText:
//
// The stream data is unrecognized.
//


//
// MessageId: WINCODEC_ERR_STREAMWRITE
//
// MessageText:
//
// Failed to write to the stream.
//


//
// MessageId: WINCODEC_ERR_STREAMREAD
//
// MessageText:
//
// Failed to read from the stream.
//


//
// MessageId: WINCODEC_ERR_STREAMNOTAVAILABLE
//
// MessageText:
//
// The stream is not available.
//


//
// MessageId: WINCODEC_ERR_UNSUPPORTEDPIXELFORMAT
//
// MessageText:
//
// The bitmap pixel format is unsupported.
//


//
// MessageId: WINCODEC_ERR_UNSUPPORTEDOPERATION
//
// MessageText:
//
// The operation is unsupported.
//


//
// MessageId: WINCODEC_ERR_INVALIDREGISTRATION
//
// MessageText:
//
// The component registration is invalid.
//


//
// MessageId: WINCODEC_ERR_COMPONENTINITIALIZEFAILURE
//
// MessageText:
//
// The component initialization has failed.
//


//
// MessageId: WINCODEC_ERR_INSUFFICIENTBUFFER
//
// MessageText:
//
// The buffer allocated is insufficient.
//


//
// MessageId: WINCODEC_ERR_DUPLICATEMETADATAPRESENT
//
// MessageText:
//
// Duplicate metadata is present.
//


//
// MessageId: WINCODEC_ERR_PROPERTYUNEXPECTEDTYPE
//
// MessageText:
//
// The bitmap property type is unexpected.
//


//
// MessageId: WINCODEC_ERR_UNEXPECTEDSIZE
//
// MessageText:
//
// The size is unexpected.
//


//
// MessageId: WINCODEC_ERR_INVALIDQUERYREQUEST
//
// MessageText:
//
// The property query is invalid.
//


//
// MessageId: WINCODEC_ERR_UNEXPECTEDMETADATATYPE
//
// MessageText:
//
// The metadata type is unexpected.
//


//
// MessageId: WINCODEC_ERR_REQUESTONLYVALIDATMETADATAROOT
//
// MessageText:
//
// The specified bitmap property is only valid at root level.
//


//
// MessageId: WINCODEC_ERR_INVALIDQUERYCHARACTER
//
// MessageText:
//
// The query string contains an invalid character.
//


//
// MessageId: WINCODEC_ERR_WIN32ERROR
//
// MessageText:
//
// Windows Codecs received an error from the Win32 system.
//


//
// MessageId: WINCODEC_ERR_INVALIDPROGRESSIVELEVEL
//
// MessageText:
//
// The requested level of detail is not present.
//


//
// MessageId: WINCODEC_ERR_INVALIDJPEGSCANINDEX
//
// MessageText:
//
// The scan index is invalid.
//



//
// MIL/DWM
//

//
// MessageId: MILERR_OBJECTBUSY
//
// MessageText:
//
// MILERR_OBJECTBUSY
//


//
// MessageId: MILERR_INSUFFICIENTBUFFER
//
// MessageText:
//
// MILERR_INSUFFICIENTBUFFER
//


//
// MessageId: MILERR_WIN32ERROR
//
// MessageText:
//
// MILERR_WIN32ERROR
//


//
// MessageId: MILERR_SCANNER_FAILED
//
// MessageText:
//
// MILERR_SCANNER_FAILED
//


//
// MessageId: MILERR_SCREENACCESSDENIED
//
// MessageText:
//
// MILERR_SCREENACCESSDENIED
//


//
// MessageId: MILERR_DISPLAYSTATEINVALID
//
// MessageText:
//
// MILERR_DISPLAYSTATEINVALID
//


//
// MessageId: MILERR_NONINVERTIBLEMATRIX
//
// MessageText:
//
// MILERR_NONINVERTIBLEMATRIX
//


//
// MessageId: MILERR_ZEROVECTOR
//
// MessageText:
//
// MILERR_ZEROVECTOR
//


//
// MessageId: MILERR_TERMINATED
//
// MessageText:
//
// MILERR_TERMINATED
//


//
// MessageId: MILERR_BADNUMBER
//
// MessageText:
//
// MILERR_BADNUMBER
//


//
// MessageId: MILERR_INTERNALERROR
//
// MessageText:
//
// An internal error (MIL bug) occurred. On checked builds, an assert would be raised.
//


//
// MessageId: MILERR_DISPLAYFORMATNOTSUPPORTED
//
// MessageText:
//
// The display format we need to render is not supported by the hardware device.
//


//
// MessageId: MILERR_INVALIDCALL
//
// MessageText:
//
// A call to this method is invalid.
//


//
// MessageId: MILERR_ALREADYLOCKED
//
// MessageText:
//
// Lock attempted on an already locked object.
//


//
// MessageId: MILERR_NOTLOCKED
//
// MessageText:
//
// Unlock attempted on an unlocked object.
//


//
// MessageId: MILERR_DEVICECANNOTRENDERTEXT
//
// MessageText:
//
// No algorithm available to render text with this device
//


//
// MessageId: MILERR_GLYPHBITMAPMISSED
//
// MessageText:
//
// Some glyph bitmaps, required for glyph run rendering, are not contained in glyph cache.
//


//
// MessageId: MILERR_MALFORMEDGLYPHCACHE
//
// MessageText:
//
// Some glyph bitmaps in glyph cache are unexpectedly big.
//


//
// MessageId: MILERR_GENERIC_IGNORE
//
// MessageText:
//
// Marker error for known Win32 errors that are currently being ignored by the compositor. This is to avoid returning S_OK when an error has occurred, but still unwind the stack in the correct location.
//


//
// MessageId: MILERR_MALFORMED_GUIDELINE_DATA
//
// MessageText:
//
// Guideline coordinates are not sorted properly or contain NaNs.
//


//
// MessageId: MILERR_NO_HARDWARE_DEVICE
//
// MessageText:
//
// No HW rendering device is available for this operation.
//


//
// MessageId: MILERR_NEED_RECREATE_AND_PRESENT
//
// MessageText:
//
// There has been a presentation error that may be recoverable. The caller needs to recreate, rerender the entire frame, and reattempt present.
// There are two known case for this: 1) D3D Driver Internal error 2) D3D E_FAIL 2a) Unknown root cause b) When resizing too quickly for DWM and D3D stay in sync
//


//
// MessageId: MILERR_ALREADY_INITIALIZED
//
// MessageText:
//
// The object has already been initialized.
//


//
// MessageId: MILERR_MISMATCHED_SIZE
//
// MessageText:
//
// The size of the object does not match the expected size.
//


//
// MessageId: MILERR_NO_REDIRECTION_SURFACE_AVAILABLE
//
// MessageText:
//
// No Redirection surface available.
//


//
// MessageId: MILERR_REMOTING_NOT_SUPPORTED
//
// MessageText:
//
// Remoting of this content is not supported.
//


//
// MessageId: MILERR_QUEUED_PRESENT_NOT_SUPPORTED
//
// MessageText:
//
// Queued Presents are not supported.
//


//
// MessageId: MILERR_NOT_QUEUING_PRESENTS
//
// MessageText:
//
// Queued Presents are not being used.
//


//
// MessageId: MILERR_NO_REDIRECTION_SURFACE_RETRY_LATER
//
// MessageText:
//
// No redirection surface was available. Caller should retry the call.
//


//
// MessageId: MILERR_TOOMANYSHADERELEMNTS
//
// MessageText:
//
// Shader construction failed because it was too complex.
//


//
// MessageId: MILERR_MROW_READLOCK_FAILED
//
// MessageText:
//
// MROW attempt to get a read lock failed.
//


//
// MessageId: MILERR_MROW_UPDATE_FAILED
//
// MessageText:
//
// MROW attempt to update the data failed because another update was outstanding.
//


//
// MessageId: MILERR_SHADER_COMPILE_FAILED
//
// MessageText:
//
// Shader compilation failed.
//


//
// MessageId: MILERR_MAX_TEXTURE_SIZE_EXCEEDED
//
// MessageText:
//
// Requested DX redirection surface size exceeded maximum texture size.
//


//
// MessageId: MILERR_QPC_TIME_WENT_BACKWARD
//
// MessageText:
//
// QueryPerformanceCounter returned a time in the past.
//


//
// MessageId: MILERR_DXGI_ENUMERATION_OUT_OF_SYNC
//
// MessageText:
//
// Primary Display device returned an invalid refresh rate.
//


//
// MessageId: MILERR_ADAPTER_NOT_FOUND
//
// MessageText:
//
// DWM can not find the adapter specified by the LUID.
//


//
// MessageId: MILERR_COLORSPACE_NOT_SUPPORTED
//
// MessageText:
//
// The requested bitmap color space is not supported.
//


//
// MessageId: MILERR_PREFILTER_NOT_SUPPORTED
//
// MessageText:
//
// The requested bitmap pre-filtering state is not supported.
//


//
// MessageId: MILERR_DISPLAYID_ACCESS_DENIED
//
// MessageText:
//
// Access is denied to the requested bitmap for the specified display id.
//


// Composition engine errors
//
// MessageId: UCEERR_INVALIDPACKETHEADER
//
// MessageText:
//
// UCEERR_INVALIDPACKETHEADER
//


//
// MessageId: UCEERR_UNKNOWNPACKET
//
// MessageText:
//
// UCEERR_UNKNOWNPACKET
//


//
// MessageId: UCEERR_ILLEGALPACKET
//
// MessageText:
//
// UCEERR_ILLEGALPACKET
//


//
// MessageId: UCEERR_MALFORMEDPACKET
//
// MessageText:
//
// UCEERR_MALFORMEDPACKET
//


//
// MessageId: UCEERR_ILLEGALHANDLE
//
// MessageText:
//
// UCEERR_ILLEGALHANDLE
//


//
// MessageId: UCEERR_HANDLELOOKUPFAILED
//
// MessageText:
//
// UCEERR_HANDLELOOKUPFAILED
//


//
// MessageId: UCEERR_RENDERTHREADFAILURE
//
// MessageText:
//
// UCEERR_RENDERTHREADFAILURE
//


//
// MessageId: UCEERR_CTXSTACKFRSTTARGETNULL
//
// MessageText:
//
// UCEERR_CTXSTACKFRSTTARGETNULL
//


//
// MessageId: UCEERR_CONNECTIONIDLOOKUPFAILED
//
// MessageText:
//
// UCEERR_CONNECTIONIDLOOKUPFAILED
//


//
// MessageId: UCEERR_BLOCKSFULL
//
// MessageText:
//
// UCEERR_BLOCKSFULL
//


//
// MessageId: UCEERR_MEMORYFAILURE
//
// MessageText:
//
// UCEERR_MEMORYFAILURE
//


//
// MessageId: UCEERR_PACKETRECORDOUTOFRANGE
//
// MessageText:
//
// UCEERR_PACKETRECORDOUTOFRANGE
//


//
// MessageId: UCEERR_ILLEGALRECORDTYPE
//
// MessageText:
//
// UCEERR_ILLEGALRECORDTYPE
//


//
// MessageId: UCEERR_OUTOFHANDLES
//
// MessageText:
//
// UCEERR_OUTOFHANDLES
//


//
// MessageId: UCEERR_UNCHANGABLE_UPDATE_ATTEMPTED
//
// MessageText:
//
// UCEERR_UNCHANGABLE_UPDATE_ATTEMPTED
//


//
// MessageId: UCEERR_NO_MULTIPLE_WORKER_THREADS
//
// MessageText:
//
// UCEERR_NO_MULTIPLE_WORKER_THREADS
//


//
// MessageId: UCEERR_REMOTINGNOTSUPPORTED
//
// MessageText:
//
// UCEERR_REMOTINGNOTSUPPORTED
//


//
// MessageId: UCEERR_MISSINGENDCOMMAND
//
// MessageText:
//
// UCEERR_MISSINGENDCOMMAND
//


//
// MessageId: UCEERR_MISSINGBEGINCOMMAND
//
// MessageText:
//
// UCEERR_MISSINGBEGINCOMMAND
//


//
// MessageId: UCEERR_CHANNELSYNCTIMEDOUT
//
// MessageText:
//
// UCEERR_CHANNELSYNCTIMEDOUT
//


//
// MessageId: UCEERR_CHANNELSYNCABANDONED
//
// MessageText:
//
// UCEERR_CHANNELSYNCABANDONED
//


//
// MessageId: UCEERR_UNSUPPORTEDTRANSPORTVERSION
//
// MessageText:
//
// UCEERR_UNSUPPORTEDTRANSPORTVERSION
//


//
// MessageId: UCEERR_TRANSPORTUNAVAILABLE
//
// MessageText:
//
// UCEERR_TRANSPORTUNAVAILABLE
//


//
// MessageId: UCEERR_FEEDBACK_UNSUPPORTED
//
// MessageText:
//
// UCEERR_FEEDBACK_UNSUPPORTED
//


//
// MessageId: UCEERR_COMMANDTRANSPORTDENIED
//
// MessageText:
//
// UCEERR_COMMANDTRANSPORTDENIED
//


//
// MessageId: UCEERR_GRAPHICSSTREAMUNAVAILABLE
//
// MessageText:
//
// UCEERR_GRAPHICSSTREAMUNAVAILABLE
//


//
// MessageId: UCEERR_GRAPHICSSTREAMALREADYOPEN
//
// MessageText:
//
// UCEERR_GRAPHICSSTREAMALREADYOPEN
//


//
// MessageId: UCEERR_TRANSPORTDISCONNECTED
//
// MessageText:
//
// UCEERR_TRANSPORTDISCONNECTED
//


//
// MessageId: UCEERR_TRANSPORTOVERLOADED
//
// MessageText:
//
// UCEERR_TRANSPORTOVERLOADED
//


//
// MessageId: UCEERR_PARTITION_ZOMBIED
//
// MessageText:
//
// UCEERR_PARTITION_ZOMBIED
//


// MIL AV Specific errors
//
// MessageId: MILAVERR_NOCLOCK
//
// MessageText:
//
// MILAVERR_NOCLOCK
//


//
// MessageId: MILAVERR_NOMEDIATYPE
//
// MessageText:
//
// MILAVERR_NOMEDIATYPE
//


//
// MessageId: MILAVERR_NOVIDEOMIXER
//
// MessageText:
//
// MILAVERR_NOVIDEOMIXER
//


//
// MessageId: MILAVERR_NOVIDEOPRESENTER
//
// MessageText:
//
// MILAVERR_NOVIDEOPRESENTER
//


//
// MessageId: MILAVERR_NOREADYFRAMES
//
// MessageText:
//
// MILAVERR_NOREADYFRAMES
//


//
// MessageId: MILAVERR_MODULENOTLOADED
//
// MessageText:
//
// MILAVERR_MODULENOTLOADED
//


//
// MessageId: MILAVERR_WMPFACTORYNOTREGISTERED
//
// MessageText:
//
// MILAVERR_WMPFACTORYNOTREGISTERED
//


//
// MessageId: MILAVERR_INVALIDWMPVERSION
//
// MessageText:
//
// MILAVERR_INVALIDWMPVERSION
//


//
// MessageId: MILAVERR_INSUFFICIENTVIDEORESOURCES
//
// MessageText:
//
// MILAVERR_INSUFFICIENTVIDEORESOURCES
//


//
// MessageId: MILAVERR_VIDEOACCELERATIONNOTAVAILABLE
//
// MessageText:
//
// MILAVERR_VIDEOACCELERATIONNOTAVAILABLE
//


//
// MessageId: MILAVERR_REQUESTEDTEXTURETOOBIG
//
// MessageText:
//
// MILAVERR_REQUESTEDTEXTURETOOBIG
//


//
// MessageId: MILAVERR_SEEKFAILED
//
// MessageText:
//
// MILAVERR_SEEKFAILED
//


//
// MessageId: MILAVERR_UNEXPECTEDWMPFAILURE
//
// MessageText:
//
// MILAVERR_UNEXPECTEDWMPFAILURE
//


//
// MessageId: MILAVERR_MEDIAPLAYERCLOSED
//
// MessageText:
//
// MILAVERR_MEDIAPLAYERCLOSED
//


//
// MessageId: MILAVERR_UNKNOWNHARDWAREERROR
//
// MessageText:
//
// MILAVERR_UNKNOWNHARDWAREERROR
//


// MIL Bitmap Effect errors
//
// MessageId: MILEFFECTSERR_UNKNOWNPROPERTY
//
// MessageText:
//
// MILEFFECTSERR_UNKNOWNPROPERTY
//


//
// MessageId: MILEFFECTSERR_EFFECTNOTPARTOFGROUP
//
// MessageText:
//
// MILEFFECTSERR_EFFECTNOTPARTOFGROUP
//


//
// MessageId: MILEFFECTSERR_NOINPUTSOURCEATTACHED
//
// MessageText:
//
// MILEFFECTSERR_NOINPUTSOURCEATTACHED
//


//
// MessageId: MILEFFECTSERR_CONNECTORNOTCONNECTED
//
// MessageText:
//
// MILEFFECTSERR_CONNECTORNOTCONNECTED
//


//
// MessageId: MILEFFECTSERR_CONNECTORNOTASSOCIATEDWITHEFFECT
//
// MessageText:
//
// MILEFFECTSERR_CONNECTORNOTASSOCIATEDWITHEFFECT
//


//
// MessageId: MILEFFECTSERR_RESERVED
//
// MessageText:
//
// MILEFFECTSERR_RESERVED
//


//
// MessageId: MILEFFECTSERR_CYCLEDETECTED
//
// MessageText:
//
// MILEFFECTSERR_CYCLEDETECTED
//


//
// MessageId: MILEFFECTSERR_EFFECTINMORETHANONEGRAPH
//
// MessageText:
//
// MILEFFECTSERR_EFFECTINMORETHANONEGRAPH
//


//
// MessageId: MILEFFECTSERR_EFFECTALREADYINAGRAPH
//
// MessageText:
//
// MILEFFECTSERR_EFFECTALREADYINAGRAPH
//


//
// MessageId: MILEFFECTSERR_EFFECTHASNOCHILDREN
//
// MessageText:
//
// MILEFFECTSERR_EFFECTHASNOCHILDREN
//


//
// MessageId: MILEFFECTSERR_ALREADYATTACHEDTOLISTENER
//
// MessageText:
//
// MILEFFECTSERR_ALREADYATTACHEDTOLISTENER
//


//
// MessageId: MILEFFECTSERR_NOTAFFINETRANSFORM
//
// MessageText:
//
// MILEFFECTSERR_NOTAFFINETRANSFORM
//


//
// MessageId: MILEFFECTSERR_EMPTYBOUNDS
//
// MessageText:
//
// MILEFFECTSERR_EMPTYBOUNDS
//


//
// MessageId: MILEFFECTSERR_OUTPUTSIZETOOLARGE
//
// MessageText:
//
// MILEFFECTSERR_OUTPUTSIZETOOLARGE
//


// DWM specific errors
//
// MessageId: DWMERR_STATE_TRANSITION_FAILED
//
// MessageText:
//
// DWMERR_STATE_TRANSITION_FAILED
//


//
// MessageId: DWMERR_THEME_FAILED
//
// MessageText:
//
// DWMERR_THEME_FAILED
//


//
// MessageId: DWMERR_CATASTROPHIC_FAILURE
//
// MessageText:
//
// DWMERR_CATASTROPHIC_FAILURE
//



//
// DirectComposition
//

//
// MessageId: DCOMPOSITION_ERROR_WINDOW_ALREADY_COMPOSED
//
// MessageText:
//
// DCOMPOSITION_ERROR_WINDOW_ALREADY_COMPOSED
//


//
// MessageId: DCOMPOSITION_ERROR_SURFACE_BEING_RENDERED
//
// MessageText:
//
// DCOMPOSITION_ERROR_SURFACE_BEING_RENDERED
//


//
// MessageId: DCOMPOSITION_ERROR_SURFACE_NOT_BEING_RENDERED
//
// MessageText:
//
// DCOMPOSITION_ERROR_SURFACE_NOT_BEING_RENDERED
//



//
// OnlineId
//

//
// MessageId: ONL_E_INVALID_AUTHENTICATION_TARGET
//
// MessageText:
//
// Authentication target is invalid or not configured correctly.
//


//
// MessageId: ONL_E_ACCESS_DENIED_BY_TOU
//
// MessageText:
//
// Your application cannot get the Online Id properties due to the Terms of Use accepted by the user.
//


//
// MessageId: ONL_E_INVALID_APPLICATION
//
// MessageText:
//
// The application requesting authentication tokens is either disabled or incorrectly configured.
//


//
// MessageId: ONL_E_PASSWORD_UPDATE_REQUIRED
//
// MessageText:
//
// Online Id password must be updated before signin.
//


//
// MessageId: ONL_E_ACCOUNT_UPDATE_REQUIRED
//
// MessageText:
//
// Online Id account properties must be updated before signin.
//


//
// MessageId: ONL_E_FORCESIGNIN
//
// MessageText:
//
// To help protect your Online Id account you must signin again.
//


//
// MessageId: ONL_E_ACCOUNT_LOCKED
//
// MessageText:
//
// Online Id account was locked because there have been too many attempts to sign in.
//


//
// MessageId: ONL_E_PARENTAL_CONSENT_REQUIRED
//
// MessageText:
//
// Online Id account requires parental consent before proceeding.
//


//
// MessageId: ONL_E_EMAIL_VERIFICATION_REQUIRED
//
// MessageText:
//
// Online Id signin name is not yet verified. Email verification is required before signin.
//


//
// MessageId: ONL_E_ACCOUNT_SUSPENDED_COMPROIMISE
//
// MessageText:
//
// We have noticed some unusual activity in your Online Id account. Your action is needed to make sure no one else is using your account.
//


//
// MessageId: ONL_E_ACCOUNT_SUSPENDED_ABUSE
//
// MessageText:
//
// We detected some suspicious activity with your Online Id account. To help protect you, we've temporarily blocked your account.
//


//
// MessageId: ONL_E_ACTION_REQUIRED
//
// MessageText:
//
// User interaction is required for authentication.
//


//
// MessageId: ONL_CONNECTION_COUNT_LIMIT
//
// MessageText:
//
// User has reached the maximum device associations per user limit.
//


//
// MessageId: ONL_E_CONNECTED_ACCOUNT_CAN_NOT_SIGNOUT
//
// MessageText:
//
// Cannot sign out from the application since the user account is connected.
//


//
// MessageId: ONL_E_USER_AUTHENTICATION_REQUIRED
//
// MessageText:
//
// User authentication is required for this operation.
//


//
// MessageId: ONL_E_REQUEST_THROTTLED
//
// MessageText:
//
// We want to make sure this is you. User interaction is required for authentication.
//



//
// Facility Shell Error codes
//

//
// MessageId: FA_E_MAX_PERSISTED_ITEMS_REACHED
//
// MessageText:
//
// The maximum number of items for the access list has been reached. An item must be removed before another item is added.
//


//
// MessageId: FA_E_HOMEGROUP_NOT_AVAILABLE
//
// MessageText:
//
// Cannot access Homegroup. Homegroup may not be set up or may have encountered an error.
//


//
// MessageId: E_MONITOR_RESOLUTION_TOO_LOW
//
// MessageText:
//
// This app can't start because the screen resolution is below 1024x768. Choose a higher screen resolution and then try again.
//


//
// MessageId: E_ELEVATED_ACTIVATION_NOT_SUPPORTED
//
// MessageText:
//
// This app can't be activated from an elevated context.
//


//
// MessageId: E_UAC_DISABLED
//
// MessageText:
//
// This app can't be activated when UAC is disabled.
//


//
// MessageId: E_FULL_ADMIN_NOT_SUPPORTED
//
// MessageText:
//
// This app can't be activated by the Built-in Administrator.
//


//
// MessageId: E_APPLICATION_NOT_REGISTERED
//
// MessageText:
//
// This app does not support the contract specified or is not installed.
//


//
// MessageId: E_MULTIPLE_EXTENSIONS_FOR_APPLICATION
//
// MessageText:
//
// This app has multiple extensions registered to support the specified contract. Activation by AppUserModelId is ambiguous.
//


//
// MessageId: E_MULTIPLE_PACKAGES_FOR_FAMILY
//
// MessageText:
//
// This app's package family has more than one package installed. This is not supported.
//


//
// MessageId: E_APPLICATION_MANAGER_NOT_RUNNING
//
// MessageText:
//
// The app manager is required to activate applications, but is not running.
//


//
// MessageId: S_STORE_LAUNCHED_FOR_REMEDIATION
//
// MessageText:
//
// The Store was launched instead of the specified app because the app's package was in an invalid state.
//


//
// MessageId: S_APPLICATION_ACTIVATION_ERROR_HANDLED_BY_DIALOG
//
// MessageText:
//
// This app failed to launch, but the error was handled with a dialog.
//


//
// MessageId: E_APPLICATION_ACTIVATION_TIMED_OUT
//
// MessageText:
//
// The app didn't start in the required time.
//


//
// MessageId: E_APPLICATION_ACTIVATION_EXEC_FAILURE
//
// MessageText:
//
// The app didn't start.
//


//
// MessageId: E_APPLICATION_TEMPORARY_LICENSE_ERROR
//
// MessageText:
//
// This app failed to launch because of an issue with its license. Please try again in a moment.
//


//
// MessageId: E_APPLICATION_TRIAL_LICENSE_EXPIRED
//
// MessageText:
//
// This app failed to launch because its trial license has expired.
//


//
// MessageId: E_SKYDRIVE_ROOT_TARGET_FILE_SYSTEM_NOT_SUPPORTED
//
// MessageText:
//
// Please choose a folder on a drive that's formatted with the NTFS file system.
//


//
// MessageId: E_SKYDRIVE_ROOT_TARGET_OVERLAP
//
// MessageText:
//
// This location is already being used. Please choose a different location.
//


//
// MessageId: E_SKYDRIVE_ROOT_TARGET_CANNOT_INDEX
//
// MessageText:
//
// This location cannot be indexed. Please choose a different location.
//


//
// MessageId: E_SKYDRIVE_FILE_NOT_UPLOADED
//
// MessageText:
//
// Sorry, the action couldn't be completed because the file hasn't finished uploading. Try again later.
//


//
// MessageId: E_SKYDRIVE_UPDATE_AVAILABILITY_FAIL
//
// MessageText:
//
// Sorry, the action couldn't be completed.
//


//
// MessageId: E_SKYDRIVE_ROOT_TARGET_VOLUME_ROOT_NOT_SUPPORTED
//
// MessageText:
//
// This content can only be moved to a folder. To move the content to this drive, please choose or create a folder.
//



// Sync Engine File Error Codes

//
// MessageId: E_SYNCENGINE_FILE_SIZE_OVER_LIMIT
//
// MessageText:
//
// The file size is larger than supported by the sync engine.
//


//
// MessageId: E_SYNCENGINE_FILE_SIZE_EXCEEDS_REMAINING_QUOTA
//
// MessageText:
//
// The file cannot be uploaded because it doesn't fit in the user's available service provided storage space.
//


//
// MessageId: E_SYNCENGINE_UNSUPPORTED_FILE_NAME
//
// MessageText:
//
// The file name contains invalid characters.
//


//
// MessageId: E_SYNCENGINE_FOLDER_ITEM_COUNT_LIMIT_EXCEEDED
//
// MessageText:
//
// The maximum file count has been reached for this folder in the sync engine.
//


//
// MessageId: E_SYNCENGINE_FILE_SYNC_PARTNER_ERROR
//
// MessageText:
//
// The file sync has been delegated to another program and has run into an issue.
//


//
// MessageId: E_SYNCENGINE_SYNC_PAUSED_BY_SERVICE
//
// MessageText:
//
// Sync has been delayed due to a throttling request from the service.
//



// Sync Engine Stream Resolver Errors

//
// MessageId: E_SYNCENGINE_FILE_IDENTIFIER_UNKNOWN
//
// MessageText:
//
// We can't seem to find that file. Please try again later.
//


//
// MessageId: E_SYNCENGINE_SERVICE_AUTHENTICATION_FAILED
//
// MessageText:
//
// The account you're signed in with doesn't have permission to open this file.
//


//
// MessageId: E_SYNCENGINE_UNKNOWN_SERVICE_ERROR
//
// MessageText:
//
// There was a problem connecting to the service. Please try again later.
//


//
// MessageId: E_SYNCENGINE_SERVICE_RETURNED_UNEXPECTED_SIZE
//
// MessageText:
//
// Sorry, there was a problem downloading the file.
//


//
// MessageId: E_SYNCENGINE_REQUEST_BLOCKED_BY_SERVICE
//
// MessageText:
//
// We're having trouble downloading the file right now. Please try again later.
//


//
// MessageId: E_SYNCENGINE_REQUEST_BLOCKED_DUE_TO_CLIENT_ERROR
//
// MessageText:
//
// We're having trouble downloading the file right now. Please try again later.
//



// Sync Engine Global Errors

//
// MessageId: E_SYNCENGINE_FOLDER_INACCESSIBLE
//
// MessageText:
//
// The sync engine does not have permissions to access a local folder under the sync root.
//


//
// MessageId: E_SYNCENGINE_UNSUPPORTED_FOLDER_NAME
//
// MessageText:
//
// The folder name contains invalid characters.
//


//
// MessageId: E_SYNCENGINE_UNSUPPORTED_MARKET
//
// MessageText:
//
// The sync engine is not allowed to run in your current market.
//


//
// MessageId: E_SYNCENGINE_PATH_LENGTH_LIMIT_EXCEEDED
//
// MessageText:
//
// All files and folders can't be uploaded because a path of a file or folder is too long.
//


//
// MessageId: E_SYNCENGINE_REMOTE_PATH_LENGTH_LIMIT_EXCEEDED
//
// MessageText:
//
// All file and folders cannot be synchronized because a path of a file or folder would exceed the local path limit.
//


//
// MessageId: E_SYNCENGINE_CLIENT_UPDATE_NEEDED
//
// MessageText:
//
// Updates are needed in order to use the sync engine.
//


//
// MessageId: E_SYNCENGINE_PROXY_AUTHENTICATION_REQUIRED
//
// MessageText:
//
// The sync engine needs to authenticate with a proxy server.
//


//
// MessageId: E_SYNCENGINE_STORAGE_SERVICE_PROVISIONING_FAILED
//
// MessageText:
//
// There was a problem setting up the storage services for the account.
//


//
// MessageId: E_SYNCENGINE_UNSUPPORTED_REPARSE_POINT
//
// MessageText:
//
// Files can't be uploaded because there's an unsupported reparse point.
//


//
// MessageId: E_SYNCENGINE_STORAGE_SERVICE_BLOCKED
//
// MessageText:
//
// The service has blocked your account from accessing the storage service.
//


//
// MessageId: E_SYNCENGINE_FOLDER_IN_REDIRECTION
//
// MessageText:
//
// The action can't be performed right now because this folder is being moved. Please try again later.
//



//
// EAS
//

//
// MessageId: EAS_E_POLICY_NOT_MANAGED_BY_OS
//
// MessageText:
//
// Windows cannot evaluate this EAS policy since this is not managed by the operating system.
//


//
// MessageId: EAS_E_POLICY_COMPLIANT_WITH_ACTIONS
//
// MessageText:
//
// The system can be made compliant to this EAS policy if certain actions are performed by the user.
//


//
// MessageId: EAS_E_REQUESTED_POLICY_NOT_ENFORCEABLE
//
// MessageText:
//
// The EAS policy being evaluated cannot be enforced by the system.
//


//
// MessageId: EAS_E_CURRENT_USER_HAS_BLANK_PASSWORD
//
// MessageText:
//
// EAS password policies for the user cannot be evaluated as the user has a blank password.
//


//
// MessageId: EAS_E_REQUESTED_POLICY_PASSWORD_EXPIRATION_INCOMPATIBLE
//
// MessageText:
//
// EAS password expiration policy cannot be satisfied as the password expiration interval is less than the minimum password interval of the system.
//


//
// MessageId: EAS_E_USER_CANNOT_CHANGE_PASSWORD
//
// MessageText:
//
// The user is not allowed to change her password.
//


//
// MessageId: EAS_E_ADMINS_HAVE_BLANK_PASSWORD
//
// MessageText:
//
// EAS password policies cannot be evaluated as one or more admins have blank passwords.
//


//
// MessageId: EAS_E_ADMINS_CANNOT_CHANGE_PASSWORD
//
// MessageText:
//
// One or more admins are not allowed to change their password.
//


//
// MessageId: EAS_E_LOCAL_CONTROLLED_USERS_CANNOT_CHANGE_PASSWORD
//
// MessageText:
//
// There are other standard users present who are not allowed to change their password.
//


//
// MessageId: EAS_E_PASSWORD_POLICY_NOT_ENFORCEABLE_FOR_CONNECTED_ADMINS
//
// MessageText:
//
// The EAS password policy cannot be enforced by the connected account provider of at least one administrator.
//


//
// MessageId: EAS_E_CONNECTED_ADMINS_NEED_TO_CHANGE_PASSWORD
//
// MessageText:
//
// There is at least one administrator whose connected account password needs to be changed for EAS password policy compliance.
//


//
// MessageId: EAS_E_PASSWORD_POLICY_NOT_ENFORCEABLE_FOR_CURRENT_CONNECTED_USER
//
// MessageText:
//
// The EAS password policy cannot be enforced by the connected account provider of the current user.
//


//
// MessageId: EAS_E_CURRENT_CONNECTED_USER_NEED_TO_CHANGE_PASSWORD
//
// MessageText:
//
// The connected account password of the current user needs to be changed for EAS password policy compliance.
//


//
// MessageId: WEB_E_UNSUPPORTED_FORMAT
//
// MessageText:
//
// Unsupported format.
//


//
// MessageId: WEB_E_INVALID_XML
//
// MessageText:
//
// Invalid XML.
//


//
// MessageId: WEB_E_MISSING_REQUIRED_ELEMENT
//
// MessageText:
//
// Missing required element.
//


//
// MessageId: WEB_E_MISSING_REQUIRED_ATTRIBUTE
//
// MessageText:
//
// Missing required attribute.
//


//
// MessageId: WEB_E_UNEXPECTED_CONTENT
//
// MessageText:
//
// Unexpected content.
//


//
// MessageId: WEB_E_RESOURCE_TOO_LARGE
//
// MessageText:
//
// Resource too large.
//


//
// MessageId: WEB_E_INVALID_JSON_STRING
//
// MessageText:
//
// Invalid JSON string.
//


//
// MessageId: WEB_E_INVALID_JSON_NUMBER
//
// MessageText:
//
// Invalid JSON number.
//


//
// MessageId: WEB_E_JSON_VALUE_NOT_FOUND
//
// MessageText:
//
// JSON value not found.
//


//
// MessageId: HTTP_E_STATUS_UNEXPECTED
//
// MessageText:
//
// Unexpected HTTP status code.
//


//
// MessageId: HTTP_E_STATUS_UNEXPECTED_REDIRECTION
//
// MessageText:
//
// Unexpected redirection status code (3xx).
//


//
// MessageId: HTTP_E_STATUS_UNEXPECTED_CLIENT_ERROR
//
// MessageText:
//
// Unexpected client error status code (4xx).
//


//
// MessageId: HTTP_E_STATUS_UNEXPECTED_SERVER_ERROR
//
// MessageText:
//
// Unexpected server error status code (5xx).
//


//
// MessageId: HTTP_E_STATUS_AMBIGUOUS
//
// MessageText:
//
// Multiple choices (300).
//


//
// MessageId: HTTP_E_STATUS_MOVED
//
// MessageText:
//
// Moved permanently (301).
//


//
// MessageId: HTTP_E_STATUS_REDIRECT
//
// MessageText:
//
// Found (302).
//


//
// MessageId: HTTP_E_STATUS_REDIRECT_METHOD
//
// MessageText:
//
// See Other (303).
//


//
// MessageId: HTTP_E_STATUS_NOT_MODIFIED
//
// MessageText:
//
// Not modified (304).
//


//
// MessageId: HTTP_E_STATUS_USE_PROXY
//
// MessageText:
//
// Use proxy (305).
//


//
// MessageId: HTTP_E_STATUS_REDIRECT_KEEP_VERB
//
// MessageText:
//
// Temporary redirect (307).
//


//
// MessageId: HTTP_E_STATUS_BAD_REQUEST
//
// MessageText:
//
// Bad request (400).
//


//
// MessageId: HTTP_E_STATUS_DENIED
//
// MessageText:
//
// Unauthorized (401).
//


//
// MessageId: HTTP_E_STATUS_PAYMENT_REQ
//
// MessageText:
//
// Payment required (402).
//


//
// MessageId: HTTP_E_STATUS_FORBIDDEN
//
// MessageText:
//
// Forbidden (403).
//


//
// MessageId: HTTP_E_STATUS_NOT_FOUND
//
// MessageText:
//
// Not found (404).
//


//
// MessageId: HTTP_E_STATUS_BAD_METHOD
//
// MessageText:
//
// Method not allowed (405).
//


//
// MessageId: HTTP_E_STATUS_NONE_ACCEPTABLE
//
// MessageText:
//
// Not acceptable (406).
//


//
// MessageId: HTTP_E_STATUS_PROXY_AUTH_REQ
//
// MessageText:
//
// Proxy authentication required (407).
//


//
// MessageId: HTTP_E_STATUS_REQUEST_TIMEOUT
//
// MessageText:
//
// Request timeout (408).
//


//
// MessageId: HTTP_E_STATUS_CONFLICT
//
// MessageText:
//
// Conflict (409).
//


//
// MessageId: HTTP_E_STATUS_GONE
//
// MessageText:
//
// Gone (410).
//


//
// MessageId: HTTP_E_STATUS_LENGTH_REQUIRED
//
// MessageText:
//
// Length required (411).
//


//
// MessageId: HTTP_E_STATUS_PRECOND_FAILED
//
// MessageText:
//
// Precondition failed (412).
//


//
// MessageId: HTTP_E_STATUS_REQUEST_TOO_LARGE
//
// MessageText:
//
// Request entity too large (413).
//


//
// MessageId: HTTP_E_STATUS_URI_TOO_LONG
//
// MessageText:
//
// Request-URI too long (414).
//


//
// MessageId: HTTP_E_STATUS_UNSUPPORTED_MEDIA
//
// MessageText:
//
// Unsupported media type (415).
//


//
// MessageId: HTTP_E_STATUS_RANGE_NOT_SATISFIABLE
//
// MessageText:
//
// Requested range not satisfiable (416).
//


//
// MessageId: HTTP_E_STATUS_EXPECTATION_FAILED
//
// MessageText:
//
// Expectation failed (417).
//


//
// MessageId: HTTP_E_STATUS_SERVER_ERROR
//
// MessageText:
//
// Internal server error (500).
//


//
// MessageId: HTTP_E_STATUS_NOT_SUPPORTED
//
// MessageText:
//
// Not implemented (501).
//


//
// MessageId: HTTP_E_STATUS_BAD_GATEWAY
//
// MessageText:
//
// Bad gateway (502).
//


//
// MessageId: HTTP_E_STATUS_SERVICE_UNAVAIL
//
// MessageText:
//
// Service unavailable (503).
//


//
// MessageId: HTTP_E_STATUS_GATEWAY_TIMEOUT
//
// MessageText:
//
// Gateway timeout (504).
//


//
// MessageId: HTTP_E_STATUS_VERSION_NOT_SUP
//
// MessageText:
//
// Version not supported (505).
//



//
// WebSocket
//

//
// MessageId: E_INVALID_PROTOCOL_OPERATION
//
// MessageText:
//
// Invalid operation performed by the protocol.
//


//
// MessageId: E_INVALID_PROTOCOL_FORMAT
//
// MessageText:
//
// Invalid data format for the specific protocol operation.
//


//
// MessageId: E_PROTOCOL_EXTENSIONS_NOT_SUPPORTED
//
// MessageText:
//
// Protocol extensions are not supported.
//


//
// MessageId: E_SUBPROTOCOL_NOT_SUPPORTED
//
// MessageText:
//
// Subprotocol is not supported.
//


//
// MessageId: E_PROTOCOL_VERSION_NOT_SUPPORTED
//
// MessageText:
//
// Incorrect protocol version.
//



//
// Touch and Pen Input Platform Error Codes
//

//
// MessageId: INPUT_E_OUT_OF_ORDER
//
// MessageText:
//
// Input data cannot be processed in the non-chronological order.
//


//
// MessageId: INPUT_E_REENTRANCY
//
// MessageText:
//
// Requested operation cannot be performed inside the callback or event handler.
//


//
// MessageId: INPUT_E_MULTIMODAL
//
// MessageText:
//
// Input cannot be processed because there is ongoing interaction with another pointer type.
//


//
// MessageId: INPUT_E_PACKET
//
// MessageText:
//
// One or more fields in the input packet are invalid.
//


//
// MessageId: INPUT_E_FRAME
//
// MessageText:
//
// Packets in the frame are inconsistent. Either pointer ids are not unique or there is a discrepancy in timestamps, frame ids, pointer types or source devices.
//


//
// MessageId: INPUT_E_HISTORY
//
// MessageText:
//
// The history of frames is inconsistent. Pointer ids, types, source devices don't match, or frame ids are not unique, or timestamps are out of order.
//


//
// MessageId: INPUT_E_DEVICE_INFO
//
// MessageText:
//
// Failed to retrieve information about the input device.
//


//
// MessageId: INPUT_E_TRANSFORM
//
// MessageText:
//
// Coordinate system transformation failed to transform the data.
//


//
// MessageId: INPUT_E_DEVICE_PROPERTY
//
// MessageText:
//
// The property is not supported or not reported correctly by the input device.
//


//
// Internet
//
//
// MessageId: INET_E_INVALID_URL
//
// MessageText:
//
// The URL is invalid.
//


//
// MessageId: INET_E_NO_SESSION
//
// MessageText:
//
// No Internet session has been established.
//


//
// MessageId: INET_E_CANNOT_CONNECT
//
// MessageText:
//
// Unable to connect to the target server.
//


//
// MessageId: INET_E_RESOURCE_NOT_FOUND
//
// MessageText:
//
// The system cannot locate the resource specified.
//


//
// MessageId: INET_E_OBJECT_NOT_FOUND
//
// MessageText:
//
// The system cannot locate the object specified.
//


//
// MessageId: INET_E_DATA_NOT_AVAILABLE
//
// MessageText:
//
// No data is available for the requested resource.
//


//
// MessageId: INET_E_DOWNLOAD_FAILURE
//
// MessageText:
//
// The download of the specified resource has failed.
//


//
// MessageId: INET_E_AUTHENTICATION_REQUIRED
//
// MessageText:
//
// Authentication is required to access this resource.
//


//
// MessageId: INET_E_NO_VALID_MEDIA
//
// MessageText:
//
// The server could not recognize the provided mime type.
//


//
// MessageId: INET_E_CONNECTION_TIMEOUT
//
// MessageText:
//
// The operation was timed out.
//


//
// MessageId: INET_E_INVALID_REQUEST
//
// MessageText:
//
// The server did not understand the request, or the request was invalid.
//


//
// MessageId: INET_E_UNKNOWN_PROTOCOL
//
// MessageText:
//
// The specified protocol is unknown.
//


//
// MessageId: INET_E_SECURITY_PROBLEM
//
// MessageText:
//
// A security problem occurred.
//


//
// MessageId: INET_E_CANNOT_LOAD_DATA
//
// MessageText:
//
// The system could not load the persisted data.
//


//
// MessageId: INET_E_CANNOT_INSTANTIATE_OBJECT
//
// MessageText:
//
// Unable to instantiate the object.
//


//
// MessageId: INET_E_INVALID_CERTIFICATE
//
// MessageText:
//
// Security certificate required to access this resource is invalid.
//


//
// MessageId: INET_E_REDIRECT_FAILED
//
// MessageText:
//
// A redirection problem occurred.
//


//
// MessageId: INET_E_REDIRECT_TO_DIR
//
// MessageText:
//
// The requested resource is a directory, not a file.
//


//
// Debuggers
//
//
// MessageId: ERROR_DBG_CREATE_PROCESS_FAILURE_LOCKDOWN
//
// MessageText:
//
// Could not create new process from ARM architecture device.
//


//
// MessageId: ERROR_DBG_ATTACH_PROCESS_FAILURE_LOCKDOWN
//
// MessageText:
//
// Could not attach to the application process from ARM architecture device.
//


//
// MessageId: ERROR_DBG_CONNECT_SERVER_FAILURE_LOCKDOWN
//
// MessageText:
//
// Could not connect to dbgsrv server from ARM architecture device.
//


//
// MessageId: ERROR_DBG_START_SERVER_FAILURE_LOCKDOWN
//
// MessageText:
//
// Could not start dbgsrv server from ARM architecture device.
//


//
//Sdbus
//
//
// MessageId: ERROR_IO_PREEMPTED
//
// MessageText:
//
// The operation was preempted by a higher priority operation. It must be resumed later.
//


//
//JScript
//
//
// MessageId: JSCRIPT_E_CANTEXECUTE
//
// MessageText:
//
// Function could not execute because it was deleted or garbage collected.
//


//
//WEP - Windows Encryption Providers
//
//
// MessageId: WEP_E_NOT_PROVISIONED_ON_ALL_VOLUMES
//
// MessageText:
//
// One or more fixed volumes are not provisioned with the 3rd party encryption providers to support device encryption. Enable encryption with the 3rd party provider to comply with policy.
//


//
// MessageId: WEP_E_FIXED_DATA_NOT_SUPPORTED
//
// MessageText:
//
// This computer is not fully encrypted. There are fixed volumes present which are not supported for encryption.
//


//
// MessageId: WEP_E_HARDWARE_NOT_COMPLIANT
//
// MessageText:
//
// This computer does not meet the hardware requirements to support device encryption with the installed 3rd party provider.
//


//
//device lock feature - requires encryption software to use something like a TPM or a secure location to store failed counts of the password in an interactive logon to lock out the device
//
//
// MessageId: WEP_E_LOCK_NOT_CONFIGURED
//
// MessageText:
//
// This computer cannot support device encryption because the requisites for the device lock feature are not configured.
//


//
// MessageId: WEP_E_PROTECTION_SUSPENDED
//
// MessageText:
//
// Protection is enabled on this volume but is not in the active state.
//


//
// MessageId: WEP_E_NO_LICENSE
//
// MessageText:
//
// The 3rd party provider has been installed, but cannot activate encryption because a license has not been activated.
//


//
// MessageId: WEP_E_OS_NOT_PROTECTED
//
// MessageText:
//
// The operating system drive is not protected by 3rd party drive encryption.
//


//
// MessageId: WEP_E_UNEXPECTED_FAIL
//
// MessageText:
//
// Unexpected failure was encountered while calling into the 3rd Party drive encryption plugin.
//


//
// MessageId: WEP_E_BUFFER_TOO_LARGE
//
// MessageText:
//
// The input buffer size for the lockout metadata used by the 3rd party drive encryption is too large.
//


//
// Shared VHDX status codes (svhdxflt.sys)
//
//
// MessageId: ERROR_SVHDX_ERROR_STORED
//
// MessageText:
//
// The proper error code with sense data was stored on server side.
//


//
// MessageId: ERROR_SVHDX_ERROR_NOT_AVAILABLE
//
// MessageText:
//
// The requested error data is not available on the server.
//


//
// MessageId: ERROR_SVHDX_UNIT_ATTENTION_AVAILABLE
//
// MessageText:
//
// Unit Attention data is available for the initiator to query.
//


//
// MessageId: ERROR_SVHDX_UNIT_ATTENTION_CAPACITY_DATA_CHANGED
//
// MessageText:
//
// The data capacity of the device has changed, resulting in a Unit Attention condition.
//


//
// MessageId: ERROR_SVHDX_UNIT_ATTENTION_RESERVATIONS_PREEMPTED
//
// MessageText:
//
// A previous operation resulted in this initiator's reservations being preempted, resulting in a Unit Attention condition.
//


//
// MessageId: ERROR_SVHDX_UNIT_ATTENTION_RESERVATIONS_RELEASED
//
// MessageText:
//
// A previous operation resulted in this initiator's reservations being released, resulting in a Unit Attention condition.
//


//
// MessageId: ERROR_SVHDX_UNIT_ATTENTION_REGISTRATIONS_PREEMPTED
//
// MessageText:
//
// A previous operation resulted in this initiator's registrations being preempted, resulting in a Unit Attention condition.
//


//
// MessageId: ERROR_SVHDX_UNIT_ATTENTION_OPERATING_DEFINITION_CHANGED
//
// MessageText:
//
// The data storage format of the device has changed, resulting in a Unit Attention condition.
//


//
// MessageId: ERROR_SVHDX_RESERVATION_CONFLICT
//
// MessageText:
//
// The current initiator is not allowed to perform the SCSI command because of a reservation conflict.
//


//
// MessageId: ERROR_SVHDX_WRONG_FILE_TYPE
//
// MessageText:
//
// Multiple virtual machines sharing a virtual hard disk is supported only on Fixed or Dynamic VHDX format virtual hard disks.
//


//
// MessageId: ERROR_SVHDX_VERSION_MISMATCH
//
// MessageText:
//
// The server version does not match the requested version.
//


//
// MessageId: ERROR_VHD_SHARED
//
// MessageText:
//
// The requested operation cannot be performed on the virtual disk as it is currently used in shared mode.
//


//
// MessageId: ERROR_SVHDX_NO_INITIATOR
//
// MessageText:
//
// Invalid Shared VHDX open due to lack of initiator ID. Check for related Continuous Availability failures.
//


//
// MessageId: ERROR_VHDSET_BACKING_STORAGE_NOT_FOUND
//
// MessageText:
//
// The requested operation failed due to a missing backing storage file.
//


//
// SMB status codes
//
//
// MessageId: ERROR_SMB_NO_PREAUTH_INTEGRITY_HASH_OVERLAP
//
// MessageText:
//
// Failed to negotiate a preauthentication integrity hash function.
//


//
// MessageId: ERROR_SMB_BAD_CLUSTER_DIALECT
//
// MessageText:
//
// The current cluster functional level does not support this SMB dialect.
//


//
// WININET.DLL errors - propagated as HRESULT's using FACILITY=WIN32
//
//
// MessageId: WININET_E_OUT_OF_HANDLES
//
// MessageText:
//
// No more Internet handles can be allocated
//


//
// MessageId: WININET_E_TIMEOUT
//
// MessageText:
//
// The operation timed out
//


//
// MessageId: WININET_E_EXTENDED_ERROR
//
// MessageText:
//
// The server returned extended information
//


//
// MessageId: WININET_E_INTERNAL_ERROR
//
// MessageText:
//
// An internal error occurred in the Microsoft Internet extensions
//


//
// MessageId: WININET_E_INVALID_URL
//
// MessageText:
//
// The URL is invalid
//


//
// MessageId: WININET_E_UNRECOGNIZED_SCHEME
//
// MessageText:
//
// The URL does not use a recognized protocol
//


//
// MessageId: WININET_E_NAME_NOT_RESOLVED
//
// MessageText:
//
// The server name or address could not be resolved
//


//
// MessageId: WININET_E_PROTOCOL_NOT_FOUND
//
// MessageText:
//
// A protocol with the required capabilities was not found
//


//
// MessageId: WININET_E_INVALID_OPTION
//
// MessageText:
//
// The option is invalid
//


//
// MessageId: WININET_E_BAD_OPTION_LENGTH
//
// MessageText:
//
// The length is incorrect for the option type
//


//
// MessageId: WININET_E_OPTION_NOT_SETTABLE
//
// MessageText:
//
// The option value cannot be set
//


//
// MessageId: WININET_E_SHUTDOWN
//
// MessageText:
//
// Microsoft Internet Extension support has been shut down
//


//
// MessageId: WININET_E_INCORRECT_USER_NAME
//
// MessageText:
//
// The user name was not allowed
//


//
// MessageId: WININET_E_INCORRECT_PASSWORD
//
// MessageText:
//
// The password was not allowed
//


//
// MessageId: WININET_E_LOGIN_FAILURE
//
// MessageText:
//
// The login request was denied
//


//
// MessageId: WININET_E_INVALID_OPERATION
//
// MessageText:
//
// The requested operation is invalid
//


//
// MessageId: WININET_E_OPERATION_CANCELLED
//
// MessageText:
//
// The operation has been canceled
//


//
// MessageId: WININET_E_INCORRECT_HANDLE_TYPE
//
// MessageText:
//
// The supplied handle is the wrong type for the requested operation
//


//
// MessageId: WININET_E_INCORRECT_HANDLE_STATE
//
// MessageText:
//
// The handle is in the wrong state for the requested operation
//


//
// MessageId: WININET_E_NOT_PROXY_REQUEST
//
// MessageText:
//
// The request cannot be made on a Proxy session
//


//
// MessageId: WININET_E_REGISTRY_VALUE_NOT_FOUND
//
// MessageText:
//
// The registry value could not be found
//


//
// MessageId: WININET_E_BAD_REGISTRY_PARAMETER
//
// MessageText:
//
// The registry parameter is incorrect
//


//
// MessageId: WININET_E_NO_DIRECT_ACCESS
//
// MessageText:
//
// Direct Internet access is not available
//


//
// MessageId: WININET_E_NO_CONTEXT
//
// MessageText:
//
// No context value was supplied
//


//
// MessageId: WININET_E_NO_CALLBACK
//
// MessageText:
//
// No status callback was supplied
//


//
// MessageId: WININET_E_REQUEST_PENDING
//
// MessageText:
//
// There are outstanding requests
//


//
// MessageId: WININET_E_INCORRECT_FORMAT
//
// MessageText:
//
// The information format is incorrect
//


//
// MessageId: WININET_E_ITEM_NOT_FOUND
//
// MessageText:
//
// The requested item could not be found
//


//
// MessageId: WININET_E_CANNOT_CONNECT
//
// MessageText:
//
// A connection with the server could not be established
//


//
// MessageId: WININET_E_CONNECTION_ABORTED
//
// MessageText:
//
// The connection with the server was terminated abnormally
//


//
// MessageId: WININET_E_CONNECTION_RESET
//
// MessageText:
//
// The connection with the server was reset
//


//
// MessageId: WININET_E_FORCE_RETRY
//
// MessageText:
//
// The action must be retried
//


//
// MessageId: WININET_E_INVALID_PROXY_REQUEST
//
// MessageText:
//
// The proxy request is invalid
//


//
// MessageId: WININET_E_NEED_UI
//
// MessageText:
//
// User interaction is required to complete the operation
//


//
// MessageId: WININET_E_HANDLE_EXISTS
//
// MessageText:
//
// The handle already exists
//


//
// MessageId: WININET_E_SEC_CERT_DATE_INVALID
//
// MessageText:
//
// The date in the certificate is invalid or has expired
//


//
// MessageId: WININET_E_SEC_CERT_CN_INVALID
//
// MessageText:
//
// The host name in the certificate is invalid or does not match
//


//
// MessageId: WININET_E_HTTP_TO_HTTPS_ON_REDIR
//
// MessageText:
//
// A redirect request will change a non-secure to a secure connection
//


//
// MessageId: WININET_E_HTTPS_TO_HTTP_ON_REDIR
//
// MessageText:
//
// A redirect request will change a secure to a non-secure connection
//


//
// MessageId: WININET_E_MIXED_SECURITY
//
// MessageText:
//
// Mixed secure and non-secure connections
//


//
// MessageId: WININET_E_CHG_POST_IS_NON_SECURE
//
// MessageText:
//
// Changing to non-secure post
//


//
// MessageId: WININET_E_POST_IS_NON_SECURE
//
// MessageText:
//
// Data is being posted on a non-secure connection
//


//
// MessageId: WININET_E_CLIENT_AUTH_CERT_NEEDED
//
// MessageText:
//
// A certificate is required to complete client authentication
//


//
// MessageId: WININET_E_INVALID_CA
//
// MessageText:
//
// The certificate authority is invalid or incorrect
//


//
// MessageId: WININET_E_CLIENT_AUTH_NOT_SETUP
//
// MessageText:
//
// Client authentication has not been correctly installed
//


//
// MessageId: WININET_E_ASYNC_THREAD_FAILED
//
// MessageText:
//
// An error has occurred in a Wininet asynchronous thread. You may need to restart
//


//
// MessageId: WININET_E_REDIRECT_SCHEME_CHANGE
//
// MessageText:
//
// The protocol scheme has changed during a redirect operation
//


//
// MessageId: WININET_E_DIALOG_PENDING
//
// MessageText:
//
// There are operations awaiting retry
//


//
// MessageId: WININET_E_RETRY_DIALOG
//
// MessageText:
//
// The operation must be retried
//


//
// MessageId: WININET_E_NO_NEW_CONTAINERS
//
// MessageText:
//
// There are no new cache containers
//


//
// MessageId: WININET_E_HTTPS_HTTP_SUBMIT_REDIR
//
// MessageText:
//
// A security zone check indicates the operation must be retried
//


//
// MessageId: WININET_E_SEC_CERT_ERRORS
//
// MessageText:
//
// The SSL certificate contains errors.
//


//
// MessageId: WININET_E_SEC_CERT_REV_FAILED
//
// MessageText:
//
// It was not possible to connect to the revocation server or a definitive response could not be obtained.
//


//
// MessageId: WININET_E_HEADER_NOT_FOUND
//
// MessageText:
//
// The requested header was not found
//


//
// MessageId: WININET_E_DOWNLEVEL_SERVER
//
// MessageText:
//
// The server does not support the requested protocol level
//


//
// MessageId: WININET_E_INVALID_SERVER_RESPONSE
//
// MessageText:
//
// The server returned an invalid or unrecognized response
//


//
// MessageId: WININET_E_INVALID_HEADER
//
// MessageText:
//
// The supplied HTTP header is invalid
//


//
// MessageId: WININET_E_INVALID_QUERY_REQUEST
//
// MessageText:
//
// The request for a HTTP header is invalid
//


//
// MessageId: WININET_E_HEADER_ALREADY_EXISTS
//
// MessageText:
//
// The HTTP header already exists
//


//
// MessageId: WININET_E_REDIRECT_FAILED
//
// MessageText:
//
// The HTTP redirect request failed
//


//
// MessageId: WININET_E_SECURITY_CHANNEL_ERROR
//
// MessageText:
//
// An error occurred in the secure channel support
//


//
// MessageId: WININET_E_UNABLE_TO_CACHE_FILE
//
// MessageText:
//
// The file could not be written to the cache
//


//
// MessageId: WININET_E_TCPIP_NOT_INSTALLED
//
// MessageText:
//
// The TCP/IP protocol is not installed properly
//


//
// MessageId: WININET_E_DISCONNECTED
//
// MessageText:
//
// The computer is disconnected from the network
//


//
// MessageId: WININET_E_SERVER_UNREACHABLE
//
// MessageText:
//
// The server is unreachable
//


//
// MessageId: WININET_E_PROXY_SERVER_UNREACHABLE
//
// MessageText:
//
// The proxy server is unreachable
//


//
// MessageId: WININET_E_BAD_AUTO_PROXY_SCRIPT
//
// MessageText:
//
// The proxy auto-configuration script is in error
//


//
// MessageId: WININET_E_UNABLE_TO_DOWNLOAD_SCRIPT
//
// MessageText:
//
// Could not download the proxy auto-configuration script file
//


//
// MessageId: WININET_E_SEC_INVALID_CERT
//
// MessageText:
//
// The supplied certificate is invalid
//


//
// MessageId: WININET_E_SEC_CERT_REVOKED
//
// MessageText:
//
// The supplied certificate has been revoked
//


//
// MessageId: WININET_E_FAILED_DUETOSECURITYCHECK
//
// MessageText:
//
// The Dialup failed because file sharing was turned on and a failure was requested if security check was needed
//


//
// MessageId: WININET_E_NOT_INITIALIZED
//
// MessageText:
//
// Initialization of the WinINet API has not occurred
//


//
// MessageId: WININET_E_LOGIN_FAILURE_DISPLAY_ENTITY_BODY
//
// MessageText:
//
// Login failed and the client should display the entity body to the user
//


//
// MessageId: WININET_E_DECODING_FAILED
//
// MessageText:
//
// Content decoding has failed
//


//
// MessageId: WININET_E_NOT_REDIRECTED
//
// MessageText:
//
// The HTTP request was not redirected
//


//
// MessageId: WININET_E_COOKIE_NEEDS_CONFIRMATION
//
// MessageText:
//
// A cookie from the server must be confirmed by the user
//


//
// MessageId: WININET_E_COOKIE_DECLINED
//
// MessageText:
//
// A cookie from the server has been declined acceptance
//


//
// MessageId: WININET_E_REDIRECT_NEEDS_CONFIRMATION
//
// MessageText:
//
// The HTTP redirect request must be confirmed by the user
//



//
// SQLite
//

//
// MessageId: SQLITE_E_ERROR
//
// MessageText:
//
// SQL error or missing database
//


//
// MessageId: SQLITE_E_INTERNAL
//
// MessageText:
//
// Internal logic error in SQLite
//


//
// MessageId: SQLITE_E_PERM
//
// MessageText:
//
// Access permission denied
//


//
// MessageId: SQLITE_E_ABORT
//
// MessageText:
//
// Callback routine requested an abort
//


//
// MessageId: SQLITE_E_BUSY
//
// MessageText:
//
// The database file is locked
//


//
// MessageId: SQLITE_E_LOCKED
//
// MessageText:
//
// A table in the database is locked
//


//
// MessageId: SQLITE_E_NOMEM
//
// MessageText:
//
// A malloc() failed
//


//
// MessageId: SQLITE_E_READONLY
//
// MessageText:
//
// Attempt to write a readonly database
//


//
// MessageId: SQLITE_E_INTERRUPT
//
// MessageText:
//
// Operation terminated by sqlite3_interrupt()
//


//
// MessageId: SQLITE_E_IOERR
//
// MessageText:
//
// Some kind of disk I/O error occurred
//


//
// MessageId: SQLITE_E_CORRUPT
//
// MessageText:
//
// The database disk image is malformed
//


//
// MessageId: SQLITE_E_NOTFOUND
//
// MessageText:
//
// Unknown opcode in sqlite3_file_control()
//


//
// MessageId: SQLITE_E_FULL
//
// MessageText:
//
// Insertion failed because database is full
//


//
// MessageId: SQLITE_E_CANTOPEN
//
// MessageText:
//
// Unable to open the database file
//


//
// MessageId: SQLITE_E_PROTOCOL
//
// MessageText:
//
// Database lock protocol error
//


//
// MessageId: SQLITE_E_EMPTY
//
// MessageText:
//
// Database is empty
//


//
// MessageId: SQLITE_E_SCHEMA
//
// MessageText:
//
// The database schema changed
//


//
// MessageId: SQLITE_E_TOOBIG
//
// MessageText:
//
// String or BLOB exceeds size limit
//


//
// MessageId: SQLITE_E_CONSTRAINT
//
// MessageText:
//
// Abort due to constraint violation
//


//
// MessageId: SQLITE_E_MISMATCH
//
// MessageText:
//
// Data type mismatch
//


//
// MessageId: SQLITE_E_MISUSE
//
// MessageText:
//
// Library used incorrectly
//


//
// MessageId: SQLITE_E_NOLFS
//
// MessageText:
//
// Uses OS features not supported on host
//


//
// MessageId: SQLITE_E_AUTH
//
// MessageText:
//
// Authorization denied
//


//
// MessageId: SQLITE_E_FORMAT
//
// MessageText:
//
// Auxiliary database format error
//


//
// MessageId: SQLITE_E_RANGE
//
// MessageText:
//
// 2nd parameter to sqlite3_bind out of range
//


//
// MessageId: SQLITE_E_NOTADB
//
// MessageText:
//
// File opened that is not a database file
//


//
// MessageId: SQLITE_E_NOTICE
//
// MessageText:
//
// Notifications from sqlite3_log()
//


//
// MessageId: SQLITE_E_WARNING
//
// MessageText:
//
// Warnings from sqlite3_log()
//


//
// MessageId: SQLITE_E_ROW
//
// MessageText:
//
// sqlite3_step() has another row ready
//


//
// MessageId: SQLITE_E_DONE
//
// MessageText:
//
// sqlite3_step() has finished executing
//


//
// MessageId: SQLITE_E_IOERR_READ
//
// MessageText:
//
// SQLITE_IOERR_READ
//


//
// MessageId: SQLITE_E_IOERR_SHORT_READ
//
// MessageText:
//
// SQLITE_IOERR_SHORT_READ
//


//
// MessageId: SQLITE_E_IOERR_WRITE
//
// MessageText:
//
// SQLITE_IOERR_WRITE
//


//
// MessageId: SQLITE_E_IOERR_FSYNC
//
// MessageText:
//
// SQLITE_IOERR_FSYNC
//


//
// MessageId: SQLITE_E_IOERR_DIR_FSYNC
//
// MessageText:
//
// SQLITE_IOERR_DIR_FSYNC
//


//
// MessageId: SQLITE_E_IOERR_TRUNCATE
//
// MessageText:
//
// SQLITE_IOERR_TRUNCATE
//


//
// MessageId: SQLITE_E_IOERR_FSTAT
//
// MessageText:
//
// SQLITE_IOERR_FSTAT
//


//
// MessageId: SQLITE_E_IOERR_UNLOCK
//
// MessageText:
//
// SQLITE_IOERR_UNLOCK
//


//
// MessageId: SQLITE_E_IOERR_RDLOCK
//
// MessageText:
//
// SQLITE_IOERR_RDLOCK
//


//
// MessageId: SQLITE_E_IOERR_DELETE
//
// MessageText:
//
// SQLITE_IOERR_DELETE
//


//
// MessageId: SQLITE_E_IOERR_BLOCKED
//
// MessageText:
//
// SQLITE_IOERR_BLOCKED
//


//
// MessageId: SQLITE_E_IOERR_NOMEM
//
// MessageText:
//
// SQLITE_IOERR_NOMEM
//


//
// MessageId: SQLITE_E_IOERR_ACCESS
//
// MessageText:
//
// SQLITE_IOERR_ACCESS
//


//
// MessageId: SQLITE_E_IOERR_CHECKRESERVEDLOCK
//
// MessageText:
//
// SQLITE_IOERR_CHECKRESERVEDLOCK
//


//
// MessageId: SQLITE_E_IOERR_LOCK
//
// MessageText:
//
// SQLITE_IOERR_LOCK
//


//
// MessageId: SQLITE_E_IOERR_CLOSE
//
// MessageText:
//
// SQLITE_IOERR_CLOSE
//


//
// MessageId: SQLITE_E_IOERR_DIR_CLOSE
//
// MessageText:
//
// SQLITE_IOERR_DIR_CLOSE
//


//
// MessageId: SQLITE_E_IOERR_SHMOPEN
//
// MessageText:
//
// SQLITE_IOERR_SHMOPEN
//


//
// MessageId: SQLITE_E_IOERR_SHMSIZE
//
// MessageText:
//
// SQLITE_IOERR_SHMSIZE
//


//
// MessageId: SQLITE_E_IOERR_SHMLOCK
//
// MessageText:
//
// SQLITE_IOERR_SHMLOCK
//


//
// MessageId: SQLITE_E_IOERR_SHMMAP
//
// MessageText:
//
// SQLITE_IOERR_SHMMAP
//


//
// MessageId: SQLITE_E_IOERR_SEEK
//
// MessageText:
//
// SQLITE_IOERR_SEEK
//


//
// MessageId: SQLITE_E_IOERR_DELETE_NOENT
//
// MessageText:
//
// SQLITE_IOERR_DELETE_NOENT
//


//
// MessageId: SQLITE_E_IOERR_MMAP
//
// MessageText:
//
// SQLITE_IOERR_MMAP
//


//
// MessageId: SQLITE_E_IOERR_GETTEMPPATH
//
// MessageText:
//
// SQLITE_IOERR_GETTEMPPATH
//


//
// MessageId: SQLITE_E_IOERR_CONVPATH
//
// MessageText:
//
// SQLITE_IOERR_CONVPATH
//


//
// MessageId: SQLITE_E_IOERR_VNODE
//
// MessageText:
//
// SQLITE_IOERR_VNODE
//


//
// MessageId: SQLITE_E_IOERR_AUTH
//
// MessageText:
//
// SQLITE_IOERR_AUTH
//


//
// MessageId: SQLITE_E_LOCKED_SHAREDCACHE
//
// MessageText:
//
// SQLITE_LOCKED_SHAREDCACHE
//


//
// MessageId: SQLITE_E_BUSY_RECOVERY
//
// MessageText:
//
// SQLITE_BUSY_RECOVERY
//


//
// MessageId: SQLITE_E_BUSY_SNAPSHOT
//
// MessageText:
//
// SQLITE_BUSY_SNAPSHOT
//


//
// MessageId: SQLITE_E_CANTOPEN_NOTEMPDIR
//
// MessageText:
//
// SQLITE_CANTOPEN_NOTEMPDIR
//


//
// MessageId: SQLITE_E_CANTOPEN_ISDIR
//
// MessageText:
//
// SQLITE_CANTOPEN_ISDIR
//


//
// MessageId: SQLITE_E_CANTOPEN_FULLPATH
//
// MessageText:
//
// SQLITE_CANTOPEN_FULLPATH
//


//
// MessageId: SQLITE_E_CANTOPEN_CONVPATH
//
// MessageText:
//
// SQLITE_CANTOPEN_CONVPATH
//


//
// MessageId: SQLITE_E_CORRUPT_VTAB
//
// MessageText:
//
// SQLITE_CORRUPT_VTAB
//


//
// MessageId: SQLITE_E_READONLY_RECOVERY
//
// MessageText:
//
// SQLITE_READONLY_RECOVERY
//


//
// MessageId: SQLITE_E_READONLY_CANTLOCK
//
// MessageText:
//
// SQLITE_READONLY_CANTLOCK
//


//
// MessageId: SQLITE_E_READONLY_ROLLBACK
//
// MessageText:
//
// SQLITE_READONLY_ROLLBACK
//


//
// MessageId: SQLITE_E_READONLY_DBMOVED
//
// MessageText:
//
// SQLITE_READONLY_DBMOVED
//


//
// MessageId: SQLITE_E_ABORT_ROLLBACK
//
// MessageText:
//
// SQLITE_ABORT_ROLLBACK
//


//
// MessageId: SQLITE_E_CONSTRAINT_CHECK
//
// MessageText:
//
// SQLITE_CONSTRAINT_CHECK
//


//
// MessageId: SQLITE_E_CONSTRAINT_COMMITHOOK
//
// MessageText:
//
// SQLITE_CONSTRAINT_COMMITHOOK
//


//
// MessageId: SQLITE_E_CONSTRAINT_FOREIGNKEY
//
// MessageText:
//
// SQLITE_CONSTRAINT_FOREIGNKEY
//


//
// MessageId: SQLITE_E_CONSTRAINT_FUNCTION
//
// MessageText:
//
// SQLITE_CONSTRAINT_FUNCTION
//


//
// MessageId: SQLITE_E_CONSTRAINT_NOTNULL
//
// MessageText:
//
// SQLITE_CONSTRAINT_NOTNULL
//


//
// MessageId: SQLITE_E_CONSTRAINT_PRIMARYKEY
//
// MessageText:
//
// SQLITE_CONSTRAINT_PRIMARYKEY
//


//
// MessageId: SQLITE_E_CONSTRAINT_TRIGGER
//
// MessageText:
//
// SQLITE_CONSTRAINT_TRIGGER
//


//
// MessageId: SQLITE_E_CONSTRAINT_UNIQUE
//
// MessageText:
//
// SQLITE_CONSTRAINT_UNIQUE
//


//
// MessageId: SQLITE_E_CONSTRAINT_VTAB
//
// MessageText:
//
// SQLITE_CONSTRAINT_VTAB
//


//
// MessageId: SQLITE_E_CONSTRAINT_ROWID
//
// MessageText:
//
// SQLITE_CONSTRAINT_ROWID
//


//
// MessageId: SQLITE_E_NOTICE_RECOVER_WAL
//
// MessageText:
//
// SQLITE_NOTICE_RECOVER_WAL
//


//
// MessageId: SQLITE_E_NOTICE_RECOVER_ROLLBACK
//
// MessageText:
//
// SQLITE_NOTICE_RECOVER_ROLLBACK
//


//
// MessageId: SQLITE_E_WARNING_AUTOINDEX
//
// MessageText:
//
// SQLITE_WARNING_AUTOINDEX
//


//
// FACILITY_UTC
//
//
// MessageId: UTC_E_TOGGLE_TRACE_STARTED
//
// MessageText:
//
// Toggle (alternative) trace started
//


//
// MessageId: UTC_E_ALTERNATIVE_TRACE_CANNOT_PREEMPT
//
// MessageText:
//
// Cannot pre-empt running trace: The current trace has a higher priority
//


//
// MessageId: UTC_E_AOT_NOT_RUNNING
//
// MessageText:
//
// The always-on-trace is not running
//


//
// MessageId: UTC_E_SCRIPT_TYPE_INVALID
//
// MessageText:
//
// RunScriptAction contains an invalid script type
//


//
// MessageId: UTC_E_SCENARIODEF_NOT_FOUND
//
// MessageText:
//
// Requested scenario definition cannot be found
//


//
// MessageId: UTC_E_TRACEPROFILE_NOT_FOUND
//
// MessageText:
//
// Requested trace profile cannot be found
//


//
// MessageId: UTC_E_FORWARDER_ALREADY_ENABLED
//
// MessageText:
//
// Trigger forwarder is already enabled
//


//
// MessageId: UTC_E_FORWARDER_ALREADY_DISABLED
//
// MessageText:
//
// Trigger forwarder is already disabled
//


//
// MessageId: UTC_E_EVENTLOG_ENTRY_MALFORMED
//
// MessageText:
//
// Cannot parse EventLog XML: The entry is malformed
//


//
// MessageId: UTC_E_DIAGRULES_SCHEMAVERSION_MISMATCH
//
// MessageText:
//
// <diagrules> node contains a schemaversion which is not compatible with this client
//


//
// MessageId: UTC_E_SCRIPT_TERMINATED
//
// MessageText:
//
// RunScriptAction was forced to terminate a script
//


//
// MessageId: UTC_E_INVALID_CUSTOM_FILTER
//
// MessageText:
//
// ToggleTraceWithCustomFilterAction contains an invalid custom filter
//


//
// MessageId: UTC_E_TRACE_NOT_RUNNING
//
// MessageText:
//
// The trace is not running
//


//
// MessageId: UTC_E_REESCALATED_TOO_QUICKLY
//
// MessageText:
//
// A scenario failed to escalate: This scenario has escalated too recently
//


//
// MessageId: UTC_E_ESCALATION_ALREADY_RUNNING
//
// MessageText:
//
// A scenario failed to escalate: This scenario is already running an escalation
//


//
// MessageId: UTC_E_PERFTRACK_ALREADY_TRACING
//
// MessageText:
//
// Cannot start tracing: PerfTrack component is already tracing
//


//
// MessageId: UTC_E_REACHED_MAX_ESCALATIONS
//
// MessageText:
//
// A scenario failed to escalate: This scenario has reached max escalations for this escalation type
//


//
// MessageId: UTC_E_FORWARDER_PRODUCER_MISMATCH
//
// MessageText:
//
// Cannot update forwarder: The forwarder passed to the function is of a different type
//


//
// MessageId: UTC_E_INTENTIONAL_SCRIPT_FAILURE
//
// MessageText:
//
// RunScriptAction failed intentionally to force this escalation to terminate
//


//
// MessageId: UTC_E_SQM_INIT_FAILED
//
// MessageText:
//
// Failed to initialize SQM logger
//


//
// MessageId: UTC_E_NO_WER_LOGGER_SUPPORTED
//
// MessageText:
//
// Failed to initialize WER logger: This system does not support WER for UTC
//


//
// MessageId: UTC_E_TRACERS_DONT_EXIST
//
// MessageText:
//
// The TraceManager has attempted to take a tracing action without initializing tracers
//


//
// MessageId: UTC_E_WINRT_INIT_FAILED
//
// MessageText:
//
// WinRT initialization failed
//


//
// MessageId: UTC_E_SCENARIODEF_SCHEMAVERSION_MISMATCH
//
// MessageText:
//
// <scenario> node contains a schemaversion that is not compatible with this client
//


//
// MessageId: UTC_E_INVALID_FILTER
//
// MessageText:
//
// Scenario contains an invalid filter that can never be satisfied
//


//
// MessageId: UTC_E_EXE_TERMINATED
//
// MessageText:
//
// RunExeWithArgsAction was forced to terminate a running executable
//


//
// MessageId: UTC_E_ESCALATION_NOT_AUTHORIZED
//
// MessageText:
//
// Escalation for scenario failed due to insufficient permissions
//


//
// MessageId: UTC_E_SETUP_NOT_AUTHORIZED
//
// MessageText:
//
// Setup for scenario failed due to insufficient permissions
//


//
// MessageId: UTC_E_CHILD_PROCESS_FAILED
//
// MessageText:
//
// A process launched by UTC failed with a non-zero exit code.
//


//
// MessageId: UTC_E_COMMAND_LINE_NOT_AUTHORIZED
//
// MessageText:
//
// A RunExeWithArgs action contains an unauthorized command line.
//


//
// MessageId: UTC_E_CANNOT_LOAD_SCENARIO_EDITOR_XML
//
// MessageText:
//
// UTC cannot load Scenario Editor XML. Convert the scenario file to a DiagTrack XML using the editor.
//


//
// MessageId: UTC_E_ESCALATION_TIMED_OUT
//
// MessageText:
//
// Escalation for scenario has timed out
//


//
// MessageId: UTC_E_SETUP_TIMED_OUT
//
// MessageText:
//
// Setup for scenario has timed out
//


//
// MessageId: UTC_E_TRIGGER_MISMATCH
//
// MessageText:
//
// The given trigger does not match the expected trigger type
//


//
// MessageId: UTC_E_TRIGGER_NOT_FOUND
//
// MessageText:
//
// Requested trigger cannot be found
//


//
// MessageId: UTC_E_SIF_NOT_SUPPORTED
//
// MessageText:
//
// SIF is not supported on the machine
//


//
// MessageId: UTC_E_DELAY_TERMINATED
//
// MessageText:
//
// The delay action was terminated
//


//
// MessageId: UTC_E_DEVICE_TICKET_ERROR
//
// MessageText:
//
// The device ticket was not obtained
//


//
// MessageId: UTC_E_TRACE_BUFFER_LIMIT_EXCEEDED
//
// MessageText:
//
// The trace profile needs more memory than is available for tracing
//


//
// MessageId: UTC_E_API_RESULT_UNAVAILABLE
//
// MessageText:
//
// The API was not completed successfully so the result is unavailable
//


//
// MessageId: UTC_E_RPC_TIMEOUT
//
// MessageText:
//
// The requested API encountered a timeout in the API manager
//


//
// MessageId: UTC_E_RPC_WAIT_FAILED
//
// MessageText:
//
// The synchronous API encountered a wait failure
//


//
// MessageId: UTC_E_API_BUSY
//
// MessageText:
//
// The UTC API is busy with another request
//


//
// MessageId: UTC_E_TRACE_MIN_DURATION_REQUIREMENT_NOT_MET
//
// MessageText:
//
// The running trace profile does not have a sufficient runtime to fulfill the escalation request
//


//
// MessageId: UTC_E_EXCLUSIVITY_NOT_AVAILABLE
//
// MessageText:
//
// The trace profile could not be started because it requires exclusivity and another higher priority trace is already running
//


//
// MessageId: UTC_E_GETFILE_FILE_PATH_NOT_APPROVED
//
// MessageText:
//
// The file path is not approved for the GetFile escalation action
//


//
// MessageId: UTC_E_ESCALATION_DIRECTORY_ALREADY_EXISTS
//
// MessageText:
//
// The escalation working directory for the requested escalation could not be created because it already exists
//


//
// MessageId: UTC_E_TIME_TRIGGER_ON_START_INVALID
//
// MessageText:
//
// Time triggers cannot be used on a transition originating from the "_start" state
//


//
// MessageId: UTC_E_TIME_TRIGGER_ONLY_VALID_ON_SINGLE_TRANSITION
//
// MessageText:
//
// Time triggers can only be attached to a single transition
//


//
// MessageId: UTC_E_TIME_TRIGGER_INVALID_TIME_RANGE
//
// MessageText:
//
// Time trigger duration must fall within an inclusive range of one second and 15 minutes
//


//
// MessageId: UTC_E_MULTIPLE_TIME_TRIGGER_ON_SINGLE_STATE
//
// MessageText:
//
// Only one Time Trigger is allowed per state
//


//
// MessageId: UTC_E_BINARY_MISSING
//
// MessageText:
//
// A RunExeWithArgs action contains a binary which is not present on the targeted device.
//


//
// MessageId: UTC_E_NETWORK_CAPTURE_NOT_ALLOWED
//
// MessageText:
//
// A network capture trace is not allowed.
//


//
// MessageId: UTC_E_FAILED_TO_RESOLVE_CONTAINER_ID
//
// MessageText:
//
// UTC failed to identify the container id to use for a scenario escalation action.
//


//
// MessageId: UTC_E_UNABLE_TO_RESOLVE_SESSION
//
// MessageText:
//
// Failed to resolve session ID during API invocation.
//


//
// MessageId: UTC_E_THROTTLED
//
// MessageText:
//
// UTC has throttled the event for firing too often.
//


//
// MessageId: UTC_E_UNAPPROVED_SCRIPT
//
// MessageText:
//
// The script is not approved to run as part of DiagTrack scenario.
//


//
// MessageId: UTC_E_SCRIPT_MISSING
//
// MessageText:
//
// The script referenced in DiagTrack scenario is not present on the system.
//


//
// MessageId: UTC_E_SCENARIO_THROTTLED
//
// MessageText:
//
// A trigger in this scenario is throttled, blocking the scenario from being loaded.
//


//
// MessageId: UTC_E_API_NOT_SUPPORTED
//
// MessageText:
//
// The requested UTC API call is not supported on this device.
//


//
// MessageId: UTC_E_GETFILE_EXTERNAL_PATH_NOT_APPROVED
//
// MessageText:
//
// The file path is not approved for collection on external rings for the GetFile escalation action.
//


//
// MessageId: UTC_E_TRY_GET_SCENARIO_TIMEOUT_EXCEEDED
//
// MessageText:
//
// Querying a scenario definition exceeded the specified maximum timeout.
//


//
// MessageId: UTC_E_CERT_REV_FAILED
//
// MessageText:
//
// Certification revocation checking has been enabled, but the revocation check failed to verify whether a certificate has been revoked. The server used to check for revocation might be unreachable.
//


//
// MessageId: UTC_E_FAILED_TO_START_NDISCAP
//
// MessageText:
//
// Failed to start NDISCAP service for network packet capture trace.
//


//
// MessageId: UTC_E_KERNELDUMP_LIMIT_REACHED
//
// MessageText:
//
// UTC can perform no more than one KernelDump action on a device every 24 hours.
//


//
// MessageId: UTC_E_MISSING_AGGREGATE_EVENT_TAG
//
// MessageText:
//
// The event contained an aggregation or differential privacy structure, but did not specify MICROSOFT_EVENTTAG_AGGREGATE.
//


//
// MessageId: UTC_E_INVALID_AGGREGATION_STRUCT
//
// MessageText:
//
// The event contained an invalid aggregation or differential privacy structure.
//


//
// MessageId: UTC_E_ACTION_NOT_SUPPORTED_IN_DESTINATION
//
// MessageText:
//
// The action cannot be completed in the specified destination.
//


//
// MessageId: UTC_E_FILTER_MISSING_ATTRIBUTE
//
// MessageText:
//
// Filter command is missing a required attribute.
//


//
// MessageId: UTC_E_FILTER_INVALID_TYPE
//
// MessageText:
//
// Filter command contains an unsupported type.
//


//
// MessageId: UTC_E_FILTER_VARIABLE_NOT_FOUND
//
// MessageText:
//
// Filter variable does not exist at point of evaluation.
//


//
// MessageId: UTC_E_FILTER_FUNCTION_RESTRICTED
//
// MessageText:
//
// Filter command is not allowed in the current context.
//


//
// MessageId: UTC_E_FILTER_VERSION_MISMATCH
//
// MessageText:
//
// Requested filter version is incompatible with available version.
//


//
// MessageId: UTC_E_FILTER_INVALID_FUNCTION
//
// MessageText:
//
// Filter does not support this function.
//


//
// MessageId: UTC_E_FILTER_INVALID_FUNCTION_PARAMS
//
// MessageText:
//
// Filter function does not accept the provided parameter types and/or count.
//


//
// MessageId: UTC_E_FILTER_INVALID_COMMAND
//
// MessageText:
//
// Filter command does not exist or is incorrectly formatted.
//


//
// MessageId: UTC_E_FILTER_ILLEGAL_EVAL
//
// MessageText:
//
// Filter types can not be compared to each other.
//


//
// MessageId: UTC_E_TTTRACER_RETURNED_ERROR
//
// MessageText:
//
// TTTracer executable returned a code other than ERROR_SUCCESS.
//


//
// MessageId: UTC_E_AGENT_DIAGNOSTICS_TOO_LARGE
//
// MessageText:
//
// The total size of the compressed escalation data payload exceeded the allowable limit.
//


//
// MessageId: UTC_E_FAILED_TO_RECEIVE_AGENT_DIAGNOSTICS
//
// MessageText:
//
// Escalation data was not completely transferred from agent to host.
//


//
// MessageId: UTC_E_SCENARIO_HAS_NO_ACTIONS
//
// MessageText:
//
// An escalation was requested for a scenario which has no actions for the passed type.
//


//
// MessageId: UTC_E_TTTRACER_STORAGE_FULL
//
// MessageText:
//
// UTC allocated space for TTTracer escalations is full.
//


//
// MessageId: UTC_E_INSUFFICIENT_SPACE_TO_START_TRACE
//
// MessageText:
//
// Disk needs minimum of 15GB to start TTD recording session.
//


//
// MessageId: UTC_E_ESCALATION_CANCELLED_AT_SHUTDOWN
//
// MessageText:
//
// Escalation was cancelled due to component shutdown.
//


//
// MessageId: UTC_E_GETFILEINFOACTION_FILE_NOT_APPROVED
//
// MessageText:
//
// The file for the GetFileInfo action must be under the \Windows, \Program Files, or \Program Files (x86) directories.
//


//
// MessageId: UTC_E_SETREGKEYACTION_TYPE_NOT_APPROVED
//
// MessageText:
//
// The registry value type for SetRegKey action must be REG_SZ, REG_MULTI_SZ, REG_EXPAND_SZ, REG_BINARY, REG_DWORD, or REG_QWORD.
//



//
// WinML
//

//
// MessageId: WINML_ERR_INVALID_DEVICE
//
// MessageText:
//
// The device is invalid or does not support machine learning.
//


//
// MessageId: WINML_ERR_INVALID_BINDING
//
// MessageText:
//
// The binding is incomplete or does not match the input/output description.
//


//
// MessageId: WINML_ERR_VALUE_NOTFOUND
//
// MessageText:
//
// An attempt was made to bind an unknown input or output.
//


//
// MessageId: WINML_ERR_SIZE_MISMATCH
//
// MessageText:
//
// The size of the buffer provided for a bound variable is invalid.
//


#line 62239 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\shared\\winerror.h"
#line 7701 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winbase.h"
#line 1 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\timezoneapi.h"
// begin_1_0
/********************************************************************************
*                                                                               *
* timezoneapi.h -- ApiSet Contract for api-ms-win-core-timezone-l1              *
*                                                                               *
* Copyright (c) Microsoft Corporation. All rights reserved.                     *
*                                                                               *
********************************************************************************/


#pragma once
#line 13 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\timezoneapi.h"










extern "C" {
#line 25 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\timezoneapi.h"

// end_1_0

#pragma region Application Family or OneCore Family or Games Family


// begin_1_0



typedef struct _TIME_ZONE_INFORMATION {
    LONG Bias;
    WCHAR StandardName[ 32 ];
    SYSTEMTIME StandardDate;
    LONG StandardBias;
    WCHAR DaylightName[ 32 ];
    SYSTEMTIME DaylightDate;
    LONG DaylightBias;
} TIME_ZONE_INFORMATION, *PTIME_ZONE_INFORMATION, *LPTIME_ZONE_INFORMATION;

typedef struct _TIME_DYNAMIC_ZONE_INFORMATION {
    LONG Bias;
    WCHAR StandardName[ 32 ];
    SYSTEMTIME StandardDate;
    LONG StandardBias;
    WCHAR DaylightName[ 32 ];
    SYSTEMTIME DaylightDate;
    LONG DaylightBias;
    WCHAR TimeZoneKeyName[ 128 ];
    BOOLEAN DynamicDaylightTimeDisabled;
} DYNAMIC_TIME_ZONE_INFORMATION, *PDYNAMIC_TIME_ZONE_INFORMATION;

__declspec(dllimport)

BOOL
__stdcall
SystemTimeToTzSpecificLocalTime(
     const TIME_ZONE_INFORMATION* lpTimeZoneInformation,
     const SYSTEMTIME* lpUniversalTime,
     LPSYSTEMTIME lpLocalTime
    );


__declspec(dllimport)

BOOL
__stdcall
TzSpecificLocalTimeToSystemTime(
     const TIME_ZONE_INFORMATION* lpTimeZoneInformation,
     const SYSTEMTIME* lpLocalTime,
     LPSYSTEMTIME lpUniversalTime
    );


__declspec(dllimport)

BOOL
__stdcall
FileTimeToSystemTime(
     const FILETIME* lpFileTime,
     LPSYSTEMTIME lpSystemTime
    );


__declspec(dllimport)

BOOL
__stdcall
SystemTimeToFileTime(
     const SYSTEMTIME* lpSystemTime,
     LPFILETIME lpFileTime
    );


__declspec(dllimport)

DWORD
__stdcall
GetTimeZoneInformation(
     LPTIME_ZONE_INFORMATION lpTimeZoneInformation
    );


#line 109 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\timezoneapi.h"
#pragma endregion

#pragma region Desktop Family or OneCore Family or Games Family


__declspec(dllimport)
BOOL
__stdcall
SetTimeZoneInformation(
     const TIME_ZONE_INFORMATION* lpTimeZoneInformation
    );




__declspec(dllimport)
BOOL
__stdcall
SetDynamicTimeZoneInformation(
     const DYNAMIC_TIME_ZONE_INFORMATION* lpTimeZoneInformation
    );


#line 133 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\timezoneapi.h"

#line 135 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\timezoneapi.h"
#pragma endregion

#pragma region Application Family or OneCore Family or Games Family




__declspec(dllimport)

DWORD
__stdcall
GetDynamicTimeZoneInformation(
     PDYNAMIC_TIME_ZONE_INFORMATION pTimeZoneInformation
    );


#line 152 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\timezoneapi.h"




BOOL
__stdcall
GetTimeZoneInformationForYear(
     USHORT wYear,
     PDYNAMIC_TIME_ZONE_INFORMATION pdtzi,
     LPTIME_ZONE_INFORMATION ptzi
    );


#line 166 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\timezoneapi.h"

// end_1_0














































#line 215 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\timezoneapi.h"

























#line 241 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\timezoneapi.h"

#line 243 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\timezoneapi.h"
#pragma endregion

// begin_1_0


}
#line 250 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\timezoneapi.h"

#line 252 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\timezoneapi.h"
// end_1_0
#line 7702 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winbase.h"

#pragma region Desktop Family


/* Abnormal termination codes */







//
// Power Management APIs
//

__declspec(dllimport)
BOOL
__stdcall
SetSystemPowerState(
     BOOL fSuspend,
     BOOL fForce
    );

#line 7727 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winbase.h"

#line 7729 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winbase.h"
#pragma endregion

#pragma region  Desktop or PC Family



//
// Power Management APIs
//



















typedef struct _SYSTEM_POWER_STATUS {
    BYTE ACLineStatus;
    BYTE BatteryFlag;
    BYTE BatteryLifePercent;
    BYTE SystemStatusFlag;
    DWORD BatteryLifeTime;
    DWORD BatteryFullLifeTime;
}   SYSTEM_POWER_STATUS, *LPSYSTEM_POWER_STATUS;

__declspec(dllimport)
BOOL
__stdcall
GetSystemPowerStatus(
     LPSYSTEM_POWER_STATUS lpSystemPowerStatus
    );

#line 7774 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winbase.h"

#line 7776 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winbase.h"
#pragma endregion


//
// Very Large Memory API Subset
//

#pragma region Desktop Family


__declspec(dllimport)
BOOL
__stdcall
MapUserPhysicalPagesScatter(
     PVOID *VirtualAddresses,
     ULONG_PTR NumberOfPages,
     PULONG_PTR PageArray
    );

#line 7796 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winbase.h"
#pragma endregion

#pragma region Desktop Family


__declspec(dllimport)

HANDLE
__stdcall
CreateJobObjectA(
     LPSECURITY_ATTRIBUTES lpJobAttributes,
     LPCSTR lpName
    );





#line 7815 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winbase.h"

__declspec(dllimport)

HANDLE
__stdcall
OpenJobObjectA(
     DWORD dwDesiredAccess,
     BOOL bInheritHandle,
     LPCSTR lpName
    );





#line 7831 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winbase.h"

#line 7833 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winbase.h"
#pragma endregion

#pragma region Desktop Family


__declspec(dllimport)
BOOL
__stdcall
CreateJobSet (
     ULONG NumJob,
     PJOB_SET_ARRAY UserJobSet,
     ULONG Flags);

#line 7847 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winbase.h"
#pragma endregion

#pragma region Desktop Family or OneCore Family


__declspec(dllimport)
HANDLE
__stdcall
FindFirstVolumeA(
     LPSTR lpszVolumeName,
     DWORD cchBufferLength
    );


#line 7862 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winbase.h"

__declspec(dllimport)
BOOL
__stdcall
FindNextVolumeA(
     HANDLE hFindVolume,
     LPSTR lpszVolumeName,
        DWORD cchBufferLength
    );


#line 7874 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winbase.h"

#line 7876 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winbase.h"
#pragma endregion

#pragma region Desktop Family


__declspec(dllimport)
HANDLE
__stdcall
FindFirstVolumeMountPointA(
     LPCSTR lpszRootPathName,
     LPSTR lpszVolumeMountPoint,
     DWORD cchBufferLength
    );
__declspec(dllimport)
HANDLE
__stdcall
FindFirstVolumeMountPointW(
     LPCWSTR lpszRootPathName,
     LPWSTR lpszVolumeMountPoint,
     DWORD cchBufferLength
    );




#line 7902 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winbase.h"

__declspec(dllimport)
BOOL
__stdcall
FindNextVolumeMountPointA(
     HANDLE hFindVolumeMountPoint,
     LPSTR lpszVolumeMountPoint,
     DWORD cchBufferLength
    );
__declspec(dllimport)
BOOL
__stdcall
FindNextVolumeMountPointW(
     HANDLE hFindVolumeMountPoint,
     LPWSTR lpszVolumeMountPoint,
     DWORD cchBufferLength
    );




#line 7924 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winbase.h"

__declspec(dllimport)
BOOL
__stdcall
FindVolumeMountPointClose(
     HANDLE hFindVolumeMountPoint
    );

__declspec(dllimport)
BOOL
__stdcall
SetVolumeMountPointA(
     LPCSTR lpszVolumeMountPoint,
     LPCSTR lpszVolumeName
    );
__declspec(dllimport)
BOOL
__stdcall
SetVolumeMountPointW(
     LPCWSTR lpszVolumeMountPoint,
     LPCWSTR lpszVolumeName
    );




#line 7951 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winbase.h"

#line 7953 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winbase.h"
#pragma endregion

#pragma region Application Family or OneCore Family


__declspec(dllimport)
BOOL
__stdcall
DeleteVolumeMountPointA(
     LPCSTR lpszVolumeMountPoint
    );


#line 7967 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winbase.h"

#line 7969 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winbase.h"
#pragma endregion

#pragma region Desktop Family or OneCore Family




#line 7977 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winbase.h"

__declspec(dllimport)
BOOL
__stdcall
GetVolumeNameForVolumeMountPointA(
     LPCSTR lpszVolumeMountPoint,
     LPSTR lpszVolumeName,
     DWORD cchBufferLength
);

__declspec(dllimport)
BOOL
__stdcall
GetVolumePathNameA(
     LPCSTR lpszFileName,
     LPSTR lpszVolumePathName,
     DWORD cchBufferLength
    );


#line 7998 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winbase.h"

#line 8000 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winbase.h"
#pragma endregion

#line 8003 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winbase.h"

#pragma region Desktop Family or OneCore Family




__declspec(dllimport)
BOOL
__stdcall
GetVolumePathNamesForVolumeNameA(
      LPCSTR lpszVolumeName,
       LPCH lpszVolumePathNames,
      DWORD cchBufferLength,
     PDWORD lpcchReturnLength
    );



#line 8022 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winbase.h"

#line 8024 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winbase.h"












typedef struct tagACTCTXA {
    ULONG       cbSize;
    DWORD       dwFlags;
    LPCSTR      lpSource;
    USHORT      wProcessorArchitecture;
    LANGID      wLangId;
    LPCSTR      lpAssemblyDirectory;
    LPCSTR      lpResourceName;
    LPCSTR      lpApplicationName;
    HMODULE     hModule;
} ACTCTXA, *PACTCTXA;
typedef struct tagACTCTXW {
    ULONG       cbSize;
    DWORD       dwFlags;
    LPCWSTR     lpSource;
    USHORT      wProcessorArchitecture;
    LANGID      wLangId;
    LPCWSTR     lpAssemblyDirectory;
    LPCWSTR     lpResourceName;
    LPCWSTR     lpApplicationName;
    HMODULE     hModule;
} ACTCTXW, *PACTCTXW;




typedef ACTCTXA ACTCTX;
typedef PACTCTXA PACTCTX;
#line 8065 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winbase.h"

typedef const ACTCTXA *PCACTCTXA;
typedef const ACTCTXW *PCACTCTXW;



typedef PCACTCTXA PCACTCTX;
#line 8073 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winbase.h"



__declspec(dllimport)
HANDLE
__stdcall
CreateActCtxA(
     PCACTCTXA pActCtx
    );
__declspec(dllimport)
HANDLE
__stdcall
CreateActCtxW(
     PCACTCTXW pActCtx
    );




#line 8093 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winbase.h"

__declspec(dllimport)
void
__stdcall
AddRefActCtx(
     HANDLE hActCtx
    );


__declspec(dllimport)
void
__stdcall
ReleaseActCtx(
     HANDLE hActCtx
    );

__declspec(dllimport)
BOOL
__stdcall
ZombifyActCtx(
     HANDLE hActCtx
    );



__declspec(dllimport)
BOOL
__stdcall
ActivateActCtx(
     HANDLE hActCtx,
       ULONG_PTR *lpCookie
    );





__declspec(dllimport)
BOOL
__stdcall
DeactivateActCtx(
     DWORD dwFlags,
     ULONG_PTR ulCookie
    );

__declspec(dllimport)
BOOL
__stdcall
GetCurrentActCtx(
     HANDLE *lphActCtx);


typedef struct tagACTCTX_SECTION_KEYED_DATA_2600 {
    ULONG cbSize;
    ULONG ulDataFormatVersion;
    PVOID lpData;
    ULONG ulLength;
    PVOID lpSectionGlobalData;
    ULONG ulSectionGlobalDataLength;
    PVOID lpSectionBase;
    ULONG ulSectionTotalLength;
    HANDLE hActCtx;
    ULONG ulAssemblyRosterIndex;
} ACTCTX_SECTION_KEYED_DATA_2600, *PACTCTX_SECTION_KEYED_DATA_2600;
typedef const ACTCTX_SECTION_KEYED_DATA_2600 * PCACTCTX_SECTION_KEYED_DATA_2600;

typedef struct tagACTCTX_SECTION_KEYED_DATA_ASSEMBLY_METADATA {
    PVOID lpInformation;
    PVOID lpSectionBase;
    ULONG ulSectionLength;
    PVOID lpSectionGlobalDataBase;
    ULONG ulSectionGlobalDataLength;
} ACTCTX_SECTION_KEYED_DATA_ASSEMBLY_METADATA, *PACTCTX_SECTION_KEYED_DATA_ASSEMBLY_METADATA;
typedef const ACTCTX_SECTION_KEYED_DATA_ASSEMBLY_METADATA *PCACTCTX_SECTION_KEYED_DATA_ASSEMBLY_METADATA;

typedef struct tagACTCTX_SECTION_KEYED_DATA {
    ULONG cbSize;
    ULONG ulDataFormatVersion;
    PVOID lpData;
    ULONG ulLength;
    PVOID lpSectionGlobalData;
    ULONG ulSectionGlobalDataLength;
    PVOID lpSectionBase;
    ULONG ulSectionTotalLength;
    HANDLE hActCtx;
    ULONG ulAssemblyRosterIndex;
// 2600 stops here
    ULONG ulFlags;
    ACTCTX_SECTION_KEYED_DATA_ASSEMBLY_METADATA AssemblyMetadata;
} ACTCTX_SECTION_KEYED_DATA, *PACTCTX_SECTION_KEYED_DATA;
typedef const ACTCTX_SECTION_KEYED_DATA * PCACTCTX_SECTION_KEYED_DATA;








__declspec(dllimport)
BOOL
__stdcall
FindActCtxSectionStringA(
           DWORD dwFlags,
     const GUID *lpExtensionGuid,
           ULONG ulSectionId,
           LPCSTR lpStringToFind,
          PACTCTX_SECTION_KEYED_DATA ReturnedData
    );

__declspec(dllimport)
BOOL
__stdcall
FindActCtxSectionStringW(
           DWORD dwFlags,
     const GUID *lpExtensionGuid,
           ULONG ulSectionId,
           LPCWSTR lpStringToFind,
          PACTCTX_SECTION_KEYED_DATA ReturnedData
    );




#line 8218 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winbase.h"

__declspec(dllimport)
BOOL
__stdcall
FindActCtxSectionGuid(
           DWORD dwFlags,
     const GUID *lpExtensionGuid,
           ULONG ulSectionId,
       const GUID *lpGuidToFind,
          PACTCTX_SECTION_KEYED_DATA ReturnedData
    );





typedef struct _ACTIVATION_CONTEXT_BASIC_INFORMATION {
    HANDLE  hActCtx;
    DWORD   dwFlags;
} ACTIVATION_CONTEXT_BASIC_INFORMATION, *PACTIVATION_CONTEXT_BASIC_INFORMATION;

typedef const struct _ACTIVATION_CONTEXT_BASIC_INFORMATION *PCACTIVATION_CONTEXT_BASIC_INFORMATION;



#line 8244 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winbase.h"
#line 8245 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winbase.h"








//
// switch (ulInfoClass)
//
//  case ActivationContextBasicInformation:
//    pvSubInstance == NULL
//    pvBuffer is of type PACTIVATION_CONTEXT_BASIC_INFORMATION
//
//  case ActivationContextDetailedInformation:
//    pvSubInstance == NULL
//    pvBuffer is of type PACTIVATION_CONTEXT_DETAILED_INFORMATION
//
//  case AssemblyDetailedInformationInActivationContext:
//    pvSubInstance is of type PULONG
//      *pvSubInstance < ACTIVATION_CONTEXT_DETAILED_INFORMATION::ulAssemblyCount
//    pvBuffer is of type PACTIVATION_CONTEXT_ASSEMBLY_DETAILED_INFORMATION
//
//  case FileInformationInAssemblyOfAssemblyInActivationContext:
//    pvSubInstance is of type PACTIVATION_CONTEXT_QUERY_INDEX
//      pvSubInstance->ulAssemblyIndex < ACTIVATION_CONTEXT_DETAILED_INFORMATION::ulAssemblyCount
//      pvSubInstance->ulFileIndexInAssembly < ACTIVATION_CONTEXT_ASSEMBLY_DETAILED_INFORMATION::ulFileCount
//    pvBuffer is of type PASSEMBLY_FILE_DETAILED_INFORMATION
//
//  case RunlevelInformationInActivationContext :
//    pvSubInstance == NULL
//    pvBuffer is of type PACTIVATION_CONTEXT_RUN_LEVEL_INFORMATION
//
// String are placed after the structs.
//

__declspec(dllimport)
BOOL
__stdcall
QueryActCtxW(
          DWORD dwFlags,
          HANDLE hActCtx,
      PVOID pvSubInstance,
          ULONG ulInfoClass,
     PVOID pvBuffer,
          SIZE_T cbBuffer,
     SIZE_T *pcbWrittenOrRequired
    );

typedef  BOOL (__stdcall * PQUERYACTCTXW_FUNC)(
          DWORD dwFlags,
          HANDLE hActCtx,
      PVOID pvSubInstance,
          ULONG ulInfoClass,
     PVOID pvBuffer,
          SIZE_T cbBuffer,
     SIZE_T *pcbWrittenOrRequired
    );

#line 8306 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winbase.h"

#line 8308 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winbase.h"
#pragma endregion

#pragma region Desktop Family





__declspec(dllimport)
DWORD
__stdcall
WTSGetActiveConsoleSessionId(
    void
    );

#line 8324 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winbase.h"

















#line 8342 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winbase.h"



__declspec(dllimport)
WORD
__stdcall
GetActiveProcessorGroupCount(
    void
    );

__declspec(dllimport)
WORD
__stdcall
GetMaximumProcessorGroupCount(
    void
    );

__declspec(dllimport)
DWORD
__stdcall
GetActiveProcessorCount(
     WORD GroupNumber
    );

__declspec(dllimport)
DWORD
__stdcall
GetMaximumProcessorCount(
     WORD GroupNumber
    );

#line 8374 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winbase.h"

//
// NUMA Information routines.
//

__declspec(dllimport)
BOOL
__stdcall
GetNumaProcessorNode(
      UCHAR Processor,
     PUCHAR NodeNumber
    );



__declspec(dllimport)
BOOL
__stdcall
GetNumaNodeNumberFromHandle(
      HANDLE hFile,
     PUSHORT NodeNumber
    );

#line 8398 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winbase.h"



__declspec(dllimport)
BOOL
__stdcall
GetNumaProcessorNodeEx(
      PPROCESSOR_NUMBER Processor,
     PUSHORT NodeNumber
    );

#line 8410 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winbase.h"

__declspec(dllimport)
BOOL
__stdcall
GetNumaNodeProcessorMask(
      UCHAR Node,
     PULONGLONG ProcessorMask
    );

__declspec(dllimport)
BOOL
__stdcall
GetNumaAvailableMemoryNode(
      UCHAR Node,
     PULONGLONG AvailableBytes
    );



__declspec(dllimport)
BOOL
__stdcall
GetNumaAvailableMemoryNodeEx(
      USHORT Node,
     PULONGLONG AvailableBytes
    );

#line 8438 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winbase.h"



__declspec(dllimport)
BOOL
__stdcall
GetNumaProximityNode(
      ULONG ProximityId,
     PUCHAR NodeNumber
    );

#line 8450 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winbase.h"

#line 8452 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winbase.h"
#pragma endregion

#pragma region Desktop Family or OneCore Family


//
// Application restart and data recovery callback
//
typedef DWORD (__stdcall *APPLICATION_RECOVERY_CALLBACK)(PVOID pvParameter);

//
// Max length of commandline in characters (including the NULL character that can be registered for restart)
//


//
// Do not restart the process for termination due to application crashes
//


//
// Do not restart the process for termination due to application hangs
//


//
// Do not restart the process for termination due to patch installations
//


//
// Do not restart the process when the system is rebooted due to patch installations
//





#line 8491 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winbase.h"
#pragma endregion

#pragma region Desktop Family




__declspec(dllimport)
HRESULT
__stdcall
RegisterApplicationRecoveryCallback(
      APPLICATION_RECOVERY_CALLBACK pRecoveyCallback,
      PVOID pvParameter,
     DWORD dwPingInterval,
     DWORD dwFlags
    );

__declspec(dllimport)
HRESULT
__stdcall
UnregisterApplicationRecoveryCallback(void);

__declspec(dllimport)
HRESULT
__stdcall
RegisterApplicationRestart(
     PCWSTR pwzCommandline,
     DWORD dwFlags
    );

__declspec(dllimport)
HRESULT
__stdcall
UnregisterApplicationRestart(void);

#line 8527 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winbase.h"

#line 8529 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winbase.h"
#pragma endregion

#pragma region Desktop Family or OneCore Family




__declspec(dllimport)
HRESULT
__stdcall
GetApplicationRecoveryCallback(
      HANDLE hProcess,
     APPLICATION_RECOVERY_CALLBACK* pRecoveryCallback,
     PVOID* ppvParameter,
     PDWORD pdwPingInterval,
     PDWORD pdwFlags
    );

__declspec(dllimport)
HRESULT
__stdcall
GetApplicationRestartSettings(
     HANDLE hProcess,
     PWSTR pwzCommandline,
     PDWORD pcchSize,
     PDWORD pdwFlags
    );

#line 8558 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winbase.h"

#line 8560 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winbase.h"
#pragma endregion

#pragma region Desktop Family




__declspec(dllimport)
HRESULT
__stdcall
ApplicationRecoveryInProgress(
     PBOOL pbCancelled
    );

__declspec(dllimport)
void
__stdcall
ApplicationRecoveryFinished(
     BOOL bSuccess
    );

#line 8582 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winbase.h"

#line 8584 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winbase.h"
#pragma endregion



#pragma region Application Family or OneCore Family


typedef struct _FILE_BASIC_INFO {
    LARGE_INTEGER CreationTime;
    LARGE_INTEGER LastAccessTime;
    LARGE_INTEGER LastWriteTime;
    LARGE_INTEGER ChangeTime;
    DWORD FileAttributes;
} FILE_BASIC_INFO, *PFILE_BASIC_INFO;

typedef struct _FILE_STANDARD_INFO {
    LARGE_INTEGER AllocationSize;
    LARGE_INTEGER EndOfFile;
    DWORD NumberOfLinks;
    BOOLEAN DeletePending;
    BOOLEAN Directory;
} FILE_STANDARD_INFO, *PFILE_STANDARD_INFO;

typedef struct _FILE_NAME_INFO {
    DWORD FileNameLength;
    WCHAR FileName[1];
} FILE_NAME_INFO, *PFILE_NAME_INFO;

typedef struct _FILE_CASE_SENSITIVE_INFO {
    ULONG Flags;
} FILE_CASE_SENSITIVE_INFO, *PFILE_CASE_SENSITIVE_INFO;




#line 8620 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winbase.h"



#line 8624 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winbase.h"

typedef struct _FILE_RENAME_INFO {

    union {
        BOOLEAN ReplaceIfExists;  // FileRenameInfo
        DWORD Flags;              // FileRenameInfoEx
    }  ;


#line 8634 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winbase.h"
    HANDLE RootDirectory;
    DWORD FileNameLength;
    WCHAR FileName[1];
} FILE_RENAME_INFO, *PFILE_RENAME_INFO;

typedef struct _FILE_ALLOCATION_INFO {
    LARGE_INTEGER AllocationSize;
} FILE_ALLOCATION_INFO, *PFILE_ALLOCATION_INFO;

typedef struct _FILE_END_OF_FILE_INFO {
    LARGE_INTEGER EndOfFile;
} FILE_END_OF_FILE_INFO, *PFILE_END_OF_FILE_INFO;

typedef struct _FILE_STREAM_INFO {
    DWORD NextEntryOffset;
    DWORD StreamNameLength;
    LARGE_INTEGER StreamSize;
    LARGE_INTEGER StreamAllocationSize;
    WCHAR StreamName[1];
} FILE_STREAM_INFO, *PFILE_STREAM_INFO;

typedef struct _FILE_COMPRESSION_INFO {
    LARGE_INTEGER CompressedFileSize;
    WORD CompressionFormat;
    UCHAR CompressionUnitShift;
    UCHAR ChunkShift;
    UCHAR ClusterShift;
    UCHAR Reserved[3];
} FILE_COMPRESSION_INFO, *PFILE_COMPRESSION_INFO;

typedef struct _FILE_ATTRIBUTE_TAG_INFO {
    DWORD FileAttributes;
    DWORD ReparseTag;
} FILE_ATTRIBUTE_TAG_INFO, *PFILE_ATTRIBUTE_TAG_INFO;

typedef struct _FILE_DISPOSITION_INFO {
    BOOLEAN DeleteFileA ;
} FILE_DISPOSITION_INFO, *PFILE_DISPOSITION_INFO;









#line 8682 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winbase.h"

typedef struct _FILE_DISPOSITION_INFO_EX {
    DWORD Flags;
} FILE_DISPOSITION_INFO_EX, *PFILE_DISPOSITION_INFO_EX;
#line 8687 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winbase.h"

typedef struct _FILE_ID_BOTH_DIR_INFO {
    DWORD NextEntryOffset;
    DWORD FileIndex;
    LARGE_INTEGER CreationTime;
    LARGE_INTEGER LastAccessTime;
    LARGE_INTEGER LastWriteTime;
    LARGE_INTEGER ChangeTime;
    LARGE_INTEGER EndOfFile;
    LARGE_INTEGER AllocationSize;
    DWORD FileAttributes;
    DWORD FileNameLength;
    DWORD EaSize;
    CCHAR ShortNameLength;
    WCHAR ShortName[12];
    LARGE_INTEGER FileId;
    WCHAR FileName[1];
} FILE_ID_BOTH_DIR_INFO, *PFILE_ID_BOTH_DIR_INFO;

typedef struct _FILE_FULL_DIR_INFO {
    ULONG NextEntryOffset;
    ULONG FileIndex;
    LARGE_INTEGER CreationTime;
    LARGE_INTEGER LastAccessTime;
    LARGE_INTEGER LastWriteTime;
    LARGE_INTEGER ChangeTime;
    LARGE_INTEGER EndOfFile;
    LARGE_INTEGER AllocationSize;
    ULONG FileAttributes;
    ULONG FileNameLength;
    ULONG EaSize;
    WCHAR FileName[1];
} FILE_FULL_DIR_INFO, *PFILE_FULL_DIR_INFO;

typedef enum _PRIORITY_HINT {
      IoPriorityHintVeryLow = 0,
      IoPriorityHintLow,
      IoPriorityHintNormal,
      MaximumIoPriorityHintType
} PRIORITY_HINT;

typedef struct _FILE_IO_PRIORITY_HINT_INFO {
    PRIORITY_HINT PriorityHint;
} FILE_IO_PRIORITY_HINT_INFO, *PFILE_IO_PRIORITY_HINT_INFO;

// Structure and constants must match those in ntioapi_x.w
































































#line 8798 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winbase.h"

//
// File Remote protocol info (FileRemoteProtocolInfo)
//

// Protocol generic flags.






#line 8811 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winbase.h"

// Protocol specific SMB2 share capability flags.







#line 8821 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winbase.h"

// Protocol specific SMB2 server capability flags.








#line 8832 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winbase.h"

typedef struct _FILE_REMOTE_PROTOCOL_INFO
{
    // Structure Version
    USHORT StructureVersion;     // 1 for Win7, 2 for Win8 SMB3, 3 for Blue SMB3.
    USHORT StructureSize;        // sizeof(FILE_REMOTE_PROTOCOL_INFO)

    ULONG  Protocol;             // Protocol (WNNC_NET_*) defined in winnetwk.h or ntifs.h.

    // Protocol Version & Type
    USHORT ProtocolMajorVersion;
    USHORT ProtocolMinorVersion;
    USHORT ProtocolRevision;

    USHORT Reserved;

    // Protocol-Generic Information
    ULONG  Flags;

    struct {
        ULONG Reserved[8];
    } GenericReserved;

    // Protocol specific information


    struct {
        ULONG Reserved[16];
    } ProtocolSpecificReserved;
#line 8862 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winbase.h"





















#line 8884 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winbase.h"

} FILE_REMOTE_PROTOCOL_INFO, *PFILE_REMOTE_PROTOCOL_INFO;

__declspec(dllimport)
BOOL
__stdcall
GetFileInformationByHandleEx(
      HANDLE hFile,
      FILE_INFO_BY_HANDLE_CLASS FileInformationClass,
     LPVOID lpFileInformation,
      DWORD dwBufferSize
);

#line 8898 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winbase.h"
#pragma endregion

#pragma region Desktop Family or OneCore Family


typedef enum _FILE_ID_TYPE {
      FileIdType,
      ObjectIdType,
      ExtendedFileIdType,
      MaximumFileIdType
} FILE_ID_TYPE, *PFILE_ID_TYPE;

typedef struct FILE_ID_DESCRIPTOR {
    DWORD dwSize;  // Size of the struct
    FILE_ID_TYPE Type; // Describes the type of identifier passed in.
    union {
        LARGE_INTEGER FileId;
        GUID ObjectId;


#line 8919 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winbase.h"
    }  ;
} FILE_ID_DESCRIPTOR, *LPFILE_ID_DESCRIPTOR;

__declspec(dllimport)
HANDLE
__stdcall
OpenFileById (
         HANDLE hVolumeHint,
         LPFILE_ID_DESCRIPTOR lpFileId,
         DWORD dwDesiredAccess,
         DWORD dwShareMode,
     LPSECURITY_ATTRIBUTES lpSecurityAttributes,
         DWORD dwFlagsAndAttributes
    );

#line 8935 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winbase.h"
#pragma endregion

#line 8938 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winbase.h"

#pragma region Desktop Family or OneCore Family




//
//  Flag values for the dwFlags parameter of the CreateSymbolicLink API
//

//  Request to create a directory symbolic link


//  Specify this flag if you want to allow creation of symbolic links when the
//  process is not elevated.  As of now enabling DEVELOPER MODE on a system
//  is the only scenario that allow unprivileged symlink creation. There may
//  be future scenarios that this flag will enable in the future.
//
//  Also be aware that the behavior of this API with this flag set will likely
//  be different between a development environment and an and customers
//  environment so please be careful with the usage of this flag.




__declspec(dllimport)
BOOLEAN
__stdcall
CreateSymbolicLinkA (
     LPCSTR lpSymlinkFileName,
     LPCSTR lpTargetFileName,
     DWORD dwFlags
    );
__declspec(dllimport)
BOOLEAN
__stdcall
CreateSymbolicLinkW (
     LPCWSTR lpSymlinkFileName,
     LPCWSTR lpTargetFileName,
     DWORD dwFlags
    );




#line 8984 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winbase.h"

#line 8986 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winbase.h"



__declspec(dllimport)
BOOL
__stdcall
QueryActCtxSettingsW(
          DWORD dwFlags,
          HANDLE hActCtx,
          PCWSTR settingsNameSpace,
              PCWSTR settingName,
     PWSTR pvBuffer,
          SIZE_T dwBuffer,
     SIZE_T *pdwWrittenOrRequired
    );

#line 9003 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winbase.h"

#line 9005 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winbase.h"
#pragma endregion

#pragma region Desktop Family




__declspec(dllimport)
BOOLEAN
__stdcall
CreateSymbolicLinkTransactedA (
         LPCSTR lpSymlinkFileName,
         LPCSTR lpTargetFileName,
         DWORD dwFlags,
         HANDLE hTransaction
    );
__declspec(dllimport)
BOOLEAN
__stdcall
CreateSymbolicLinkTransactedW (
         LPCWSTR lpSymlinkFileName,
         LPCWSTR lpTargetFileName,
         DWORD dwFlags,
         HANDLE hTransaction
    );




#line 9035 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winbase.h"

#line 9037 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winbase.h"



__declspec(dllimport)
BOOL
__stdcall
ReplacePartitionUnit (
     PWSTR TargetPartition,
     PWSTR SparePartition,
     ULONG Flags
    );

#line 9050 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winbase.h"




__declspec(dllimport)
BOOL
__stdcall
AddSecureMemoryCacheCallback(
      PSECURE_MEMORY_CACHE_CALLBACK pfnCallBack
    );

__declspec(dllimport)
BOOL
__stdcall
RemoveSecureMemoryCacheCallback(
      PSECURE_MEMORY_CACHE_CALLBACK pfnCallBack
    );

#line 9069 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winbase.h"

#line 9071 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winbase.h"
#pragma endregion



#pragma region Desktop Family or OneCore Family



__declspec(dllimport)
BOOL
__stdcall
CopyContext(
     PCONTEXT Destination,
     DWORD ContextFlags,
     PCONTEXT Source
    );

#line 9089 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winbase.h"
#pragma endregion

#pragma region Application Family or OneCore Family



__declspec(dllimport)
BOOL
__stdcall
InitializeContext(
     PVOID Buffer,
     DWORD ContextFlags,
     PCONTEXT* Context,
     PDWORD ContextLength
    );















#line 9120 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winbase.h"

#line 9122 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winbase.h"
#pragma endregion



#pragma region Application Family or OneCore Family


__declspec(dllimport)
DWORD64
__stdcall
GetEnabledXStateFeatures(
    void
    );


__declspec(dllimport)
BOOL
__stdcall
GetXStateFeaturesMask(
     PCONTEXT Context,
     PDWORD64 FeatureMask
    );


__declspec(dllimport)
PVOID
__stdcall
LocateXStateFeature(
     PCONTEXT Context,
     DWORD FeatureId,
     PDWORD Length
    );

#line 9156 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winbase.h"
#pragma endregion

#pragma region Desktop Family or OneCore Family



__declspec(dllimport)
BOOL
__stdcall
SetXStateFeaturesMask(
     PCONTEXT Context,
     DWORD64 FeatureMask
    );

#line 9171 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winbase.h"
#pragma endregion

#line 9174 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winbase.h"

#line 9176 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winbase.h"



#pragma region Desktop Family


__declspec(dllimport)
DWORD
__stdcall
EnableThreadProfiling(
     HANDLE ThreadHandle,
     DWORD Flags,
     DWORD64 HardwareCounters,
     HANDLE *PerformanceDataHandle
    );

__declspec(dllimport)
DWORD
__stdcall
DisableThreadProfiling(
     HANDLE PerformanceDataHandle
    );

__declspec(dllimport)
DWORD
__stdcall
QueryThreadProfiling(
     HANDLE ThreadHandle,
     PBOOLEAN Enabled
    );

__declspec(dllimport)
DWORD
__stdcall
ReadThreadProfilingData(
     HANDLE PerformanceDataHandle,
     DWORD Flags,
     PPERFORMANCE_DATA PerformanceData
    );

#line 9217 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winbase.h"
#pragma endregion

#line 9220 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winbase.h"
















#line 9237 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winbase.h"






#line 9244 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winbase.h"
#line 9245 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winbase.h"


}
#line 9249 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winbase.h"



#pragma warning(pop)




#line 9258 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winbase.h"
#line 9259 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winbase.h"



#line 9263 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winbase.h"




/*++

Copyright (c) Microsoft Corporation.  All rights reserved.

Module Name:

    winbase_interlockedcplusplus.h

Abstract:

    C++ function overloads in place of "manual name mangling".
    This file is meant to be #included by winbase.h or any other file declaring the signed interlocked functions.

Author:

    Jay Krell (JayKrell) April 2002

--*/






#pragma once
#line 9293 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winbase.h"



/*
To turn off/hide the contents of this file:
 #define MICROSOFT_WINDOWS_WINBASE_H_DEFINE_INTERLOCKED_CPLUSPLUS_OVERLOADS 0
*/



#line 9304 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winbase.h"





extern "C++" {

__forceinline
unsigned
_InterlockedIncrement (
      unsigned volatile *Addend
    )
{
    return (unsigned) _InterlockedIncrement((volatile long*) Addend);
}

__forceinline
unsigned long
_InterlockedIncrement (
      unsigned long volatile *Addend
    )
{
    return (unsigned long) _InterlockedIncrement((volatile long*) Addend);
}

// ARM64_WORKAROUND : should this work for managed code?


__forceinline
unsigned __int64
_InterlockedIncrement (
      unsigned __int64 volatile *Addend
    )
{
    return (unsigned __int64) (_InterlockedIncrement64 )((volatile __int64*) Addend);
}

#line 9342 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winbase.h"

__forceinline
unsigned
_InterlockedDecrement (
      unsigned volatile *Addend
    )
{
    return (unsigned long) _InterlockedDecrement((volatile long*) Addend);
}

__forceinline
unsigned long
_InterlockedDecrement (
      unsigned long volatile *Addend
    )
{
    return (unsigned long) _InterlockedDecrement((volatile long*) Addend);
}

// ARM64_WORKAROUND : should this work for managed code?


__forceinline
unsigned __int64
_InterlockedDecrement (
      unsigned __int64 volatile *Addend
    )
{
    return (unsigned __int64) (_InterlockedDecrement64 )((volatile __int64*) Addend);
}

#line 9374 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winbase.h"



__forceinline
unsigned
_InterlockedExchange (
      unsigned volatile *Target,
     unsigned Value
    )
{
    return (unsigned) _InterlockedExchange((volatile long*) Target, (long) Value);
}

__forceinline
unsigned long
_InterlockedExchange (
      unsigned long volatile *Target,
     unsigned long Value
    )
{
    return (unsigned long) _InterlockedExchange((volatile long*) Target, (long) Value);
}



__forceinline
unsigned __int64
_InterlockedExchange (
      unsigned __int64 volatile *Target,
     unsigned __int64 Value
    )
{
    return (unsigned __int64) _InterlockedExchange64 ((volatile __int64*) Target, (__int64) Value);
}

#line 9410 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winbase.h"

__forceinline
unsigned
_InterlockedExchangeAdd (
      unsigned volatile *Addend,
     unsigned Value
    )
{
    return (unsigned) _InterlockedExchangeAdd((volatile long*) Addend, (long) Value);
}

__forceinline
unsigned
InterlockedExchangeSubtract(
      unsigned volatile *Addend,
     unsigned Value
    )
{
    return (unsigned) _InterlockedExchangeAdd((volatile long*) Addend,  - (long) Value);
}

__forceinline
unsigned long
_InterlockedExchangeAdd (
      unsigned long volatile *Addend,
     unsigned long Value
    )
{
    return (unsigned long) _InterlockedExchangeAdd((volatile long*) Addend, (long) Value);
}

__forceinline
unsigned long
InterlockedExchangeSubtract(
      unsigned long volatile *Addend,
     unsigned long Value
    )
{
    return (unsigned long) _InterlockedExchangeAdd((volatile long*) Addend,  - (long) Value);
}



__forceinline
unsigned __int64
_InterlockedExchangeAdd (
      unsigned __int64 volatile *Addend,
     unsigned __int64 Value
    )
{
    return (unsigned __int64) _InterlockedExchangeAdd64 ((volatile __int64*) Addend,  (__int64) Value);
}

__forceinline
unsigned __int64
InterlockedExchangeSubtract(
      unsigned __int64 volatile *Addend,
     unsigned __int64 Value
    )
{
    return (unsigned __int64) _InterlockedExchangeAdd64 ((volatile __int64*) Addend,  - (__int64) Value);
}

#line 9474 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winbase.h"

__forceinline
unsigned
_InterlockedCompareExchange (
      unsigned volatile *Destination,
     unsigned Exchange,
     unsigned Comperand
    )
{
    return (unsigned) _InterlockedCompareExchange((volatile long*) Destination, (long) Exchange, (long) Comperand);
}

__forceinline
unsigned long
_InterlockedCompareExchange (
      unsigned long volatile *Destination,
     unsigned long Exchange,
     unsigned long Comperand
    )
{
    return (unsigned long) _InterlockedCompareExchange((volatile long*) Destination, (long) Exchange, (long) Comperand);
}



__forceinline
unsigned __int64
_InterlockedCompareExchange (
      unsigned __int64 volatile *Destination,
     unsigned __int64 Exchange,
     unsigned __int64 Comperand
    )
{
    return (unsigned __int64) _InterlockedCompareExchange64((volatile __int64*) Destination, (__int64) Exchange, (__int64) Comperand);
}

__forceinline
unsigned __int64
_InterlockedAnd (
      unsigned __int64 volatile *Destination,
     unsigned __int64 Value
    )
{
    return (unsigned __int64) _InterlockedAnd64 ((volatile __int64*) Destination, (__int64) Value);
}

__forceinline
unsigned __int64
_InterlockedOr (
      unsigned __int64 volatile *Destination,
     unsigned __int64 Value
    )
{
    return (unsigned __int64) _InterlockedOr64 ((volatile __int64*) Destination, (__int64) Value);
}

__forceinline
unsigned __int64
_InterlockedXor (
      unsigned __int64 volatile *Destination,
     unsigned __int64 Value
    )
{
    return (unsigned __int64) _InterlockedXor64 ((volatile __int64*) Destination, (__int64) Value);
}

#line 9541 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winbase.h"

#line 9543 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winbase.h"

} /* extern "C++" */
#line 9546 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winbase.h"

#line 9548 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winbase.h"




#line 9553 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winbase.h"
#line 9554 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winbase.h"
#line 9555 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winbase.h"
#line 9556 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winbase.h"
#line 9557 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winbase.h"
#line 9558 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winbase.h"
#line 173 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\Windows.h"
#line 1 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\wingdi.h"


/**************************************************************************
*                                                                         *
* wingdi.h -- GDI procedure declarations, constant definitions and macros *
*                                                                         *
* Copyright (c) Microsoft Corp. All rights reserved.                      *
*                                                                         *
**************************************************************************/





#pragma once


#pragma warning(push)
#pragma warning(disable: 4201)      



#pragma warning(disable: 4820)      
#line 25 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\wingdi.h"






//
// Define API decoration for direct importing of DLL references.
//





#line 40 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\wingdi.h"

//
// Define API decoration for direct importing of DLL references.
//





#line 50 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\wingdi.h"


extern "C" {
#line 54 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\wingdi.h"









/* Binary raster ops */


















/* Ternary raster operations */



















#line 103 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\wingdi.h"


/* Quaternary raster codes */


#line 109 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\wingdi.h"






#line 116 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\wingdi.h"

/* Region Flags */






/* CombineRgn() Styles */








/* StretchBlt() Modes */







/* New StretchBlt() Modes */




#line 147 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\wingdi.h"

/* PolyFill() Modes */




/* Layout Orientation Options */






#line 161 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\wingdi.h"

/* Text Alignment Options */















#line 179 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\wingdi.h"
















#line 196 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\wingdi.h"


#line 199 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\wingdi.h"


#line 202 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\wingdi.h"



/* Bounds Accumulation APIs */










/* Metafile Functions */































































#line 281 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\wingdi.h"








#pragma region Desktop Family



typedef struct _DRAWPATRECT {
        POINT ptPosition;
        POINT ptSize;
        WORD wStyle;
        WORD wPattern;
} DRAWPATRECT, *PDRAWPATRECT;
#line 300 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\wingdi.h"

#line 302 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\wingdi.h"
#pragma endregion

#line 305 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\wingdi.h"

/* GDI Escapes */




























































































/*
 * Return Values for MILCORE_TS_QUERYVER
 */




#line 407 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\wingdi.h"




/*
 * Parameters for POSTSCRIPT_IDENTIFY escape
 */




#pragma region Desktop Family


/*
 * Header structure for the input buffer to POSTSCRIPT_INJECTION escape
 */

typedef struct _PSINJECTDATA {

    DWORD   DataBytes;      /* number of raw data bytes (NOT including this header) */
    WORD    InjectionPoint; /* injection point */
    WORD    PageNumber;     /* page number to apply the injection */

    /* Followed by raw data to be injected */

} PSINJECTDATA, *PPSINJECTDATA;

#line 436 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\wingdi.h"
#pragma endregion

/*
 * Constants for PSINJECTDATA.InjectionPoint field
 */






































/*
 * InjectionPoint for publisher mode PScript5 OEM plugin to
 * generate DSC comment for included font resource
 */


/*
 * Parameter for GET_PS_FEATURESETTING escape
 */










//
// The range of selectors between FEATURESETTING_PRIVATE_BEGIN and
// FEATURESETTING_PRIVATE_END is reserved by Microsoft for private use
//


#line 505 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\wingdi.h"

#pragma region Desktop Family


/*
 * Information about output options
 */

typedef struct _PSFEATURE_OUTPUT {

    BOOL bPageIndependent;
    BOOL bSetPageDevice;

} PSFEATURE_OUTPUT, *PPSFEATURE_OUTPUT;

/*
 * Information about custom paper size
 */

typedef struct _PSFEATURE_CUSTPAPER {

    LONG lOrientation;
    LONG lWidth;
    LONG lHeight;
    LONG lWidthOffset;
    LONG lHeightOffset;

} PSFEATURE_CUSTPAPER, *PPSFEATURE_CUSTPAPER;

#line 535 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\wingdi.h"
#pragma endregion

/* Value returned for FEATURESETTING_PROTOCOL */





/* Flag returned from QUERYDIBSUPPORT */





/* Spooler Error Codes */









/* Object Definitions for EnumObjects() */

















/* xform stuff */









#pragma region Application Family


typedef struct  tagXFORM
  {
    FLOAT   eM11;
    FLOAT   eM12;
    FLOAT   eM21;
    FLOAT   eM22;
    FLOAT   eDx;
    FLOAT   eDy;
  } XFORM, *PXFORM,  *LPXFORM;

/* Bitmap Header Definition */
typedef struct tagBITMAP
  {
    LONG        bmType;
    LONG        bmWidth;
    LONG        bmHeight;
    LONG        bmWidthBytes;
    WORD        bmPlanes;
    WORD        bmBitsPixel;
    LPVOID      bmBits;
  } BITMAP, *PBITMAP,  *NPBITMAP,  *LPBITMAP;

#line 613 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\wingdi.h"
#pragma endregion

#line 1 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\shared\\pshpack1.h"
/*++

Copyright (c) Microsoft Corporation.  All rights reserved.

Module Name:

    pshpack1.h

Abstract:

    This file turns 1 byte packing of structures on.  (That is, it disables
    automatic alignment of structure fields.)  An include file is needed
    because various compilers do this in different ways.  For Microsoft
    compatible compilers, this files uses the push option to the pack pragma
    so that the poppack.h include file can restore the previous packing
    reliably.

    The file poppack.h is the complement to this file.

--*/



#pragma warning(disable:4103)

#pragma pack(push,1)


#line 30 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\shared\\pshpack1.h"


#line 33 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\shared\\pshpack1.h"
#line 34 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\shared\\pshpack1.h"
#line 616 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\wingdi.h"

#pragma region Application Family


typedef struct tagRGBTRIPLE {
        BYTE    rgbtBlue;
        BYTE    rgbtGreen;
        BYTE    rgbtRed;
} RGBTRIPLE, *PRGBTRIPLE,  *NPRGBTRIPLE,  *LPRGBTRIPLE;

#line 627 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\wingdi.h"
#pragma endregion

#line 1 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\shared\\poppack.h"
/*++

Copyright (c) Microsoft Corporation.  All rights reserved.

Module Name:

    poppack.h

Abstract:

    This file turns packing of structures off.  (That is, it enables
    automatic alignment of structure fields.)  An include file is needed
    because various compilers do this in different ways.

    poppack.h is the complement to pshpack?.h.  An inclusion of poppack.h
    MUST ALWAYS be preceded by an inclusion of one of pshpack?.h, in one-to-one
    correspondence.

    For Microsoft compatible compilers, this file uses the pop option
    to the pack pragma so that it can restore the previous saved by the
    pshpack?.h include file.

--*/



#pragma warning(disable:4103)

#pragma pack(pop)


#line 33 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\shared\\poppack.h"


#line 36 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\shared\\poppack.h"
#line 37 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\shared\\poppack.h"
#line 630 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\wingdi.h"

#pragma region Application Family


typedef struct tagRGBQUAD {
        BYTE    rgbBlue;
        BYTE    rgbGreen;
        BYTE    rgbRed;
        BYTE    rgbReserved;
} RGBQUAD;

#line 642 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\wingdi.h"
#pragma endregion

#pragma region Desktop Family


typedef RGBQUAD  * LPRGBQUAD;

#line 650 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\wingdi.h"
#pragma endregion



/* Image Color Matching color definitions */





/* Logcolorspace signature */



/* Logcolorspace lcsType values */




#pragma region Application Family


typedef LONG   LCSCSTYPE;



typedef LONG    LCSGAMUTMATCH;






/* ICM Defines for results from CheckColorInGamut() */



/* UpdateICMRegKey Constants               */








/* Macros to retrieve CMYK values from a COLORREF */







typedef long            FXPT16DOT16,  *LPFXPT16DOT16;
typedef long            FXPT2DOT30,  *LPFXPT2DOT30;

/* ICM Color Definitions */
// The following two structures are used for defining RGB's in terms of CIEXYZ.

typedef struct tagCIEXYZ
{
        FXPT2DOT30 ciexyzX;
        FXPT2DOT30 ciexyzY;
        FXPT2DOT30 ciexyzZ;
} CIEXYZ;

#line 718 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\wingdi.h"
#pragma endregion

#pragma region Desktop Family


typedef CIEXYZ   *LPCIEXYZ;

#line 726 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\wingdi.h"
#pragma endregion

#pragma region Application Family


typedef struct tagICEXYZTRIPLE
{
        CIEXYZ  ciexyzRed;
        CIEXYZ  ciexyzGreen;
        CIEXYZ  ciexyzBlue;
} CIEXYZTRIPLE;

#line 739 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\wingdi.h"
#pragma endregion

#pragma region Desktop Family


typedef CIEXYZTRIPLE     *LPCIEXYZTRIPLE;

#line 747 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\wingdi.h"
#pragma endregion

#pragma region Application Family


// The next structures the logical color space. Unlike pens and brushes,
// but like palettes, there is only one way to create a LogColorSpace.
// A pointer to it must be passed, its elements can't be pushed as
// arguments.

typedef struct tagLOGCOLORSPACEA {
    DWORD lcsSignature;
    DWORD lcsVersion;
    DWORD lcsSize;
    LCSCSTYPE lcsCSType;
    LCSGAMUTMATCH lcsIntent;
    CIEXYZTRIPLE lcsEndpoints;
    DWORD lcsGammaRed;
    DWORD lcsGammaGreen;
    DWORD lcsGammaBlue;
    CHAR   lcsFilename[260 ];
} LOGCOLORSPACEA, *LPLOGCOLORSPACEA;
typedef struct tagLOGCOLORSPACEW {
    DWORD lcsSignature;
    DWORD lcsVersion;
    DWORD lcsSize;
    LCSCSTYPE lcsCSType;
    LCSGAMUTMATCH lcsIntent;
    CIEXYZTRIPLE lcsEndpoints;
    DWORD lcsGammaRed;
    DWORD lcsGammaGreen;
    DWORD lcsGammaBlue;
    WCHAR  lcsFilename[260 ];
} LOGCOLORSPACEW, *LPLOGCOLORSPACEW;




typedef LOGCOLORSPACEA LOGCOLORSPACE;
typedef LPLOGCOLORSPACEA LPLOGCOLORSPACE;
#line 788 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\wingdi.h"

#line 790 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\wingdi.h"
#pragma endregion

#line 793 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\wingdi.h"

#pragma region Desktop Family


/* structures for defining DIBs */
typedef struct tagBITMAPCOREHEADER {
        DWORD   bcSize;                 /* used to get to color table */
        WORD    bcWidth;
        WORD    bcHeight;
        WORD    bcPlanes;
        WORD    bcBitCount;
} BITMAPCOREHEADER,  *LPBITMAPCOREHEADER, *PBITMAPCOREHEADER;

#line 807 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\wingdi.h"
#pragma endregion

#pragma region Application Family or OneCore Family or Games Family


typedef struct tagBITMAPINFOHEADER{
        DWORD      biSize;
        LONG       biWidth;
        LONG       biHeight;
        WORD       biPlanes;
        WORD       biBitCount;
        DWORD      biCompression;
        DWORD      biSizeImage;
        LONG       biXPelsPerMeter;
        LONG       biYPelsPerMeter;
        DWORD      biClrUsed;
        DWORD      biClrImportant;
} BITMAPINFOHEADER,  *LPBITMAPINFOHEADER, *PBITMAPINFOHEADER;

#line 827 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\wingdi.h"
#pragma endregion



#pragma region Desktop Family


typedef struct {
        DWORD        bV4Size;
        LONG         bV4Width;
        LONG         bV4Height;
        WORD         bV4Planes;
        WORD         bV4BitCount;
        DWORD        bV4V4Compression;
        DWORD        bV4SizeImage;
        LONG         bV4XPelsPerMeter;
        LONG         bV4YPelsPerMeter;
        DWORD        bV4ClrUsed;
        DWORD        bV4ClrImportant;
        DWORD        bV4RedMask;
        DWORD        bV4GreenMask;
        DWORD        bV4BlueMask;
        DWORD        bV4AlphaMask;
        DWORD        bV4CSType;
        CIEXYZTRIPLE bV4Endpoints;
        DWORD        bV4GammaRed;
        DWORD        bV4GammaGreen;
        DWORD        bV4GammaBlue;
} BITMAPV4HEADER,  *LPBITMAPV4HEADER, *PBITMAPV4HEADER;

#line 858 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\wingdi.h"
#pragma endregion
#line 860 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\wingdi.h"



#pragma region Desktop Family

typedef struct {
        DWORD        bV5Size;
        LONG         bV5Width;
        LONG         bV5Height;
        WORD         bV5Planes;
        WORD         bV5BitCount;
        DWORD        bV5Compression;
        DWORD        bV5SizeImage;
        LONG         bV5XPelsPerMeter;
        LONG         bV5YPelsPerMeter;
        DWORD        bV5ClrUsed;
        DWORD        bV5ClrImportant;
        DWORD        bV5RedMask;
        DWORD        bV5GreenMask;
        DWORD        bV5BlueMask;
        DWORD        bV5AlphaMask;
        DWORD        bV5CSType;
        CIEXYZTRIPLE bV5Endpoints;
        DWORD        bV5GammaRed;
        DWORD        bV5GammaGreen;
        DWORD        bV5GammaBlue;
        DWORD        bV5Intent;
        DWORD        bV5ProfileData;
        DWORD        bV5ProfileSize;
        DWORD        bV5Reserved;
} BITMAPV5HEADER,  *LPBITMAPV5HEADER, *PBITMAPV5HEADER;

#line 893 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\wingdi.h"
#pragma endregion

// Values for bV5CSType


#line 899 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\wingdi.h"

/* constants for the biCompression field */







#line 909 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\wingdi.h"

#pragma region Application Family


typedef struct tagBITMAPINFO {
    BITMAPINFOHEADER    bmiHeader;
    RGBQUAD             bmiColors[1];
} BITMAPINFO,  *LPBITMAPINFO, *PBITMAPINFO;

#line 919 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\wingdi.h"
#pragma endregion

#pragma region Desktop Family


typedef struct tagBITMAPCOREINFO {
    BITMAPCOREHEADER    bmciHeader;
    RGBTRIPLE           bmciColors[1];
} BITMAPCOREINFO,  *LPBITMAPCOREINFO, *PBITMAPCOREINFO;

#line 930 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\wingdi.h"
#pragma endregion

#line 1 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\shared\\pshpack2.h"
/*++

Copyright (c) Microsoft Corporation.  All rights reserved.

Module Name:

    pshpack2.h

Abstract:

    This file turns 2 byte packing of structures on.  (That is, it disables
    automatic alignment of structure fields.)  An include file is needed
    because various compilers do this in different ways.  For Microsoft
    compatible compilers, this files uses the push option to the pack pragma
    so that the poppack.h include file can restore the previous packing
    reliably.

    The file poppack.h is the complement to this file.

--*/



#pragma warning(disable:4103)

#pragma pack(push,2)


#line 30 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\shared\\pshpack2.h"


#line 33 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\shared\\pshpack2.h"
#line 34 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\shared\\pshpack2.h"
#line 933 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\wingdi.h"

#pragma region Desktop Family


typedef struct tagBITMAPFILEHEADER {
        WORD    bfType;
        DWORD   bfSize;
        WORD    bfReserved1;
        WORD    bfReserved2;
        DWORD   bfOffBits;
} BITMAPFILEHEADER,  *LPBITMAPFILEHEADER, *PBITMAPFILEHEADER;

#line 946 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\wingdi.h"
#pragma endregion

#line 1 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\shared\\poppack.h"
/*++

Copyright (c) Microsoft Corporation.  All rights reserved.

Module Name:

    poppack.h

Abstract:

    This file turns packing of structures off.  (That is, it enables
    automatic alignment of structure fields.)  An include file is needed
    because various compilers do this in different ways.

    poppack.h is the complement to pshpack?.h.  An inclusion of poppack.h
    MUST ALWAYS be preceded by an inclusion of one of pshpack?.h, in one-to-one
    correspondence.

    For Microsoft compatible compilers, this file uses the pop option
    to the pack pragma so that it can restore the previous saved by the
    pshpack?.h include file.

--*/



#pragma warning(disable:4103)

#pragma pack(pop)


#line 33 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\shared\\poppack.h"


#line 36 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\shared\\poppack.h"
#line 37 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\shared\\poppack.h"
#line 949 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\wingdi.h"






#pragma region Application Family


typedef struct tagFONTSIGNATURE
{
    DWORD fsUsb[4];
    DWORD fsCsb[2];
} FONTSIGNATURE, *PFONTSIGNATURE, *LPFONTSIGNATURE;

#line 965 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\wingdi.h"
#pragma endregion

#pragma region Desktop Family


typedef struct tagCHARSETINFO
{
    UINT ciCharset;
    UINT ciACP;
    FONTSIGNATURE fs;
} CHARSETINFO, *PCHARSETINFO,  *NPCHARSETINFO,  *LPCHARSETINFO;

#line 978 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\wingdi.h"
#pragma endregion






#line 986 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\wingdi.h"

#pragma region Application Family


typedef struct tagLOCALESIGNATURE
{
    DWORD lsUsb[4];
    DWORD lsCsbDefault[2];
    DWORD lsCsbSupported[2];
} LOCALESIGNATURE, *PLOCALESIGNATURE, *LPLOCALESIGNATURE;

#line 998 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\wingdi.h"
#pragma endregion

#line 1001 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\wingdi.h"
#line 1002 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\wingdi.h"



#pragma region Application Family


/* Clipboard Metafile Picture Structure */

typedef struct tagHANDLETABLE
  {
    HGDIOBJ     objectHandle[1];
  } HANDLETABLE, *PHANDLETABLE,  *LPHANDLETABLE;

typedef struct tagMETARECORD
  {
    DWORD       rdSize;
    WORD        rdFunction;
    WORD        rdParm[1];
  } METARECORD;

#line 1023 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\wingdi.h"
#pragma endregion

#pragma region Desktop Family


typedef struct tagMETARECORD __unaligned *PMETARECORD;

#line 1031 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\wingdi.h"
#pragma endregion

#pragma region Application Family


typedef struct tagMETARECORD __unaligned  *LPMETARECORD;

typedef struct tagMETAFILEPICT
  {
    LONG        mm;
    LONG        xExt;
    LONG        yExt;
    HMETAFILE   hMF;
  } METAFILEPICT,  *LPMETAFILEPICT;

#line 1047 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\wingdi.h"
#pragma endregion

#line 1 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\shared\\pshpack2.h"
/*++

Copyright (c) Microsoft Corporation.  All rights reserved.

Module Name:

    pshpack2.h

Abstract:

    This file turns 2 byte packing of structures on.  (That is, it disables
    automatic alignment of structure fields.)  An include file is needed
    because various compilers do this in different ways.  For Microsoft
    compatible compilers, this files uses the push option to the pack pragma
    so that the poppack.h include file can restore the previous packing
    reliably.

    The file poppack.h is the complement to this file.

--*/



#pragma warning(disable:4103)

#pragma pack(push,2)


#line 30 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\shared\\pshpack2.h"


#line 33 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\shared\\pshpack2.h"
#line 34 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\shared\\pshpack2.h"
#line 1050 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\wingdi.h"

#pragma region Desktop Family


typedef struct tagMETAHEADER
{
    WORD        mtType;
    WORD        mtHeaderSize;
    WORD        mtVersion;
    DWORD       mtSize;
    WORD        mtNoObjects;
    DWORD       mtMaxRecord;
    WORD        mtNoParameters;
} METAHEADER;
typedef struct tagMETAHEADER __unaligned *PMETAHEADER;
typedef struct tagMETAHEADER __unaligned  *LPMETAHEADER;

#line 1068 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\wingdi.h"
#pragma endregion

#line 1 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\shared\\poppack.h"
/*++

Copyright (c) Microsoft Corporation.  All rights reserved.

Module Name:

    poppack.h

Abstract:

    This file turns packing of structures off.  (That is, it enables
    automatic alignment of structure fields.)  An include file is needed
    because various compilers do this in different ways.

    poppack.h is the complement to pshpack?.h.  An inclusion of poppack.h
    MUST ALWAYS be preceded by an inclusion of one of pshpack?.h, in one-to-one
    correspondence.

    For Microsoft compatible compilers, this file uses the pop option
    to the pack pragma so that it can restore the previous saved by the
    pshpack?.h include file.

--*/



#pragma warning(disable:4103)

#pragma pack(pop)


#line 33 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\shared\\poppack.h"


#line 36 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\shared\\poppack.h"
#line 37 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\shared\\poppack.h"
#line 1071 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\wingdi.h"

#pragma region Application Family


/* Enhanced Metafile structures */
typedef struct tagENHMETARECORD
{
    DWORD   iType;              // Record type EMR_XXX
    DWORD   nSize;              // Record size in bytes
    DWORD   dParm[1];           // Parameters
} ENHMETARECORD, *PENHMETARECORD, *LPENHMETARECORD;

typedef struct tagENHMETAHEADER
{
    DWORD   iType;              // Record typeEMR_HEADER
    DWORD   nSize;              // Record size in bytes.  This may be greater
                                // than the sizeof(ENHMETAHEADER).
    RECTL   rclBounds;          // Inclusive-inclusive bounds in device units
    RECTL   rclFrame;           // Inclusive-inclusive Picture Frame of metafile in .01 mm units
    DWORD   dSignature;         // Signature.  Must be ENHMETA_SIGNATURE.
    DWORD   nVersion;           // Version number
    DWORD   nBytes;             // Size of the metafile in bytes
    DWORD   nRecords;           // Number of records in the metafile
    WORD    nHandles;           // Number of handles in the handle table
                                // Handle index zero is reserved.
    WORD    sReserved;          // Reserved.  Must be zero.
    DWORD   nDescription;       // Number of chars in the unicode description string
                                // This is 0 if there is no description string
    DWORD   offDescription;     // Offset to the metafile description record.
                                // This is 0 if there is no description string
    DWORD   nPalEntries;        // Number of entries in the metafile palette.
    SIZEL   szlDevice;          // Size of the reference device in pels
    SIZEL   szlMillimeters;     // Size of the reference device in millimeters

    DWORD   cbPixelFormat;      // Size of PIXELFORMATDESCRIPTOR information
                                // This is 0 if no pixel format is set
    DWORD   offPixelFormat;     // Offset to PIXELFORMATDESCRIPTOR
                                // This is 0 if no pixel format is set
    DWORD   bOpenGL;            // TRUE if OpenGL commands are present in
                                // the metafile, otherwise FALSE
#line 1112 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\wingdi.h"

    SIZEL   szlMicrometers;     // Size of the reference device in micrometers
#line 1115 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\wingdi.h"

} ENHMETAHEADER, *PENHMETAHEADER, *LPENHMETAHEADER;

#line 1119 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\wingdi.h"
#pragma endregion

#line 1122 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\wingdi.h"



/* tmPitchAndFamily flags */





#pragma region Desktop Family


//
// BCHAR definition for APPs
//



    typedef BYTE BCHAR;
#line 1142 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\wingdi.h"

#line 1144 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\wingdi.h"
#pragma endregion



#line 1 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\shared\\pshpack4.h"
/*++

Copyright (c) Microsoft Corporation.  All rights reserved.

Module Name:

    pshpack4.h

Abstract:

    This file turns 4 byte packing of structures on.  (That is, it disables
    automatic alignment of structure fields.)  An include file is needed
    because various compilers do this in different ways.  For Microsoft
    compatible compilers, this files uses the push option to the pack pragma
    so that the poppack.h include file can restore the previous packing
    reliably.

    The file poppack.h is the complement to this file.

--*/



#pragma warning(disable:4103)

#pragma pack(push,4)


#line 30 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\shared\\pshpack4.h"


#line 33 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\shared\\pshpack4.h"
#line 34 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\shared\\pshpack4.h"
#line 1149 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\wingdi.h"

#pragma region Application Family


typedef struct tagTEXTMETRICA
{
    LONG        tmHeight;
    LONG        tmAscent;
    LONG        tmDescent;
    LONG        tmInternalLeading;
    LONG        tmExternalLeading;
    LONG        tmAveCharWidth;
    LONG        tmMaxCharWidth;
    LONG        tmWeight;
    LONG        tmOverhang;
    LONG        tmDigitizedAspectX;
    LONG        tmDigitizedAspectY;
    BYTE        tmFirstChar;
    BYTE        tmLastChar;
    BYTE        tmDefaultChar;
    BYTE        tmBreakChar;
    BYTE        tmItalic;
    BYTE        tmUnderlined;
    BYTE        tmStruckOut;
    BYTE        tmPitchAndFamily;
    BYTE        tmCharSet;
} TEXTMETRICA, *PTEXTMETRICA,  *NPTEXTMETRICA,  *LPTEXTMETRICA;
typedef struct tagTEXTMETRICW
{
    LONG        tmHeight;
    LONG        tmAscent;
    LONG        tmDescent;
    LONG        tmInternalLeading;
    LONG        tmExternalLeading;
    LONG        tmAveCharWidth;
    LONG        tmMaxCharWidth;
    LONG        tmWeight;
    LONG        tmOverhang;
    LONG        tmDigitizedAspectX;
    LONG        tmDigitizedAspectY;
    WCHAR       tmFirstChar;
    WCHAR       tmLastChar;
    WCHAR       tmDefaultChar;
    WCHAR       tmBreakChar;
    BYTE        tmItalic;
    BYTE        tmUnderlined;
    BYTE        tmStruckOut;
    BYTE        tmPitchAndFamily;
    BYTE        tmCharSet;
} TEXTMETRICW, *PTEXTMETRICW,  *NPTEXTMETRICW,  *LPTEXTMETRICW;






typedef TEXTMETRICA TEXTMETRIC;
typedef PTEXTMETRICA PTEXTMETRIC;
typedef NPTEXTMETRICA NPTEXTMETRIC;
typedef LPTEXTMETRICA LPTEXTMETRIC;
#line 1210 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\wingdi.h"

#line 1212 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\wingdi.h"
#pragma endregion

#line 1 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\shared\\poppack.h"
/*++

Copyright (c) Microsoft Corporation.  All rights reserved.

Module Name:

    poppack.h

Abstract:

    This file turns packing of structures off.  (That is, it enables
    automatic alignment of structure fields.)  An include file is needed
    because various compilers do this in different ways.

    poppack.h is the complement to pshpack?.h.  An inclusion of poppack.h
    MUST ALWAYS be preceded by an inclusion of one of pshpack?.h, in one-to-one
    correspondence.

    For Microsoft compatible compilers, this file uses the pop option
    to the pack pragma so that it can restore the previous saved by the
    pshpack?.h include file.

--*/



#pragma warning(disable:4103)

#pragma pack(pop)


#line 33 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\shared\\poppack.h"


#line 36 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\shared\\poppack.h"
#line 37 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\shared\\poppack.h"
#line 1215 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\wingdi.h"
#line 1216 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\wingdi.h"

/* ntmFlags field flags */




/* new in NT 5.0 */








#line 1 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\shared\\pshpack4.h"
/*++

Copyright (c) Microsoft Corporation.  All rights reserved.

Module Name:

    pshpack4.h

Abstract:

    This file turns 4 byte packing of structures on.  (That is, it disables
    automatic alignment of structure fields.)  An include file is needed
    because various compilers do this in different ways.  For Microsoft
    compatible compilers, this files uses the push option to the pack pragma
    so that the poppack.h include file can restore the previous packing
    reliably.

    The file poppack.h is the complement to this file.

--*/



#pragma warning(disable:4103)

#pragma pack(push,4)


#line 30 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\shared\\pshpack4.h"


#line 33 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\shared\\pshpack4.h"
#line 34 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\shared\\pshpack4.h"
#line 1232 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\wingdi.h"

#pragma region Desktop Family


typedef struct tagNEWTEXTMETRICA
{
    LONG        tmHeight;
    LONG        tmAscent;
    LONG        tmDescent;
    LONG        tmInternalLeading;
    LONG        tmExternalLeading;
    LONG        tmAveCharWidth;
    LONG        tmMaxCharWidth;
    LONG        tmWeight;
    LONG        tmOverhang;
    LONG        tmDigitizedAspectX;
    LONG        tmDigitizedAspectY;
    BYTE        tmFirstChar;
    BYTE        tmLastChar;
    BYTE        tmDefaultChar;
    BYTE        tmBreakChar;
    BYTE        tmItalic;
    BYTE        tmUnderlined;
    BYTE        tmStruckOut;
    BYTE        tmPitchAndFamily;
    BYTE        tmCharSet;
    DWORD   ntmFlags;
    UINT    ntmSizeEM;
    UINT    ntmCellHeight;
    UINT    ntmAvgWidth;
} NEWTEXTMETRICA, *PNEWTEXTMETRICA,  *NPNEWTEXTMETRICA,  *LPNEWTEXTMETRICA;
typedef struct tagNEWTEXTMETRICW
{
    LONG        tmHeight;
    LONG        tmAscent;
    LONG        tmDescent;
    LONG        tmInternalLeading;
    LONG        tmExternalLeading;
    LONG        tmAveCharWidth;
    LONG        tmMaxCharWidth;
    LONG        tmWeight;
    LONG        tmOverhang;
    LONG        tmDigitizedAspectX;
    LONG        tmDigitizedAspectY;
    WCHAR       tmFirstChar;
    WCHAR       tmLastChar;
    WCHAR       tmDefaultChar;
    WCHAR       tmBreakChar;
    BYTE        tmItalic;
    BYTE        tmUnderlined;
    BYTE        tmStruckOut;
    BYTE        tmPitchAndFamily;
    BYTE        tmCharSet;
    DWORD   ntmFlags;
    UINT    ntmSizeEM;
    UINT    ntmCellHeight;
    UINT    ntmAvgWidth;
} NEWTEXTMETRICW, *PNEWTEXTMETRICW,  *NPNEWTEXTMETRICW,  *LPNEWTEXTMETRICW;






typedef NEWTEXTMETRICA NEWTEXTMETRIC;
typedef PNEWTEXTMETRICA PNEWTEXTMETRIC;
typedef NPNEWTEXTMETRICA NPNEWTEXTMETRIC;
typedef LPNEWTEXTMETRICA LPNEWTEXTMETRIC;
#line 1301 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\wingdi.h"

#line 1303 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\wingdi.h"
#pragma endregion

#line 1 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\shared\\poppack.h"
/*++

Copyright (c) Microsoft Corporation.  All rights reserved.

Module Name:

    poppack.h

Abstract:

    This file turns packing of structures off.  (That is, it enables
    automatic alignment of structure fields.)  An include file is needed
    because various compilers do this in different ways.

    poppack.h is the complement to pshpack?.h.  An inclusion of poppack.h
    MUST ALWAYS be preceded by an inclusion of one of pshpack?.h, in one-to-one
    correspondence.

    For Microsoft compatible compilers, this file uses the pop option
    to the pack pragma so that it can restore the previous saved by the
    pshpack?.h include file.

--*/



#pragma warning(disable:4103)

#pragma pack(pop)


#line 33 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\shared\\poppack.h"


#line 36 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\shared\\poppack.h"
#line 37 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\shared\\poppack.h"
#line 1306 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\wingdi.h"



#pragma region Desktop Family


typedef struct tagNEWTEXTMETRICEXA
{
    NEWTEXTMETRICA  ntmTm;
    FONTSIGNATURE   ntmFontSig;
}NEWTEXTMETRICEXA;
typedef struct tagNEWTEXTMETRICEXW
{
    NEWTEXTMETRICW  ntmTm;
    FONTSIGNATURE   ntmFontSig;
}NEWTEXTMETRICEXW;



typedef NEWTEXTMETRICEXA NEWTEXTMETRICEX;
#line 1327 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\wingdi.h"

#line 1329 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\wingdi.h"
#pragma endregion
#line 1331 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\wingdi.h"

#line 1333 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\wingdi.h"
/* GDI Logical Objects: */

/* Pel Array */
#pragma region Desktop Family


typedef struct tagPELARRAY
  {
    LONG        paXCount;
    LONG        paYCount;
    LONG        paXExt;
    LONG        paYExt;
    BYTE        paRGBs;
  } PELARRAY, *PPELARRAY,  *NPPELARRAY,  *LPPELARRAY;

#line 1349 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\wingdi.h"
#pragma endregion

#pragma region Application Family


/* Logical Brush (or Pattern) */
typedef struct tagLOGBRUSH
  {
    UINT        lbStyle;
    COLORREF    lbColor;
    ULONG_PTR   lbHatch;
  } LOGBRUSH, *PLOGBRUSH,  *NPLOGBRUSH,  *LPLOGBRUSH;

typedef struct tagLOGBRUSH32
  {
    UINT        lbStyle;
    COLORREF    lbColor;
    ULONG       lbHatch;
  } LOGBRUSH32, *PLOGBRUSH32,  *NPLOGBRUSH32,  *LPLOGBRUSH32;

#line 1370 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\wingdi.h"
#pragma endregion

#pragma region Desktop Family


typedef LOGBRUSH            PATTERN;
typedef PATTERN             *PPATTERN;
typedef PATTERN         *NPPATTERN;
typedef PATTERN          *LPPATTERN;

#line 1381 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\wingdi.h"
#pragma endregion

#pragma region Application Family


/* Logical Pen */
typedef struct tagLOGPEN
  {
    UINT        lopnStyle;
    POINT       lopnWidth;
    COLORREF    lopnColor;
  } LOGPEN, *PLOGPEN,  *NPLOGPEN,  *LPLOGPEN;

#line 1395 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\wingdi.h"
#pragma endregion

#pragma region Desktop Family


typedef struct tagEXTLOGPEN {
    DWORD       elpPenStyle;
    DWORD       elpWidth;
    UINT        elpBrushStyle;
    COLORREF    elpColor;
    ULONG_PTR   elpHatch;
    DWORD       elpNumEntries;
    DWORD       elpStyleEntry[1];
} EXTLOGPEN, *PEXTLOGPEN,  *NPEXTLOGPEN,  *LPEXTLOGPEN;

#line 1411 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\wingdi.h"
#pragma endregion

#pragma region Application Family


typedef struct tagEXTLOGPEN32 {
    DWORD       elpPenStyle;
    DWORD       elpWidth;
    UINT        elpBrushStyle;
    COLORREF    elpColor;
    ULONG       elpHatch;
    DWORD       elpNumEntries;
    DWORD       elpStyleEntry[1];
} EXTLOGPEN32, *PEXTLOGPEN32,  *NPEXTLOGPEN32,  *LPEXTLOGPEN32;



typedef struct tagPALETTEENTRY {
    BYTE        peRed;
    BYTE        peGreen;
    BYTE        peBlue;
    BYTE        peFlags;
} PALETTEENTRY, *PPALETTEENTRY,  *LPPALETTEENTRY;
#line 1435 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\wingdi.h"



/* Logical Palette */
typedef struct tagLOGPALETTE {
    WORD        palVersion;
    WORD        palNumEntries;
     PALETTEENTRY        palPalEntry[1];
} LOGPALETTE, *PLOGPALETTE,  *NPLOGPALETTE,  *LPLOGPALETTE;
#line 1445 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\wingdi.h"


/* Logical Font */


typedef struct tagLOGFONTA
{
    LONG      lfHeight;
    LONG      lfWidth;
    LONG      lfEscapement;
    LONG      lfOrientation;
    LONG      lfWeight;
    BYTE      lfItalic;
    BYTE      lfUnderline;
    BYTE      lfStrikeOut;
    BYTE      lfCharSet;
    BYTE      lfOutPrecision;
    BYTE      lfClipPrecision;
    BYTE      lfQuality;
    BYTE      lfPitchAndFamily;
    CHAR      lfFaceName[32 ];
} LOGFONTA, *PLOGFONTA,  *NPLOGFONTA,  *LPLOGFONTA;
typedef struct tagLOGFONTW
{
    LONG      lfHeight;
    LONG      lfWidth;
    LONG      lfEscapement;
    LONG      lfOrientation;
    LONG      lfWeight;
    BYTE      lfItalic;
    BYTE      lfUnderline;
    BYTE      lfStrikeOut;
    BYTE      lfCharSet;
    BYTE      lfOutPrecision;
    BYTE      lfClipPrecision;
    BYTE      lfQuality;
    BYTE      lfPitchAndFamily;
    WCHAR     lfFaceName[32 ];
} LOGFONTW, *PLOGFONTW,  *NPLOGFONTW,  *LPLOGFONTW;






typedef LOGFONTA LOGFONT;
typedef PLOGFONTA PLOGFONT;
typedef NPLOGFONTA NPLOGFONT;
typedef LPLOGFONTA LPLOGFONT;
#line 1495 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\wingdi.h"

#line 1497 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\wingdi.h"
#pragma endregion



#pragma region Desktop Family


/* Structure passed to FONTENUMPROC */
typedef struct tagENUMLOGFONTA
{
    LOGFONTA elfLogFont;
    BYTE     elfFullName[64 ];
    BYTE     elfStyle[32 ];
} ENUMLOGFONTA,  * LPENUMLOGFONTA;
/* Structure passed to FONTENUMPROC */
typedef struct tagENUMLOGFONTW
{
    LOGFONTW elfLogFont;
    WCHAR    elfFullName[64 ];
    WCHAR    elfStyle[32 ];
} ENUMLOGFONTW,  * LPENUMLOGFONTW;




typedef ENUMLOGFONTA ENUMLOGFONT;
typedef LPENUMLOGFONTA LPENUMLOGFONT;
#line 1525 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\wingdi.h"


typedef struct tagENUMLOGFONTEXA
{
    LOGFONTA    elfLogFont;
    BYTE        elfFullName[64 ];
    BYTE        elfStyle[32 ];
    BYTE        elfScript[32 ];
} ENUMLOGFONTEXA,  *LPENUMLOGFONTEXA;
typedef struct tagENUMLOGFONTEXW
{
    LOGFONTW    elfLogFont;
    WCHAR       elfFullName[64 ];
    WCHAR       elfStyle[32 ];
    WCHAR       elfScript[32 ];
} ENUMLOGFONTEXW,  *LPENUMLOGFONTEXW;




typedef ENUMLOGFONTEXA ENUMLOGFONTEX;
typedef LPENUMLOGFONTEXA LPENUMLOGFONTEX;
#line 1548 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\wingdi.h"
#line 1549 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\wingdi.h"

#line 1551 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\wingdi.h"
#pragma endregion





















#line 1574 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\wingdi.h"








#line 1583 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\wingdi.h"




#line 1588 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\wingdi.h"






#line 1595 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\wingdi.h"








































#line 1636 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\wingdi.h"

/* Font Families */


                                    /* Times Roman, Century Schoolbook, etc. */

                                    /* Helvetica, Swiss, etc. */

                                    /* Pica, Elite, Courier, etc. */



/* Font Weights */































#pragma region Application Family


typedef struct tagPANOSE
{
    BYTE    bFamilyType;
    BYTE    bSerifStyle;
    BYTE    bWeight;
    BYTE    bProportion;
    BYTE    bContrast;
    BYTE    bStrokeVariation;
    BYTE    bArmStyle;
    BYTE    bLetterform;
    BYTE    bMidline;
    BYTE    bXHeight;
} PANOSE, * LPPANOSE;














































































































/* The extended logical font       */
/* An extension of the ENUMLOGFONT */

typedef struct tagEXTLOGFONTA {
    LOGFONTA    elfLogFont;
    BYTE        elfFullName[64 ];
    BYTE        elfStyle[32 ];
    DWORD       elfVersion;     /* 0 for the first release of NT */
    DWORD       elfStyleSize;
    DWORD       elfMatch;
    DWORD       elfReserved;
    BYTE        elfVendorId[4 ];
    DWORD       elfCulture;     /* 0 for Latin                   */
    PANOSE      elfPanose;
} EXTLOGFONTA, *PEXTLOGFONTA,  *NPEXTLOGFONTA,  *LPEXTLOGFONTA;
typedef struct tagEXTLOGFONTW {
    LOGFONTW    elfLogFont;
    WCHAR       elfFullName[64 ];
    WCHAR       elfStyle[32 ];
    DWORD       elfVersion;     /* 0 for the first release of NT */
    DWORD       elfStyleSize;
    DWORD       elfMatch;
    DWORD       elfReserved;
    BYTE        elfVendorId[4 ];
    DWORD       elfCulture;     /* 0 for Latin                   */
    PANOSE      elfPanose;
} EXTLOGFONTW, *PEXTLOGFONTW,  *NPEXTLOGFONTW,  *LPEXTLOGFONTW;






typedef EXTLOGFONTA EXTLOGFONT;
typedef PEXTLOGFONTA PEXTLOGFONT;
typedef NPEXTLOGFONTA NPEXTLOGFONT;
typedef LPEXTLOGFONTA LPEXTLOGFONT;
#line 1844 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\wingdi.h"

#line 1846 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\wingdi.h"
#pragma endregion




/* EnumFonts Masks */








/* palette entry flags */









/* Background Modes */




/* Graphics Modes */





/* PolyDraw and GetPath point types */





/* Mapping Modes */









/* Min and Max Mapping Mode values */




/* Coordinate Modes */



/* Stock Logical Objects */




















#line 1928 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\wingdi.h"




#line 1933 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\wingdi.h"







#line 1941 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\wingdi.h"



/* Brush Styles */












/* Hatch Styles */








/* Pen Styles */




























/* Device Parameters for GetDeviceCaps() */































// Printing related DeviceCaps. These replace the appropriate Escapes








// Display driver specific


                             /* display device (for displays only) in Hz*/

                             /* pixels                                  */

                             /* pixels                                  */





#line 2050 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\wingdi.h"



/* Device Capability Masks: */

/* Device Technologies */








/* Curve Capabilities */











/* Line Capabilities */









/* Polygonal Capabilities */













/* Clipping Capabilities */




/* Text Capabilities */


















#line 2125 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\wingdi.h"

/* Raster Capabilities */




















/* Shading and blending caps */








/* Color Management caps */





#line 2163 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\wingdi.h"


/* DIB color table identifiers */




/* constants for Get/SetSystemPaletteUse() */






/* constants for CreateDIBitmap */



/* ExtFloodFill style flags */



/* size of a device name string */


/* size of a form name string */


#pragma region Application Family



typedef struct _devicemodeA {
    BYTE   dmDeviceName[32 ];
    WORD dmSpecVersion;
    WORD dmDriverVersion;
    WORD dmSize;
    WORD dmDriverExtra;
    DWORD dmFields;
    union {
      /* printer only fields */
      struct {
        short dmOrientation;
        short dmPaperSize;
        short dmPaperLength;
        short dmPaperWidth;
        short dmScale;
        short dmCopies;
        short dmDefaultSource;
        short dmPrintQuality;
      }  ;
      /* display only fields */
      struct {
        POINTL dmPosition;
        DWORD  dmDisplayOrientation;
        DWORD  dmDisplayFixedOutput;
      }  ;
    }  ;
    short dmColor;
    short dmDuplex;
    short dmYResolution;
    short dmTTOption;
    short dmCollate;
    BYTE   dmFormName[32 ];
    WORD   dmLogPixels;
    DWORD  dmBitsPerPel;
    DWORD  dmPelsWidth;
    DWORD  dmPelsHeight;
    union {
        DWORD  dmDisplayFlags;
        DWORD  dmNup;
    }  ;
    DWORD  dmDisplayFrequency;

    DWORD  dmICMMethod;
    DWORD  dmICMIntent;
    DWORD  dmMediaType;
    DWORD  dmDitherType;
    DWORD  dmReserved1;
    DWORD  dmReserved2;

    DWORD  dmPanningWidth;
    DWORD  dmPanningHeight;
#line 2247 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\wingdi.h"
#line 2248 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\wingdi.h"
} DEVMODEA, *PDEVMODEA, *NPDEVMODEA, *LPDEVMODEA;
typedef struct _devicemodeW {
    WCHAR  dmDeviceName[32 ];
    WORD dmSpecVersion;
    WORD dmDriverVersion;
    WORD dmSize;
    WORD dmDriverExtra;
    DWORD dmFields;
    union {
      /* printer only fields */
      struct {
        short dmOrientation;
        short dmPaperSize;
        short dmPaperLength;
        short dmPaperWidth;
        short dmScale;
        short dmCopies;
        short dmDefaultSource;
        short dmPrintQuality;
      }  ;
      /* display only fields */
      struct {
        POINTL dmPosition;
        DWORD  dmDisplayOrientation;
        DWORD  dmDisplayFixedOutput;
      }  ;
    }  ;
    short dmColor;
    short dmDuplex;
    short dmYResolution;
    short dmTTOption;
    short dmCollate;
    WCHAR  dmFormName[32 ];
    WORD   dmLogPixels;
    DWORD  dmBitsPerPel;
    DWORD  dmPelsWidth;
    DWORD  dmPelsHeight;
    union {
        DWORD  dmDisplayFlags;
        DWORD  dmNup;
    }  ;
    DWORD  dmDisplayFrequency;

    DWORD  dmICMMethod;
    DWORD  dmICMIntent;
    DWORD  dmMediaType;
    DWORD  dmDitherType;
    DWORD  dmReserved1;
    DWORD  dmReserved2;

    DWORD  dmPanningWidth;
    DWORD  dmPanningHeight;
#line 2301 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\wingdi.h"
#line 2302 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\wingdi.h"
} DEVMODEW, *PDEVMODEW, *NPDEVMODEW, *LPDEVMODEW;






typedef DEVMODEA DEVMODE;
typedef PDEVMODEA PDEVMODE;
typedef NPDEVMODEA NPDEVMODE;
typedef LPDEVMODEA LPDEVMODE;
#line 2314 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\wingdi.h"












































































































#line 2423 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\wingdi.h"

#line 2425 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\wingdi.h"
#pragma endregion

/* current version of specification */






#line 2435 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\wingdi.h"

/* field selection bits */








#line 2446 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\wingdi.h"


#line 2449 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\wingdi.h"






















#line 2472 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\wingdi.h"


#line 2475 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\wingdi.h"


/* orientation selections */



/* paper selections */






































































#line 2553 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\wingdi.h"




















































#line 2606 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\wingdi.h"







#line 2614 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\wingdi.h"



/* bin selections */



















/* print qualities */





/* color enable/disable for color printers */



/* duplex enable */




/* TrueType options */





#line 2659 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\wingdi.h"

/* Collation selections */




/* DEVMODE dmDisplayOrientation specifiations */





/* DEVMODE dmDisplayFixedOutput specifiations */



#line 2676 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\wingdi.h"

/* DEVMODE dmDisplayFlags flags */

// #define DM_GRAYSCALE            0x00000001 /* This flag is no longer valid */



/* dmNup , multiple logical page per physical page options */




/* ICM methods */







/* ICM Intents */







/* Media types */







/* Dither types */












#line 2726 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\wingdi.h"

#pragma region Application Family


typedef struct _DISPLAY_DEVICEA {
    DWORD  cb;
    CHAR   DeviceName[32];
    CHAR   DeviceString[128];
    DWORD  StateFlags;
    CHAR   DeviceID[128];
    CHAR   DeviceKey[128];
} DISPLAY_DEVICEA, *PDISPLAY_DEVICEA, *LPDISPLAY_DEVICEA;
typedef struct _DISPLAY_DEVICEW {
    DWORD  cb;
    WCHAR  DeviceName[32];
    WCHAR  DeviceString[128];
    DWORD  StateFlags;
    WCHAR  DeviceID[128];
    WCHAR  DeviceKey[128];
} DISPLAY_DEVICEW, *PDISPLAY_DEVICEW, *LPDISPLAY_DEVICEW;





typedef DISPLAY_DEVICEA DISPLAY_DEVICE;
typedef PDISPLAY_DEVICEA PDISPLAY_DEVICE;
typedef LPDISPLAY_DEVICEA LPDISPLAY_DEVICE;
#line 2755 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\wingdi.h"

#line 2757 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\wingdi.h"
#pragma endregion








#line 2767 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\wingdi.h"


#line 2770 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\wingdi.h"





#line 2776 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\wingdi.h"



#line 2780 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\wingdi.h"

/* Child device state */



#line 2786 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\wingdi.h"




                                          // Max adapter (16) * Max source (16) *
                                          // Max clone pre source (4)

#pragma region Application Family


typedef struct DISPLAYCONFIG_RATIONAL
{
    UINT32    Numerator;
    UINT32    Denominator;
} DISPLAYCONFIG_RATIONAL;

typedef enum
{
    DISPLAYCONFIG_OUTPUT_TECHNOLOGY_OTHER                   = -1,
    DISPLAYCONFIG_OUTPUT_TECHNOLOGY_HD15                    =  0,
    DISPLAYCONFIG_OUTPUT_TECHNOLOGY_SVIDEO                  =  1,
    DISPLAYCONFIG_OUTPUT_TECHNOLOGY_COMPOSITE_VIDEO         =  2,
    DISPLAYCONFIG_OUTPUT_TECHNOLOGY_COMPONENT_VIDEO         =  3,
    DISPLAYCONFIG_OUTPUT_TECHNOLOGY_DVI                     =  4,
    DISPLAYCONFIG_OUTPUT_TECHNOLOGY_HDMI                    =  5,
    DISPLAYCONFIG_OUTPUT_TECHNOLOGY_LVDS                    =  6,
    DISPLAYCONFIG_OUTPUT_TECHNOLOGY_D_JPN                   =  8,
    DISPLAYCONFIG_OUTPUT_TECHNOLOGY_SDI                     =  9,
    DISPLAYCONFIG_OUTPUT_TECHNOLOGY_DISPLAYPORT_EXTERNAL    = 10,
    DISPLAYCONFIG_OUTPUT_TECHNOLOGY_DISPLAYPORT_EMBEDDED    = 11,
    DISPLAYCONFIG_OUTPUT_TECHNOLOGY_UDI_EXTERNAL            = 12,
    DISPLAYCONFIG_OUTPUT_TECHNOLOGY_UDI_EMBEDDED            = 13,
    DISPLAYCONFIG_OUTPUT_TECHNOLOGY_SDTVDONGLE              = 14,
    DISPLAYCONFIG_OUTPUT_TECHNOLOGY_MIRACAST                = 15,
    DISPLAYCONFIG_OUTPUT_TECHNOLOGY_INDIRECT_WIRED          = 16,
    DISPLAYCONFIG_OUTPUT_TECHNOLOGY_INDIRECT_VIRTUAL        = 17,
    DISPLAYCONFIG_OUTPUT_TECHNOLOGY_INTERNAL                = 0x80000000,
    DISPLAYCONFIG_OUTPUT_TECHNOLOGY_FORCE_UINT32            = 0xFFFFFFFF
} DISPLAYCONFIG_VIDEO_OUTPUT_TECHNOLOGY;

typedef enum
{
    DISPLAYCONFIG_SCANLINE_ORDERING_UNSPECIFIED                 = 0,
    DISPLAYCONFIG_SCANLINE_ORDERING_PROGRESSIVE                 = 1,
    DISPLAYCONFIG_SCANLINE_ORDERING_INTERLACED                  = 2,
    DISPLAYCONFIG_SCANLINE_ORDERING_INTERLACED_UPPERFIELDFIRST  = DISPLAYCONFIG_SCANLINE_ORDERING_INTERLACED,
    DISPLAYCONFIG_SCANLINE_ORDERING_INTERLACED_LOWERFIELDFIRST  = 3,
    DISPLAYCONFIG_SCANLINE_ORDERING_FORCE_UINT32                = 0xFFFFFFFF
} DISPLAYCONFIG_SCANLINE_ORDERING;

typedef struct DISPLAYCONFIG_2DREGION
{
    UINT32 cx;
    UINT32 cy;
} DISPLAYCONFIG_2DREGION;

typedef struct DISPLAYCONFIG_VIDEO_SIGNAL_INFO
{
    UINT64                          pixelRate;
    DISPLAYCONFIG_RATIONAL          hSyncFreq;
    DISPLAYCONFIG_RATIONAL          vSyncFreq;
    DISPLAYCONFIG_2DREGION          activeSize;
    DISPLAYCONFIG_2DREGION          totalSize;

    union
    {
        struct
        {
            UINT32 videoStandard : 16;

            // Vertical refresh frequency divider
            UINT32 vSyncFreqDivider : 6;

            UINT32 reserved : 10;
        } AdditionalSignalInfo;

        UINT32 videoStandard;
    }  ;

    // Scan line ordering (e.g. progressive, interlaced).
    DISPLAYCONFIG_SCANLINE_ORDERING scanLineOrdering;
} DISPLAYCONFIG_VIDEO_SIGNAL_INFO;

typedef enum
{
    DISPLAYCONFIG_SCALING_IDENTITY                  = 1,
    DISPLAYCONFIG_SCALING_CENTERED                  = 2,
    DISPLAYCONFIG_SCALING_STRETCHED                 = 3,
    DISPLAYCONFIG_SCALING_ASPECTRATIOCENTEREDMAX    = 4,
    DISPLAYCONFIG_SCALING_CUSTOM                    = 5,
    DISPLAYCONFIG_SCALING_PREFERRED                 = 128,
    DISPLAYCONFIG_SCALING_FORCE_UINT32              = 0xFFFFFFFF
} DISPLAYCONFIG_SCALING;

typedef enum
{
    DISPLAYCONFIG_ROTATION_IDENTITY     = 1,
    DISPLAYCONFIG_ROTATION_ROTATE90     = 2,
    DISPLAYCONFIG_ROTATION_ROTATE180    = 3,
    DISPLAYCONFIG_ROTATION_ROTATE270    = 4,
    DISPLAYCONFIG_ROTATION_FORCE_UINT32 = 0xFFFFFFFF
} DISPLAYCONFIG_ROTATION;

typedef enum
{
    DISPLAYCONFIG_MODE_INFO_TYPE_SOURCE        = 1,
    DISPLAYCONFIG_MODE_INFO_TYPE_TARGET        = 2,
    DISPLAYCONFIG_MODE_INFO_TYPE_DESKTOP_IMAGE = 3,
    DISPLAYCONFIG_MODE_INFO_TYPE_FORCE_UINT32 = 0xFFFFFFFF
} DISPLAYCONFIG_MODE_INFO_TYPE;

typedef enum
{
    DISPLAYCONFIG_PIXELFORMAT_8BPP          = 1,
    DISPLAYCONFIG_PIXELFORMAT_16BPP         = 2,
    DISPLAYCONFIG_PIXELFORMAT_24BPP         = 3,
    DISPLAYCONFIG_PIXELFORMAT_32BPP         = 4,
    DISPLAYCONFIG_PIXELFORMAT_NONGDI        = 5,
    DISPLAYCONFIG_PIXELFORMAT_FORCE_UINT32  = 0xffffffff
} DISPLAYCONFIG_PIXELFORMAT;

typedef struct DISPLAYCONFIG_SOURCE_MODE
{
    UINT32                      width;
    UINT32                      height;
    DISPLAYCONFIG_PIXELFORMAT   pixelFormat;
    POINTL                      position;
} DISPLAYCONFIG_SOURCE_MODE;

typedef struct DISPLAYCONFIG_TARGET_MODE
{
    DISPLAYCONFIG_VIDEO_SIGNAL_INFO   targetVideoSignalInfo;
} DISPLAYCONFIG_TARGET_MODE;

typedef struct DISPLAYCONFIG_DESKTOP_IMAGE_INFO
{
    POINTL PathSourceSize;
    RECTL DesktopImageRegion;
    RECTL DesktopImageClip;
} DISPLAYCONFIG_DESKTOP_IMAGE_INFO;

typedef struct DISPLAYCONFIG_MODE_INFO
{
    DISPLAYCONFIG_MODE_INFO_TYPE    infoType;
    UINT32                          id;
    LUID                            adapterId;
    union
    {
        DISPLAYCONFIG_TARGET_MODE   targetMode;
        DISPLAYCONFIG_SOURCE_MODE   sourceMode;
        DISPLAYCONFIG_DESKTOP_IMAGE_INFO    desktopImageInfo;
    }  ;
} DISPLAYCONFIG_MODE_INFO;







typedef struct DISPLAYCONFIG_PATH_SOURCE_INFO
{
    LUID    adapterId;
    UINT32  id;
    union
    {
        UINT32 modeInfoIdx;
        struct
        {
            UINT32 cloneGroupId       : 16;
            UINT32 sourceModeInfoIdx  : 16;
        }  ;
    }  ;

    UINT32  statusFlags;
} DISPLAYCONFIG_PATH_SOURCE_INFO;

//
// Flags for source info structure (from OS to application through QDC)
//



typedef struct DISPLAYCONFIG_PATH_TARGET_INFO
{
    LUID                                    adapterId;
    UINT32                                  id;
    union
    {
        UINT32                                  modeInfoIdx;
        struct
        {
            UINT32 desktopModeInfoIdx : 16;
            UINT32 targetModeInfoIdx  : 16;
        }  ;
    }  ;
    DISPLAYCONFIG_VIDEO_OUTPUT_TECHNOLOGY   outputTechnology;
    DISPLAYCONFIG_ROTATION                  rotation;
    DISPLAYCONFIG_SCALING                   scaling;
    DISPLAYCONFIG_RATIONAL                  refreshRate;
    DISPLAYCONFIG_SCANLINE_ORDERING         scanLineOrdering;
    BOOL                                    targetAvailable;
    UINT32                                  statusFlags;
} DISPLAYCONFIG_PATH_TARGET_INFO;

//
// Status flags for target info structure (from OS to application through QDC)
//







typedef struct DISPLAYCONFIG_PATH_INFO
{
    DISPLAYCONFIG_PATH_SOURCE_INFO  sourceInfo;
    DISPLAYCONFIG_PATH_TARGET_INFO  targetInfo;
    UINT32                          flags;
} DISPLAYCONFIG_PATH_INFO;

//
// Flags for path info structure (from OS to application through QDC)
//






typedef enum DISPLAYCONFIG_TOPOLOGY_ID
{
      DISPLAYCONFIG_TOPOLOGY_INTERNAL       = 0x00000001,
      DISPLAYCONFIG_TOPOLOGY_CLONE          = 0x00000002,
      DISPLAYCONFIG_TOPOLOGY_EXTEND         = 0x00000004,
      DISPLAYCONFIG_TOPOLOGY_EXTERNAL       = 0x00000008,
      DISPLAYCONFIG_TOPOLOGY_FORCE_UINT32   = 0xFFFFFFFF
} DISPLAYCONFIG_TOPOLOGY_ID;


typedef enum
{
      DISPLAYCONFIG_DEVICE_INFO_GET_SOURCE_NAME                 = 1,
      DISPLAYCONFIG_DEVICE_INFO_GET_TARGET_NAME                 = 2,
      DISPLAYCONFIG_DEVICE_INFO_GET_TARGET_PREFERRED_MODE       = 3,
      DISPLAYCONFIG_DEVICE_INFO_GET_ADAPTER_NAME                = 4,
      DISPLAYCONFIG_DEVICE_INFO_SET_TARGET_PERSISTENCE          = 5,
      DISPLAYCONFIG_DEVICE_INFO_GET_TARGET_BASE_TYPE            = 6,
      DISPLAYCONFIG_DEVICE_INFO_GET_SUPPORT_VIRTUAL_RESOLUTION  = 7,
      DISPLAYCONFIG_DEVICE_INFO_SET_SUPPORT_VIRTUAL_RESOLUTION  = 8,
      DISPLAYCONFIG_DEVICE_INFO_GET_ADVANCED_COLOR_INFO         = 9,
      DISPLAYCONFIG_DEVICE_INFO_SET_ADVANCED_COLOR_STATE        = 10,
      DISPLAYCONFIG_DEVICE_INFO_GET_SDR_WHITE_LEVEL             = 11,
      DISPLAYCONFIG_DEVICE_INFO_FORCE_UINT32                = 0xFFFFFFFF
} DISPLAYCONFIG_DEVICE_INFO_TYPE;


#line 3045 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\wingdi.h"
#pragma endregion


#pragma region Application Family


typedef struct DISPLAYCONFIG_DEVICE_INFO_HEADER
{
    DISPLAYCONFIG_DEVICE_INFO_TYPE  type;
    UINT32                          size;
    LUID                            adapterId;
    UINT32                          id;
} DISPLAYCONFIG_DEVICE_INFO_HEADER;

#line 3060 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\wingdi.h"
#pragma endregion

#pragma region Desktop Family


typedef struct DISPLAYCONFIG_SOURCE_DEVICE_NAME
{
    DISPLAYCONFIG_DEVICE_INFO_HEADER            header;
    WCHAR                                       viewGdiDeviceName[32 ];
} DISPLAYCONFIG_SOURCE_DEVICE_NAME;

typedef struct DISPLAYCONFIG_TARGET_DEVICE_NAME_FLAGS
{
    union
    {
        struct
        {
            UINT32  friendlyNameFromEdid : 1;
            UINT32  friendlyNameForced : 1;
            UINT32  edidIdsValid : 1;
            UINT32  reserved : 29;
        }  ;
        UINT32  value;
    }  ;
} DISPLAYCONFIG_TARGET_DEVICE_NAME_FLAGS;

typedef struct DISPLAYCONFIG_TARGET_DEVICE_NAME
{
    DISPLAYCONFIG_DEVICE_INFO_HEADER            header;
    DISPLAYCONFIG_TARGET_DEVICE_NAME_FLAGS      flags;
    DISPLAYCONFIG_VIDEO_OUTPUT_TECHNOLOGY       outputTechnology;
    UINT16                                      edidManufactureId;
    UINT16                                      edidProductCodeId;
    UINT32                                      connectorInstance;
    WCHAR                                       monitorFriendlyDeviceName[64];
    WCHAR                                       monitorDevicePath[128];
} DISPLAYCONFIG_TARGET_DEVICE_NAME;

typedef struct DISPLAYCONFIG_TARGET_PREFERRED_MODE
{
    DISPLAYCONFIG_DEVICE_INFO_HEADER    header;
    UINT32                              width;
    UINT32                              height;
    DISPLAYCONFIG_TARGET_MODE           targetMode;
} DISPLAYCONFIG_TARGET_PREFERRED_MODE;

typedef struct DISPLAYCONFIG_ADAPTER_NAME
{
    DISPLAYCONFIG_DEVICE_INFO_HEADER    header;
    WCHAR                               adapterDevicePath[128];
} DISPLAYCONFIG_ADAPTER_NAME;

typedef struct DISPLAYCONFIG_TARGET_BASE_TYPE {
    DISPLAYCONFIG_DEVICE_INFO_HEADER      header;
    DISPLAYCONFIG_VIDEO_OUTPUT_TECHNOLOGY baseOutputTechnology;
} DISPLAYCONFIG_TARGET_BASE_TYPE;


typedef struct DISPLAYCONFIG_SET_TARGET_PERSISTENCE
{
    DISPLAYCONFIG_DEVICE_INFO_HEADER    header;
    union
    {
        struct
        {
            UINT32 bootPersistenceOn    : 1;
            UINT32 reserved             : 31;
        }  ;
        UINT32 value;
    }  ;
} DISPLAYCONFIG_SET_TARGET_PERSISTENCE;

typedef struct DISPLAYCONFIG_SUPPORT_VIRTUAL_RESOLUTION
{
    DISPLAYCONFIG_DEVICE_INFO_HEADER    header;
    union
    {
        struct
        {
            UINT32 disableMonitorVirtualResolution  : 1;
            UINT32 reserved                         : 31;
        }  ;
        UINT32 value;
    }  ;
} DISPLAYCONFIG_SUPPORT_VIRTUAL_RESOLUTION;

typedef enum _DISPLAYCONFIG_COLOR_ENCODING
{
    DISPLAYCONFIG_COLOR_ENCODING_RGB           = 0,
    DISPLAYCONFIG_COLOR_ENCODING_YCBCR444      = 1,
    DISPLAYCONFIG_COLOR_ENCODING_YCBCR422      = 2,
    DISPLAYCONFIG_COLOR_ENCODING_YCBCR420      = 3,
    DISPLAYCONFIG_COLOR_ENCODING_INTENSITY     = 4,
    DISPLAYCONFIG_COLOR_ENCODING_FORCE_UINT32  = 0xFFFFFFFF
} DISPLAYCONFIG_COLOR_ENCODING;

typedef struct _DISPLAYCONFIG_GET_ADVANCED_COLOR_INFO
{
    DISPLAYCONFIG_DEVICE_INFO_HEADER header;
    union
    {
        struct
        {
          UINT32 advancedColorSupported        :1;    // A type of advanced color is supported
          UINT32 advancedColorEnabled          :1;    // A type of advanced color is enabled
          UINT32 wideColorEnforced             :1;    // Wide color gamut is enabled
          UINT32 advancedColorForceDisabled    :1;    // Advanced color is force disabled due to system/OS policy
          UINT32 reserved                      :28;
        }  ;

        UINT32 value;
    }  ;

    DISPLAYCONFIG_COLOR_ENCODING colorEncoding;
    UINT32 bitsPerColorChannel;
} DISPLAYCONFIG_GET_ADVANCED_COLOR_INFO;

typedef struct _DISPLAYCONFIG_SET_ADVANCED_COLOR_STATE
{
    DISPLAYCONFIG_DEVICE_INFO_HEADER header;
    union
    {
        struct
        {
          UINT32 enableAdvancedColor  :1;
          UINT32 reserved  :31;
        }  ;

        UINT32 value;
    } ;
} DISPLAYCONFIG_SET_ADVANCED_COLOR_STATE;

typedef struct _DISPLAYCONFIG_SDR_WHITE_LEVEL
{
    DISPLAYCONFIG_DEVICE_INFO_HEADER header;

    // SDRWhiteLevel represents a multiplier for standard SDR white
    // peak value i.e. 80 nits represented as fixed point.
    // To get value in nits use the following conversion
    // SDRWhiteLevel in nits = (SDRWhiteLevel / 1000 ) * 80
    ULONG SDRWhiteLevel;
} DISPLAYCONFIG_SDR_WHITE_LEVEL;

#line 3204 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\wingdi.h"
#pragma endregion


//
// Definitions to be used by GetDisplayConfigBufferSizes and QueryDisplayConfig.
//







//
// Definitions used by SetDisplayConfig.
//




















#line 3241 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\wingdi.h"

/* GetRegionData/ExtCreateRegion */



#pragma region Application Family


typedef struct _RGNDATAHEADER {
    DWORD   dwSize;
    DWORD   iType;
    DWORD   nCount;
    DWORD   nRgnSize;
    RECT    rcBound;
} RGNDATAHEADER, *PRGNDATAHEADER;

typedef struct _RGNDATA {
    RGNDATAHEADER   rdh;
    char            Buffer[1];
} RGNDATA, *PRGNDATA,  *NPRGNDATA,  *LPRGNDATA;

#line 3263 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\wingdi.h"
#pragma endregion


/* for GetRandomRgn */



#pragma region Desktop Family


typedef struct _ABC {
    int     abcA;
    UINT    abcB;
    int     abcC;
} ABC, *PABC,  *NPABC,  *LPABC;

typedef struct _ABCFLOAT {
    FLOAT   abcfA;
    FLOAT   abcfB;
    FLOAT   abcfC;
} ABCFLOAT, *PABCFLOAT,  *NPABCFLOAT,  *LPABCFLOAT;

#line 3286 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\wingdi.h"
#pragma endregion







#pragma region Desktop Family


typedef struct _OUTLINETEXTMETRICA {
    UINT    otmSize;
    TEXTMETRICA otmTextMetrics;
    BYTE    otmFiller;
    PANOSE  otmPanoseNumber;
    UINT    otmfsSelection;
    UINT    otmfsType;
     int    otmsCharSlopeRise;
     int    otmsCharSlopeRun;
     int    otmItalicAngle;
    UINT    otmEMSquare;
     int    otmAscent;
     int    otmDescent;
    UINT    otmLineGap;
    UINT    otmsCapEmHeight;
    UINT    otmsXHeight;
    RECT    otmrcFontBox;
     int    otmMacAscent;
     int    otmMacDescent;
    UINT    otmMacLineGap;
    UINT    otmusMinimumPPEM;
    POINT   otmptSubscriptSize;
    POINT   otmptSubscriptOffset;
    POINT   otmptSuperscriptSize;
    POINT   otmptSuperscriptOffset;
    UINT    otmsStrikeoutSize;
     int    otmsStrikeoutPosition;
     int    otmsUnderscoreSize;
     int    otmsUnderscorePosition;
    PSTR    otmpFamilyName;
    PSTR    otmpFaceName;
    PSTR    otmpStyleName;
    PSTR    otmpFullName;
} OUTLINETEXTMETRICA, *POUTLINETEXTMETRICA,  *NPOUTLINETEXTMETRICA,  *LPOUTLINETEXTMETRICA;
typedef struct _OUTLINETEXTMETRICW {
    UINT    otmSize;
    TEXTMETRICW otmTextMetrics;
    BYTE    otmFiller;
    PANOSE  otmPanoseNumber;
    UINT    otmfsSelection;
    UINT    otmfsType;
     int    otmsCharSlopeRise;
     int    otmsCharSlopeRun;
     int    otmItalicAngle;
    UINT    otmEMSquare;
     int    otmAscent;
     int    otmDescent;
    UINT    otmLineGap;
    UINT    otmsCapEmHeight;
    UINT    otmsXHeight;
    RECT    otmrcFontBox;
     int    otmMacAscent;
     int    otmMacDescent;
    UINT    otmMacLineGap;
    UINT    otmusMinimumPPEM;
    POINT   otmptSubscriptSize;
    POINT   otmptSubscriptOffset;
    POINT   otmptSuperscriptSize;
    POINT   otmptSuperscriptOffset;
    UINT    otmsStrikeoutSize;
     int    otmsStrikeoutPosition;
     int    otmsUnderscoreSize;
     int    otmsUnderscorePosition;
    PSTR    otmpFamilyName;
    PSTR    otmpFaceName;
    PSTR    otmpStyleName;
    PSTR    otmpFullName;
} OUTLINETEXTMETRICW, *POUTLINETEXTMETRICW,  *NPOUTLINETEXTMETRICW,  *LPOUTLINETEXTMETRICW;






typedef OUTLINETEXTMETRICA OUTLINETEXTMETRIC;
typedef POUTLINETEXTMETRICA POUTLINETEXTMETRIC;
typedef NPOUTLINETEXTMETRICA NPOUTLINETEXTMETRIC;
typedef LPOUTLINETEXTMETRICA LPOUTLINETEXTMETRIC;
#line 3376 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\wingdi.h"

#line 3378 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\wingdi.h"
#pragma endregion





#line 3385 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\wingdi.h"

#pragma region Application Family


typedef struct tagPOLYTEXTA
{
    int       x;
    int       y;
    UINT      n;
    LPCSTR    lpstr;
    UINT      uiFlags;
    RECT      rcl;
    int      *pdx;
} POLYTEXTA, *PPOLYTEXTA,  *NPPOLYTEXTA,  *LPPOLYTEXTA;
typedef struct tagPOLYTEXTW
{
    int       x;
    int       y;
    UINT      n;
    LPCWSTR   lpstr;
    UINT      uiFlags;
    RECT      rcl;
    int      *pdx;
} POLYTEXTW, *PPOLYTEXTW,  *NPPOLYTEXTW,  *LPPOLYTEXTW;






typedef POLYTEXTA POLYTEXT;
typedef PPOLYTEXTA PPOLYTEXT;
typedef NPPOLYTEXTA NPPOLYTEXT;
typedef LPPOLYTEXTA LPPOLYTEXT;
#line 3420 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\wingdi.h"

#line 3422 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\wingdi.h"
#pragma endregion

#pragma region Desktop Family


typedef struct _FIXED {

    WORD    fract;
    short   value;



#line 3435 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\wingdi.h"
} FIXED;


typedef struct _MAT2 {
     FIXED  eM11;
     FIXED  eM12;
     FIXED  eM21;
     FIXED  eM22;
} MAT2,  *LPMAT2;



typedef struct _GLYPHMETRICS {
    UINT    gmBlackBoxX;
    UINT    gmBlackBoxY;
    POINT   gmptGlyphOrigin;
    short   gmCellIncX;
    short   gmCellIncY;
} GLYPHMETRICS,  *LPGLYPHMETRICS;

#line 3456 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\wingdi.h"
#pragma endregion

//  GetGlyphOutline constants











#line 3471 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\wingdi.h"



#line 3475 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\wingdi.h"







#pragma region Desktop Family


typedef struct tagPOINTFX
{
    FIXED x;
    FIXED y;
} POINTFX,  * LPPOINTFX;

typedef struct tagTTPOLYCURVE
{
    WORD    wType;
    WORD    cpfx;
    POINTFX apfx[1];
} TTPOLYCURVE,  * LPTTPOLYCURVE;

typedef struct tagTTPOLYGONHEADER
{
    DWORD   cb;
    DWORD   dwType;
    POINTFX pfxStart;
} TTPOLYGONHEADER,  * LPTTPOLYGONHEADER;

#line 3506 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\wingdi.h"
#pragma endregion








////#define GCP_GLYPHINDEXING  0x0080






////#define GCP_NODIACRITICS   0x00020000L





























#pragma region Desktop Family


typedef struct tagGCP_RESULTSA
    {
    DWORD   lStructSize;
    LPSTR     lpOutString;
    UINT  *lpOrder;
    int   *lpDx;
    int   *lpCaretPos;
    LPSTR   lpClass;
    LPWSTR  lpGlyphs;
    UINT    nGlyphs;
    int     nMaxFit;
    } GCP_RESULTSA,  * LPGCP_RESULTSA;
typedef struct tagGCP_RESULTSW
    {
    DWORD   lStructSize;
    LPWSTR    lpOutString;
    UINT  *lpOrder;
    int   *lpDx;
    int   *lpCaretPos;
    LPSTR   lpClass;
    LPWSTR  lpGlyphs;
    UINT    nGlyphs;
    int     nMaxFit;
    } GCP_RESULTSW,  * LPGCP_RESULTSW;




typedef GCP_RESULTSA GCP_RESULTS;
typedef LPGCP_RESULTSA LPGCP_RESULTS;
#line 3586 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\wingdi.h"

#line 3588 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\wingdi.h"
#pragma endregion
#line 3590 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\wingdi.h"

#pragma region Desktop Family


typedef struct _RASTERIZER_STATUS {
    short   nSize;
    short   wFlags;
    short   nLanguageID;
} RASTERIZER_STATUS,  *LPRASTERIZER_STATUS;

#line 3601 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\wingdi.h"
#pragma endregion

/* bits defined in wFlags of RASTERIZER_STATUS */



#pragma region Application Family


/* Pixel format descriptor */
typedef struct tagPIXELFORMATDESCRIPTOR
{
    WORD  nSize;
    WORD  nVersion;
    DWORD dwFlags;
    BYTE  iPixelType;
    BYTE  cColorBits;
    BYTE  cRedBits;
    BYTE  cRedShift;
    BYTE  cGreenBits;
    BYTE  cGreenShift;
    BYTE  cBlueBits;
    BYTE  cBlueShift;
    BYTE  cAlphaBits;
    BYTE  cAlphaShift;
    BYTE  cAccumBits;
    BYTE  cAccumRedBits;
    BYTE  cAccumGreenBits;
    BYTE  cAccumBlueBits;
    BYTE  cAccumAlphaBits;
    BYTE  cDepthBits;
    BYTE  cStencilBits;
    BYTE  cAuxBuffers;
    BYTE  iLayerType;
    BYTE  bReserved;
    DWORD dwLayerMask;
    DWORD dwVisibleMask;
    DWORD dwDamageMask;
} PIXELFORMATDESCRIPTOR, *PPIXELFORMATDESCRIPTOR,  *LPPIXELFORMATDESCRIPTOR;

#line 3642 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\wingdi.h"
#pragma endregion

/* pixel types */



/* layer types */




/* PIXELFORMATDESCRIPTOR flags */

















/* PIXELFORMATDESCRIPTOR flags for use in ChoosePixelFormat only */





#pragma region Desktop Family





typedef int (__stdcall * OLDFONTENUMPROCA)(const LOGFONTA *, const TEXTMETRICA *, DWORD, LPARAM);
typedef int (__stdcall * OLDFONTENUMPROCW)(const LOGFONTW *, const TEXTMETRICW *, DWORD, LPARAM);




#line 3690 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\wingdi.h"








#line 3699 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\wingdi.h"

typedef OLDFONTENUMPROCA    FONTENUMPROCA;
typedef OLDFONTENUMPROCW    FONTENUMPROCW;



typedef FONTENUMPROCA FONTENUMPROC;
#line 3707 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\wingdi.h"

typedef int (__stdcall * GOBJENUMPROC)(LPVOID, LPARAM);
typedef void (__stdcall * LINEDDAPROC)(int, int, LPARAM);











#line 3722 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\wingdi.h"

#line 3724 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\wingdi.h"
#pragma endregion



#pragma region Desktop Family


__declspec(dllimport) int __stdcall AddFontResourceA( LPCSTR);
__declspec(dllimport) int __stdcall AddFontResourceW( LPCWSTR);




#line 3738 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\wingdi.h"

 __declspec(dllimport) BOOL  __stdcall AnimatePalette(  HPALETTE hPal,  UINT iStartIndex,   UINT cEntries,  const PALETTEENTRY * ppe);
 __declspec(dllimport) BOOL  __stdcall Arc(  HDC hdc,  int x1,  int y1,  int x2,  int y2,  int x3,  int y3,  int x4,  int y4);
 __declspec(dllimport) BOOL  __stdcall BitBlt(  HDC hdc,  int x,  int y,  int cx,  int cy,  HDC hdcSrc,  int x1,  int y1,  DWORD rop);
__declspec(dllimport) BOOL  __stdcall CancelDC(  HDC hdc);
 __declspec(dllimport) BOOL  __stdcall Chord(  HDC hdc,  int x1,  int y1,  int x2,  int y2,  int x3,  int y3,  int x4,  int y4);
__declspec(dllimport) int   __stdcall ChoosePixelFormat(  HDC hdc,  const PIXELFORMATDESCRIPTOR *ppfd);
__declspec(dllimport) HMETAFILE  __stdcall CloseMetaFile(  HDC hdc);
__declspec(dllimport) int     __stdcall CombineRgn(  HRGN hrgnDst,  HRGN hrgnSrc1,  HRGN hrgnSrc2,  int iMode);
__declspec(dllimport) HMETAFILE __stdcall CopyMetaFileA(  HMETAFILE,  LPCSTR);
__declspec(dllimport) HMETAFILE __stdcall CopyMetaFileW(  HMETAFILE,  LPCWSTR);




#line 3754 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\wingdi.h"
 __declspec(dllimport) HBITMAP __stdcall CreateBitmap(  int nWidth,  int nHeight,  UINT nPlanes,  UINT nBitCount,  const void *lpBits);
 __declspec(dllimport) HBITMAP __stdcall CreateBitmapIndirect(  const BITMAP *pbm);
 __declspec(dllimport) HBRUSH  __stdcall CreateBrushIndirect(  const LOGBRUSH *plbrush);
__declspec(dllimport) HBITMAP __stdcall CreateCompatibleBitmap(  HDC hdc,  int cx,  int cy);
__declspec(dllimport) HBITMAP __stdcall CreateDiscardableBitmap(  HDC hdc,  int cx,  int cy);
__declspec(dllimport) HDC     __stdcall CreateCompatibleDC(  HDC hdc);
__declspec(dllimport) HDC     __stdcall CreateDCA(  LPCSTR pwszDriver,  LPCSTR pwszDevice,  LPCSTR pszPort,  const DEVMODEA * pdm);
__declspec(dllimport) HDC     __stdcall CreateDCW(  LPCWSTR pwszDriver,  LPCWSTR pwszDevice,  LPCWSTR pszPort,  const DEVMODEW * pdm);




#line 3767 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\wingdi.h"
__declspec(dllimport) HBITMAP __stdcall CreateDIBitmap(  HDC hdc,  const BITMAPINFOHEADER *pbmih,  DWORD flInit,  const void *pjBits,  const BITMAPINFO *pbmi,  UINT iUsage);
__declspec(dllimport) HBRUSH  __stdcall CreateDIBPatternBrush(  HGLOBAL h,  UINT iUsage);
 __declspec(dllimport) HBRUSH  __stdcall CreateDIBPatternBrushPt(  const void *lpPackedDIB,  UINT iUsage);
__declspec(dllimport) HRGN    __stdcall CreateEllipticRgn(  int x1,  int y1,  int x2,  int y2);
__declspec(dllimport) HRGN    __stdcall CreateEllipticRgnIndirect(  const RECT *lprect);
 __declspec(dllimport) HFONT   __stdcall CreateFontIndirectA(  const LOGFONTA *lplf);
 __declspec(dllimport) HFONT   __stdcall CreateFontIndirectW(  const LOGFONTW *lplf);




#line 3779 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\wingdi.h"
__declspec(dllimport) HFONT   __stdcall CreateFontA(  int cHeight,  int cWidth,  int cEscapement,  int cOrientation,  int cWeight,  DWORD bItalic,
                              DWORD bUnderline,  DWORD bStrikeOut,  DWORD iCharSet,  DWORD iOutPrecision,  DWORD iClipPrecision,
                              DWORD iQuality,  DWORD iPitchAndFamily,  LPCSTR pszFaceName);
__declspec(dllimport) HFONT   __stdcall CreateFontW(  int cHeight,  int cWidth,  int cEscapement,  int cOrientation,  int cWeight,  DWORD bItalic,
                              DWORD bUnderline,  DWORD bStrikeOut,  DWORD iCharSet,  DWORD iOutPrecision,  DWORD iClipPrecision,
                              DWORD iQuality,  DWORD iPitchAndFamily,  LPCWSTR pszFaceName);




#line 3790 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\wingdi.h"

__declspec(dllimport) HBRUSH  __stdcall CreateHatchBrush(  int iHatch,  COLORREF color);
__declspec(dllimport) HDC     __stdcall CreateICA(  LPCSTR pszDriver,  LPCSTR pszDevice,  LPCSTR pszPort,  const DEVMODEA * pdm);
__declspec(dllimport) HDC     __stdcall CreateICW(  LPCWSTR pszDriver,  LPCWSTR pszDevice,  LPCWSTR pszPort,  const DEVMODEW * pdm);




#line 3799 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\wingdi.h"
__declspec(dllimport) HDC     __stdcall CreateMetaFileA(  LPCSTR pszFile);
__declspec(dllimport) HDC     __stdcall CreateMetaFileW(  LPCWSTR pszFile);




#line 3806 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\wingdi.h"
 __declspec(dllimport) HPALETTE __stdcall CreatePalette(  const LOGPALETTE * plpal);
__declspec(dllimport) HPEN    __stdcall CreatePen(  int iStyle,  int cWidth,  COLORREF color);
 __declspec(dllimport) HPEN    __stdcall CreatePenIndirect(  const LOGPEN *plpen);
__declspec(dllimport) HRGN    __stdcall CreatePolyPolygonRgn(   const POINT *pptl,
                                                 const INT  *pc,
                                                 int cPoly,
                                                 int iMode);
 __declspec(dllimport) HBRUSH  __stdcall CreatePatternBrush(  HBITMAP hbm);
__declspec(dllimport) HRGN    __stdcall CreateRectRgn(  int x1,  int y1,  int x2,  int y2);
__declspec(dllimport) HRGN    __stdcall CreateRectRgnIndirect(  const RECT *lprect);
__declspec(dllimport) HRGN    __stdcall CreateRoundRectRgn(  int x1,  int y1,  int x2,  int y2,  int w,  int h);
__declspec(dllimport) BOOL    __stdcall CreateScalableFontResourceA(  DWORD fdwHidden,  LPCSTR lpszFont,  LPCSTR lpszFile,  LPCSTR lpszPath);
__declspec(dllimport) BOOL    __stdcall CreateScalableFontResourceW(  DWORD fdwHidden,  LPCWSTR lpszFont,  LPCWSTR lpszFile,  LPCWSTR lpszPath);




#line 3824 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\wingdi.h"
__declspec(dllimport) HBRUSH  __stdcall CreateSolidBrush(  COLORREF color);

__declspec(dllimport) BOOL __stdcall DeleteDC(  HDC hdc);
__declspec(dllimport) BOOL __stdcall DeleteMetaFile(  HMETAFILE hmf);
 __declspec(dllimport) BOOL __stdcall DeleteObject(  HGDIOBJ ho);
__declspec(dllimport) int  __stdcall DescribePixelFormat(   HDC hdc,
                                             int iPixelFormat,
                                             UINT nBytes,
                                             LPPIXELFORMATDESCRIPTOR ppfd);

/* define types of pointers to ExtDeviceMode() and DeviceCapabilities()
 * functions for Win 3.1 compatibility
 */

typedef UINT   (__stdcall * LPFNDEVMODE)(HWND, HMODULE, LPDEVMODE, LPSTR, LPSTR, LPDEVMODE, LPSTR, UINT);

typedef DWORD  (__stdcall * LPFNDEVCAPS)(LPSTR, LPSTR, UINT, LPSTR, LPDEVMODE);

#line 3843 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\wingdi.h"
#pragma endregion

/* mode selections for the device mode function */










/* device capabilities indices */

























#line 3883 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\wingdi.h"


















#line 3902 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\wingdi.h"
#line 3903 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\wingdi.h"

/* bit fields of the return value (DWORD) for DC_TRUETYPE */






/* return values for DC_BINADJUST */








#line 3921 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\wingdi.h"

#pragma region Desktop Family


__declspec(dllimport)
int
__stdcall
DeviceCapabilitiesA(
                    LPCSTR         pDevice,
                LPCSTR         pPort,
                    WORD             fwCapability,
     LPSTR          pOutput,
                const DEVMODEA   *pDevMode
    );
__declspec(dllimport)
int
__stdcall
DeviceCapabilitiesW(
                    LPCWSTR         pDevice,
                LPCWSTR         pPort,
                    WORD             fwCapability,
     LPWSTR          pOutput,
                const DEVMODEW   *pDevMode
    );




#line 3950 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\wingdi.h"

__declspec(dllimport) int  __stdcall DrawEscape(    HDC    hdc,
                                     int    iEscape,
                                     int    cjIn,
                                     LPCSTR lpIn);

 __declspec(dllimport) BOOL __stdcall Ellipse(  HDC hdc,  int left,  int top,   int right,  int bottom);


__declspec(dllimport) int  __stdcall EnumFontFamiliesExA(  HDC hdc,  LPLOGFONTA lpLogfont,  FONTENUMPROCA lpProc,  LPARAM lParam,  DWORD dwFlags);
__declspec(dllimport) int  __stdcall EnumFontFamiliesExW(  HDC hdc,  LPLOGFONTW lpLogfont,  FONTENUMPROCW lpProc,  LPARAM lParam,  DWORD dwFlags);




#line 3966 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\wingdi.h"
#line 3967 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\wingdi.h"

__declspec(dllimport) int  __stdcall EnumFontFamiliesA(  HDC hdc,  LPCSTR lpLogfont,  FONTENUMPROCA lpProc,  LPARAM lParam);
__declspec(dllimport) int  __stdcall EnumFontFamiliesW(  HDC hdc,  LPCWSTR lpLogfont,  FONTENUMPROCW lpProc,  LPARAM lParam);




#line 3975 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\wingdi.h"
__declspec(dllimport) int  __stdcall EnumFontsA(  HDC hdc,  LPCSTR lpLogfont,   FONTENUMPROCA lpProc,  LPARAM lParam);
__declspec(dllimport) int  __stdcall EnumFontsW(  HDC hdc,  LPCWSTR lpLogfont,   FONTENUMPROCW lpProc,  LPARAM lParam);




#line 3982 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\wingdi.h"


__declspec(dllimport) int  __stdcall EnumObjects(  HDC hdc,  int nType,  GOBJENUMPROC lpFunc,  LPARAM lParam);


#line 3988 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\wingdi.h"


__declspec(dllimport) BOOL __stdcall EqualRgn(  HRGN hrgn1,  HRGN hrgn2);
 __declspec(dllimport) int  __stdcall Escape(    HDC hdc,
                                 int iEscape,
                                 int cjIn,
                                 LPCSTR pvIn,
                                 LPVOID pvOut);
__declspec(dllimport) int  __stdcall ExtEscape(     HDC hdc,
                                     int iEscape,
                                     int cjInput,
                                     LPCSTR lpInData,
                                     int cjOutput,
                                     LPSTR lpOutData);
 __declspec(dllimport) int  __stdcall ExcludeClipRect(  HDC hdc,  int left,  int top,  int right,  int bottom);
 __declspec(dllimport) HRGN __stdcall ExtCreateRegion(  const XFORM * lpx,  DWORD nCount,  const RGNDATA * lpData);
 __declspec(dllimport) BOOL __stdcall ExtFloodFill(  HDC hdc,  int x,  int y,  COLORREF color,  UINT type);
 __declspec(dllimport) BOOL __stdcall FillRgn(  HDC hdc,  HRGN hrgn,  HBRUSH hbr);
 __declspec(dllimport) BOOL __stdcall FloodFill(  HDC hdc,  int x,  int y,  COLORREF color);
 __declspec(dllimport) BOOL __stdcall FrameRgn(  HDC hdc,  HRGN hrgn,  HBRUSH hbr,  int w,  int h);
__declspec(dllimport) int  __stdcall GetROP2(  HDC hdc);
__declspec(dllimport) BOOL __stdcall GetAspectRatioFilterEx(  HDC hdc,  LPSIZE lpsize);
__declspec(dllimport) COLORREF __stdcall GetBkColor(  HDC hdc);


__declspec(dllimport) COLORREF __stdcall GetDCBrushColor(  HDC hdc);
__declspec(dllimport) COLORREF __stdcall GetDCPenColor(  HDC hdc);
#line 4016 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\wingdi.h"

__declspec(dllimport)
int
__stdcall
GetBkMode(
     HDC hdc
    );

__declspec(dllimport)
LONG
__stdcall
GetBitmapBits(
     HBITMAP hbit,
     LONG cb,
     LPVOID lpvBits
    );

__declspec(dllimport) BOOL  __stdcall GetBitmapDimensionEx(  HBITMAP hbit,  LPSIZE lpsize);
__declspec(dllimport) UINT  __stdcall GetBoundsRect(  HDC hdc,  LPRECT lprect,  UINT flags);

__declspec(dllimport) BOOL  __stdcall GetBrushOrgEx(  HDC hdc,  LPPOINT lppt);

__declspec(dllimport) BOOL  __stdcall GetCharWidthA(  HDC hdc,  UINT iFirst,  UINT iLast,  LPINT lpBuffer);
__declspec(dllimport) BOOL  __stdcall GetCharWidthW(  HDC hdc,  UINT iFirst,  UINT iLast,  LPINT lpBuffer);




#line 4045 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\wingdi.h"
__declspec(dllimport) BOOL  __stdcall GetCharWidth32A(  HDC hdc,  UINT iFirst,  UINT iLast,   LPINT lpBuffer);
__declspec(dllimport) BOOL  __stdcall GetCharWidth32W(  HDC hdc,  UINT iFirst,  UINT iLast,   LPINT lpBuffer);




#line 4052 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\wingdi.h"
__declspec(dllimport) BOOL  __stdcall GetCharWidthFloatA(  HDC hdc,  UINT iFirst,  UINT iLast,  PFLOAT lpBuffer);
__declspec(dllimport) BOOL  __stdcall GetCharWidthFloatW(  HDC hdc,  UINT iFirst,  UINT iLast,  PFLOAT lpBuffer);




#line 4059 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\wingdi.h"

__declspec(dllimport) BOOL  __stdcall GetCharABCWidthsA(  HDC hdc,
                                             UINT wFirst,
                                             UINT wLast,
                                             LPABC lpABC);
__declspec(dllimport) BOOL  __stdcall GetCharABCWidthsW(  HDC hdc,
                                             UINT wFirst,
                                             UINT wLast,
                                             LPABC lpABC);




#line 4073 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\wingdi.h"

__declspec(dllimport) BOOL  __stdcall GetCharABCWidthsFloatA(  HDC hdc,  UINT iFirst,  UINT iLast,  LPABCFLOAT lpABC);
__declspec(dllimport) BOOL  __stdcall GetCharABCWidthsFloatW(  HDC hdc,  UINT iFirst,  UINT iLast,  LPABCFLOAT lpABC);




#line 4081 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\wingdi.h"
__declspec(dllimport) int   __stdcall GetClipBox(  HDC hdc,   LPRECT lprect);
__declspec(dllimport) int   __stdcall GetClipRgn(  HDC hdc,  HRGN hrgn);
__declspec(dllimport) int   __stdcall GetMetaRgn(  HDC hdc,  HRGN hrgn);
__declspec(dllimport) HGDIOBJ __stdcall GetCurrentObject(  HDC hdc,  UINT type);
__declspec(dllimport) BOOL  __stdcall GetCurrentPositionEx(  HDC hdc,   LPPOINT lppt);
__declspec(dllimport) int   __stdcall GetDeviceCaps(  HDC hdc,  int index);
__declspec(dllimport) int   __stdcall GetDIBits(  HDC hdc,  HBITMAP hbm,  UINT start,  UINT cLines,
     LPVOID lpvBits,  LPBITMAPINFO lpbmi,  UINT usage);  // SAL actual size of lpbmi is computed from structure elements


__declspec(dllimport) DWORD __stdcall GetFontData (     HDC     hdc,
                                         DWORD   dwTable,
                                         DWORD   dwOffset,
                                         PVOID pvBuffer,
                                         DWORD   cjBuffer
                                        );

__declspec(dllimport) DWORD __stdcall GetGlyphOutlineA(     HDC hdc,
                                             UINT uChar,
                                             UINT fuFormat,
                                             LPGLYPHMETRICS lpgm,
                                             DWORD cjBuffer,
                                             LPVOID pvBuffer,
                                             const MAT2 *lpmat2
                                        );
__declspec(dllimport) DWORD __stdcall GetGlyphOutlineW(     HDC hdc,
                                             UINT uChar,
                                             UINT fuFormat,
                                             LPGLYPHMETRICS lpgm,
                                             DWORD cjBuffer,
                                             LPVOID pvBuffer,
                                             const MAT2 *lpmat2
                                        );




#line 4119 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\wingdi.h"

__declspec(dllimport) int   __stdcall GetGraphicsMode(  HDC hdc);
__declspec(dllimport) int   __stdcall GetMapMode(  HDC hdc);
__declspec(dllimport) UINT  __stdcall GetMetaFileBitsEx( HMETAFILE hMF,  UINT cbBuffer,  LPVOID lpData);
__declspec(dllimport) HMETAFILE   __stdcall GetMetaFileA(  LPCSTR lpName);
__declspec(dllimport) HMETAFILE   __stdcall GetMetaFileW(  LPCWSTR lpName);




#line 4130 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\wingdi.h"
__declspec(dllimport) COLORREF __stdcall GetNearestColor(  HDC hdc,  COLORREF color);
__declspec(dllimport) UINT  __stdcall GetNearestPaletteIndex(  HPALETTE h,  COLORREF color);
__declspec(dllimport) DWORD __stdcall GetObjectType(  HGDIOBJ h);



__declspec(dllimport) UINT __stdcall GetOutlineTextMetricsA(  HDC hdc,
                                                 UINT cjCopy,
                                                 LPOUTLINETEXTMETRICA potm);
__declspec(dllimport) UINT __stdcall GetOutlineTextMetricsW(  HDC hdc,
                                                 UINT cjCopy,
                                                 LPOUTLINETEXTMETRICW potm);




#line 4147 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\wingdi.h"

#line 4149 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\wingdi.h"


__declspec(dllimport) UINT  __stdcall GetPaletteEntries(    HPALETTE hpal,
                                             UINT iStart,
                                             UINT cEntries,
                                             LPPALETTEENTRY pPalEntries);
__declspec(dllimport) COLORREF __stdcall GetPixel(  HDC hdc,  int x,  int y);
__declspec(dllimport) int   __stdcall GetPixelFormat(  HDC hdc);
__declspec(dllimport) int   __stdcall GetPolyFillMode(  HDC hdc);
__declspec(dllimport) BOOL  __stdcall GetRasterizerCaps(    LPRASTERIZER_STATUS lpraststat,
                                             UINT cjBytes);

__declspec(dllimport) int   __stdcall GetRandomRgn ( HDC hdc,  HRGN hrgn,  INT i);
__declspec(dllimport) DWORD __stdcall GetRegionData(    HRGN hrgn,
                                         DWORD nCount,
                                         LPRGNDATA lpRgnData);
__declspec(dllimport) int   __stdcall GetRgnBox(  HRGN hrgn,   LPRECT lprc);
__declspec(dllimport) HGDIOBJ __stdcall GetStockObject(  int i);
__declspec(dllimport) int   __stdcall GetStretchBltMode( HDC hdc);
__declspec(dllimport)
UINT
__stdcall
GetSystemPaletteEntries(
     HDC  hdc,
     UINT iStart,
     UINT cEntries,
     LPPALETTEENTRY pPalEntries
    );

__declspec(dllimport) UINT  __stdcall GetSystemPaletteUse( HDC hdc);
__declspec(dllimport) int   __stdcall GetTextCharacterExtra( HDC hdc);
__declspec(dllimport) UINT  __stdcall GetTextAlign( HDC hdc);
__declspec(dllimport) COLORREF __stdcall GetTextColor( HDC hdc);

__declspec(dllimport)
BOOL
__stdcall
GetTextExtentPointA(
     HDC hdc,
     LPCSTR lpString,
     int c,
     LPSIZE lpsz
    );
__declspec(dllimport)
BOOL
__stdcall
GetTextExtentPointW(
     HDC hdc,
     LPCWSTR lpString,
     int c,
     LPSIZE lpsz
    );




#line 4206 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\wingdi.h"

__declspec(dllimport)
BOOL
__stdcall
GetTextExtentPoint32A(
     HDC hdc,
     LPCSTR lpString,
     int c,
     LPSIZE psizl
    );
__declspec(dllimport)
BOOL
__stdcall
GetTextExtentPoint32W(
     HDC hdc,
     LPCWSTR lpString,
     int c,
     LPSIZE psizl
    );




#line 4230 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\wingdi.h"

__declspec(dllimport)
BOOL
__stdcall
GetTextExtentExPointA(
     HDC hdc,
     LPCSTR lpszString,
     int cchString,
     int nMaxExtent,
     LPINT lpnFit,
     LPINT lpnDx,
     LPSIZE lpSize
    );
__declspec(dllimport)
BOOL
__stdcall
GetTextExtentExPointW(
     HDC hdc,
     LPCWSTR lpszString,
     int cchString,
     int nMaxExtent,
     LPINT lpnFit,
     LPINT lpnDx,
     LPSIZE lpSize
    );




#line 4260 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\wingdi.h"


__declspec(dllimport) int __stdcall GetTextCharset(  HDC hdc);
__declspec(dllimport) int __stdcall GetTextCharsetInfo(  HDC hdc,  LPFONTSIGNATURE lpSig,  DWORD dwFlags);
__declspec(dllimport) BOOL __stdcall TranslateCharsetInfo(  DWORD  *lpSrc,   LPCHARSETINFO lpCs,  DWORD dwFlags);
__declspec(dllimport) DWORD __stdcall GetFontLanguageInfo(  HDC hdc);
__declspec(dllimport) DWORD __stdcall GetCharacterPlacementA(   HDC hdc,  LPCSTR lpString,  int nCount,  int nMexExtent,  LPGCP_RESULTSA lpResults,  DWORD dwFlags);
__declspec(dllimport) DWORD __stdcall GetCharacterPlacementW(   HDC hdc,  LPCWSTR lpString,  int nCount,  int nMexExtent,  LPGCP_RESULTSW lpResults,  DWORD dwFlags);




#line 4273 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\wingdi.h"
#line 4274 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\wingdi.h"

#line 4276 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\wingdi.h"
#pragma endregion



#pragma region Desktop Family


typedef struct tagWCRANGE
{
    WCHAR  wcLow;
    USHORT cGlyphs;
} WCRANGE, *PWCRANGE, *LPWCRANGE;


typedef struct tagGLYPHSET
{
    DWORD    cbThis;
    DWORD    flAccel;
    DWORD    cGlyphsSupported;
    DWORD    cRanges;
    WCRANGE  ranges[1];
} GLYPHSET, *PGLYPHSET,  *LPGLYPHSET;

/* flAccel flags for the GLYPHSET structure above */



/* flags for GetGlyphIndices */



__declspec(dllimport) DWORD __stdcall GetFontUnicodeRanges(  HDC hdc,  LPGLYPHSET lpgs);
__declspec(dllimport) DWORD __stdcall GetGlyphIndicesA(  HDC hdc,  LPCSTR lpstr,  int c,  LPWORD pgi,  DWORD fl);
__declspec(dllimport) DWORD __stdcall GetGlyphIndicesW(  HDC hdc,  LPCWSTR lpstr,  int c,  LPWORD pgi,  DWORD fl);




#line 4315 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\wingdi.h"
__declspec(dllimport) BOOL  __stdcall GetTextExtentPointI( HDC hdc,  LPWORD pgiIn,  int cgi,  LPSIZE psize);
__declspec(dllimport) BOOL  __stdcall GetTextExtentExPointI (   HDC hdc,
                                                 LPWORD lpwszString,
                                                 int cwchString,
                                                 int nMaxExtent,
                                                 LPINT lpnFit,
                                                 LPINT lpnDx,
                                                 LPSIZE lpSize
                                                );

__declspec(dllimport) BOOL  __stdcall GetCharWidthI(    HDC hdc,
                                         UINT giFirst,
                                         UINT cgi,
                                         LPWORD pgi,
                                         LPINT piWidths
                                        );

__declspec(dllimport) BOOL  __stdcall GetCharABCWidthsI(    HDC    hdc,
                                             UINT   giFirst,
                                             UINT   cgi,
                                             LPWORD pgi,
                                             LPABC  pabc
                                        );










typedef struct tagDESIGNVECTOR
{
    DWORD  dvReserved;
    DWORD  dvNumAxes;
    LONG   dvValues[16 ];
} DESIGNVECTOR, *PDESIGNVECTOR,  *LPDESIGNVECTOR;

__declspec(dllimport) int  __stdcall AddFontResourceExA(  LPCSTR name,  DWORD fl,  PVOID res);
__declspec(dllimport) int  __stdcall AddFontResourceExW(  LPCWSTR name,  DWORD fl,  PVOID res);




#line 4362 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\wingdi.h"
__declspec(dllimport) BOOL __stdcall RemoveFontResourceExA(  LPCSTR name,  DWORD fl,  PVOID pdv);
__declspec(dllimport) BOOL __stdcall RemoveFontResourceExW(  LPCWSTR name,  DWORD fl,  PVOID pdv);




#line 4369 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\wingdi.h"
__declspec(dllimport) HANDLE __stdcall AddFontMemResourceEx(    PVOID pFileView,
                                                 DWORD cjSize,
                                                 PVOID pvResrved,
                                                 DWORD* pNumFonts);

__declspec(dllimport) BOOL __stdcall RemoveFontMemResourceEx(  HANDLE h);



// The actual size of the DESIGNVECTOR and ENUMLOGFONTEXDV structures
// is determined by dvNumAxes,
// MM_MAX_NUMAXES only detemines the maximal size allowed



typedef struct tagAXISINFOA
{
    LONG   axMinValue;
    LONG   axMaxValue;
    BYTE   axAxisName[16 ];
} AXISINFOA, *PAXISINFOA,  *LPAXISINFOA;
typedef struct tagAXISINFOW
{
    LONG   axMinValue;
    LONG   axMaxValue;
    WCHAR  axAxisName[16 ];
} AXISINFOW, *PAXISINFOW,  *LPAXISINFOW;





typedef AXISINFOA AXISINFO;
typedef PAXISINFOA PAXISINFO;
typedef LPAXISINFOA LPAXISINFO;
#line 4405 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\wingdi.h"

typedef struct tagAXESLISTA
{
    DWORD     axlReserved;
    DWORD     axlNumAxes;
    AXISINFOA axlAxisInfo[16 ];
} AXESLISTA, *PAXESLISTA,  *LPAXESLISTA;
typedef struct tagAXESLISTW
{
    DWORD     axlReserved;
    DWORD     axlNumAxes;
    AXISINFOW axlAxisInfo[16 ];
} AXESLISTW, *PAXESLISTW,  *LPAXESLISTW;





typedef AXESLISTA AXESLIST;
typedef PAXESLISTA PAXESLIST;
typedef LPAXESLISTA LPAXESLIST;
#line 4427 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\wingdi.h"

// The actual size of the AXESLIST and ENUMTEXTMETRIC structure is
// determined by axlNumAxes,
// MM_MAX_NUMAXES only detemines the maximal size allowed

typedef struct tagENUMLOGFONTEXDVA
{
    ENUMLOGFONTEXA elfEnumLogfontEx;
    DESIGNVECTOR   elfDesignVector;
} ENUMLOGFONTEXDVA, *PENUMLOGFONTEXDVA,  *LPENUMLOGFONTEXDVA;
typedef struct tagENUMLOGFONTEXDVW
{
    ENUMLOGFONTEXW elfEnumLogfontEx;
    DESIGNVECTOR   elfDesignVector;
} ENUMLOGFONTEXDVW, *PENUMLOGFONTEXDVW,  *LPENUMLOGFONTEXDVW;





typedef ENUMLOGFONTEXDVA ENUMLOGFONTEXDV;
typedef PENUMLOGFONTEXDVA PENUMLOGFONTEXDV;
typedef LPENUMLOGFONTEXDVA LPENUMLOGFONTEXDV;
#line 4451 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\wingdi.h"

__declspec(dllimport) HFONT  __stdcall CreateFontIndirectExA(  const ENUMLOGFONTEXDVA *);
__declspec(dllimport) HFONT  __stdcall CreateFontIndirectExW(  const ENUMLOGFONTEXDVW *);




#line 4459 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\wingdi.h"


typedef struct tagENUMTEXTMETRICA
{
    NEWTEXTMETRICEXA etmNewTextMetricEx;
    AXESLISTA        etmAxesList;
} ENUMTEXTMETRICA, *PENUMTEXTMETRICA,  *LPENUMTEXTMETRICA;
typedef struct tagENUMTEXTMETRICW
{
    NEWTEXTMETRICEXW etmNewTextMetricEx;
    AXESLISTW        etmAxesList;
} ENUMTEXTMETRICW, *PENUMTEXTMETRICW,  *LPENUMTEXTMETRICW;





typedef ENUMTEXTMETRICA ENUMTEXTMETRIC;
typedef PENUMTEXTMETRICA PENUMTEXTMETRIC;
typedef LPENUMTEXTMETRICA LPENUMTEXTMETRIC;
#line 4480 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\wingdi.h"
#line 4481 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\wingdi.h"

#line 4483 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\wingdi.h"
#pragma endregion

#line 4486 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\wingdi.h"

#pragma region Desktop Family


__declspec(dllimport) BOOL  __stdcall GetViewportExtEx(  HDC hdc,  LPSIZE lpsize);
__declspec(dllimport) BOOL  __stdcall GetViewportOrgEx(  HDC hdc,  LPPOINT lppoint);
__declspec(dllimport) BOOL  __stdcall GetWindowExtEx(  HDC hdc,  LPSIZE lpsize);
__declspec(dllimport) BOOL  __stdcall GetWindowOrgEx(  HDC hdc,  LPPOINT lppoint);

 __declspec(dllimport) int  __stdcall IntersectClipRect(  HDC hdc,  int left,  int top,  int right,  int bottom);
 __declspec(dllimport) BOOL __stdcall InvertRgn(  HDC hdc,  HRGN hrgn);
__declspec(dllimport) BOOL __stdcall LineDDA(  int xStart,  int yStart,  int xEnd,  int yEnd,  LINEDDAPROC lpProc,  LPARAM data);
 __declspec(dllimport) BOOL __stdcall LineTo(  HDC hdc,  int x,  int y);
__declspec(dllimport) BOOL __stdcall MaskBlt(  HDC hdcDest,  int xDest,  int yDest,  int width,  int height,
               HDC hdcSrc,  int xSrc,  int ySrc,  HBITMAP hbmMask,  int xMask,  int yMask,  DWORD rop);
__declspec(dllimport) BOOL __stdcall PlgBlt(  HDC hdcDest,  const POINT * lpPoint,  HDC hdcSrc,  int xSrc,  int ySrc,  int width,
                      int height,  HBITMAP hbmMask,  int xMask,  int yMask);

 __declspec(dllimport) int  __stdcall OffsetClipRgn( HDC hdc,  int x,  int y);
__declspec(dllimport) int  __stdcall OffsetRgn( HRGN hrgn,  int x,  int y);
 __declspec(dllimport) BOOL __stdcall PatBlt( HDC hdc,  int x,  int y,  int w,  int h,  DWORD rop);
 __declspec(dllimport) BOOL __stdcall Pie( HDC hdc,  int left,  int top,  int right,  int bottom,  int xr1,  int yr1,  int xr2,  int yr2);
__declspec(dllimport) BOOL __stdcall PlayMetaFile( HDC hdc,  HMETAFILE hmf);
 __declspec(dllimport) BOOL __stdcall PaintRgn( HDC hdc,  HRGN hrgn);
 __declspec(dllimport) BOOL __stdcall PolyPolygon( HDC hdc,   const POINT *apt,   const INT *asz,   int csz);
__declspec(dllimport) BOOL __stdcall PtInRegion( HRGN hrgn,  int x,  int y);
__declspec(dllimport) BOOL __stdcall PtVisible( HDC hdc,  int x,  int y);
__declspec(dllimport) BOOL __stdcall RectInRegion( HRGN hrgn,  const RECT * lprect);
__declspec(dllimport) BOOL __stdcall RectVisible( HDC hdc,  const RECT * lprect);
 __declspec(dllimport) BOOL __stdcall Rectangle( HDC hdc,  int left,  int top,  int right,  int bottom);
 __declspec(dllimport) BOOL __stdcall RestoreDC( HDC hdc,  int nSavedDC);
 __declspec(dllimport) HDC  __stdcall ResetDCA( HDC hdc,  const DEVMODEA * lpdm);
 __declspec(dllimport) HDC  __stdcall ResetDCW( HDC hdc,  const DEVMODEW * lpdm);




#line 4524 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\wingdi.h"
 __declspec(dllimport) UINT __stdcall RealizePalette( HDC hdc);
__declspec(dllimport) BOOL __stdcall RemoveFontResourceA( LPCSTR lpFileName);
__declspec(dllimport) BOOL __stdcall RemoveFontResourceW( LPCWSTR lpFileName);




#line 4532 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\wingdi.h"
 __declspec(dllimport) BOOL  __stdcall RoundRect( HDC hdc,  int left,  int top,  int right,  int bottom,  int width,  int height);
 __declspec(dllimport) BOOL __stdcall ResizePalette( HPALETTE hpal,  UINT n);

 __declspec(dllimport) int  __stdcall SaveDC( HDC hdc);
 __declspec(dllimport) int  __stdcall SelectClipRgn( HDC hdc,  HRGN hrgn);
__declspec(dllimport) int  __stdcall ExtSelectClipRgn( HDC hdc,  HRGN hrgn,  int mode);
__declspec(dllimport) int  __stdcall SetMetaRgn( HDC hdc);
 __declspec(dllimport) HGDIOBJ __stdcall SelectObject( HDC hdc,  HGDIOBJ h);
 __declspec(dllimport) HPALETTE __stdcall SelectPalette( HDC hdc,  HPALETTE hPal,  BOOL bForceBkgd);
 __declspec(dllimport) COLORREF __stdcall SetBkColor( HDC hdc,  COLORREF color);


__declspec(dllimport) COLORREF __stdcall SetDCBrushColor( HDC hdc,  COLORREF color);
__declspec(dllimport) COLORREF __stdcall SetDCPenColor( HDC hdc,  COLORREF color);
#line 4547 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\wingdi.h"

 __declspec(dllimport) int   __stdcall SetBkMode( HDC hdc,  int mode);

__declspec(dllimport)
LONG __stdcall
SetBitmapBits(
     HBITMAP hbm,
     DWORD cb,
     const void *pvBits);

__declspec(dllimport) UINT  __stdcall SetBoundsRect( HDC hdc,  const RECT * lprect,  UINT flags);
__declspec(dllimport) int   __stdcall SetDIBits( HDC hdc,  HBITMAP hbm,  UINT start,  UINT cLines,  const void *lpBits,  const BITMAPINFO * lpbmi,  UINT ColorUse);
 __declspec(dllimport) int   __stdcall SetDIBitsToDevice( HDC hdc,  int xDest,  int yDest,  DWORD w,  DWORD h,  int xSrc,
         int ySrc,  UINT StartScan,  UINT cLines,  const void * lpvBits,  const BITMAPINFO * lpbmi,  UINT ColorUse);
 __declspec(dllimport) DWORD __stdcall SetMapperFlags( HDC hdc,  DWORD flags);
__declspec(dllimport) int   __stdcall SetGraphicsMode( HDC hdc,  int iMode);
 __declspec(dllimport) int   __stdcall SetMapMode( HDC hdc,  int iMode);


 __declspec(dllimport) DWORD __stdcall SetLayout( HDC hdc,  DWORD l);
__declspec(dllimport) DWORD __stdcall GetLayout( HDC hdc);
#line 4569 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\wingdi.h"

__declspec(dllimport) HMETAFILE   __stdcall SetMetaFileBitsEx( UINT cbBuffer,  const BYTE *lpData);
 __declspec(dllimport) UINT  __stdcall SetPaletteEntries(    HPALETTE hpal,
                                             UINT iStart,
                                             UINT cEntries,
                                             const PALETTEENTRY *pPalEntries);
 __declspec(dllimport) COLORREF __stdcall SetPixel( HDC hdc,  int x,  int y,  COLORREF color);
__declspec(dllimport) BOOL   __stdcall SetPixelV( HDC hdc,  int x,  int y,  COLORREF color);
__declspec(dllimport) BOOL  __stdcall SetPixelFormat( HDC hdc,  int format,  const PIXELFORMATDESCRIPTOR * ppfd);
 __declspec(dllimport) int   __stdcall SetPolyFillMode( HDC hdc,  int mode);
 __declspec(dllimport) BOOL  __stdcall StretchBlt( HDC hdcDest,  int xDest,  int yDest,  int wDest,  int hDest,  HDC hdcSrc,  int xSrc,  int ySrc,  int wSrc,  int hSrc,  DWORD rop);
__declspec(dllimport) BOOL   __stdcall SetRectRgn( HRGN hrgn,  int left,  int top,  int right,  int bottom);
 __declspec(dllimport) int   __stdcall StretchDIBits( HDC hdc,  int xDest,  int yDest,  int DestWidth,  int DestHeight,  int xSrc,  int ySrc,  int SrcWidth,  int SrcHeight,
         const void * lpBits,  const BITMAPINFO * lpbmi,  UINT iUsage,  DWORD rop);
 __declspec(dllimport) int   __stdcall SetROP2( HDC hdc,  int rop2);
 __declspec(dllimport) int   __stdcall SetStretchBltMode( HDC hdc,  int mode);
__declspec(dllimport) UINT  __stdcall SetSystemPaletteUse( HDC hdc,  UINT use);
 __declspec(dllimport) int   __stdcall SetTextCharacterExtra( HDC hdc,  int extra);
 __declspec(dllimport) COLORREF __stdcall SetTextColor( HDC hdc,  COLORREF color);
 __declspec(dllimport) UINT  __stdcall SetTextAlign( HDC hdc,  UINT align);
 __declspec(dllimport) BOOL  __stdcall SetTextJustification( HDC hdc,  int extra,  int count);
__declspec(dllimport) BOOL  __stdcall UpdateColors( HDC hdc);

#line 4593 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\wingdi.h"
#pragma endregion








































//
// image blt
//

#pragma region Application Family


typedef USHORT COLOR16;

typedef struct _TRIVERTEX
{
    LONG    x;
    LONG    y;
    COLOR16 Red;
    COLOR16 Green;
    COLOR16 Blue;
    COLOR16 Alpha;
}TRIVERTEX,*PTRIVERTEX,*LPTRIVERTEX;

#line 4654 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\wingdi.h"
#pragma endregion

#pragma region Desktop Family


typedef struct _GRADIENT_TRIANGLE
{
    ULONG Vertex1;
    ULONG Vertex2;
    ULONG Vertex3;
} GRADIENT_TRIANGLE,*PGRADIENT_TRIANGLE,*LPGRADIENT_TRIANGLE;

typedef struct _GRADIENT_RECT
{
    ULONG UpperLeft;
    ULONG LowerRight;
}GRADIENT_RECT,*PGRADIENT_RECT,*LPGRADIENT_RECT;

#line 4673 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\wingdi.h"
#pragma endregion

#pragma region Application Family


typedef struct _BLENDFUNCTION
{
    BYTE   BlendOp;
    BYTE   BlendFlags;
    BYTE   SourceConstantAlpha;
    BYTE   AlphaFormat;
}BLENDFUNCTION,*PBLENDFUNCTION;

#line 4687 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\wingdi.h"
#pragma endregion

#pragma region Desktop Family



//
// currentlly defined blend function
//



//
// alpha format flags
//



__declspec(dllimport) BOOL __stdcall AlphaBlend(
     HDC hdcDest,
     int xoriginDest,
     int yoriginDest,
     int wDest,
     int hDest,
     HDC hdcSrc,
     int xoriginSrc,
     int yoriginSrc,
     int wSrc,
     int hSrc,
     BLENDFUNCTION ftn);

__declspec(dllimport) BOOL __stdcall TransparentBlt(
     HDC hdcDest,
     int xoriginDest,
     int yoriginDest,
     int wDest,
     int hDest,
     HDC hdcSrc,
     int xoriginSrc,
     int yoriginSrc,
     int wSrc,
     int hSrc,
     UINT crTransparent);


//
// gradient drawing modes
//






__declspec(dllimport)
BOOL
__stdcall
GradientFill(
     HDC hdc,
     PTRIVERTEX pVertex,
     ULONG nVertex,
     PVOID pMesh,
     ULONG nMesh,
     ULONG ulMode
    );

#line 4754 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\wingdi.h"
#pragma endregion

#line 4757 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\wingdi.h"

#pragma region Desktop Family





__declspec(dllimport) BOOL  __stdcall GdiAlphaBlend( HDC hdcDest,  int xoriginDest,  int yoriginDest,  int wDest,  int hDest,  HDC hdcSrc,  int xoriginSrc,  int yoriginSrc,  int wSrc,  int hSrc,  BLENDFUNCTION ftn);

__declspec(dllimport) BOOL  __stdcall GdiTransparentBlt( HDC hdcDest, int xoriginDest,  int yoriginDest,  int wDest,  int hDest,  HDC hdcSrc,
                                            int xoriginSrc,  int yoriginSrc,  int wSrc,  int hSrc,  UINT crTransparent);

__declspec(dllimport) BOOL  __stdcall GdiGradientFill(  HDC hdc,
                                         PTRIVERTEX pVertex,
                                         ULONG nVertex,
                                         PVOID pMesh,
                                         ULONG nCount,
                                         ULONG ulMode);

#line 4777 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\wingdi.h"





__declspec(dllimport) BOOL  __stdcall PlayMetaFileRecord(   HDC hdc,
                                             LPHANDLETABLE lpHandleTable,
                                             LPMETARECORD lpMR,
                                             UINT noObjs);

typedef int (__stdcall * MFENUMPROC)(  HDC hdc,  HANDLETABLE  * lpht,  METARECORD  * lpMR,  int nObj,  LPARAM param);
__declspec(dllimport) BOOL  __stdcall EnumMetaFile(  HDC hdc,  HMETAFILE hmf,  MFENUMPROC proc,  LPARAM param);

typedef int (__stdcall * ENHMFENUMPROC)( HDC hdc,  HANDLETABLE  * lpht,  const ENHMETARECORD * lpmr,  int nHandles,  LPARAM data);

// Enhanced Metafile Function Declarations

__declspec(dllimport) HENHMETAFILE __stdcall CloseEnhMetaFile(  HDC hdc);
__declspec(dllimport) HENHMETAFILE __stdcall CopyEnhMetaFileA(  HENHMETAFILE hEnh,  LPCSTR lpFileName);
__declspec(dllimport) HENHMETAFILE __stdcall CopyEnhMetaFileW(  HENHMETAFILE hEnh,  LPCWSTR lpFileName);




#line 4802 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\wingdi.h"
__declspec(dllimport) HDC   __stdcall CreateEnhMetaFileA(  HDC hdc,  LPCSTR lpFilename,  const RECT *lprc,  LPCSTR lpDesc);
__declspec(dllimport) HDC   __stdcall CreateEnhMetaFileW(  HDC hdc,  LPCWSTR lpFilename,  const RECT *lprc,  LPCWSTR lpDesc);




#line 4809 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\wingdi.h"
__declspec(dllimport) BOOL  __stdcall DeleteEnhMetaFile(  HENHMETAFILE hmf);
__declspec(dllimport) BOOL  __stdcall EnumEnhMetaFile(  HDC hdc,  HENHMETAFILE hmf,  ENHMFENUMPROC proc,
                                         LPVOID param,  const RECT * lpRect);
__declspec(dllimport) HENHMETAFILE  __stdcall GetEnhMetaFileA(  LPCSTR lpName);
__declspec(dllimport) HENHMETAFILE  __stdcall GetEnhMetaFileW(  LPCWSTR lpName);




#line 4819 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\wingdi.h"
__declspec(dllimport) UINT  __stdcall GetEnhMetaFileBits(   HENHMETAFILE hEMF,
                                             UINT nSize,
                                             LPBYTE lpData);
__declspec(dllimport) UINT  __stdcall GetEnhMetaFileDescriptionA(   HENHMETAFILE hemf,
                                                     UINT cchBuffer,
                                                     LPSTR lpDescription);
__declspec(dllimport) UINT  __stdcall GetEnhMetaFileDescriptionW(   HENHMETAFILE hemf,
                                                     UINT cchBuffer,
                                                     LPWSTR lpDescription);




#line 4833 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\wingdi.h"
__declspec(dllimport) UINT  __stdcall GetEnhMetaFileHeader(     HENHMETAFILE hemf,
                                                 UINT nSize,
                                                 LPENHMETAHEADER lpEnhMetaHeader);
__declspec(dllimport) UINT  __stdcall GetEnhMetaFilePaletteEntries( HENHMETAFILE hemf,
                                                     UINT nNumEntries,
                                                     LPPALETTEENTRY lpPaletteEntries);

__declspec(dllimport) UINT  __stdcall GetEnhMetaFilePixelFormat(    HENHMETAFILE hemf,
                                                     UINT cbBuffer,
                                                     PIXELFORMATDESCRIPTOR *ppfd);
__declspec(dllimport) UINT  __stdcall GetWinMetaFileBits(   HENHMETAFILE hemf,
                                             UINT cbData16,
                                             LPBYTE pData16,
                                             INT iMapMode,
                                             HDC hdcRef);
__declspec(dllimport) BOOL  __stdcall PlayEnhMetaFile(  HDC hdc,  HENHMETAFILE hmf,  const RECT * lprect);
__declspec(dllimport) BOOL  __stdcall PlayEnhMetaFileRecord(    HDC hdc,
                                                 LPHANDLETABLE pht,
                                                 const ENHMETARECORD *pmr,
                                                 UINT cht);

__declspec(dllimport) HENHMETAFILE  __stdcall SetEnhMetaFileBits(   UINT nSize,
                                                     const BYTE * pb);

__declspec(dllimport) HENHMETAFILE  __stdcall SetWinMetaFileBits(   UINT nSize,
                                                     const BYTE *lpMeta16Data,
                                                     HDC hdcRef,
                                                     const METAFILEPICT *lpMFP);
__declspec(dllimport) BOOL  __stdcall GdiComment( HDC hdc,  UINT nSize,  const BYTE *lpData);

#line 4864 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\wingdi.h"



__declspec(dllimport) BOOL __stdcall GetTextMetricsA(  HDC hdc,  LPTEXTMETRICA lptm);
__declspec(dllimport) BOOL __stdcall GetTextMetricsW(  HDC hdc,  LPTEXTMETRICW lptm);




#line 4874 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\wingdi.h"



















#line 4894 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\wingdi.h"

#line 4896 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\wingdi.h"

/* new GDI */

typedef struct tagDIBSECTION {
    BITMAP       dsBm;
    BITMAPINFOHEADER    dsBmih;
    DWORD               dsBitfields[3];
    HANDLE              dshSection;
    DWORD               dsOffset;
} DIBSECTION,  *LPDIBSECTION, *PDIBSECTION;


__declspec(dllimport) BOOL __stdcall AngleArc(  HDC hdc,  int x,  int y,  DWORD r,  FLOAT StartAngle,  FLOAT SweepAngle);
__declspec(dllimport) BOOL __stdcall PolyPolyline( HDC hdc,  const POINT *apt,  const DWORD *asz,  DWORD csz);
__declspec(dllimport) BOOL __stdcall GetWorldTransform(  HDC hdc,  LPXFORM lpxf);
__declspec(dllimport) BOOL __stdcall SetWorldTransform(  HDC hdc,  const XFORM * lpxf);
__declspec(dllimport) BOOL __stdcall ModifyWorldTransform(  HDC hdc,  const XFORM * lpxf,  DWORD mode);
__declspec(dllimport) BOOL __stdcall CombineTransform(  LPXFORM lpxfOut,  const XFORM *lpxf1,  const XFORM *lpxf2);






__declspec(dllimport)  HBITMAP __stdcall CreateDIBSection(
            HDC               hdc,
                const BITMAPINFO *pbmi,
                UINT              usage,
    
    
                    void            **ppvBits,
            HANDLE            hSection,
                DWORD             offset);



__declspec(dllimport) UINT __stdcall GetDIBColorTable(  HDC  hdc,
                                         UINT iStart,
                                         UINT cEntries,
                                         RGBQUAD *prgbq);
__declspec(dllimport) UINT __stdcall SetDIBColorTable(  HDC  hdc,
                                         UINT iStart,
                                         UINT cEntries,
                                         const RGBQUAD *prgbq);

/* Flags value for COLORADJUSTMENT */



/* IlluminantIndex values */
















/* Min and max for RedGamma, GreenGamma, BlueGamma */



/* Min and max for ReferenceBlack and ReferenceWhite */





/* Min and max for Contrast, Brightness, Colorfulness, RedGreenTint */



typedef struct  tagCOLORADJUSTMENT {
    WORD   caSize;
    WORD   caFlags;
    WORD   caIlluminantIndex;
    WORD   caRedGamma;
    WORD   caGreenGamma;
    WORD   caBlueGamma;
    WORD   caReferenceBlack;
    WORD   caReferenceWhite;
    SHORT  caContrast;
    SHORT  caBrightness;
    SHORT  caColorfulness;
    SHORT  caRedGreenTint;
} COLORADJUSTMENT, *PCOLORADJUSTMENT,  *LPCOLORADJUSTMENT;

__declspec(dllimport) BOOL __stdcall SetColorAdjustment(  HDC hdc,  const COLORADJUSTMENT *lpca);
__declspec(dllimport) BOOL __stdcall GetColorAdjustment(  HDC hdc,  LPCOLORADJUSTMENT lpca);
__declspec(dllimport) HPALETTE __stdcall CreateHalftonePalette(  HDC hdc);


typedef BOOL (__stdcall * ABORTPROC)(  HDC,  int);


#line 5000 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\wingdi.h"

typedef struct _DOCINFOA {
    int     cbSize;
    LPCSTR   lpszDocName;
    LPCSTR   lpszOutput;

    LPCSTR   lpszDatatype;
    DWORD    fwType;
#line 5009 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\wingdi.h"
} DOCINFOA, *LPDOCINFOA;
typedef struct _DOCINFOW {
    int     cbSize;
    LPCWSTR  lpszDocName;
    LPCWSTR  lpszOutput;

    LPCWSTR  lpszDatatype;
    DWORD    fwType;
#line 5018 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\wingdi.h"
} DOCINFOW, *LPDOCINFOW;




typedef DOCINFOA DOCINFO;
typedef LPDOCINFOA LPDOCINFO;
#line 5026 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\wingdi.h"




#line 5031 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\wingdi.h"

 __declspec(dllimport) int __stdcall StartDocA( HDC hdc,  const DOCINFOA *lpdi);
 __declspec(dllimport) int __stdcall StartDocW( HDC hdc,  const DOCINFOW *lpdi);




#line 5039 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\wingdi.h"
 __declspec(dllimport) int __stdcall EndDoc( HDC hdc);
 __declspec(dllimport) int __stdcall StartPage( HDC hdc);
 __declspec(dllimport) int __stdcall EndPage( HDC hdc);
 __declspec(dllimport) int __stdcall AbortDoc( HDC hdc);
__declspec(dllimport) int __stdcall SetAbortProc( HDC hdc,  ABORTPROC proc);

__declspec(dllimport) BOOL __stdcall AbortPath( HDC hdc);
__declspec(dllimport) BOOL __stdcall ArcTo( HDC hdc,  int left,  int top,  int right,  int bottom,  int xr1,  int yr1,  int xr2,  int yr2);
__declspec(dllimport) BOOL __stdcall BeginPath( HDC hdc);
__declspec(dllimport) BOOL __stdcall CloseFigure( HDC hdc);
__declspec(dllimport) BOOL __stdcall EndPath( HDC hdc);
__declspec(dllimport) BOOL __stdcall FillPath( HDC hdc);
__declspec(dllimport) BOOL __stdcall FlattenPath( HDC hdc);
__declspec(dllimport) int  __stdcall GetPath( HDC hdc,  LPPOINT apt,  LPBYTE aj, int cpt);
__declspec(dllimport) HRGN __stdcall PathToRegion( HDC hdc);
__declspec(dllimport) BOOL __stdcall PolyDraw( HDC hdc,  const POINT * apt,  const BYTE * aj,  int cpt);
__declspec(dllimport) BOOL __stdcall SelectClipPath( HDC hdc,  int mode);
__declspec(dllimport) int  __stdcall SetArcDirection( HDC hdc,  int dir);
__declspec(dllimport) BOOL __stdcall SetMiterLimit( HDC hdc,  FLOAT limit,  PFLOAT old);
__declspec(dllimport) BOOL __stdcall StrokeAndFillPath( HDC hdc);
__declspec(dllimport) BOOL __stdcall StrokePath( HDC hdc);
__declspec(dllimport) BOOL __stdcall WidenPath( HDC hdc);
__declspec(dllimport) HPEN __stdcall ExtCreatePen(  DWORD iPenStyle,
                                     DWORD cWidth,
                                     const LOGBRUSH *plbrush,
                                     DWORD cStyle,
                                     const DWORD *pstyle);
__declspec(dllimport) BOOL __stdcall GetMiterLimit( HDC hdc,  PFLOAT plimit);
__declspec(dllimport) int  __stdcall GetArcDirection( HDC hdc);

__declspec(dllimport) int   __stdcall GetObjectA( HANDLE h,  int c,  LPVOID pv);
__declspec(dllimport) int   __stdcall GetObjectW( HANDLE h,  int c,  LPVOID pv);




#line 5076 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\wingdi.h"




















#line 5097 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\wingdi.h"


 __declspec(dllimport) BOOL  __stdcall MoveToEx(  HDC hdc,  int x,  int y,  LPPOINT lppt);
 __declspec(dllimport) BOOL  __stdcall TextOutA(  HDC hdc,  int x,  int y,  LPCSTR lpString,  int c);
 __declspec(dllimport) BOOL  __stdcall TextOutW(  HDC hdc,  int x,  int y,  LPCWSTR lpString,  int c);




#line 5107 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\wingdi.h"
 __declspec(dllimport) BOOL  __stdcall ExtTextOutA(  HDC hdc,  int x,  int y,  UINT options,  const RECT * lprect,  LPCSTR lpString,  UINT c,  const INT * lpDx);
 __declspec(dllimport) BOOL  __stdcall ExtTextOutW(  HDC hdc,  int x,  int y,  UINT options,  const RECT * lprect,  LPCWSTR lpString,  UINT c,  const INT * lpDx);




#line 5114 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\wingdi.h"
__declspec(dllimport) BOOL  __stdcall PolyTextOutA( HDC hdc,  const POLYTEXTA * ppt,  int nstrings);
__declspec(dllimport) BOOL  __stdcall PolyTextOutW( HDC hdc,  const POLYTEXTW * ppt,  int nstrings);




#line 5121 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\wingdi.h"

__declspec(dllimport) HRGN  __stdcall CreatePolygonRgn(     const POINT *pptl,
                                             int cPoint,
                                             int iMode);
__declspec(dllimport) BOOL  __stdcall DPtoLP(  HDC hdc,  LPPOINT lppt,  int c);
__declspec(dllimport) BOOL  __stdcall LPtoDP(  HDC hdc,  LPPOINT lppt,  int c);
 __declspec(dllimport) BOOL  __stdcall Polygon( HDC hdc,  const POINT *apt,  int cpt);
 __declspec(dllimport) BOOL  __stdcall Polyline( HDC hdc,  const POINT *apt,  int cpt);

__declspec(dllimport) BOOL  __stdcall PolyBezier( HDC hdc,  const POINT * apt,  DWORD cpt);
__declspec(dllimport) BOOL  __stdcall PolyBezierTo( HDC hdc,  const POINT * apt,  DWORD cpt);
__declspec(dllimport) BOOL  __stdcall PolylineTo( HDC hdc,  const POINT * apt,  DWORD cpt);

 __declspec(dllimport) BOOL  __stdcall SetViewportExtEx(  HDC hdc,  int x,  int y,  LPSIZE lpsz);
 __declspec(dllimport) BOOL  __stdcall SetViewportOrgEx(  HDC hdc,  int x,  int y,  LPPOINT lppt);
 __declspec(dllimport) BOOL  __stdcall SetWindowExtEx(  HDC hdc,  int x,  int y,  LPSIZE lpsz);
 __declspec(dllimport) BOOL  __stdcall SetWindowOrgEx(  HDC hdc,  int x,  int y,  LPPOINT lppt);

 __declspec(dllimport) BOOL  __stdcall OffsetViewportOrgEx(  HDC hdc,  int x,  int y,  LPPOINT lppt);
 __declspec(dllimport) BOOL  __stdcall OffsetWindowOrgEx(  HDC hdc,  int x,  int y,  LPPOINT lppt);
 __declspec(dllimport) BOOL  __stdcall ScaleViewportExtEx(  HDC hdc,  int xn,  int dx,  int yn,  int yd,  LPSIZE lpsz);
 __declspec(dllimport) BOOL  __stdcall ScaleWindowExtEx(  HDC hdc,  int xn,  int xd,  int yn,  int yd,  LPSIZE lpsz);
__declspec(dllimport) BOOL  __stdcall SetBitmapDimensionEx(  HBITMAP hbm,  int w,  int h,  LPSIZE lpsz);
__declspec(dllimport) BOOL  __stdcall SetBrushOrgEx(  HDC hdc,  int x,  int y,  LPPOINT lppt);

__declspec(dllimport) int   __stdcall GetTextFaceA(  HDC hdc,  int c,   LPSTR lpName);
__declspec(dllimport) int   __stdcall GetTextFaceW(  HDC hdc,  int c,   LPWSTR lpName);




#line 5153 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\wingdi.h"



typedef struct tagKERNINGPAIR {
   WORD wFirst;
   WORD wSecond;
   int  iKernAmount;
} KERNINGPAIR, *LPKERNINGPAIR;

__declspec(dllimport) DWORD __stdcall GetKerningPairsA(     HDC hdc,
                                             DWORD nPairs,
                                             LPKERNINGPAIR   lpKernPair);
__declspec(dllimport) DWORD __stdcall GetKerningPairsW(     HDC hdc,
                                             DWORD nPairs,
                                             LPKERNINGPAIR   lpKernPair);




#line 5173 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\wingdi.h"


__declspec(dllimport) BOOL  __stdcall GetDCOrgEx(  HDC hdc,  LPPOINT lppt);
__declspec(dllimport) BOOL  __stdcall FixBrushOrgEx(  HDC hdc,  int x,  int y,   LPPOINT ptl);
__declspec(dllimport) BOOL  __stdcall UnrealizeObject(  HGDIOBJ h);

__declspec(dllimport) BOOL  __stdcall GdiFlush(void);
__declspec(dllimport) DWORD __stdcall GdiSetBatchLimit(  DWORD dw);
__declspec(dllimport) DWORD __stdcall GdiGetBatchLimit(void);








typedef int (__stdcall * ICMENUMPROCA)(LPSTR, LPARAM);
typedef int (__stdcall * ICMENUMPROCW)(LPWSTR, LPARAM);




#line 5197 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\wingdi.h"

__declspec(dllimport) int         __stdcall SetICMMode(  HDC hdc,  int mode);
__declspec(dllimport) BOOL        __stdcall CheckColorsInGamut(     HDC hdc,
                                                     LPRGBTRIPLE lpRGBTriple,
                                                     LPVOID dlpBuffer,
                                                     DWORD nCount);

__declspec(dllimport) HCOLORSPACE __stdcall GetColorSpace(  HDC hdc);
__declspec(dllimport) BOOL        __stdcall GetLogColorSpaceA(  HCOLORSPACE hColorSpace,
                                                 LPLOGCOLORSPACEA lpBuffer,
                                                 DWORD nSize);
__declspec(dllimport) BOOL        __stdcall GetLogColorSpaceW(  HCOLORSPACE hColorSpace,
                                                 LPLOGCOLORSPACEW lpBuffer,
                                                 DWORD nSize);




#line 5216 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\wingdi.h"

__declspec(dllimport) HCOLORSPACE __stdcall CreateColorSpaceA(  LPLOGCOLORSPACEA lplcs);
__declspec(dllimport) HCOLORSPACE __stdcall CreateColorSpaceW(  LPLOGCOLORSPACEW lplcs);




#line 5224 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\wingdi.h"
__declspec(dllimport) HCOLORSPACE __stdcall SetColorSpace(  HDC hdc,  HCOLORSPACE hcs);
__declspec(dllimport) BOOL        __stdcall DeleteColorSpace(  HCOLORSPACE hcs);
__declspec(dllimport) BOOL        __stdcall GetICMProfileA(     HDC hdc,
                                                 LPDWORD pBufSize,
                                                 LPSTR pszFilename);
__declspec(dllimport) BOOL        __stdcall GetICMProfileW(     HDC hdc,
                                                 LPDWORD pBufSize,
                                                 LPWSTR pszFilename);




#line 5237 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\wingdi.h"

__declspec(dllimport) BOOL        __stdcall SetICMProfileA(  HDC hdc,  LPSTR lpFileName);
__declspec(dllimport) BOOL        __stdcall SetICMProfileW(  HDC hdc,  LPWSTR lpFileName);




#line 5245 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\wingdi.h"
__declspec(dllimport) BOOL        __stdcall GetDeviceGammaRamp(  HDC hdc,  LPVOID lpRamp);
__declspec(dllimport) BOOL        __stdcall SetDeviceGammaRamp(  HDC hdc,   LPVOID lpRamp);
__declspec(dllimport) BOOL        __stdcall ColorMatchToTarget(  HDC hdc,  HDC hdcTarget,  DWORD action);
__declspec(dllimport) int         __stdcall EnumICMProfilesA(  HDC hdc,  ICMENUMPROCA proc,  LPARAM param);
__declspec(dllimport) int         __stdcall EnumICMProfilesW(  HDC hdc,  ICMENUMPROCW proc,  LPARAM param);




#line 5255 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\wingdi.h"
// The Win95 update API UpdateICMRegKeyA is deprecated to set last error to ERROR_NOT_SUPPORTED and return FALSE
__declspec(dllimport) BOOL        __stdcall UpdateICMRegKeyA(  DWORD reserved,  LPSTR lpszCMID,  LPSTR lpszFileName,  UINT command);
// The Win95 update API UpdateICMRegKeyW is deprecated to set last error to ERROR_NOT_SUPPORTED and return FALSE
__declspec(dllimport) BOOL        __stdcall UpdateICMRegKeyW(  DWORD reserved,  LPWSTR lpszCMID,  LPWSTR lpszFileName,  UINT command);




#line 5264 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\wingdi.h"


#pragma deprecated (UpdateICMRegKeyW)
#pragma deprecated (UpdateICMRegKeyA)
#line 5269 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\wingdi.h"

#line 5271 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\wingdi.h"


__declspec(dllimport) BOOL        __stdcall ColorCorrectPalette(  HDC hdc,  HPALETTE hPal,  DWORD deFirst,  DWORD num);
#line 5275 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\wingdi.h"



// Enhanced metafile constants.





#line 5285 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\wingdi.h"

// Stock object flag used in the object handle index in the enhanced
// metafile records.
// E.g. The object handle index (META_STOCK_OBJECT | BLACK_BRUSH)
// represents the stock object BLACK_BRUSH.



// Enhanced metafile record types.











































































































#line 5402 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\wingdi.h"
















#line 5419 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\wingdi.h"





#line 5425 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\wingdi.h"









#line 5435 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\wingdi.h"

// Base record type for the enhanced metafile.

typedef struct tagEMR
{
    DWORD   iType;              // Enhanced metafile record type
    DWORD   nSize;              // Length of the record in bytes.
                                // This must be a multiple of 4.
} EMR, *PEMR;

// Base text record type for the enhanced metafile.

typedef struct tagEMRTEXT
{
    POINTL  ptlReference;
    DWORD   nChars;
    DWORD   offString;          // Offset to the string
    DWORD   fOptions;
    RECTL   rcl;
    DWORD   offDx;              // Offset to the inter-character spacing array.
                                // This is always given.
} EMRTEXT, *PEMRTEXT;

// Record structures for the enhanced metafile.

typedef struct tagABORTPATH
{
    EMR     emr;
} EMRABORTPATH,      *PEMRABORTPATH,
  EMRBEGINPATH,      *PEMRBEGINPATH,
  EMRENDPATH,        *PEMRENDPATH,
  EMRCLOSEFIGURE,    *PEMRCLOSEFIGURE,
  EMRFLATTENPATH,    *PEMRFLATTENPATH,
  EMRWIDENPATH,      *PEMRWIDENPATH,
  EMRSETMETARGN,     *PEMRSETMETARGN,
  EMRSAVEDC,         *PEMRSAVEDC,
  EMRREALIZEPALETTE, *PEMRREALIZEPALETTE;

typedef struct tagEMRSELECTCLIPPATH
{
    EMR     emr;
    DWORD   iMode;
} EMRSELECTCLIPPATH,    *PEMRSELECTCLIPPATH,
  EMRSETBKMODE,         *PEMRSETBKMODE,
  EMRSETMAPMODE,        *PEMRSETMAPMODE,

  EMRSETLAYOUT,         *PEMRSETLAYOUT,
#line 5483 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\wingdi.h"
  EMRSETPOLYFILLMODE,   *PEMRSETPOLYFILLMODE,
  EMRSETROP2,           *PEMRSETROP2,
  EMRSETSTRETCHBLTMODE, *PEMRSETSTRETCHBLTMODE,
  EMRSETICMMODE,        *PEMRSETICMMODE,
  EMRSETTEXTALIGN,      *PEMRSETTEXTALIGN;

typedef struct tagEMRSETMITERLIMIT
{
    EMR     emr;
    FLOAT   eMiterLimit;
} EMRSETMITERLIMIT, *PEMRSETMITERLIMIT;

typedef struct tagEMRRESTOREDC
{
    EMR     emr;
    LONG    iRelative;          // Specifies a relative instance
} EMRRESTOREDC, *PEMRRESTOREDC;

typedef struct tagEMRSETARCDIRECTION
{
    EMR     emr;
    DWORD   iArcDirection;      // Specifies the arc direction in the
                                // advanced graphics mode.
} EMRSETARCDIRECTION, *PEMRSETARCDIRECTION;

typedef struct tagEMRSETMAPPERFLAGS
{
    EMR     emr;
    DWORD   dwFlags;
} EMRSETMAPPERFLAGS, *PEMRSETMAPPERFLAGS;

typedef struct tagEMRSETTEXTCOLOR
{
    EMR     emr;
    COLORREF crColor;
} EMRSETBKCOLOR,   *PEMRSETBKCOLOR,
  EMRSETTEXTCOLOR, *PEMRSETTEXTCOLOR;

typedef struct tagEMRSELECTOBJECT
{
    EMR     emr;
    DWORD   ihObject;           // Object handle index
} EMRSELECTOBJECT, *PEMRSELECTOBJECT,
  EMRDELETEOBJECT, *PEMRDELETEOBJECT;

typedef struct tagEMRSELECTPALETTE
{
    EMR     emr;
    DWORD   ihPal;              // Palette handle index, background mode only
} EMRSELECTPALETTE, *PEMRSELECTPALETTE;

typedef struct tagEMRRESIZEPALETTE
{
    EMR     emr;
    DWORD   ihPal;              // Palette handle index
    DWORD   cEntries;
} EMRRESIZEPALETTE, *PEMRRESIZEPALETTE;

typedef struct tagEMRSETPALETTEENTRIES
{
    EMR     emr;
    DWORD   ihPal;              // Palette handle index
    DWORD   iStart;
    DWORD   cEntries;
    PALETTEENTRY aPalEntries[1];// The peFlags fields do not contain any flags
} EMRSETPALETTEENTRIES, *PEMRSETPALETTEENTRIES;

typedef struct tagEMRSETCOLORADJUSTMENT
{
    EMR     emr;
    COLORADJUSTMENT ColorAdjustment;
} EMRSETCOLORADJUSTMENT, *PEMRSETCOLORADJUSTMENT;

typedef struct tagEMRGDICOMMENT
{
    EMR     emr;
    DWORD   cbData;             // Size of data in bytes
    BYTE    Data[1];
} EMRGDICOMMENT, *PEMRGDICOMMENT;

typedef struct tagEMREOF
{
    EMR     emr;
    DWORD   nPalEntries;        // Number of palette entries
    DWORD   offPalEntries;      // Offset to the palette entries
    DWORD   nSizeLast;          // Same as nSize and must be the last DWORD
                                // of the record.  The palette entries,
                                // if exist, precede this field.
} EMREOF, *PEMREOF;

typedef struct tagEMRLINETO
{
    EMR     emr;
    POINTL  ptl;
} EMRLINETO,   *PEMRLINETO,
  EMRMOVETOEX, *PEMRMOVETOEX;

typedef struct tagEMROFFSETCLIPRGN
{
    EMR     emr;
    POINTL  ptlOffset;
} EMROFFSETCLIPRGN, *PEMROFFSETCLIPRGN;

typedef struct tagEMRFILLPATH
{
    EMR     emr;
    RECTL   rclBounds;          // Inclusive-inclusive bounds in device units
} EMRFILLPATH,          *PEMRFILLPATH,
  EMRSTROKEANDFILLPATH, *PEMRSTROKEANDFILLPATH,
  EMRSTROKEPATH,        *PEMRSTROKEPATH;

typedef struct tagEMREXCLUDECLIPRECT
{
    EMR     emr;
    RECTL   rclClip;
} EMREXCLUDECLIPRECT,   *PEMREXCLUDECLIPRECT,
  EMRINTERSECTCLIPRECT, *PEMRINTERSECTCLIPRECT;

typedef struct tagEMRSETVIEWPORTORGEX
{
    EMR     emr;
    POINTL  ptlOrigin;
} EMRSETVIEWPORTORGEX, *PEMRSETVIEWPORTORGEX,
  EMRSETWINDOWORGEX,   *PEMRSETWINDOWORGEX,
  EMRSETBRUSHORGEX,    *PEMRSETBRUSHORGEX;

typedef struct tagEMRSETVIEWPORTEXTEX
{
    EMR     emr;
    SIZEL   szlExtent;
} EMRSETVIEWPORTEXTEX, *PEMRSETVIEWPORTEXTEX,
  EMRSETWINDOWEXTEX,   *PEMRSETWINDOWEXTEX;

typedef struct tagEMRSCALEVIEWPORTEXTEX
{
    EMR     emr;
    LONG    xNum;
    LONG    xDenom;
    LONG    yNum;
    LONG    yDenom;
} EMRSCALEVIEWPORTEXTEX, *PEMRSCALEVIEWPORTEXTEX,
  EMRSCALEWINDOWEXTEX,   *PEMRSCALEWINDOWEXTEX;

typedef struct tagEMRSETWORLDTRANSFORM
{
    EMR     emr;
    XFORM   xform;
} EMRSETWORLDTRANSFORM, *PEMRSETWORLDTRANSFORM;

typedef struct tagEMRMODIFYWORLDTRANSFORM
{
    EMR     emr;
    XFORM   xform;
    DWORD   iMode;
} EMRMODIFYWORLDTRANSFORM, *PEMRMODIFYWORLDTRANSFORM;

typedef struct tagEMRSETPIXELV
{
    EMR     emr;
    POINTL  ptlPixel;
    COLORREF crColor;
} EMRSETPIXELV, *PEMRSETPIXELV;

typedef struct tagEMREXTFLOODFILL
{
    EMR     emr;
    POINTL  ptlStart;
    COLORREF crColor;
    DWORD   iMode;
} EMREXTFLOODFILL, *PEMREXTFLOODFILL;

typedef struct tagEMRELLIPSE
{
    EMR     emr;
    RECTL   rclBox;             // Inclusive-inclusive bounding rectangle
} EMRELLIPSE,  *PEMRELLIPSE,
  EMRRECTANGLE, *PEMRRECTANGLE;


typedef struct tagEMRROUNDRECT
{
    EMR     emr;
    RECTL   rclBox;             // Inclusive-inclusive bounding rectangle
    SIZEL   szlCorner;
} EMRROUNDRECT, *PEMRROUNDRECT;

typedef struct tagEMRARC
{
    EMR     emr;
    RECTL   rclBox;             // Inclusive-inclusive bounding rectangle
    POINTL  ptlStart;
    POINTL  ptlEnd;
} EMRARC,   *PEMRARC,
  EMRARCTO, *PEMRARCTO,
  EMRCHORD, *PEMRCHORD,
  EMRPIE,   *PEMRPIE;

typedef struct tagEMRANGLEARC
{
    EMR     emr;
    POINTL  ptlCenter;
    DWORD   nRadius;
    FLOAT   eStartAngle;
    FLOAT   eSweepAngle;
} EMRANGLEARC, *PEMRANGLEARC;

typedef struct tagEMRPOLYLINE
{
    EMR     emr;
    RECTL   rclBounds;          // Inclusive-inclusive bounds in device units
    DWORD   cptl;
    POINTL  aptl[1];
} EMRPOLYLINE,     *PEMRPOLYLINE,
  EMRPOLYBEZIER,   *PEMRPOLYBEZIER,
  EMRPOLYGON,      *PEMRPOLYGON,
  EMRPOLYBEZIERTO, *PEMRPOLYBEZIERTO,
  EMRPOLYLINETO,   *PEMRPOLYLINETO;

typedef struct tagEMRPOLYLINE16
{
    EMR     emr;
    RECTL   rclBounds;          // Inclusive-inclusive bounds in device units
    DWORD   cpts;
    POINTS  apts[1];
} EMRPOLYLINE16,     *PEMRPOLYLINE16,
  EMRPOLYBEZIER16,   *PEMRPOLYBEZIER16,
  EMRPOLYGON16,      *PEMRPOLYGON16,
  EMRPOLYBEZIERTO16, *PEMRPOLYBEZIERTO16,
  EMRPOLYLINETO16,   *PEMRPOLYLINETO16;

typedef struct tagEMRPOLYDRAW
{
    EMR     emr;
    RECTL   rclBounds;          // Inclusive-inclusive bounds in device units
    DWORD   cptl;               // Number of points
    POINTL  aptl[1];            // Array of points
    BYTE    abTypes[1];         // Array of point types
} EMRPOLYDRAW, *PEMRPOLYDRAW;

typedef struct tagEMRPOLYDRAW16
{
    EMR     emr;
    RECTL   rclBounds;          // Inclusive-inclusive bounds in device units
    DWORD   cpts;               // Number of points
    POINTS  apts[1];            // Array of points
    BYTE    abTypes[1];         // Array of point types
} EMRPOLYDRAW16, *PEMRPOLYDRAW16;

typedef struct tagEMRPOLYPOLYLINE
{
    EMR     emr;
    RECTL   rclBounds;          // Inclusive-inclusive bounds in device units
    DWORD   nPolys;             // Number of polys
    DWORD   cptl;               // Total number of points in all polys
    DWORD   aPolyCounts[1];     // Array of point counts for each poly
    POINTL  aptl[1];            // Array of points
} EMRPOLYPOLYLINE, *PEMRPOLYPOLYLINE,
  EMRPOLYPOLYGON,  *PEMRPOLYPOLYGON;

typedef struct tagEMRPOLYPOLYLINE16
{
    EMR     emr;
    RECTL   rclBounds;          // Inclusive-inclusive bounds in device units
    DWORD   nPolys;             // Number of polys
    DWORD   cpts;               // Total number of points in all polys
    DWORD   aPolyCounts[1];     // Array of point counts for each poly
    POINTS  apts[1];            // Array of points
} EMRPOLYPOLYLINE16, *PEMRPOLYPOLYLINE16,
  EMRPOLYPOLYGON16,  *PEMRPOLYPOLYGON16;

typedef struct tagEMRINVERTRGN
{
    EMR     emr;
    RECTL   rclBounds;          // Inclusive-inclusive bounds in device units
    DWORD   cbRgnData;          // Size of region data in bytes
    BYTE    RgnData[1];
} EMRINVERTRGN, *PEMRINVERTRGN,
  EMRPAINTRGN,  *PEMRPAINTRGN;

typedef struct tagEMRFILLRGN
{
    EMR     emr;
    RECTL   rclBounds;          // Inclusive-inclusive bounds in device units
    DWORD   cbRgnData;          // Size of region data in bytes
    DWORD   ihBrush;            // Brush handle index
    BYTE    RgnData[1];
} EMRFILLRGN, *PEMRFILLRGN;

typedef struct tagEMRFRAMERGN
{
    EMR     emr;
    RECTL   rclBounds;          // Inclusive-inclusive bounds in device units
    DWORD   cbRgnData;          // Size of region data in bytes
    DWORD   ihBrush;            // Brush handle index
    SIZEL   szlStroke;
    BYTE    RgnData[1];
} EMRFRAMERGN, *PEMRFRAMERGN;

typedef struct tagEMREXTSELECTCLIPRGN
{
    EMR     emr;
    DWORD   cbRgnData;          // Size of region data in bytes
    DWORD   iMode;
    BYTE    RgnData[1];
} EMREXTSELECTCLIPRGN, *PEMREXTSELECTCLIPRGN;

typedef struct tagEMREXTTEXTOUTA
{
    EMR     emr;
    RECTL   rclBounds;          // Inclusive-inclusive bounds in device units
    DWORD   iGraphicsMode;      // Current graphics mode
    FLOAT   exScale;            // X and Y scales from Page units to .01mm units
    FLOAT   eyScale;            //   if graphics mode is GM_COMPATIBLE.
    EMRTEXT emrtext;            // This is followed by the string and spacing
                                // array
} EMREXTTEXTOUTA, *PEMREXTTEXTOUTA,
  EMREXTTEXTOUTW, *PEMREXTTEXTOUTW;

typedef struct tagEMRPOLYTEXTOUTA
{
    EMR     emr;
    RECTL   rclBounds;          // Inclusive-inclusive bounds in device units
    DWORD   iGraphicsMode;      // Current graphics mode
    FLOAT   exScale;            // X and Y scales from Page units to .01mm units
    FLOAT   eyScale;            //   if graphics mode is GM_COMPATIBLE.
    LONG    cStrings;
    EMRTEXT aemrtext[1];        // Array of EMRTEXT structures.  This is
                                // followed by the strings and spacing arrays.
} EMRPOLYTEXTOUTA, *PEMRPOLYTEXTOUTA,
  EMRPOLYTEXTOUTW, *PEMRPOLYTEXTOUTW;

typedef struct tagEMRBITBLT
{
    EMR     emr;
    RECTL   rclBounds;          // Inclusive-inclusive bounds in device units
    LONG    xDest;
    LONG    yDest;
    LONG    cxDest;
    LONG    cyDest;
    DWORD   dwRop;
    LONG    xSrc;
    LONG    ySrc;
    XFORM   xformSrc;           // Source DC transform
    COLORREF crBkColorSrc;      // Source DC BkColor in RGB
    DWORD   iUsageSrc;          // Source bitmap info color table usage
                                // (DIB_RGB_COLORS)
    DWORD   offBmiSrc;          // Offset to the source BITMAPINFO structure
    DWORD   cbBmiSrc;           // Size of the source BITMAPINFO structure
    DWORD   offBitsSrc;         // Offset to the source bitmap bits
    DWORD   cbBitsSrc;          // Size of the source bitmap bits
} EMRBITBLT, *PEMRBITBLT;

typedef struct tagEMRSTRETCHBLT
{
    EMR     emr;
    RECTL   rclBounds;          // Inclusive-inclusive bounds in device units
    LONG    xDest;
    LONG    yDest;
    LONG    cxDest;
    LONG    cyDest;
    DWORD   dwRop;
    LONG    xSrc;
    LONG    ySrc;
    XFORM   xformSrc;           // Source DC transform
    COLORREF crBkColorSrc;      // Source DC BkColor in RGB
    DWORD   iUsageSrc;          // Source bitmap info color table usage
                                // (DIB_RGB_COLORS)
    DWORD   offBmiSrc;          // Offset to the source BITMAPINFO structure
    DWORD   cbBmiSrc;           // Size of the source BITMAPINFO structure
    DWORD   offBitsSrc;         // Offset to the source bitmap bits
    DWORD   cbBitsSrc;          // Size of the source bitmap bits
    LONG    cxSrc;
    LONG    cySrc;
} EMRSTRETCHBLT, *PEMRSTRETCHBLT;

typedef struct tagEMRMASKBLT
{
    EMR     emr;
    RECTL   rclBounds;          // Inclusive-inclusive bounds in device units
    LONG    xDest;
    LONG    yDest;
    LONG    cxDest;
    LONG    cyDest;
    DWORD   dwRop;
    LONG    xSrc;
    LONG    ySrc;
    XFORM   xformSrc;           // Source DC transform
    COLORREF crBkColorSrc;      // Source DC BkColor in RGB
    DWORD   iUsageSrc;          // Source bitmap info color table usage
                                // (DIB_RGB_COLORS)
    DWORD   offBmiSrc;          // Offset to the source BITMAPINFO structure
    DWORD   cbBmiSrc;           // Size of the source BITMAPINFO structure
    DWORD   offBitsSrc;         // Offset to the source bitmap bits
    DWORD   cbBitsSrc;          // Size of the source bitmap bits
    LONG    xMask;
    LONG    yMask;
    DWORD   iUsageMask;         // Mask bitmap info color table usage
    DWORD   offBmiMask;         // Offset to the mask BITMAPINFO structure if any
    DWORD   cbBmiMask;          // Size of the mask BITMAPINFO structure if any
    DWORD   offBitsMask;        // Offset to the mask bitmap bits if any
    DWORD   cbBitsMask;         // Size of the mask bitmap bits if any
} EMRMASKBLT, *PEMRMASKBLT;

typedef struct tagEMRPLGBLT
{
    EMR     emr;
    RECTL   rclBounds;          // Inclusive-inclusive bounds in device units
    POINTL  aptlDest[3];
    LONG    xSrc;
    LONG    ySrc;
    LONG    cxSrc;
    LONG    cySrc;
    XFORM   xformSrc;           // Source DC transform
    COLORREF crBkColorSrc;      // Source DC BkColor in RGB
    DWORD   iUsageSrc;          // Source bitmap info color table usage
                                // (DIB_RGB_COLORS)
    DWORD   offBmiSrc;          // Offset to the source BITMAPINFO structure
    DWORD   cbBmiSrc;           // Size of the source BITMAPINFO structure
    DWORD   offBitsSrc;         // Offset to the source bitmap bits
    DWORD   cbBitsSrc;          // Size of the source bitmap bits
    LONG    xMask;
    LONG    yMask;
    DWORD   iUsageMask;         // Mask bitmap info color table usage
    DWORD   offBmiMask;         // Offset to the mask BITMAPINFO structure if any
    DWORD   cbBmiMask;          // Size of the mask BITMAPINFO structure if any
    DWORD   offBitsMask;        // Offset to the mask bitmap bits if any
    DWORD   cbBitsMask;         // Size of the mask bitmap bits if any
} EMRPLGBLT, *PEMRPLGBLT;

typedef struct tagEMRSETDIBITSTODEVICE
{
    EMR     emr;
    RECTL   rclBounds;          // Inclusive-inclusive bounds in device units
    LONG    xDest;
    LONG    yDest;
    LONG    xSrc;
    LONG    ySrc;
    LONG    cxSrc;
    LONG    cySrc;
    DWORD   offBmiSrc;          // Offset to the source BITMAPINFO structure
    DWORD   cbBmiSrc;           // Size of the source BITMAPINFO structure
    DWORD   offBitsSrc;         // Offset to the source bitmap bits
    DWORD   cbBitsSrc;          // Size of the source bitmap bits
    DWORD   iUsageSrc;          // Source bitmap info color table usage
    DWORD   iStartScan;
    DWORD   cScans;
} EMRSETDIBITSTODEVICE, *PEMRSETDIBITSTODEVICE;

typedef struct tagEMRSTRETCHDIBITS
{
    EMR     emr;
    RECTL   rclBounds;          // Inclusive-inclusive bounds in device units
    LONG    xDest;
    LONG    yDest;
    LONG    xSrc;
    LONG    ySrc;
    LONG    cxSrc;
    LONG    cySrc;
    DWORD   offBmiSrc;          // Offset to the source BITMAPINFO structure
    DWORD   cbBmiSrc;           // Size of the source BITMAPINFO structure
    DWORD   offBitsSrc;         // Offset to the source bitmap bits
    DWORD   cbBitsSrc;          // Size of the source bitmap bits
    DWORD   iUsageSrc;          // Source bitmap info color table usage
    DWORD   dwRop;
    LONG    cxDest;
    LONG    cyDest;
} EMRSTRETCHDIBITS, *PEMRSTRETCHDIBITS;

typedef struct tagEMREXTCREATEFONTINDIRECTW
{
    EMR     emr;
    DWORD   ihFont;             // Font handle index
    EXTLOGFONTW elfw;
} EMREXTCREATEFONTINDIRECTW, *PEMREXTCREATEFONTINDIRECTW;

typedef struct tagEMRCREATEPALETTE
{
    EMR     emr;
    DWORD   ihPal;              // Palette handle index
    LOGPALETTE lgpl;            // The peFlags fields in the palette entries
                                // do not contain any flags
} EMRCREATEPALETTE, *PEMRCREATEPALETTE;

typedef struct tagEMRCREATEPEN
{
    EMR     emr;
    DWORD   ihPen;              // Pen handle index
    LOGPEN  lopn;
} EMRCREATEPEN, *PEMRCREATEPEN;

typedef struct tagEMREXTCREATEPEN
{
    EMR     emr;
    DWORD   ihPen;              // Pen handle index
    DWORD   offBmi;             // Offset to the BITMAPINFO structure if any
    DWORD   cbBmi;              // Size of the BITMAPINFO structure if any
                                // The bitmap info is followed by the bitmap
                                // bits to form a packed DIB.
    DWORD   offBits;            // Offset to the brush bitmap bits if any
    DWORD   cbBits;             // Size of the brush bitmap bits if any
    EXTLOGPEN32 elp;            // The extended pen with the style array.
} EMREXTCREATEPEN, *PEMREXTCREATEPEN;

typedef struct tagEMRCREATEBRUSHINDIRECT
{
    EMR        emr;
    DWORD      ihBrush;          // Brush handle index
    LOGBRUSH32 lb;               // The style must be BS_SOLID, BS_HOLLOW,
                                 // BS_NULL or BS_HATCHED.
} EMRCREATEBRUSHINDIRECT, *PEMRCREATEBRUSHINDIRECT;

typedef struct tagEMRCREATEMONOBRUSH
{
    EMR     emr;
    DWORD   ihBrush;            // Brush handle index
    DWORD   iUsage;             // Bitmap info color table usage
    DWORD   offBmi;             // Offset to the BITMAPINFO structure
    DWORD   cbBmi;              // Size of the BITMAPINFO structure
    DWORD   offBits;            // Offset to the bitmap bits
    DWORD   cbBits;             // Size of the bitmap bits
} EMRCREATEMONOBRUSH, *PEMRCREATEMONOBRUSH;

typedef struct tagEMRCREATEDIBPATTERNBRUSHPT
{
    EMR     emr;
    DWORD   ihBrush;            // Brush handle index
    DWORD   iUsage;             // Bitmap info color table usage
    DWORD   offBmi;             // Offset to the BITMAPINFO structure
    DWORD   cbBmi;              // Size of the BITMAPINFO structure
                                // The bitmap info is followed by the bitmap
                                // bits to form a packed DIB.
    DWORD   offBits;            // Offset to the bitmap bits
    DWORD   cbBits;             // Size of the bitmap bits
} EMRCREATEDIBPATTERNBRUSHPT, *PEMRCREATEDIBPATTERNBRUSHPT;

typedef struct tagEMRFORMAT
{
    DWORD   dSignature;         // Format signature, e.g. ENHMETA_SIGNATURE.
    DWORD   nVersion;           // Format version number.
    DWORD   cbData;             // Size of data in bytes.
    DWORD   offData;            // Offset to data from GDICOMMENT_IDENTIFIER.
                                // It must begin at a DWORD offset.
} EMRFORMAT, *PEMRFORMAT;



typedef struct tagEMRGLSRECORD
{
    EMR     emr;
    DWORD   cbData;             // Size of data in bytes
    BYTE    Data[1];
} EMRGLSRECORD, *PEMRGLSRECORD;

typedef struct tagEMRGLSBOUNDEDRECORD
{
    EMR     emr;
    RECTL   rclBounds;          // Bounds in recording coordinates
    DWORD   cbData;             // Size of data in bytes
    BYTE    Data[1];
} EMRGLSBOUNDEDRECORD, *PEMRGLSBOUNDEDRECORD;

typedef struct tagEMRPIXELFORMAT
{
    EMR     emr;
    PIXELFORMATDESCRIPTOR pfd;
} EMRPIXELFORMAT, *PEMRPIXELFORMAT;

typedef struct tagEMRCREATECOLORSPACE
{
    EMR             emr;
    DWORD           ihCS;       // ColorSpace handle index
    LOGCOLORSPACEA  lcs;        // Ansi version of LOGCOLORSPACE
} EMRCREATECOLORSPACE, *PEMRCREATECOLORSPACE;

typedef struct tagEMRSETCOLORSPACE
{
    EMR     emr;
    DWORD   ihCS;               // ColorSpace handle index
} EMRSETCOLORSPACE,    *PEMRSETCOLORSPACE,
  EMRSELECTCOLORSPACE, *PEMRSELECTCOLORSPACE,
  EMRDELETECOLORSPACE, *PEMRDELETECOLORSPACE;

#line 6066 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\wingdi.h"



typedef struct tagEMREXTESCAPE
{
    EMR     emr;
    INT     iEscape;            // Escape code
    INT     cbEscData;          // Size of escape data
    BYTE    EscData[1];         // Escape data
} EMREXTESCAPE,  *PEMREXTESCAPE,
  EMRDRAWESCAPE, *PEMRDRAWESCAPE;

typedef struct tagEMRNAMEDESCAPE
{
    EMR     emr;
    INT     iEscape;            // Escape code
    INT     cbDriver;           // Size of driver name
    INT     cbEscData;          // Size of escape data
    BYTE    EscData[1];         // Driver name and Escape data
} EMRNAMEDESCAPE, *PEMRNAMEDESCAPE;



typedef struct tagEMRSETICMPROFILE
{
    EMR     emr;
    DWORD   dwFlags;            // flags
    DWORD   cbName;             // Size of desired profile name
    DWORD   cbData;             // Size of raw profile data if attached
    BYTE    Data[1];            // Array size is cbName + cbData
} EMRSETICMPROFILE,  *PEMRSETICMPROFILE,
  EMRSETICMPROFILEA, *PEMRSETICMPROFILEA,
  EMRSETICMPROFILEW, *PEMRSETICMPROFILEW;



typedef struct tagEMRCREATECOLORSPACEW
{
    EMR             emr;
    DWORD           ihCS;       // ColorSpace handle index
    LOGCOLORSPACEW  lcs;        // Unicode version of logical color space structure
    DWORD           dwFlags;    // flags
    DWORD           cbData;     // size of raw source profile data if attached
    BYTE            Data[1];    // Array size is cbData
} EMRCREATECOLORSPACEW, *PEMRCREATECOLORSPACEW;



typedef struct tagCOLORMATCHTOTARGET
{
    EMR     emr;
    DWORD   dwAction;           // CS_ENABLE, CS_DISABLE or CS_DELETE_TRANSFORM
    DWORD   dwFlags;            // flags
    DWORD   cbName;             // Size of desired target profile name
    DWORD   cbData;             // Size of raw target profile data if attached
    BYTE    Data[1];            // Array size is cbName + cbData
} EMRCOLORMATCHTOTARGET, *PEMRCOLORMATCHTOTARGET;

typedef struct tagCOLORCORRECTPALETTE
{
    EMR     emr;
    DWORD   ihPalette;          // Palette handle index
    DWORD   nFirstEntry;        // Index of first entry to correct
    DWORD   nPalEntries;        // Number of palette entries to correct
    DWORD   nReserved;          // Reserved
} EMRCOLORCORRECTPALETTE, *PEMRCOLORCORRECTPALETTE;

typedef struct tagEMRALPHABLEND
{
    EMR     emr;
    RECTL   rclBounds;          // Inclusive-inclusive bounds in device units
    LONG    xDest;
    LONG    yDest;
    LONG    cxDest;
    LONG    cyDest;
    DWORD   dwRop;
    LONG    xSrc;
    LONG    ySrc;
    XFORM   xformSrc;           // Source DC transform
    COLORREF crBkColorSrc;      // Source DC BkColor in RGB
    DWORD   iUsageSrc;          // Source bitmap info color table usage
                                // (DIB_RGB_COLORS)
    DWORD   offBmiSrc;          // Offset to the source BITMAPINFO structure
    DWORD   cbBmiSrc;           // Size of the source BITMAPINFO structure
    DWORD   offBitsSrc;         // Offset to the source bitmap bits
    DWORD   cbBitsSrc;          // Size of the source bitmap bits
    LONG    cxSrc;
    LONG    cySrc;
} EMRALPHABLEND, *PEMRALPHABLEND;

typedef struct tagEMRGRADIENTFILL
{
    EMR       emr;
    RECTL     rclBounds;          // Inclusive-inclusive bounds in device units
    DWORD     nVer;
    DWORD     nTri;
    ULONG     ulMode;
    TRIVERTEX Ver[1];
}EMRGRADIENTFILL,*PEMRGRADIENTFILL;

typedef struct tagEMRTRANSPARENTBLT
{
    EMR     emr;
    RECTL   rclBounds;          // Inclusive-inclusive bounds in device units
    LONG    xDest;
    LONG    yDest;
    LONG    cxDest;
    LONG    cyDest;
    DWORD   dwRop;
    LONG    xSrc;
    LONG    ySrc;
    XFORM   xformSrc;           // Source DC transform
    COLORREF crBkColorSrc;      // Source DC BkColor in RGB
    DWORD   iUsageSrc;          // Source bitmap info color table usage
                                // (DIB_RGB_COLORS)
    DWORD   offBmiSrc;          // Offset to the source BITMAPINFO structure
    DWORD   cbBmiSrc;           // Size of the source BITMAPINFO structure
    DWORD   offBitsSrc;         // Offset to the source bitmap bits
    DWORD   cbBitsSrc;          // Size of the source bitmap bits
    LONG    cxSrc;
    LONG    cySrc;
} EMRTRANSPARENTBLT, *PEMRTRANSPARENTBLT;


#line 6191 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\wingdi.h"










#line 6202 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\wingdi.h"


// OpenGL wgl prototypes

__declspec(dllimport) BOOL  __stdcall wglCopyContext(HGLRC, HGLRC, UINT);
__declspec(dllimport) HGLRC __stdcall wglCreateContext(HDC);
__declspec(dllimport) HGLRC __stdcall wglCreateLayerContext(HDC, int);
__declspec(dllimport) BOOL  __stdcall wglDeleteContext(HGLRC);
__declspec(dllimport) HGLRC __stdcall wglGetCurrentContext(void );
__declspec(dllimport) HDC   __stdcall wglGetCurrentDC(void );
__declspec(dllimport) PROC  __stdcall wglGetProcAddress(LPCSTR);
__declspec(dllimport) BOOL  __stdcall wglMakeCurrent(HDC, HGLRC);
__declspec(dllimport) BOOL  __stdcall wglShareLists(HGLRC, HGLRC);
__declspec(dllimport) BOOL  __stdcall wglUseFontBitmapsA(HDC, DWORD, DWORD, DWORD);
__declspec(dllimport) BOOL  __stdcall wglUseFontBitmapsW(HDC, DWORD, DWORD, DWORD);




#line 6222 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\wingdi.h"
__declspec(dllimport) BOOL  __stdcall SwapBuffers(HDC);

typedef struct _POINTFLOAT {
    FLOAT   x;
    FLOAT   y;
} POINTFLOAT, *PPOINTFLOAT;

typedef struct _GLYPHMETRICSFLOAT {
    FLOAT       gmfBlackBoxX;
    FLOAT       gmfBlackBoxY;
    POINTFLOAT  gmfptGlyphOrigin;
    FLOAT       gmfCellIncX;
    FLOAT       gmfCellIncY;
} GLYPHMETRICSFLOAT, *PGLYPHMETRICSFLOAT,  *LPGLYPHMETRICSFLOAT;



__declspec(dllimport) BOOL  __stdcall wglUseFontOutlinesA(HDC, DWORD, DWORD, DWORD, FLOAT,
                                           FLOAT, int, LPGLYPHMETRICSFLOAT);
__declspec(dllimport) BOOL  __stdcall wglUseFontOutlinesW(HDC, DWORD, DWORD, DWORD, FLOAT,
                                           FLOAT, int, LPGLYPHMETRICSFLOAT);




#line 6248 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\wingdi.h"

/* Layer plane descriptor */
typedef struct tagLAYERPLANEDESCRIPTOR { // lpd
    WORD  nSize;
    WORD  nVersion;
    DWORD dwFlags;
    BYTE  iPixelType;
    BYTE  cColorBits;
    BYTE  cRedBits;
    BYTE  cRedShift;
    BYTE  cGreenBits;
    BYTE  cGreenShift;
    BYTE  cBlueBits;
    BYTE  cBlueShift;
    BYTE  cAlphaBits;
    BYTE  cAlphaShift;
    BYTE  cAccumBits;
    BYTE  cAccumRedBits;
    BYTE  cAccumGreenBits;
    BYTE  cAccumBlueBits;
    BYTE  cAccumAlphaBits;
    BYTE  cDepthBits;
    BYTE  cStencilBits;
    BYTE  cAuxBuffers;
    BYTE  iLayerPlane;
    BYTE  bReserved;
    COLORREF crTransparent;
} LAYERPLANEDESCRIPTOR, *PLAYERPLANEDESCRIPTOR,  *LPLAYERPLANEDESCRIPTOR;

/* LAYERPLANEDESCRIPTOR flags */














/* wglSwapLayerBuffers flags */
































__declspec(dllimport) BOOL  __stdcall wglDescribeLayerPlane(HDC, int, int, UINT,
                                             LPLAYERPLANEDESCRIPTOR);
__declspec(dllimport) int   __stdcall wglSetLayerPaletteEntries(HDC, int, int, int,
                                                 const COLORREF *);
__declspec(dllimport) int   __stdcall wglGetLayerPaletteEntries(HDC, int, int, int,
                                                 COLORREF *);
__declspec(dllimport) BOOL  __stdcall wglRealizeLayerPalette(HDC, int, BOOL);
__declspec(dllimport) BOOL  __stdcall wglSwapLayerBuffers(HDC, UINT);



typedef struct _WGLSWAP
{
    HDC hdc;
    UINT uiFlags;
} WGLSWAP, *PWGLSWAP,  *LPWGLSWAP;



__declspec(dllimport) DWORD __stdcall wglSwapMultipleBuffers(UINT, const WGLSWAP *);

#line 6347 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\wingdi.h"

#line 6349 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\wingdi.h"
#pragma endregion

#line 6352 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\wingdi.h"

#pragma region Desktop Family



#line 6358 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\wingdi.h"
#pragma endregion


}
#line 6363 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\wingdi.h"


#pragma warning(pop)
#line 6367 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\wingdi.h"

#line 6369 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\wingdi.h"

#line 174 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\Windows.h"
#line 1 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"


/****************************************************************************
*                                                                           *
* winuser.h -- USER procedure declarations, constant definitions and macros *
*                                                                           *
* Copyright (c) Microsoft Corporation. All rights reserved.                 *
*                                                                           *
****************************************************************************/








#pragma once

//
// Define API decoration for direct importing of DLL references.
//






#line 30 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"







#line 38 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"






extern "C" {
#line 46 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"

#pragma warning(push)



#pragma warning(disable:4820) 
#line 53 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"









#line 63 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"



#pragma region Desktop Family


typedef HANDLE HDWP;
typedef void MENUTEMPLATEA;
typedef void MENUTEMPLATEW;



typedef MENUTEMPLATEA MENUTEMPLATE;
#line 77 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"
typedef PVOID LPMENUTEMPLATEA;
typedef PVOID LPMENUTEMPLATEW;



typedef LPMENUTEMPLATEA LPMENUTEMPLATE;
#line 84 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"

#line 86 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"
#pragma endregion

#pragma region Desktop Family


typedef LRESULT (__stdcall * WNDPROC)(HWND, UINT, WPARAM, LPARAM);

#line 94 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"
#pragma endregion



#pragma region Application Family or OneCore Family


typedef INT_PTR (__stdcall * DLGPROC)(HWND, UINT, WPARAM, LPARAM);

#line 104 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"
#pragma endregion

#pragma region Desktop Family or Games Family


typedef void (__stdcall * TIMERPROC)(HWND, UINT, UINT_PTR, DWORD);

#line 112 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"
#pragma endregion

#pragma region Desktop Family


typedef BOOL (__stdcall * GRAYSTRINGPROC)(HDC, LPARAM, int);
typedef BOOL (__stdcall * WNDENUMPROC)(HWND, LPARAM);
typedef LRESULT (__stdcall * HOOKPROC)(int code, WPARAM wParam, LPARAM lParam);
typedef void (__stdcall * SENDASYNCPROC)(HWND, UINT, ULONG_PTR, LRESULT);

typedef BOOL (__stdcall * PROPENUMPROCA)(HWND, LPCSTR, HANDLE);
typedef BOOL (__stdcall * PROPENUMPROCW)(HWND, LPCWSTR, HANDLE);

typedef BOOL (__stdcall * PROPENUMPROCEXA)(HWND, LPSTR, HANDLE, ULONG_PTR);
typedef BOOL (__stdcall * PROPENUMPROCEXW)(HWND, LPWSTR, HANDLE, ULONG_PTR);

typedef int (__stdcall * EDITWORDBREAKPROCA)(LPSTR lpch, int ichCurrent, int cch, int code);
typedef int (__stdcall * EDITWORDBREAKPROCW)(LPWSTR lpch, int ichCurrent, int cch, int code);


typedef BOOL (__stdcall * DRAWSTATEPROC)(HDC hdc, LPARAM lData, WPARAM wData, int cx, int cy);
#line 134 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"


#line 137 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"
#pragma endregion












































#line 183 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"

#pragma region Desktop Family







typedef PROPENUMPROCA        PROPENUMPROC;
typedef PROPENUMPROCEXA      PROPENUMPROCEX;
typedef EDITWORDBREAKPROCA   EDITWORDBREAKPROC;
#line 196 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"



typedef BOOL (__stdcall * NAMEENUMPROCA)(LPSTR, LPARAM);
typedef BOOL (__stdcall * NAMEENUMPROCW)(LPWSTR, LPARAM);

typedef NAMEENUMPROCA   WINSTAENUMPROCA;
typedef NAMEENUMPROCA   DESKTOPENUMPROCA;
typedef NAMEENUMPROCW   WINSTAENUMPROCW;
typedef NAMEENUMPROCW   DESKTOPENUMPROCW;












#line 219 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"







typedef WINSTAENUMPROCA     WINSTAENUMPROC;
typedef DESKTOPENUMPROCA    DESKTOPENUMPROC;

#line 230 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"

#line 232 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"
#pragma endregion








#line 242 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"



/*
 * Predefined Resource Types
 */






















#line 271 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"



















#line 291 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"


#line 294 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"

#pragma region Desktop Family



#pragma warning(push)
#pragma warning(disable:4995)
#line 302 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"

__declspec(dllimport)
int
__stdcall
wvsprintfA(
     LPSTR,
      LPCSTR,
     va_list arglist);
__declspec(dllimport)
int
__stdcall
wvsprintfW(
     LPWSTR,
      LPCWSTR,
     va_list arglist);




#line 322 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"

__declspec(dllimport)
int
__cdecl
wsprintfA(
     LPSTR,
      LPCSTR,
    ...);
__declspec(dllimport)
int
__cdecl
wsprintfW(
     LPWSTR,
      LPCWSTR,
    ...);




#line 342 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"


#pragma warning(pop)
#line 346 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"

#line 348 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"
#pragma endregion


/*
 * SPI_SETDESKWALLPAPER defined constants
 */




/*
 * Scroll Bar Constants
 */





/*
 * Scroll Bar Commands
 */
















#line 386 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"




/*
 * ShowWindow() Commands
 */

















/*
 * Old ShowWindow() Commands
 */






/*
 * Identifiers for the WM_SHOWWINDOW message
 */






#line 429 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"


/*
 * AnimateWindow() Commands
 */










#line 445 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"


/*
 * WM_KEYUP/DOWN/CHAR HIWORD(lParam) flags
 */










/*
 * Virtual Keys, Standard Set
 */








#line 472 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"

/*
 * 0x07 : reserved
 */





/*
 * 0x0A - 0x0B : reserved
 */




/*
 * 0x0E - 0x0F : unassigned
 */











/*
 * 0x16 : unassigned
 */






/*
 * 0x1A : unassigned
 */

























/*
 * VK_0 - VK_9 are the same as ASCII '0' - '9' (0x30 - 0x39)
 * 0x3A - 0x40 : unassigned
 * VK_A - VK_Z are the same as ASCII 'A' - 'Z' (0x41 - 0x5A)
 */





/*
 * 0x5E : reserved
 */



























































#line 612 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"




/*
 * NEC PC-9800 kbd definitions
 */


/*
 * Fujitsu/OASYS kbd definitions
 */






/*
 * 0x97 - 0x9F : unassigned
 */

/*
 * VK_L* & VK_R* - left and right Alt, Ctrl and Shift virtual keys.
 * Used only as parameters to GetAsyncKeyState() and GetKeyState().
 * No other API or message will distinguish left and right keys in this way.
 */




























#line 668 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"

/*
 * 0xB8 - 0xB9 : reserved
 */









/*
 * 0xC1 - 0xC2 : reserved
 */
































#line 717 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"








/*
 * 0xE0 : reserved
 */

/*
 * Various extended or enhanced keyboards
 */







#line 740 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"






#line 747 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"

/*
 * 0xE8 : unassigned
 */

/*
 * Nokia/Ericsson definitions
 */
























/*
 * 0xFF : reserved
 */


#line 785 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"



/*
 * SetWindowsHook() codes
 */












#line 804 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"





#line 810 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"




#line 815 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"






#line 822 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"


#line 825 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"




/*
 * Hook Codes
 */








/*
 * CBT Hook Codes
 */











#pragma region Desktop Family


/*
 * HCBT_CREATEWND parameters pointed to by lParam
 */
typedef struct tagCBT_CREATEWNDA
{
    struct tagCREATESTRUCTA *lpcs;
    HWND           hwndInsertAfter;
} CBT_CREATEWNDA, *LPCBT_CREATEWNDA;
/*
 * HCBT_CREATEWND parameters pointed to by lParam
 */
typedef struct tagCBT_CREATEWNDW
{
    struct tagCREATESTRUCTW *lpcs;
    HWND           hwndInsertAfter;
} CBT_CREATEWNDW, *LPCBT_CREATEWNDW;




typedef CBT_CREATEWNDA CBT_CREATEWND;
typedef LPCBT_CREATEWNDA LPCBT_CREATEWND;
#line 880 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"

/*
 * HCBT_ACTIVATE structure pointed to by lParam
 */
typedef struct tagCBTACTIVATESTRUCT
{
    BOOL    fMouse;
    HWND    hWndActive;
} CBTACTIVATESTRUCT, *LPCBTACTIVATESTRUCT;

#line 891 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"
#pragma endregion



#pragma region Desktop Family


/*
 * WTSSESSION_NOTIFICATION struct pointed by lParam, for WM_WTSSESSION_CHANGE
 */
typedef struct tagWTSSESSION_NOTIFICATION
{
    DWORD cbSize;
    DWORD dwSessionId;

} WTSSESSION_NOTIFICATION, *PWTSSESSION_NOTIFICATION;

#line 909 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"
#pragma endregion

/*
 * codes passed in WPARAM for WM_WTSSESSION_CHANGE
 */













#line 928 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"

/*
 * WH_MSGFILTER Filter Proc Codes
 */








/*
 * Shell support
 */












#line 956 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"



#line 960 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"




#line 965 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"







#line 973 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"







/* cmd for HSHELL_APPCOMMAND and WM_APPCOMMAND */





















































#line 1035 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"



#line 1039 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"











#line 1051 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"

#pragma region Desktop Family


typedef struct
{
    HWND    hwnd;
    RECT    rc;
} SHELLHOOKINFO, *LPSHELLHOOKINFO;

/*
 * Message Structure used in Journaling
 */
typedef struct tagEVENTMSG {
    UINT    message;
    UINT    paramL;
    UINT    paramH;
    DWORD    time;
    HWND     hwnd;
} EVENTMSG, *PEVENTMSGMSG,  *NPEVENTMSGMSG,  *LPEVENTMSGMSG;

typedef struct tagEVENTMSG *PEVENTMSG,  *NPEVENTMSG,  *LPEVENTMSG;

/*
 * Message structure used by WH_CALLWNDPROC
 */
typedef struct tagCWPSTRUCT {
    LPARAM  lParam;
    WPARAM  wParam;
    UINT    message;
    HWND    hwnd;
} CWPSTRUCT, *PCWPSTRUCT,  *NPCWPSTRUCT,  *LPCWPSTRUCT;


/*
 * Message structure used by WH_CALLWNDPROCRET
 */
typedef struct tagCWPRETSTRUCT {
    LRESULT lResult;
    LPARAM  lParam;
    WPARAM  wParam;
    UINT    message;
    HWND    hwnd;
} CWPRETSTRUCT, *PCWPRETSTRUCT,  *NPCWPRETSTRUCT,  *LPCWPRETSTRUCT;

#line 1097 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"

#line 1099 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"
#pragma endregion



/*
 * Low level hook flags
 */










#pragma region Desktop Family


/*
 * Structure used by WH_KEYBOARD_LL
 */
typedef struct tagKBDLLHOOKSTRUCT {
    DWORD   vkCode;
    DWORD   scanCode;
    DWORD   flags;
    DWORD   time;
    ULONG_PTR dwExtraInfo;
} KBDLLHOOKSTRUCT,  *LPKBDLLHOOKSTRUCT, *PKBDLLHOOKSTRUCT;

/*
 * Structure used by WH_MOUSE_LL
 */
typedef struct tagMSLLHOOKSTRUCT {
    POINT   pt;
    DWORD   mouseData;
    DWORD   flags;
    DWORD   time;
    ULONG_PTR dwExtraInfo;
} MSLLHOOKSTRUCT,  *LPMSLLHOOKSTRUCT, *PMSLLHOOKSTRUCT;

#line 1142 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"
#pragma endregion

#line 1145 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"

#pragma region Desktop Family


/*
 * Structure used by WH_DEBUG
 */
typedef struct tagDEBUGHOOKINFO
{
    DWORD   idThread;
    DWORD   idThreadInstaller;
    LPARAM  lParam;
    WPARAM  wParam;
    int     code;
} DEBUGHOOKINFO, *PDEBUGHOOKINFO,  *NPDEBUGHOOKINFO,  * LPDEBUGHOOKINFO;

/*
 * Structure used by WH_MOUSE
 */
typedef struct tagMOUSEHOOKSTRUCT {
    POINT   pt;
    HWND    hwnd;
    UINT    wHitTestCode;
    ULONG_PTR dwExtraInfo;
} MOUSEHOOKSTRUCT,  *LPMOUSEHOOKSTRUCT, *PMOUSEHOOKSTRUCT;



typedef struct tagMOUSEHOOKSTRUCTEX : public tagMOUSEHOOKSTRUCT
{
    DWORD   mouseData;
} MOUSEHOOKSTRUCTEX, *LPMOUSEHOOKSTRUCTEX, *PMOUSEHOOKSTRUCTEX;






#line 1184 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"
#line 1185 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"


/*
 * Structure used by WH_HARDWARE
 */
typedef struct tagHARDWAREHOOKSTRUCT {
    HWND    hwnd;
    UINT    message;
    WPARAM  wParam;
    LPARAM  lParam;
} HARDWAREHOOKSTRUCT,  *LPHARDWAREHOOKSTRUCT, *PHARDWAREHOOKSTRUCT;
#line 1197 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"

#line 1199 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"
#pragma endregion

#line 1202 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"

/*
 * Keyboard Layout API
 */










#line 1217 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"




#line 1222 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"



/*
 * Bits in wParam of WM_INPUTLANGCHANGEREQUEST message
 */



#line 1232 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"

/*
 * Size of KeyboardLayoutName (number of characters), including nul terminator
 */


#pragma region Desktop Family


__declspec(dllimport)
HKL
__stdcall
LoadKeyboardLayoutA(
     LPCSTR pwszKLID,
     UINT Flags);
__declspec(dllimport)
HKL
__stdcall
LoadKeyboardLayoutW(
     LPCWSTR pwszKLID,
     UINT Flags);




#line 1258 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"



__declspec(dllimport)
HKL
__stdcall
ActivateKeyboardLayout(
     HKL hkl,
     UINT Flags);







#line 1275 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"


__declspec(dllimport)
int
__stdcall
ToUnicodeEx(
     UINT wVirtKey,
     UINT wScanCode,
     const BYTE *lpKeyState,
     LPWSTR pwszBuff,
     int cchBuff,
     UINT wFlags,
     HKL dwhkl);
#line 1289 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"

__declspec(dllimport)
BOOL
__stdcall
UnloadKeyboardLayout(
     HKL hkl);

__declspec(dllimport)
BOOL
__stdcall
GetKeyboardLayoutNameA(
     LPSTR pwszKLID);
__declspec(dllimport)
BOOL
__stdcall
GetKeyboardLayoutNameW(
     LPWSTR pwszKLID);




#line 1311 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"


__declspec(dllimport)
int
__stdcall
GetKeyboardLayoutList(
     int nBuff,
     HKL  *lpList);

__declspec(dllimport)
HKL
__stdcall
GetKeyboardLayout(
     DWORD idThread);

#line 1327 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"


#line 1330 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"
#pragma endregion



#pragma region Desktop Family


typedef struct tagMOUSEMOVEPOINT {
    int   x;
    int   y;
    DWORD time;
    ULONG_PTR dwExtraInfo;
} MOUSEMOVEPOINT, *PMOUSEMOVEPOINT,  * LPMOUSEMOVEPOINT;

#line 1345 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"
#pragma endregion

/*
 * Values for resolution parameter of GetMouseMovePointsEx
 */



#pragma region Desktop Family


__declspec(dllimport)
int
__stdcall
GetMouseMovePointsEx(
     UINT cbSize,
     LPMOUSEMOVEPOINT lppt,
     LPMOUSEMOVEPOINT lpptBuf,
     int nBufPoints,
     DWORD resolution);

#line 1367 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"
#pragma endregion

#line 1370 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"


/*
 * Desktop-specific access flags
 */










/*
 * Desktop-specific control flags
 */





#pragma region Desktop Family


__declspec(dllimport)
HDESK
__stdcall
CreateDesktopA(
     LPCSTR lpszDesktop,
     LPCSTR lpszDevice,
     DEVMODEA* pDevmode,
     DWORD dwFlags,
     ACCESS_MASK dwDesiredAccess,
     LPSECURITY_ATTRIBUTES lpsa);
__declspec(dllimport)
HDESK
__stdcall
CreateDesktopW(
     LPCWSTR lpszDesktop,
     LPCWSTR lpszDevice,
     DEVMODEW* pDevmode,
     DWORD dwFlags,
     ACCESS_MASK dwDesiredAccess,
     LPSECURITY_ATTRIBUTES lpsa);




#line 1421 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"

__declspec(dllimport)
HDESK
__stdcall
CreateDesktopExA(
     LPCSTR lpszDesktop,
     LPCSTR lpszDevice,
     DEVMODEA* pDevmode,
     DWORD dwFlags,
     ACCESS_MASK dwDesiredAccess,
     LPSECURITY_ATTRIBUTES lpsa,
     ULONG ulHeapSize,
     PVOID pvoid);
__declspec(dllimport)
HDESK
__stdcall
CreateDesktopExW(
     LPCWSTR lpszDesktop,
     LPCWSTR lpszDevice,
     DEVMODEW* pDevmode,
     DWORD dwFlags,
     ACCESS_MASK dwDesiredAccess,
     LPSECURITY_ATTRIBUTES lpsa,
     ULONG ulHeapSize,
     PVOID pvoid);




#line 1451 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"

#line 1453 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"
#pragma endregion

#line 1456 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"
#line 1457 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"

#pragma region Desktop Family


__declspec(dllimport)
HDESK
__stdcall
OpenDesktopA(
     LPCSTR lpszDesktop,
     DWORD dwFlags,
     BOOL fInherit,
     ACCESS_MASK dwDesiredAccess);
__declspec(dllimport)
HDESK
__stdcall
OpenDesktopW(
     LPCWSTR lpszDesktop,
     DWORD dwFlags,
     BOOL fInherit,
     ACCESS_MASK dwDesiredAccess);




#line 1482 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"

__declspec(dllimport)
HDESK
__stdcall
OpenInputDesktop(
     DWORD dwFlags,
     BOOL fInherit,
     ACCESS_MASK dwDesiredAccess);


__declspec(dllimport)
BOOL
__stdcall
EnumDesktopsA(
     HWINSTA hwinsta,
     DESKTOPENUMPROCA lpEnumFunc,
     LPARAM lParam);
__declspec(dllimport)
BOOL
__stdcall
EnumDesktopsW(
     HWINSTA hwinsta,
     DESKTOPENUMPROCW lpEnumFunc,
     LPARAM lParam);




#line 1511 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"

__declspec(dllimport)
BOOL
__stdcall
EnumDesktopWindows(
     HDESK hDesktop,
     WNDENUMPROC lpfn,
     LPARAM lParam);


__declspec(dllimport)
BOOL
__stdcall
SwitchDesktop(
     HDESK hDesktop);


__declspec(dllimport)
BOOL
__stdcall
SetThreadDesktop(
      HDESK hDesktop);

__declspec(dllimport)
BOOL
__stdcall
CloseDesktop(
     HDESK hDesktop);

__declspec(dllimport)
HDESK
__stdcall
GetThreadDesktop(
     DWORD dwThreadId);

#line 1547 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"
#pragma endregion

#line 1550 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"


/*
 * Windowstation-specific access flags
 */














/*
 * Windowstation creation flags.
 */


/*
 * Windowstation-specific attribute flags
 */


#pragma region Desktop Family


__declspec(dllimport)
HWINSTA
__stdcall
CreateWindowStationA(
     LPCSTR lpwinsta,
     DWORD dwFlags,
     ACCESS_MASK dwDesiredAccess,
     LPSECURITY_ATTRIBUTES lpsa);
__declspec(dllimport)
HWINSTA
__stdcall
CreateWindowStationW(
     LPCWSTR lpwinsta,
     DWORD dwFlags,
     ACCESS_MASK dwDesiredAccess,
     LPSECURITY_ATTRIBUTES lpsa);




#line 1603 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"

__declspec(dllimport)
HWINSTA
__stdcall
OpenWindowStationA(
     LPCSTR lpszWinSta,
     BOOL fInherit,
     ACCESS_MASK dwDesiredAccess);
__declspec(dllimport)
HWINSTA
__stdcall
OpenWindowStationW(
     LPCWSTR lpszWinSta,
     BOOL fInherit,
     ACCESS_MASK dwDesiredAccess);




#line 1623 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"

__declspec(dllimport)
BOOL
__stdcall
EnumWindowStationsA(
     WINSTAENUMPROCA lpEnumFunc,
     LPARAM lParam);
__declspec(dllimport)
BOOL
__stdcall
EnumWindowStationsW(
     WINSTAENUMPROCW lpEnumFunc,
     LPARAM lParam);




#line 1641 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"

__declspec(dllimport)
BOOL
__stdcall
CloseWindowStation(
     HWINSTA hWinSta);

__declspec(dllimport)
BOOL
__stdcall
SetProcessWindowStation(
     HWINSTA hWinSta);

__declspec(dllimport)
HWINSTA
__stdcall
GetProcessWindowStation(
    void );

#line 1661 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"
#pragma endregion

#line 1664 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"



#pragma region Desktop Family


__declspec(dllimport)
BOOL
__stdcall
SetUserObjectSecurity(
     HANDLE hObj,
     PSECURITY_INFORMATION pSIRequested,
     PSECURITY_DESCRIPTOR pSID);

__declspec(dllimport)
BOOL
__stdcall
GetUserObjectSecurity(
     HANDLE hObj,
     PSECURITY_INFORMATION pSIRequested,
     PSECURITY_DESCRIPTOR pSID,
     DWORD nLength,
     LPDWORD lpnLengthNeeded);

#line 1689 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"
#pragma endregion








#line 1699 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"


#pragma region Desktop Family


typedef struct tagUSEROBJECTFLAGS {
    BOOL fInherit;
    BOOL fReserved;
    DWORD dwFlags;
} USEROBJECTFLAGS, *PUSEROBJECTFLAGS;

__declspec(dllimport)
BOOL
__stdcall
GetUserObjectInformationA(
     HANDLE hObj,
     int nIndex,
     PVOID pvInfo,
     DWORD nLength,
     LPDWORD lpnLengthNeeded);
__declspec(dllimport)
BOOL
__stdcall
GetUserObjectInformationW(
     HANDLE hObj,
     int nIndex,
     PVOID pvInfo,
     DWORD nLength,
     LPDWORD lpnLengthNeeded);




#line 1733 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"

__declspec(dllimport)
BOOL
__stdcall
SetUserObjectInformationA(
     HANDLE hObj,
     int nIndex,
     PVOID pvInfo,
     DWORD nLength);
__declspec(dllimport)
BOOL
__stdcall
SetUserObjectInformationW(
     HANDLE hObj,
     int nIndex,
     PVOID pvInfo,
     DWORD nLength);




#line 1755 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"

#line 1757 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"
#pragma endregion

#line 1760 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"

#pragma region Desktop or Games Family



typedef struct tagWNDCLASSEXA {
    UINT        cbSize;
    /* Win 3.x */
    UINT        style;
    WNDPROC     lpfnWndProc;
    int         cbClsExtra;
    int         cbWndExtra;
    HINSTANCE   hInstance;
    HICON       hIcon;
    HCURSOR     hCursor;
    HBRUSH      hbrBackground;
    LPCSTR      lpszMenuName;
    LPCSTR      lpszClassName;
    /* Win 4.0 */
    HICON       hIconSm;
} WNDCLASSEXA, *PWNDCLASSEXA,  *NPWNDCLASSEXA,  *LPWNDCLASSEXA;
typedef struct tagWNDCLASSEXW {
    UINT        cbSize;
    /* Win 3.x */
    UINT        style;
    WNDPROC     lpfnWndProc;
    int         cbClsExtra;
    int         cbWndExtra;
    HINSTANCE   hInstance;
    HICON       hIcon;
    HCURSOR     hCursor;
    HBRUSH      hbrBackground;
    LPCWSTR     lpszMenuName;
    LPCWSTR     lpszClassName;
    /* Win 4.0 */
    HICON       hIconSm;
} WNDCLASSEXW, *PWNDCLASSEXW,  *NPWNDCLASSEXW,  *LPWNDCLASSEXW;






typedef WNDCLASSEXA WNDCLASSEX;
typedef PWNDCLASSEXA PWNDCLASSEX;
typedef NPWNDCLASSEXA NPWNDCLASSEX;
typedef LPWNDCLASSEXA LPWNDCLASSEX;
#line 1808 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"
#line 1809 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"

typedef struct tagWNDCLASSA {
    UINT        style;
    WNDPROC     lpfnWndProc;
    int         cbClsExtra;
    int         cbWndExtra;
    HINSTANCE   hInstance;
    HICON       hIcon;
    HCURSOR     hCursor;
    HBRUSH      hbrBackground;
    LPCSTR      lpszMenuName;
    LPCSTR      lpszClassName;
} WNDCLASSA, *PWNDCLASSA,  *NPWNDCLASSA,  *LPWNDCLASSA;
typedef struct tagWNDCLASSW {
    UINT        style;
    WNDPROC     lpfnWndProc;
    int         cbClsExtra;
    int         cbWndExtra;
    HINSTANCE   hInstance;
    HICON       hIcon;
    HCURSOR     hCursor;
    HBRUSH      hbrBackground;
    LPCWSTR     lpszMenuName;
    LPCWSTR     lpszClassName;
} WNDCLASSW, *PWNDCLASSW,  *NPWNDCLASSW,  *LPWNDCLASSW;






typedef WNDCLASSA WNDCLASS;
typedef PWNDCLASSA PWNDCLASS;
typedef NPWNDCLASSA NPWNDCLASS;
typedef LPWNDCLASSA LPWNDCLASS;
#line 1845 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"

#line 1847 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"
#pragma endregion

#pragma region Desktop Family


__declspec(dllimport)
BOOL
__stdcall
IsHungAppWindow(
     HWND hwnd);



__declspec(dllimport)
void
__stdcall
DisableProcessWindowsGhosting(
    void );
#line 1866 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"

#line 1868 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"
#pragma endregion




#pragma region Application Family or OneCore Family or Games Family


/*
 * Message structure
 */
typedef struct tagMSG {
    HWND        hwnd;
    UINT        message;
    WPARAM      wParam;
    LPARAM      lParam;
    DWORD       time;
    POINT       pt;



} MSG, *PMSG,  *NPMSG,  *LPMSG;

#line 1892 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"
#pragma endregion











#line 1905 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"



/*
 * Window field offsets for GetWindowLong()
 */















#line 1927 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"







/*
 * Class field offsets for GetClassLong()
 */













#line 1951 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"











#line 1963 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"









#line 1973 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"




/*
 * Window Messages
 */








/*
 * WM_ACTIVATE state values
 */

















#line 2009 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"







#line 2017 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"














#pragma region Desktop Family


/*
 * Struct pointed to by WM_GETMINMAXINFO lParam
 */
typedef struct tagMINMAXINFO {
    POINT ptReserved;
    POINT ptMaxSize;
    POINT ptMaxPosition;
    POINT ptMinTrackSize;
    POINT ptMaxTrackSize;
} MINMAXINFO, *PMINMAXINFO, *LPMINMAXINFO;

#line 2046 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"
#pragma endregion



















#line 2067 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"
#line 2068 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"






/*
 * wParam for WM_POWER window message and DRV_POWER driver notification
 */










#pragma region Desktop Family


/*
 * lParam of WM_COPYDATA message points to...
 */
typedef struct tagCOPYDATASTRUCT {
    ULONG_PTR dwData;
    DWORD cbData;
     PVOID lpData;
} COPYDATASTRUCT, *PCOPYDATASTRUCT;


typedef struct tagMDINEXTMENU
{
    HMENU   hmenuIn;
    HMENU   hmenuNext;
    HWND    hwndNext;
} MDINEXTMENU, * PMDINEXTMENU,  * LPMDINEXTMENU;
#line 2107 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"

#line 2109 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"
#pragma endregion






















#line 2133 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"










#line 2144 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"

















#line 2162 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"




#line 2167 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"



#line 2171 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"
















#line 2188 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"






#line 2195 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"












#line 2208 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"

















/*
 * LOWORD(wParam) values in WM_*UISTATE*
 */




/*
 * HIWORD(wParam) values in WM_*UISTATE*
 */




#line 2240 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"
#line 2241 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"
#line 2242 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"

#line 2244 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"
#line 2245 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"























#line 2269 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"




#line 2274 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"


#line 2277 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"









#line 2287 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"



/* Value for rolling one detent */



/* Setting to scroll one page for SPI_GET/SETWHEELSCROLLLINES */

#line 2297 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"






/* XButton values are WORD flags */


/* Were there to be an XBUTTON3, its value would be 0x0004 */
#line 2308 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"










#line 2319 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"

































#pragma region Desktop Family


typedef struct {
    GUID PowerSetting;
    DWORD DataLength;
    UCHAR Data[1];
} POWERBROADCAST_SETTING, *PPOWERBROADCAST_SETTING;


#line 2363 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"
#pragma endregion

#line 2366 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"

#line 2368 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"
#line 2369 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"

#line 2371 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"



#line 2375 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"























#line 2399 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"




#line 2404 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"



















#line 2424 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"









#line 2434 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"


#line 2437 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"



#line 2441 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"




#line 2446 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"



#line 2450 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"






#line 2457 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"



#line 2461 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"




#line 2466 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"

























#line 2492 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"



#line 2496 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"



#line 2500 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"




#line 2505 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"






#line 2512 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"




#line 2517 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"




#line 2522 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"


#line 2525 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"








#line 2534 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"







#line 2542 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"


/*
 * NOTE: All Message Numbers below 0x0400 are RESERVED.
 *
 * Private Window Messages Start Here:
 */




/*  wParam for WM_SIZING message  */








#line 2563 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"



/*
 * WM_NCHITTEST and MOUSEHOOKSTRUCT Mouse Position Codes
 */






























#line 2600 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"


/*
 * SendMessageTimeout values
 */





#line 2611 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"


#line 2614 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"

#line 2616 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"

#line 2618 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"

/*
 * WM_MOUSEACTIVATE Return Codes
 */





/*
 * WM_SETICON / WM_GETICON Type Codes
 */




#line 2635 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"


#pragma region Desktop Family


__declspec(dllimport)
UINT
__stdcall
RegisterWindowMessageA(
     LPCSTR lpString);
__declspec(dllimport)
UINT
__stdcall
RegisterWindowMessageW(
     LPCWSTR lpString);




#line 2655 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"

#line 2657 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"
#pragma endregion


/*
 * WM_SIZE message wParam values
 */






/*
 * Obsolete constant names
 */







#pragma region Desktop Family


/*
 * WM_WINDOWPOSCHANGING/CHANGED struct pointed to by lParam
 */
typedef struct tagWINDOWPOS {
    HWND    hwnd;
    HWND    hwndInsertAfter;
    int     x;
    int     y;
    int     cx;
    int     cy;
    UINT    flags;
} WINDOWPOS, *LPWINDOWPOS, *PWINDOWPOS;

/*
 * WM_NCCALCSIZE parameter structure
 */
typedef struct tagNCCALCSIZE_PARAMS {
    RECT       rgrc[3];
    PWINDOWPOS lppos;
} NCCALCSIZE_PARAMS, *LPNCCALCSIZE_PARAMS;

#line 2704 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"
#pragma endregion

/*
 * WM_NCCALCSIZE "window valid rect" return values
 */













/*
 * Key State Masks for Mouse Messages
 */








#line 2734 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"

#line 2736 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"









#line 2746 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"





#line 2752 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"



#pragma region Desktop Family


typedef struct tagTRACKMOUSEEVENT {
    DWORD cbSize;
    DWORD dwFlags;
    HWND  hwndTrack;
    DWORD dwHoverTime;
} TRACKMOUSEEVENT, *LPTRACKMOUSEEVENT;

__declspec(dllimport)
BOOL
__stdcall
TrackMouseEvent(
     LPTRACKMOUSEEVENT lpEventTrack);

#line 2772 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"
#pragma endregion

#line 2775 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"



#line 2779 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"
#line 2780 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"


#line 2783 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"




/*
 * Window Styles
 */




























/*
 * Common Window Styles
 */













/*
 * Extended Window Styles
 */












#line 2850 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"

















#line 2868 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"




#line 2873 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"




#line 2878 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"



#line 2882 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"



#line 2886 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"



#line 2890 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"


#line 2893 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"


/*
 * Class styles
 */















#line 2914 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"



#line 2918 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"

/* WM_PRINT flags */







/* 3D border styles */
















/* Border flags */













// For diagonal lines, the BF_RECT flags specify the end point of the
// vector bounded by the rectangle parameter.













#pragma region Desktop Family


__declspec(dllimport)
BOOL
__stdcall
DrawEdge(
     HDC hdc,
     LPRECT qrc,
     UINT edge,
     UINT grfFlags);

#line 2986 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"
#pragma endregion

/* flags for DrawFrameControl */







#line 2997 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"

































#line 3031 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"





#pragma region Desktop Family


__declspec(dllimport)
BOOL
__stdcall
DrawFrameControl(
     HDC,
     LPRECT,
     UINT,
     UINT);


#line 3050 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"
#pragma endregion


/* flags for DrawCaption */







#line 3062 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"


#line 3065 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"

#pragma region Desktop Family


__declspec(dllimport)
BOOL
__stdcall
DrawCaption(
     HWND hwnd,
     HDC hdc,
     const RECT * lprect,
     UINT flags);


#line 3080 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"
#pragma endregion




#pragma region Desktop Family


__declspec(dllimport)
BOOL
__stdcall
DrawAnimatedRects(
     HWND hwnd,
     int idAni,
     const RECT *lprcFrom,
     const RECT *lprcTo);

#line 3098 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"
#pragma endregion

#line 3101 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"




/*
 * Predefined Clipboard Formats
 */

















#line 3126 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"


#line 3129 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"







#line 3137 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"







/*
 * "Private" formats don't get GlobalFree()'d
 */



/*
 * "GDIOBJ" formats do get DeleteObject()'d
 */




#line 3158 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"

/*
 * Defines for the fVirt field of the Accelerator table structure.
 */






#pragma region Desktop Family


typedef struct tagACCEL {

    BYTE   fVirt;               /* Also called the flags field */
    WORD   key;
    WORD   cmd;




#line 3181 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"
} ACCEL, *LPACCEL;

typedef struct tagPAINTSTRUCT {
    HDC         hdc;
    BOOL        fErase;
    RECT        rcPaint;
    BOOL        fRestore;
    BOOL        fIncUpdate;
    BYTE        rgbReserved[32];
} PAINTSTRUCT, *PPAINTSTRUCT, *NPPAINTSTRUCT, *LPPAINTSTRUCT;

#line 3193 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"
#pragma endregion

#pragma region Desktop Family or Games Family


typedef struct tagCREATESTRUCTA {
    LPVOID      lpCreateParams;
    HINSTANCE   hInstance;
    HMENU       hMenu;
    HWND        hwndParent;
    int         cy;
    int         cx;
    int         y;
    int         x;
    LONG        style;
    LPCSTR      lpszName;
    LPCSTR      lpszClass;
    DWORD       dwExStyle;
} CREATESTRUCTA, *LPCREATESTRUCTA;
typedef struct tagCREATESTRUCTW {
    LPVOID      lpCreateParams;
    HINSTANCE   hInstance;
    HMENU       hMenu;
    HWND        hwndParent;
    int         cy;
    int         cx;
    int         y;
    int         x;
    LONG        style;
    LPCWSTR     lpszName;
    LPCWSTR     lpszClass;
    DWORD       dwExStyle;
} CREATESTRUCTW, *LPCREATESTRUCTW;




typedef CREATESTRUCTA CREATESTRUCT;
typedef LPCREATESTRUCTA LPCREATESTRUCT;
#line 3233 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"

#line 3235 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"
#pragma endregion

#pragma region Desktop Family


typedef struct tagWINDOWPLACEMENT {
    UINT  length;
    UINT  flags;
    UINT  showCmd;
    POINT ptMinPosition;
    POINT ptMaxPosition;
    RECT  rcNormalPosition;



} WINDOWPLACEMENT;
typedef WINDOWPLACEMENT *PWINDOWPLACEMENT, *LPWINDOWPLACEMENT;





#line 3258 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"

#line 3260 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"
#pragma endregion



#pragma region Application Family or OneCore Family


typedef struct tagNMHDR
{
    HWND      hwndFrom;
    UINT_PTR  idFrom;
    UINT      code;         // NM_ code
}   NMHDR;

#line 3275 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"
#pragma endregion

#pragma region Desktop Family


typedef NMHDR  * LPNMHDR;

typedef struct tagSTYLESTRUCT
{
    DWORD   styleOld;
    DWORD   styleNew;
} STYLESTRUCT, * LPSTYLESTRUCT;

#line 3289 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"
#pragma endregion
#line 3291 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"


/*
 * Owner draw control types
 */






#line 3303 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"

/*
 * Owner draw actions
 */




/*
 * Owner draw state
 */








#line 3323 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"






#line 3330 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"
#line 3331 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"

#pragma region Desktop Family


/*
 * MEASUREITEMSTRUCT for ownerdraw
 */
typedef struct tagMEASUREITEMSTRUCT {
    UINT       CtlType;
    UINT       CtlID;
    UINT       itemID;
    UINT       itemWidth;
    UINT       itemHeight;
    ULONG_PTR  itemData;
} MEASUREITEMSTRUCT,  *PMEASUREITEMSTRUCT,  *LPMEASUREITEMSTRUCT;

/*
 * DRAWITEMSTRUCT for ownerdraw
 */
typedef struct tagDRAWITEMSTRUCT {
    UINT        CtlType;
    UINT        CtlID;
    UINT        itemID;
    UINT        itemAction;
    UINT        itemState;
    HWND        hwndItem;
    HDC         hDC;
    RECT        rcItem;
    ULONG_PTR   itemData;
} DRAWITEMSTRUCT,  *PDRAWITEMSTRUCT,  *LPDRAWITEMSTRUCT;

/*
 * DELETEITEMSTRUCT for ownerdraw
 */
typedef struct tagDELETEITEMSTRUCT {
    UINT       CtlType;
    UINT       CtlID;
    UINT       itemID;
    HWND       hwndItem;
    ULONG_PTR  itemData;
} DELETEITEMSTRUCT,  *PDELETEITEMSTRUCT,  *LPDELETEITEMSTRUCT;

/*
 * COMPAREITEMSTUCT for ownerdraw sorting
 */
typedef struct tagCOMPAREITEMSTRUCT {
    UINT        CtlType;
    UINT        CtlID;
    HWND        hwndItem;
    UINT        itemID1;
    ULONG_PTR   itemData1;
    UINT        itemID2;
    ULONG_PTR   itemData2;
    DWORD       dwLocaleId;
} COMPAREITEMSTRUCT,  *PCOMPAREITEMSTRUCT,  *LPCOMPAREITEMSTRUCT;

#line 3388 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"
#pragma endregion



#pragma region Desktop Family or Games Family


/*
 * Message Function Templates
 */

__declspec(dllimport)
BOOL
__stdcall
GetMessageA(
     LPMSG lpMsg,
     HWND hWnd,
     UINT wMsgFilterMin,
     UINT wMsgFilterMax);
__declspec(dllimport)
BOOL
__stdcall
GetMessageW(
     LPMSG lpMsg,
     HWND hWnd,
     UINT wMsgFilterMin,
     UINT wMsgFilterMax);




#line 3420 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"























#line 3444 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"


__declspec(dllimport)
BOOL
__stdcall
TranslateMessage(
     const MSG *lpMsg);

__declspec(dllimport)
LRESULT
__stdcall
DispatchMessageA(
     const MSG *lpMsg);
__declspec(dllimport)
LRESULT
__stdcall
DispatchMessageW(
     const MSG *lpMsg);




#line 3467 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"

















#line 3485 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"

#line 3487 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"
#pragma endregion

#pragma region Desktop Family


__declspec(dllimport)
BOOL
__stdcall
SetMessageQueue(
     int cMessagesMax);

#line 3499 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"
#pragma endregion

#pragma region Desktop Family or Games Family


__declspec(dllimport)
BOOL
__stdcall
PeekMessageA(
     LPMSG lpMsg,
     HWND hWnd,
     UINT wMsgFilterMin,
     UINT wMsgFilterMax,
     UINT wRemoveMsg);
__declspec(dllimport)
BOOL
__stdcall
PeekMessageW(
     LPMSG lpMsg,
     HWND hWnd,
     UINT wMsgFilterMin,
     UINT wMsgFilterMax,
     UINT wRemoveMsg);




#line 3527 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"

#line 3529 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"
#pragma endregion

/*
 * PeekMessage() Options
 */










#line 3545 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"


#line 3548 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"

#pragma region Desktop Family


__declspec(dllimport)
BOOL
__stdcall
RegisterHotKey(
     HWND hWnd,
     int id,
     UINT fsModifiers,
     UINT vk);

__declspec(dllimport)
BOOL
__stdcall
UnregisterHotKey(
     HWND hWnd,
     int id);

#line 3569 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"
#pragma endregion







#line 3578 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"















#line 3594 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"



#line 3598 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"


#line 3601 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"


#line 3604 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"








#line 3613 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"



#line 3617 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"





#pragma region Desktop Family







__declspec(dllimport)
BOOL
__stdcall
ExitWindowsEx(
     UINT uFlags,
     DWORD dwReason);

__declspec(dllimport)
BOOL
__stdcall
SwapMouseButton(
     BOOL fSwap);

__declspec(dllimport)
DWORD
__stdcall
GetMessagePos(
    void );

__declspec(dllimport)
LONG
__stdcall
GetMessageTime(
    void );

__declspec(dllimport)
LPARAM
__stdcall
GetMessageExtraInfo(
    void );







#line 3668 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"


__declspec(dllimport)
BOOL
__stdcall
IsWow64Message(
    void );
#line 3676 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"


__declspec(dllimport)
LPARAM
__stdcall
SetMessageExtraInfo(
     LPARAM lParam);
#line 3684 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"

#line 3686 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"
#pragma endregion

#pragma region Desktop Family or Games Family


__declspec(dllimport)
LRESULT
__stdcall
SendMessageA(
     HWND hWnd,
     UINT Msg,
      WPARAM wParam,
      LPARAM lParam);
__declspec(dllimport)
LRESULT
__stdcall
SendMessageW(
     HWND hWnd,
     UINT Msg,
      WPARAM wParam,
      LPARAM lParam);




#line 3712 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"























#line 3736 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"

#line 3738 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"
#pragma endregion

#pragma region Desktop Family


__declspec(dllimport)
LRESULT
__stdcall
SendMessageTimeoutA(
     HWND hWnd,
     UINT Msg,
     WPARAM wParam,
     LPARAM lParam,
     UINT fuFlags,
     UINT uTimeout,
     PDWORD_PTR lpdwResult);
__declspec(dllimport)
LRESULT
__stdcall
SendMessageTimeoutW(
     HWND hWnd,
     UINT Msg,
     WPARAM wParam,
     LPARAM lParam,
     UINT fuFlags,
     UINT uTimeout,
     PDWORD_PTR lpdwResult);




#line 3770 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"

__declspec(dllimport)
BOOL
__stdcall
SendNotifyMessageA(
     HWND hWnd,
     UINT Msg,
     WPARAM wParam,
     LPARAM lParam);
__declspec(dllimport)
BOOL
__stdcall
SendNotifyMessageW(
     HWND hWnd,
     UINT Msg,
     WPARAM wParam,
     LPARAM lParam);




#line 3792 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"

__declspec(dllimport)
BOOL
__stdcall
SendMessageCallbackA(
     HWND hWnd,
     UINT Msg,
     WPARAM wParam,
     LPARAM lParam,
     SENDASYNCPROC lpResultCallBack,
     ULONG_PTR dwData);
__declspec(dllimport)
BOOL
__stdcall
SendMessageCallbackW(
     HWND hWnd,
     UINT Msg,
     WPARAM wParam,
     LPARAM lParam,
     SENDASYNCPROC lpResultCallBack,
     ULONG_PTR dwData);




#line 3818 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"


typedef struct {
    UINT  cbSize;
    HDESK hdesk;
    HWND  hwnd;
    LUID  luid;
} BSMINFO, *PBSMINFO;

__declspec(dllimport)
long
__stdcall
BroadcastSystemMessageExA(
     DWORD flags,
     LPDWORD lpInfo,
     UINT Msg,
     WPARAM wParam,
     LPARAM lParam,
     PBSMINFO pbsmInfo);
__declspec(dllimport)
long
__stdcall
BroadcastSystemMessageExW(
     DWORD flags,
     LPDWORD lpInfo,
     UINT Msg,
     WPARAM wParam,
     LPARAM lParam,
     PBSMINFO pbsmInfo);




#line 3852 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"
#line 3853 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"

#line 3855 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"
#pragma endregion



#pragma region Desktop Family



__declspec(dllimport)
long
__stdcall
BroadcastSystemMessageA(
     DWORD flags,
     LPDWORD lpInfo,
     UINT Msg,
     WPARAM wParam,
     LPARAM lParam);
__declspec(dllimport)
long
__stdcall
BroadcastSystemMessageW(
     DWORD flags,
     LPDWORD lpInfo,
     UINT Msg,
     WPARAM wParam,
     LPARAM lParam);




#line 3886 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"












#line 3899 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"

#line 3901 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"
#pragma endregion

//Broadcast Special Message Recipient list







//Broadcast Special Message Flags










#line 3923 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"



#line 3927 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"


#line 3930 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"

// RegisterDeviceNotification

#pragma region Desktop Family



typedef  PVOID           HDEVNOTIFY;
typedef  HDEVNOTIFY     *PHDEVNOTIFY;





#line 3945 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"

__declspec(dllimport)
HDEVNOTIFY
__stdcall
RegisterDeviceNotificationA(
     HANDLE hRecipient,
     LPVOID NotificationFilter,
     DWORD Flags);
__declspec(dllimport)
HDEVNOTIFY
__stdcall
RegisterDeviceNotificationW(
     HANDLE hRecipient,
     LPVOID NotificationFilter,
     DWORD Flags);




#line 3965 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"

__declspec(dllimport)
BOOL
__stdcall
UnregisterDeviceNotification(
     HDEVNOTIFY Handle
    );







typedef  PVOID           HPOWERNOTIFY;
typedef  HPOWERNOTIFY   *PHPOWERNOTIFY;

#line 3983 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"

__declspec(dllimport)
HPOWERNOTIFY
__stdcall
RegisterPowerSettingNotification(
     HANDLE hRecipient,
     LPCGUID PowerSettingGuid,
     DWORD Flags
    );

__declspec(dllimport)
BOOL
__stdcall
UnregisterPowerSettingNotification(
     HPOWERNOTIFY Handle
    );

__declspec(dllimport)
HPOWERNOTIFY
__stdcall
RegisterSuspendResumeNotification (
     HANDLE hRecipient,
     DWORD Flags
    );

__declspec(dllimport)
BOOL
__stdcall
UnregisterSuspendResumeNotification (
     HPOWERNOTIFY Handle
    );


#line 4017 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"
#line 4018 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"

#line 4020 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"
#pragma endregion

#pragma region Desktop Family


__declspec(dllimport)
BOOL
__stdcall
PostMessageA(
     HWND hWnd,
     UINT Msg,
     WPARAM wParam,
     LPARAM lParam);
__declspec(dllimport)
BOOL
__stdcall
PostMessageW(
     HWND hWnd,
     UINT Msg,
     WPARAM wParam,
     LPARAM lParam);




#line 4046 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"

__declspec(dllimport)
BOOL
__stdcall
PostThreadMessageA(
     DWORD idThread,
     UINT Msg,
     WPARAM wParam,
     LPARAM lParam);
__declspec(dllimport)
BOOL
__stdcall
PostThreadMessageW(
     DWORD idThread,
     UINT Msg,
     WPARAM wParam,
     LPARAM lParam);




#line 4068 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"

#line 4070 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"
#pragma endregion









#line 4081 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"

/*
 * Special HWND value for use with PostMessage() and SendMessage()
 */




#line 4090 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"

#pragma region Desktop Family


__declspec(dllimport)
BOOL
__stdcall
AttachThreadInput(
     DWORD idAttach,
     DWORD idAttachTo,
     BOOL fAttach);


__declspec(dllimport)
BOOL
__stdcall
ReplyMessage(
     LRESULT lResult);

__declspec(dllimport)
BOOL
__stdcall
WaitMessage(
    void );


#line 4117 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"


__declspec(dllimport)
DWORD
__stdcall
WaitForInputIdle(
     HANDLE hProcess,
     DWORD dwMilliseconds);

#line 4127 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"
#pragma endregion

#pragma region Desktop Family or Games Family


__declspec(dllimport)

LRESULT
__stdcall



#line 4140 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"
DefWindowProcA(
     HWND hWnd,
     UINT Msg,
     WPARAM wParam,
     LPARAM lParam);
__declspec(dllimport)

LRESULT
__stdcall



#line 4153 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"
DefWindowProcW(
     HWND hWnd,
     UINT Msg,
     WPARAM wParam,
     LPARAM lParam);




#line 4163 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"

__declspec(dllimport)
void
__stdcall
PostQuitMessage(
     int nExitCode);



__declspec(dllimport)
LRESULT
__stdcall
CallWindowProcA(
     WNDPROC lpPrevWndFunc,
     HWND hWnd,
     UINT Msg,
     WPARAM wParam,
     LPARAM lParam);
__declspec(dllimport)
LRESULT
__stdcall
CallWindowProcW(
     WNDPROC lpPrevWndFunc,
     HWND hWnd,
     UINT Msg,
     WPARAM wParam,
     LPARAM lParam);




#line 4195 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"



























#line 4223 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"

#line 4225 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"
#pragma endregion

#pragma region Desktop Family


__declspec(dllimport)
BOOL
__stdcall
InSendMessage(
    void );

#line 4237 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"
#pragma endregion



#pragma region Desktop Family


__declspec(dllimport)
DWORD
__stdcall
InSendMessageEx(
     LPVOID lpReserved);

#line 4251 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"
#pragma endregion

/*
 * InSendMessageEx return value
 */





#line 4262 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"


#pragma region Desktop Family


__declspec(dllimport)
UINT
__stdcall
GetDoubleClickTime(
    void );

__declspec(dllimport)
BOOL
__stdcall
SetDoubleClickTime(
     UINT);

#line 4280 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"
#pragma endregion

#pragma region Desktop Family or Games Family


__declspec(dllimport)
ATOM
__stdcall
RegisterClassA(
     const WNDCLASSA *lpWndClass);
__declspec(dllimport)
ATOM
__stdcall
RegisterClassW(
     const WNDCLASSW *lpWndClass);




#line 4300 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"

__declspec(dllimport)
BOOL
__stdcall
UnregisterClassA(
     LPCSTR lpClassName,
     HINSTANCE hInstance);
__declspec(dllimport)
BOOL
__stdcall
UnregisterClassW(
     LPCWSTR lpClassName,
     HINSTANCE hInstance);




#line 4318 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"

#line 4320 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"
#pragma endregion

#pragma region Desktop Family



__declspec(dllimport)
BOOL
__stdcall
GetClassInfoA(
     HINSTANCE hInstance,
     LPCSTR lpClassName,
     LPWNDCLASSA lpWndClass);

__declspec(dllimport)
BOOL
__stdcall
GetClassInfoW(
     HINSTANCE hInstance,
     LPCWSTR lpClassName,
     LPWNDCLASSW lpWndClass);




#line 4346 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"

#line 4348 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"
#pragma endregion

#pragma region Desktop Family or Games Family



__declspec(dllimport)
ATOM
__stdcall
RegisterClassExA(
     const WNDCLASSEXA *);
__declspec(dllimport)
ATOM
__stdcall
RegisterClassExW(
     const WNDCLASSEXW *);




#line 4369 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"

#line 4371 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"
#pragma endregion

#pragma region Desktop Family



__declspec(dllimport)
BOOL
__stdcall
GetClassInfoExA(
     HINSTANCE hInstance,
     LPCSTR lpszClass,
     LPWNDCLASSEXA lpwcx);

__declspec(dllimport)
BOOL
__stdcall
GetClassInfoExW(
     HINSTANCE hInstance,
     LPCWSTR lpszClass,
     LPWNDCLASSEXW lpwcx);




#line 4397 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"

#line 4399 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"

#line 4401 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"
#pragma endregion



/*
 * Special value for CreateWindow, et al.
 */


#pragma region Desktop Family or Games Family



typedef BOOLEAN (__stdcall * PREGISTERCLASSNAMEW)(LPCWSTR);
#line 4416 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"

__declspec(dllimport)
HWND
__stdcall
CreateWindowExA(
     DWORD dwExStyle,
     LPCSTR lpClassName,
     LPCSTR lpWindowName,
     DWORD dwStyle,
     int X,
     int Y,
     int nWidth,
     int nHeight,
     HWND hWndParent,
     HMENU hMenu,
     HINSTANCE hInstance,
     LPVOID lpParam);
__declspec(dllimport)
HWND
__stdcall
CreateWindowExW(
     DWORD dwExStyle,
     LPCWSTR lpClassName,
     LPCWSTR lpWindowName,
     DWORD dwStyle,
     int X,
     int Y,
     int nWidth,
     int nHeight,
     HWND hWndParent,
     HMENU hMenu,
     HINSTANCE hInstance,
     LPVOID lpParam);




#line 4454 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"

#line 4456 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"
#pragma endregion











#line 4471 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"

#pragma region Desktop Family



__declspec(dllimport)
BOOL
__stdcall
IsWindow(
     HWND hWnd);


__declspec(dllimport)
BOOL
__stdcall
IsMenu(
     HMENU hMenu);

__declspec(dllimport)
BOOL
__stdcall
IsChild(
     HWND hWndParent,
     HWND hWnd);

#line 4497 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"
#pragma endregion

#pragma region Desktop or Games Family


__declspec(dllimport)
BOOL
__stdcall
DestroyWindow(
     HWND hWnd);

__declspec(dllimport)
BOOL
__stdcall
ShowWindow(
     HWND hWnd,
     int nCmdShow);

#line 4516 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"
#pragma endregion

#pragma region Desktop Family



__declspec(dllimport)
BOOL
__stdcall
AnimateWindow(
     HWND hWnd,
     DWORD dwTime,
     DWORD dwFlags);
#line 4530 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"

#line 4532 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"
#pragma endregion




#pragma region Desktop Family


__declspec(dllimport)
BOOL
__stdcall
UpdateLayeredWindow(
     HWND hWnd,
     HDC hdcDst,
     POINT* pptDst,
     SIZE* psize,
     HDC hdcSrc,
     POINT* pptSrc,
     COLORREF crKey,
     BLENDFUNCTION* pblend,
     DWORD dwFlags);

/*
 * Layered Window Update information
 */
typedef struct tagUPDATELAYEREDWINDOWINFO
{
    DWORD cbSize;
    HDC hdcDst;
    const POINT* pptDst;
    const SIZE* psize;
    HDC hdcSrc;
    const POINT* pptSrc;
    COLORREF crKey;
    const BLENDFUNCTION* pblend;
    DWORD dwFlags;
    const RECT* prcDirty;
} UPDATELAYEREDWINDOWINFO, *PUPDATELAYEREDWINDOWINFO;




#line 4575 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"
__declspec(dllimport)
BOOL
__stdcall
UpdateLayeredWindowIndirect(
     HWND hWnd,
     const UPDATELAYEREDWINDOWINFO* pULWInfo);

#line 4583 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"
#pragma endregion

#line 4586 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"



#pragma region Desktop Family


__declspec(dllimport)
BOOL
__stdcall
GetLayeredWindowAttributes(
     HWND hwnd,
     COLORREF* pcrKey,
     BYTE* pbAlpha,
     DWORD* pdwFlags);





#line 4606 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"


__declspec(dllimport)
BOOL
__stdcall
PrintWindow(
     HWND hwnd,
     HDC hdcBlt,
     UINT nFlags);

#line 4617 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"
#pragma endregion

#line 4620 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"

#pragma region Desktop Family


__declspec(dllimport)
BOOL
__stdcall
SetLayeredWindowAttributes(
     HWND hwnd,
     COLORREF crKey,
     BYTE bAlpha,
     DWORD dwFlags);

#line 4634 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"
#pragma endregion











#line 4647 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"


#pragma region Desktop Family




__declspec(dllimport)
BOOL
__stdcall
ShowWindowAsync(
      HWND hWnd,
      int nCmdShow);
#line 4661 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"

__declspec(dllimport)
BOOL
__stdcall
FlashWindow(
      HWND hWnd,
      BOOL bInvert);


typedef struct {
    UINT  cbSize;
    HWND  hwnd;
    DWORD dwFlags;
    UINT  uCount;
    DWORD dwTimeout;
} FLASHWINFO, *PFLASHWINFO;

__declspec(dllimport)
BOOL
__stdcall
FlashWindowEx(
     PFLASHWINFO pfwi);








#line 4692 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"

__declspec(dllimport)
BOOL
__stdcall
ShowOwnedPopups(
      HWND hWnd,
      BOOL fShow);

__declspec(dllimport)
BOOL
__stdcall
OpenIcon(
      HWND hWnd);

__declspec(dllimport)
BOOL
__stdcall
CloseWindow(
      HWND hWnd);

#line 4713 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"
#pragma endregion

#pragma region Desktop Family


__declspec(dllimport)
BOOL
__stdcall
MoveWindow(
     HWND hWnd,
     int X,
     int Y,
     int nWidth,
     int nHeight,
     BOOL bRepaint);

__declspec(dllimport)
BOOL
__stdcall
SetWindowPos(
     HWND hWnd,
     HWND hWndInsertAfter,
     int X,
     int Y,
     int cx,
     int cy,
     UINT uFlags);

#line 4742 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"
#pragma endregion

#pragma region Desktop Family


__declspec(dllimport)
BOOL
__stdcall
GetWindowPlacement(
     HWND hWnd,
     WINDOWPLACEMENT *lpwndpl);

__declspec(dllimport)
BOOL
__stdcall
SetWindowPlacement(
     HWND hWnd,
     const WINDOWPLACEMENT *lpwndpl);






__declspec(dllimport)
BOOL
__stdcall
GetWindowDisplayAffinity(
     HWND hWnd,
     DWORD* pdwAffinity);

__declspec(dllimport)
BOOL
__stdcall
SetWindowDisplayAffinity(
     HWND hWnd,
     DWORD dwAffinity);

#line 4781 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"

#line 4783 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"
#pragma endregion



#pragma region Desktop Family


__declspec(dllimport)
HDWP
__stdcall
BeginDeferWindowPos(
     int nNumWindows);

__declspec(dllimport)
HDWP
__stdcall
DeferWindowPos(
     HDWP hWinPosInfo,
     HWND hWnd,
     HWND hWndInsertAfter,
     int x,
     int y,
     int cx,
     int cy,
     UINT uFlags);


__declspec(dllimport)
BOOL
__stdcall
EndDeferWindowPos(
     HDWP hWinPosInfo);

#line 4817 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"
#pragma endregion

#line 4820 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"

#pragma region Desktop Family


__declspec(dllimport)
BOOL
__stdcall
IsWindowVisible(
     HWND hWnd);

#line 4831 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"
#pragma endregion

#pragma region Desktop Family


__declspec(dllimport)
BOOL
__stdcall
IsIconic(
     HWND hWnd);

__declspec(dllimport)
BOOL
__stdcall
AnyPopup(
    void );

__declspec(dllimport)
BOOL
__stdcall
BringWindowToTop(
     HWND hWnd);

__declspec(dllimport)
BOOL
__stdcall
IsZoomed(
     HWND hWnd);

#line 4861 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"
#pragma endregion

/*
 * SetWindowPos Flags
 */


















#line 4885 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"









/*
 * WARNING:
 * The following structures must NOT be DWORD padded because they are
 * followed by strings, etc that do not have to be DWORD aligned.
 */
#line 1 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\shared\\pshpack2.h"
/*++

Copyright (c) Microsoft Corporation.  All rights reserved.

Module Name:

    pshpack2.h

Abstract:

    This file turns 2 byte packing of structures on.  (That is, it disables
    automatic alignment of structure fields.)  An include file is needed
    because various compilers do this in different ways.  For Microsoft
    compatible compilers, this files uses the push option to the pack pragma
    so that the poppack.h include file can restore the previous packing
    reliably.

    The file poppack.h is the complement to this file.

--*/



#pragma warning(disable:4103)

#pragma pack(push,2)


#line 30 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\shared\\pshpack2.h"


#line 33 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\shared\\pshpack2.h"
#line 34 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\shared\\pshpack2.h"
#line 4900 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"

#pragma region Application Family or OneCore Family


/*
 * original NT 32 bit dialog template:
 */
typedef struct {
    DWORD style;
    DWORD dwExtendedStyle;
    WORD cdit;
    short x;
    short y;
    short cx;
    short cy;
} DLGTEMPLATE;

#line 4918 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"
#pragma endregion

#pragma region Desktop Family


typedef DLGTEMPLATE *LPDLGTEMPLATEA;
typedef DLGTEMPLATE *LPDLGTEMPLATEW;



typedef LPDLGTEMPLATEA LPDLGTEMPLATE;
#line 4930 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"

#line 4932 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"
#pragma endregion

#pragma region Application Family or OneCore Family


typedef const DLGTEMPLATE *LPCDLGTEMPLATEA;
typedef const DLGTEMPLATE *LPCDLGTEMPLATEW;



typedef LPCDLGTEMPLATEA LPCDLGTEMPLATE;
#line 4944 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"

#line 4946 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"
#pragma endregion


#pragma region Desktop Family


/*
 * 32 bit Dialog item template.
 */
typedef struct {
    DWORD style;
    DWORD dwExtendedStyle;
    short x;
    short y;
    short cx;
    short cy;
    WORD id;
} DLGITEMTEMPLATE;
typedef DLGITEMTEMPLATE *PDLGITEMTEMPLATEA;
typedef DLGITEMTEMPLATE *PDLGITEMTEMPLATEW;



typedef PDLGITEMTEMPLATEA PDLGITEMTEMPLATE;
#line 4971 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"
typedef DLGITEMTEMPLATE *LPDLGITEMTEMPLATEA;
typedef DLGITEMTEMPLATE *LPDLGITEMTEMPLATEW;



typedef LPDLGITEMTEMPLATEA LPDLGITEMTEMPLATE;
#line 4978 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"

#line 4980 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"
#pragma endregion


#line 1 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\shared\\poppack.h"
/*++

Copyright (c) Microsoft Corporation.  All rights reserved.

Module Name:

    poppack.h

Abstract:

    This file turns packing of structures off.  (That is, it enables
    automatic alignment of structure fields.)  An include file is needed
    because various compilers do this in different ways.

    poppack.h is the complement to pshpack?.h.  An inclusion of poppack.h
    MUST ALWAYS be preceded by an inclusion of one of pshpack?.h, in one-to-one
    correspondence.

    For Microsoft compatible compilers, this file uses the pop option
    to the pack pragma so that it can restore the previous saved by the
    pshpack?.h include file.

--*/



#pragma warning(disable:4103)

#pragma pack(pop)


#line 33 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\shared\\poppack.h"


#line 36 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\shared\\poppack.h"
#line 37 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\shared\\poppack.h"
#line 4984 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"

#pragma region Desktop Family


__declspec(dllimport)
HWND
__stdcall
CreateDialogParamA(
     HINSTANCE hInstance,
     LPCSTR lpTemplateName,
     HWND hWndParent,
     DLGPROC lpDialogFunc,
     LPARAM dwInitParam);
__declspec(dllimport)
HWND
__stdcall
CreateDialogParamW(
     HINSTANCE hInstance,
     LPCWSTR lpTemplateName,
     HWND hWndParent,
     DLGPROC lpDialogFunc,
     LPARAM dwInitParam);




#line 5011 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"

__declspec(dllimport)
HWND
__stdcall
CreateDialogIndirectParamA(
     HINSTANCE hInstance,
     LPCDLGTEMPLATEA lpTemplate,
     HWND hWndParent,
     DLGPROC lpDialogFunc,
     LPARAM dwInitParam);
__declspec(dllimport)
HWND
__stdcall
CreateDialogIndirectParamW(
     HINSTANCE hInstance,
     LPCDLGTEMPLATEW lpTemplate,
     HWND hWndParent,
     DLGPROC lpDialogFunc,
     LPARAM dwInitParam);




#line 5035 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"









#line 5045 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"









#line 5055 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"

__declspec(dllimport)
INT_PTR
__stdcall
DialogBoxParamA(
     HINSTANCE hInstance,
     LPCSTR lpTemplateName,
     HWND hWndParent,
     DLGPROC lpDialogFunc,
     LPARAM dwInitParam);
__declspec(dllimport)
INT_PTR
__stdcall
DialogBoxParamW(
     HINSTANCE hInstance,
     LPCWSTR lpTemplateName,
     HWND hWndParent,
     DLGPROC lpDialogFunc,
     LPARAM dwInitParam);




#line 5079 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"

__declspec(dllimport)
INT_PTR
__stdcall
DialogBoxIndirectParamA(
     HINSTANCE hInstance,
     LPCDLGTEMPLATEA hDialogTemplate,
     HWND hWndParent,
     DLGPROC lpDialogFunc,
     LPARAM dwInitParam);
__declspec(dllimport)
INT_PTR
__stdcall
DialogBoxIndirectParamW(
     HINSTANCE hInstance,
     LPCDLGTEMPLATEW hDialogTemplate,
     HWND hWndParent,
     DLGPROC lpDialogFunc,
     LPARAM dwInitParam);




#line 5103 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"









#line 5113 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"









#line 5123 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"

__declspec(dllimport)
BOOL
__stdcall
EndDialog(
     HWND hDlg,
     INT_PTR nResult);

__declspec(dllimport)
HWND
__stdcall
GetDlgItem(
     HWND hDlg,
     int nIDDlgItem);

__declspec(dllimport)
BOOL
__stdcall
SetDlgItemInt(
     HWND hDlg,
     int nIDDlgItem,
     UINT uValue,
     BOOL bSigned);

__declspec(dllimport)
UINT
__stdcall
GetDlgItemInt(
     HWND hDlg,
     int nIDDlgItem,
     BOOL *lpTranslated,
     BOOL bSigned);

__declspec(dllimport)
BOOL
__stdcall
SetDlgItemTextA(
     HWND hDlg,
     int nIDDlgItem,
     LPCSTR lpString);
__declspec(dllimport)
BOOL
__stdcall
SetDlgItemTextW(
     HWND hDlg,
     int nIDDlgItem,
     LPCWSTR lpString);




#line 5175 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"


__declspec(dllimport)
UINT
__stdcall
GetDlgItemTextA(
     HWND hDlg,
     int nIDDlgItem,
     LPSTR lpString,
     int cchMax);

__declspec(dllimport)
UINT
__stdcall
GetDlgItemTextW(
     HWND hDlg,
     int nIDDlgItem,
     LPWSTR lpString,
     int cchMax);




#line 5199 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"

__declspec(dllimport)
BOOL
__stdcall
CheckDlgButton(
     HWND hDlg,
     int nIDButton,
     UINT uCheck);

__declspec(dllimport)
BOOL
__stdcall
CheckRadioButton(
     HWND hDlg,
     int nIDFirstButton,
     int nIDLastButton,
     int nIDCheckButton);

__declspec(dllimport)
UINT
__stdcall
IsDlgButtonChecked(
     HWND hDlg,
     int nIDButton);

__declspec(dllimport)
LRESULT
__stdcall
SendDlgItemMessageA(
     HWND hDlg,
     int nIDDlgItem,
     UINT Msg,
     WPARAM wParam,
     LPARAM lParam);
__declspec(dllimport)
LRESULT
__stdcall
SendDlgItemMessageW(
     HWND hDlg,
     int nIDDlgItem,
     UINT Msg,
     WPARAM wParam,
     LPARAM lParam);




#line 5247 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"

__declspec(dllimport)
HWND
__stdcall
GetNextDlgGroupItem(
     HWND hDlg,
     HWND hCtl,
     BOOL bPrevious);

__declspec(dllimport)
HWND
__stdcall
GetNextDlgTabItem(
     HWND hDlg,
     HWND hCtl,
     BOOL bPrevious);

__declspec(dllimport)
int
__stdcall
GetDlgCtrlID(
     HWND hWnd);

__declspec(dllimport)
long
__stdcall
GetDialogBaseUnits(void );


__declspec(dllimport)

LRESULT
__stdcall



#line 5284 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"
DefDlgProcA(
     HWND hDlg,
     UINT Msg,
     WPARAM wParam,
     LPARAM lParam);
__declspec(dllimport)

LRESULT
__stdcall



#line 5297 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"
DefDlgProcW(
     HWND hDlg,
     UINT Msg,
     WPARAM wParam,
     LPARAM lParam);




#line 5307 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"


typedef enum DIALOG_CONTROL_DPI_CHANGE_BEHAVIORS {
     DCDC_DEFAULT                  = 0x0000,
     DCDC_DISABLE_FONT_UPDATE      = 0x0001,
     DCDC_DISABLE_RELAYOUT         = 0x0002,
} DIALOG_CONTROL_DPI_CHANGE_BEHAVIORS;


extern "C++" { inline constexpr DIALOG_CONTROL_DPI_CHANGE_BEHAVIORS operator | (DIALOG_CONTROL_DPI_CHANGE_BEHAVIORS a, DIALOG_CONTROL_DPI_CHANGE_BEHAVIORS b) throw() { return DIALOG_CONTROL_DPI_CHANGE_BEHAVIORS(((_ENUM_FLAG_SIZED_INTEGER<DIALOG_CONTROL_DPI_CHANGE_BEHAVIORS>::type)a) | ((_ENUM_FLAG_SIZED_INTEGER<DIALOG_CONTROL_DPI_CHANGE_BEHAVIORS>::type)b)); } inline DIALOG_CONTROL_DPI_CHANGE_BEHAVIORS &operator |= (DIALOG_CONTROL_DPI_CHANGE_BEHAVIORS &a, DIALOG_CONTROL_DPI_CHANGE_BEHAVIORS b) throw() { return (DIALOG_CONTROL_DPI_CHANGE_BEHAVIORS &)(((_ENUM_FLAG_SIZED_INTEGER<DIALOG_CONTROL_DPI_CHANGE_BEHAVIORS>::type &)a) |= ((_ENUM_FLAG_SIZED_INTEGER<DIALOG_CONTROL_DPI_CHANGE_BEHAVIORS>::type)b)); } inline constexpr DIALOG_CONTROL_DPI_CHANGE_BEHAVIORS operator & (DIALOG_CONTROL_DPI_CHANGE_BEHAVIORS a, DIALOG_CONTROL_DPI_CHANGE_BEHAVIORS b) throw() { return DIALOG_CONTROL_DPI_CHANGE_BEHAVIORS(((_ENUM_FLAG_SIZED_INTEGER<DIALOG_CONTROL_DPI_CHANGE_BEHAVIORS>::type)a) & ((_ENUM_FLAG_SIZED_INTEGER<DIALOG_CONTROL_DPI_CHANGE_BEHAVIORS>::type)b)); } inline DIALOG_CONTROL_DPI_CHANGE_BEHAVIORS &operator &= (DIALOG_CONTROL_DPI_CHANGE_BEHAVIORS &a, DIALOG_CONTROL_DPI_CHANGE_BEHAVIORS b) throw() { return (DIALOG_CONTROL_DPI_CHANGE_BEHAVIORS &)(((_ENUM_FLAG_SIZED_INTEGER<DIALOG_CONTROL_DPI_CHANGE_BEHAVIORS>::type &)a) &= ((_ENUM_FLAG_SIZED_INTEGER<DIALOG_CONTROL_DPI_CHANGE_BEHAVIORS>::type)b)); } inline constexpr DIALOG_CONTROL_DPI_CHANGE_BEHAVIORS operator ~ (DIALOG_CONTROL_DPI_CHANGE_BEHAVIORS a) throw() { return DIALOG_CONTROL_DPI_CHANGE_BEHAVIORS(~((_ENUM_FLAG_SIZED_INTEGER<DIALOG_CONTROL_DPI_CHANGE_BEHAVIORS>::type)a)); } inline constexpr DIALOG_CONTROL_DPI_CHANGE_BEHAVIORS operator ^ (DIALOG_CONTROL_DPI_CHANGE_BEHAVIORS a, DIALOG_CONTROL_DPI_CHANGE_BEHAVIORS b) throw() { return DIALOG_CONTROL_DPI_CHANGE_BEHAVIORS(((_ENUM_FLAG_SIZED_INTEGER<DIALOG_CONTROL_DPI_CHANGE_BEHAVIORS>::type)a) ^ ((_ENUM_FLAG_SIZED_INTEGER<DIALOG_CONTROL_DPI_CHANGE_BEHAVIORS>::type)b)); } inline DIALOG_CONTROL_DPI_CHANGE_BEHAVIORS &operator ^= (DIALOG_CONTROL_DPI_CHANGE_BEHAVIORS &a, DIALOG_CONTROL_DPI_CHANGE_BEHAVIORS b) throw() { return (DIALOG_CONTROL_DPI_CHANGE_BEHAVIORS &)(((_ENUM_FLAG_SIZED_INTEGER<DIALOG_CONTROL_DPI_CHANGE_BEHAVIORS>::type &)a) ^= ((_ENUM_FLAG_SIZED_INTEGER<DIALOG_CONTROL_DPI_CHANGE_BEHAVIORS>::type)b)); } } ;
#line 5318 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"

BOOL
__stdcall
SetDialogControlDpiChangeBehavior(
     HWND hWnd,
     DIALOG_CONTROL_DPI_CHANGE_BEHAVIORS mask,
     DIALOG_CONTROL_DPI_CHANGE_BEHAVIORS values);

DIALOG_CONTROL_DPI_CHANGE_BEHAVIORS
__stdcall
GetDialogControlDpiChangeBehavior(
     HWND hWnd);

typedef enum DIALOG_DPI_CHANGE_BEHAVIORS {
    DDC_DEFAULT                     = 0x0000,
    DDC_DISABLE_ALL                 = 0x0001,
    DDC_DISABLE_RESIZE              = 0x0002,
    DDC_DISABLE_CONTROL_RELAYOUT    = 0x0004,
} DIALOG_DPI_CHANGE_BEHAVIORS;


extern "C++" { inline constexpr DIALOG_DPI_CHANGE_BEHAVIORS operator | (DIALOG_DPI_CHANGE_BEHAVIORS a, DIALOG_DPI_CHANGE_BEHAVIORS b) throw() { return DIALOG_DPI_CHANGE_BEHAVIORS(((_ENUM_FLAG_SIZED_INTEGER<DIALOG_DPI_CHANGE_BEHAVIORS>::type)a) | ((_ENUM_FLAG_SIZED_INTEGER<DIALOG_DPI_CHANGE_BEHAVIORS>::type)b)); } inline DIALOG_DPI_CHANGE_BEHAVIORS &operator |= (DIALOG_DPI_CHANGE_BEHAVIORS &a, DIALOG_DPI_CHANGE_BEHAVIORS b) throw() { return (DIALOG_DPI_CHANGE_BEHAVIORS &)(((_ENUM_FLAG_SIZED_INTEGER<DIALOG_DPI_CHANGE_BEHAVIORS>::type &)a) |= ((_ENUM_FLAG_SIZED_INTEGER<DIALOG_DPI_CHANGE_BEHAVIORS>::type)b)); } inline constexpr DIALOG_DPI_CHANGE_BEHAVIORS operator & (DIALOG_DPI_CHANGE_BEHAVIORS a, DIALOG_DPI_CHANGE_BEHAVIORS b) throw() { return DIALOG_DPI_CHANGE_BEHAVIORS(((_ENUM_FLAG_SIZED_INTEGER<DIALOG_DPI_CHANGE_BEHAVIORS>::type)a) & ((_ENUM_FLAG_SIZED_INTEGER<DIALOG_DPI_CHANGE_BEHAVIORS>::type)b)); } inline DIALOG_DPI_CHANGE_BEHAVIORS &operator &= (DIALOG_DPI_CHANGE_BEHAVIORS &a, DIALOG_DPI_CHANGE_BEHAVIORS b) throw() { return (DIALOG_DPI_CHANGE_BEHAVIORS &)(((_ENUM_FLAG_SIZED_INTEGER<DIALOG_DPI_CHANGE_BEHAVIORS>::type &)a) &= ((_ENUM_FLAG_SIZED_INTEGER<DIALOG_DPI_CHANGE_BEHAVIORS>::type)b)); } inline constexpr DIALOG_DPI_CHANGE_BEHAVIORS operator ~ (DIALOG_DPI_CHANGE_BEHAVIORS a) throw() { return DIALOG_DPI_CHANGE_BEHAVIORS(~((_ENUM_FLAG_SIZED_INTEGER<DIALOG_DPI_CHANGE_BEHAVIORS>::type)a)); } inline constexpr DIALOG_DPI_CHANGE_BEHAVIORS operator ^ (DIALOG_DPI_CHANGE_BEHAVIORS a, DIALOG_DPI_CHANGE_BEHAVIORS b) throw() { return DIALOG_DPI_CHANGE_BEHAVIORS(((_ENUM_FLAG_SIZED_INTEGER<DIALOG_DPI_CHANGE_BEHAVIORS>::type)a) ^ ((_ENUM_FLAG_SIZED_INTEGER<DIALOG_DPI_CHANGE_BEHAVIORS>::type)b)); } inline DIALOG_DPI_CHANGE_BEHAVIORS &operator ^= (DIALOG_DPI_CHANGE_BEHAVIORS &a, DIALOG_DPI_CHANGE_BEHAVIORS b) throw() { return (DIALOG_DPI_CHANGE_BEHAVIORS &)(((_ENUM_FLAG_SIZED_INTEGER<DIALOG_DPI_CHANGE_BEHAVIORS>::type &)a) ^= ((_ENUM_FLAG_SIZED_INTEGER<DIALOG_DPI_CHANGE_BEHAVIORS>::type)b)); } } ;
#line 5341 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"

BOOL
__stdcall
SetDialogDpiChangeBehavior(
     HWND hDlg,
     DIALOG_DPI_CHANGE_BEHAVIORS mask,
     DIALOG_DPI_CHANGE_BEHAVIORS values);

DIALOG_DPI_CHANGE_BEHAVIORS
__stdcall
GetDialogDpiChangeBehavior(
     HWND hDlg);

#line 5355 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"
#pragma endregion

/*
 * Window extra byted needed for private dialog classes.
 */




#line 5365 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"

#line 5367 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"

#pragma region Desktop Family




__declspec(dllimport)
BOOL
__stdcall
CallMsgFilterA(
     LPMSG lpMsg,
     int nCode);
__declspec(dllimport)
BOOL
__stdcall
CallMsgFilterW(
     LPMSG lpMsg,
     int nCode);




#line 5390 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"

#line 5392 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"



/*
 * Clipboard Manager Functions
 */

__declspec(dllimport)
BOOL
__stdcall
OpenClipboard(
     HWND hWndNewOwner);

__declspec(dllimport)
BOOL
__stdcall
CloseClipboard(
    void );




__declspec(dllimport)
DWORD
__stdcall
GetClipboardSequenceNumber(
    void );

#line 5421 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"

__declspec(dllimport)
HWND
__stdcall
GetClipboardOwner(
    void );

__declspec(dllimport)
HWND
__stdcall
SetClipboardViewer(
     HWND hWndNewViewer);

__declspec(dllimport)
HWND
__stdcall
GetClipboardViewer(
    void );

__declspec(dllimport)
BOOL
__stdcall
ChangeClipboardChain(
     HWND hWndRemove,
     HWND hWndNewNext);

__declspec(dllimport)
HANDLE
__stdcall
SetClipboardData(
     UINT uFormat,
     HANDLE hMem);

__declspec(dllimport)
HANDLE
__stdcall
GetClipboardData(
     UINT uFormat);

__declspec(dllimport)
UINT
__stdcall
RegisterClipboardFormatA(
     LPCSTR lpszFormat);
__declspec(dllimport)
UINT
__stdcall
RegisterClipboardFormatW(
     LPCWSTR lpszFormat);




#line 5475 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"

__declspec(dllimport)
int
__stdcall
CountClipboardFormats(
    void );

__declspec(dllimport)
UINT
__stdcall
EnumClipboardFormats(
     UINT format);

__declspec(dllimport)
int
__stdcall
GetClipboardFormatNameA(
     UINT format,
     LPSTR lpszFormatName,
     int cchMaxCount);
__declspec(dllimport)
int
__stdcall
GetClipboardFormatNameW(
     UINT format,
     LPWSTR lpszFormatName,
     int cchMaxCount);




#line 5507 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"

__declspec(dllimport)
BOOL
__stdcall
EmptyClipboard(
    void );

__declspec(dllimport)
BOOL
__stdcall
IsClipboardFormatAvailable(
     UINT format);

__declspec(dllimport)
int
__stdcall
GetPriorityClipboardFormat(
     UINT *paFormatPriorityList,
     int cFormats);

__declspec(dllimport)
HWND
__stdcall
GetOpenClipboardWindow(
    void );


__declspec(dllimport)
BOOL
__stdcall
AddClipboardFormatListener(
     HWND hwnd);

__declspec(dllimport)
BOOL
__stdcall
RemoveClipboardFormatListener(
     HWND hwnd);

__declspec(dllimport)
BOOL
__stdcall
GetUpdatedClipboardFormats(
     PUINT lpuiFormats,
     UINT cFormats,
     PUINT pcFormatsOut);
#line 5554 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"

#line 5556 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"

/*
 * Character Translation Routines
 */

__declspec(dllimport)
BOOL
__stdcall
CharToOemA(
     LPCSTR pSrc,
     LPSTR pDst);
__declspec(dllimport)
BOOL
__stdcall
CharToOemW(
     LPCWSTR pSrc,
     LPSTR pDst);




#line 5578 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"


__declspec(dllimport)
BOOL
__stdcall
OemToCharA(
     LPCSTR pSrc,
     LPSTR pDst);

__declspec(dllimport)
BOOL
__stdcall
OemToCharW(
     LPCSTR pSrc,
     LPWSTR pDst);




#line 5598 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"

__declspec(dllimport)
BOOL
__stdcall
CharToOemBuffA(
     LPCSTR lpszSrc,
     LPSTR lpszDst,
     DWORD cchDstLength);
__declspec(dllimport)
BOOL
__stdcall
CharToOemBuffW(
     LPCWSTR lpszSrc,
     LPSTR lpszDst,
     DWORD cchDstLength);




#line 5618 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"

__declspec(dllimport)
BOOL
__stdcall
OemToCharBuffA(
     LPCSTR lpszSrc,
     LPSTR lpszDst,
     DWORD cchDstLength);
__declspec(dllimport)
BOOL
__stdcall
OemToCharBuffW(
     LPCSTR lpszSrc,
     LPWSTR lpszDst,
     DWORD cchDstLength);




#line 5638 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"

#line 5640 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"
#pragma endregion

#pragma region Desktop Family or OneCore Family


__declspec(dllimport)
LPSTR
__stdcall
CharUpperA(
     LPSTR lpsz);
__declspec(dllimport)
LPWSTR
__stdcall
CharUpperW(
     LPWSTR lpsz);




#line 5660 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"

__declspec(dllimport)
DWORD
__stdcall
CharUpperBuffA(
     LPSTR lpsz,
     DWORD cchLength);
__declspec(dllimport)
DWORD
__stdcall
CharUpperBuffW(
     LPWSTR lpsz,
     DWORD cchLength);




#line 5678 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"

__declspec(dllimport)
LPSTR
__stdcall
CharLowerA(
     LPSTR lpsz);
__declspec(dllimport)
LPWSTR
__stdcall
CharLowerW(
     LPWSTR lpsz);




#line 5694 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"

__declspec(dllimport)
DWORD
__stdcall
CharLowerBuffA(
     LPSTR lpsz,
     DWORD cchLength);
__declspec(dllimport)
DWORD
__stdcall
CharLowerBuffW(
     LPWSTR lpsz,
     DWORD cchLength);




#line 5712 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"

__declspec(dllimport)
LPSTR
__stdcall
CharNextA(
     LPCSTR lpsz);
__declspec(dllimport)
LPWSTR
__stdcall
CharNextW(
     LPCWSTR lpsz);




#line 5728 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"

__declspec(dllimport)
LPSTR
__stdcall
CharPrevA(
     LPCSTR lpszStart,
     LPCSTR lpszCurrent);
__declspec(dllimport)
LPWSTR
__stdcall
CharPrevW(
     LPCWSTR lpszStart,
     LPCWSTR lpszCurrent);




#line 5746 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"


__declspec(dllimport)
LPSTR
__stdcall
CharNextExA(
      WORD CodePage,
      LPCSTR lpCurrentChar,
      DWORD dwFlags);

__declspec(dllimport)
LPSTR
__stdcall
CharPrevExA(
      WORD CodePage,
      LPCSTR lpStart,
      LPCSTR lpCurrentChar,
      DWORD dwFlags);
#line 5765 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"

#line 5767 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"
#pragma endregion

/*
 * Compatibility defines for character translation routines
 */











#pragma region Desktop or OneCore Family



/*
 * Language dependent Routines
 */

__declspec(dllimport)
BOOL
__stdcall
IsCharAlphaA(
     CHAR ch);
__declspec(dllimport)
BOOL
__stdcall
IsCharAlphaW(
     WCHAR ch);




#line 5806 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"

__declspec(dllimport)
BOOL
__stdcall
IsCharAlphaNumericA(
     CHAR ch);
__declspec(dllimport)
BOOL
__stdcall
IsCharAlphaNumericW(
     WCHAR ch);




#line 5822 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"

__declspec(dllimport)
BOOL
__stdcall
IsCharUpperA(
     CHAR ch);
__declspec(dllimport)
BOOL
__stdcall
IsCharUpperW(
     WCHAR ch);




#line 5838 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"

__declspec(dllimport)
BOOL
__stdcall
IsCharLowerA(
     CHAR ch);
__declspec(dllimport)
BOOL
__stdcall
IsCharLowerW(
     WCHAR ch);




#line 5854 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"

#line 5856 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"

#line 5858 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"
#pragma endregion

#pragma region Desktop Family


__declspec(dllimport)
HWND
__stdcall
SetFocus(
     HWND hWnd);

__declspec(dllimport)
HWND
__stdcall
GetActiveWindow(
    void );

__declspec(dllimport)
HWND
__stdcall
GetFocus(
    void );

__declspec(dllimport)
UINT
__stdcall
GetKBCodePage(
    void );

__declspec(dllimport)
SHORT
__stdcall
GetKeyState(
     int nVirtKey);

__declspec(dllimport)
SHORT
__stdcall
GetAsyncKeyState(
     int vKey);

__declspec(dllimport)

BOOL
__stdcall
GetKeyboardState(
     PBYTE lpKeyState);

__declspec(dllimport)
BOOL
__stdcall
SetKeyboardState(
     LPBYTE lpKeyState);


#line 5914 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"
#pragma endregion

#pragma region  Desktop or PC Family


__declspec(dllimport)
int
__stdcall
GetKeyNameTextA(
     LONG lParam,
     LPSTR lpString,
     int cchSize);
__declspec(dllimport)
int
__stdcall
GetKeyNameTextW(
     LONG lParam,
     LPWSTR lpString,
     int cchSize);




#line 5938 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"

#line 5940 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"
#pragma endregion

#pragma region Desktop Family



__declspec(dllimport)
int
__stdcall
GetKeyboardType(
     int nTypeFlag);

__declspec(dllimport)
int
__stdcall
ToAscii(
     UINT uVirtKey,
     UINT uScanCode,
     const BYTE *lpKeyState,
     LPWORD lpChar,
     UINT uFlags);


__declspec(dllimport)
int
__stdcall
ToAsciiEx(
     UINT uVirtKey,
     UINT uScanCode,
     const BYTE *lpKeyState,
     LPWORD lpChar,
     UINT uFlags,
     HKL dwhkl);
#line 5974 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"

__declspec(dllimport)
int
__stdcall
ToUnicode(
     UINT wVirtKey,
     UINT wScanCode,
     const BYTE *lpKeyState,
     LPWSTR pwszBuff,
     int cchBuff,
     UINT wFlags);

__declspec(dllimport)
DWORD
__stdcall
OemKeyScan(
     WORD wOemChar);

__declspec(dllimport)
SHORT
__stdcall
VkKeyScanA(
     CHAR ch);
__declspec(dllimport)
SHORT
__stdcall
VkKeyScanW(
     WCHAR ch);




#line 6007 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"


__declspec(dllimport)
SHORT
__stdcall
VkKeyScanExA(
     CHAR ch,
     HKL dwhkl);
__declspec(dllimport)
SHORT
__stdcall
VkKeyScanExW(
     WCHAR ch,
     HKL dwhkl);




#line 6026 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"
#line 6027 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"





#line 6033 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"

__declspec(dllimport)
void
__stdcall
keybd_event(
     BYTE bVk,
     BYTE bScan,
     DWORD dwFlags,
     ULONG_PTR dwExtraInfo);

#line 6044 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"
#pragma endregion













#line 6059 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"


#line 6062 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"



#pragma region Desktop Family


__declspec(dllimport)
void
__stdcall
mouse_event(
     DWORD dwFlags,
     DWORD dx,
     DWORD dy,
     DWORD dwData,
     ULONG_PTR dwExtraInfo);

#line 6079 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"
#pragma endregion



typedef struct tagMOUSEINPUT {
    LONG    dx;
    LONG    dy;
    DWORD   mouseData;
    DWORD   dwFlags;
    DWORD   time;
    ULONG_PTR dwExtraInfo;
} MOUSEINPUT, *PMOUSEINPUT,  * LPMOUSEINPUT;

typedef struct tagKEYBDINPUT {
    WORD    wVk;
    WORD    wScan;
    DWORD   dwFlags;
    DWORD   time;
    ULONG_PTR dwExtraInfo;
} KEYBDINPUT, *PKEYBDINPUT,  * LPKEYBDINPUT;

#pragma region Desktop Family


typedef struct tagHARDWAREINPUT {
    DWORD   uMsg;
    WORD    wParamL;
    WORD    wParamH;
} HARDWAREINPUT, *PHARDWAREINPUT,  * LPHARDWAREINPUT;





typedef struct tagINPUT {
    DWORD   type;

    union
    {
        MOUSEINPUT      mi;
        KEYBDINPUT      ki;
        HARDWAREINPUT   hi;
    }  ;
} INPUT, *PINPUT,  * LPINPUT;

__declspec(dllimport)
UINT
__stdcall
SendInput(
     UINT cInputs,                     // number of input in the array
     LPINPUT pInputs,  // array of inputs
     int cbSize);                      // sizeof(INPUT)

#line 6133 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"
#pragma endregion

#line 6136 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"



#pragma region Desktop Family


/*
 * Touch Input defines and functions
 */

/*
 * Touch input handle
 */
struct HTOUCHINPUT__{int unused;}; typedef struct HTOUCHINPUT__ *HTOUCHINPUT ;

typedef struct tagTOUCHINPUT {
    LONG x;
    LONG y;
    HANDLE hSource;
    DWORD dwID;
    DWORD dwFlags;
    DWORD dwMask;
    DWORD dwTime;
    ULONG_PTR dwExtraInfo;
    DWORD cxContact;
    DWORD cyContact;
} TOUCHINPUT, *PTOUCHINPUT;
typedef TOUCHINPUT const * PCTOUCHINPUT;


#line 6167 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"
#pragma endregion

/*
 * Conversion of touch input coordinates to pixels
 */


/*
 * Touch input flag values (TOUCHINPUT.dwFlags)
 */









/*
 * Touch input mask values (TOUCHINPUT.dwMask)
 */




#pragma region Desktop Family


__declspec(dllimport)
BOOL
__stdcall
GetTouchInputInfo(
     HTOUCHINPUT hTouchInput,               // input event handle; from touch message lParam
     UINT cInputs,                          // number of elements in the array
     PTOUCHINPUT pInputs,  // array of touch inputs
     int cbSize);                           // sizeof(TOUCHINPUT)

__declspec(dllimport)
BOOL
__stdcall
CloseTouchInputHandle(
     HTOUCHINPUT hTouchInput);                   // input event handle; from touch message lParam


#line 6213 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"
#pragma endregion


/*
 * RegisterTouchWindow flag values
 */



#pragma region Desktop Family


__declspec(dllimport)
BOOL
__stdcall
RegisterTouchWindow(
     HWND hwnd,
     ULONG ulFlags);

__declspec(dllimport)
BOOL
__stdcall
UnregisterTouchWindow(
     HWND hwnd);

__declspec(dllimport)
BOOL
__stdcall
IsTouchWindow(
     HWND hwnd,
     PULONG pulFlags);

#line 6246 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"
#pragma endregion

#line 6249 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"












































































































































































































































































































































































































































































































































#line 6774 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"








































#line 6815 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"

#pragma region Desktop Family


#line 6820 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"
#pragma endregion

#pragma region Desktop Family



typedef struct tagLASTINPUTINFO {
    UINT cbSize;
    DWORD dwTime;
} LASTINPUTINFO, * PLASTINPUTINFO;

__declspec(dllimport)
BOOL
__stdcall
GetLastInputInfo(
     PLASTINPUTINFO plii);
#line 6837 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"

#line 6839 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"
#pragma endregion

#pragma region Desktop or PC Family


__declspec(dllimport)
UINT
__stdcall
MapVirtualKeyA(
     UINT uCode,
     UINT uMapType);
__declspec(dllimport)
UINT
__stdcall
MapVirtualKeyW(
     UINT uCode,
     UINT uMapType);




#line 6861 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"


__declspec(dllimport)
UINT
__stdcall
MapVirtualKeyExA(
     UINT uCode,
     UINT uMapType,
     HKL dwhkl);
__declspec(dllimport)
UINT
__stdcall
MapVirtualKeyExW(
     UINT uCode,
     UINT uMapType,
     HKL dwhkl);




#line 6882 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"

#line 6884 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"
#pragma endregion

#pragma region Desktop Family






#line 6894 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"


#line 6897 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"

__declspec(dllimport)
BOOL
__stdcall
GetInputState(
    void );

__declspec(dllimport)
DWORD
__stdcall
GetQueueStatus(
     UINT flags);


__declspec(dllimport)
HWND
__stdcall
GetCapture(
    void );

__declspec(dllimport)
HWND
__stdcall
SetCapture(
     HWND hWnd);

__declspec(dllimport)
BOOL
__stdcall
ReleaseCapture(
    void );

__declspec(dllimport)
DWORD
__stdcall
MsgWaitForMultipleObjects(
     DWORD nCount,
     const HANDLE *pHandles,
     BOOL fWaitAll,
     DWORD dwMilliseconds,
     DWORD dwWakeMask);

__declspec(dllimport)
DWORD
__stdcall
MsgWaitForMultipleObjectsEx(
     DWORD nCount,
     const HANDLE *pHandles,
     DWORD dwMilliseconds,
     DWORD dwWakeMask,
     DWORD dwFlags);


#line 6951 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"
#pragma endregion





/*
 * Queue status flags for GetQueueStatus() and MsgWaitForMultipleObjects()
 */












#line 6973 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"





#line 6979 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"












#line 6992 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"







#line 7000 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"
#line 7001 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"















#pragma region Desktop Family or Games Family





/*
 * Windows Functions
 */

__declspec(dllimport)
UINT_PTR
__stdcall
SetTimer(
     HWND hWnd,
     UINT_PTR nIDEvent,
     UINT uElapse,
     TIMERPROC lpTimerFunc);









#line 7044 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"

#line 7046 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"
#pragma endregion

#pragma region Desktop Family




__declspec(dllimport)
UINT_PTR
__stdcall
SetCoalescableTimer(
     HWND hWnd,
     UINT_PTR nIDEvent,
     UINT uElapse,
     TIMERPROC lpTimerFunc,
     ULONG uToleranceDelay);

#line 7064 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"

#line 7066 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"
#pragma endregion

#pragma region Desktop Family or Games Family


__declspec(dllimport)
BOOL
__stdcall
KillTimer(
     HWND hWnd,
     UINT_PTR uIDEvent);

#line 7079 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"
#pragma endregion

#pragma region Desktop Family


__declspec(dllimport)
BOOL
__stdcall
IsWindowUnicode(
     HWND hWnd);

__declspec(dllimport)
BOOL
__stdcall
EnableWindow(
     HWND hWnd,
     BOOL bEnable);

__declspec(dllimport)
BOOL
__stdcall
IsWindowEnabled(
     HWND hWnd);

__declspec(dllimport)
HACCEL
__stdcall
LoadAcceleratorsA(
     HINSTANCE hInstance,
     LPCSTR lpTableName);
__declspec(dllimport)
HACCEL
__stdcall
LoadAcceleratorsW(
     HINSTANCE hInstance,
     LPCWSTR lpTableName);




#line 7120 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"

__declspec(dllimport)
HACCEL
__stdcall
CreateAcceleratorTableA(
     LPACCEL paccel,
     int cAccel);
__declspec(dllimport)
HACCEL
__stdcall
CreateAcceleratorTableW(
     LPACCEL paccel,
     int cAccel);




#line 7138 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"

__declspec(dllimport)
BOOL
__stdcall
DestroyAcceleratorTable(
     HACCEL hAccel);

__declspec(dllimport)
int
__stdcall
CopyAcceleratorTableA(
     HACCEL hAccelSrc,
     LPACCEL lpAccelDst,
     int cAccelEntries);
__declspec(dllimport)
int
__stdcall
CopyAcceleratorTableW(
     HACCEL hAccelSrc,
     LPACCEL lpAccelDst,
     int cAccelEntries);




#line 7164 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"



__declspec(dllimport)
int
__stdcall
TranslateAcceleratorA(
     HWND hWnd,
     HACCEL hAccTable,
     LPMSG lpMsg);
__declspec(dllimport)
int
__stdcall
TranslateAcceleratorW(
     HWND hWnd,
     HACCEL hAccTable,
     LPMSG lpMsg);




#line 7186 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"

#line 7188 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"

#line 7190 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"
#pragma endregion



/*
 * GetSystemMetrics() codes
 */











































































#line 7273 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"






#line 7280 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"



#line 7284 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"







#line 7292 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"


#line 7295 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"



#line 7299 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"






#line 7306 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"




#line 7311 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"





#line 7317 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"



#line 7321 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"

#line 7323 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"

#line 7325 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"

#line 7327 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"

#line 7329 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"







#line 7337 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"



#line 7341 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"



#line 7345 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"




#line 7350 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"

#line 7352 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"


#pragma region Desktop Family


__declspec(dllimport)
int
__stdcall
GetSystemMetrics(
     int nIndex);










#line 7373 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"

#line 7375 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"
#pragma endregion

#line 7378 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"

#pragma region Desktop Family




__declspec(dllimport)
HMENU
__stdcall
LoadMenuA(
     HINSTANCE hInstance,
     LPCSTR lpMenuName);
__declspec(dllimport)
HMENU
__stdcall
LoadMenuW(
     HINSTANCE hInstance,
     LPCWSTR lpMenuName);




#line 7401 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"

__declspec(dllimport)
HMENU
__stdcall
LoadMenuIndirectA(
     const MENUTEMPLATEA *lpMenuTemplate);
__declspec(dllimport)
HMENU
__stdcall
LoadMenuIndirectW(
     const MENUTEMPLATEW *lpMenuTemplate);




#line 7417 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"

__declspec(dllimport)
HMENU
__stdcall
GetMenu(
     HWND hWnd);

__declspec(dllimport)
BOOL
__stdcall
SetMenu(
     HWND hWnd,
     HMENU hMenu);

__declspec(dllimport)
BOOL
__stdcall
ChangeMenuA(
     HMENU hMenu,
     UINT cmd,
     LPCSTR lpszNewItem,
     UINT cmdInsert,
     UINT flags);
__declspec(dllimport)
BOOL
__stdcall
ChangeMenuW(
     HMENU hMenu,
     UINT cmd,
     LPCWSTR lpszNewItem,
     UINT cmdInsert,
     UINT flags);




#line 7454 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"

__declspec(dllimport)
BOOL
__stdcall
HiliteMenuItem(
     HWND hWnd,
     HMENU hMenu,
     UINT uIDHiliteItem,
     UINT uHilite);

__declspec(dllimport)
int
__stdcall
GetMenuStringA(
     HMENU hMenu,
     UINT uIDItem,
     LPSTR lpString,
     int cchMax,
     UINT flags);
__declspec(dllimport)
int
__stdcall
GetMenuStringW(
     HMENU hMenu,
     UINT uIDItem,
     LPWSTR lpString,
     int cchMax,
     UINT flags);




#line 7487 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"

__declspec(dllimport)
UINT
__stdcall
GetMenuState(
     HMENU hMenu,
     UINT uId,
     UINT uFlags);

__declspec(dllimport)
BOOL
__stdcall
DrawMenuBar(
     HWND hWnd);




#line 7506 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"


__declspec(dllimport)
HMENU
__stdcall
GetSystemMenu(
     HWND hWnd,
     BOOL bRevert);


__declspec(dllimport)
HMENU
__stdcall
CreateMenu(
    void );

__declspec(dllimport)
HMENU
__stdcall
CreatePopupMenu(
    void );

__declspec(dllimport)
BOOL
__stdcall
DestroyMenu(
     HMENU hMenu);

__declspec(dllimport)
DWORD
__stdcall
CheckMenuItem(
     HMENU hMenu,
     UINT uIDCheckItem,
     UINT uCheck);

__declspec(dllimport)
BOOL
__stdcall
EnableMenuItem(
     HMENU hMenu,
     UINT uIDEnableItem,
     UINT uEnable);

__declspec(dllimport)
HMENU
__stdcall
GetSubMenu(
     HMENU hMenu,
     int nPos);

__declspec(dllimport)
UINT
__stdcall
GetMenuItemID(
     HMENU hMenu,
     int nPos);

__declspec(dllimport)
int
__stdcall
GetMenuItemCount(
     HMENU hMenu);

__declspec(dllimport)
BOOL
__stdcall
InsertMenuA(
     HMENU hMenu,
     UINT uPosition,
     UINT uFlags,
     UINT_PTR uIDNewItem,
     LPCSTR lpNewItem);
__declspec(dllimport)
BOOL
__stdcall
InsertMenuW(
     HMENU hMenu,
     UINT uPosition,
     UINT uFlags,
     UINT_PTR uIDNewItem,
     LPCWSTR lpNewItem);




#line 7593 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"

__declspec(dllimport)
BOOL
__stdcall
AppendMenuA(
     HMENU hMenu,
     UINT uFlags,
     UINT_PTR uIDNewItem,
     LPCSTR lpNewItem);
__declspec(dllimport)
BOOL
__stdcall
AppendMenuW(
     HMENU hMenu,
     UINT uFlags,
     UINT_PTR uIDNewItem,
     LPCWSTR lpNewItem);




#line 7615 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"

__declspec(dllimport)
BOOL
__stdcall
ModifyMenuA(
     HMENU hMnu,
     UINT uPosition,
     UINT uFlags,
     UINT_PTR uIDNewItem,
     LPCSTR lpNewItem);
__declspec(dllimport)
BOOL
__stdcall
ModifyMenuW(
     HMENU hMnu,
     UINT uPosition,
     UINT uFlags,
     UINT_PTR uIDNewItem,
     LPCWSTR lpNewItem);




#line 7639 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"

__declspec(dllimport)
BOOL
__stdcall RemoveMenu(
     HMENU hMenu,
     UINT uPosition,
     UINT uFlags);

__declspec(dllimport)
BOOL
__stdcall
DeleteMenu(
     HMENU hMenu,
     UINT uPosition,
     UINT uFlags);

__declspec(dllimport)
BOOL
__stdcall
SetMenuItemBitmaps(
     HMENU hMenu,
     UINT uPosition,
     UINT uFlags,
     HBITMAP hBitmapUnchecked,
     HBITMAP hBitmapChecked);

__declspec(dllimport)
LONG
__stdcall
GetMenuCheckMarkDimensions(
    void );

__declspec(dllimport)
BOOL
__stdcall
TrackPopupMenu(
     HMENU hMenu,
     UINT uFlags,
     int x,
     int y,
     int nReserved,
     HWND hWnd,
     const RECT *prcRect);


/* return codes for WM_MENUCHAR */





typedef struct tagTPMPARAMS
{
    UINT    cbSize;     /* Size of structure */
    RECT    rcExclude;  /* Screen coordinates of rectangle to exclude when positioning */
}   TPMPARAMS;
typedef TPMPARAMS  *LPTPMPARAMS;

__declspec(dllimport)
BOOL
__stdcall
TrackPopupMenuEx(
     HMENU hMenu,
     UINT uFlags,
     int x,
     int y,
     HWND hwnd,
     LPTPMPARAMS lptpm);
#line 7708 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"


__declspec(dllimport)
BOOL
__stdcall
CalculatePopupWindowPosition(
     const POINT *anchorPoint,
     const SIZE *windowSize,
     UINT /* TPM_XXX values */ flags,
     RECT *excludeRect,
     RECT *popupWindowPosition);

#line 7721 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"

















typedef struct tagMENUINFO
{
    DWORD   cbSize;
    DWORD   fMask;
    DWORD   dwStyle;
    UINT    cyMax;
    HBRUSH  hbrBack;
    DWORD   dwContextHelpID;
    ULONG_PTR dwMenuData;
}   MENUINFO,  *LPMENUINFO;
typedef MENUINFO const  *LPCMENUINFO;

__declspec(dllimport)
BOOL
__stdcall
GetMenuInfo(
     HMENU,
     LPMENUINFO);

__declspec(dllimport)
BOOL
__stdcall
SetMenuInfo(
     HMENU,
     LPCMENUINFO);

__declspec(dllimport)
BOOL
__stdcall
EndMenu(
        void );

/*
 * WM_MENUDRAG return values.
 */



typedef struct tagMENUGETOBJECTINFO
{
    DWORD dwFlags;
    UINT uPos;
    HMENU hmenu;
    PVOID riid;
    PVOID pvObj;
} MENUGETOBJECTINFO, * PMENUGETOBJECTINFO;

/*
 * MENUGETOBJECTINFO dwFlags values
 */



/*
 * WM_MENUGETOBJECT return values
 */


#line 7797 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"








#line 7806 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"

















#line 7824 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"


typedef struct tagMENUITEMINFOA
{
    UINT     cbSize;
    UINT     fMask;
    UINT     fType;         // used if MIIM_TYPE (4.0) or MIIM_FTYPE (>4.0)
    UINT     fState;        // used if MIIM_STATE
    UINT     wID;           // used if MIIM_ID
    HMENU    hSubMenu;      // used if MIIM_SUBMENU
    HBITMAP  hbmpChecked;   // used if MIIM_CHECKMARKS
    HBITMAP  hbmpUnchecked; // used if MIIM_CHECKMARKS
    ULONG_PTR dwItemData;   // used if MIIM_DATA
    LPSTR    dwTypeData;    // used if MIIM_TYPE (4.0) or MIIM_STRING (>4.0)
    UINT     cch;           // used if MIIM_TYPE (4.0) or MIIM_STRING (>4.0)

    HBITMAP  hbmpItem;      // used if MIIM_BITMAP
#line 7842 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"
}   MENUITEMINFOA,  *LPMENUITEMINFOA;
typedef struct tagMENUITEMINFOW
{
    UINT     cbSize;
    UINT     fMask;
    UINT     fType;         // used if MIIM_TYPE (4.0) or MIIM_FTYPE (>4.0)
    UINT     fState;        // used if MIIM_STATE
    UINT     wID;           // used if MIIM_ID
    HMENU    hSubMenu;      // used if MIIM_SUBMENU
    HBITMAP  hbmpChecked;   // used if MIIM_CHECKMARKS
    HBITMAP  hbmpUnchecked; // used if MIIM_CHECKMARKS
    ULONG_PTR dwItemData;   // used if MIIM_DATA
    LPWSTR   dwTypeData;    // used if MIIM_TYPE (4.0) or MIIM_STRING (>4.0)
    UINT     cch;           // used if MIIM_TYPE (4.0) or MIIM_STRING (>4.0)

    HBITMAP  hbmpItem;      // used if MIIM_BITMAP
#line 7859 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"
}   MENUITEMINFOW,  *LPMENUITEMINFOW;




typedef MENUITEMINFOA MENUITEMINFO;
typedef LPMENUITEMINFOA LPMENUITEMINFO;
#line 7867 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"
typedef MENUITEMINFOA const  *LPCMENUITEMINFOA;
typedef MENUITEMINFOW const  *LPCMENUITEMINFOW;



typedef LPCMENUITEMINFOA LPCMENUITEMINFO;
#line 7874 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"


__declspec(dllimport)
BOOL
__stdcall
InsertMenuItemA(
     HMENU hmenu,
     UINT item,
     BOOL fByPosition,
     LPCMENUITEMINFOA lpmi);
__declspec(dllimport)
BOOL
__stdcall
InsertMenuItemW(
     HMENU hmenu,
     UINT item,
     BOOL fByPosition,
     LPCMENUITEMINFOW lpmi);




#line 7897 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"

__declspec(dllimport)
BOOL
__stdcall
GetMenuItemInfoA(
     HMENU hmenu,
     UINT item,
     BOOL fByPosition,
     LPMENUITEMINFOA lpmii);
__declspec(dllimport)
BOOL
__stdcall
GetMenuItemInfoW(
     HMENU hmenu,
     UINT item,
     BOOL fByPosition,
     LPMENUITEMINFOW lpmii);




#line 7919 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"

__declspec(dllimport)
BOOL
__stdcall
SetMenuItemInfoA(
     HMENU hmenu,
     UINT item,
     BOOL fByPositon,
     LPCMENUITEMINFOA lpmii);
__declspec(dllimport)
BOOL
__stdcall
SetMenuItemInfoW(
     HMENU hmenu,
     UINT item,
     BOOL fByPositon,
     LPCMENUITEMINFOW lpmii);




#line 7941 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"





__declspec(dllimport)
UINT
__stdcall
GetMenuDefaultItem(
     HMENU hMenu,
     UINT fByPos,
     UINT gmdiFlags);

__declspec(dllimport)
BOOL
__stdcall
SetMenuDefaultItem(
     HMENU hMenu,
     UINT uItem,
     UINT fByPos);

__declspec(dllimport)
BOOL
__stdcall
GetMenuItemRect(
     HWND hWnd,
     HMENU hMenu,
     UINT uItem,
     LPRECT lprcItem);

__declspec(dllimport)
int
__stdcall
MenuItemFromPoint(
     HWND hWnd,
     HMENU hMenu,
     POINT ptScreen);
#line 7979 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"

/*
 * Flags for TrackPopupMenu
 */














#line 7998 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"








#line 8007 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"


#line 8010 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"
#line 8011 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"


#line 8014 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"


#line 8017 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"

#line 8019 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"
#pragma endregion




#pragma region Desktop Family


//
// Drag-and-drop support
// Obsolete - use OLE instead
//
typedef struct tagDROPSTRUCT
{
    HWND    hwndSource;
    HWND    hwndSink;
    DWORD   wFmt;
    ULONG_PTR dwData;
    POINT   ptDrop;
    DWORD   dwControlData;
} DROPSTRUCT, *PDROPSTRUCT, *LPDROPSTRUCT;

#line 8042 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"
#pragma endregion











#pragma region Desktop Family


__declspec(dllimport)
DWORD
__stdcall
DragObject(
     HWND hwndParent,
     HWND hwndFrom,
     UINT fmt,
     ULONG_PTR data,
     HCURSOR hcur);

__declspec(dllimport)
BOOL
__stdcall
DragDetect(
     HWND hwnd,
     POINT pt);

#line 8075 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"
#pragma endregion

#line 8078 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"

#pragma region Desktop Family


__declspec(dllimport)
BOOL
__stdcall
DrawIcon(
     HDC hDC,
     int X,
     int Y,
     HICON hIcon);

#line 8092 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"
#pragma endregion



/*
 * DrawText() Format Flags
 */




























#line 8128 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"
#line 8129 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"

#pragma region Desktop Family


typedef struct tagDRAWTEXTPARAMS
{
    UINT    cbSize;
    int     iTabLength;
    int     iLeftMargin;
    int     iRightMargin;
    UINT    uiLengthDrawn;
} DRAWTEXTPARAMS,  *LPDRAWTEXTPARAMS;

#line 8143 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"
#pragma endregion

#line 8146 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"


#pragma region Desktop Family










__declspec(dllimport)

int
__stdcall
DrawTextA(
     HDC hdc,
    
    
    LPCSTR lpchText,
     int cchText,
     LPRECT lprc,
     UINT format);
__declspec(dllimport)

int
__stdcall
DrawTextW(
     HDC hdc,
    
    
    LPCWSTR lpchText,
     int cchText,
     LPRECT lprc,
     UINT format);




#line 8188 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"

























#line 8214 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"



__declspec(dllimport)

int
__stdcall
DrawTextExA(
     HDC hdc,
    
    
    
    LPSTR lpchText,
     int cchText,
     LPRECT lprc,
     UINT format,
     LPDRAWTEXTPARAMS lpdtp);
__declspec(dllimport)

int
__stdcall
DrawTextExW(
     HDC hdc,
    
    
    
    LPWSTR lpchText,
     int cchText,
     LPRECT lprc,
     UINT format,
     LPDRAWTEXTPARAMS lpdtp);




#line 8250 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"
#line 8251 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"

#line 8253 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"
#pragma endregion

#line 8256 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"

#pragma region Desktop Family


__declspec(dllimport)
BOOL
__stdcall
GrayStringA(
     HDC hDC,
     HBRUSH hBrush,
     GRAYSTRINGPROC lpOutputFunc,
     LPARAM lpData,
     int nCount,
     int X,
     int Y,
     int nWidth,
     int nHeight);
__declspec(dllimport)
BOOL
__stdcall
GrayStringW(
     HDC hDC,
     HBRUSH hBrush,
     GRAYSTRINGPROC lpOutputFunc,
     LPARAM lpData,
     int nCount,
     int X,
     int Y,
     int nWidth,
     int nHeight);




#line 8291 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"

#line 8293 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"
#pragma endregion


/* Monolithic state-drawing routine */
/* Image type */






/* State type */







#line 8313 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"


#pragma region Desktop Family


__declspec(dllimport)
BOOL
__stdcall
DrawStateA(
     HDC hdc,
     HBRUSH hbrFore,
     DRAWSTATEPROC qfnCallBack,
     LPARAM lData,
     WPARAM wData,
     int x,
     int y,
     int cx,
     int cy,
     UINT uFlags);
__declspec(dllimport)
BOOL
__stdcall
DrawStateW(
     HDC hdc,
     HBRUSH hbrFore,
     DRAWSTATEPROC qfnCallBack,
     LPARAM lData,
     WPARAM wData,
     int x,
     int y,
     int cx,
     int cy,
     UINT uFlags);




#line 8351 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"

#line 8353 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"
#pragma endregion

#line 8356 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"

#pragma region Desktop Family


__declspec(dllimport)
LONG
__stdcall
TabbedTextOutA(
     HDC hdc,
     int x,
     int y,
     LPCSTR lpString,
     int chCount,
     int nTabPositions,
     const INT *lpnTabStopPositions,
     int nTabOrigin);
__declspec(dllimport)
LONG
__stdcall
TabbedTextOutW(
     HDC hdc,
     int x,
     int y,
     LPCWSTR lpString,
     int chCount,
     int nTabPositions,
     const INT *lpnTabStopPositions,
     int nTabOrigin);




#line 8389 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"

__declspec(dllimport)
DWORD
__stdcall
GetTabbedTextExtentA(
     HDC hdc,
     LPCSTR lpString,
     int chCount,
     int nTabPositions,
     const INT *lpnTabStopPositions);
__declspec(dllimport)
DWORD
__stdcall
GetTabbedTextExtentW(
     HDC hdc,
     LPCWSTR lpString,
     int chCount,
     int nTabPositions,
     const INT *lpnTabStopPositions);




#line 8413 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"

__declspec(dllimport)
BOOL
__stdcall
UpdateWindow(
     HWND hWnd);

__declspec(dllimport)
HWND
__stdcall
SetActiveWindow(
     HWND hWnd);


__declspec(dllimport)
HWND
__stdcall
GetForegroundWindow(
    void );


__declspec(dllimport)
BOOL
__stdcall
PaintDesktop(
     HDC hdc);

__declspec(dllimport)
void
__stdcall
SwitchToThisWindow(
     HWND hwnd,
     BOOL fUnknown);
#line 8447 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"


__declspec(dllimport)
BOOL
__stdcall
SetForegroundWindow(
     HWND hWnd);


__declspec(dllimport)
BOOL
__stdcall
AllowSetForegroundWindow(
     DWORD dwProcessId);



__declspec(dllimport)
BOOL
__stdcall
LockSetForegroundWindow(
     UINT uLockCode);




#line 8474 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"

__declspec(dllimport)
HWND
__stdcall
WindowFromDC(
     HDC hDC);

__declspec(dllimport)
HDC
__stdcall
GetDC(
     HWND hWnd);

__declspec(dllimport)
HDC
__stdcall
GetDCEx(
     HWND hWnd,
     HRGN hrgnClip,
     DWORD flags);

#line 8496 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"
#pragma endregion

/*
 * GetDCEx() flags
 */














#pragma region Desktop Family


__declspec(dllimport)
HDC
__stdcall
GetWindowDC(
     HWND hWnd);

__declspec(dllimport)
int
__stdcall
ReleaseDC(
     HWND hWnd,
     HDC hDC);

__declspec(dllimport)
HDC
__stdcall
BeginPaint(
     HWND hWnd,
     LPPAINTSTRUCT lpPaint);

__declspec(dllimport)
BOOL
__stdcall
EndPaint(
     HWND hWnd,
     const PAINTSTRUCT *lpPaint);

__declspec(dllimport)
BOOL
__stdcall
GetUpdateRect(
     HWND hWnd,
     LPRECT lpRect,
     BOOL bErase);

__declspec(dllimport)
int
__stdcall
GetUpdateRgn(
     HWND hWnd,
     HRGN hRgn,
     BOOL bErase);

__declspec(dllimport)
int
__stdcall
SetWindowRgn(
     HWND hWnd,
     HRGN hRgn,
     BOOL bRedraw);

#line 8570 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"
#pragma endregion


#pragma region Desktop Family


__declspec(dllimport)
int
__stdcall
GetWindowRgn(
     HWND hWnd,
     HRGN hRgn);



__declspec(dllimport)
int
__stdcall
GetWindowRgnBox(
     HWND hWnd,
     LPRECT lprc);

#line 8593 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"

__declspec(dllimport)
int
__stdcall
ExcludeUpdateRgn(
     HDC hDC,
     HWND hWnd);

__declspec(dllimport)
BOOL
__stdcall
InvalidateRect(
     HWND hWnd,
     const RECT *lpRect,
     BOOL bErase);

__declspec(dllimport)
BOOL
__stdcall
ValidateRect(
     HWND hWnd,
     const RECT *lpRect);

__declspec(dllimport)
BOOL
__stdcall
InvalidateRgn(
     HWND hWnd,
     HRGN hRgn,
     BOOL bErase);

__declspec(dllimport)
BOOL
__stdcall
ValidateRgn(
     HWND hWnd,
     HRGN hRgn);


__declspec(dllimport)
BOOL
__stdcall
RedrawWindow(
     HWND hWnd,
     const RECT *lprcUpdate,
     HRGN hrgnUpdate,
     UINT flags);

#line 8642 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"
#pragma endregion

/*
 * RedrawWindow() flags
 */


















#pragma region Desktop Family


/*
 * LockWindowUpdate API
 */

__declspec(dllimport)
BOOL
__stdcall
LockWindowUpdate(
     HWND hWndLock);

__declspec(dllimport)
BOOL
__stdcall
ScrollWindow(
     HWND hWnd,
     int XAmount,
     int YAmount,
     const RECT *lpRect,
     const RECT *lpClipRect);

__declspec(dllimport)
BOOL
__stdcall
ScrollDC(
     HDC hDC,
     int dx,
     int dy,
     const RECT *lprcScroll,
     const RECT *lprcClip,
     HRGN hrgnUpdate,
     LPRECT lprcUpdate);

__declspec(dllimport)
int
__stdcall
ScrollWindowEx(
     HWND hWnd,
     int dx,
     int dy,
     const RECT *prcScroll,
     const RECT *prcClip,
     HRGN hrgnUpdate,
     LPRECT prcUpdate,
     UINT flags);

#line 8714 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"
#pragma endregion






#line 8722 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"

#pragma region Desktop Family




__declspec(dllimport)
int
__stdcall
SetScrollPos(
     HWND hWnd,
     int nBar,
     int nPos,
     BOOL bRedraw);

__declspec(dllimport)
int
__stdcall
GetScrollPos(
     HWND hWnd,
     int nBar);

__declspec(dllimport)
BOOL
__stdcall
SetScrollRange(
     HWND hWnd,
     int nBar,
     int nMinPos,
     int nMaxPos,
     BOOL bRedraw);

__declspec(dllimport)
BOOL
__stdcall
GetScrollRange(
     HWND hWnd,
     int nBar,
     LPINT lpMinPos,
     LPINT lpMaxPos);

__declspec(dllimport)
BOOL
__stdcall
ShowScrollBar(
     HWND hWnd,
     int wBar,
     BOOL bShow);

__declspec(dllimport)
BOOL
__stdcall
EnableScrollBar(
     HWND hWnd,
     UINT wSBflags,
     UINT wArrows);


/*
 * EnableScrollBar() flags
 */













#line 8797 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"


__declspec(dllimport)
BOOL
__stdcall
SetPropA(
     HWND hWnd,
     LPCSTR lpString,
     HANDLE hData);
__declspec(dllimport)
BOOL
__stdcall
SetPropW(
     HWND hWnd,
     LPCWSTR lpString,
     HANDLE hData);




#line 8818 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"

__declspec(dllimport)
HANDLE
__stdcall
GetPropA(
     HWND hWnd,
     LPCSTR lpString);
__declspec(dllimport)
HANDLE
__stdcall
GetPropW(
     HWND hWnd,
     LPCWSTR lpString);




#line 8836 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"

__declspec(dllimport)
HANDLE
__stdcall
RemovePropA(
     HWND hWnd,
     LPCSTR lpString);
__declspec(dllimport)
HANDLE
__stdcall
RemovePropW(
     HWND hWnd,
     LPCWSTR lpString);




#line 8854 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"

__declspec(dllimport)
int
__stdcall
EnumPropsExA(
     HWND hWnd,
     PROPENUMPROCEXA lpEnumFunc,
     LPARAM lParam);
__declspec(dllimport)
int
__stdcall
EnumPropsExW(
     HWND hWnd,
     PROPENUMPROCEXW lpEnumFunc,
     LPARAM lParam);




#line 8874 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"

__declspec(dllimport)
int
__stdcall
EnumPropsA(
     HWND hWnd,
     PROPENUMPROCA lpEnumFunc);
__declspec(dllimport)
int
__stdcall
EnumPropsW(
     HWND hWnd,
     PROPENUMPROCW lpEnumFunc);




#line 8892 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"

__declspec(dllimport)
BOOL
__stdcall
SetWindowTextA(
     HWND hWnd,
     LPCSTR lpString);
__declspec(dllimport)
BOOL
__stdcall
SetWindowTextW(
     HWND hWnd,
     LPCWSTR lpString);




#line 8910 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"


__declspec(dllimport)
int
__stdcall
GetWindowTextA(
     HWND hWnd,
     LPSTR lpString,
     int nMaxCount);

__declspec(dllimport)
int
__stdcall
GetWindowTextW(
     HWND hWnd,
     LPWSTR lpString,
     int nMaxCount);




#line 8932 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"

__declspec(dllimport)
int
__stdcall
GetWindowTextLengthA(
     HWND hWnd);
__declspec(dllimport)
int
__stdcall
GetWindowTextLengthW(
     HWND hWnd);




#line 8948 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"

#line 8950 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"
#pragma endregion

#pragma region Desktop Family or Games Family


__declspec(dllimport)
BOOL
__stdcall
GetClientRect(
     HWND hWnd,
     LPRECT lpRect);

#line 8963 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"
#pragma endregion

#pragma region Desktop Family


__declspec(dllimport)
BOOL
__stdcall
GetWindowRect(
     HWND hWnd,
     LPRECT lpRect);

#line 8976 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"
#pragma endregion

#pragma region Desktop Family or Games Family


__declspec(dllimport)
BOOL
__stdcall
AdjustWindowRect(
     LPRECT lpRect,
     DWORD dwStyle,
     BOOL bMenu);

__declspec(dllimport)
BOOL
__stdcall
AdjustWindowRectEx(
     LPRECT lpRect,
     DWORD dwStyle,
     BOOL bMenu,
     DWORD dwExStyle);

#line 8999 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"
#pragma endregion

#pragma region Desktop Family












#line 9015 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"


#line 9018 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"
#pragma endregion





#pragma region Desktop Family


typedef struct tagHELPINFO      /* Structure pointed to by lParam of WM_HELP */
{
    UINT    cbSize;             /* Size in bytes of this struct  */
    int     iContextType;       /* Either HELPINFO_WINDOW or HELPINFO_MENUITEM */
    int     iCtrlId;            /* Control Id or a Menu item Id. */
    HANDLE  hItemHandle;        /* hWnd of control or hMenu.     */
    DWORD_PTR dwContextId;      /* Context Id associated with this item */
    POINT   MousePos;           /* Mouse Position in screen co-ordinates */
}  HELPINFO,  *LPHELPINFO;

__declspec(dllimport)
BOOL
__stdcall
SetWindowContextHelpId(
     HWND,
     DWORD);

__declspec(dllimport)
DWORD
__stdcall
GetWindowContextHelpId(
     HWND);

__declspec(dllimport)
BOOL
__stdcall
SetMenuContextHelpId(
     HMENU,
     DWORD);

__declspec(dllimport)
DWORD
__stdcall
GetMenuContextHelpId(
     HMENU);

#line 9064 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"
#pragma endregion

#line 9067 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"




/*
 * MessageBox() Flags
 */








#line 9083 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"











#line 9095 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"









#line 9105 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"






#line 9112 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"










#line 9123 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"






#line 9130 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"

#line 9132 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"







#pragma region Desktop Family


__declspec(dllimport)
int
__stdcall
MessageBoxA(
     HWND hWnd,
     LPCSTR lpText,
     LPCSTR lpCaption,
     UINT uType);
__declspec(dllimport)
int
__stdcall
MessageBoxW(
     HWND hWnd,
     LPCWSTR lpText,
     LPCWSTR lpCaption,
     UINT uType);




#line 9163 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"























#line 9187 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"

__declspec(dllimport)
int
__stdcall
MessageBoxExA(
     HWND hWnd,
     LPCSTR lpText,
     LPCSTR lpCaption,
     UINT uType,
     WORD wLanguageId);
__declspec(dllimport)
int
__stdcall
MessageBoxExW(
     HWND hWnd,
     LPCWSTR lpText,
     LPCWSTR lpCaption,
     UINT uType,
     WORD wLanguageId);




#line 9211 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"



typedef void (__stdcall *MSGBOXCALLBACK)(LPHELPINFO lpHelpInfo);

typedef struct tagMSGBOXPARAMSA
{
    UINT        cbSize;
    HWND        hwndOwner;
    HINSTANCE   hInstance;
    LPCSTR      lpszText;
    LPCSTR      lpszCaption;
    DWORD       dwStyle;
    LPCSTR      lpszIcon;
    DWORD_PTR   dwContextHelpId;
    MSGBOXCALLBACK      lpfnMsgBoxCallback;
    DWORD       dwLanguageId;
} MSGBOXPARAMSA, *PMSGBOXPARAMSA, *LPMSGBOXPARAMSA;
typedef struct tagMSGBOXPARAMSW
{
    UINT        cbSize;
    HWND        hwndOwner;
    HINSTANCE   hInstance;
    LPCWSTR     lpszText;
    LPCWSTR     lpszCaption;
    DWORD       dwStyle;
    LPCWSTR     lpszIcon;
    DWORD_PTR   dwContextHelpId;
    MSGBOXCALLBACK      lpfnMsgBoxCallback;
    DWORD       dwLanguageId;
} MSGBOXPARAMSW, *PMSGBOXPARAMSW, *LPMSGBOXPARAMSW;





typedef MSGBOXPARAMSA MSGBOXPARAMS;
typedef PMSGBOXPARAMSA PMSGBOXPARAMS;
typedef LPMSGBOXPARAMSA LPMSGBOXPARAMS;
#line 9251 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"

__declspec(dllimport)
int
__stdcall
MessageBoxIndirectA(
     const MSGBOXPARAMSA * lpmbp);
__declspec(dllimport)
int
__stdcall
MessageBoxIndirectW(
     const MSGBOXPARAMSW * lpmbp);




#line 9267 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"
#line 9268 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"


#line 9271 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"
#pragma endregion


#pragma region Desktop Family


__declspec(dllimport)
BOOL
__stdcall
MessageBeep(
     UINT uType);

#line 9284 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"
#pragma endregion

#line 9287 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"

#pragma region Desktop Family



#line 9293 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"
#pragma endregion

#pragma region Desktop Family or Games Family


__declspec(dllimport)
int
__stdcall
ShowCursor(
     BOOL bShow);

#line 9305 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"
#pragma endregion

#pragma region Desktop Family


__declspec(dllimport)
BOOL
__stdcall
SetCursorPos(
     int X,
     int Y);


__declspec(dllimport)
BOOL
__stdcall
SetPhysicalCursorPos(
     int X,
     int Y);
#line 9325 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"

#line 9327 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"
#pragma endregion

#pragma region Desktop Family or Games Family


__declspec(dllimport)
HCURSOR
__stdcall
SetCursor(
     HCURSOR hCursor);

__declspec(dllimport)
BOOL
__stdcall
GetCursorPos(
     LPPOINT lpPoint);

#line 9345 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"
#pragma endregion

#pragma region Desktop Family



__declspec(dllimport)
BOOL
__stdcall
GetPhysicalCursorPos(
     LPPOINT lpPoint);
#line 9357 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"


__declspec(dllimport)
BOOL
__stdcall
GetClipCursor(
     LPRECT lpRect);

__declspec(dllimport)
HCURSOR
__stdcall
GetCursor(
    void );

__declspec(dllimport)
BOOL
__stdcall
CreateCaret(
     HWND hWnd,
     HBITMAP hBitmap,
     int nWidth,
     int nHeight);

__declspec(dllimport)
UINT
__stdcall
GetCaretBlinkTime(
    void );

__declspec(dllimport)
BOOL
__stdcall
SetCaretBlinkTime(
     UINT uMSeconds);

__declspec(dllimport)
BOOL
__stdcall
DestroyCaret(
    void );

__declspec(dllimport)
BOOL
__stdcall
HideCaret(
     HWND hWnd);

__declspec(dllimport)
BOOL
__stdcall
ShowCaret(
     HWND hWnd);

__declspec(dllimport)
BOOL
__stdcall
SetCaretPos(
     int X,
     int Y);

__declspec(dllimport)
BOOL
__stdcall
GetCaretPos(
     LPPOINT lpPoint);

__declspec(dllimport)
BOOL
__stdcall
ClientToScreen(
     HWND hWnd,
     LPPOINT lpPoint);

__declspec(dllimport)
BOOL
__stdcall
ScreenToClient(
     HWND hWnd,
     LPPOINT lpPoint);


__declspec(dllimport)
BOOL
__stdcall
LogicalToPhysicalPoint(
     HWND hWnd,
     LPPOINT lpPoint);

__declspec(dllimport)
BOOL
__stdcall
PhysicalToLogicalPoint(
     HWND hWnd,
     LPPOINT lpPoint);

#line 9453 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"
















#line 9470 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"

__declspec(dllimport)
int
__stdcall
MapWindowPoints(
     HWND hWndFrom,
     HWND hWndTo,
     LPPOINT lpPoints,
     UINT cPoints);

__declspec(dllimport)
HWND
__stdcall
WindowFromPoint(
     POINT Point);


__declspec(dllimport)
HWND
__stdcall
WindowFromPhysicalPoint(
     POINT Point);
#line 9493 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"

__declspec(dllimport)
HWND
__stdcall
ChildWindowFromPoint(
     HWND hWndParent,
     POINT Point);

#line 9502 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"
#pragma endregion

#pragma region Desktop or PC Family

__declspec(dllimport)
BOOL
__stdcall
ClipCursor(
     const RECT *lpRect);
#line 9512 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"
#pragma endregion







#pragma region Desktop Family


__declspec(dllimport)
HWND
__stdcall
ChildWindowFromPointEx(
     HWND hwnd,
     POINT pt,
     UINT flags);

#line 9532 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"
#pragma endregion

#line 9535 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"



/*
 * Color Types
 */




































#line 9578 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"








#line 9587 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"
#line 9588 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"








#line 9597 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"


#pragma region Desktop Family


__declspec(dllimport)
DWORD
__stdcall
GetSysColor(
     int nIndex);


__declspec(dllimport)
HBRUSH
__stdcall
GetSysColorBrush(
     int nIndex);


#line 9617 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"

__declspec(dllimport)
BOOL
__stdcall
SetSysColors(
     int cElements,
     const INT * lpaElements,
     const COLORREF * lpaRgbValues);

#line 9627 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"
#pragma endregion

#line 9630 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"

#pragma region Desktop Family


__declspec(dllimport)
BOOL
__stdcall
DrawFocusRect(
     HDC hDC,
     const RECT * lprc);

__declspec(dllimport)
int
__stdcall
FillRect(
     HDC hDC,
     const RECT *lprc,
     HBRUSH hbr);

__declspec(dllimport)
int
__stdcall
FrameRect(
     HDC hDC,
     const RECT *lprc,
     HBRUSH hbr);

__declspec(dllimport)
BOOL
__stdcall
InvertRect(
     HDC hDC,
     const RECT *lprc);

__declspec(dllimport)
BOOL
__stdcall
SetRect(
     LPRECT lprc,
     int xLeft,
     int yTop,
     int xRight,
     int yBottom);

__declspec(dllimport)
BOOL
__stdcall
SetRectEmpty(
     LPRECT lprc);

__declspec(dllimport)
BOOL
__stdcall
CopyRect(
     LPRECT lprcDst,
     const RECT *lprcSrc);

__declspec(dllimport)
BOOL
__stdcall
InflateRect(
     LPRECT lprc,
     int dx,
     int dy);

__declspec(dllimport)
BOOL
__stdcall
IntersectRect(
     LPRECT lprcDst,
     const RECT *lprcSrc1,
     const RECT *lprcSrc2);

__declspec(dllimport)
BOOL
__stdcall
UnionRect(
     LPRECT lprcDst,
     const RECT *lprcSrc1,
     const RECT *lprcSrc2);

__declspec(dllimport)
BOOL
__stdcall
SubtractRect(
     LPRECT lprcDst,
     const RECT *lprcSrc1,
     const RECT *lprcSrc2);

__declspec(dllimport)
BOOL
__stdcall
OffsetRect(
     LPRECT lprc,
     int dx,
     int dy);

__declspec(dllimport)
BOOL
__stdcall
IsRectEmpty(
     const RECT *lprc);

__declspec(dllimport)
BOOL
__stdcall
EqualRect(
     const RECT *lprc1,
     const RECT *lprc2);

__declspec(dllimport)
BOOL
__stdcall
PtInRect(
     const RECT *lprc,
     POINT pt);



__declspec(dllimport)
WORD
__stdcall
GetWindowWord(
     HWND hWnd,
     int nIndex);

__declspec(dllimport)
WORD
__stdcall
SetWindowWord(
     HWND hWnd,
     int nIndex,
     WORD wNewWord);

#line 9765 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"

#line 9767 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"
#pragma endregion

#pragma region Desktop Family or Games Family




__declspec(dllimport)
LONG
__stdcall
GetWindowLongA(
     HWND hWnd,
     int nIndex);
__declspec(dllimport)
LONG
__stdcall
GetWindowLongW(
     HWND hWnd,
     int nIndex);




#line 9791 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"

__declspec(dllimport)
LONG
__stdcall
SetWindowLongA(
     HWND hWnd,
     int nIndex,
     LONG dwNewLong);
__declspec(dllimport)
LONG
__stdcall
SetWindowLongW(
     HWND hWnd,
     int nIndex,
     LONG dwNewLong);




#line 9811 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"



__declspec(dllimport)
LONG_PTR
__stdcall
GetWindowLongPtrA(
     HWND hWnd,
     int nIndex);
__declspec(dllimport)
LONG_PTR
__stdcall
GetWindowLongPtrW(
     HWND hWnd,
     int nIndex);




#line 9831 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"

__declspec(dllimport)
LONG_PTR
__stdcall
SetWindowLongPtrA(
     HWND hWnd,
     int nIndex,
     LONG_PTR dwNewLong);
__declspec(dllimport)
LONG_PTR
__stdcall
SetWindowLongPtrW(
     HWND hWnd,
     int nIndex,
     LONG_PTR dwNewLong);




#line 9851 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"



















#line 9871 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"

#line 9873 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"

#line 9875 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"
#pragma endregion

#pragma region Desktop Family




__declspec(dllimport)
WORD
__stdcall
GetClassWord(
     HWND hWnd,
     int nIndex);

__declspec(dllimport)
WORD
__stdcall
SetClassWord(
     HWND hWnd,
     int nIndex,
     WORD wNewWord);

__declspec(dllimport)
DWORD
__stdcall
GetClassLongA(
     HWND hWnd,
     int nIndex);
__declspec(dllimport)
DWORD
__stdcall
GetClassLongW(
     HWND hWnd,
     int nIndex);




#line 9914 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"

__declspec(dllimport)
DWORD
__stdcall
SetClassLongA(
     HWND hWnd,
     int nIndex,
     LONG dwNewLong);
__declspec(dllimport)
DWORD
__stdcall
SetClassLongW(
     HWND hWnd,
     int nIndex,
     LONG dwNewLong);




#line 9934 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"



__declspec(dllimport)
ULONG_PTR
__stdcall
GetClassLongPtrA(
     HWND hWnd,
     int nIndex);
__declspec(dllimport)
ULONG_PTR
__stdcall
GetClassLongPtrW(
     HWND hWnd,
     int nIndex);




#line 9954 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"

__declspec(dllimport)
ULONG_PTR
__stdcall
SetClassLongPtrA(
     HWND hWnd,
     int nIndex,
     LONG_PTR dwNewLong);
__declspec(dllimport)
ULONG_PTR
__stdcall
SetClassLongPtrW(
     HWND hWnd,
     int nIndex,
     LONG_PTR dwNewLong);




#line 9974 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"



















#line 9994 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"

#line 9996 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"


__declspec(dllimport)
BOOL
__stdcall
GetProcessDefaultLayout(
     DWORD *pdwDefaultLayout);

__declspec(dllimport)
BOOL
__stdcall
SetProcessDefaultLayout(
     DWORD dwDefaultLayout);
#line 10010 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"

__declspec(dllimport)
HWND
__stdcall
GetDesktopWindow(
    void );


__declspec(dllimport)
HWND
__stdcall
GetParent(
     HWND hWnd);

__declspec(dllimport)
HWND
__stdcall
SetParent(
     HWND hWndChild,
     HWND hWndNewParent);

__declspec(dllimport)
BOOL
__stdcall
EnumChildWindows(
     HWND hWndParent,
     WNDENUMPROC lpEnumFunc,
     LPARAM lParam);


__declspec(dllimport)
HWND
__stdcall
FindWindowA(
     LPCSTR lpClassName,
     LPCSTR lpWindowName);
__declspec(dllimport)
HWND
__stdcall
FindWindowW(
     LPCWSTR lpClassName,
     LPCWSTR lpWindowName);




#line 10057 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"


__declspec(dllimport)
HWND
__stdcall
FindWindowExA(
     HWND hWndParent,
     HWND hWndChildAfter,
     LPCSTR lpszClass,
     LPCSTR lpszWindow);
__declspec(dllimport)
HWND
__stdcall
FindWindowExW(
     HWND hWndParent,
     HWND hWndChildAfter,
     LPCWSTR lpszClass,
     LPCWSTR lpszWindow);




#line 10080 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"

__declspec(dllimport)
HWND
__stdcall
GetShellWindow(
    void );

#line 10088 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"


__declspec(dllimport)
BOOL
__stdcall
RegisterShellHookWindow(
     HWND hwnd);

__declspec(dllimport)
BOOL
__stdcall
DeregisterShellHookWindow(
     HWND hwnd);

__declspec(dllimport)
BOOL
__stdcall
EnumWindows(
     WNDENUMPROC lpEnumFunc,
     LPARAM lParam);

__declspec(dllimport)
BOOL
__stdcall
EnumThreadWindows(
     DWORD dwThreadId,
     WNDENUMPROC lpfn,
     LPARAM lParam);




#line 10121 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"
#pragma endregion

#pragma region Desktop Family or Games Family


__declspec(dllimport)
int
__stdcall
GetClassNameA(
     HWND hWnd,
     LPSTR lpClassName,
     int nMaxCount
    );
__declspec(dllimport)
int
__stdcall
GetClassNameW(
     HWND hWnd,
     LPWSTR lpClassName,
     int nMaxCount
    );




#line 10147 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"





















#line 10169 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"

#line 10171 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"
#pragma endregion

#pragma region Desktop Family


__declspec(dllimport)
HWND
__stdcall
GetTopWindow(
     HWND hWnd);





__declspec(dllimport)
DWORD
__stdcall
GetWindowThreadProcessId(
     HWND hWnd,
     LPDWORD lpdwProcessId);



__declspec(dllimport)
BOOL
__stdcall
IsGUIThread(
     BOOL bConvert);

#line 10202 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"





__declspec(dllimport)
HWND
__stdcall
GetLastActivePopup(
     HWND hWnd);

/*
 * GetWindow() Constants
 */








#line 10225 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"


#line 10228 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"

__declspec(dllimport)
HWND
__stdcall
GetWindow(
     HWND hWnd,
     UINT uCmd);






__declspec(dllimport)
HHOOK
__stdcall
SetWindowsHookA(
     int nFilterType,
     HOOKPROC pfnFilterProc);
__declspec(dllimport)
HHOOK
__stdcall
SetWindowsHookW(
     int nFilterType,
     HOOKPROC pfnFilterProc);




#line 10258 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"





















#line 10280 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"

__declspec(dllimport)
BOOL
__stdcall
UnhookWindowsHook(
     int nCode,
     HOOKPROC pfnFilterProc);

__declspec(dllimport)
HHOOK
__stdcall
SetWindowsHookExA(
     int idHook,
     HOOKPROC lpfn,
     HINSTANCE hmod,
     DWORD dwThreadId);
__declspec(dllimport)
HHOOK
__stdcall
SetWindowsHookExW(
     int idHook,
     HOOKPROC lpfn,
     HINSTANCE hmod,
     DWORD dwThreadId);




#line 10309 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"

__declspec(dllimport)
BOOL
__stdcall
UnhookWindowsHookEx(
     HHOOK hhk);

__declspec(dllimport)
LRESULT
__stdcall
CallNextHookEx(
     HHOOK hhk,
     int nCode,
     WPARAM wParam,
     LPARAM lParam);

/*
 * Macros for source-level compatibility with old functions.
 */






#line 10335 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"
#line 10336 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"

#line 10338 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"
#pragma endregion




/* ;win40  -- A lot of MF_* flags have been renamed as MFT_* and MFS_* flags */
/*
 * Menu flags for Add/Check/EnableMenuItem()
 */
































#line 10380 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"




#line 10385 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"




#line 10390 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"













/* Menu flags for Add/Check/EnableMenuItem() */








#line 10413 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"


#pragma region Desktop Family




__declspec(dllimport)
BOOL
__stdcall
CheckMenuRadioItem(
     HMENU hmenu,
     UINT first,
     UINT last,
     UINT check,
     UINT flags);
#line 10430 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"

/*
 * Menu item resource format
 */
typedef struct {
    WORD versionNumber;
    WORD offset;
} MENUITEMTEMPLATEHEADER, *PMENUITEMTEMPLATEHEADER;

typedef struct {        // version 0
    WORD mtOption;
    WORD mtID;
    WCHAR mtString[1];
} MENUITEMTEMPLATE, *PMENUITEMTEMPLATE;


#line 10447 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"
#pragma endregion

#line 10450 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"



/*
 * System Menu Command Values
 */





















#line 10478 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"



#line 10482 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"



/*
 * Obsolete names
 */



#line 10492 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"

/*
 * Resource Loading Routines
 */

#pragma region Desktop Family


__declspec(dllimport)
HBITMAP
__stdcall
LoadBitmapA(
     HINSTANCE hInstance,
     LPCSTR lpBitmapName);
__declspec(dllimport)
HBITMAP
__stdcall
LoadBitmapW(
     HINSTANCE hInstance,
     LPCWSTR lpBitmapName);




#line 10517 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"

#line 10519 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"
#pragma endregion

#pragma region Desktop or Games Family


__declspec(dllimport)
HCURSOR
__stdcall
LoadCursorA(
     HINSTANCE hInstance,
     LPCSTR lpCursorName);
__declspec(dllimport)
HCURSOR
__stdcall
LoadCursorW(
     HINSTANCE hInstance,
     LPCWSTR lpCursorName);




#line 10541 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"

#line 10543 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"
#pragma endregion

#pragma region Desktop Family


__declspec(dllimport)
HCURSOR
__stdcall
LoadCursorFromFileA(
     LPCSTR lpFileName);
__declspec(dllimport)
HCURSOR
__stdcall
LoadCursorFromFileW(
     LPCWSTR lpFileName);




#line 10563 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"

#line 10565 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"
#pragma endregion

#pragma region Desktop or Games Family


__declspec(dllimport)
HCURSOR
__stdcall
CreateCursor(
     HINSTANCE hInst,
     int xHotSpot,
     int yHotSpot,
     int nWidth,
     int nHeight,
     const void *pvANDPlane,
     const void *pvXORPlane);

__declspec(dllimport)
BOOL
__stdcall
DestroyCursor(
     HCURSOR hCursor);

#line 10589 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"
#pragma endregion

#pragma region Desktop Family










#line 10603 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"

#line 10605 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"
#pragma endregion

/*
 * Standard Cursor IDs
 */















#line 10626 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"



#line 10630 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"




#line 10635 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"

#pragma region Desktop Family


__declspec(dllimport)
BOOL
__stdcall
SetSystemCursor(
     HCURSOR hcur,
     DWORD id);

typedef struct _ICONINFO {
    BOOL    fIcon;
    DWORD   xHotspot;
    DWORD   yHotspot;
    HBITMAP hbmMask;
    HBITMAP hbmColor;
} ICONINFO;
typedef ICONINFO *PICONINFO;

__declspec(dllimport)
HICON
__stdcall
LoadIconA(
     HINSTANCE hInstance,
     LPCSTR lpIconName);
__declspec(dllimport)
HICON
__stdcall
LoadIconW(
     HINSTANCE hInstance,
     LPCWSTR lpIconName);




#line 10672 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"


__declspec(dllimport)
UINT
__stdcall
PrivateExtractIconsA(
     LPCSTR szFileName,
     int nIconIndex,
     int cxIcon,
     int cyIcon,
     HICON *phicon,
     UINT *piconid,
     UINT nIcons,
     UINT flags);
__declspec(dllimport)
UINT
__stdcall
PrivateExtractIconsW(
     LPCWSTR szFileName,
     int nIconIndex,
     int cxIcon,
     int cyIcon,
     HICON *phicon,
     UINT *piconid,
     UINT nIcons,
     UINT flags);




#line 10703 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"

__declspec(dllimport)
HICON
__stdcall
CreateIcon(
     HINSTANCE hInstance,
     int nWidth,
     int nHeight,
     BYTE cPlanes,
     BYTE cBitsPixel,
     const BYTE *lpbANDbits,
     const BYTE *lpbXORbits);

__declspec(dllimport)
BOOL
__stdcall
DestroyIcon(
     HICON hIcon);

__declspec(dllimport)
int
__stdcall
LookupIconIdFromDirectory(
     PBYTE presbits,
     BOOL fIcon);


__declspec(dllimport)
int
__stdcall
LookupIconIdFromDirectoryEx(
     PBYTE presbits,
     BOOL fIcon,
     int cxDesired,
     int cyDesired,
     UINT Flags);
#line 10740 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"

__declspec(dllimport)
HICON
__stdcall
CreateIconFromResource(
     PBYTE presbits,
     DWORD dwResSize,
     BOOL fIcon,
     DWORD dwVer);


__declspec(dllimport)
HICON
__stdcall
CreateIconFromResourceEx(
     PBYTE presbits,
     DWORD dwResSize,
     BOOL fIcon,
     DWORD dwVer,
     int cxDesired,
     int cyDesired,
     UINT Flags);

/* Icon/Cursor header */
typedef struct tagCURSORSHAPE
{
    int     xHotSpot;
    int     yHotSpot;
    int     cx;
    int     cy;
    int     cbWidth;
    BYTE    Planes;
    BYTE    BitsPixel;
} CURSORSHAPE,  *LPCURSORSHAPE;
#line 10775 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"

#line 10777 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"
#pragma endregion





















#pragma region Desktop Family


__declspec(dllimport)
HANDLE
__stdcall
LoadImageA(
     HINSTANCE hInst,
     LPCSTR name,
     UINT type,
     int cx,
     int cy,
     UINT fuLoad);
__declspec(dllimport)
HANDLE
__stdcall
LoadImageW(
     HINSTANCE hInst,
     LPCWSTR name,
     UINT type,
     int cx,
     int cy,
     UINT fuLoad);




#line 10827 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"

__declspec(dllimport)
HANDLE
__stdcall
CopyImage(
     HANDLE h,
     UINT type,
     int cx,
     int cy,
     UINT flags);








#line 10846 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"

__declspec(dllimport) BOOL __stdcall DrawIconEx(
     HDC hdc,
     int xLeft,
     int yTop,
     HICON hIcon,
     int cxWidth,
     int cyWidth,
     UINT istepIfAniCur,
     HBRUSH hbrFlickerFreeDraw,
     UINT diFlags);

#line 10859 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"
#pragma endregion

#line 10862 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"

#pragma region Desktop Family


__declspec(dllimport)
HICON
__stdcall
CreateIconIndirect(
     PICONINFO piconinfo);

__declspec(dllimport)
HICON
__stdcall
CopyIcon(
     HICON hIcon);

__declspec(dllimport)
BOOL
__stdcall
GetIconInfo(
     HICON hIcon,
     PICONINFO piconinfo);


typedef struct _ICONINFOEXA {
    DWORD   cbSize;
    BOOL    fIcon;
    DWORD   xHotspot;
    DWORD   yHotspot;
    HBITMAP hbmMask;
    HBITMAP hbmColor;
    WORD    wResID;
    CHAR    szModName[260 ];
    CHAR    szResName[260 ];
} ICONINFOEXA, *PICONINFOEXA;
typedef struct _ICONINFOEXW {
    DWORD   cbSize;
    BOOL    fIcon;
    DWORD   xHotspot;
    DWORD   yHotspot;
    HBITMAP hbmMask;
    HBITMAP hbmColor;
    WORD    wResID;
    WCHAR   szModName[260 ];
    WCHAR   szResName[260 ];
} ICONINFOEXW, *PICONINFOEXW;




typedef ICONINFOEXA ICONINFOEX;
typedef PICONINFOEXA PICONINFOEX;
#line 10915 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"

__declspec(dllimport)
BOOL
__stdcall
GetIconInfoExA(
     HICON hicon,
     PICONINFOEXA piconinfo);
__declspec(dllimport)
BOOL
__stdcall
GetIconInfoExW(
     HICON hicon,
     PICONINFOEXW piconinfo);




#line 10933 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"
#line 10934 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"




#line 10939 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"

#line 10941 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"
#pragma endregion



























































































/*
 * Standard Icon IDs
 */




















#line 11057 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"


#line 11060 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"
#line 11061 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"





#line 11067 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"


#line 11070 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"



































/*
 * Dialog Box Command IDs
 */










#line 11119 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"




#line 11124 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"




#line 11129 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"
#line 11130 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"




/*
 * Control Manager Structures and Definitions
 */




/*
 * Edit Control Styles
 */















#line 11160 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"


#line 11163 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"

/*
 * Edit Control Notification Codes
 */












#line 11180 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"




#line 11185 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"


/* Edit control EM_SETMARGIN parameters */



#line 11192 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"


/* wParam of EM_GET/SETIMESTATUS  */


/* lParam for EMSIS_COMPOSITIONSTRING  */



#line 11202 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"




/*
 * Edit Control Messages
 */






































#line 11248 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"




#line 11253 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"



#line 11257 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"


#line 11260 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"









#line 11270 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"

/*
 * EDITWORDBREAKPROC code values
 */





/*
 * Button Control Styles
 */





























#line 11312 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"

/*
 * User Button Notification Codes
 */












#line 11329 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"

/*
 * Button Control Messages
 */









#line 11343 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"


#line 11346 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"







#line 11354 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"

/*
 * Static Control Constants
 */





















#line 11380 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"


#line 11383 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"












#line 11396 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"




/*
 * Static Control Mesages
 */









#line 11413 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"

#line 11415 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"

/*
 * Dialog window class
 */


/*
 * Get/SetWindowWord/Long offsets for use with WC_DIALOG windows
 */










#line 11435 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"





#pragma region Desktop Family


/*
 * Dialog Manager Routines
 */



__declspec(dllimport)
BOOL
__stdcall
IsDialogMessageA(
     HWND hDlg,
     LPMSG lpMsg);
__declspec(dllimport)
BOOL
__stdcall
IsDialogMessageW(
     HWND hDlg,
     LPMSG lpMsg);




#line 11466 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"

#line 11468 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"

__declspec(dllimport)
BOOL
__stdcall
MapDialogRect(
     HWND hDlg,
     LPRECT lpRect);

__declspec(dllimport)
int
__stdcall
DlgDirListA(
     HWND hDlg,
     LPSTR lpPathSpec,
     int nIDListBox,
     int nIDStaticPath,
     UINT uFileType);
__declspec(dllimport)
int
__stdcall
DlgDirListW(
     HWND hDlg,
     LPWSTR lpPathSpec,
     int nIDListBox,
     int nIDStaticPath,
     UINT uFileType);




#line 11499 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"

#line 11501 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"
#pragma endregion

/*
 * DlgDirList, DlgDirListComboBox flags values
 */











#pragma region Desktop Family


__declspec(dllimport)
BOOL
__stdcall
DlgDirSelectExA(
     HWND hwndDlg,
     LPSTR lpString,
     int chCount,
     int idListBox);
__declspec(dllimport)
BOOL
__stdcall
DlgDirSelectExW(
     HWND hwndDlg,
     LPWSTR lpString,
     int chCount,
     int idListBox);




#line 11541 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"

__declspec(dllimport)
int
__stdcall
DlgDirListComboBoxA(
     HWND hDlg,
     LPSTR lpPathSpec,
     int nIDComboBox,
     int nIDStaticPath,
     UINT uFiletype);
__declspec(dllimport)
int
__stdcall
DlgDirListComboBoxW(
     HWND hDlg,
     LPWSTR lpPathSpec,
     int nIDComboBox,
     int nIDStaticPath,
     UINT uFiletype);




#line 11565 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"

__declspec(dllimport)
BOOL
__stdcall
DlgDirSelectComboBoxExA(
     HWND hwndDlg,
     LPSTR lpString,
     int cchOut,
     int idComboBox);
__declspec(dllimport)
BOOL
__stdcall
DlgDirSelectComboBoxExW(
     HWND hwndDlg,
     LPWSTR lpString,
     int cchOut,
     int idComboBox);




#line 11587 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"

#line 11589 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"
#pragma endregion



/*
 * Dialog Styles
 */



















#line 11616 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"



#line 11620 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"







#line 11628 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"
/*
 * Returned in HIWORD() of DM_GETDEFID result if msg is supported
 */


/*
 * Dialog Codes
 */














/*
 * Listbox Return Values
 */




/*
**  The idStaticPath parameter to DlgDirList can have the following values
**  ORed if the list box should show other details of the files along with
**  the name of the files;
*/
                                  /* all other details also will be returned */


/*
 * Listbox Notification Codes
 */











/*
 * Listbox messages
 */









































#line 11724 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"


#line 11727 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"




#line 11732 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"









#line 11742 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"

#line 11744 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"




/*
 * Listbox Styles
 */
















#line 11768 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"





#line 11774 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"


/*
 * Combo Box return Values
 */





/*
 * Combo Box Notification Codes
 */














/*
 * Combo Box styles
 */














#line 11819 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"

#line 11821 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"


/*
 * Combo Box messages
 */






































#line 11865 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"
#line 11866 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"



#line 11870 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"









#line 11880 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"
#line 11881 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"






/*
 * Scroll Bar Styles
 */











#line 11902 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"


#line 11905 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"

/*
 * Scroll bar messages
 */










#line 11920 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"



#line 11924 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"









#pragma region Desktop Family


typedef struct tagSCROLLINFO
{
    UINT    cbSize;
    UINT    fMask;
    int     nMin;
    int     nMax;
    UINT    nPage;
    int     nPos;
    int     nTrackPos;
}   SCROLLINFO,  *LPSCROLLINFO;
typedef SCROLLINFO const  *LPCSCROLLINFO;

__declspec(dllimport)
int
__stdcall
SetScrollInfo(
     HWND hwnd,
     int nBar,
     LPCSCROLLINFO lpsi,
     BOOL redraw);

__declspec(dllimport)
BOOL
__stdcall
GetScrollInfo(
     HWND hwnd,
     int nBar,
     LPSCROLLINFO lpsi);


#line 11967 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"
#pragma endregion
#line 11969 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"

#line 11971 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"
#line 11972 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"



/*
 * MDI client style bits
 */


/*
 * wParam Flags for WM_MDITILE and WM_MDICASCADE messages.
 */





#line 11989 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"

#pragma region Desktop Family


typedef struct tagMDICREATESTRUCTA {
    LPCSTR   szClass;
    LPCSTR   szTitle;
    HANDLE hOwner;
    int x;
    int y;
    int cx;
    int cy;
    DWORD style;
    LPARAM lParam;        /* app-defined stuff */
} MDICREATESTRUCTA, *LPMDICREATESTRUCTA;
typedef struct tagMDICREATESTRUCTW {
    LPCWSTR  szClass;
    LPCWSTR  szTitle;
    HANDLE hOwner;
    int x;
    int y;
    int cx;
    int cy;
    DWORD style;
    LPARAM lParam;        /* app-defined stuff */
} MDICREATESTRUCTW, *LPMDICREATESTRUCTW;




typedef MDICREATESTRUCTA MDICREATESTRUCT;
typedef LPMDICREATESTRUCTA LPMDICREATESTRUCT;
#line 12022 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"

typedef struct tagCLIENTCREATESTRUCT {
    HANDLE hWindowMenu;
    UINT idFirstChild;
} CLIENTCREATESTRUCT, *LPCLIENTCREATESTRUCT;

__declspec(dllimport)
LRESULT
__stdcall
DefFrameProcA(
     HWND hWnd,
     HWND hWndMDIClient,
     UINT uMsg,
     WPARAM wParam,
     LPARAM lParam);
__declspec(dllimport)
LRESULT
__stdcall
DefFrameProcW(
     HWND hWnd,
     HWND hWndMDIClient,
     UINT uMsg,
     WPARAM wParam,
     LPARAM lParam);




#line 12051 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"

__declspec(dllimport)

LRESULT
__stdcall



#line 12060 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"
DefMDIChildProcA(
     HWND hWnd,
     UINT uMsg,
     WPARAM wParam,
     LPARAM lParam);
__declspec(dllimport)

LRESULT
__stdcall



#line 12073 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"
DefMDIChildProcW(
     HWND hWnd,
     UINT uMsg,
     WPARAM wParam,
     LPARAM lParam);




#line 12083 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"



__declspec(dllimport)
BOOL
__stdcall
TranslateMDISysAccel(
     HWND hWndClient,
     LPMSG lpMsg);

#line 12094 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"

__declspec(dllimport)
UINT
__stdcall
ArrangeIconicWindows(
     HWND hWnd);

__declspec(dllimport)
HWND
__stdcall
CreateMDIWindowA(
     LPCSTR lpClassName,
     LPCSTR lpWindowName,
     DWORD dwStyle,
     int X,
     int Y,
     int nWidth,
     int nHeight,
     HWND hWndParent,
     HINSTANCE hInstance,
     LPARAM lParam);
__declspec(dllimport)
HWND
__stdcall
CreateMDIWindowW(
     LPCWSTR lpClassName,
     LPCWSTR lpWindowName,
     DWORD dwStyle,
     int X,
     int Y,
     int nWidth,
     int nHeight,
     HWND hWndParent,
     HINSTANCE hInstance,
     LPARAM lParam);




#line 12134 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"


__declspec(dllimport)
WORD
__stdcall
TileWindows(
     HWND hwndParent,
     UINT wHow,
     const RECT * lpRect,
     UINT cKids,
     const HWND  * lpKids);

__declspec(dllimport)
WORD
__stdcall CascadeWindows(
     HWND hwndParent,
     UINT wHow,
     const RECT * lpRect,
     UINT cKids,
     const HWND  * lpKids);

#line 12156 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"

#line 12158 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"
#pragma endregion

#line 12161 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"

#line 12163 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"

/****** Help support ********************************************************/

#pragma region Desktop Family




typedef DWORD HELPPOLY;
typedef struct tagMULTIKEYHELPA {

    DWORD  mkSize;


#line 12178 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"
    CHAR   mkKeylist;
    CHAR   szKeyphrase[1];
} MULTIKEYHELPA, *PMULTIKEYHELPA, *LPMULTIKEYHELPA;
typedef struct tagMULTIKEYHELPW {

    DWORD  mkSize;


#line 12187 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"
    WCHAR  mkKeylist;
    WCHAR  szKeyphrase[1];
} MULTIKEYHELPW, *PMULTIKEYHELPW, *LPMULTIKEYHELPW;





typedef MULTIKEYHELPA MULTIKEYHELP;
typedef PMULTIKEYHELPA PMULTIKEYHELP;
typedef LPMULTIKEYHELPA LPMULTIKEYHELP;
#line 12199 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"

typedef struct tagHELPWININFOA {
    int  wStructSize;
    int  x;
    int  y;
    int  dx;
    int  dy;
    int  wMax;
    CHAR   rgchMember[2];
} HELPWININFOA, *PHELPWININFOA, *LPHELPWININFOA;
typedef struct tagHELPWININFOW {
    int  wStructSize;
    int  x;
    int  y;
    int  dx;
    int  dy;
    int  wMax;
    WCHAR  rgchMember[2];
} HELPWININFOW, *PHELPWININFOW, *LPHELPWININFOW;





typedef HELPWININFOA HELPWININFO;
typedef PHELPWININFOA PHELPWININFO;
typedef LPHELPWININFOA LPHELPWININFO;
#line 12227 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"


/*
 * Commands to pass to WinHelp()
 */
























// These are in winhelp.h in Win95.







#line 12265 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"



__declspec(dllimport)
BOOL
__stdcall
WinHelpA(
     HWND hWndMain,
     LPCSTR lpszHelp,
     UINT uCommand,
     ULONG_PTR dwData);
__declspec(dllimport)
BOOL
__stdcall
WinHelpW(
     HWND hWndMain,
     LPCWSTR lpszHelp,
     UINT uCommand,
     ULONG_PTR dwData);




#line 12289 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"

#line 12291 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"

#line 12293 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"
#pragma endregion





#line 12300 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"



#line 12304 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"



#line 12308 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"

#pragma region Desktop Family



__declspec(dllimport)
DWORD
__stdcall
GetGuiResources(
     HANDLE hProcess,
     DWORD uiFlags);
#line 12320 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"

#line 12322 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"
#pragma endregion


#pragma region Desktop Family



#line 12330 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"
#pragma endregion



/*
 * Parameter for SystemParametersInfo.
 */














































































#line 12416 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"















#line 12432 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"





#line 12438 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"















#line 12454 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"



#line 12458 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"







#line 12466 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"







#line 12474 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"




























#line 12503 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"







































#line 12543 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"












































#line 12588 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"













#line 12602 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"








#line 12611 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"


#line 12614 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"
















/* constants for SPI_GETFONTSMOOTHINGTYPE and SPI_SETFONTSMOOTHINGTYPE: */














/* constants for SPI_GETFONTSMOOTHINGORIENTATION and SPI_SETFONTSMOOTHINGORIENTATION: */


#line 12649 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"






#line 12656 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"



















#line 12676 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"










#line 12687 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"



















#line 12707 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"




#line 12712 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"








#line 12721 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"

#line 12723 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"

/*
 * Flags
 */









#pragma region Desktop Family


typedef struct tagNONCLIENTMETRICSA
{
    UINT    cbSize;
    int     iBorderWidth;
    int     iScrollWidth;
    int     iScrollHeight;
    int     iCaptionWidth;
    int     iCaptionHeight;
    LOGFONTA lfCaptionFont;
    int     iSmCaptionWidth;
    int     iSmCaptionHeight;
    LOGFONTA lfSmCaptionFont;
    int     iMenuWidth;
    int     iMenuHeight;
    LOGFONTA lfMenuFont;
    LOGFONTA lfStatusFont;
    LOGFONTA lfMessageFont;

    int     iPaddedBorderWidth;
#line 12759 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"
}   NONCLIENTMETRICSA, *PNONCLIENTMETRICSA,  * LPNONCLIENTMETRICSA;
typedef struct tagNONCLIENTMETRICSW
{
    UINT    cbSize;
    int     iBorderWidth;
    int     iScrollWidth;
    int     iScrollHeight;
    int     iCaptionWidth;
    int     iCaptionHeight;
    LOGFONTW lfCaptionFont;
    int     iSmCaptionWidth;
    int     iSmCaptionHeight;
    LOGFONTW lfSmCaptionFont;
    int     iMenuWidth;
    int     iMenuHeight;
    LOGFONTW lfMenuFont;
    LOGFONTW lfStatusFont;
    LOGFONTW lfMessageFont;

    int     iPaddedBorderWidth;
#line 12780 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"
}   NONCLIENTMETRICSW, *PNONCLIENTMETRICSW,  * LPNONCLIENTMETRICSW;





typedef NONCLIENTMETRICSA NONCLIENTMETRICS;
typedef PNONCLIENTMETRICSA PNONCLIENTMETRICS;
typedef LPNONCLIENTMETRICSA LPNONCLIENTMETRICS;
#line 12790 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"

#line 12792 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"
#pragma endregion

#line 12795 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"
#line 12796 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"















#pragma region Desktop Family


typedef struct tagMINIMIZEDMETRICS
{
    UINT    cbSize;
    int     iWidth;
    int     iHorzGap;
    int     iVertGap;
    int     iArrange;
}   MINIMIZEDMETRICS, *PMINIMIZEDMETRICS, *LPMINIMIZEDMETRICS;



typedef struct tagICONMETRICSA
{
    UINT    cbSize;
    int     iHorzSpacing;
    int     iVertSpacing;
    int     iTitleWrap;
    LOGFONTA lfFont;
}   ICONMETRICSA, *PICONMETRICSA, *LPICONMETRICSA;
typedef struct tagICONMETRICSW
{
    UINT    cbSize;
    int     iHorzSpacing;
    int     iVertSpacing;
    int     iTitleWrap;
    LOGFONTW lfFont;
}   ICONMETRICSW, *PICONMETRICSW, *LPICONMETRICSW;





typedef ICONMETRICSA ICONMETRICS;
typedef PICONMETRICSA PICONMETRICS;
typedef LPICONMETRICSA LPICONMETRICS;
#line 12850 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"
#line 12851 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"
#line 12852 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"

typedef struct tagANIMATIONINFO
{
    UINT    cbSize;
    int     iMinAnimate;
}   ANIMATIONINFO, *LPANIMATIONINFO;

typedef struct tagSERIALKEYSA
{
    UINT    cbSize;
    DWORD   dwFlags;
    LPSTR     lpszActivePort;
    LPSTR     lpszPort;
    UINT    iBaudRate;
    UINT    iPortState;
    UINT    iActive;
}   SERIALKEYSA, *LPSERIALKEYSA;
typedef struct tagSERIALKEYSW
{
    UINT    cbSize;
    DWORD   dwFlags;
    LPWSTR    lpszActivePort;
    LPWSTR    lpszPort;
    UINT    iBaudRate;
    UINT    iPortState;
    UINT    iActive;
}   SERIALKEYSW, *LPSERIALKEYSW;




typedef SERIALKEYSA SERIALKEYS;
typedef LPSERIALKEYSA LPSERIALKEYS;
#line 12886 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"

/* flags for SERIALKEYS dwFlags field */





typedef struct tagHIGHCONTRASTA
{
    UINT    cbSize;
    DWORD   dwFlags;
    LPSTR   lpszDefaultScheme;
}   HIGHCONTRASTA, *LPHIGHCONTRASTA;
typedef struct tagHIGHCONTRASTW
{
    UINT    cbSize;
    DWORD   dwFlags;
    LPWSTR  lpszDefaultScheme;
}   HIGHCONTRASTW, *LPHIGHCONTRASTW;




typedef HIGHCONTRASTA HIGHCONTRAST;
typedef LPHIGHCONTRASTA LPHIGHCONTRAST;
#line 12912 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"

#line 12914 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"
#pragma endregion

/* flags for HIGHCONTRAST dwFlags field */










/* Flags for ChangeDisplaySettings */









#line 12938 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"




#line 1 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\shared\\tvout.h"


/*++

Copyright (c) Microsoft Corporation. All rights reserved.
*/





#pragma once
#line 14 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\shared\\tvout.h"





#pragma region Desktop Family


typedef struct _VIDEOPARAMETERS {
    GUID  Guid;                         // GUID for this structure
    ULONG dwOffset;                     // leave it 0 for now.
    ULONG dwCommand;                    // VP_COMMAND_*            SET or GET
    ULONG dwFlags;                      // bitfield, defined below SET or GET
    ULONG dwMode;                       // bitfield, defined below SET or GET
    ULONG dwTVStandard;                 // bitfield, defined below SET or GET
    ULONG dwAvailableModes;             // bitfield, defined below GET
    ULONG dwAvailableTVStandard;        // bitfield, defined below GET
    ULONG dwFlickerFilter;              // value                   SET or GET
    ULONG dwOverScanX;                  // value                   SET or GET
    ULONG dwOverScanY;                  //                         SET or GET
    ULONG dwMaxUnscaledX;               // value                   SET or GET
    ULONG dwMaxUnscaledY;               //                         SET or GET
    ULONG dwPositionX;                  // value                   SET or GET
    ULONG dwPositionY;                  //                         SET or GET
    ULONG dwBrightness;                 // value                   SET or GET
    ULONG dwContrast;                   // value                   SET or GET
    ULONG dwCPType;                     // copy protection type    SET or GET
    ULONG dwCPCommand;                  // VP_CP_CMD_
    ULONG dwCPStandard;                 // what TV standards CP is available on. GET
    ULONG dwCPKey;
    ULONG bCP_APSTriggerBits;           // (a dword for alignment) SET(bits 0 and 1 valid).
    UCHAR bOEMCopyProtection[256];      // oem specific copy protection data SET or GET
} VIDEOPARAMETERS, *PVIDEOPARAMETERS, *LPVIDEOPARAMETERS;


                                        // returned Flags = 0 if not supported.































// and the rest












#line 95 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\shared\\tvout.h"
#pragma endregion

#line 98 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\shared\\tvout.h"
#line 12943 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"

/* Return values for ChangeDisplaySettings */









#line 12955 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"

#pragma region Desktop Family





__declspec(dllimport)
LONG
__stdcall
ChangeDisplaySettingsA(
     DEVMODEA* lpDevMode,
     DWORD dwFlags);
__declspec(dllimport)
LONG
__stdcall
ChangeDisplaySettingsW(
     DEVMODEW* lpDevMode,
     DWORD dwFlags);




#line 12979 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"

__declspec(dllimport)
LONG
__stdcall
ChangeDisplaySettingsExA(
     LPCSTR lpszDeviceName,
     DEVMODEA* lpDevMode,
     HWND hwnd,
     DWORD dwflags,
     LPVOID lParam);
__declspec(dllimport)
LONG
__stdcall
ChangeDisplaySettingsExW(
     LPCWSTR lpszDeviceName,
     DEVMODEW* lpDevMode,
     HWND hwnd,
     DWORD dwflags,
     LPVOID lParam);




#line 13003 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"





__declspec(dllimport)
BOOL
__stdcall
EnumDisplaySettingsA(
     LPCSTR lpszDeviceName,
     DWORD iModeNum,
     DEVMODEA* lpDevMode);
__declspec(dllimport)
BOOL
__stdcall
EnumDisplaySettingsW(
     LPCWSTR lpszDeviceName,
     DWORD iModeNum,
     DEVMODEW* lpDevMode);




#line 13027 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"



__declspec(dllimport)
BOOL
__stdcall
EnumDisplaySettingsExA(
     LPCSTR lpszDeviceName,
     DWORD iModeNum,
     DEVMODEA* lpDevMode,
     DWORD dwFlags);
__declspec(dllimport)
BOOL
__stdcall
EnumDisplaySettingsExW(
     LPCWSTR lpszDeviceName,
     DWORD iModeNum,
     DEVMODEW* lpDevMode,
     DWORD dwFlags);




#line 13051 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"

/* Flags for EnumDisplaySettingsEx */



__declspec(dllimport)
BOOL
__stdcall
EnumDisplayDevicesA(
     LPCSTR lpDevice,
     DWORD iDevNum,
     PDISPLAY_DEVICEA lpDisplayDevice,
     DWORD dwFlags);
__declspec(dllimport)
BOOL
__stdcall
EnumDisplayDevicesW(
     LPCWSTR lpDevice,
     DWORD iDevNum,
     PDISPLAY_DEVICEW lpDisplayDevice,
     DWORD dwFlags);




#line 13077 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"

/* Flags for EnumDisplayDevices */


#line 13082 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"



__declspec(dllimport)
LONG
__stdcall
GetDisplayConfigBufferSizes(
     UINT32 flags,
     UINT32* numPathArrayElements,
     UINT32* numModeInfoArrayElements);

__declspec(dllimport)
LONG
__stdcall
SetDisplayConfig(
     UINT32 numPathArrayElements,
     DISPLAYCONFIG_PATH_INFO* pathArray,
     UINT32 numModeInfoArrayElements,
     DISPLAYCONFIG_MODE_INFO* modeInfoArray,
     UINT32 flags);

__declspec(dllimport)
 LONG
__stdcall
QueryDisplayConfig(
     UINT32 flags,
     UINT32* numPathArrayElements,
     DISPLAYCONFIG_PATH_INFO* pathArray,
     UINT32* numModeInfoArrayElements,
     DISPLAYCONFIG_MODE_INFO* modeInfoArray,
    
    
        DISPLAYCONFIG_TOPOLOGY_ID* currentTopologyId);

__declspec(dllimport)
LONG
__stdcall
DisplayConfigGetDeviceInfo(
     DISPLAYCONFIG_DEVICE_INFO_HEADER* requestPacket);

__declspec(dllimport)
LONG
__stdcall
DisplayConfigSetDeviceInfo(
     DISPLAYCONFIG_DEVICE_INFO_HEADER* setPacket);

#line 13129 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"


#line 13132 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"
#line 13133 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"


__declspec(dllimport)

BOOL
__stdcall
SystemParametersInfoA(
     UINT uiAction,
     UINT uiParam,
      PVOID pvParam,
     UINT fWinIni);
__declspec(dllimport)

BOOL
__stdcall
SystemParametersInfoW(
     UINT uiAction,
     UINT uiParam,
      PVOID pvParam,
     UINT fWinIni);




#line 13158 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"














#line 13173 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"

#line 13175 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"
#pragma endregion

#line 13178 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"

#pragma region Desktop Family


/*
 * Accessibility support
 */
typedef struct tagFILTERKEYS
{
    UINT  cbSize;
    DWORD dwFlags;
    DWORD iWaitMSec;            // Acceptance Delay
    DWORD iDelayMSec;           // Delay Until Repeat
    DWORD iRepeatMSec;          // Repeat Rate
    DWORD iBounceMSec;          // Debounce Time
} FILTERKEYS, *LPFILTERKEYS;

#line 13196 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"
#pragma endregion

/*
 * FILTERKEYS dwFlags field
 */








#pragma region Desktop Family


typedef struct tagSTICKYKEYS
{
    UINT  cbSize;
    DWORD dwFlags;
} STICKYKEYS, *LPSTICKYKEYS;

#line 13219 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"
#pragma endregion

/*
 * STICKYKEYS dwFlags field
 */


























#line 13251 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"

#pragma region Desktop Family


typedef struct tagMOUSEKEYS
{
    UINT cbSize;
    DWORD dwFlags;
    DWORD iMaxSpeed;
    DWORD iTimeToMaxSpeed;
    DWORD iCtrlSpeed;
    DWORD dwReserved1;
    DWORD dwReserved2;
} MOUSEKEYS, *LPMOUSEKEYS;

#line 13267 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"
#pragma endregion

/*
 * MOUSEKEYS dwFlags field
 */














#line 13287 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"

#pragma region Desktop Family


typedef struct tagACCESSTIMEOUT
{
    UINT  cbSize;
    DWORD dwFlags;
    DWORD iTimeOutMSec;
} ACCESSTIMEOUT, *LPACCESSTIMEOUT;

#line 13299 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"
#pragma endregion

/*
 * ACCESSTIMEOUT dwFlags field
 */



/* values for SOUNDSENTRY iFSGrafEffect field */



/* values for SOUNDSENTRY iFSTextEffect field */





/* values for SOUNDSENTRY iWindowsEffect field */






#pragma region Desktop Family


typedef struct tagSOUNDSENTRYA
{
    UINT cbSize;
    DWORD dwFlags;
    DWORD iFSTextEffect;
    DWORD iFSTextEffectMSec;
    DWORD iFSTextEffectColorBits;
    DWORD iFSGrafEffect;
    DWORD iFSGrafEffectMSec;
    DWORD iFSGrafEffectColor;
    DWORD iWindowsEffect;
    DWORD iWindowsEffectMSec;
    LPSTR   lpszWindowsEffectDLL;
    DWORD iWindowsEffectOrdinal;
} SOUNDSENTRYA, *LPSOUNDSENTRYA;
typedef struct tagSOUNDSENTRYW
{
    UINT cbSize;
    DWORD dwFlags;
    DWORD iFSTextEffect;
    DWORD iFSTextEffectMSec;
    DWORD iFSTextEffectColorBits;
    DWORD iFSGrafEffect;
    DWORD iFSGrafEffectMSec;
    DWORD iFSGrafEffectColor;
    DWORD iWindowsEffect;
    DWORD iWindowsEffectMSec;
    LPWSTR  lpszWindowsEffectDLL;
    DWORD iWindowsEffectOrdinal;
} SOUNDSENTRYW, *LPSOUNDSENTRYW;




typedef SOUNDSENTRYA SOUNDSENTRY;
typedef LPSOUNDSENTRYA LPSOUNDSENTRY;
#line 13364 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"

#line 13366 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"
#pragma endregion

/*
 * SOUNDSENTRY dwFlags field
 */




#pragma region Desktop or PC Family


__declspec(dllimport)
BOOL
__stdcall
SoundSentry(void );
#line 13383 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"
#line 13384 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"
#pragma endregion

#pragma region Desktop Family

typedef struct tagTOGGLEKEYS
{
    UINT cbSize;
    DWORD dwFlags;
} TOGGLEKEYS, *LPTOGGLEKEYS;

#line 13395 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"
#pragma endregion

/*
 * TOGGLEKEYS dwFlags field
 */







#pragma region Desktop Family



typedef struct tagAUDIODESCRIPTION {
    UINT cbSize;   // sizeof(AudioDescriptionType)
    BOOL Enabled;  // On/Off
    LCID Locale;   // locale ID for language
} AUDIODESCRIPTION, *LPAUDIODESCRIPTION;
#line 13417 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"


/*
 * Set debug level
 */

__declspec(dllimport)
void
__stdcall
SetDebugErrorLevel(
     DWORD dwLevel);

#line 13430 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"
#pragma endregion

/*
 * SetLastErrorEx() types.
 */





#pragma region Desktop Family


__declspec(dllimport)
void
__stdcall
SetLastErrorEx(
     DWORD dwErrCode,
     DWORD dwType);

__declspec(dllimport)
int
__stdcall
InternalGetWindowText(
     HWND hWnd,
     LPWSTR pString,
     int cchMaxCount);










#line 13468 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"

__declspec(dllimport)
BOOL
__stdcall
CancelShutdown(
    void );

#line 13476 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"
#pragma endregion




/*
 * Multimonitor API.
 */





#pragma region Desktop Family


__declspec(dllimport)
HMONITOR
__stdcall
MonitorFromPoint(
     POINT pt,
     DWORD dwFlags);

__declspec(dllimport)
HMONITOR
__stdcall
MonitorFromRect(
     LPCRECT lprc,
     DWORD dwFlags);

__declspec(dllimport)
HMONITOR
__stdcall
MonitorFromWindow(
     HWND hwnd,
     DWORD dwFlags);

#line 13514 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"
#pragma endregion







#pragma region Desktop Family


typedef struct tagMONITORINFO
{
    DWORD   cbSize;
    RECT    rcMonitor;
    RECT    rcWork;
    DWORD   dwFlags;
} MONITORINFO, *LPMONITORINFO;


typedef struct tagMONITORINFOEXA : public tagMONITORINFO
{
    CHAR        szDevice[32 ];
} MONITORINFOEXA, *LPMONITORINFOEXA;
typedef struct tagMONITORINFOEXW : public tagMONITORINFO
{
    WCHAR       szDevice[32 ];
} MONITORINFOEXW, *LPMONITORINFOEXW;




typedef MONITORINFOEXA MONITORINFOEX;
typedef LPMONITORINFOEXA LPMONITORINFOEX;
#line 13549 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"


















#line 13568 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"

__declspec(dllimport)
BOOL
__stdcall
GetMonitorInfoA(
     HMONITOR hMonitor,
     LPMONITORINFO lpmi);
__declspec(dllimport)
BOOL
__stdcall
GetMonitorInfoW(
     HMONITOR hMonitor,
     LPMONITORINFO lpmi);




#line 13586 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"

typedef BOOL (__stdcall * MONITORENUMPROC)(HMONITOR, HDC, LPRECT, LPARAM);

__declspec(dllimport)
BOOL
__stdcall
EnumDisplayMonitors(
     HDC hdc,
     LPCRECT lprcClip,
     MONITORENUMPROC lpfnEnum,
     LPARAM dwData);

#line 13599 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"
#pragma endregion




#pragma region Desktop Family


/*
 * WinEvents - Active Accessibility hooks
 */

__declspec(dllimport)
void
__stdcall
NotifyWinEvent(
     DWORD event,
     HWND  hwnd,
     LONG  idObject,
     LONG  idChild);

typedef void (__stdcall * WINEVENTPROC)(
    HWINEVENTHOOK hWinEventHook,
    DWORD         event,
    HWND          hwnd,
    LONG          idObject,
    LONG          idChild,
    DWORD         idEventThread,
    DWORD         dwmsEventTime);

__declspec(dllimport)
HWINEVENTHOOK
__stdcall
SetWinEventHook(
     DWORD eventMin,
     DWORD eventMax,
     HMODULE hmodWinEventProc,
     WINEVENTPROC pfnWinEventProc,
     DWORD idProcess,
     DWORD idThread,
     DWORD dwFlags);


__declspec(dllimport)
BOOL
__stdcall
IsWinEventHookInstalled(
     DWORD event);
#line 13648 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"

#line 13650 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"
#pragma endregion

/*
 * dwFlags for SetWinEventHook
 */





#pragma region Desktop Family


__declspec(dllimport)
BOOL
__stdcall
UnhookWinEvent(
     HWINEVENTHOOK hWinEventHook);

#line 13670 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"
#pragma endregion

/*
 * idObject values for WinEventProc and NotifyWinEvent
 */

/*
 * hwnd + idObject can be used with OLEACC.DLL's OleGetObjectFromWindow()
 * to get an interface pointer to the container.  indexChild is the item
 * within the container in question.  Setup a VARIANT with vt VT_I4 and
 * lVal the indexChild and pass that in to all methods.  Then you
 * are raring to go.
 */


/*
 * Common object IDs (cookies, only for sending WM_GETOBJECT to get at the
 * thing in question).  Positive IDs are reserved for apps (app specific),
 * negative IDs are system things and are global, 0 means "just little old
 * me".
 */




/*
 * Reserved IDs for system objects
 */















/*
 * EVENT DEFINITION
 */



/*
 *  EVENT_SYSTEM_SOUND
 *  Sent when a sound is played.  Currently nothing is generating this, we
 *  this event when a system sound (for menus, etc) is played.  Apps
 *  generate this, if accessible, when a private sound is played.  For
 *  example, if Mail plays a "New Mail" sound.
 *
 *  System Sounds:
 *  (Generated by PlaySoundEvent in USER itself)
 *      hwnd            is NULL
 *      idObject        is OBJID_SOUND
 *      idChild         is sound child ID if one
 *  App Sounds:
 *  (PlaySoundEvent won't generate notification; up to app)
 *      hwnd + idObject gets interface pointer to Sound object
 *      idChild identifies the sound in question
 *  are going to be cleaning up the SOUNDSENTRY feature in the control panel
 *  and will use this at that time.  Applications implementing WinEvents
 *  are perfectly welcome to use it.  Clients of IAccessible* will simply
 *  turn around and get back a non-visual object that describes the sound.
 */


/*
 * EVENT_SYSTEM_ALERT
 * System Alerts:
 * (Generated by MessageBox() calls for example)
 *      hwnd            is hwndMessageBox
 *      idObject        is OBJID_ALERT
 * App Alerts:
 * (Generated whenever)
 *      hwnd+idObject gets interface pointer to Alert
 */


/*
 * EVENT_SYSTEM_FOREGROUND
 * Sent when the foreground (active) window changes, even if it is changing
 * to another window in the same thread as the previous one.
 *      hwnd            is hwndNewForeground
 *      idObject        is OBJID_WINDOW
 *      idChild    is INDEXID_OBJECT
 */


/*
 * Menu
 *      hwnd            is window (top level window or popup menu window)
 *      idObject        is ID of control (OBJID_MENU, OBJID_SYSMENU, OBJID_SELF for popup)
 *      idChild         is CHILDID_SELF
 *
 * EVENT_SYSTEM_MENUSTART
 * EVENT_SYSTEM_MENUEND
 * For MENUSTART, hwnd+idObject+idChild refers to the control with the menu bar,
 *  or the control bringing up the context menu.
 *
 * Sent when entering into and leaving from menu mode (system, app bar, and
 * track popups).
 */



/*
 * EVENT_SYSTEM_MENUPOPUPSTART
 * EVENT_SYSTEM_MENUPOPUPEND
 * Sent when a menu popup comes up and just before it is taken down.  Note
 * that for a call to TrackPopupMenu(), a client will see EVENT_SYSTEM_MENUSTART
 * followed almost immediately by EVENT_SYSTEM_MENUPOPUPSTART for the popup
 * being shown.
 *
 * For MENUPOPUP, hwnd+idObject+idChild refers to the NEW popup coming up, not the
 * parent item which is hierarchical.  You can get the parent menu/popup by
 * asking for the accParent object.
 */




/*
 * EVENT_SYSTEM_CAPTURESTART
 * EVENT_SYSTEM_CAPTUREEND
 * Sent when a window takes the capture and releases the capture.
 */



/*
 * Move Size
 * EVENT_SYSTEM_MOVESIZESTART
 * EVENT_SYSTEM_MOVESIZEEND
 * Sent when a window enters and leaves move-size dragging mode.
 */



/*
 * Context Help
 * EVENT_SYSTEM_CONTEXTHELPSTART
 * EVENT_SYSTEM_CONTEXTHELPEND
 * Sent when a window enters and leaves context sensitive help mode.
 */



/*
 * Drag & Drop
 * EVENT_SYSTEM_DRAGDROPSTART
 * EVENT_SYSTEM_DRAGDROPEND
 * Send the START notification just before going into drag&drop loop.  Send
 * the END notification just after canceling out.
 * Note that it is up to apps and OLE to generate this, since the system
 * doesn't know.  Like EVENT_SYSTEM_SOUND, it will be a while before this
 * is prevalent.
 */



/*
 * Dialog
 * Send the START notification right after the dialog is completely
 *  initialized and visible.  Send the END right before the dialog
 *  is hidden and goes away.
 * EVENT_SYSTEM_DIALOGSTART
 * EVENT_SYSTEM_DIALOGEND
 */



/*
 * EVENT_SYSTEM_SCROLLING
 * EVENT_SYSTEM_SCROLLINGSTART
 * EVENT_SYSTEM_SCROLLINGEND
 * Sent when beginning and ending the tracking of a scrollbar in a window,
 * and also for scrollbar controls.
 */



/*
 * Alt-Tab Window
 * Send the START notification right after the switch window is initialized
 * and visible.  Send the END right before it is hidden and goes away.
 * EVENT_SYSTEM_SWITCHSTART
 * EVENT_SYSTEM_SWITCHEND
 */



/*
 * EVENT_SYSTEM_MINIMIZESTART
 * EVENT_SYSTEM_MINIMIZEEND
 * Sent when a window minimizes and just before it restores.
 */






#line 13879 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"
















#line 13896 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"















#line 13912 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"













#line 13926 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"










/*
 * Flags for EVENT_CONSOLE_START/END_APPLICATION.
 */




#line 13944 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"

/*
 * Flags for EVENT_CONSOLE_CARET
 */


#line 13951 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"



#line 13955 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"

/*
 * Object events
 *
 * The system AND apps generate these.  The system generates these for
 * real windows.  Apps generate these for objects within their window which
 * act like a separate control, e.g. an item in a list view.
 *
 * When the system generate them, dwParam2 is always WMOBJID_SELF.  When
 * apps generate them, apps put the has-meaning-to-the-app-only ID value
 * in dwParam2.
 * For all events, if you want detailed accessibility information, callers
 * should
 *      * Call AccessibleObjectFromWindow() with the hwnd, idObject parameters
 *          of the event, and IID_IAccessible as the REFIID, to get back an
 *          IAccessible* to talk to
 *      * Initialize and fill in a VARIANT as VT_I4 with lVal the idChild
 *          parameter of the event.
 *      * If idChild isn't zero, call get_accChild() in the container to see
 *          if the child is an object in its own right.  If so, you will get
 *          back an IDispatch* object for the child.  You should release the
 *          parent, and call QueryInterface() on the child object to get its
 *          IAccessible*.  Then you talk directly to the child.  Otherwise,
 *          if get_accChild() returns you nothing, you should continue to
 *          use the child VARIANT.  You will ask the container for the properties
 *          of the child identified by the VARIANT.  In other words, the
 *          child in this case is accessible but not a full-blown object.
 *          Like a button on a titlebar which is 'small' and has no children.
 */

/*
 * For all EVENT_OBJECT events,
 *      hwnd is the dude to Send the WM_GETOBJECT message to (unless NULL,
 *          see above for system things)
 *      idObject is the ID of the object that can resolve any queries a
 *          client might have.  It's a way to deal with windowless controls,
 *          controls that are just drawn on the screen in some larger parent
 *          window (like SDM), or standard frame elements of a window.
 *      idChild is the piece inside of the object that is affected.  This
 *          allows clients to access things that are too small to have full
 *          blown objects in their own right.  Like the thumb of a scrollbar.
 *          The hwnd/idObject pair gets you to the container, the dude you
 *          probably want to talk to most of the time anyway.  The idChild
 *          can then be passed into the acc properties to get the name/value
 *          of it as needed.
 *
 * Example #1:
 *      System propagating a listbox selection change
 *      EVENT_OBJECT_SELECTION
 *          hwnd == listbox hwnd
 *          idObject == OBJID_WINDOW
 *          idChild == new selected item, or CHILDID_SELF if
 *              nothing now selected within container.
 *      Word '97 propagating a listbox selection change
 *          hwnd == SDM window
 *          idObject == SDM ID to get at listbox 'control'
 *          idChild == new selected item, or CHILDID_SELF if
 *              nothing
 *
 * Example #2:
 *      System propagating a menu item selection on the menu bar
 *      EVENT_OBJECT_SELECTION
 *          hwnd == top level window
 *          idObject == OBJID_MENU
 *          idChild == ID of child menu bar item selected
 *
 * Example #3:
 *      System propagating a dropdown coming off of said menu bar item
 *      EVENT_OBJECT_CREATE
 *          hwnd == popup item
 *          idObject == OBJID_WINDOW
 *          idChild == CHILDID_SELF
 *
 * Example #4:
 *
 * For EVENT_OBJECT_REORDER, the object referred to by hwnd/idObject is the
 * PARENT container in which the zorder is occurring.  This is because if
 * one child is zordering, all of them are changing their relative zorder.
 */





/*
 * NOTE:
 * Minimize the number of notifications!
 *
 * When you are hiding a parent object, obviously all child objects are no
 * longer visible on screen.  They still have the same "visible" status,
 * but are not truly visible.  Hence do not send HIDE notifications for the
 * children also.  One implies all.  The same goes for SHOW.
 */








/*
 * NOTES:
 * There is only one "focused" child item in a parent.  This is the place
 * keystrokes are going at a given moment.  Hence only send a notification
 * about where the NEW focus is going.  A NEW item getting the focus already
 * implies that the OLD item is losing it.
 *
 * SELECTION however can be multiple.  Hence the different SELECTION
 * notifications.  Here's when to use each:
 *
 * (1) Send a SELECTION notification in the simple single selection
 *     case (like the focus) when the item with the selection is
 *     merely moving to a different item within a container.  hwnd + ID
 *     is the container control, idChildItem is the new child with the
 *     selection.
 *
 * (2) Send a SELECTIONADD notification when a new item has simply been added
 *     to the selection within a container.  This is appropriate when the
 *     number of newly selected items is very small.  hwnd + ID is the
 *     container control, idChildItem is the new child added to the selection.
 *
 * (3) Send a SELECTIONREMOVE notification when a new item has simply been
 *     removed from the selection within a container.  This is appropriate
 *     when the number of newly selected items is very small, just like
 *     SELECTIONADD.  hwnd + ID is the container control, idChildItem is the
 *     new child removed from the selection.
 *
 * (4) Send a SELECTIONWITHIN notification when the selected items within a
 *     control have changed substantially.  Rather than propagate a large
 *     number of changes to reflect removal for some items, addition of
 *     others, just tell somebody who cares that a lot happened.  It will
 *     be faster an easier for somebody watching to just turn around and
 *     query the container control what the new bunch of selected items
 *     are.
 */


/*
 * Examples of when to send an EVENT_OBJECT_STATECHANGE include
 *      * It is being enabled/disabled (USER does for windows)
 *      * It is being pressed/released (USER does for buttons)
 *      * It is being checked/unchecked (USER does for radio/check buttons)
 */


/*
 * Note:
 * A LOCATIONCHANGE is not sent for every child object when the parent
 * changes shape/moves.  Send one notification for the topmost object
 * that is changing.  For example, if the user resizes a top level window,
 * USER will generate a LOCATIONCHANGE for it, but not for the menu bar,
 * title bar, scrollbars, etc.  that are also changing shape/moving.
 *
 * In other words, it only generates LOCATIONCHANGE notifications for
 * real windows that are moving/sizing.  It will not generate a LOCATIONCHANGE
 * for every non-floating child window when the parent moves (the children are
 * logically moving also on screen, but not relative to the parent).
 *
 * Now, if the app itself resizes child windows as a result of being
 * sized, USER will generate LOCATIONCHANGEs for those dudes also because
 * it doesn't know better.
 *
 * Note also that USER will generate LOCATIONCHANGE notifications for two
 * non-window sys objects:
 *      (1) System caret
 *      (2) Cursor
 */













/*
 * EVENT_OBJECT_CONTENTSCROLLED
 * Sent when ending the scrolling of a window object.
 *
 * Unlike the similar event (EVENT_SYSTEM_SCROLLEND), this event will be
 * associated with the scrolling window itself. There is no difference
 * between horizontal or vertical scrolling.
 *
 * This event should be posted whenever scroll action is completed, including
 * when it is scrolled by scroll bars, mouse wheel, or keyboard navigations.
 *
 *   example:
 *          hwnd == window that is scrolling
 *          idObject == OBJID_CLIENT
 *          idChild == CHILDID_SELF
 */

#line 14154 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"



#line 14158 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"










































































#line 14233 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"






#line 14240 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"


/*
 * Child IDs
 */


/*
 * System Sounds (idChild of system SOUND notification)
 */


















/*
 * System Alerts (indexChild of system ALERT notification)
 */







#pragma region Desktop Family


typedef struct tagGUITHREADINFO
{
    DWORD   cbSize;
    DWORD   flags;
    HWND    hwndActive;
    HWND    hwndFocus;
    HWND    hwndCapture;
    HWND    hwndMenuOwner;
    HWND    hwndMoveSize;
    HWND    hwndCaret;
    RECT    rcCaret;
} GUITHREADINFO, *PGUITHREADINFO,  * LPGUITHREADINFO;

#line 14295 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"
#pragma endregion











#line 14308 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"
#line 14309 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"

#pragma region Desktop Family


__declspec(dllimport)
BOOL
__stdcall
GetGUIThreadInfo(
     DWORD idThread,
     PGUITHREADINFO pgui);

__declspec(dllimport)
BOOL
__stdcall
BlockInput(
    BOOL fBlockIt);





__declspec(dllimport)
BOOL
__stdcall
SetProcessDPIAware(
    void );

__declspec(dllimport)
BOOL
__stdcall
IsProcessDPIAware(
    void );

#line 14343 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"












































































#line 14420 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"








#line 14429 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"









#line 14439 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"




















#line 14460 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"


__declspec(dllimport)
UINT
__stdcall
GetWindowModuleFileNameA(
     HWND hwnd,
     LPSTR pszFileName,
     UINT cchFileNameMax);
__declspec(dllimport)
UINT
__stdcall
GetWindowModuleFileNameW(
     HWND hwnd,
     LPWSTR pszFileName,
     UINT cchFileNameMax);




#line 14481 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"

#line 14483 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"
#pragma endregion


































#line 14519 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"




#pragma region Desktop Family or Games Family


/*
 * Information about the global cursor.
 */
typedef struct tagCURSORINFO
{
    DWORD   cbSize;
    DWORD   flags;
    HCURSOR hCursor;
    POINT   ptScreenPos;
} CURSORINFO, *PCURSORINFO, *LPCURSORINFO;




#line 14541 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"

__declspec(dllimport)
BOOL
__stdcall
GetCursorInfo(
     PCURSORINFO pci);

#line 14549 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"
#pragma endregion

#pragma region Desktop Family


/*
 * Window information snapshot
 */
typedef struct tagWINDOWINFO
{
    DWORD cbSize;
    RECT rcWindow;
    RECT rcClient;
    DWORD dwStyle;
    DWORD dwExStyle;
    DWORD dwWindowStatus;
    UINT cxWindowBorders;
    UINT cyWindowBorders;
    ATOM atomWindowType;
    WORD wCreatorVersion;
} WINDOWINFO, *PWINDOWINFO, *LPWINDOWINFO;



__declspec(dllimport)
BOOL
__stdcall
GetWindowInfo(
     HWND hwnd,
     PWINDOWINFO pwi);

/*
 * Titlebar information.
 */
typedef struct tagTITLEBARINFO
{
    DWORD cbSize;
    RECT rcTitleBar;
    DWORD rgstate[5 + 1];
} TITLEBARINFO, *PTITLEBARINFO, *LPTITLEBARINFO;

__declspec(dllimport)
BOOL
__stdcall
GetTitleBarInfo(
     HWND hwnd,
     PTITLEBARINFO pti);


typedef struct tagTITLEBARINFOEX
{
    DWORD cbSize;
    RECT rcTitleBar;
    DWORD rgstate[5 + 1];
    RECT rgrect[5 + 1];
} TITLEBARINFOEX, *PTITLEBARINFOEX, *LPTITLEBARINFOEX;
#line 14606 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"

/*
 * Menubar information
 */
typedef struct tagMENUBARINFO
{
    DWORD cbSize;
    RECT rcBar;          // rect of bar, popup, item
    HMENU hMenu;         // real menu handle of bar, popup
    HWND hwndMenu;       // hwnd of item submenu if one
    BOOL fBarFocused:1;  // bar, popup has the focus
    BOOL fFocused:1;     // item has the focus
} MENUBARINFO, *PMENUBARINFO, *LPMENUBARINFO;

__declspec(dllimport)
BOOL
__stdcall
GetMenuBarInfo(
     HWND hwnd,
     LONG idObject,
     LONG idItem,
     PMENUBARINFO pmbi);

/*
 * Scrollbar information
 */
typedef struct tagSCROLLBARINFO
{
    DWORD cbSize;
    RECT rcScrollBar;
    int dxyLineButton;
    int xyThumbTop;
    int xyThumbBottom;
    int reserved;
    DWORD rgstate[5 + 1];
} SCROLLBARINFO, *PSCROLLBARINFO, *LPSCROLLBARINFO;

__declspec(dllimport)
BOOL
__stdcall
GetScrollBarInfo(
     HWND hwnd,
     LONG idObject,
     PSCROLLBARINFO psbi);

/*
 * Combobox information
 */
typedef struct tagCOMBOBOXINFO
{
    DWORD cbSize;
    RECT rcItem;
    RECT rcButton;
    DWORD stateButton;
    HWND hwndCombo;
    HWND hwndItem;
    HWND hwndList;
} COMBOBOXINFO, *PCOMBOBOXINFO, *LPCOMBOBOXINFO;

__declspec(dllimport)
BOOL
__stdcall
GetComboBoxInfo(
     HWND hwndCombo,
     PCOMBOBOXINFO pcbi);

#line 14673 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"
#pragma endregion

/*
 * The "real" ancestor window
 */




#pragma region Desktop Family


__declspec(dllimport)
HWND
__stdcall
GetAncestor(
     HWND hwnd,
     UINT gaFlags);


/*
 * This gets the REAL child window at the point.  If it is in the dead
 * space of a group box, it will try a sibling behind it.  But static
 * fields will get returned.  In other words, it is kind of a cross between
 * ChildWindowFromPointEx and WindowFromPoint.
 */
__declspec(dllimport)
HWND
__stdcall
RealChildWindowFromPoint(
     HWND hwndParent,
     POINT ptParentClientCoords);


/*
 * This gets the name of the window TYPE, not class.  This allows us to
 * recognize ThunderButton32 et al.
 */
__declspec(dllimport)
UINT
__stdcall
RealGetWindowClassA(
     HWND hwnd,
     LPSTR ptszClassName,
     UINT cchClassNameMax);
/*
 * This gets the name of the window TYPE, not class.  This allows us to
 * recognize ThunderButton32 et al.
 */
__declspec(dllimport)
UINT
__stdcall
RealGetWindowClassW(
     HWND hwnd,
     LPWSTR ptszClassName,
     UINT cchClassNameMax);




#line 14734 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"

/*
 * Alt-Tab Switch window information.
 */
typedef struct tagALTTABINFO
{
    DWORD cbSize;
    int cItems;
    int cColumns;
    int cRows;
    int iColFocus;
    int iRowFocus;
    int cxItem;
    int cyItem;
    POINT ptStart;
} ALTTABINFO, *PALTTABINFO, *LPALTTABINFO;

__declspec(dllimport)
BOOL
__stdcall
GetAltTabInfoA(
     HWND hwnd,
     int iItem,
     PALTTABINFO pati,
     LPSTR pszItemText,
     UINT cchItemText);
__declspec(dllimport)
BOOL
__stdcall
GetAltTabInfoW(
     HWND hwnd,
     int iItem,
     PALTTABINFO pati,
     LPWSTR pszItemText,
     UINT cchItemText);




#line 14774 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"

/*
 * Listbox information.
 * Returns the number of items per row.
 */
__declspec(dllimport)
DWORD
__stdcall
GetListBoxInfo(
     HWND hwnd);

#line 14786 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"
#pragma endregion

#line 14789 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"
#line 14790 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"

#pragma region Desktop Family




__declspec(dllimport)
BOOL
__stdcall
LockWorkStation(
    void );
#line 14802 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"



__declspec(dllimport)
BOOL
__stdcall
UserHandleGrantAccess(
     HANDLE hUserHandle,
     HANDLE hJob,
     BOOL   bGrant);

#line 14814 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"

#line 14816 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"
#pragma endregion



/*
 * Raw Input Messages.
 */

#pragma region Desktop Family


struct HRAWINPUT__{int unused;}; typedef struct HRAWINPUT__ *HRAWINPUT ;

#line 14830 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"
#pragma endregion

/*
 * WM_INPUT wParam
 */

/*
 * Use this macro to get the input code from wParam.
 */


/*
 * The input is in the regular message flow,
 * the app is required to call DefWindowProc
 * so that the system can perform clean ups.
 */


/*
 * The input is sink only. The app is expected
 * to behave nicely.
 */


#pragma region Desktop Family


/*
 * Raw Input data header
 */
typedef struct tagRAWINPUTHEADER {
    DWORD dwType;
    DWORD dwSize;
    HANDLE hDevice;
    WPARAM wParam;
} RAWINPUTHEADER, *PRAWINPUTHEADER, *LPRAWINPUTHEADER;

#line 14868 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"
#pragma endregion

/*
 * Type of the raw input
 */





#pragma region Desktop Family


//Disable warning C4201:nameless struct/union

#pragma warning(push)
#line 14885 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"
#pragma warning(disable : 4201)

/*
 * Raw format of the mouse input
 */
typedef struct tagRAWMOUSE {
    /*
     * Indicator flags.
     */
    USHORT usFlags;

    /*
     * The transition state of the mouse buttons.
     */
    union {
        ULONG ulButtons;
        struct  {
            USHORT  usButtonFlags;
            USHORT  usButtonData;
        }  ;
    }  ;


    /*
     * The raw state of the mouse buttons.
     */
    ULONG ulRawButtons;

    /*
     * The signed relative or absolute motion in the X direction.
     */
    LONG lLastX;

    /*
     * The signed relative or absolute motion in the Y direction.
     */
    LONG lLastY;

    /*
     * Device-specific additional information for the event.
     */
    ULONG ulExtraInformation;

} RAWMOUSE, *PRAWMOUSE, *LPRAWMOUSE;


#pragma warning(pop)
#line 14933 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"

#line 14935 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"
#pragma endregion

/*
 * Define the mouse button state indicators.
 */




















/*
 * If usButtonFlags has RI_MOUSE_WHEEL, the wheel delta is stored in usButtonData.
 * Take it as a signed value.
 */



#line 14968 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"

/*
 * Define the mouse indicator flags.
 */






#line 14979 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"

#pragma region Desktop Family


/*
 * Raw format of the keyboard input
 */
typedef struct tagRAWKEYBOARD {
    /*
     * The "make" scan code (key depression).
     */
    USHORT MakeCode;

    /*
     * The flags field indicates a "break" (key release) and other
     * miscellaneous scan code information defined in ntddkbd.h.
     */
    USHORT Flags;

    USHORT Reserved;

    /*
     * Windows message compatible information
     */
    USHORT VKey;
    UINT   Message;

    /*
     * Device-specific additional information for the event.
     */
    ULONG ExtraInformation;


} RAWKEYBOARD, *PRAWKEYBOARD, *LPRAWKEYBOARD;

#line 15015 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"
#pragma endregion

/*
 * Define the keyboard overrun MakeCode.
 */



/*
 * Define the keyboard input data Flags.
 */







#pragma region Desktop Family


/*
 * Raw format of the input from Human Input Devices
 */
typedef struct tagRAWHID {
    DWORD dwSizeHid;    // byte size of each report
    DWORD dwCount;      // number of input packed
    BYTE bRawData[1];
} RAWHID, *PRAWHID, *LPRAWHID;

#line 15046 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"
#pragma endregion

/*
 * RAWINPUT data structure.
 */

#pragma region Desktop Family


typedef struct tagRAWINPUT {
    RAWINPUTHEADER header;
    union {
        RAWMOUSE    mouse;
        RAWKEYBOARD keyboard;
        RAWHID      hid;
    } data;
} RAWINPUT, *PRAWINPUT, *LPRAWINPUT;

#line 15065 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"
#pragma endregion





#line 15072 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"



/*
 * Flags for GetRawInputData
 */




#pragma region Desktop Family


__declspec(dllimport)
UINT
__stdcall
GetRawInputData(
     HRAWINPUT hRawInput,
     UINT uiCommand,
     LPVOID pData,
     PUINT pcbSize,
     UINT cbSizeHeader);

#line 15096 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"
#pragma endregion

/*
 * Raw Input Device Information
 */




#pragma region Desktop Family


typedef struct tagRID_DEVICE_INFO_MOUSE {
    DWORD dwId;
    DWORD dwNumberOfButtons;
    DWORD dwSampleRate;
    BOOL  fHasHorizontalWheel;
} RID_DEVICE_INFO_MOUSE, *PRID_DEVICE_INFO_MOUSE;

typedef struct tagRID_DEVICE_INFO_KEYBOARD {
    DWORD dwType;
    DWORD dwSubType;
    DWORD dwKeyboardMode;
    DWORD dwNumberOfFunctionKeys;
    DWORD dwNumberOfIndicators;
    DWORD dwNumberOfKeysTotal;
} RID_DEVICE_INFO_KEYBOARD, *PRID_DEVICE_INFO_KEYBOARD;

typedef struct tagRID_DEVICE_INFO_HID {
    DWORD dwVendorId;
    DWORD dwProductId;
    DWORD dwVersionNumber;

    /*
     * Top level collection UsagePage and Usage
     */
    USHORT usUsagePage;
    USHORT usUsage;
} RID_DEVICE_INFO_HID, *PRID_DEVICE_INFO_HID;

typedef struct tagRID_DEVICE_INFO {
    DWORD cbSize;
    DWORD dwType;
    union {
        RID_DEVICE_INFO_MOUSE mouse;
        RID_DEVICE_INFO_KEYBOARD keyboard;
        RID_DEVICE_INFO_HID hid;
    }  ;
} RID_DEVICE_INFO, *PRID_DEVICE_INFO, *LPRID_DEVICE_INFO;

__declspec(dllimport)
UINT
__stdcall
GetRawInputDeviceInfoA(
     HANDLE hDevice,
     UINT uiCommand,
     LPVOID pData,
     PUINT pcbSize);
__declspec(dllimport)
UINT
__stdcall
GetRawInputDeviceInfoW(
     HANDLE hDevice,
     UINT uiCommand,
     LPVOID pData,
     PUINT pcbSize);




#line 15167 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"


/*
 * Raw Input Bulk Read: GetRawInputBuffer
 */
__declspec(dllimport)
UINT
__stdcall
GetRawInputBuffer(
     PRAWINPUT pData,
     PUINT pcbSize,
     UINT cbSizeHeader);

/*
 * Raw Input request APIs
 */
typedef struct tagRAWINPUTDEVICE {
    USHORT usUsagePage; // Toplevel collection UsagePage
    USHORT usUsage;     // Toplevel collection Usage
    DWORD dwFlags;
    HWND hwndTarget;    // Target hwnd. NULL = follows keyboard focus
} RAWINPUTDEVICE, *PRAWINPUTDEVICE, *LPRAWINPUTDEVICE;

typedef const RAWINPUTDEVICE* PCRAWINPUTDEVICE;

#line 15193 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"
#pragma endregion












#line 15207 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"





/*
 * Flags for the WM_INPUT_DEVICE_CHANGE message.
 */


#line 15218 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"





#line 15224 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"

#pragma region Desktop Family


__declspec(dllimport)
BOOL
__stdcall
RegisterRawInputDevices(
     PCRAWINPUTDEVICE pRawInputDevices,
     UINT uiNumDevices,
     UINT cbSize);

__declspec(dllimport)
UINT
__stdcall
GetRegisteredRawInputDevices(
     PRAWINPUTDEVICE pRawInputDevices,
     PUINT puiNumDevices,
     UINT cbSize);


typedef struct tagRAWINPUTDEVICELIST {
    HANDLE hDevice;
    DWORD dwType;
} RAWINPUTDEVICELIST, *PRAWINPUTDEVICELIST;

__declspec(dllimport)
UINT
__stdcall
GetRawInputDeviceList(
     PRAWINPUTDEVICELIST pRawInputDeviceList,
     PUINT puiNumDevices,
     UINT cbSize);

__declspec(dllimport)
LRESULT
__stdcall
DefRawInputProc(
     PRAWINPUT* paRawInput,
     INT nInput,
     UINT cbSizeHeader);

#line 15267 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"
#pragma endregion

#line 15270 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"






























































































































#line 15397 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"




/*
 * Message Filter
 */




#pragma region Desktop Family


__declspec(dllimport)
BOOL
__stdcall
ChangeWindowMessageFilter(
     UINT message,
     DWORD dwFlag);

#line 15419 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"
#pragma endregion

#line 15422 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"



/*
 * Message filter info values (CHANGEFILTERSTRUCT.ExtStatus)
 */





#pragma region Desktop Family


typedef struct tagCHANGEFILTERSTRUCT {
    DWORD cbSize;
    DWORD ExtStatus;
} CHANGEFILTERSTRUCT, *PCHANGEFILTERSTRUCT;

#line 15442 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"
#pragma endregion

/*
 * Message filter action values (action parameter to ChangeWindowMessageFilterEx)
 */




#pragma region Desktop Family


__declspec(dllimport)
BOOL
__stdcall
ChangeWindowMessageFilterEx(
     HWND hwnd,                                         // Window
     UINT message,                                      // WM_ message
     DWORD action,                                      // Message filter action value
     PCHANGEFILTERSTRUCT pChangeFilterStruct);   // Optional

#line 15464 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"
#pragma endregion

#line 15467 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"


#line 15470 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"



/*
 * Gesture defines and functions
 */

#pragma region Desktop Family


/*
 * Gesture information handle
 */
struct HGESTUREINFO__{int unused;}; typedef struct HGESTUREINFO__ *HGESTUREINFO ;

#line 15486 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"
#pragma endregion

/*
 * Gesture flags - GESTUREINFO.dwFlags
 */




/*
 * Gesture IDs
 */









#pragma region Desktop Family


/*
 * Gesture information structure
 *   - Pass the HGESTUREINFO received in the WM_GESTURE message lParam into the
 *     GetGestureInfo function to retrieve this information.
 *   - If cbExtraArgs is non-zero, pass the HGESTUREINFO received in the WM_GESTURE
 *     message lParam into the GetGestureExtraArgs function to retrieve extended
 *     argument information.
 */
typedef struct tagGESTUREINFO {
    UINT cbSize;                    // size, in bytes, of this structure (including variable length Args field)
    DWORD dwFlags;                  // see GF_* flags
    DWORD dwID;                     // gesture ID, see GID_* defines
    HWND hwndTarget;                // handle to window targeted by this gesture
    POINTS ptsLocation;             // current location of this gesture
    DWORD dwInstanceID;             // internally used
    DWORD dwSequenceID;             // internally used
    ULONGLONG ullArguments;         // arguments for gestures whose arguments fit in 8 BYTES
    UINT cbExtraArgs;               // size, in bytes, of extra arguments, if any, that accompany this gesture
} GESTUREINFO, *PGESTUREINFO;
typedef GESTUREINFO const * PCGESTUREINFO;


/*
 * Gesture notification structure
 *   - The WM_GESTURENOTIFY message lParam contains a pointer to this structure.
 *   - The WM_GESTURENOTIFY message notifies a window that gesture recognition is
 *     in progress and a gesture will be generated if one is recognized under the
 *     current gesture settings.
 */
typedef struct tagGESTURENOTIFYSTRUCT {
    UINT cbSize;                    // size, in bytes, of this structure
    DWORD dwFlags;                  // unused
    HWND hwndTarget;                // handle to window targeted by the gesture
    POINTS ptsLocation;             // starting location
    DWORD dwInstanceID;             // internally used
} GESTURENOTIFYSTRUCT, *PGESTURENOTIFYSTRUCT;

/*
 * Gesture argument helpers
 *   - Angle should be a double in the range of -2pi to +2pi
 *   - Argument should be an unsigned 16-bit value
 */



/*
 * Gesture information retrieval
 *   - HGESTUREINFO is received by a window in the lParam of a WM_GESTURE message.
 */
__declspec(dllimport)
BOOL
__stdcall
GetGestureInfo(
     HGESTUREINFO hGestureInfo,
     PGESTUREINFO pGestureInfo);

/*
 * Gesture extra arguments retrieval
 *   - HGESTUREINFO is received by a window in the lParam of a WM_GESTURE message.
 *   - Size, in bytes, of the extra argument data is available in the cbExtraArgs
 *     field of the GESTUREINFO structure retrieved using the GetGestureInfo function.
 */
__declspec(dllimport)
BOOL
__stdcall
GetGestureExtraArgs(
     HGESTUREINFO hGestureInfo,
     UINT cbExtraArgs,
     PBYTE pExtraArgs);

/*
 * Gesture information handle management
 *   - If an application processes the WM_GESTURE message, then once it is done
 *     with the associated HGESTUREINFO, the application is responsible for
 *     closing the handle using this function. Failure to do so may result in
 *     process memory leaks.
 *   - If the message is instead passed to DefWindowProc, or is forwarded using
 *     one of the PostMessage or SendMessage class of API functions, the handle
 *     is transfered with the message and need not be closed by the application.
 */
__declspec(dllimport)
BOOL
__stdcall
CloseGestureInfoHandle(
     HGESTUREINFO hGestureInfo);


/*
 * Gesture configuration structure
 *   - Used in SetGestureConfig and GetGestureConfig
 *   - Note that any setting not included in either GESTURECONFIG.dwWant or
 *     GESTURECONFIG.dwBlock will use the parent window's preferences or
 *     system defaults.
 */
typedef struct tagGESTURECONFIG {
    DWORD dwID;                     // gesture ID
    DWORD dwWant;                   // settings related to gesture ID that are to be turned on
    DWORD dwBlock;                  // settings related to gesture ID that are to be turned off
} GESTURECONFIG, *PGESTURECONFIG;

#line 15611 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"
#pragma endregion

/*
 * Gesture configuration flags - GESTURECONFIG.dwWant or GESTURECONFIG.dwBlock
 */

/*
 * Common gesture configuration flags - set GESTURECONFIG.dwID to zero
 */


/*
 * Zoom gesture configuration flags - set GESTURECONFIG.dwID to GID_ZOOM
 */


/*
 * Pan gesture configuration flags - set GESTURECONFIG.dwID to GID_PAN
 */






/*
 * Rotate gesture configuration flags - set GESTURECONFIG.dwID to GID_ROTATE
 */


/*
 * Two finger tap gesture configuration flags - set GESTURECONFIG.dwID to GID_TWOFINGERTAP
 */


/*
 * PressAndTap gesture configuration flags - set GESTURECONFIG.dwID to GID_PRESSANDTAP
 */




                                                        // in a single call to SetGestureConfig / GetGestureConfig

#pragma region Desktop Family


__declspec(dllimport)
BOOL
__stdcall
SetGestureConfig(
     HWND hwnd,                                     // window for which configuration is specified
     DWORD dwReserved,                              // reserved, must be 0
     UINT cIDs,                                     // count of GESTURECONFIG structures
     PGESTURECONFIG pGestureConfig,    // array of GESTURECONFIG structures, dwIDs will be processed in the
                                                        // order specified and repeated occurances will overwrite previous ones
     UINT cbSize);                                  // sizeof(GESTURECONFIG)



                                                        // for the specified window and it's parent window chain

__declspec(dllimport)
BOOL
__stdcall
GetGestureConfig(
     HWND hwnd,                                     // window for which configuration is required
     DWORD dwReserved,                              // reserved, must be 0
     DWORD dwFlags,                                 // see GCF_* flags
     PUINT pcIDs,                                   // *pcIDs contains the size, in number of GESTURECONFIG structures,
                                                        // of the buffer pointed to by pGestureConfig
     PGESTURECONFIG pGestureConfig,
                                                        // pointer to buffer to receive the returned array of GESTURECONFIG structures
     UINT cbSize);                                  // sizeof(GESTURECONFIG)

#line 15687 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"
#pragma endregion


#line 15691 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"




/*
 * GetSystemMetrics(SM_DIGITIZER) flag values
 */







#line 15706 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"




#pragma region Desktop Family


__declspec(dllimport)
BOOL
__stdcall
ShutdownBlockReasonCreate(
     HWND hWnd,
     LPCWSTR pwszReason);

__declspec(dllimport)
BOOL
__stdcall
ShutdownBlockReasonQuery(
     HWND hWnd,
     LPWSTR pwszBuff,
     DWORD *pcchBuff);

__declspec(dllimport)
BOOL
__stdcall
ShutdownBlockReasonDestroy(
     HWND hWnd);

#line 15735 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"
#pragma endregion




#pragma region Desktop Family


/*
 * Identifiers for message input source device type.
 */
typedef enum tagINPUT_MESSAGE_DEVICE_TYPE  {
    IMDT_UNAVAILABLE        = 0x00000000,       // not specified
    IMDT_KEYBOARD           = 0x00000001,       // from keyboard
    IMDT_MOUSE              = 0x00000002,       // from mouse
    IMDT_TOUCH              = 0x00000004,       // from touch
    IMDT_PEN                = 0x00000008,       // from pen


#line 15755 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"
 } INPUT_MESSAGE_DEVICE_TYPE;

typedef enum tagINPUT_MESSAGE_ORIGIN_ID {
     IMO_UNAVAILABLE = 0x00000000,  // not specified
     IMO_HARDWARE    = 0x00000001,  // from a hardware device or injected by a UIAccess app
     IMO_INJECTED    = 0x00000002,  // injected via SendInput() by a non-UIAccess app
     IMO_SYSTEM      = 0x00000004,  // injected by the system
} INPUT_MESSAGE_ORIGIN_ID;

/*
 * Input source structure.
 */
 typedef struct tagINPUT_MESSAGE_SOURCE {
     INPUT_MESSAGE_DEVICE_TYPE deviceType;
     INPUT_MESSAGE_ORIGIN_ID   originId;
 } INPUT_MESSAGE_SOURCE;


/*
 * API to determine the input source of the current messsage.
 */
__declspec(dllimport)
BOOL
__stdcall
GetCurrentInputMessageSource(
     INPUT_MESSAGE_SOURCE *inputMessageSource);

__declspec(dllimport)
BOOL
__stdcall
GetCIMSSM(
     INPUT_MESSAGE_SOURCE *inputMessageSource);

#line 15789 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"
#pragma endregion

#line 15792 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"



#pragma region Application Family or OneCore Family or Games Family


/*
 * AutoRotation state structure
 */
typedef enum tagAR_STATE {
    AR_ENABLED        = 0x0,
    AR_DISABLED       = 0x1,
    AR_SUPPRESSED     = 0x2,
    AR_REMOTESESSION  = 0x4,
    AR_MULTIMON       = 0x8,
    AR_NOSENSOR       = 0x10,
    AR_NOT_SUPPORTED  = 0x20,
    AR_DOCKED         = 0x40,
    AR_LAPTOP         = 0x80
} AR_STATE, *PAR_STATE;

#line 15814 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"
#pragma endregion


// Don't define this for MIDL compiler passes over winuser.h. Some of them
// don't include winnt.h (where DEFINE_ENUM_FLAG_OPERATORS is defined and
// get compile errors.
extern "C++" { inline constexpr AR_STATE operator | (AR_STATE a, AR_STATE b) throw() { return AR_STATE(((_ENUM_FLAG_SIZED_INTEGER<AR_STATE>::type)a) | ((_ENUM_FLAG_SIZED_INTEGER<AR_STATE>::type)b)); } inline AR_STATE &operator |= (AR_STATE &a, AR_STATE b) throw() { return (AR_STATE &)(((_ENUM_FLAG_SIZED_INTEGER<AR_STATE>::type &)a) |= ((_ENUM_FLAG_SIZED_INTEGER<AR_STATE>::type)b)); } inline constexpr AR_STATE operator & (AR_STATE a, AR_STATE b) throw() { return AR_STATE(((_ENUM_FLAG_SIZED_INTEGER<AR_STATE>::type)a) & ((_ENUM_FLAG_SIZED_INTEGER<AR_STATE>::type)b)); } inline AR_STATE &operator &= (AR_STATE &a, AR_STATE b) throw() { return (AR_STATE &)(((_ENUM_FLAG_SIZED_INTEGER<AR_STATE>::type &)a) &= ((_ENUM_FLAG_SIZED_INTEGER<AR_STATE>::type)b)); } inline constexpr AR_STATE operator ~ (AR_STATE a) throw() { return AR_STATE(~((_ENUM_FLAG_SIZED_INTEGER<AR_STATE>::type)a)); } inline constexpr AR_STATE operator ^ (AR_STATE a, AR_STATE b) throw() { return AR_STATE(((_ENUM_FLAG_SIZED_INTEGER<AR_STATE>::type)a) ^ ((_ENUM_FLAG_SIZED_INTEGER<AR_STATE>::type)b)); } inline AR_STATE &operator ^= (AR_STATE &a, AR_STATE b) throw() { return (AR_STATE &)(((_ENUM_FLAG_SIZED_INTEGER<AR_STATE>::type &)a) ^= ((_ENUM_FLAG_SIZED_INTEGER<AR_STATE>::type)b)); } }
#line 15822 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"

#pragma region Desktop Family


/*
 * Orientation preference structure. This is used by applications to specify
 * their orientation preferences to windows.
 */
typedef enum ORIENTATION_PREFERENCE {
    ORIENTATION_PREFERENCE_NONE              = 0x0,
    ORIENTATION_PREFERENCE_LANDSCAPE         = 0x1,
    ORIENTATION_PREFERENCE_PORTRAIT          = 0x2,
    ORIENTATION_PREFERENCE_LANDSCAPE_FLIPPED = 0x4,
    ORIENTATION_PREFERENCE_PORTRAIT_FLIPPED  = 0x8
} ORIENTATION_PREFERENCE;



// Don't define this for MIDL compiler passes over winuser.h. Some of them
// don't include winnt.h (where DEFINE_ENUM_FLAG_OPERATORS is defined and
// get compile errors.
extern "C++" { inline constexpr ORIENTATION_PREFERENCE operator | (ORIENTATION_PREFERENCE a, ORIENTATION_PREFERENCE b) throw() { return ORIENTATION_PREFERENCE(((_ENUM_FLAG_SIZED_INTEGER<ORIENTATION_PREFERENCE>::type)a) | ((_ENUM_FLAG_SIZED_INTEGER<ORIENTATION_PREFERENCE>::type)b)); } inline ORIENTATION_PREFERENCE &operator |= (ORIENTATION_PREFERENCE &a, ORIENTATION_PREFERENCE b) throw() { return (ORIENTATION_PREFERENCE &)(((_ENUM_FLAG_SIZED_INTEGER<ORIENTATION_PREFERENCE>::type &)a) |= ((_ENUM_FLAG_SIZED_INTEGER<ORIENTATION_PREFERENCE>::type)b)); } inline constexpr ORIENTATION_PREFERENCE operator & (ORIENTATION_PREFERENCE a, ORIENTATION_PREFERENCE b) throw() { return ORIENTATION_PREFERENCE(((_ENUM_FLAG_SIZED_INTEGER<ORIENTATION_PREFERENCE>::type)a) & ((_ENUM_FLAG_SIZED_INTEGER<ORIENTATION_PREFERENCE>::type)b)); } inline ORIENTATION_PREFERENCE &operator &= (ORIENTATION_PREFERENCE &a, ORIENTATION_PREFERENCE b) throw() { return (ORIENTATION_PREFERENCE &)(((_ENUM_FLAG_SIZED_INTEGER<ORIENTATION_PREFERENCE>::type &)a) &= ((_ENUM_FLAG_SIZED_INTEGER<ORIENTATION_PREFERENCE>::type)b)); } inline constexpr ORIENTATION_PREFERENCE operator ~ (ORIENTATION_PREFERENCE a) throw() { return ORIENTATION_PREFERENCE(~((_ENUM_FLAG_SIZED_INTEGER<ORIENTATION_PREFERENCE>::type)a)); } inline constexpr ORIENTATION_PREFERENCE operator ^ (ORIENTATION_PREFERENCE a, ORIENTATION_PREFERENCE b) throw() { return ORIENTATION_PREFERENCE(((_ENUM_FLAG_SIZED_INTEGER<ORIENTATION_PREFERENCE>::type)a) ^ ((_ENUM_FLAG_SIZED_INTEGER<ORIENTATION_PREFERENCE>::type)b)); } inline ORIENTATION_PREFERENCE &operator ^= (ORIENTATION_PREFERENCE &a, ORIENTATION_PREFERENCE b) throw() { return (ORIENTATION_PREFERENCE &)(((_ENUM_FLAG_SIZED_INTEGER<ORIENTATION_PREFERENCE>::type &)a) ^= ((_ENUM_FLAG_SIZED_INTEGER<ORIENTATION_PREFERENCE>::type)b)); } }
#line 15845 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"

__declspec(dllimport)
BOOL
__stdcall
GetAutoRotationState(
     PAR_STATE pState);

__declspec(dllimport)
BOOL
__stdcall
GetDisplayAutoRotationPreferences(
     ORIENTATION_PREFERENCE *pOrientation);

__declspec(dllimport)
BOOL
__stdcall
GetDisplayAutoRotationPreferencesByProcessId(
     DWORD dwProcessId,
     ORIENTATION_PREFERENCE *pOrientation,
     BOOL *fRotateScreen);

__declspec(dllimport)
BOOL
__stdcall
SetDisplayAutoRotationPreferences(
     ORIENTATION_PREFERENCE orientation);

#line 15873 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"
#pragma endregion

#line 15876 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"



#pragma region Desktop Family



__declspec(dllimport)
BOOL
__stdcall
IsImmersiveProcess(
     HANDLE hProcess);

__declspec(dllimport)
BOOL
__stdcall
SetProcessRestrictionExemption(
     BOOL fEnableExemption);

#line 15896 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"
#pragma endregion

#line 15899 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"


#pragma region Desktop Family



#line 15906 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"


/*
 * Ink Feedback APIs
 */


#pragma warning(pop)
#line 15915 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"





#line 15921 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"
#line 15922 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"


}
#line 15926 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"

#line 15928 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winuser.h"



#line 175 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\Windows.h"

#line 1 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winnls.h"
/*++

Copyright (c) Microsoft Corporation  All rights reserved.

Module Name:

    winnls.h

Abstract:

    Procedure declarations, constant definitions, and macros for the
    NLS component.

--*/









extern "C" {
#line 26 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winnls.h"




#line 1 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\datetimeapi.h"
/********************************************************************************
*                                                                               *
* datetimeapi.h -- ApiSet Contract for api-ms-win-core-datetime-l1              *  
*                                                                               *
* Copyright (c) Microsoft Corporation. All rights reserved.                     *
*                                                                               *
********************************************************************************/


#pragma once
#line 12 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\datetimeapi.h"










extern "C" {
#line 24 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\datetimeapi.h"

#pragma region Desktop Family or OneCore or Games Family


// For Windows Vista and above GetDateFormatEx is preferred
__declspec(dllimport)
int
__stdcall
GetDateFormatA(
     LCID Locale,
     DWORD dwFlags,
     const SYSTEMTIME* lpDate,
     LPCSTR lpFormat,
     LPSTR lpDateStr,
     int cchDate
    );

__declspec(dllimport)
int
__stdcall
GetDateFormatW(
     LCID Locale,
     DWORD dwFlags,
     const SYSTEMTIME* lpDate,
     LPCWSTR lpFormat,
     LPWSTR lpDateStr,
     int cchDate
    );





#line 58 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\datetimeapi.h"

// For Windows Vista and above GetTimeFormatEx is preferred
__declspec(dllimport)
int
__stdcall
GetTimeFormatA(
     LCID Locale,
     DWORD dwFlags,
     const SYSTEMTIME* lpTime,
     LPCSTR lpFormat,
     LPSTR lpTimeStr,
     int cchTime
    );

__declspec(dllimport)
int
__stdcall
GetTimeFormatW(
     LCID Locale,
     DWORD dwFlags,
     const SYSTEMTIME* lpTime,
     LPCWSTR lpFormat,
     LPWSTR lpTimeStr,
     int cchTime
    );





#line 89 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\datetimeapi.h"

#line 91 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\datetimeapi.h"
#pragma endregion

#pragma region Application Family or OneCore or Games Family


__declspec(dllimport)
int
__stdcall
GetTimeFormatEx(
     LPCWSTR lpLocaleName,
     DWORD dwFlags,
     const SYSTEMTIME* lpTime,
     LPCWSTR lpFormat,
     LPWSTR lpTimeStr,
     int cchTime
    );


__declspec(dllimport)
int
__stdcall
GetDateFormatEx(
     LPCWSTR lpLocaleName,
     DWORD dwFlags,
     const SYSTEMTIME* lpDate,
     LPCWSTR lpFormat,
     LPWSTR lpDateStr,
     int cchDate,
     LPCWSTR lpCalendar
    );


#line 124 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\datetimeapi.h"
#pragma endregion

#pragma region Desktop Family or OneCore Family




__declspec(dllimport)
int
__stdcall
GetDurationFormatEx(
     LPCWSTR lpLocaleName,
     DWORD dwFlags,
     const SYSTEMTIME* lpDuration,
     ULONGLONG ullDuration,
     LPCWSTR lpFormat,
     LPWSTR lpDurationStr,
     int cchDuration
    );


#line 146 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\datetimeapi.h"
#pragma endregion


}
#line 151 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\datetimeapi.h"

#line 153 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\datetimeapi.h"

#line 31 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winnls.h"

#line 33 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winnls.h"



#pragma warning(push)
#pragma warning(disable:4820) 
#line 39 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winnls.h"

//
// Deprecated attribute support for NLS
//



// Disable NLS deprecation for the moment


#line 50 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winnls.h"

// Deprecated NLS types/functions
















#line 69 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winnls.h"

#line 71 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winnls.h"




#pragma region Application Family or OneCore or Games Family










#line 87 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winnls.h"



////////////////////////////////////////////////////////////////////////////
//
//  Constants
//
//  Define all constants for the NLS component here.
//
////////////////////////////////////////////////////////////////////////////

//
//  String Length Maximums.
//



//
//  Surrogate pairs
//
//  Conversion examples:
//
//  A) The first character in the Surrogate range (D800, DC00) as UTF-32:
//
//  1.  D800: binary 1101100000000000  (lower ten bits: 0000000000)
//  2.  DC00: binary 1101110000000000  (lower ten bits: 0000000000)
//  3.  Concatenate 0000000000+0000000000 = 0x0000
//  4.  Add 0x10000
//
//  Result: U+10000. This is correct, since the first character in the Supplementary character
//  range immediately follows the last code point in the 16-bit UTF-16 range (U+FFFF)
//
//  B) A UTF-32 code point such as U+2040A (this a CJK character in CJK Extension B), and wish
//  to convert it in UTF-16:
//
//  1.  Subtract 0x10000 - Result: 0x1040A
//  2.  Split into two ten-bit pieces: 0001000001 0000001010
//  3.  Add 1101100000000000 (0xD800) to the high 10 bits piece (0001000001) - Result: 1101100001000001 (0xD841)
//  4.  Add 1101110000000000 (0xDC00) to the low 10 bits piece (0000001010) - Result: 1101110000001010 (0xDC0A)
//
//  RESULT: The surrogate pair: U+D841, U+DC0A
//
//  Special Unicode code point values, for use with UTF-16 surrogate pairs.
//






//
//  MBCS and Unicode Translation Flags.
//  Please use Unicode, either UTF-16 (WCHAR) or UTF-8 (CP_UTF8)
//
// MB_PRECOMPOSED and MB_COMPOSITE are deprecated, not recommended, and
// provide out-of-date behavior.
// Windows typically uses Unicode Normalization Form C type sequences,
// If explicit normalization forms are required, please use NormalizeString.





// WC_COMPOSITECHECK, WC_DISCARDNS and WC_SEPCHARS are deprecated, not recommended,
// and provide out-of-date behavior.
// Windows typically uses Unicode Normalization Form C type sequences,
// If explicit normalization forms are required, please use NormalizeString.






#line 161 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winnls.h"



#line 165 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winnls.h"


//
//  Character Type Flags.
//




//
//  CType 1 Flag Bits.
//











//
//  CType 2 Flag Bits.
//
















//
//  CType 3 Flag Bits.
//




















//
//  String Flags.
//












//
//  Locale Independent Mapping Flags.
//







#line 256 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winnls.h"

//
//  Locale Dependent Mapping Flags.
//




#line 265 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winnls.h"


















#line 284 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winnls.h"

//
//  Search Flags
//






//
// ** DEPRECATED ** DEPRECATED ** DEPRECATED ** DEPRECATED ** DEPRECATED **
//
// Language Group Enumeration Flags.
//
// The "Language Group" concept is an obsolete concept.
// The groups returned are not well defined, arbitrary, inconsistent, inaccurate,
// no longer maintained, and no longer supported.
//
// ** DEPRECATED ** DEPRECATED ** DEPRECATED ** DEPRECATED ** DEPRECATED **
//




//
//  Locale Enumeration Flags.
//






//
//  Named based enumeration flags.
//





#line 327 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winnls.h"



#line 331 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winnls.h"


//
//  Code Page Enumeration Flags.
//




//
//  Sorting Flags.
//
//    WORD Sort:    culturally correct sort
//                  hyphen and apostrophe are special cased
//                  example: "coop" and "co-op" will sort together in a list
//
//                        co_op     <-------  underscore (symbol)
//                        coat
//                        comb
//                        coop
//                        co-op     <-------  hyphen (punctuation)
//                        cork
//                        went
//                        were
//                        we're     <-------  apostrophe (punctuation)
//
//
//    STRING Sort:  hyphen and apostrophe will sort with all other symbols
//
//                        co-op     <-------  hyphen (punctuation)
//                        co_op     <-------  underscore (symbol)
//                        coat
//                        comb
//                        coop
//                        cork
//                        we're     <-------  apostrophe (punctuation)
//                        went
//                        were
//


//  Sort digits as numbers (ie: 2 comes before 10)


#line 376 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winnls.h"


//
//  Compare String Return Values.
//





//
//  Code Page Default Values.
//  Please Use Unicode, either UTF-16 (as in WCHAR) or UTF-8 (code page CP_ACP)
//









//
// ** DEPRECATED ** DEPRECATED ** DEPRECATED ** DEPRECATED ** DEPRECATED **
//
//  Country/Region Codes.
//
//  DEPRECATED: The GEOID  concept is deprecated, please use
//  Country/Region Names instead, eg: "US" instead of a GEOID like 244.
//  See the documentation for GetGeoInfoEx.
//
//  WARNING: These values are arbitrarily assigned values, please use
//           standard country/region names instead, such as "US".
//
// ** DEPRECATED ** DEPRECATED ** DEPRECATED ** DEPRECATED ** DEPRECATED **
//



















































































































//
//  Locale Types.
//
//  These types are used for the GetLocaleInfo NLS API routine.
//  Some of these types are also used for the SetLocaleInfo NLS API routine.
//

//
//  The following LCTypes may be used in combination with any other LCTypes.
//
//    LOCALE_NOUSEROVERRIDE is also used in GetTimeFormat and
//    GetDateFormat.
//
//    LOCALE_RETURN_NUMBER will return the result from GetLocaleInfo as a
//    number instead of a string.  This flag is only valid for the LCTypes
//    beginning with LOCALE_I.
//
//    DEPRECATED: LOCALE_USE_CP_ACP is used in many of the A (Ansi) apis that need
//                to do string translation.  Callers are encouraged to use the W
//                (WCHAR/Unicode) apis instead.
//





#line 555 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winnls.h"




#line 560 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winnls.h"


//
//  The following LCTypes are mutually exclusive in that they may NOT
//  be used in combination with each other.
//

//
// These are the various forms of the name of the locale:
//




#line 575 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winnls.h"



#line 579 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winnls.h"







// Additional LCTypes























































































#line 675 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winnls.h"









#line 685 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winnls.h"



















#line 705 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winnls.h"



                                                   // 0 - Left to right (eg en-US)
                                                   // 1 - Right to left (eg arabic locales)
                                                   // 2 - Vertical top to bottom with columns to the left and also left to right (ja-JP locales)
                                                   // 3 - Vertical top to bottom with columns proceeding to the right









#line 722 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winnls.h"



#line 726 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winnls.h"




#line 731 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winnls.h"

//
// DEPRECATED LCTYPEs
//

// DEPRECATED LCTYPEs for Code Pages
// Applications are strongly encouraged to Use Unicode, such as UTF-16 (WCHAR type)
// or the CP_UTF8 Code Page.  Legacy encodings are unable to represent the full
// set of scripts/language and characters (& emoji!) available on modern computers.
// Use of legacy code pages (encodings) is a leading cause of data loss and corruption.





#line 747 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winnls.h"

// LCTYPEs using out-of-date concepts








// Derived legacy date & time values for compatibility only.
// Please use the appropriate date or time pattern instead.
// These can be misleading, for example a locale configured as 12h24m52s could have a time separator of "h".













#line 774 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winnls.h"

// LCTYPEs which have been renamed to enable more understandable source code.



#line 780 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winnls.h"





// DEPRECATED: Use LOCALE_SISO3166CTRYNAME to query for a region identifier, LOCALE_ICOUNTRY is not a region identifier.





//
//  Time Flags for GetTimeFormat.
//






//
//  Date Flags for GetDateFormat.
//








#line 812 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winnls.h"



#line 816 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winnls.h"



#line 820 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winnls.h"

//
//  Calendar Types.
//
//  These types are used for the EnumCalendarInfo and GetCalendarInfo
//  NLS API routines.
//  Some of these types are also used for the SetCalendarInfo NLS API
//  routine.
//

//
//  The following CalTypes may be used in combination with any other CalTypes.
//
//    CAL_NOUSEROVERRIDE
//
//    CAL_RETURN_NUMBER will return the result from GetCalendarInfo as a
//    number instead of a string.  This flag is only valid for the CalTypes
//    beginning with CAL_I.
//
//    DEPRECATED: CAL_USE_CP_ACP is used in many of the A (Ansi) apis that need
//                to do string translation.  Callers are encouraged to use the W
//                (WCHAR/Unicode) apis instead.
//




#line 848 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winnls.h"




#line 853 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winnls.h"

//
//  The following CalTypes are mutually exclusive in that they may NOT
//  be used in combination with each other.
//




















// Note that in the hebrew calendar the leap month name is always returned as the 7th month






























#line 910 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winnls.h"









#line 920 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winnls.h"




#line 925 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winnls.h"



#line 929 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winnls.h"




#line 934 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winnls.h"

// CAL_SJAPANESEERAFIRSTYEAR is only supported on machines with updates to support the "gannen" era first year behavior
// Machines without that update will return 0 and ERROR_INVALID_FLAGS, in which case ichinen is presumed.


//
//  Calendar Enumeration Value.
//


//
//  Calendar ID Values.
//















//
// ** DEPRECATED ** DEPRECATED ** DEPRECATED ** DEPRECATED ** DEPRECATED **
//
//  Language Group ID Values
//
// The "Language Group" concept is an obsolete concept.
// The groups returned are not well defined, arbitrary, inconsistent, inaccurate,
// no longer maintained, and no longer supported.
//
// ** DEPRECATED ** DEPRECATED ** DEPRECATED ** DEPRECATED ** DEPRECATED **
//





















//
//  MUI function flag values
//






























//
// MUI_CALLBACK_FLAG defines are duplicated in rtlmui.h
//



//
// MUI_CALLBACK_ flags are duplicated in rtlmui.h
//

#line 1038 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winnls.h"

////////////////////////////////////////////////////////////////////////////
//
//  Typedefs
//
//  Define all types for the NLS component here.
//
////////////////////////////////////////////////////////////////////////////

//
// ** DEPRECATED ** DEPRECATED ** DEPRECATED ** DEPRECATED ** DEPRECATED **
//
//  Language Group ID 
//
// The "Language Group" concept is an obsolete concept.
// The groups returned are not well defined, arbitrary, inconsistent, inaccurate,
// no longer maintained, and no longer supported.
//
// ** DEPRECATED ** DEPRECATED ** DEPRECATED ** DEPRECATED ** DEPRECATED **
//
typedef DWORD LGRPID;

//
//  Locale type constant.
//
typedef DWORD LCTYPE;

//
//  Calendar type constant.
//
typedef DWORD CALTYPE;


//
//  Calendar ID.
//
typedef DWORD CALID;


//
//  CP Info.
//
// Deprecated.  Applications should use Unicode (WCHAR / UTF-16 or UTF-8)
//
// WARNING: These structures fail for some encodings, including UTF-8, which
//          do not fit into the assumptions of these APIs.
//


typedef struct _cpinfo {
    UINT    MaxCharSize;                    // max length (in bytes) of a char
    BYTE    DefaultChar[2 ];   // default character
    BYTE    LeadByte[12 ];        // lead byte ranges
} CPINFO, *LPCPINFO;

//
//  GEO defines
//
typedef DWORD   GEOTYPE;
typedef DWORD   GEOCLASS;

//
// ** DEPRECATED ** DEPRECATED ** DEPRECATED ** DEPRECATED ** DEPRECATED **
//
//  DEPRECATED: The GEOID  concept is deprecated, please use
//  Country/Region Names instead, eg: "US" instead of a GEOID like 244.
//  See the documentation for GetGeoInfoEx.
//
//  WARNING: These values are arbitrarily assigned values, please use
//           standard country/region names instead, such as "US".
//
// ** DEPRECATED ** DEPRECATED ** DEPRECATED ** DEPRECATED ** DEPRECATED **
//
typedef LONG    GEOID;



#line 1116 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winnls.h"
#pragma endregion

#pragma region Application Family or OneCore Family




typedef struct _cpinfoexA {
    UINT    MaxCharSize;                    // max length (in bytes) of a char
    BYTE    DefaultChar[2 ];   // default character (MB)
    BYTE    LeadByte[12 ];        // lead byte ranges
    WCHAR   UnicodeDefaultChar;             // default character (Unicode)
    UINT    CodePage;                       // code page id
    CHAR    CodePageName[260 ];         // code page name (Unicode)
} CPINFOEXA, *LPCPINFOEXA;

typedef struct _cpinfoexW {
    UINT    MaxCharSize;                    // max length (in bytes) of a char
    BYTE    DefaultChar[2 ];   // default character (MB)
    BYTE    LeadByte[12 ];        // lead byte ranges
    WCHAR   UnicodeDefaultChar;             // default character (Unicode)
    UINT    CodePage;                       // code page id
    WCHAR   CodePageName[260 ];         // code page name (Unicode)
} CPINFOEXW, *LPCPINFOEXW;




typedef CPINFOEXA CPINFOEX;
typedef LPCPINFOEXA LPCPINFOEX;
#line 1147 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winnls.h"


//
//  Number format.
//

typedef struct _numberfmtA {
    UINT    NumDigits;                 // number of decimal digits
    UINT    LeadingZero;               // if leading zero in decimal fields
    UINT    Grouping;                  // group size left of decimal
    LPSTR   lpDecimalSep;              // ptr to decimal separator string
    LPSTR   lpThousandSep;             // ptr to thousand separator string
    UINT    NegativeOrder;             // negative number ordering
} NUMBERFMTA, *LPNUMBERFMTA;
typedef struct _numberfmtW {
    UINT    NumDigits;                 // number of decimal digits
    UINT    LeadingZero;               // if leading zero in decimal fields
    UINT    Grouping;                  // group size left of decimal
    LPWSTR  lpDecimalSep;              // ptr to decimal separator string
    LPWSTR  lpThousandSep;             // ptr to thousand separator string
    UINT    NegativeOrder;             // negative number ordering
} NUMBERFMTW, *LPNUMBERFMTW;




typedef NUMBERFMTA NUMBERFMT;
typedef LPNUMBERFMTA LPNUMBERFMT;
#line 1176 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winnls.h"


//
//  Currency format.
//

typedef struct _currencyfmtA {
    UINT    NumDigits;                 // number of decimal digits
    UINT    LeadingZero;               // if leading zero in decimal fields
    UINT    Grouping;                  // group size left of decimal
    LPSTR   lpDecimalSep;              // ptr to decimal separator string
    LPSTR   lpThousandSep;             // ptr to thousand separator string
    UINT    NegativeOrder;             // negative currency ordering
    UINT    PositiveOrder;             // positive currency ordering
    LPSTR   lpCurrencySymbol;          // ptr to currency symbol string
} CURRENCYFMTA, *LPCURRENCYFMTA;
typedef struct _currencyfmtW {
    UINT    NumDigits;                 // number of decimal digits
    UINT    LeadingZero;               // if leading zero in decimal fields
    UINT    Grouping;                  // group size left of decimal
    LPWSTR  lpDecimalSep;              // ptr to decimal separator string
    LPWSTR  lpThousandSep;             // ptr to thousand separator string
    UINT    NegativeOrder;             // negative currency ordering
    UINT    PositiveOrder;             // positive currency ordering
    LPWSTR  lpCurrencySymbol;          // ptr to currency symbol string
} CURRENCYFMTW, *LPCURRENCYFMTW;




typedef CURRENCYFMTA CURRENCYFMT;
typedef LPCURRENCYFMTA LPCURRENCYFMT;
#line 1209 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winnls.h"

//
//  NLS function capabilities
//

enum SYSNLS_FUNCTION{
    COMPARE_STRING    =  0x0001,
};
typedef DWORD NLS_FUNCTION;


//
//  NLS version structure.
//
















#line 1240 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winnls.h"
// 
// Windows 7 and below had different sizes
//

// This is to be deprecated, please use the NLSVERSIONINFOEX
// structure below in the future.  The difference is that
// guidCustomversion is required to uniquely identify a sort
typedef struct _nlsversioninfo{		// Use NLSVERSIONINFOEX instead
    DWORD dwNLSVersionInfoSize;     // 12 bytes
    DWORD dwNLSVersion;
    DWORD dwDefinedVersion;         // Deprecated, use dwNLSVersion instead
} NLSVERSIONINFO, *LPNLSVERSIONINFO;
#line 1253 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winnls.h"

// The combination of dwNLSVersion, and guidCustomVersion
// identify specific sort behavior, persist those to ensure identical
// behavior in the future.
typedef struct _nlsversioninfoex{
    DWORD dwNLSVersionInfoSize;     // sizeof(NLSVERSIONINFOEX) == 32 bytes
    DWORD dwNLSVersion;
    DWORD dwDefinedVersion;         // Deprecated, use dwNLSVersion instead
    DWORD dwEffectiveId;            // Deprecated, use guidCustomVerison instead
    GUID  guidCustomVersion;        // Explicit sort version
} NLSVERSIONINFOEX, *LPNLSVERSIONINFOEX;



#line 1268 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winnls.h"

//
//  GEO information types for clients to query
//
// Please use GetGeoInfoEx and query by country/region name instead of GEOID (eg: "US" instead of 244)
enum SYSGEOTYPE {
    GEO_NATION      =       0x0001, // DEPRECATED Not used by name API
    GEO_LATITUDE    =       0x0002,
    GEO_LONGITUDE   =       0x0003,
    GEO_ISO2        =       0x0004,
    GEO_ISO3        =       0x0005,
    GEO_RFC1766     =       0x0006, // DEPRECATED and misleading, not used by name API
    GEO_LCID        =       0x0007, // DEPRECATED Not used by name API
    GEO_FRIENDLYNAME=       0x0008,
    GEO_OFFICIALNAME=       0x0009,
    GEO_TIMEZONES   =       0x000A, // Not implemented
    GEO_OFFICIALLANGUAGES = 0x000B, // Not implemented
    GEO_ISO_UN_NUMBER =     0x000C,
    GEO_PARENT      =       0x000D,
    GEO_DIALINGCODE =       0x000E,
    GEO_CURRENCYCODE=       0x000F, // eg: USD
    GEO_CURRENCYSYMBOL=     0x0010, // eg: $



#line 1294 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winnls.h"
};

//
//  More GEOCLASS defines will be listed here
//

enum SYSGEOCLASS {
    GEOCLASS_NATION  = 16,
    GEOCLASS_REGION  = 14,          // DEPRECATED - Never used
    GEOCLASS_ALL = 0
};


//
//  Normalization forms
//

typedef enum _NORM_FORM {
    NormalizationOther  = 0,       // Not supported
    NormalizationC      = 0x1,     // Each base plus combining characters to the canonical precomposed equivalent.
    NormalizationD      = 0x2,     // Each precomposed character to its canonical decomposed equivalent.
    NormalizationKC     = 0x5,     // Each base plus combining characters to the canonical precomposed
                                   //   equivalents and all compatibility characters to their equivalents.
    NormalizationKD     = 0x6      // Each precomposed character to its canonical decomposed equivalent
                                   //   and all compatibility characters to their equivalents.
} NORM_FORM;


//
// IDN (International Domain Name) Flags
//








#line 1334 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winnls.h"

//
//  Enumeration function constants.
//




typedef BOOL (__stdcall * LANGUAGEGROUP_ENUMPROCA)(LGRPID, LPSTR, LPSTR, DWORD, LONG_PTR);    // Deprecated, please use Unicode

typedef BOOL (__stdcall * LANGGROUPLOCALE_ENUMPROCA)(LGRPID, LCID, LPSTR, LONG_PTR);          // Deprecated, please use Unicode
typedef BOOL (__stdcall * UILANGUAGE_ENUMPROCA)(LPSTR, LONG_PTR);                             // Deprecated, please use Unicode
typedef BOOL (__stdcall * CODEPAGE_ENUMPROCA)(LPSTR);                                         // Deprecated, please use Unicode
typedef BOOL (__stdcall * DATEFMT_ENUMPROCA)(LPSTR);                                          // Deprecated, please use Unicode
typedef BOOL (__stdcall * DATEFMT_ENUMPROCEXA)(LPSTR, CALID);                                 // Deprecated, please use Unicode
typedef BOOL (__stdcall * TIMEFMT_ENUMPROCA)(LPSTR);                                          // Deprecated, please use Unicode
typedef BOOL (__stdcall * CALINFO_ENUMPROCA)(LPSTR);                                          // Deprecated, please use Unicode
typedef BOOL (__stdcall * CALINFO_ENUMPROCEXA)(LPSTR, CALID);                                 // Deprecated, please use Unicode
typedef BOOL (__stdcall * LOCALE_ENUMPROCA)(LPSTR);                                           // Deprecated, please use Unicode
typedef BOOL (__stdcall * LOCALE_ENUMPROCW)(LPWSTR);                                          // DEPRECATED: please use LOCALE_ENUMPROCEX

typedef BOOL (__stdcall * LANGUAGEGROUP_ENUMPROCW)(LGRPID, LPWSTR, LPWSTR, DWORD, LONG_PTR);  // DEPRECATED: Language groups are no longer supported

typedef BOOL (__stdcall * LANGGROUPLOCALE_ENUMPROCW)(LGRPID, LCID, LPWSTR, LONG_PTR);         // DEPRECATED: Language groups are no longer supported
typedef BOOL (__stdcall * UILANGUAGE_ENUMPROCW)(LPWSTR, LONG_PTR);
typedef BOOL (__stdcall * CODEPAGE_ENUMPROCW)(LPWSTR);            // Please use Unicode / UTF-8
typedef BOOL (__stdcall * DATEFMT_ENUMPROCW)(LPWSTR);
typedef BOOL (__stdcall * DATEFMT_ENUMPROCEXW)(LPWSTR, CALID);
typedef BOOL (__stdcall * TIMEFMT_ENUMPROCW)(LPWSTR);
typedef BOOL (__stdcall * CALINFO_ENUMPROCW)(LPWSTR);
typedef BOOL (__stdcall * CALINFO_ENUMPROCEXW)(LPWSTR, CALID);
typedef BOOL (__stdcall * GEO_ENUMPROC)(GEOID);                   // DEPRECATED, use GEO_ENUMNAMEPROC instead


#line 1369 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winnls.h"
































#line 1402 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winnls.h"


















// DEPRECATED("The Language Group concept is obsolete and no longer supported. Set DISABLE_NLS_DEPRECATION to disable this warning.")

// DEPRECATED("The Language Group concept is obsolete and no longer supported. Set DISABLE_NLS_DEPRECATION to disable this warning.")










#line 1434 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winnls.h"

//
// Information about a MUI file, used as input/output in GetFileMUIInfo
// All offsets are relative to start of the structure. Offsets with value 0 mean empty field.
//

typedef struct _FILEMUIINFO {
    DWORD       dwSize;                 // Size of the structure including buffer size [in]
    DWORD       dwVersion;              // Version of the structure [in]
    DWORD       dwFileType;             // Type of the file [out]
    BYTE        pChecksum[16];          // Checksum of the file [out]
    BYTE        pServiceChecksum[16];   // Checksum of the file [out]
    DWORD       dwLanguageNameOffset;   // Language name of the file [out]
    DWORD       dwTypeIDMainSize;       // Number of TypeIDs in main module [out]
    DWORD       dwTypeIDMainOffset;     // Array of TypeIDs (DWORD) in main module [out]
    DWORD       dwTypeNameMainOffset;   // Multistring array of TypeNames in main module [out]
    DWORD       dwTypeIDMUISize;        // Number of TypeIDs in MUI module [out]
    DWORD       dwTypeIDMUIOffset;      // Array of TypeIDs (DWORD) in MUI module [out]
    DWORD       dwTypeNameMUIOffset;    // Multistring array of TypeNames in MUI module [out]
    BYTE        abBuffer[8];             // Buffer for extra data [in] (Size 4 is for padding)
} FILEMUIINFO, *PFILEMUIINFO;


#line 1 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\stringapiset.h"
/********************************************************************************
*                                                                               *
* stringapi.h -- ApiSet Contract for api-ms-win-core-string-l1                  *
*                                                                               *
* Copyright (c) Microsoft Corporation. All rights reserved.                     *
*                                                                               *
********************************************************************************/


#pragma once
#line 12 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\stringapiset.h"







#line 1 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winnls.h"
/*++

Copyright (c) Microsoft Corporation  All rights reserved.

Module Name:

    winnls.h

Abstract:

    Procedure declarations, constant definitions, and macros for the
    NLS component.

--*/













































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































#line 20 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\stringapiset.h"


extern "C" {
#line 24 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\stringapiset.h"

#pragma region Desktop or OneCore or Application or Games Family




__declspec(dllimport)
int
__stdcall
CompareStringEx(
     LPCWSTR lpLocaleName,
     DWORD dwCmpFlags,
     LPCWCH lpString1,
     int cchCount1,
     LPCWCH lpString2,
     int cchCount2,
     LPNLSVERSIONINFO lpVersionInformation,
     LPVOID lpReserved,
     LPARAM lParam
    );


__declspec(dllimport)
int
__stdcall
CompareStringOrdinal(
     LPCWCH lpString1,
     int cchCount1,
     LPCWCH lpString2,
     int cchCount2,
     BOOL bIgnoreCase
    );


#line 59 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\stringapiset.h"

__declspec(dllimport)
int
__stdcall
CompareStringW(
     LCID Locale,
     DWORD dwCmpFlags,
     PCNZWCH lpString1,
     int cchCount1,
     PCNZWCH lpString2,
     int cchCount2
    );





__declspec(dllimport)
int
__stdcall
FoldStringW(
     DWORD dwMapFlags,
     LPCWCH lpSrcStr,
     int cchSrc,
     LPWSTR lpDestStr,
     int cchDest
    );





__declspec(dllimport)
BOOL
__stdcall
GetStringTypeExW(
     LCID Locale,
     DWORD dwInfoType,
     LPCWCH lpSrcStr,
     int cchSrc,
     LPWORD lpCharType
    );





__declspec(dllimport)
BOOL
__stdcall
GetStringTypeW(
     DWORD dwInfoType,
     LPCWCH lpSrcStr,
     int cchSrc,
     LPWORD lpCharType
    );


//
//  NLS Code Page Dependent APIs.
//

__declspec(dllimport)

         
int
__stdcall
MultiByteToWideChar(
     UINT CodePage,
     DWORD dwFlags,
     LPCCH lpMultiByteStr,
     int cbMultiByte,
     LPWSTR lpWideCharStr,
     int cchWideChar
    );


__declspec(dllimport)

         
int
__stdcall
WideCharToMultiByte(
     UINT CodePage,
     DWORD dwFlags,
     LPCWCH lpWideCharStr,
     int cchWideChar,
     LPSTR lpMultiByteStr,
     int cbMultiByte,
     LPCCH lpDefaultChar,
     LPBOOL lpUsedDefaultChar
    );


#line 154 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\stringapiset.h"
#pragma endregion


}
#line 159 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\stringapiset.h"

#line 161 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\stringapiset.h"
#line 1458 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winnls.h"
#line 1459 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winnls.h"


////////////////////////////////////////////////////////////////////////////
//
//  Macros
//
//  Define all macros for the NLS component here.
//
////////////////////////////////////////////////////////////////////////////

//
//  Macros to determine whether a character is a high or low surrogate,
//  and whether two code points make up a surrogate pair (a high surrogate
//  and a low surrogate).
//




// ----------------------------------------------------------------------
// The following macros retrieve information from a MUIFILEINFO structure
//
// Gets the culture name (LPWSTR), NULL if not initialized


//
// Gets the main module types array (DWORD[]), NULL if not initialized


//
// Gets the main module type array element iType (DWORD), the array is not initialized or index is out of bounds


//
// Gets the main module names multistring array (LPWSTR), NULL if not initialized


//
// Gets the mui module types array (DWORD[]), NULL if not initialized


//
// Gets the mui module type array element iType (DWORD), the array is not initialized or index is out of bounds


//
// Gets the mui module names multistring array (LPWSTR), NULL if not initialized


// ------------------------------------------------------------------------


////////////////////////////////////////////////////////////////////////////
//
//  Function Prototypes
//
//  Only prototypes for the NLS APIs should go here.
//
////////////////////////////////////////////////////////////////////////////

#line 1520 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winnls.h"
#pragma endregion

#pragma region Application Family or OneCore or Games Family


//
//  Code Page Dependent APIs.
//
//  Applications should use Unicode (WCHAR / UTF-16 &/or UTF-8)
//

__declspec(dllimport)
BOOL
__stdcall
IsValidCodePage(
     UINT  CodePage);

__declspec(dllimport)
UINT
__stdcall
GetACP(void);

#line 1543 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winnls.h"
#pragma endregion

#pragma region Desktop Family or OneCore Family


__declspec(dllimport)
UINT
__stdcall
GetOEMCP(void);

#line 1554 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winnls.h"
#pragma endregion

#pragma region Desktop or Pc Family or OneCore or Games Family



__declspec(dllimport)
BOOL
__stdcall
GetCPInfo(
     UINT       CodePage,
     LPCPINFO  lpCPInfo);

#line 1568 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winnls.h"
#pragma endregion

#pragma region Desktop or Pc Family or OneCore Family



__declspec(dllimport)
BOOL
__stdcall
GetCPInfoExA(
     UINT          CodePage,
     DWORD         dwFlags,
     LPCPINFOEXA  lpCPInfoEx);

__declspec(dllimport)
BOOL
__stdcall
GetCPInfoExW(
     UINT          CodePage,
     DWORD         dwFlags,
     LPCPINFOEXW  lpCPInfoEx);




#line 1594 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winnls.h"

#line 1596 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winnls.h"
#pragma endregion

//
//  Locale Dependent APIs.
//

#pragma region Desktop or OneCore or Application or Games Family



__declspec(dllimport)
int
__stdcall
CompareStringA(
     LCID     Locale,
     DWORD    dwCmpFlags,
     PCNZCH lpString1,
     int      cchCount1,
     PCNZCH  lpString2,
     int      cchCount2);



#line 1620 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winnls.h"




























#line 1649 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winnls.h"

#line 1651 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winnls.h"
#pragma endregion

#pragma region Desktop or OneCore or Games Family




// DEPRECATED: FindNLSStringEx is preferred
__declspec(dllimport)
int
__stdcall
FindNLSString(
                        LCID Locale,
                        DWORD dwFindNLSStringFlags,
      LPCWSTR lpStringSource,
                        int cchSource,
       LPCWSTR lpStringValue,
                        int cchValue,
                   LPINT pcchFound);

#line 1672 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winnls.h"

// DEPRECATED: LCMapStringEx is preferred
__declspec(dllimport)
int
__stdcall
LCMapStringW(
     LCID     Locale,
     DWORD    dwMapFlags,
     LPCWSTR  lpSrcStr,
     int      cchSrc,
     LPWSTR  lpDestStr,
     int      cchDest);




// DEPRECATED: Use Unicode, LCMapStringEx is preferred
__declspec(dllimport)
int
__stdcall
LCMapStringA(
     LCID     Locale,
     DWORD    dwMapFlags,
     LPCSTR  lpSrcStr,
     int      cchSrc,
     LPSTR  lpDestStr,
     int      cchDest);


#line 1702 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winnls.h"

#line 1704 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winnls.h"
#pragma endregion

#pragma region Application Family or OneCore or Games Family


// DEPRECATED: GetLocaleInfoEx is preferred
__declspec(dllimport)
int
__stdcall
GetLocaleInfoW(
     LCID     Locale,
     LCTYPE   LCType,
     LPWSTR lpLCData,
     int      cchData);
    




// DEPRECATED: Use Unicode. GetLocaleInfoEx is preferred
__declspec(dllimport)
int 
__stdcall 
GetLocaleInfoA(
     LCID Locale,
     LCTYPE LCType,
     LPSTR lpLCData,
     int cchData
    );



#line 1737 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winnls.h"

#line 1739 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winnls.h"
#pragma endregion

#pragma region Desktop or OneCore Family


__declspec(dllimport)
BOOL
__stdcall
SetLocaleInfoA(
     LCID     Locale,
     LCTYPE   LCType,
     LPCSTR  lpLCData);
__declspec(dllimport)
BOOL
__stdcall
SetLocaleInfoW(
     LCID     Locale,
     LCTYPE   LCType,
     LPCWSTR  lpLCData);




#line 1763 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winnls.h"



// DEPRECATED: GetCalendarInfoEx is preferred
__declspec(dllimport)
int
__stdcall
GetCalendarInfoA(
     LCID     Locale,
     CALID    Calendar,
     CALTYPE  CalType,
     LPSTR   lpCalData,
     int      cchData,
     LPDWORD  lpValue);
// DEPRECATED: GetCalendarInfoEx is preferred
__declspec(dllimport)
int
__stdcall
GetCalendarInfoW(
     LCID     Locale,
     CALID    Calendar,
     CALTYPE  CalType,
     LPWSTR   lpCalData,
     int      cchData,
     LPDWORD  lpValue);




#line 1793 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winnls.h"

__declspec(dllimport)
BOOL
__stdcall
SetCalendarInfoA(
     LCID     Locale,
     CALID    Calendar,
     CALTYPE  CalType,
     LPCSTR  lpCalData);
__declspec(dllimport)
BOOL
__stdcall
SetCalendarInfoW(
     LCID     Locale,
     CALID    Calendar,
     CALTYPE  CalType,
     LPCWSTR  lpCalData);




#line 1815 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winnls.h"
#line 1816 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winnls.h"

#line 1818 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winnls.h"
#pragma endregion

#pragma region Desktop Family



//                                        
// Flags used by LoadStringByReference    
//                                        





        
__declspec(dllimport)                                
BOOL                                      
__stdcall                                    
LoadStringByReference(                    
           DWORD   Flags,             
           PCWSTR  Language,      
           PCWSTR  SourceString,      
       PWSTR   Buffer,     
           ULONG  cchBuffer,                      
       PCWSTR  Directory,                     
      PULONG  pcchBufferOut                  
    );                                                
#line 1846 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winnls.h"


#line 1849 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winnls.h"
#pragma endregion

#pragma region Application Family or OneCore Family



__declspec(dllimport)         
BOOL               
__stdcall             
IsDBCSLeadByte(    
     BYTE  TestChar 
    );


__declspec(dllimport)
BOOL
__stdcall
IsDBCSLeadByteEx(
     UINT  CodePage,
     BYTE  TestChar
    );



// Use of Locale Names is preferred, LCIDs are deprecated.
// This function is provided to enable compatibility with legacy data sets only.
__declspec(dllimport)
LCID
__stdcall
LocaleNameToLCID(
     LPCWSTR lpName,
     DWORD dwFlags);

#line 1883 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winnls.h"

#line 1885 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winnls.h"
#pragma endregion

#pragma region Application Family or OneCore or Games Family



// Use of Locale Names is preferred, LCIDs are deprecated.
// This function is provided to enable compatibility with legacy data sets only.
__declspec(dllimport)
int
__stdcall
LCIDToLocaleName(
     LCID     Locale,
     LPWSTR  lpName,
     int      cchName,
     DWORD    dwFlags);

#line 1903 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winnls.h"

#line 1905 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winnls.h"
#pragma endregion

#pragma region Desktop Family


// DEPRECATED: GetDurationFormatEx is preferred

__declspec(dllimport)
int
__stdcall
GetDurationFormat(
     LCID             Locale,
     DWORD            dwFlags,
     const SYSTEMTIME *lpDuration,
     ULONGLONG ullDuration,
     LPCWSTR          lpFormat,
     LPWSTR          lpDurationStr,
     int              cchDuration);
#line 1924 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winnls.h"

#line 1926 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winnls.h"
#pragma endregion

#pragma region Desktop Family or OneCore or Games Family


// DEPRECATED: GetNumberFormatEx is preferred
__declspec(dllimport)
int
__stdcall
GetNumberFormatA(
     LCID             Locale,
     DWORD            dwFlags,
     LPCSTR          lpValue,
     const NUMBERFMTA *lpFormat,
     LPSTR          lpNumberStr,
     int              cchNumber);
// DEPRECATED: GetNumberFormatEx is preferred
__declspec(dllimport)
int
__stdcall
GetNumberFormatW(
     LCID             Locale,
     DWORD            dwFlags,
     LPCWSTR          lpValue,
     const NUMBERFMTW *lpFormat,
     LPWSTR          lpNumberStr,
     int              cchNumber);




#line 1958 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winnls.h"

// DEPRECATED: GetCurrencyFormatEx is preferred
__declspec(dllimport)
int
__stdcall
GetCurrencyFormatA(
     LCID               Locale,
     DWORD              dwFlags,
     LPCSTR            lpValue,
     const CURRENCYFMTA *lpFormat,
     LPSTR            lpCurrencyStr,
     int                cchCurrency);
// DEPRECATED: GetCurrencyFormatEx is preferred
__declspec(dllimport)
int
__stdcall
GetCurrencyFormatW(
     LCID               Locale,
     DWORD              dwFlags,
     LPCWSTR            lpValue,
     const CURRENCYFMTW *lpFormat,
     LPWSTR            lpCurrencyStr,
     int                cchCurrency);




#line 1986 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winnls.h"

#line 1988 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winnls.h"
#pragma endregion

#pragma region Desktop Family or OneCore Family


// DEPRECATED: EnumCalendarInfoExEx is preferred
__declspec(dllimport)
BOOL
__stdcall
EnumCalendarInfoA(
     CALINFO_ENUMPROCA lpCalInfoEnumProc,
     LCID              Locale,
     CALID             Calendar,
     CALTYPE           CalType);
// DEPRECATED: EnumCalendarInfoExEx is preferred
__declspec(dllimport)
BOOL
__stdcall
EnumCalendarInfoW(
     CALINFO_ENUMPROCW lpCalInfoEnumProc,
     LCID              Locale,
     CALID             Calendar,
     CALTYPE           CalType);




#line 2016 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winnls.h"


// DEPRECATED: EnumCalendarInfoExEx is preferred
__declspec(dllimport)
BOOL
__stdcall
EnumCalendarInfoExA(
     CALINFO_ENUMPROCEXA lpCalInfoEnumProcEx,
     LCID                Locale,
     CALID               Calendar,
     CALTYPE             CalType);
// DEPRECATED: EnumCalendarInfoExEx is preferred
__declspec(dllimport)
BOOL
__stdcall
EnumCalendarInfoExW(
     CALINFO_ENUMPROCEXW lpCalInfoEnumProcEx,
     LCID                Locale,
     CALID               Calendar,
     CALTYPE             CalType);




#line 2041 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winnls.h"
#line 2042 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winnls.h"

// DEPRECATED: EnumTimeFormatsEx is preferred
__declspec(dllimport)
BOOL
__stdcall
EnumTimeFormatsA(
     TIMEFMT_ENUMPROCA lpTimeFmtEnumProc,
     LCID              Locale,
     DWORD             dwFlags);
// DEPRECATED: EnumTimeFormatsEx is preferred
__declspec(dllimport)
BOOL
__stdcall
EnumTimeFormatsW(
     TIMEFMT_ENUMPROCW lpTimeFmtEnumProc,
     LCID              Locale,
     DWORD             dwFlags);




#line 2064 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winnls.h"

// DEPRECATED: EnumDateFormatsExEx is preferred
__declspec(dllimport)
BOOL
__stdcall
EnumDateFormatsA(
     DATEFMT_ENUMPROCA lpDateFmtEnumProc,
     LCID              Locale,
     DWORD             dwFlags);
// DEPRECATED: EnumDateFormatsExEx is preferred
__declspec(dllimport)
BOOL
__stdcall
EnumDateFormatsW(
     DATEFMT_ENUMPROCW lpDateFmtEnumProc,
     LCID              Locale,
     DWORD             dwFlags);




#line 2086 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winnls.h"


// DEPRECATED: EnumDateFormatsExEx is preferred
__declspec(dllimport)
BOOL
__stdcall
EnumDateFormatsExA(
     DATEFMT_ENUMPROCEXA lpDateFmtEnumProcEx,
     LCID                Locale,
     DWORD               dwFlags);
// DEPRECATED: EnumDateFormatsExEx is preferred
__declspec(dllimport)
BOOL
__stdcall
EnumDateFormatsExW(
     DATEFMT_ENUMPROCEXW lpDateFmtEnumProcEx,
     LCID                Locale,
     DWORD               dwFlags);




#line 2109 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winnls.h"
#line 2110 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winnls.h"



__declspec(dllimport)
BOOL
__stdcall
IsValidLanguageGroup(
     LGRPID  LanguageGroup,
     DWORD   dwFlags);
#line 2120 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winnls.h"

// DEPRECATED: GetNLSVersionEx is preferred
__declspec(dllimport)
BOOL
__stdcall
GetNLSVersion(
        NLS_FUNCTION     Function,
        LCID             Locale,
     LPNLSVERSIONINFO lpVersionInformation);

// DEPRECATED: IsValidLocaleName is preferred
__declspec(dllimport)
BOOL
__stdcall
IsValidLocale(
     LCID   Locale,
     DWORD  dwFlags);

#line 2139 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winnls.h"
#pragma endregion

#pragma region Application Family or OneCore or Games Family


// GetGeoInfoEx is preferred where available

__declspec(dllimport)
int
__stdcall
GetGeoInfoA(
     GEOID       Location,
     GEOTYPE     GeoType,
     LPSTR     lpGeoData,
     int         cchData,
     LANGID      LangId);
// GetGeoInfoEx is preferred where available

__declspec(dllimport)
int
__stdcall
GetGeoInfoW(
     GEOID       Location,
     GEOTYPE     GeoType,
     LPWSTR     lpGeoData,
     int         cchData,
     LANGID      LangId);




#line 2171 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winnls.h"

#line 2173 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winnls.h"
#pragma endregion

#pragma region Application Family or OneCore Family











#line 2188 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winnls.h"

#line 2190 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winnls.h"
#pragma endregion

#pragma region Desktop or PC Family or OneCore Family


// EnumSystemGeoNames is preferred where available

__declspec(dllimport)
BOOL
__stdcall
EnumSystemGeoID(
     GEOCLASS        GeoClass,
     GEOID           ParentGeoId,
     GEO_ENUMPROC    lpGeoEnumProc);









#line 2214 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winnls.h"

#line 2216 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winnls.h"
#pragma endregion

#pragma region Application Family or OneCore or Games Family


// GetUserDefaultGeoName is preferred where available

__declspec(dllimport)
GEOID
__stdcall
GetUserGeoID(
     GEOCLASS    GeoClass);

#line 2230 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winnls.h"
#pragma endregion

#pragma region Application Family or OneCore Family


/**
 * Note: This API was added in the Windows 10 Fall Creators Update.
 * (Please use this API instead of calling GetUserGeoID.)
 *
 */
__declspec(dllimport)
int
__stdcall
GetUserDefaultGeoName(
     LPWSTR geoName,
     int geoNameCount
);

#line 2249 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winnls.h"
#pragma endregion

#pragma region Desktop Family or OneCore Family


// GetUserDefaultGeoName is preferred where available
// Applications are recommended to not change user settings themselves.

__declspec(dllimport)
BOOL
__stdcall
SetUserGeoID(
     GEOID       GeoId);








#line 2271 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winnls.h"

// DEPRECATED: Please use ResolveLocaleName
__declspec(dllimport)
LCID
__stdcall
ConvertDefaultLocale(
     LCID   Locale);


// DEPRECATED: Please use the user's language profile.
__declspec(dllimport)
LANGID
__stdcall
GetSystemDefaultUILanguage(void);

#line 2287 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winnls.h"
#pragma endregion

#pragma region Desktop Family or OneCore Family


__declspec(dllimport)
LCID
__stdcall
GetThreadLocale(void);

__declspec(dllimport)
BOOL
__stdcall
SetThreadLocale(
     LCID  Locale
    );

#line 2305 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winnls.h"
#pragma endregion

#pragma region Application Family or OneCore Family


// DEPRECATED: Please use the user's language profile.
__declspec(dllimport)
LANGID
__stdcall
GetUserDefaultUILanguage(void);
#line 2316 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winnls.h"

// DEPRECATED: Please use GetUserDefaultLocaleName
__declspec(dllimport)
LANGID
__stdcall
GetUserDefaultLangID(void);

#line 2324 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winnls.h"
#pragma endregion

#pragma region Desktop Family or OneCore Family


// DEPRECATED: Please use GetUserDefaultLocaleName or the user's Language Profile
__declspec(dllimport)
LANGID
__stdcall
GetSystemDefaultLangID(void);

// DEPRECATED: Please use GetUserDefaultLocaleName or the user's Language Profile
__declspec(dllimport)
LCID
__stdcall
GetSystemDefaultLCID(void);

// DEPRECATED: Please use GetUserDefaultLocaleName
__declspec(dllimport)
LCID
__stdcall
GetUserDefaultLCID(void);

#line 2348 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winnls.h"
#pragma endregion

#pragma region Desktop Family



#line 2355 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winnls.h"
#pragma endregion

#pragma region Desktop Family or OneCore Family


__declspec(dllimport)
LANGID
__stdcall
SetThreadUILanguage( LANGID LangId);




__declspec(dllimport)
LANGID
__stdcall
GetThreadUILanguage(void);

__declspec(dllimport)
BOOL
__stdcall
GetProcessPreferredUILanguages(
     DWORD dwFlags,
     PULONG pulNumLanguages,
     PZZWSTR pwszLanguagesBuffer,
     PULONG pcchLanguagesBuffer
);


__declspec(dllimport)
BOOL
__stdcall
SetProcessPreferredUILanguages(
            DWORD dwFlags,
        PCZZWSTR pwszLanguagesBuffer,
       PULONG pulNumLanguages
);

#line 2394 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winnls.h"
#line 2395 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winnls.h"
#pragma endregion

#pragma region Desktop Family or Phone Family or OneCore or Games Family



__declspec(dllimport)
BOOL
__stdcall
GetUserPreferredUILanguages (
     DWORD dwFlags,
     PULONG pulNumLanguages,
     PZZWSTR pwszLanguagesBuffer,
     PULONG pcchLanguagesBuffer
);

#line 2412 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winnls.h"

#line 2414 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winnls.h"
#pragma endregion

#pragma region Desktop Family or OneCore Family




__declspec(dllimport)
BOOL
__stdcall
GetSystemPreferredUILanguages (
     DWORD dwFlags,
     PULONG pulNumLanguages,
     PZZWSTR pwszLanguagesBuffer,
     PULONG pcchLanguagesBuffer
);


__declspec(dllimport)
BOOL
__stdcall
GetThreadPreferredUILanguages(
     DWORD dwFlags,
     PULONG pulNumLanguages,
     PZZWSTR pwszLanguagesBuffer,
     PULONG pcchLanguagesBuffer
);


__declspec(dllimport)
BOOL
__stdcall
SetThreadPreferredUILanguages(
            DWORD dwFlags,
        PCZZWSTR pwszLanguagesBuffer,
       PULONG pulNumLanguages
);

__declspec(dllimport)

BOOL
__stdcall
GetFileMUIInfo(
                        DWORD           dwFlags,
                    PCWSTR          pcwszFilePath,
     PFILEMUIINFO    pFileMUIInfo,
                 DWORD*          pcbFileMUIInfo);

__declspec(dllimport)
BOOL
__stdcall
GetFileMUIPath(
     DWORD      dwFlags,
     PCWSTR     pcwszFilePath ,
       PWSTR pwszLanguage,
     PULONG  pcchLanguage,
     PWSTR pwszFileMUIPath,
             PULONG pcchFileMUIPath,
             PULONGLONG pululEnumerator
);


__declspec(dllimport)
BOOL
__stdcall
GetUILanguageInfo(
     DWORD dwFlags,
     PCZZWSTR pwmszLanguage,
     PZZWSTR pwszFallbackLanguages,
     PDWORD pcchFallbackLanguages,
     PDWORD pAttributes
);

#line 2488 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winnls.h"

#line 2490 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winnls.h"
#pragma endregion

#pragma region Desktop Family




__declspec(dllimport)
BOOL
__stdcall
NotifyUILanguageChange(
            DWORD dwFlags,
        PCWSTR pcwstrNewLanguage,
        PCWSTR pcwstrPreviousLanguage,
            DWORD dwReserved,
       PDWORD pdwStatusRtrn
);

#line 2509 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winnls.h"

#line 2511 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winnls.h"
#pragma endregion


//
//  Locale Independent APIs.
//

#pragma region Desktop or OneCore or Application or Games Family


__declspec(dllimport)
BOOL
__stdcall
GetStringTypeExA(
                     LCID       Locale,
                     DWORD      dwInfoType,
       LPCSTR   lpSrcStr,
                     int        cchSrc,
     LPWORD     lpCharType);


#line 2533 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winnls.h"


//
//  NOTE: The parameters for GetStringTypeA and GetStringTypeW are
//        NOT the same.  The W version was shipped in NT 3.1.  The
//        A version was then shipped in 16-bit OLE with the wrong
//        parameters (ported from Win95).  To be compatible, we
//        must break the relationship between the A and W versions
//        of GetStringType.  There will be NO function call for the
//        generic GetStringType.
//
//        GetStringTypeEx (above) should be used instead.
//
__declspec(dllimport)
BOOL
__stdcall
GetStringTypeA(
     LCID     Locale,
     DWORD    dwInfoType,
     LPCSTR   lpSrcStr,
     int      cchSrc,
     LPWORD  lpCharType);

__declspec(dllimport)
int
__stdcall
FoldStringA(
     DWORD    dwMapFlags,
     LPCSTR  lpSrcStr,
     int      cchSrc,
     LPSTR  lpDestStr,
     int      cchDest);


#line 2568 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winnls.h"

#line 2570 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winnls.h"
#pragma endregion

#pragma region Desktop Family or OneCore or Games Family




// DEPRECATED, please use Locale Names and call EnumSystemLocalesEx
__declspec(dllimport)
BOOL
__stdcall
EnumSystemLocalesA(
     LOCALE_ENUMPROCA lpLocaleEnumProc,
     DWORD            dwFlags);
// DEPRECATED, please use Locale Names and call EnumSystemLocalesEx
__declspec(dllimport)
BOOL
__stdcall
EnumSystemLocalesW(
     LOCALE_ENUMPROCW lpLocaleEnumProc,
     DWORD            dwFlags);




#line 2596 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winnls.h"

#line 2598 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winnls.h"

#line 2600 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winnls.h"
#pragma endregion

#pragma region Desktop Family or OneCore Family





__declspec(dllimport)
BOOL
__stdcall
EnumSystemLanguageGroupsA(
     LANGUAGEGROUP_ENUMPROCA lpLanguageGroupEnumProc,
     DWORD                   dwFlags,
     LONG_PTR                lParam);

__declspec(dllimport)
BOOL
__stdcall
EnumSystemLanguageGroupsW(
     LANGUAGEGROUP_ENUMPROCW lpLanguageGroupEnumProc,
     DWORD                   dwFlags,
     LONG_PTR                lParam);




#line 2628 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winnls.h"


__declspec(dllimport)
BOOL
__stdcall
EnumLanguageGroupLocalesA(
     LANGGROUPLOCALE_ENUMPROCA lpLangGroupLocaleEnumProc,
     LGRPID                    LanguageGroup,
     DWORD                     dwFlags,
     LONG_PTR                  lParam);

__declspec(dllimport)
BOOL
__stdcall
EnumLanguageGroupLocalesW(
     LANGGROUPLOCALE_ENUMPROCW lpLangGroupLocaleEnumProc,
     LGRPID                    LanguageGroup,
     DWORD                     dwFlags,
     LONG_PTR                  lParam);




#line 2652 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winnls.h"

#line 2654 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winnls.h"
#pragma endregion

#pragma region Application Family or OneCore Family


// DEPRECATED: use the user language profile instead.
__declspec(dllimport)
BOOL
__stdcall
EnumUILanguagesA(
     UILANGUAGE_ENUMPROCA lpUILanguageEnumProc,
     DWORD                dwFlags,
     LONG_PTR             lParam);
// DEPRECATED: use the user language profile instead.
__declspec(dllimport)
BOOL
__stdcall
EnumUILanguagesW(
     UILANGUAGE_ENUMPROCW lpUILanguageEnumProc,
     DWORD                dwFlags,
     LONG_PTR             lParam);




#line 2680 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winnls.h"

#line 2682 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winnls.h"

#line 2684 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winnls.h"
#pragma endregion

#pragma region Desktop or PC Family or OneCore Family


// Please use Unicode instead.  Use of other code pages/encodings is discouraged.
__declspec(dllimport)
BOOL
__stdcall
EnumSystemCodePagesA(
     CODEPAGE_ENUMPROCA lpCodePageEnumProc,
     DWORD              dwFlags);
// Please use Unicode instead.  Use of other code pages/encodings is discouraged.
__declspec(dllimport)
BOOL
__stdcall
EnumSystemCodePagesW(
     CODEPAGE_ENUMPROCW lpCodePageEnumProc,
     DWORD              dwFlags);




#line 2708 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winnls.h"

#line 2710 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winnls.h"
#pragma endregion

//
// Windows API Normalization Functions
//

#pragma region Application Family or OneCore or Games Family




//
// IDN (International Domain Name) Functions
//
__declspec(dllimport)
int
__stdcall IdnToAscii(                           DWORD    dwFlags,
                   	 LPCWSTR  lpUnicodeCharStr,
                                          	 int      cchUnicodeChar,
                   LPWSTR   lpASCIICharStr,
                                          	 int      cchASCIIChar);

__declspec(dllimport)
int
__stdcall IdnToUnicode(                         	 DWORD   dwFlags,
                        	 LPCWSTR lpASCIICharStr,
                                             	 int     cchASCIIChar,
                     LPWSTR  lpUnicodeCharStr,
                                             	 int     cchUnicodeChar);

#line 2741 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winnls.h"

#line 2743 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winnls.h"
#pragma endregion

#pragma region Application Family or OneCore Family




__declspec(dllimport)
int
__stdcall IdnToNameprepUnicode(                            	DWORD   dwFlags,
                                 	LPCWSTR lpUnicodeCharStr,
                                                        	int     cchUnicodeChar,
                               LPWSTR  lpNameprepCharStr,
                                                        	int     cchNameprepChar);

__declspec(dllimport)
int
__stdcall NormalizeString(                           NORM_FORM NormForm,
                              LPCWSTR   lpSrcString,
                                                  int       cwSrcLength,
                         LPWSTR    lpDstString,
                                                  int       cwDstLength );

__declspec(dllimport)
BOOL
__stdcall IsNormalizedString(                    NORM_FORM NormForm,
                             LPCWSTR   lpString,
                                              int       cwLength );

__declspec(dllimport)
BOOL
__stdcall VerifyScripts(
        DWORD   dwFlags,            // optional behavior flags
        LPCWSTR lpLocaleScripts,    // Locale list of scripts string
        int     cchLocaleScripts,   // size of locale script list string
        LPCWSTR lpTestScripts,      // test scripts string
        int     cchTestScripts);    // size of test list string

__declspec(dllimport)
int
__stdcall GetStringScripts(
                                 DWORD   dwFlags,        // optional behavior flags
                                 LPCWSTR lpString,       // Unicode character input string
                                 int     cchString,      // size of input string
         LPWSTR  lpScripts,      // Script list output string
                                 int     cchScripts);    // size of output string

#line 2791 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winnls.h"

#line 2793 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winnls.h"
#pragma endregion



#pragma region Application Family or OneCore or Games Family


//
// String based NLS APIs
//





__declspec(dllimport)
int
__stdcall
GetLocaleInfoEx(
     LPCWSTR lpLocaleName,
     LCTYPE LCType,
     LPWSTR lpLCData,
     int cchData
);

#line 2819 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winnls.h"
#pragma endregion

#pragma region Desktop or PC Family or OneCore Family


__declspec(dllimport)
int
__stdcall
GetCalendarInfoEx(
     LPCWSTR lpLocaleName,
     CALID Calendar,
     LPCWSTR lpReserved,
     CALTYPE CalType,
     LPWSTR lpCalData,
     int cchData,
     LPDWORD lpValue
);

#line 2838 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winnls.h"
#pragma endregion

#pragma region Application Family

















#line 2859 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winnls.h"
#pragma endregion

#pragma region Application Family or OneCore Family


__declspec(dllimport)
int
__stdcall
GetNumberFormatEx(
     LPCWSTR lpLocaleName,
     DWORD dwFlags,
     LPCWSTR lpValue,
     const NUMBERFMTW *lpFormat,
     LPWSTR lpNumberStr,
     int cchNumber
);

__declspec(dllimport)
int
__stdcall
GetCurrencyFormatEx(
     LPCWSTR lpLocaleName,
     DWORD dwFlags,
     LPCWSTR lpValue,
     const CURRENCYFMTW *lpFormat,
     LPWSTR lpCurrencyStr,
     int cchCurrency
);

__declspec(dllimport)
int
__stdcall
GetUserDefaultLocaleName(
     LPWSTR lpLocaleName,
     int cchLocaleName
);

#line 2897 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winnls.h"
#pragma endregion

#pragma region Desktop or PC Family or OneCore Family


__declspec(dllimport)
int
__stdcall
GetSystemDefaultLocaleName(
     LPWSTR lpLocaleName,
     int cchLocaleName
);

__declspec(dllimport)
BOOL
__stdcall
IsNLSDefinedString(
     NLS_FUNCTION     Function,
     DWORD            dwFlags,
     LPNLSVERSIONINFO lpVersionInformation,
     LPCWSTR          lpString,
     INT              cchStr);

__declspec(dllimport)
BOOL
__stdcall
GetNLSVersionEx(
    	    NLS_FUNCTION function,
        LPCWSTR lpLocaleName,
    	    LPNLSVERSIONINFOEX lpVersionInformation
);










#line 2939 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winnls.h"

#line 2941 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winnls.h"
#pragma endregion

#pragma region Application Family or OneCore or Gamaes Family


__declspec(dllimport)
int
__stdcall
FindNLSStringEx(
     LPCWSTR lpLocaleName,
     DWORD dwFindNLSStringFlags,
     LPCWSTR lpStringSource,
     int cchSource,
     LPCWSTR lpStringValue,
     int cchValue,
     LPINT pcchFound,
     LPNLSVERSIONINFO lpVersionInformation,
     LPVOID lpReserved,
     LPARAM sortHandle
);



#line 2965 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winnls.h"

#line 2967 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winnls.h"


__declspec(dllimport)
int
__stdcall
LCMapStringEx(
     LPCWSTR lpLocaleName,
     DWORD dwMapFlags,
     LPCWSTR lpSrcStr,
     int cchSrc,
     LPWSTR lpDestStr,
     int cchDest,
     LPNLSVERSIONINFO lpVersionInformation,
     LPVOID lpReserved,
     LPARAM sortHandle
);

__declspec(dllimport)
BOOL
__stdcall
IsValidLocaleName(
     LPCWSTR lpLocaleName
);

#line 2992 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winnls.h"
#pragma endregion

#pragma region Desktop or PC Family or OneCore Family


typedef BOOL (__stdcall * CALINFO_ENUMPROCEXEX)(LPWSTR, CALID, LPWSTR, LPARAM);

__declspec(dllimport)
BOOL
__stdcall
EnumCalendarInfoExEx(
     CALINFO_ENUMPROCEXEX pCalInfoEnumProcExEx,
     LPCWSTR lpLocaleName,
     CALID Calendar,
     LPCWSTR lpReserved,
     CALTYPE CalType,
     LPARAM lParam
);

typedef BOOL (__stdcall * DATEFMT_ENUMPROCEXEX)(LPWSTR, CALID, LPARAM);

__declspec(dllimport)
BOOL
__stdcall
EnumDateFormatsExEx(
     DATEFMT_ENUMPROCEXEX lpDateFmtEnumProcExEx,
     LPCWSTR lpLocaleName,
     DWORD dwFlags,
     LPARAM lParam
);

typedef BOOL (__stdcall * TIMEFMT_ENUMPROCEX)(LPWSTR, LPARAM);

__declspec(dllimport)
BOOL
__stdcall
EnumTimeFormatsEx(
     TIMEFMT_ENUMPROCEX lpTimeFmtEnumProcEx,
     LPCWSTR lpLocaleName,
     DWORD dwFlags,
     LPARAM lParam
);

#line 3036 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winnls.h"
#pragma endregion

#pragma region Desktop or PC Family or OneCore or Games Family


typedef BOOL (__stdcall * LOCALE_ENUMPROCEX)(LPWSTR, DWORD, LPARAM);

__declspec(dllimport)
BOOL
__stdcall
EnumSystemLocalesEx(
     LOCALE_ENUMPROCEX lpLocaleEnumProcEx,
     DWORD dwFlags,
     LPARAM lParam,
     LPVOID lpReserved
);

#line 3054 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winnls.h"
#pragma endregion

#line 3057 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winnls.h"



#pragma region Application Family or OneCore or Games Family


__declspec(dllimport)
int
__stdcall
ResolveLocaleName(
                            LPCWSTR lpNameToResolve,
     LPWSTR  lpLocaleName,
                                int     cchLocaleName
);

#line 3073 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winnls.h"
#pragma endregion

#line 3076 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winnls.h"

#pragma region Desktop Family


    
#line 3082 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winnls.h"
#pragma endregion

#line 3085 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winnls.h"


// Restore the original value of the 'DEPRECATED' macro");



#pragma warning(pop)
#line 3093 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winnls.h"


}
#line 3097 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winnls.h"


#line 3100 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winnls.h"
#line 177 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\Windows.h"
#line 178 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\Windows.h"

#line 1 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\wincon.h"


/*++ BUILD Version: 0002    // Increment this if a change has global effects

Copyright (c) Microsoft Corporation. All rights reserved.

Module Name:

    wincon.h

Abstract:

    This module contains the public data structures, data types,
    and procedures exported by the NT console subsystem.

Created:

    26-Oct-1990

Revision History:

--*/




#pragma once


extern "C" {
#line 32 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\wincon.h"


#pragma warning(push)
#pragma warning(disable:4820) 
#line 37 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\wincon.h"

#line 1 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\wincontypes.h"
/*++

Copyright (c) Microsoft Corporation. All rights reserved.

Module Name:

    wincontypes.h

Abstract:

    This module contains the common data types
    exported by the NT console subsystem.

Created:
    08-Sep-2017

Revision History:
    26-Oct-1990 - Originally created in wincon.h

--*/




#pragma once




extern "C" {
#line 32 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\wincontypes.h"

#pragma region Application Family


typedef struct _COORD {
    SHORT X;
    SHORT Y;
} COORD, *PCOORD;

typedef struct _SMALL_RECT {
    SHORT Left;
    SHORT Top;
    SHORT Right;
    SHORT Bottom;
} SMALL_RECT, *PSMALL_RECT;

typedef struct _KEY_EVENT_RECORD {
    BOOL bKeyDown;
    WORD wRepeatCount;
    WORD wVirtualKeyCode;
    WORD wVirtualScanCode;
    union {
        WCHAR UnicodeChar;
        CHAR   AsciiChar;
    } uChar;
    DWORD dwControlKeyState;
} KEY_EVENT_RECORD, *PKEY_EVENT_RECORD;

//
// ControlKeyState flags
//



















typedef struct _MOUSE_EVENT_RECORD {
    COORD dwMousePosition;
    DWORD dwButtonState;
    DWORD dwControlKeyState;
    DWORD dwEventFlags;
} MOUSE_EVENT_RECORD, *PMOUSE_EVENT_RECORD;

//
// ButtonState flags
//







//
// EventFlags
//






#line 109 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\wincontypes.h"

typedef struct _WINDOW_BUFFER_SIZE_RECORD {
    COORD dwSize;
} WINDOW_BUFFER_SIZE_RECORD, *PWINDOW_BUFFER_SIZE_RECORD;

typedef struct _MENU_EVENT_RECORD {
    UINT dwCommandId;
} MENU_EVENT_RECORD, *PMENU_EVENT_RECORD;

typedef struct _FOCUS_EVENT_RECORD {
    BOOL bSetFocus;
} FOCUS_EVENT_RECORD, *PFOCUS_EVENT_RECORD;

typedef struct _INPUT_RECORD {
    WORD EventType;
    union {
        KEY_EVENT_RECORD KeyEvent;
        MOUSE_EVENT_RECORD MouseEvent;
        WINDOW_BUFFER_SIZE_RECORD WindowBufferSizeEvent;
        MENU_EVENT_RECORD MenuEvent;
        FOCUS_EVENT_RECORD FocusEvent;
    } Event;
} INPUT_RECORD, *PINPUT_RECORD;

//
//  EventType flags:
//







typedef struct _CHAR_INFO {
    union {
        WCHAR UnicodeChar;
        CHAR   AsciiChar;
    } Char;
    WORD Attributes;
} CHAR_INFO, *PCHAR_INFO;

typedef struct _CONSOLE_FONT_INFO {
    DWORD  nFont;
    COORD  dwFontSize;
} CONSOLE_FONT_INFO, *PCONSOLE_FONT_INFO;

typedef void * HPCON;

#line 159 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\wincontypes.h"
#pragma endregion


}
#line 164 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\wincontypes.h"

#line 166 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\wincontypes.h"
#line 39 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\wincon.h"




#line 44 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\wincon.h"


#line 1 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\consoleapi.h"
// begin_consoleapi_h
/********************************************************************************
*                                                                               *
* consoleapi.h -- ApiSet Contract for api-ms-win-core-console-l1                *
*                                                                               *
* Copyright (c) Microsoft Corporation. All rights reserved.                     *
*                                                                               *
********************************************************************************/


#pragma once
#line 13 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\consoleapi.h"












extern "C" {
#line 27 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\consoleapi.h"

#pragma region Application Family or OneCore Family


__declspec(dllimport)
BOOL
__stdcall
AllocConsole(
    void
    );


__declspec(dllimport)
BOOL
__stdcall
FreeConsole(
    void
    );




__declspec(dllimport)
BOOL
__stdcall
AttachConsole(
     DWORD dwProcessId
    );




#line 60 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\consoleapi.h"

__declspec(dllimport)
UINT
__stdcall
GetConsoleCP(
    void
    );


__declspec(dllimport)
UINT
__stdcall
GetConsoleOutputCP(
    void
    );


//
// Input Mode flags:
//












//
// Output Mode flags:
//







__declspec(dllimport)
BOOL
__stdcall
GetConsoleMode(
     HANDLE hConsoleHandle,
     LPDWORD lpMode
    );


__declspec(dllimport)
BOOL
__stdcall
SetConsoleMode(
     HANDLE hConsoleHandle,
     DWORD dwMode
    );


__declspec(dllimport)
BOOL
__stdcall
GetNumberOfConsoleInputEvents(
     HANDLE hConsoleInput,
     LPDWORD lpNumberOfEvents
    );


__declspec(dllimport)

BOOL
__stdcall
ReadConsoleInputA(
     HANDLE hConsoleInput,
     PINPUT_RECORD lpBuffer,
     DWORD nLength,
      LPDWORD lpNumberOfEventsRead
    );

__declspec(dllimport)

BOOL
__stdcall
ReadConsoleInputW(
     HANDLE hConsoleInput,
     PINPUT_RECORD lpBuffer,
     DWORD nLength,
      LPDWORD lpNumberOfEventsRead
    );





#line 156 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\consoleapi.h"

// end_consoleapi_h





#line 164 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\consoleapi.h"

// begin_consoleapi_h

__declspec(dllimport)
BOOL
__stdcall
PeekConsoleInputA(
     HANDLE hConsoleInput,
     PINPUT_RECORD lpBuffer,
     DWORD nLength,
     LPDWORD lpNumberOfEventsRead
    );

__declspec(dllimport)
BOOL
__stdcall
PeekConsoleInputW(
     HANDLE hConsoleInput,
     PINPUT_RECORD lpBuffer,
     DWORD nLength,
     LPDWORD lpNumberOfEventsRead
    );





#line 192 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\consoleapi.h"

typedef struct _CONSOLE_READCONSOLE_CONTROL {
    ULONG nLength;
    ULONG nInitialChars;
    ULONG dwCtrlWakeupMask;
    ULONG dwControlKeyState;
} CONSOLE_READCONSOLE_CONTROL, *PCONSOLE_READCONSOLE_CONTROL;

__declspec(dllimport)

BOOL
__stdcall
ReadConsoleA(
     HANDLE hConsoleInput,
     LPVOID lpBuffer,
     DWORD nNumberOfCharsToRead,
      LPDWORD lpNumberOfCharsRead,
     PCONSOLE_READCONSOLE_CONTROL pInputControl
    );

__declspec(dllimport)

BOOL
__stdcall
ReadConsoleW(
     HANDLE hConsoleInput,
     LPVOID lpBuffer,
     DWORD nNumberOfCharsToRead,
      LPDWORD lpNumberOfCharsRead,
     PCONSOLE_READCONSOLE_CONTROL pInputControl
    );





#line 229 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\consoleapi.h"

__declspec(dllimport)
BOOL
__stdcall
WriteConsoleA(
     HANDLE hConsoleOutput,
     const void * lpBuffer,
     DWORD nNumberOfCharsToWrite,
     LPDWORD lpNumberOfCharsWritten,
     LPVOID lpReserved
    );

__declspec(dllimport)
BOOL
__stdcall
WriteConsoleW(
     HANDLE hConsoleOutput,
     const void * lpBuffer,
     DWORD nNumberOfCharsToWrite,
     LPDWORD lpNumberOfCharsWritten,
     LPVOID lpReserved
    );





#line 257 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\consoleapi.h"

//
// Ctrl Event flags
//




// 3 is reserved!
// 4 is reserved!



//
// typedef for ctrl-c handler routines
//

typedef
BOOL
(__stdcall *PHANDLER_ROUTINE)(
     DWORD CtrlType
    );

__declspec(dllimport)
BOOL
__stdcall
SetConsoleCtrlHandler(
     PHANDLER_ROUTINE HandlerRoutine,
     BOOL Add
    );



#line 291 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\consoleapi.h"
#pragma endregion

#pragma region Desktop Family or OneCore Family




































#line 331 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\consoleapi.h"

#line 333 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\consoleapi.h"
#pragma endregion


}
#line 338 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\consoleapi.h"

#line 340 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\consoleapi.h"
// end_consoleapi_h
#line 47 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\wincon.h"
#line 1 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\consoleapi2.h"
/********************************************************************************
*                                                                               *
* consoleapi2.h -- ApiSet Contract for api-ms-win-core-console-l2                *
*                                                                               *
* Copyright (c) Microsoft Corporation. All rights reserved.                     *
*                                                                               *
********************************************************************************/


#pragma once
#line 12 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\consoleapi2.h"













extern "C" {
#line 27 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\consoleapi2.h"

#pragma region Application Family or OneCore Family


//
// Attributes flags:
//



















__declspec(dllimport)
BOOL
__stdcall
FillConsoleOutputCharacterA(
     HANDLE hConsoleOutput,
     CHAR cCharacter,
     DWORD nLength,
     COORD dwWriteCoord,
     LPDWORD lpNumberOfCharsWritten
    );

__declspec(dllimport)
BOOL
__stdcall
FillConsoleOutputCharacterW(
     HANDLE hConsoleOutput,
     WCHAR cCharacter,
     DWORD nLength,
     COORD dwWriteCoord,
     LPDWORD lpNumberOfCharsWritten
    );





#line 80 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\consoleapi2.h"

__declspec(dllimport)
BOOL
__stdcall
FillConsoleOutputAttribute(
     HANDLE hConsoleOutput,
     WORD wAttribute,
     DWORD nLength,
     COORD dwWriteCoord,
     LPDWORD lpNumberOfAttrsWritten
    );


__declspec(dllimport)
BOOL
__stdcall
GenerateConsoleCtrlEvent(
     DWORD dwCtrlEvent,
     DWORD dwProcessGroupId
    );


__declspec(dllimport)
HANDLE
__stdcall
CreateConsoleScreenBuffer(
     DWORD dwDesiredAccess,
     DWORD dwShareMode,
     const SECURITY_ATTRIBUTES* lpSecurityAttributes,
     DWORD dwFlags,
     LPVOID lpScreenBufferData
    );


__declspec(dllimport)
BOOL
__stdcall
SetConsoleActiveScreenBuffer(
     HANDLE hConsoleOutput
    );


__declspec(dllimport)
BOOL
__stdcall
FlushConsoleInputBuffer(
     HANDLE hConsoleInput
    );


__declspec(dllimport)
BOOL
__stdcall
SetConsoleCP(
     UINT wCodePageID
    );


__declspec(dllimport)
BOOL
__stdcall
SetConsoleOutputCP(
     UINT wCodePageID
    );


typedef struct _CONSOLE_CURSOR_INFO {
    DWORD  dwSize;
    BOOL   bVisible;
} CONSOLE_CURSOR_INFO, *PCONSOLE_CURSOR_INFO;

__declspec(dllimport)
BOOL
__stdcall
GetConsoleCursorInfo(
     HANDLE hConsoleOutput,
     PCONSOLE_CURSOR_INFO lpConsoleCursorInfo
    );


__declspec(dllimport)
BOOL
__stdcall
SetConsoleCursorInfo(
     HANDLE hConsoleOutput,
     const CONSOLE_CURSOR_INFO* lpConsoleCursorInfo
    );


typedef struct _CONSOLE_SCREEN_BUFFER_INFO {
    COORD dwSize;
    COORD dwCursorPosition;
    WORD  wAttributes;
    SMALL_RECT srWindow;
    COORD dwMaximumWindowSize;
} CONSOLE_SCREEN_BUFFER_INFO, *PCONSOLE_SCREEN_BUFFER_INFO;

__declspec(dllimport)
BOOL
__stdcall
GetConsoleScreenBufferInfo(
     HANDLE hConsoleOutput,
     PCONSOLE_SCREEN_BUFFER_INFO lpConsoleScreenBufferInfo
    );


typedef struct _CONSOLE_SCREEN_BUFFER_INFOEX {
    ULONG cbSize;
    COORD dwSize;
    COORD dwCursorPosition;
    WORD wAttributes;
    SMALL_RECT srWindow;
    COORD dwMaximumWindowSize;
    WORD wPopupAttributes;
    BOOL bFullscreenSupported;
    COLORREF ColorTable[16];
} CONSOLE_SCREEN_BUFFER_INFOEX, *PCONSOLE_SCREEN_BUFFER_INFOEX;

__declspec(dllimport)
BOOL
__stdcall
GetConsoleScreenBufferInfoEx(
     HANDLE hConsoleOutput,
     PCONSOLE_SCREEN_BUFFER_INFOEX lpConsoleScreenBufferInfoEx
    );


__declspec(dllimport)
BOOL
__stdcall
SetConsoleScreenBufferInfoEx(
     HANDLE hConsoleOutput,
     PCONSOLE_SCREEN_BUFFER_INFOEX lpConsoleScreenBufferInfoEx
    );


__declspec(dllimport)
BOOL
__stdcall
SetConsoleScreenBufferSize(
     HANDLE hConsoleOutput,
     COORD dwSize
    );


__declspec(dllimport)
BOOL
__stdcall
SetConsoleCursorPosition(
     HANDLE hConsoleOutput,
     COORD dwCursorPosition
    );


__declspec(dllimport)
COORD
__stdcall
GetLargestConsoleWindowSize(
     HANDLE hConsoleOutput
    );


__declspec(dllimport)
BOOL
__stdcall
SetConsoleTextAttribute(
     HANDLE hConsoleOutput,
     WORD wAttributes
    );


__declspec(dllimport)
BOOL
__stdcall
SetConsoleWindowInfo(
     HANDLE hConsoleOutput,
     BOOL bAbsolute,
     const SMALL_RECT* lpConsoleWindow
    );


__declspec(dllimport)
BOOL
__stdcall
WriteConsoleOutputCharacterA(
     HANDLE hConsoleOutput,
     LPCSTR lpCharacter,
     DWORD nLength,
     COORD dwWriteCoord,
     LPDWORD lpNumberOfCharsWritten
    );

__declspec(dllimport)
BOOL
__stdcall
WriteConsoleOutputCharacterW(
     HANDLE hConsoleOutput,
     LPCWSTR lpCharacter,
     DWORD nLength,
     COORD dwWriteCoord,
     LPDWORD lpNumberOfCharsWritten
    );





#line 288 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\consoleapi2.h"

__declspec(dllimport)
BOOL
__stdcall
WriteConsoleOutputAttribute(
     HANDLE hConsoleOutput,
     const WORD* lpAttribute,
     DWORD nLength,
     COORD dwWriteCoord,
     LPDWORD lpNumberOfAttrsWritten
    );


__declspec(dllimport)
BOOL
__stdcall
ReadConsoleOutputCharacterA(
     HANDLE hConsoleOutput,
     LPSTR lpCharacter,
     DWORD nLength,
     COORD dwReadCoord,
     LPDWORD lpNumberOfCharsRead
    );

__declspec(dllimport)
BOOL
__stdcall
ReadConsoleOutputCharacterW(
     HANDLE hConsoleOutput,
     LPWSTR lpCharacter,
     DWORD nLength,
     COORD dwReadCoord,
     LPDWORD lpNumberOfCharsRead
    );





#line 328 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\consoleapi2.h"

__declspec(dllimport)
BOOL
__stdcall
ReadConsoleOutputAttribute(
     HANDLE hConsoleOutput,
     LPWORD lpAttribute,
     DWORD nLength,
     COORD dwReadCoord,
     LPDWORD lpNumberOfAttrsRead
    );


__declspec(dllimport)
BOOL
__stdcall
WriteConsoleInputA(
     HANDLE hConsoleInput,
     const INPUT_RECORD* lpBuffer,
     DWORD nLength,
     LPDWORD lpNumberOfEventsWritten
    );

__declspec(dllimport)
BOOL
__stdcall
WriteConsoleInputW(
     HANDLE hConsoleInput,
     const INPUT_RECORD* lpBuffer,
     DWORD nLength,
     LPDWORD lpNumberOfEventsWritten
    );





#line 366 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\consoleapi2.h"

__declspec(dllimport)
BOOL
__stdcall
ScrollConsoleScreenBufferA(
     HANDLE hConsoleOutput,
     const SMALL_RECT* lpScrollRectangle,
     const SMALL_RECT* lpClipRectangle,
     COORD dwDestinationOrigin,
     const CHAR_INFO* lpFill
    );

__declspec(dllimport)
BOOL
__stdcall
ScrollConsoleScreenBufferW(
     HANDLE hConsoleOutput,
     const SMALL_RECT* lpScrollRectangle,
     const SMALL_RECT* lpClipRectangle,
     COORD dwDestinationOrigin,
     const CHAR_INFO* lpFill
    );





#line 394 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\consoleapi2.h"

__declspec(dllimport)
BOOL
__stdcall
WriteConsoleOutputA(
     HANDLE hConsoleOutput,
     const CHAR_INFO* lpBuffer,
     COORD dwBufferSize,
     COORD dwBufferCoord,
     PSMALL_RECT lpWriteRegion
    );

__declspec(dllimport)
BOOL
__stdcall
WriteConsoleOutputW(
     HANDLE hConsoleOutput,
     const CHAR_INFO* lpBuffer,
     COORD dwBufferSize,
     COORD dwBufferCoord,
     PSMALL_RECT lpWriteRegion
    );





#line 422 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\consoleapi2.h"

__declspec(dllimport)
BOOL
__stdcall
ReadConsoleOutputA(
     HANDLE hConsoleOutput,
     PCHAR_INFO lpBuffer,
     COORD dwBufferSize,
     COORD dwBufferCoord,
     PSMALL_RECT lpReadRegion
    );

__declspec(dllimport)
BOOL
__stdcall
ReadConsoleOutputW(
     HANDLE hConsoleOutput,
     PCHAR_INFO lpBuffer,
     COORD dwBufferSize,
     COORD dwBufferCoord,
     PSMALL_RECT lpReadRegion
    );





#line 450 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\consoleapi2.h"


__declspec(dllimport)
DWORD
__stdcall
GetConsoleTitleA(
     LPSTR lpConsoleTitle,
     DWORD nSize
    );

__declspec(dllimport)
DWORD
__stdcall
GetConsoleTitleW(
     LPWSTR lpConsoleTitle,
     DWORD nSize
    );





#line 473 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\consoleapi2.h"



__declspec(dllimport)
DWORD
__stdcall
GetConsoleOriginalTitleA(
     LPSTR lpConsoleTitle,
     DWORD nSize
    );

__declspec(dllimport)
DWORD
__stdcall
GetConsoleOriginalTitleW(
     LPWSTR lpConsoleTitle,
     DWORD nSize
    );





#line 497 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\consoleapi2.h"
    
#line 499 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\consoleapi2.h"

__declspec(dllimport)
BOOL
__stdcall
SetConsoleTitleA(
     LPCSTR lpConsoleTitle
    );

__declspec(dllimport)
BOOL
__stdcall
SetConsoleTitleW(
     LPCWSTR lpConsoleTitle
    );





#line 519 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\consoleapi2.h"

#line 521 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\consoleapi2.h"
#pragma endregion


}
#line 526 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\consoleapi2.h"

#line 528 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\consoleapi2.h"
#line 48 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\wincon.h"
#line 1 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\consoleapi3.h"
/********************************************************************************
*                                                                               *
* consoleapi3.h -- ApiSet Contract for api-ms-win-core-console-l3                                *
*                                                                               *
* Copyright (c) Microsoft Corporation. All rights reserved.                     *
*                                                                               *
********************************************************************************/


#pragma once
#line 12 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\consoleapi3.h"














#line 27 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\consoleapi3.h"


extern "C" {
#line 31 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\consoleapi3.h"

#pragma region Application Family or OneCore Family


__declspec(dllimport)
BOOL
__stdcall
GetNumberOfConsoleMouseButtons(
     LPDWORD lpNumberOfMouseButtons
    );




__declspec(dllimport)
COORD
__stdcall
GetConsoleFontSize(
     HANDLE hConsoleOutput,
     DWORD nFont
    );


__declspec(dllimport)
BOOL
__stdcall
GetCurrentConsoleFont(
     HANDLE hConsoleOutput,
     BOOL bMaximumWindow,
     PCONSOLE_FONT_INFO lpConsoleCurrentFont
    );




typedef struct _CONSOLE_FONT_INFOEX {
    ULONG cbSize;
    DWORD nFont;
    COORD dwFontSize;
    UINT FontFamily;
    UINT FontWeight;
    WCHAR FaceName[32 ];
} CONSOLE_FONT_INFOEX, *PCONSOLE_FONT_INFOEX;

__declspec(dllimport)
BOOL
__stdcall
GetCurrentConsoleFontEx(
     HANDLE hConsoleOutput,
     BOOL bMaximumWindow,
     PCONSOLE_FONT_INFOEX lpConsoleCurrentFontEx
    );


__declspec(dllimport)
BOOL
__stdcall
SetCurrentConsoleFontEx(
     HANDLE hConsoleOutput,
     BOOL bMaximumWindow,
     PCONSOLE_FONT_INFOEX lpConsoleCurrentFontEx
    );


#line 96 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\consoleapi3.h"

//
// Selection flags
//







typedef struct _CONSOLE_SELECTION_INFO {
    DWORD dwFlags;
    COORD dwSelectionAnchor;
    SMALL_RECT srSelection;
} CONSOLE_SELECTION_INFO, *PCONSOLE_SELECTION_INFO;

__declspec(dllimport)
BOOL
__stdcall
GetConsoleSelectionInfo(
     PCONSOLE_SELECTION_INFO lpConsoleSelectionInfo
    );


//
// History flags
//



typedef struct _CONSOLE_HISTORY_INFO {
    UINT cbSize;
    UINT HistoryBufferSize;
    UINT NumberOfHistoryBuffers;
    DWORD dwFlags;
} CONSOLE_HISTORY_INFO, *PCONSOLE_HISTORY_INFO;

__declspec(dllimport)
BOOL
__stdcall
GetConsoleHistoryInfo(
     PCONSOLE_HISTORY_INFO lpConsoleHistoryInfo
    );


__declspec(dllimport)
BOOL
__stdcall
SetConsoleHistoryInfo(
     PCONSOLE_HISTORY_INFO lpConsoleHistoryInfo
    );





__declspec(dllimport)
BOOL
__stdcall
GetConsoleDisplayMode(
     LPDWORD lpModeFlags
    );





__declspec(dllimport)
BOOL
__stdcall
SetConsoleDisplayMode(
     HANDLE hConsoleOutput,
     DWORD dwFlags,
     PCOORD lpNewScreenBufferDimensions
    );

    
__declspec(dllimport)
HWND
__stdcall
GetConsoleWindow(
    void
    );


#line 183 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\consoleapi3.h"



__declspec(dllimport)
BOOL
__stdcall
AddConsoleAliasA(
     LPSTR Source,
     LPSTR Target,
     LPSTR ExeName
    );

__declspec(dllimport)
BOOL
__stdcall
AddConsoleAliasW(
     LPWSTR Source,
     LPWSTR Target,
     LPWSTR ExeName
    );





#line 209 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\consoleapi3.h"

__declspec(dllimport)
DWORD
__stdcall
GetConsoleAliasA(
     LPSTR Source,
     LPSTR TargetBuffer,
     DWORD TargetBufferLength,
     LPSTR ExeName
    );

__declspec(dllimport)
DWORD
__stdcall
GetConsoleAliasW(
     LPWSTR Source,
     LPWSTR TargetBuffer,
     DWORD TargetBufferLength,
     LPWSTR ExeName
    );





#line 235 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\consoleapi3.h"

__declspec(dllimport)
DWORD
__stdcall
GetConsoleAliasesLengthA(
     LPSTR ExeName
    );

__declspec(dllimport)
DWORD
__stdcall
GetConsoleAliasesLengthW(
     LPWSTR ExeName
    );





#line 255 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\consoleapi3.h"

__declspec(dllimport)
DWORD
__stdcall
GetConsoleAliasExesLengthA(
    void
    );

__declspec(dllimport)
DWORD
__stdcall
GetConsoleAliasExesLengthW(
    void
    );





#line 275 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\consoleapi3.h"

__declspec(dllimport)
DWORD
__stdcall
GetConsoleAliasesA(
     LPSTR AliasBuffer,
     DWORD AliasBufferLength,
     LPSTR ExeName
    );

__declspec(dllimport)
DWORD
__stdcall
GetConsoleAliasesW(
     LPWSTR AliasBuffer,
     DWORD AliasBufferLength,
     LPWSTR ExeName
    );





#line 299 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\consoleapi3.h"

__declspec(dllimport)
DWORD
__stdcall
GetConsoleAliasExesA(
     LPSTR ExeNameBuffer,
     DWORD ExeNameBufferLength
    );

__declspec(dllimport)
DWORD
__stdcall
GetConsoleAliasExesW(
     LPWSTR ExeNameBuffer,
     DWORD ExeNameBufferLength
    );





#line 321 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\consoleapi3.h"

#line 323 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\consoleapi3.h"

__declspec(dllimport)
void
__stdcall
ExpungeConsoleCommandHistoryA(
     LPSTR ExeName
    );

__declspec(dllimport)
void
__stdcall
ExpungeConsoleCommandHistoryW(
     LPWSTR ExeName
    );





#line 343 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\consoleapi3.h"

__declspec(dllimport)
BOOL
__stdcall
SetConsoleNumberOfCommandsA(
     DWORD Number,
     LPSTR ExeName
    );

__declspec(dllimport)
BOOL
__stdcall
SetConsoleNumberOfCommandsW(
     DWORD Number,
     LPWSTR ExeName
    );





#line 365 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\consoleapi3.h"

__declspec(dllimport)
DWORD
__stdcall
GetConsoleCommandHistoryLengthA(
     LPSTR ExeName
    );

__declspec(dllimport)
DWORD
__stdcall
GetConsoleCommandHistoryLengthW(
     LPWSTR ExeName
    );





#line 385 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\consoleapi3.h"

__declspec(dllimport)
DWORD
__stdcall
GetConsoleCommandHistoryA(
     LPSTR Commands,
     DWORD CommandBufferLength,
     LPSTR ExeName
    );

__declspec(dllimport)
DWORD
__stdcall
GetConsoleCommandHistoryW(
     LPWSTR Commands,
     DWORD CommandBufferLength,
     LPWSTR ExeName
    );





#line 409 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\consoleapi3.h"



__declspec(dllimport)
DWORD
__stdcall
GetConsoleProcessList(
     LPDWORD lpdwProcessList,
     DWORD dwProcessCount
    );


#line 422 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\consoleapi3.h"

#line 424 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\consoleapi3.h"
#pragma endregion
    

}
#line 429 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\consoleapi3.h"

#line 431 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\consoleapi3.h"
#line 49 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\wincon.h"
#line 50 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\wincon.h"







#line 58 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\wincon.h"



#pragma warning(pop)
#line 63 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\wincon.h"


}
#line 67 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\wincon.h"

#line 69 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\wincon.h"

#line 180 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\Windows.h"
#line 1 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winver.h"


/****************************************************************************
**                                                                             *
* winver.h -    Version management functions, types, and definitions          *
*                                                                             *
*               Include file for VER.DLL.  This library is                    *
*               designed to allow version stamping of Windows executable files*
*               and of special .VER files for DOS executable files.           *
*                                                                             *
*               Copyright (c) Microsoft Corporation. All rights reserved.     *
*                                                                             *
\*****************************************************************************/





#line 1 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\verrsrc.h"


/****************************************************************************
**                                                                             *
* verrsrc.h -   Version Resource definitions                                  *
*                                                                             *
*               Include file declaring version resources in rc files          *
*                                                                             *
*               Copyright (c) Microsoft Corporation. All rights reserved.     *
*                                                                             *
\*****************************************************************************/

#pragma region Application Family or OneCore Family


/* ----- Symbols ----- */




/* ----- VS_VERSION.dwFileFlags ----- */




#line 27 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\verrsrc.h"



/* ----- VS_VERSION.dwFileFlags ----- */







/* ----- VS_VERSION.dwFileOS ----- */



















/* ----- VS_VERSION.dwFileType ----- */








/* ----- VS_VERSION.dwFileSubtype for VFT_WINDOWS_DRV ----- */














/* ----- VS_VERSION.dwFileSubtype for VFT_WINDOWS_FONT ----- */




#line 88 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\verrsrc.h"
#pragma endregion

#pragma region Desktop Family or OneCore Family or Games Family


/* ----- VerFindFile() flags ----- */






/* ----- VerInstallFile() flags ----- */
































extern "C" {
#line 135 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\verrsrc.h"
    
/* 
    FILE_VER_GET_... flags are for use by 
    GetFileVersionInfoSizeEx
    GetFileVersionInfoExW
*/




/* ----- Types and structures ----- */

typedef struct tagVS_FIXEDFILEINFO
{
    DWORD   dwSignature;            /* e.g. 0xfeef04bd */
    DWORD   dwStrucVersion;         /* e.g. 0x00000042 = "0.42" */
    DWORD   dwFileVersionMS;        /* e.g. 0x00030075 = "3.75" */
    DWORD   dwFileVersionLS;        /* e.g. 0x00000031 = "0.31" */
    DWORD   dwProductVersionMS;     /* e.g. 0x00030010 = "3.10" */
    DWORD   dwProductVersionLS;     /* e.g. 0x00000031 = "0.31" */
    DWORD   dwFileFlagsMask;        /* = 0x3F for version "0.42" */
    DWORD   dwFileFlags;            /* e.g. VFF_DEBUG | VFF_PRERELEASE */
    DWORD   dwFileOS;               /* e.g. VOS_DOS_WINDOWS16 */
    DWORD   dwFileType;             /* e.g. VFT_DRIVER */
    DWORD   dwFileSubtype;          /* e.g. VFT2_DRV_KEYBOARD */
    DWORD   dwFileDateMS;           /* e.g. 0 */
    DWORD   dwFileDateLS;           /* e.g. 0 */
} VS_FIXEDFILEINFO;


}
#line 167 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\verrsrc.h"

#line 169 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\verrsrc.h"

#line 171 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\verrsrc.h"
#pragma endregion

#line 20 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winver.h"



extern "C" {
#line 25 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winver.h"

#pragma region Desktop Family or OneCore Family





/* ----- Function prototypes ----- */

DWORD
__stdcall
VerFindFileA(
                                 DWORD uFlags,
                                 LPCSTR szFileName,
                             LPCSTR szWinDir,
                                 LPCSTR szAppDir,
           LPSTR szCurDir,
                              PUINT puCurDirLen,
          LPSTR szDestDir,
                              PUINT puDestDirLen
        );
DWORD
__stdcall
VerFindFileW(
                                 DWORD uFlags,
                                 LPCWSTR szFileName,
                             LPCWSTR szWinDir,
                                 LPCWSTR szAppDir,
           LPWSTR szCurDir,
                              PUINT puCurDirLen,
          LPWSTR szDestDir,
                              PUINT puDestDirLen
        );




#line 63 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winver.h"

#line 65 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winver.h"

#line 67 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winver.h"
#pragma endregion

#pragma region Desktop Family




DWORD
__stdcall
VerInstallFileA(
                                 DWORD uFlags,
                                 LPCSTR szSrcFileName,
                                 LPCSTR szDestFileName,
                                 LPCSTR szSrcDir,
                                 LPCSTR szDestDir,
                                 LPCSTR szCurDir,
          LPSTR szTmpFile,
                              PUINT puTmpFileLen
        );
DWORD
__stdcall
VerInstallFileW(
                                 DWORD uFlags,
                                 LPCWSTR szSrcFileName,
                                 LPCWSTR szDestFileName,
                                 LPCWSTR szSrcDir,
                                 LPCWSTR szDestDir,
                                 LPCWSTR szCurDir,
          LPWSTR szTmpFile,
                              PUINT puTmpFileLen
        );




#line 103 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winver.h"

#line 105 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winver.h"

#line 107 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winver.h"
#pragma endregion

#pragma region Desktop Family or OneCore Family




/* Returns size of version info in bytes */
DWORD
__stdcall
GetFileVersionInfoSizeA(
                LPCSTR lptstrFilename, /* Filename of version stamped file */
         LPDWORD lpdwHandle       /* Information for use by GetFileVersionInfo */
        );
/* Returns size of version info in bytes */
DWORD
__stdcall
GetFileVersionInfoSizeW(
                LPCWSTR lptstrFilename, /* Filename of version stamped file */
         LPDWORD lpdwHandle       /* Information for use by GetFileVersionInfo */
        );




#line 133 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winver.h"

/* Read version info into buffer */
BOOL
__stdcall
GetFileVersionInfoA(
                        LPCSTR lptstrFilename, /* Filename of version stamped file */
                  DWORD dwHandle,          /* Information from GetFileVersionSize */
                        DWORD dwLen,             /* Length of buffer for info */
         LPVOID lpData            /* Buffer to place the data structure */
        );
/* Read version info into buffer */
BOOL
__stdcall
GetFileVersionInfoW(
                        LPCWSTR lptstrFilename, /* Filename of version stamped file */
                  DWORD dwHandle,          /* Information from GetFileVersionSize */
                        DWORD dwLen,             /* Length of buffer for info */
         LPVOID lpData            /* Buffer to place the data structure */
        );




#line 157 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winver.h"

#line 159 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winver.h"

#line 161 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winver.h"
#pragma endregion

#pragma region Application or OneCore Family




DWORD __stdcall GetFileVersionInfoSizeExA( DWORD dwFlags,  LPCSTR lpwstrFilename,  LPDWORD lpdwHandle);
DWORD __stdcall GetFileVersionInfoSizeExW( DWORD dwFlags,  LPCWSTR lpwstrFilename,  LPDWORD lpdwHandle);




#line 175 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winver.h"

BOOL __stdcall GetFileVersionInfoExA( DWORD dwFlags,
                                     LPCSTR lpwstrFilename,
                                     DWORD dwHandle,
                                     DWORD dwLen,
                                     LPVOID lpData);
BOOL __stdcall GetFileVersionInfoExW( DWORD dwFlags,
                                     LPCWSTR lpwstrFilename,
                                     DWORD dwHandle,
                                     DWORD dwLen,
                                     LPVOID lpData);




#line 191 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winver.h"

#line 193 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winver.h"

#line 195 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winver.h"
#pragma endregion

#pragma region Desktop Family





#line 204 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winver.h"

#line 206 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winver.h"
#pragma endregion

#pragma region Application Family or OneCore Family




DWORD
__stdcall
VerLanguageNameA(
                          DWORD wLang,
         LPSTR szLang,
                          DWORD cchLang
        );
DWORD
__stdcall
VerLanguageNameW(
                          DWORD wLang,
         LPWSTR szLang,
                          DWORD cchLang
        );




#line 232 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winver.h"

BOOL
__stdcall
VerQueryValueA(
         LPCVOID pBlock,
         LPCSTR lpSubBlock,
         LPVOID * lplpBuffer,
         PUINT puLen
        );
BOOL
__stdcall
VerQueryValueW(
         LPCVOID pBlock,
         LPCWSTR lpSubBlock,
         LPVOID * lplpBuffer,
         PUINT puLen
        );




#line 254 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winver.h"


#line 257 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winver.h"

#line 259 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winver.h"
#pragma endregion


}
#line 264 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winver.h"


#line 267 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winver.h"

#line 181 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\Windows.h"
#line 182 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\Windows.h"

#line 1 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winreg.h"
/*++ BUILD Version: 0001    // Increment this if a change has global effects

Copyright (c) Microsoft Corporation.  All rights reserved.

Module Name:

    Winreg.h

Abstract:

    This module contains the function prototypes and constant, type and
    structure definitions for the Windows 32-Bit Registry API.

--*/

















extern "C" {
#line 34 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winreg.h"


#pragma warning(push)
#pragma warning(disable:4820) 
#line 39 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winreg.h"

#pragma region Application Family or Desktop Family or OneCore Family







typedef  LONG LSTATUS;

//
// RRF - Registry Routine Flags (for RegGetValue)
//

















#line 71 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winreg.h"




//
// Flags for RegLoadAppKey
//


//
// Requested Key access mask type.
//

typedef ACCESS_MASK REGSAM;

//
// Reserved Key Handles.
//













/*NOINC*/




struct val_context {
    int valuelen;       // the total length of this value
    LPVOID value_context;   // provider's context
    LPVOID val_buff_ptr;    // where in the ouput buffer the value is.
};

typedef struct val_context  *PVALCONTEXT;

typedef struct pvalueA {           // Provider supplied value/context.
    LPSTR   pv_valuename;          // The value name pointer
    int pv_valuelen;
    LPVOID pv_value_context;
    DWORD pv_type;
}PVALUEA,  *PPVALUEA;
typedef struct pvalueW {           // Provider supplied value/context.
    LPWSTR  pv_valuename;          // The value name pointer
    int pv_valuelen;
    LPVOID pv_value_context;
    DWORD pv_type;
}PVALUEW,  *PPVALUEW;




typedef PVALUEA PVALUE;
typedef PPVALUEA PPVALUE;
#line 134 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winreg.h"

typedef
DWORD __cdecl
QUERYHANDLER (LPVOID keycontext, PVALCONTEXT val_list, DWORD num_vals,
          LPVOID outputbuffer, DWORD  *total_outlen, DWORD input_blen);

typedef QUERYHANDLER  *PQUERYHANDLER;

typedef struct provider_info {
    PQUERYHANDLER pi_R0_1val;
    PQUERYHANDLER pi_R0_allvals;
    PQUERYHANDLER pi_R3_1val;
    PQUERYHANDLER pi_R3_allvals;
    DWORD pi_flags;    // capability flags (none defined yet).
    LPVOID pi_key_context;
}REG_PROVIDER;

typedef struct provider_info  *PPROVIDER;

typedef struct value_entA {
    LPSTR   ve_valuename;
    DWORD ve_valuelen;
    DWORD_PTR ve_valueptr;
    DWORD ve_type;
}VALENTA,  *PVALENTA;
typedef struct value_entW {
    LPWSTR  ve_valuename;
    DWORD ve_valuelen;
    DWORD_PTR ve_valueptr;
    DWORD ve_type;
}VALENTW,  *PVALENTW;




typedef VALENTA VALENT;
typedef PVALENTA PVALENT;
#line 172 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winreg.h"

#line 174 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winreg.h"
/*INC*/

#line 177 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winreg.h"

//
// Default values for parameters that do not exist in the Win 3.1
// compatible APIs.
//



#line 186 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winreg.h"
#pragma endregion

#pragma region Desktop Family or OneCore Family


//
// Flags for RegLoadMUIString
//




//
// RegConnectRegistryEx supported flags
//


#line 204 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winreg.h"

//
// API Prototypes.
//

__declspec(dllimport)
LSTATUS
__stdcall
RegCloseKey(
     HKEY hKey
    );


__declspec(dllimport)
LSTATUS
__stdcall
RegOverridePredefKey (
     HKEY hKey,
     HKEY hNewHKey
    );

__declspec(dllimport)
LSTATUS
__stdcall
RegOpenUserClassesRoot(
     HANDLE hToken,
     DWORD dwOptions,
     REGSAM samDesired,
     PHKEY phkResult
    );


__declspec(dllimport)
LSTATUS
__stdcall
RegOpenCurrentUser(
     REGSAM samDesired,
     PHKEY phkResult
    );


__declspec(dllimport)
LSTATUS
__stdcall
RegDisablePredefinedCache(
    void
    );

__declspec(dllimport)
LSTATUS
__stdcall
RegDisablePredefinedCacheEx(
    void
    );


__declspec(dllimport)
LSTATUS
__stdcall
RegConnectRegistryA (
     LPCSTR lpMachineName,
     HKEY hKey,
     PHKEY phkResult
    );
__declspec(dllimport)
LSTATUS
__stdcall
RegConnectRegistryW (
     LPCWSTR lpMachineName,
     HKEY hKey,
     PHKEY phkResult
    );




#line 281 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winreg.h"

__declspec(dllimport)
LSTATUS
__stdcall
RegConnectRegistryExA (
     LPCSTR lpMachineName,
     HKEY hKey,
     ULONG Flags,
     PHKEY phkResult
    );
__declspec(dllimport)
LSTATUS
__stdcall
RegConnectRegistryExW (
     LPCWSTR lpMachineName,
     HKEY hKey,
     ULONG Flags,
     PHKEY phkResult
    );




#line 305 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winreg.h"

__declspec(dllimport)
LSTATUS
__stdcall
RegCreateKeyA (
     HKEY hKey,
     LPCSTR lpSubKey,
     PHKEY phkResult
    );
__declspec(dllimport)
LSTATUS
__stdcall
RegCreateKeyW (
     HKEY hKey,
     LPCWSTR lpSubKey,
     PHKEY phkResult
    );




#line 327 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winreg.h"

__declspec(dllimport)
LSTATUS
__stdcall
RegCreateKeyExA(
     HKEY hKey,
     LPCSTR lpSubKey,
     DWORD Reserved,
     LPSTR lpClass,
     DWORD dwOptions,
     REGSAM samDesired,
     const LPSECURITY_ATTRIBUTES lpSecurityAttributes,
     PHKEY phkResult,
     LPDWORD lpdwDisposition
    );

__declspec(dllimport)
LSTATUS
__stdcall
RegCreateKeyExW(
     HKEY hKey,
     LPCWSTR lpSubKey,
     DWORD Reserved,
     LPWSTR lpClass,
     DWORD dwOptions,
     REGSAM samDesired,
     const LPSECURITY_ATTRIBUTES lpSecurityAttributes,
     PHKEY phkResult,
     LPDWORD lpdwDisposition
    );





#line 363 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winreg.h"

__declspec(dllimport)
LSTATUS
__stdcall
RegCreateKeyTransactedA (
     HKEY hKey,
     LPCSTR lpSubKey,
     DWORD Reserved,
     LPSTR lpClass,
     DWORD dwOptions,
     REGSAM samDesired,
     const LPSECURITY_ATTRIBUTES lpSecurityAttributes,
     PHKEY phkResult,
     LPDWORD lpdwDisposition,
            HANDLE hTransaction,
     PVOID  pExtendedParemeter
    );
__declspec(dllimport)
LSTATUS
__stdcall
RegCreateKeyTransactedW (
     HKEY hKey,
     LPCWSTR lpSubKey,
     DWORD Reserved,
     LPWSTR lpClass,
     DWORD dwOptions,
     REGSAM samDesired,
     const LPSECURITY_ATTRIBUTES lpSecurityAttributes,
     PHKEY phkResult,
     LPDWORD lpdwDisposition,
            HANDLE hTransaction,
     PVOID  pExtendedParemeter
    );




#line 401 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winreg.h"

__declspec(dllimport)
LSTATUS
__stdcall
RegDeleteKeyA (
     HKEY hKey,
     LPCSTR lpSubKey
    );
__declspec(dllimport)
LSTATUS
__stdcall
RegDeleteKeyW (
     HKEY hKey,
     LPCWSTR lpSubKey
    );




#line 421 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winreg.h"

__declspec(dllimport)
LSTATUS
__stdcall
RegDeleteKeyExA(
     HKEY hKey,
     LPCSTR lpSubKey,
     REGSAM samDesired,
     DWORD Reserved
    );

__declspec(dllimport)
LSTATUS
__stdcall
RegDeleteKeyExW(
     HKEY hKey,
     LPCWSTR lpSubKey,
     REGSAM samDesired,
     DWORD Reserved
    );





#line 447 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winreg.h"

__declspec(dllimport)
LSTATUS
__stdcall
RegDeleteKeyTransactedA (
     HKEY hKey,
     LPCSTR lpSubKey,
     REGSAM samDesired,
     DWORD Reserved,
            HANDLE hTransaction,
     PVOID  pExtendedParameter
    );
__declspec(dllimport)
LSTATUS
__stdcall
RegDeleteKeyTransactedW (
     HKEY hKey,
     LPCWSTR lpSubKey,
     REGSAM samDesired,
     DWORD Reserved,
            HANDLE hTransaction,
     PVOID  pExtendedParameter
    );




#line 475 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winreg.h"

__declspec(dllimport)
LONG
__stdcall
RegDisableReflectionKey (
     HKEY hBase
    );

__declspec(dllimport)
LONG
__stdcall
RegEnableReflectionKey (
     HKEY hBase
    );

__declspec(dllimport)
LONG
__stdcall
RegQueryReflectionKey (
     HKEY hBase,
     BOOL *bIsReflectionDisabled
    );

__declspec(dllimport)
LSTATUS
__stdcall
RegDeleteValueA(
     HKEY hKey,
     LPCSTR lpValueName
    );

__declspec(dllimport)
LSTATUS
__stdcall
RegDeleteValueW(
     HKEY hKey,
     LPCWSTR lpValueName
    );





#line 519 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winreg.h"

__declspec(dllimport)
LSTATUS
__stdcall
RegEnumKeyA (
     HKEY hKey,
     DWORD dwIndex,
     LPSTR lpName,
     DWORD cchName
    );
__declspec(dllimport)
LSTATUS
__stdcall
RegEnumKeyW (
     HKEY hKey,
     DWORD dwIndex,
     LPWSTR lpName,
     DWORD cchName
    );




#line 543 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winreg.h"

__declspec(dllimport)
LSTATUS
__stdcall
RegEnumKeyExA(
     HKEY hKey,
     DWORD dwIndex,
     LPSTR lpName,
     LPDWORD lpcchName,
     LPDWORD lpReserved,
     LPSTR lpClass,
     LPDWORD lpcchClass,
     PFILETIME lpftLastWriteTime
    );

__declspec(dllimport)
LSTATUS
__stdcall
RegEnumKeyExW(
     HKEY hKey,
     DWORD dwIndex,
     LPWSTR lpName,
     LPDWORD lpcchName,
     LPDWORD lpReserved,
     LPWSTR lpClass,
     LPDWORD lpcchClass,
     PFILETIME lpftLastWriteTime
    );





#line 577 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winreg.h"

__declspec(dllimport)
LSTATUS
__stdcall
RegEnumValueA(
     HKEY hKey,
     DWORD dwIndex,
     LPSTR lpValueName,
     LPDWORD lpcchValueName,
     LPDWORD lpReserved,
     LPDWORD lpType,
      LPBYTE lpData,
     LPDWORD lpcbData
    );

__declspec(dllimport)
LSTATUS
__stdcall
RegEnumValueW(
     HKEY hKey,
     DWORD dwIndex,
     LPWSTR lpValueName,
     LPDWORD lpcchValueName,
     LPDWORD lpReserved,
     LPDWORD lpType,
      LPBYTE lpData,
     LPDWORD lpcbData
    );





#line 611 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winreg.h"

__declspec(dllimport)
LSTATUS
__stdcall
RegFlushKey(
     HKEY hKey
    );


__declspec(dllimport)
LSTATUS
__stdcall
RegGetKeySecurity(
     HKEY hKey,
     SECURITY_INFORMATION SecurityInformation,
     PSECURITY_DESCRIPTOR pSecurityDescriptor,
     LPDWORD lpcbSecurityDescriptor
    );


__declspec(dllimport)
LSTATUS
__stdcall
RegLoadKeyA(
     HKEY hKey,
     LPCSTR lpSubKey,
     LPCSTR lpFile
    );

__declspec(dllimport)
LSTATUS
__stdcall
RegLoadKeyW(
     HKEY hKey,
     LPCWSTR lpSubKey,
     LPCWSTR lpFile
    );





#line 654 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winreg.h"

__declspec(dllimport)
LSTATUS
__stdcall
RegNotifyChangeKeyValue(
     HKEY hKey,
     BOOL bWatchSubtree,
     DWORD dwNotifyFilter,
     HANDLE hEvent,
     BOOL fAsynchronous
    );


__declspec(dllimport)
LSTATUS
__stdcall
RegOpenKeyA (
     HKEY hKey,
     LPCSTR lpSubKey,
     PHKEY phkResult
    );
__declspec(dllimport)
LSTATUS
__stdcall
RegOpenKeyW (
     HKEY hKey,
     LPCWSTR lpSubKey,
     PHKEY phkResult
    );




#line 688 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winreg.h"

__declspec(dllimport)
LSTATUS
__stdcall
RegOpenKeyExA(
     HKEY hKey,
     LPCSTR lpSubKey,
     DWORD ulOptions,
     REGSAM samDesired,
     PHKEY phkResult
    );

__declspec(dllimport)
LSTATUS
__stdcall
RegOpenKeyExW(
     HKEY hKey,
     LPCWSTR lpSubKey,
     DWORD ulOptions,
     REGSAM samDesired,
     PHKEY phkResult
    );





#line 716 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winreg.h"

__declspec(dllimport)
LSTATUS
__stdcall
RegOpenKeyTransactedA (
     HKEY hKey,
     LPCSTR lpSubKey,
     DWORD ulOptions,
     REGSAM samDesired,
     PHKEY phkResult,
            HANDLE hTransaction,
     PVOID  pExtendedParemeter
    );
__declspec(dllimport)
LSTATUS
__stdcall
RegOpenKeyTransactedW (
     HKEY hKey,
     LPCWSTR lpSubKey,
     DWORD ulOptions,
     REGSAM samDesired,
     PHKEY phkResult,
            HANDLE hTransaction,
     PVOID  pExtendedParemeter
    );




#line 746 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winreg.h"

__declspec(dllimport)
LSTATUS
__stdcall
RegQueryInfoKeyA(
     HKEY hKey,
     LPSTR lpClass,
     LPDWORD lpcchClass,
     LPDWORD lpReserved,
     LPDWORD lpcSubKeys,
     LPDWORD lpcbMaxSubKeyLen,
     LPDWORD lpcbMaxClassLen,
     LPDWORD lpcValues,
     LPDWORD lpcbMaxValueNameLen,
     LPDWORD lpcbMaxValueLen,
     LPDWORD lpcbSecurityDescriptor,
     PFILETIME lpftLastWriteTime
    );

__declspec(dllimport)
LSTATUS
__stdcall
RegQueryInfoKeyW(
     HKEY hKey,
     LPWSTR lpClass,
     LPDWORD lpcchClass,
     LPDWORD lpReserved,
     LPDWORD lpcSubKeys,
     LPDWORD lpcbMaxSubKeyLen,
     LPDWORD lpcbMaxClassLen,
     LPDWORD lpcValues,
     LPDWORD lpcbMaxValueNameLen,
     LPDWORD lpcbMaxValueLen,
     LPDWORD lpcbSecurityDescriptor,
     PFILETIME lpftLastWriteTime
    );





#line 788 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winreg.h"

__declspec(dllimport)
LSTATUS
__stdcall
RegQueryValueA (
     HKEY hKey,
     LPCSTR lpSubKey,
      LPSTR lpData,
     PLONG lpcbData
    );
__declspec(dllimport)
LSTATUS
__stdcall
RegQueryValueW (
     HKEY hKey,
     LPCWSTR lpSubKey,
      LPWSTR lpData,
     PLONG lpcbData
    );




#line 812 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winreg.h"



__declspec(dllimport)
LSTATUS
__stdcall
RegQueryMultipleValuesA(
     HKEY hKey,
     PVALENTA val_list,
     DWORD num_vals,
      LPSTR lpValueBuf,
     LPDWORD ldwTotsize
    );

__declspec(dllimport)
LSTATUS
__stdcall
RegQueryMultipleValuesW(
     HKEY hKey,
     PVALENTW val_list,
     DWORD num_vals,
      LPWSTR lpValueBuf,
     LPDWORD ldwTotsize
    );





#line 842 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winreg.h"

#line 844 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winreg.h"

__declspec(dllimport)
LSTATUS
__stdcall
RegQueryValueExA(
     HKEY hKey,
     LPCSTR lpValueName,
     LPDWORD lpReserved,
     LPDWORD lpType,
      LPBYTE lpData,
      LPDWORD lpcbData
    );

__declspec(dllimport)
LSTATUS
__stdcall
RegQueryValueExW(
     HKEY hKey,
     LPCWSTR lpValueName,
     LPDWORD lpReserved,
     LPDWORD lpType,
      LPBYTE lpData,
      LPDWORD lpcbData
    );





#line 874 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winreg.h"

__declspec(dllimport)
LSTATUS
__stdcall
RegReplaceKeyA (
     HKEY hKey,
     LPCSTR lpSubKey,
     LPCSTR lpNewFile,
     LPCSTR lpOldFile
    );
__declspec(dllimport)
LSTATUS
__stdcall
RegReplaceKeyW (
     HKEY hKey,
     LPCWSTR lpSubKey,
     LPCWSTR lpNewFile,
     LPCWSTR lpOldFile
    );




#line 898 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winreg.h"

__declspec(dllimport)
LSTATUS
__stdcall
RegRestoreKeyA(
     HKEY hKey,
     LPCSTR lpFile,
     DWORD dwFlags
    );

__declspec(dllimport)
LSTATUS
__stdcall
RegRestoreKeyW(
     HKEY hKey,
     LPCWSTR lpFile,
     DWORD dwFlags
    );





#line 922 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winreg.h"



__declspec(dllimport)
LSTATUS
__stdcall
RegRenameKey(
     HKEY hKey,
     LPCWSTR lpSubKeyName,
     LPCWSTR lpNewKeyName
    );

#line 935 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winreg.h"

__declspec(dllimport)
LSTATUS
__stdcall
RegSaveKeyA (
     HKEY hKey,
     LPCSTR lpFile,
     const LPSECURITY_ATTRIBUTES lpSecurityAttributes
    );
__declspec(dllimport)
LSTATUS
__stdcall
RegSaveKeyW (
     HKEY hKey,
     LPCWSTR lpFile,
     const LPSECURITY_ATTRIBUTES lpSecurityAttributes
    );




#line 957 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winreg.h"

__declspec(dllimport)
LSTATUS
__stdcall
RegSetKeySecurity(
     HKEY hKey,
     SECURITY_INFORMATION SecurityInformation,
     PSECURITY_DESCRIPTOR pSecurityDescriptor
    );


__declspec(dllimport)
LSTATUS
__stdcall
RegSetValueA (
     HKEY hKey,
     LPCSTR lpSubKey,
     DWORD dwType,
     LPCSTR lpData,
     DWORD cbData
    );
__declspec(dllimport)
LSTATUS
__stdcall
RegSetValueW (
     HKEY hKey,
     LPCWSTR lpSubKey,
     DWORD dwType,
     LPCWSTR lpData,
     DWORD cbData
    );




#line 993 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winreg.h"

__declspec(dllimport)
LSTATUS
__stdcall
RegSetValueExA(
     HKEY hKey,
     LPCSTR lpValueName,
     DWORD Reserved,
     DWORD dwType,
     const BYTE* lpData,
     DWORD cbData
    );

__declspec(dllimport)
LSTATUS
__stdcall
RegSetValueExW(
     HKEY hKey,
     LPCWSTR lpValueName,
     DWORD Reserved,
     DWORD dwType,
     const BYTE* lpData,
     DWORD cbData
    );





#line 1023 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winreg.h"

__declspec(dllimport)
LSTATUS
__stdcall
RegUnLoadKeyA(
     HKEY hKey,
     LPCSTR lpSubKey
    );

__declspec(dllimport)
LSTATUS
__stdcall
RegUnLoadKeyW(
     HKEY hKey,
     LPCWSTR lpSubKey
    );





#line 1045 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winreg.h"

//
// Utils wrappers
//


__declspec(dllimport)
LSTATUS
__stdcall
RegDeleteKeyValueA(
     HKEY hKey,
     LPCSTR lpSubKey,
     LPCSTR lpValueName
    );

__declspec(dllimport)
LSTATUS
__stdcall
RegDeleteKeyValueW(
     HKEY hKey,
     LPCWSTR lpSubKey,
     LPCWSTR lpValueName
    );





#line 1074 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winreg.h"

__declspec(dllimport)
LSTATUS
__stdcall
RegSetKeyValueA(
     HKEY hKey,
     LPCSTR lpSubKey,
     LPCSTR lpValueName,
     DWORD dwType,
     LPCVOID lpData,
     DWORD cbData
    );

__declspec(dllimport)
LSTATUS
__stdcall
RegSetKeyValueW(
     HKEY hKey,
     LPCWSTR lpSubKey,
     LPCWSTR lpValueName,
     DWORD dwType,
     LPCVOID lpData,
     DWORD cbData
    );





#line 1104 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winreg.h"

__declspec(dllimport)
LSTATUS
__stdcall
RegDeleteTreeA(
     HKEY hKey,
     LPCSTR lpSubKey
    );

__declspec(dllimport)
LSTATUS
__stdcall
RegDeleteTreeW(
     HKEY hKey,
     LPCWSTR lpSubKey
    );





#line 1126 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winreg.h"

__declspec(dllimport)
LSTATUS
__stdcall
RegCopyTreeA (
            HKEY     hKeySrc,
        LPCSTR  lpSubKey,
            HKEY     hKeyDest
    );


#line 1138 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winreg.h"

#line 1140 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winreg.h"



__declspec(dllimport)
LSTATUS
__stdcall
RegGetValueA(
     HKEY hkey,
     LPCSTR lpSubKey,
     LPCSTR lpValue,
     DWORD dwFlags,
     LPDWORD pdwType,
    




        

     PVOID pvData,
     LPDWORD pcbData
    );

__declspec(dllimport)
LSTATUS
__stdcall
RegGetValueW(
     HKEY hkey,
     LPCWSTR lpSubKey,
     LPCWSTR lpValue,
     DWORD dwFlags,
     LPDWORD pdwType,
    




        

     PVOID pvData,
     LPDWORD pcbData
    );





#line 1188 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winreg.h"

#line 1190 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winreg.h"



__declspec(dllimport)
LSTATUS
__stdcall
RegCopyTreeW(
     HKEY hKeySrc,
     LPCWSTR lpSubKey,
     HKEY hKeyDest
    );





__declspec(dllimport)
LSTATUS
__stdcall
RegLoadMUIStringA(
     HKEY hKey,
     LPCSTR pszValue,
     LPSTR pszOutBuf,
     DWORD cbOutBuf,
     LPDWORD pcbData,
     DWORD Flags,
     LPCSTR pszDirectory
    );

__declspec(dllimport)
LSTATUS
__stdcall
RegLoadMUIStringW(
     HKEY hKey,
     LPCWSTR pszValue,
     LPWSTR pszOutBuf,
     DWORD cbOutBuf,
     LPDWORD pcbData,
     DWORD Flags,
     LPCWSTR pszDirectory
    );





#line 1237 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winreg.h"

__declspec(dllimport)
LSTATUS
__stdcall
RegLoadAppKeyA(
     LPCSTR lpFile,
     PHKEY phkResult,
     REGSAM samDesired,
     DWORD dwOptions,
     DWORD Reserved
    );

__declspec(dllimport)
LSTATUS
__stdcall
RegLoadAppKeyW(
     LPCWSTR lpFile,
     PHKEY phkResult,
     REGSAM samDesired,
     DWORD dwOptions,
     DWORD Reserved
    );





#line 1265 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winreg.h"

#line 1267 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winreg.h"

//
// Remoteable System Shutdown APIs
//


__declspec(dllimport)
BOOL
__stdcall
InitiateSystemShutdownA(
     LPSTR lpMachineName,
     LPSTR lpMessage,
     DWORD dwTimeout,
     BOOL bForceAppsClosed,
     BOOL bRebootAfterShutdown
    );

__declspec(dllimport)
BOOL
__stdcall
InitiateSystemShutdownW(
     LPWSTR lpMachineName,
     LPWSTR lpMessage,
     DWORD dwTimeout,
     BOOL bForceAppsClosed,
     BOOL bRebootAfterShutdown
    );




#line 1299 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winreg.h"

__declspec(dllimport)
BOOL
__stdcall
AbortSystemShutdownA(
     LPSTR lpMachineName
    );
__declspec(dllimport)
BOOL
__stdcall
AbortSystemShutdownW(
     LPWSTR lpMachineName
    );




#line 1317 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winreg.h"

//
// defines for InitiateSystemShutdownEx reason codes
//

#line 1 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\reason.h"


//+-------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (c) Microsoft Corporation. All rights reserved.
//
//  File:        reason.h
//
//  Contents:    Shutdown reason code values.
//
//  History:     8-00        Created         Hughleat
//
//--------------------------------------------------------------------


#pragma once

#pragma region Desktop Family


// Reason flags

// Flags used by the various UIs.






// Flags that end up in the event log code.



// Microsoft major reasons.










// Microsoft minor reasons.



































// This mask cuts out UI flags.


// Convenience flags.





/*
 * Maximum character lengths for reason name, description, problem id, and
 * comment respectively.
 */






/*
 *	S.E.T. policy value
 *
 */






/*
 * Snapshot policy values
 */




/*
 * Maximue user defined reasons
 */


#line 124 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\reason.h"
#pragma endregion

#line 127 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\reason.h"
#line 1323 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winreg.h"
//
// Then for Historical reasons support some old symbols, internal only











//
// MAX Shutdown TimeOut == 10 Years in seconds
//





__declspec(dllimport)
BOOL
__stdcall
InitiateSystemShutdownExA(
     LPSTR lpMachineName,
     LPSTR lpMessage,
     DWORD dwTimeout,
     BOOL bForceAppsClosed,
     BOOL bRebootAfterShutdown,
     DWORD dwReason
    );



__declspec(dllimport)
BOOL
__stdcall
InitiateSystemShutdownExW(
     LPWSTR lpMachineName,
     LPWSTR lpMessage,
     DWORD dwTimeout,
     BOOL bForceAppsClosed,
     BOOL bRebootAfterShutdown,
     DWORD dwReason
    );




#line 1374 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winreg.h"

//
// Shutdown flags
//
















__declspec(dllimport)
DWORD
__stdcall
InitiateShutdownA(
     LPSTR lpMachineName,
     LPSTR lpMessage,
         DWORD dwGracePeriod,
         DWORD dwShutdownFlags,
         DWORD dwReason
    );
__declspec(dllimport)
DWORD
__stdcall
InitiateShutdownW(
     LPWSTR lpMachineName,
     LPWSTR lpMessage,
         DWORD dwGracePeriod,
         DWORD dwShutdownFlags,
         DWORD dwReason
    );




#line 1419 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winreg.h"

__declspec(dllimport)
DWORD
__stdcall
CheckForHiberboot(
     PBOOLEAN pHiberboot,
     BOOLEAN bClearFlag
    );

__declspec(dllimport)
LSTATUS
__stdcall
RegSaveKeyExA(
     HKEY hKey,
     LPCSTR lpFile,
     const LPSECURITY_ATTRIBUTES lpSecurityAttributes,
     DWORD Flags
    );

__declspec(dllimport)
LSTATUS
__stdcall
RegSaveKeyExW(
     HKEY hKey,
     LPCWSTR lpFile,
     const LPSECURITY_ATTRIBUTES lpSecurityAttributes,
     DWORD Flags
    );





#line 1453 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winreg.h"


#line 1456 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winreg.h"
#pragma endregion


#pragma warning(pop)
#line 1461 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winreg.h"


}
#line 1465 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winreg.h"


#line 1468 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winreg.h"

#line 184 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\Windows.h"
#line 185 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\Windows.h"

#line 1 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winnetwk.h"


/*++

Copyright (c) Microsoft Corporation. All rights reserved.

Module Name:

    winnetwk.h

Abstract:

    Standard WINNET Header File for WIN32

Environment:

    User Mode -Win32

Notes:

    optional-notes

--*/





#pragma once



extern "C" {
#line 35 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winnetwk.h"


#pragma warning(push)
#pragma warning(disable:4820) 
#line 40 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winnetwk.h"


#pragma region Desktop Family or System Family




//
// Network types
//

#line 1 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\shared\\wnnc.h"


/*++

Copyright (c) Microsoft Corporation. All rights reserved.

Module Name:

    wnnc.h

Abstract:

    This header provides the Windows Networking WNNC_NET definitions to winnetwk.h
    and the IFS Kit.

Environment:

    User Mode / Kernel Mode

Notes:

--*/

// begin_ntifs



#pragma region Desktop Family or OneCore Family


//
// Network types
//











































































//
// Network type aliases
//




#line 117 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\shared\\wnnc.h"
#pragma endregion

#line 120 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\shared\\wnnc.h"
// end_ntifs


#line 52 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winnetwk.h"

//
//  Network Resources.
//







#line 64 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winnetwk.h"






#line 71 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winnetwk.h"









#line 81 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winnetwk.h"













#line 95 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winnetwk.h"



#line 99 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winnetwk.h"

typedef struct  _NETRESOURCEA {
    DWORD    dwScope;
    DWORD    dwType;
    DWORD    dwDisplayType;
    DWORD    dwUsage;
    LPSTR    lpLocalName;
    LPSTR    lpRemoteName;
    LPSTR    lpComment ;
    LPSTR    lpProvider;
}NETRESOURCEA, *LPNETRESOURCEA;
typedef struct  _NETRESOURCEW {
    DWORD    dwScope;
    DWORD    dwType;
    DWORD    dwDisplayType;
    DWORD    dwUsage;
    LPWSTR   lpLocalName;
    LPWSTR   lpRemoteName;
    LPWSTR   lpComment ;
    LPWSTR   lpProvider;
}NETRESOURCEW, *LPNETRESOURCEW;




typedef NETRESOURCEA NETRESOURCE;
typedef LPNETRESOURCEA LPNETRESOURCE;
#line 127 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winnetwk.h"


//
//  Network Connections.
//
















#line 149 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winnetwk.h"



#line 153 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winnetwk.h"


#line 156 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winnetwk.h"







#line 164 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winnetwk.h"


DWORD __stdcall
WNetAddConnectionA(
         LPCSTR   lpRemoteName,
     LPCSTR   lpPassword,
     LPCSTR   lpLocalName
    );

DWORD __stdcall
WNetAddConnectionW(
         LPCWSTR   lpRemoteName,
     LPCWSTR   lpPassword,
     LPCWSTR   lpLocalName
    );




#line 184 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winnetwk.h"


DWORD __stdcall
WNetAddConnection2A(
         LPNETRESOURCEA lpNetResource,
     LPCSTR       lpPassword,
     LPCSTR       lpUserName,
         DWORD          dwFlags
    );

DWORD __stdcall
WNetAddConnection2W(
         LPNETRESOURCEW lpNetResource,
     LPCWSTR       lpPassword,
     LPCWSTR       lpUserName,
         DWORD          dwFlags
    );




#line 206 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winnetwk.h"


DWORD __stdcall
WNetAddConnection3A(
     HWND           hwndOwner,
         LPNETRESOURCEA lpNetResource,
     LPCSTR       lpPassword,
     LPCSTR       lpUserName,
         DWORD          dwFlags
    );

DWORD __stdcall
WNetAddConnection3W(
     HWND           hwndOwner,
         LPNETRESOURCEW lpNetResource,
     LPCWSTR       lpPassword,
     LPCWSTR       lpUserName,
         DWORD          dwFlags
    );




#line 230 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winnetwk.h"


DWORD __stdcall
WNetCancelConnectionA(
     LPCSTR lpName,
     BOOL     fForce
    );

DWORD __stdcall
WNetCancelConnectionW(
     LPCWSTR lpName,
     BOOL     fForce
    );




#line 248 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winnetwk.h"


DWORD __stdcall
WNetCancelConnection2A(
     LPCSTR lpName,
     DWORD    dwFlags,
     BOOL     fForce
    );

DWORD __stdcall
WNetCancelConnection2W(
     LPCWSTR lpName,
     DWORD    dwFlags,
     BOOL     fForce
    );




#line 268 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winnetwk.h"


DWORD __stdcall
WNetGetConnectionA(
     LPCSTR lpLocalName,
     LPSTR  lpRemoteName,
     LPDWORD lpnLength
    );

DWORD __stdcall
WNetGetConnectionW(
     LPCWSTR lpLocalName,
     LPWSTR  lpRemoteName,
     LPDWORD lpnLength
    );




#line 288 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winnetwk.h"


#line 291 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winnetwk.h"
#pragma endregion

#pragma region Desktop Family




DWORD __stdcall
WNetRestoreSingleConnectionW(
     HWND    hwndParent,
         LPCWSTR lpDevice,
         BOOL    fUseUI
    );









#line 314 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winnetwk.h"

#line 316 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winnetwk.h"
#pragma endregion

#pragma region Desktop Family or System Family




DWORD __stdcall
WNetUseConnectionA(
     HWND            hwndOwner,
         LPNETRESOURCEA  lpNetResource,
     LPCSTR        lpPassword,
     LPCSTR        lpUserId,
         DWORD           dwFlags,
     LPSTR lpAccessName,
     LPDWORD lpBufferSize,
     LPDWORD   lpResult
    );

DWORD __stdcall
WNetUseConnectionW(
     HWND            hwndOwner,
         LPNETRESOURCEW  lpNetResource,
     LPCWSTR        lpPassword,
     LPCWSTR        lpUserId,
         DWORD           dwFlags,
     LPWSTR lpAccessName,
     LPDWORD lpBufferSize,
     LPDWORD   lpResult
    );




#line 351 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winnetwk.h"
#line 352 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winnetwk.h"


//
//  Network Connection Dialogs.
//

DWORD __stdcall
WNetConnectionDialog(
     HWND  hwnd,
     DWORD dwType
    );


DWORD __stdcall
WNetDisconnectDialog(
     HWND hwnd,
     DWORD dwType
    );


typedef struct _CONNECTDLGSTRUCTA{
    DWORD cbStructure;       /* size of this structure in bytes */
    HWND hwndOwner;          /* owner window for the dialog */
    LPNETRESOURCEA lpConnRes;/* Requested Resource info    */
    DWORD dwFlags;           /* flags (see below) */
    DWORD dwDevNum;          /* number of devices connected to */
} CONNECTDLGSTRUCTA,  *LPCONNECTDLGSTRUCTA;
typedef struct _CONNECTDLGSTRUCTW{
    DWORD cbStructure;       /* size of this structure in bytes */
    HWND hwndOwner;          /* owner window for the dialog */
    LPNETRESOURCEW lpConnRes;/* Requested Resource info    */
    DWORD dwFlags;           /* flags (see below) */
    DWORD dwDevNum;          /* number of devices connected to */
} CONNECTDLGSTRUCTW,  *LPCONNECTDLGSTRUCTW;




typedef CONNECTDLGSTRUCTA CONNECTDLGSTRUCT;
typedef LPCONNECTDLGSTRUCTA LPCONNECTDLGSTRUCT;
#line 393 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winnetwk.h"






/*
 * NOTE:  Set at most ONE of the below flags.  If neither flag is set,
 *        then the persistence is set to whatever the user chose during
 *        a previous connection
 */




DWORD __stdcall
WNetConnectionDialog1A(
     LPCONNECTDLGSTRUCTA lpConnDlgStruct
    );

DWORD __stdcall
WNetConnectionDialog1W(
     LPCONNECTDLGSTRUCTW lpConnDlgStruct
    );




#line 422 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winnetwk.h"

typedef struct _DISCDLGSTRUCTA{
    DWORD           cbStructure;      /* size of this structure in bytes */
    HWND            hwndOwner;        /* owner window for the dialog */
    LPSTR           lpLocalName;      /* local device name */
    LPSTR           lpRemoteName;     /* network resource name */
    DWORD           dwFlags;          /* flags */
} DISCDLGSTRUCTA,  *LPDISCDLGSTRUCTA;
typedef struct _DISCDLGSTRUCTW{
    DWORD           cbStructure;      /* size of this structure in bytes */
    HWND            hwndOwner;        /* owner window for the dialog */
    LPWSTR          lpLocalName;      /* local device name */
    LPWSTR          lpRemoteName;     /* network resource name */
    DWORD           dwFlags;          /* flags */
} DISCDLGSTRUCTW,  *LPDISCDLGSTRUCTW;




typedef DISCDLGSTRUCTA DISCDLGSTRUCT;
typedef LPDISCDLGSTRUCTA LPDISCDLGSTRUCT;
#line 444 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winnetwk.h"





DWORD __stdcall
WNetDisconnectDialog1A(
     LPDISCDLGSTRUCTA lpConnDlgStruct
    );

DWORD __stdcall
WNetDisconnectDialog1W(
     LPDISCDLGSTRUCTW lpConnDlgStruct
    );




#line 463 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winnetwk.h"
#line 464 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winnetwk.h"

//
//  Network Browsing.
//


DWORD __stdcall
WNetOpenEnumA(
      DWORD          dwScope,
      DWORD          dwType,
      DWORD          dwUsage,
     LPNETRESOURCEA lpNetResource,
     LPHANDLE       lphEnum
    );

DWORD __stdcall
WNetOpenEnumW(
      DWORD          dwScope,
      DWORD          dwType,
      DWORD          dwUsage,
     LPNETRESOURCEW lpNetResource,
     LPHANDLE       lphEnum
    );




#line 492 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winnetwk.h"


DWORD __stdcall
WNetEnumResourceA(
        HANDLE  hEnum,
     LPDWORD lpcCount,
     LPVOID  lpBuffer,
     LPDWORD lpBufferSize
    );

DWORD __stdcall
WNetEnumResourceW(
        HANDLE  hEnum,
     LPDWORD lpcCount,
     LPVOID  lpBuffer,
     LPDWORD lpBufferSize
    );




#line 514 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winnetwk.h"


DWORD __stdcall
WNetCloseEnum(
     HANDLE   hEnum
    );



DWORD __stdcall
WNetGetResourceParentA(
     LPNETRESOURCEA lpNetResource,
     LPVOID lpBuffer,
     LPDWORD lpcbBuffer
    );

DWORD __stdcall
WNetGetResourceParentW(
     LPNETRESOURCEW lpNetResource,
     LPVOID lpBuffer,
     LPDWORD lpcbBuffer
    );




#line 541 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winnetwk.h"


DWORD __stdcall
WNetGetResourceInformationA(
     LPNETRESOURCEA  lpNetResource,
     LPVOID lpBuffer,
     LPDWORD lpcbBuffer,
     LPSTR *lplpSystem
    );

DWORD __stdcall
WNetGetResourceInformationW(
     LPNETRESOURCEW  lpNetResource,
     LPVOID lpBuffer,
     LPDWORD lpcbBuffer,
     LPWSTR *lplpSystem
    );




#line 563 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winnetwk.h"
#line 564 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winnetwk.h"

//
//  Universal Naming.
//




typedef struct  _UNIVERSAL_NAME_INFOA {
    LPSTR    lpUniversalName;
}UNIVERSAL_NAME_INFOA, *LPUNIVERSAL_NAME_INFOA;
typedef struct  _UNIVERSAL_NAME_INFOW {
    LPWSTR   lpUniversalName;
}UNIVERSAL_NAME_INFOW, *LPUNIVERSAL_NAME_INFOW;




typedef UNIVERSAL_NAME_INFOA UNIVERSAL_NAME_INFO;
typedef LPUNIVERSAL_NAME_INFOA LPUNIVERSAL_NAME_INFO;
#line 585 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winnetwk.h"

typedef struct  _REMOTE_NAME_INFOA {
    LPSTR    lpUniversalName;
    LPSTR    lpConnectionName;
    LPSTR    lpRemainingPath;
}REMOTE_NAME_INFOA, *LPREMOTE_NAME_INFOA;
typedef struct  _REMOTE_NAME_INFOW {
    LPWSTR   lpUniversalName;
    LPWSTR   lpConnectionName;
    LPWSTR   lpRemainingPath;
}REMOTE_NAME_INFOW, *LPREMOTE_NAME_INFOW;




typedef REMOTE_NAME_INFOA REMOTE_NAME_INFO;
typedef LPREMOTE_NAME_INFOA LPREMOTE_NAME_INFO;
#line 603 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winnetwk.h"


DWORD __stdcall
WNetGetUniversalNameA(
     LPCSTR lpLocalPath,
     DWORD    dwInfoLevel,
     LPVOID lpBuffer,
     LPDWORD lpBufferSize
    );

DWORD __stdcall
WNetGetUniversalNameW(
     LPCWSTR lpLocalPath,
     DWORD    dwInfoLevel,
     LPVOID lpBuffer,
     LPDWORD lpBufferSize
    );




#line 625 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winnetwk.h"

//
//  Authentication and Logon/Logoff.
//

DWORD __stdcall
WNetGetUserA(
     LPCSTR  lpName,
     LPSTR lpUserName,
      LPDWORD lpnLength
    );
//
//  Authentication and Logon/Logoff.
//

DWORD __stdcall
WNetGetUserW(
     LPCWSTR  lpName,
     LPWSTR lpUserName,
      LPDWORD lpnLength
    );




#line 651 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winnetwk.h"



//
// Other.
//






#line 664 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winnetwk.h"




DWORD __stdcall
WNetGetProviderNameA(
        DWORD   dwNetType,
     LPSTR lpProviderName,
     LPDWORD lpBufferSize
    );

DWORD __stdcall
WNetGetProviderNameW(
        DWORD   dwNetType,
     LPWSTR lpProviderName,
     LPDWORD lpBufferSize
    );




#line 686 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winnetwk.h"

typedef struct _NETINFOSTRUCT{
    DWORD cbStructure;
    DWORD dwProviderVersion;
    DWORD dwStatus;
    DWORD dwCharacteristics;
    ULONG_PTR dwHandle;
    WORD  wNetType;
    DWORD dwPrinters;
    DWORD dwDrives;
} NETINFOSTRUCT,  *LPNETINFOSTRUCT;






DWORD __stdcall
WNetGetNetworkInformationA(
      LPCSTR        lpProvider,
     LPNETINFOSTRUCT lpNetInfoStruct
    );

DWORD __stdcall
WNetGetNetworkInformationW(
      LPCWSTR        lpProvider,
     LPNETINFOSTRUCT lpNetInfoStruct
    );




#line 719 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winnetwk.h"

#line 721 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winnetwk.h"

//
//  Error handling.
//


DWORD __stdcall
WNetGetLastErrorA(
     LPDWORD    lpError,
     LPSTR lpErrorBuf,
     DWORD      nErrorBufSize,
     LPSTR  lpNameBuf,
     DWORD      nNameBufSize
    );

DWORD __stdcall
WNetGetLastErrorW(
     LPDWORD    lpError,
     LPWSTR lpErrorBuf,
     DWORD      nErrorBufSize,
     LPWSTR  lpNameBuf,
     DWORD      nNameBufSize
    );




#line 749 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winnetwk.h"

//
//  STATUS CODES
//

// General























#line 779 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winnetwk.h"

// Connection


















#line 800 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winnetwk.h"

// Enumeration





// Authentication




#line 813 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winnetwk.h"

//
//  For Shell
//


typedef struct _NETCONNECTINFOSTRUCT{
    DWORD cbStructure;
    DWORD dwFlags;
    DWORD dwSpeed;
    DWORD dwDelay;
    DWORD dwOptDataSize;
} NETCONNECTINFOSTRUCT,  *LPNETCONNECTINFOSTRUCT;







DWORD __stdcall
MultinetGetConnectionPerformanceA(
      LPNETRESOURCEA lpNetResource,
     LPNETCONNECTINFOSTRUCT lpNetConnectInfoStruct
    );

DWORD __stdcall
MultinetGetConnectionPerformanceW(
      LPNETRESOURCEW lpNetResource,
     LPNETCONNECTINFOSTRUCT lpNetConnectInfoStruct
    );




#line 849 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winnetwk.h"
#line 850 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winnetwk.h"


#line 853 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winnetwk.h"
#pragma endregion



#pragma warning(pop)
#line 859 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winnetwk.h"


}
#line 863 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winnetwk.h"


#line 866 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winnetwk.h"

#line 187 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\Windows.h"
#line 188 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\Windows.h"




































#line 1 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\shared\\stralign.h"


/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    stralign.h

Abstract:

    This module contains macros and prototypes to expose the unaligned wide
    character interfaces.

    Public interfaces created or declared here include:

    ua_CharUpper()
    ua_CharUpperW()
    ua_lstrcmp()
    ua_lstrcmpW()
    ua_lstrcmpi()
    ua_lstrcmpiW()
    ua_lstrlen()
    ua_lstrlenW()
    ua_tcscpy()
    ua_tcscpy_s()
    ua_wcschr()
    ua_wcscpy()
    ua_wcscpy_s()
    ua_wcsicmp()
    ua_wcslen()
    ua_wcsrchr()

    STRUC_ALIGNED_STACK_COPY()
    TSTR_ALIGNED()
    TSTR_ALIGNED_STACK_COPY()
    WSTR_ALIGNED()
    WSTR_ALIGNED_STACK_COPY()

Author:

--*/









#line 54 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\shared\\stralign.h"
#line 55 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\shared\\stralign.h"




#line 60 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\shared\\stralign.h"

#line 62 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\shared\\stralign.h"
#line 63 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\shared\\stralign.h"


extern "C" {
#line 67 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\shared\\stralign.h"

#pragma region Desktop Family


//
// N.B. On AMD64 platforms the key word __unaligned is enabled, but has no
//      effect and strings can be unaligned exactly as they are on the x86.
//      Therefore, all AMD64 alignment macros are forced to produce values
//      that make the subject arguments appear as it they are aligned.
//
//      On ARM platforms, the operation is similar.
//


#pragma warning(push)
#pragma warning(disable:4127)
#line 84 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\shared\\stralign.h"








































#line 125 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\shared\\stralign.h"

//
// The C runtime libraries expect aligned string pointers.  Following are the
// prototypes for our own, slower worker functions that accept unaligned
// UNICODE strings.
//
// Macro to determine whether a pointer to a unicode character is naturally
// aligned.
//









#line 144 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\shared\\stralign.h"

//
// Platform-specific prototypes for worker functions exported from kernel32.
// Do not call these directly, they do not exist on all platforms.  Instead
// use the equivalent ua_xxx() routines.
//

LPUWSTR
__stdcall
uaw_CharUpperW(
     LPUWSTR String
    );

int
__stdcall
uaw_lstrcmpW(
     PCUWSTR String1,
     PCUWSTR String2
    );

int
__stdcall
uaw_lstrcmpiW(
     PCUWSTR String1,
     PCUWSTR String2
    );

int
__stdcall
uaw_lstrlenW(
     LPCUWSTR String
    );

PUWSTR
__cdecl
uaw_wcschr(
     PCUWSTR String,
     WCHAR   Character
    );

PUWSTR
__cdecl
uaw_wcscpy(
     PUWSTR  Destination,
      PCUWSTR Source
    );

int
__cdecl
uaw_wcsicmp(
     PCUWSTR String1,
     PCUWSTR String2
    );

size_t
__cdecl
uaw_wcslen(
     PCUWSTR String
    );

PUWSTR
__cdecl
uaw_wcsrchr(
     PCUWSTR String,
     WCHAR   Character
    );

//
// Following are the inline wrappers that determine the optimal worker function
// to call based on the alignment of the UNICODE string arguments.  Their
// behavior is otherwise identical to the corresponding standard run-time
// routiunes.
//


__inline
LPUWSTR
static
ua_CharUpperW(
     LPUWSTR String
    )
{
    if (1 ) {
        return CharUpperW( (PWSTR)String );
    } else {
        return uaw_CharUpperW( String );
    }
}
#line 233 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\shared\\stralign.h"


__inline
int
static
ua_lstrcmpW(
     LPCUWSTR String1,
     LPCUWSTR String2
    )
{
    if (1 && 1 ) {
        return lstrcmpW( (LPCWSTR)String1, (LPCWSTR)String2);
    } else {
        return uaw_lstrcmpW( String1, String2 );
    }
}
#line 250 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\shared\\stralign.h"


__inline
int
static
ua_lstrcmpiW(
     LPCUWSTR String1,
     LPCUWSTR String2
    )
{
    if (1 && 1 ) {
        return lstrcmpiW( (LPCWSTR)String1, (LPCWSTR)String2 );
    } else {
        return uaw_lstrcmpiW( String1, String2 );
    }
}
#line 267 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\shared\\stralign.h"


__inline
int
static
ua_lstrlenW(
     LPCUWSTR String
    )
{
    if (1 ) {
#pragma warning(suppress: 28750) 
        return lstrlenW( (PCWSTR)String );
    } else {
        return uaw_lstrlenW( String );
    }
}
#line 284 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\shared\\stralign.h"

// _WSTRING_DEFINED is no longer defined in newer versions of STL.
// Check to see if string.h or wchar.h have been included instead.


//
// Certain run-time string functions are overloaded in C++, to avoid
// inadvertent stripping of the const attribute.
//
// The functions of interest here include: wcschr and wcsrchr.
//
// There are three flavors of these functions:
//
// Flavor  Returns    Parameter
//
// 1       PWSTR      PCWSTR
// 2       PCWSTR     PCWSTR
// 3       PWSTR      PWSTR
//
// string.h declares flavor 1 whether for C or C++.  This is the non-ANSI,
// backward compatible mode.
//
// wchar.h declares flavor 1 if C, or flavors 2 and 3 if C++.  This is the
// ANSI method.
//
// Our corresponding functions need to match what was declared.  The way
// we can tell is by looking at _WConst_return... if it is defined then
// we want to match the prototypes in wchar.h, otherwise we'll match
// the prototypes in string.h.
//


typedef const WCHAR __unaligned *PUWSTR_C;


#line 320 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\shared\\stralign.h"

//
// Here is flavor 1 or 2
//

__inline
PUWSTR_C
static
ua_wcschr(
     PCUWSTR String,
     WCHAR   Character
    )
{
    if (1 ) {
        return wcschr((PCWSTR)String, Character);
    } else {
        return (PUWSTR_C)uaw_wcschr(String, Character);
    }
}

__inline
PUWSTR_C
static
ua_wcsrchr(
     PCUWSTR String,
     WCHAR   Character
    )
{
    if (1 ) {
        return wcsrchr((PCWSTR)String, Character);
    } else {
        return (PUWSTR_C)uaw_wcsrchr(String, Character);
    }
}



























































#line 414 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\shared\\stralign.h"

__inline
PUWSTR
static
__declspec(deprecated)
ua_wcscpy(
     PUWSTR  Destination,
     PCUWSTR Source
    )
{
    if (1 && 1 ) {
#pragma warning(push)
#pragma warning(disable:4995)
#pragma warning(disable:4996)



        return wcscpy( (PWSTR)Destination, (PCWSTR)Source );
#pragma warning(pop)
    } else {
        return uaw_wcscpy( Destination, Source );
    }
}



__inline
PUWSTR
static
ua_wcscpy_s(
     PUWSTR Destination,
     size_t  DestinationSize,
     PCUWSTR Source
    )
{
    if (1 && 1 ) {
        return (wcscpy_s( (PWSTR)Destination, DestinationSize, (PCWSTR)Source ) == 0 ? Destination : 0 );
    } else {
        /* TODO: Need to reference uaw_wcscpy_s */
        return uaw_wcscpy( Destination, Source );
    }
}
#line 457 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\shared\\stralign.h"

__inline
size_t
static
ua_wcslen(
     PCUWSTR String
    )
{
    if (1 ) {
        return wcslen( (PCWSTR)String );
    } else {
        return uaw_wcslen( String );
    }
}

#line 473 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\shared\\stralign.h"

__inline
int
static
ua_wcsicmp(
     PCUWSTR String1,
     PCUWSTR String2
    )
{
    if (1 && 1 ) {
        return _wcsicmp( (LPCWSTR)String1, (LPCWSTR)String2 );
    } else {
        return uaw_wcsicmp( String1, String2 );
    }
}

#line 490 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\shared\\stralign.h"

//++
//
// VOID
// WSTR_ALIGNED_STACK_COPY (
//    _Out_ PCWSTR *TargetString,
//    _In_opt_  PCUWSTR SourceString
//    )
//
// VOID
// TSTR_ALIGNED_STACK_COPY (
//    _Out_ PCTSTR *TargetString,
//    _In_opt_  PCUTSTR SourceString
//    )
//
// Routine Description:
//
//    These macros set TargetString to an aligned pointer to the string
//    represented by SourceString.  If necessary, an aligned copy of
//    SourceString is copied onto the stack.
//
// Arguments:
//
//    TargetString - Supplies a pointer to a pointer to the resultant
//                   string.  This may be the same as SourceString if
//                   that argument is aligned.
//
//    SourceString - Supplies a pointer to the possibly unaligned UNICODE
//                   string.
//
// Return Value:
//
//    None.
//
// Note:
//
//    These macros may allocate memory on the stack via the CRT function
//    _alloca().  This memory is "freed" when the calling function exits.
//    As a result, do not use these macros inside of a loop that may execute
//    a large number of times - instead, use a wrapper function, or use
//    an explicit buffer like this:
//
//    TCHAR AlignedStringBuffer[ MAX_FOOSTR_CHARS ];
//    PTSTR AlignedString;
//
//    while (a < b) {
//        ...
//        if (TSTR_ALIGNED(s) {
//            AlignedString = s;
//        } else {
//            AlignedString = (PTSTR)ua_tcscpy(AlignedStringBuffer,s);
//        }
//        SomeSystemFunction(AlignedString);
//        ...
//    }
//
//
//--

//
// __UA_WSTRSIZE returns the number of bytes required to store the
// supplied null-terminated UNICODE string.
//
// __UA_LOCALCOPY accepts a pointer to unaligned data and a size.  It
// allocates an aligned buffer on the stack and copies the data into
// it, returning a pointer to the buffer.
//



#line 561 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\shared\\stralign.h"




//
// Note that NULL is aligned.
//





























#line 598 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\shared\\stralign.h"



//++
//
// <type> CONST *
// STRUC_ALIGNED_STACK_COPY (
//     _In_ <type name>,
//     _In_opt_ PVOID Struc
//     )
//
// Routine Description:
//
//    This macro returns an aligned pointer to Struc, creating a local
//    copy on the stack if necessary.
//
//    This should be used only for relatively small structures, and efforts
//    should be made to align the structure properly in the first place.  Use
//    this macro only as a last resort.
//
// Arguments:
//
//    <type> - The type specifier of Struc
//
//    Struc - Supplies a pointer to the structure in question.
//
// Return Value:
//
//    Returns a const pointer to Struc if it is properly aligned, or a pointer
//    to a stack-allocated copy of Struc if it is not.
//
//--











#line 642 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\shared\\stralign.h"



#line 646 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\shared\\stralign.h"














#line 661 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\shared\\stralign.h"










#line 672 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\shared\\stralign.h"

#line 674 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\shared\\stralign.h"


#pragma warning(pop)
#line 678 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\shared\\stralign.h"

#line 680 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\shared\\stralign.h"
#pragma endregion


}
#line 685 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\shared\\stralign.h"

#line 687 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\shared\\stralign.h"








#line 225 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\Windows.h"












#line 1 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winsvc.h"
/*++ BUILD Version: 0010    // Increment this if a change has global effects

Copyright (c) 1995-1998  Microsoft Corporation

Module Name:

    winsvc.h

Abstract:

    Header file for the Service Control Manager

Environment:

    User Mode - Win32

--*/





//
// Define API decoration for direct importing of DLL references.
//







#line 34 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winsvc.h"


#pragma warning(push)
#pragma warning(disable:4820) 
#line 39 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winsvc.h"


extern "C" {
#line 43 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winsvc.h"

#pragma region Desktop Family or OneCore Family


//
// Constants
//

//
// Service database names
//







//
// Character to designate that a name is a group
//


















#line 83 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winsvc.h"


//
// Value to indicate no change to an optional parameter
//


//
// Service State -- for Enum Requests (Bit Mask)
//





//
// Controls
//
















//#define SERVICE_CONTROL_USER_LOGOFF            0x00000011

//reserved for internal use                    0x00000021
//reserved for internal use                    0x00000050



//
// Service State -- for CurrentState
//








//
// Controls Accepted  (Bit Mask)
//












// reserved for internal use                   0x00001000



//
// Service Control Manager object specific access types
//

















//
// Service object specific access type
//





















//
// Service flags for QueryServiceStatusEx
//


//
// Info levels for ChangeServiceConfig2 and QueryServiceConfig2
//









// reserved                                     10
// reserved                                     11


//
// Info levels for NotifyServiceStatusChange
//





//
// Service notification masks
//











//
// The following defines are for service stop reason codes
//

//
// Stop reason flags. Update SERVICE_STOP_REASON_FLAG_MAX when
// new flags are added.
//






//
// Microsoft major reasons. Update SERVICE_STOP_REASON_MAJOR_MAX when
// new codes are added.
//











//
// Microsoft minor reasons. Update SERVICE_STOP_REASON_MINOR_MAX when
// new codes are added.
//





























//
// Info levels for ControlServiceEx
//


//
// Service SID types supported
//




//
// Service trigger types
//










//
// Service trigger data types
//






//
//  Service start reason
//






//
//  Service dynamic information levels
//


//
// Service LaunchProtected types supported
//





//
//  NETWORK_MANAGER_FIRST_IP_ADDRESS_ARRIVAL_GUID & NETWORK_MANAGER_LAST_IP_ADDRESS_REMOVAL_GUID are used with
//  SERVICE_TRIGGER_TYPE_IP_ADDRESS_AVAILABILITY trigger.
//
extern "C" const GUID NETWORK_MANAGER_FIRST_IP_ADDRESS_ARRIVAL_GUID





;

extern "C" const GUID NETWORK_MANAGER_LAST_IP_ADDRESS_REMOVAL_GUID





;

//
//  DOMAIN_JOIN_GUID & DOMAIN_LEAVE_GUID are used with SERVICE_TRIGGER_TYPE_DOMAIN_JOIN trigger.
//
extern "C" const GUID DOMAIN_JOIN_GUID





;

extern "C" const GUID DOMAIN_LEAVE_GUID





;

//
//  FIREWALL_PORT_OPEN_GUID & FIREWALL_PORT_CLOSE_GUID are used with
//  SERVICE_TRIGGER_TYPE_FIREWALL_PORT_EVENT trigger.
//
extern "C" const GUID FIREWALL_PORT_OPEN_GUID





;

extern "C" const GUID FIREWALL_PORT_CLOSE_GUID





;

//
//  MACHINE_POLICY_PRESENT_GUID & USER_POLICY_PRESENT_GUID are used with
//  SERVICE_TRIGGER_TYPE_GROUP_POLICY trigger.
//
extern "C" const GUID MACHINE_POLICY_PRESENT_GUID





;

extern "C" const GUID USER_POLICY_PRESENT_GUID





;

//
// RPC_INTERFACE_EVENT_GUID, NAMED_PIPE_EVENT_GUID & TCP_PORT_EVENT_GUID are
// used with SERVICE_TRIGGER_TYPE_NETWORK_ENDPOINT trigger.

extern "C" const GUID RPC_INTERFACE_EVENT_GUID





;

extern "C" const GUID NAMED_PIPE_EVENT_GUID





;

//
// CUSTOM_SYSTEM_STATE_CHANGE_EVENT_GUID is used with SERVICE_TRIGGER_TYPE_CUSTOM_SYSTEM_STATE_CHANGE
//
extern "C" const GUID CUSTOM_SYSTEM_STATE_CHANGE_EVENT_GUID





;

//
// Service notification trigger identifier
//
typedef struct
{
    DWORD Data[2];
} SERVICE_TRIGGER_CUSTOM_STATE_ID;

typedef struct _SERVICE_CUSTOM_SYSTEM_STATE_CHANGE_DATA_ITEM {
    union {
        SERVICE_TRIGGER_CUSTOM_STATE_ID CustomStateId;
        struct {
            DWORD DataOffset;
            BYTE Data[1];
        } s;
    } u;
} SERVICE_CUSTOM_SYSTEM_STATE_CHANGE_DATA_ITEM, *LPSERVICE_CUSTOM_SYSTEM_STATE_CHANGE_DATA_ITEM;

//
// Service trigger actions
//




//
// argv[1] passed into ServiceMain of trigger started services
//


//
// Service description string
//
typedef struct _SERVICE_DESCRIPTIONA {
    LPSTR       lpDescription;
} SERVICE_DESCRIPTIONA, *LPSERVICE_DESCRIPTIONA;
//
// Service description string
//
typedef struct _SERVICE_DESCRIPTIONW {
    LPWSTR      lpDescription;
} SERVICE_DESCRIPTIONW, *LPSERVICE_DESCRIPTIONW;




typedef SERVICE_DESCRIPTIONA SERVICE_DESCRIPTION;
typedef LPSERVICE_DESCRIPTIONA LPSERVICE_DESCRIPTION;
#line 518 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winsvc.h"

//
// Actions to take on service failure
//
typedef enum _SC_ACTION_TYPE {
        SC_ACTION_NONE          = 0,
        SC_ACTION_RESTART       = 1,
        SC_ACTION_REBOOT        = 2,
        SC_ACTION_RUN_COMMAND   = 3,
        SC_ACTION_OWN_RESTART   = 4
} SC_ACTION_TYPE;

typedef struct _SC_ACTION {
    SC_ACTION_TYPE  Type;
    DWORD           Delay;
} SC_ACTION, *LPSC_ACTION;

typedef struct _SERVICE_FAILURE_ACTIONSA {
    DWORD       dwResetPeriod;
    LPSTR       lpRebootMsg;
    LPSTR       lpCommand;



    DWORD       cActions;



    SC_ACTION * lpsaActions;
} SERVICE_FAILURE_ACTIONSA, *LPSERVICE_FAILURE_ACTIONSA;
typedef struct _SERVICE_FAILURE_ACTIONSW {
    DWORD       dwResetPeriod;
    LPWSTR      lpRebootMsg;
    LPWSTR      lpCommand;



    DWORD       cActions;



    SC_ACTION * lpsaActions;
} SERVICE_FAILURE_ACTIONSW, *LPSERVICE_FAILURE_ACTIONSW;




typedef SERVICE_FAILURE_ACTIONSA SERVICE_FAILURE_ACTIONS;
typedef LPSERVICE_FAILURE_ACTIONSA LPSERVICE_FAILURE_ACTIONS;
#line 568 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winsvc.h"

//
// Service delayed autostart info setting
//
typedef struct _SERVICE_DELAYED_AUTO_START_INFO {
    BOOL       fDelayedAutostart;      // Delayed autostart flag
} SERVICE_DELAYED_AUTO_START_INFO, *LPSERVICE_DELAYED_AUTO_START_INFO;

//
// Service failure actions flag setting
//
typedef struct _SERVICE_FAILURE_ACTIONS_FLAG {
    BOOL       fFailureActionsOnNonCrashFailures;       // Failure actions flag
} SERVICE_FAILURE_ACTIONS_FLAG, *LPSERVICE_FAILURE_ACTIONS_FLAG;

//
// Service SID info setting
//
typedef struct _SERVICE_SID_INFO {
    DWORD       dwServiceSidType;     // Service SID type
} SERVICE_SID_INFO, *LPSERVICE_SID_INFO;

//
// Service required privileges information
//
typedef struct _SERVICE_REQUIRED_PRIVILEGES_INFOA {
    LPSTR       pmszRequiredPrivileges;             // Required privileges multi-sz
} SERVICE_REQUIRED_PRIVILEGES_INFOA, *LPSERVICE_REQUIRED_PRIVILEGES_INFOA;
//
// Service required privileges information
//
typedef struct _SERVICE_REQUIRED_PRIVILEGES_INFOW {
    LPWSTR      pmszRequiredPrivileges;             // Required privileges multi-sz
} SERVICE_REQUIRED_PRIVILEGES_INFOW, *LPSERVICE_REQUIRED_PRIVILEGES_INFOW;




typedef SERVICE_REQUIRED_PRIVILEGES_INFOA SERVICE_REQUIRED_PRIVILEGES_INFO;
typedef LPSERVICE_REQUIRED_PRIVILEGES_INFOA LPSERVICE_REQUIRED_PRIVILEGES_INFO;
#line 609 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winsvc.h"

//
// Service preshutdown timeout setting
//
typedef struct _SERVICE_PRESHUTDOWN_INFO {
    DWORD       dwPreshutdownTimeout;   // Timeout in msecs
} SERVICE_PRESHUTDOWN_INFO, *LPSERVICE_PRESHUTDOWN_INFO;

//
//  Service trigger data item
//
typedef struct _SERVICE_TRIGGER_SPECIFIC_DATA_ITEM
{
    DWORD   dwDataType; // Data type -- one of SERVICE_TRIGGER_DATA_TYPE_* constants



    DWORD   cbData;     // Size of trigger specific data



    PBYTE   pData;      // Trigger specific data
} SERVICE_TRIGGER_SPECIFIC_DATA_ITEM, *PSERVICE_TRIGGER_SPECIFIC_DATA_ITEM;

//
//  Trigger-specific information
//
typedef struct _SERVICE_TRIGGER
{
    DWORD                       dwTriggerType;              // One of SERVICE_TRIGGER_TYPE_* constants
    DWORD                       dwAction;                   // One of SERVICE_TRIGGER_ACTION_* constants
    GUID    *                   pTriggerSubtype;            // Provider GUID if the trigger type is SERVICE_TRIGGER_TYPE_CUSTOM
                                                            // Device class interface GUID if the trigger type is
                                                            // SERVICE_TRIGGER_TYPE_DEVICE_INTERFACE_ARRIVAL
                                                            // Aggregate identifier GUID if type is aggregate.



    DWORD                       cDataItems;                 // Number of data items in pDataItems array



    PSERVICE_TRIGGER_SPECIFIC_DATA_ITEM  pDataItems;       // Trigger specific data
} SERVICE_TRIGGER, *PSERVICE_TRIGGER;

//
// Service trigger information
//
typedef struct _SERVICE_TRIGGER_INFO {



    DWORD                   cTriggers;  // Number of triggers in the pTriggers array



    PSERVICE_TRIGGER        pTriggers;  // Array of triggers
    PBYTE                   pReserved;  // Reserved, must be NULL
} SERVICE_TRIGGER_INFO, *PSERVICE_TRIGGER_INFO;



//
// Preferred node information
//
typedef struct _SERVICE_PREFERRED_NODE_INFO {
    USHORT                  usPreferredNode;    // Preferred node
    BOOLEAN                 fDelete;            // Delete the preferred node setting
} SERVICE_PREFERRED_NODE_INFO, *LPSERVICE_PREFERRED_NODE_INFO;

//
// Time change information
//
typedef struct _SERVICE_TIMECHANGE_INFO {
    LARGE_INTEGER   liNewTime;      // New time
    LARGE_INTEGER   liOldTime;      // Old time
} SERVICE_TIMECHANGE_INFO, *PSERVICE_TIMECHANGE_INFO;

//
// Service launch protected setting
//
typedef struct _SERVICE_LAUNCH_PROTECTED_INFO {
    DWORD       dwLaunchProtected;     // Service launch protected
} SERVICE_LAUNCH_PROTECTED_INFO, *PSERVICE_LAUNCH_PROTECTED_INFO;

//
// Handle Types
//

struct SC_HANDLE__{int unused;}; typedef struct SC_HANDLE__ *SC_HANDLE ;
typedef SC_HANDLE   *LPSC_HANDLE;

struct SERVICE_STATUS_HANDLE__{int unused;}; typedef struct SERVICE_STATUS_HANDLE__ *SERVICE_STATUS_HANDLE ;

//
// Info levels for QueryServiceStatusEx
//

typedef enum _SC_STATUS_TYPE {
    SC_STATUS_PROCESS_INFO      = 0
} SC_STATUS_TYPE;

//
// Info levels for EnumServicesStatusEx
//
typedef enum _SC_ENUM_TYPE {
    SC_ENUM_PROCESS_INFO        = 0
} SC_ENUM_TYPE;


//
// Service Status Structures
//

typedef struct _SERVICE_STATUS {
    DWORD   dwServiceType;
    DWORD   dwCurrentState;
    DWORD   dwControlsAccepted;
    DWORD   dwWin32ExitCode;
    DWORD   dwServiceSpecificExitCode;
    DWORD   dwCheckPoint;
    DWORD   dwWaitHint;
} SERVICE_STATUS, *LPSERVICE_STATUS;

typedef struct _SERVICE_STATUS_PROCESS {
    DWORD   dwServiceType;
    DWORD   dwCurrentState;
    DWORD   dwControlsAccepted;
    DWORD   dwWin32ExitCode;
    DWORD   dwServiceSpecificExitCode;
    DWORD   dwCheckPoint;
    DWORD   dwWaitHint;
    DWORD   dwProcessId;
    DWORD   dwServiceFlags;
} SERVICE_STATUS_PROCESS, *LPSERVICE_STATUS_PROCESS;


//
// Service Status Enumeration Structure
//

typedef struct _ENUM_SERVICE_STATUSA {
    LPSTR             lpServiceName;
    LPSTR             lpDisplayName;
    SERVICE_STATUS    ServiceStatus;
} ENUM_SERVICE_STATUSA, *LPENUM_SERVICE_STATUSA;
typedef struct _ENUM_SERVICE_STATUSW {
    LPWSTR            lpServiceName;
    LPWSTR            lpDisplayName;
    SERVICE_STATUS    ServiceStatus;
} ENUM_SERVICE_STATUSW, *LPENUM_SERVICE_STATUSW;




typedef ENUM_SERVICE_STATUSA ENUM_SERVICE_STATUS;
typedef LPENUM_SERVICE_STATUSA LPENUM_SERVICE_STATUS;
#line 767 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winsvc.h"

typedef struct _ENUM_SERVICE_STATUS_PROCESSA {
    LPSTR                     lpServiceName;
    LPSTR                     lpDisplayName;
    SERVICE_STATUS_PROCESS    ServiceStatusProcess;
} ENUM_SERVICE_STATUS_PROCESSA, *LPENUM_SERVICE_STATUS_PROCESSA;
typedef struct _ENUM_SERVICE_STATUS_PROCESSW {
    LPWSTR                    lpServiceName;
    LPWSTR                    lpDisplayName;
    SERVICE_STATUS_PROCESS    ServiceStatusProcess;
} ENUM_SERVICE_STATUS_PROCESSW, *LPENUM_SERVICE_STATUS_PROCESSW;




typedef ENUM_SERVICE_STATUS_PROCESSA ENUM_SERVICE_STATUS_PROCESS;
typedef LPENUM_SERVICE_STATUS_PROCESSA LPENUM_SERVICE_STATUS_PROCESS;
#line 785 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winsvc.h"

//
// Structures for the Lock API functions
//

typedef LPVOID  SC_LOCK;

typedef struct _QUERY_SERVICE_LOCK_STATUSA {
    DWORD   fIsLocked;
    LPSTR   lpLockOwner;
    DWORD   dwLockDuration;
} QUERY_SERVICE_LOCK_STATUSA, *LPQUERY_SERVICE_LOCK_STATUSA;
typedef struct _QUERY_SERVICE_LOCK_STATUSW {
    DWORD   fIsLocked;
    LPWSTR  lpLockOwner;
    DWORD   dwLockDuration;
} QUERY_SERVICE_LOCK_STATUSW, *LPQUERY_SERVICE_LOCK_STATUSW;




typedef QUERY_SERVICE_LOCK_STATUSA QUERY_SERVICE_LOCK_STATUS;
typedef LPQUERY_SERVICE_LOCK_STATUSA LPQUERY_SERVICE_LOCK_STATUS;
#line 809 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winsvc.h"



//
// Query Service Configuration Structure
//

typedef struct _QUERY_SERVICE_CONFIGA {
    DWORD   dwServiceType;
    DWORD   dwStartType;
    DWORD   dwErrorControl;
    LPSTR   lpBinaryPathName;
    LPSTR   lpLoadOrderGroup;
    DWORD   dwTagId;
    LPSTR   lpDependencies;
    LPSTR   lpServiceStartName;
    LPSTR   lpDisplayName;
} QUERY_SERVICE_CONFIGA, *LPQUERY_SERVICE_CONFIGA;
typedef struct _QUERY_SERVICE_CONFIGW {
    DWORD   dwServiceType;
    DWORD   dwStartType;
    DWORD   dwErrorControl;
    LPWSTR  lpBinaryPathName;
    LPWSTR  lpLoadOrderGroup;
    DWORD   dwTagId;
    LPWSTR  lpDependencies;
    LPWSTR  lpServiceStartName;
    LPWSTR  lpDisplayName;
} QUERY_SERVICE_CONFIGW, *LPQUERY_SERVICE_CONFIGW;




typedef QUERY_SERVICE_CONFIGA QUERY_SERVICE_CONFIG;
typedef LPQUERY_SERVICE_CONFIGA LPQUERY_SERVICE_CONFIG;
#line 845 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winsvc.h"



//
// Function Prototype for the Service Main Function
//

typedef void __stdcall SERVICE_MAIN_FUNCTIONW (
    DWORD dwNumServicesArgs,
    LPWSTR *lpServiceArgVectors
    );

typedef void __stdcall SERVICE_MAIN_FUNCTIONA (
    DWORD dwNumServicesArgs,
    LPTSTR *lpServiceArgVectors
    );





#line 867 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winsvc.h"

typedef void (__stdcall *LPSERVICE_MAIN_FUNCTIONW)(
    DWORD   dwNumServicesArgs,
    LPWSTR  *lpServiceArgVectors
    );

typedef void (__stdcall *LPSERVICE_MAIN_FUNCTIONA)(
    DWORD   dwNumServicesArgs,
    LPSTR   *lpServiceArgVectors
    );





#line 883 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winsvc.h"


//
// Service Start Table
//

typedef struct _SERVICE_TABLE_ENTRYA {
    LPSTR                       lpServiceName;
    LPSERVICE_MAIN_FUNCTIONA    lpServiceProc;
}SERVICE_TABLE_ENTRYA, *LPSERVICE_TABLE_ENTRYA;
typedef struct _SERVICE_TABLE_ENTRYW {
    LPWSTR                      lpServiceName;
    LPSERVICE_MAIN_FUNCTIONW    lpServiceProc;
}SERVICE_TABLE_ENTRYW, *LPSERVICE_TABLE_ENTRYW;




typedef SERVICE_TABLE_ENTRYA SERVICE_TABLE_ENTRY;
typedef LPSERVICE_TABLE_ENTRYA LPSERVICE_TABLE_ENTRY;
#line 904 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winsvc.h"

//
// Prototype for the Service Control Handler Function
//

typedef void __stdcall HANDLER_FUNCTION (
    DWORD    dwControl
    );

typedef DWORD __stdcall HANDLER_FUNCTION_EX (
    DWORD    dwControl,
    DWORD    dwEventType,
    LPVOID   lpEventData,
    LPVOID   lpContext
    );

typedef void (__stdcall *LPHANDLER_FUNCTION)(
    DWORD    dwControl
    );

typedef DWORD (__stdcall *LPHANDLER_FUNCTION_EX)(
    DWORD    dwControl,
    DWORD    dwEventType,
    LPVOID   lpEventData,
    LPVOID   lpContext
    );

//
// Service notification parameters
//
typedef
void
( __stdcall * PFN_SC_NOTIFY_CALLBACK ) (
     PVOID pParameter
    );

//
//  Each new notify structure is a superset of the older version
//
typedef struct _SERVICE_NOTIFY_1 {
    DWORD                   dwVersion;
    PFN_SC_NOTIFY_CALLBACK  pfnNotifyCallback;
    PVOID                   pContext;
    DWORD                   dwNotificationStatus;
    SERVICE_STATUS_PROCESS  ServiceStatus;
} SERVICE_NOTIFY_1, *PSERVICE_NOTIFY_1;

typedef struct _SERVICE_NOTIFY_2A {
    DWORD                   dwVersion;
    PFN_SC_NOTIFY_CALLBACK  pfnNotifyCallback;
    PVOID                   pContext;
    DWORD                   dwNotificationStatus;
    SERVICE_STATUS_PROCESS  ServiceStatus;
    DWORD                   dwNotificationTriggered;
    LPSTR                   pszServiceNames;
} SERVICE_NOTIFY_2A, *PSERVICE_NOTIFY_2A;
typedef struct _SERVICE_NOTIFY_2W {
    DWORD                   dwVersion;
    PFN_SC_NOTIFY_CALLBACK  pfnNotifyCallback;
    PVOID                   pContext;
    DWORD                   dwNotificationStatus;
    SERVICE_STATUS_PROCESS  ServiceStatus;
    DWORD                   dwNotificationTriggered;
    LPWSTR                  pszServiceNames;
} SERVICE_NOTIFY_2W, *PSERVICE_NOTIFY_2W;




typedef SERVICE_NOTIFY_2A SERVICE_NOTIFY_2;
typedef PSERVICE_NOTIFY_2A PSERVICE_NOTIFY_2;
#line 976 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winsvc.h"

typedef SERVICE_NOTIFY_2A SERVICE_NOTIFYA, *PSERVICE_NOTIFYA;
typedef SERVICE_NOTIFY_2W SERVICE_NOTIFYW, *PSERVICE_NOTIFYW;




typedef SERVICE_NOTIFYA SERVICE_NOTIFY;
typedef PSERVICE_NOTIFYA PSERVICE_NOTIFY;
#line 986 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winsvc.h"

//
// Service control status reason parameters
//
typedef struct _SERVICE_CONTROL_STATUS_REASON_PARAMSA {
    DWORD                   dwReason;
    LPSTR                   pszComment;
    SERVICE_STATUS_PROCESS  ServiceStatus;
} SERVICE_CONTROL_STATUS_REASON_PARAMSA, *PSERVICE_CONTROL_STATUS_REASON_PARAMSA;
//
// Service control status reason parameters
//
typedef struct _SERVICE_CONTROL_STATUS_REASON_PARAMSW {
    DWORD                   dwReason;
    LPWSTR                  pszComment;
    SERVICE_STATUS_PROCESS  ServiceStatus;
} SERVICE_CONTROL_STATUS_REASON_PARAMSW, *PSERVICE_CONTROL_STATUS_REASON_PARAMSW;




typedef SERVICE_CONTROL_STATUS_REASON_PARAMSA SERVICE_CONTROL_STATUS_REASON_PARAMS;
typedef PSERVICE_CONTROL_STATUS_REASON_PARAMSA PSERVICE_CONTROL_STATUS_REASON_PARAMS;
#line 1010 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winsvc.h"

//
//  Service start reason
//
typedef struct _SERVICE_START_REASON {
    DWORD                   dwReason;
} SERVICE_START_REASON, *PSERVICE_START_REASON;

///////////////////////////////////////////////////////////////////////////
// API Function Prototypes
///////////////////////////////////////////////////////////////////////////

__declspec(dllimport)
BOOL
__stdcall
ChangeServiceConfigA(
            SC_HANDLE    hService,
            DWORD        dwServiceType,
            DWORD        dwStartType,
            DWORD        dwErrorControl,
        LPCSTR     lpBinaryPathName,
        LPCSTR     lpLoadOrderGroup,
       LPDWORD      lpdwTagId,
        LPCSTR     lpDependencies,
        LPCSTR     lpServiceStartName,
        LPCSTR     lpPassword,
        LPCSTR     lpDisplayName
    );
__declspec(dllimport)
BOOL
__stdcall
ChangeServiceConfigW(
            SC_HANDLE    hService,
            DWORD        dwServiceType,
            DWORD        dwStartType,
            DWORD        dwErrorControl,
        LPCWSTR     lpBinaryPathName,
        LPCWSTR     lpLoadOrderGroup,
       LPDWORD      lpdwTagId,
        LPCWSTR     lpDependencies,
        LPCWSTR     lpServiceStartName,
        LPCWSTR     lpPassword,
        LPCWSTR     lpDisplayName
    );




#line 1059 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winsvc.h"

__declspec(dllimport)
BOOL
__stdcall
ChangeServiceConfig2A(
            SC_HANDLE    hService,
            DWORD        dwInfoLevel,
        LPVOID       lpInfo
    );
__declspec(dllimport)
BOOL
__stdcall
ChangeServiceConfig2W(
            SC_HANDLE    hService,
            DWORD        dwInfoLevel,
        LPVOID       lpInfo
    );




#line 1081 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winsvc.h"

__declspec(dllimport)
BOOL
__stdcall
CloseServiceHandle(
            SC_HANDLE   hSCObject
    );

__declspec(dllimport)
BOOL
__stdcall
ControlService(
            SC_HANDLE           hService,
            DWORD               dwControl,
           LPSERVICE_STATUS    lpServiceStatus
    );


__declspec(dllimport)
SC_HANDLE
__stdcall
CreateServiceA(
            SC_HANDLE    hSCManager,
            LPCSTR     lpServiceName,
        LPCSTR     lpDisplayName,
            DWORD        dwDesiredAccess,
            DWORD        dwServiceType,
            DWORD        dwStartType,
            DWORD        dwErrorControl,
        LPCSTR     lpBinaryPathName,
        LPCSTR     lpLoadOrderGroup,
       LPDWORD      lpdwTagId,
        LPCSTR     lpDependencies,
        LPCSTR     lpServiceStartName,
        LPCSTR     lpPassword
    );

__declspec(dllimport)
SC_HANDLE
__stdcall
CreateServiceW(
            SC_HANDLE    hSCManager,
            LPCWSTR     lpServiceName,
        LPCWSTR     lpDisplayName,
            DWORD        dwDesiredAccess,
            DWORD        dwServiceType,
            DWORD        dwStartType,
            DWORD        dwErrorControl,
        LPCWSTR     lpBinaryPathName,
        LPCWSTR     lpLoadOrderGroup,
       LPDWORD      lpdwTagId,
        LPCWSTR     lpDependencies,
        LPCWSTR     lpServiceStartName,
        LPCWSTR     lpPassword
    );




#line 1141 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winsvc.h"

__declspec(dllimport)
BOOL
__stdcall
DeleteService(
            SC_HANDLE   hService
    );


__declspec(dllimport)
BOOL
__stdcall
EnumDependentServicesA(
                SC_HANDLE               hService,
                DWORD                   dwServiceState,
    
                    LPENUM_SERVICE_STATUSA  lpServices,
                DWORD                   cbBufSize,
               LPDWORD                 pcbBytesNeeded,
               LPDWORD                 lpServicesReturned
    );

__declspec(dllimport)
BOOL
__stdcall
EnumDependentServicesW(
                SC_HANDLE               hService,
                DWORD                   dwServiceState,
    
                    LPENUM_SERVICE_STATUSW  lpServices,
                DWORD                   cbBufSize,
               LPDWORD                 pcbBytesNeeded,
               LPDWORD                 lpServicesReturned
    );




#line 1180 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winsvc.h"

#line 1182 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winsvc.h"
#pragma endregion

#pragma region Desktop Family



__declspec(dllimport)
BOOL
__stdcall
EnumServicesStatusA(
                SC_HANDLE               hSCManager,
                DWORD                   dwServiceType,
                DWORD                   dwServiceState,
    
                    LPENUM_SERVICE_STATUSA  lpServices,
                DWORD                   cbBufSize,
               LPDWORD                 pcbBytesNeeded,
               LPDWORD                 lpServicesReturned,
         LPDWORD                 lpResumeHandle
    );

__declspec(dllimport)
BOOL
__stdcall
EnumServicesStatusW(
                SC_HANDLE               hSCManager,
                DWORD                   dwServiceType,
                DWORD                   dwServiceState,
    
                    LPENUM_SERVICE_STATUSW  lpServices,
                DWORD                   cbBufSize,
               LPDWORD                 pcbBytesNeeded,
               LPDWORD                 lpServicesReturned,
         LPDWORD                 lpResumeHandle
    );




#line 1222 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winsvc.h"

#line 1224 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winsvc.h"
#pragma endregion

#pragma region Desktop Family or OneCore Family



__declspec(dllimport)
BOOL
__stdcall
EnumServicesStatusExA(
                SC_HANDLE               hSCManager,
                SC_ENUM_TYPE            InfoLevel,
                DWORD                   dwServiceType,
                DWORD                   dwServiceState,
    
                    LPBYTE                  lpServices,
                DWORD                   cbBufSize,
               LPDWORD                 pcbBytesNeeded,
               LPDWORD                 lpServicesReturned,
         LPDWORD                 lpResumeHandle,
            LPCSTR                pszGroupName
    );

__declspec(dllimport)
BOOL
__stdcall
EnumServicesStatusExW(
                SC_HANDLE               hSCManager,
                SC_ENUM_TYPE            InfoLevel,
                DWORD                   dwServiceType,
                DWORD                   dwServiceState,
    
                    LPBYTE                  lpServices,
                DWORD                   cbBufSize,
               LPDWORD                 pcbBytesNeeded,
               LPDWORD                 lpServicesReturned,
         LPDWORD                 lpResumeHandle,
            LPCWSTR                pszGroupName
    );




#line 1268 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winsvc.h"


__declspec(dllimport)
BOOL
__stdcall
GetServiceKeyNameA(
                SC_HANDLE               hSCManager,
                LPCSTR                lpDisplayName,
    
                    LPSTR                 lpServiceName,
             LPDWORD                 lpcchBuffer
    );

__declspec(dllimport)
BOOL
__stdcall
GetServiceKeyNameW(
                SC_HANDLE               hSCManager,
                LPCWSTR                lpDisplayName,
    
                    LPWSTR                 lpServiceName,
             LPDWORD                 lpcchBuffer
    );




#line 1296 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winsvc.h"


__declspec(dllimport)
BOOL
__stdcall
GetServiceDisplayNameA(
                SC_HANDLE               hSCManager,
                LPCSTR                lpServiceName,
    
                    LPSTR                 lpDisplayName,
             LPDWORD                 lpcchBuffer
    );

__declspec(dllimport)
BOOL
__stdcall
GetServiceDisplayNameW(
                SC_HANDLE               hSCManager,
                LPCWSTR                lpServiceName,
    
                    LPWSTR                 lpDisplayName,
             LPDWORD                 lpcchBuffer
    );




#line 1324 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winsvc.h"

#line 1326 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winsvc.h"
#pragma endregion

#pragma region Desktop Family


__declspec(dllimport)
SC_LOCK
__stdcall
LockServiceDatabase(
                SC_HANDLE               hSCManager
    );

__declspec(dllimport)
BOOL
__stdcall
NotifyBootConfigStatus(
                BOOL                    BootAcceptable
    );

#line 1346 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winsvc.h"
#pragma endregion

#pragma region Desktop Family or OneCore Family



__declspec(dllimport)
SC_HANDLE
__stdcall
OpenSCManagerA(
            LPCSTR                lpMachineName,
            LPCSTR                lpDatabaseName,
                DWORD                   dwDesiredAccess
    );

__declspec(dllimport)
SC_HANDLE
__stdcall
OpenSCManagerW(
            LPCWSTR                lpMachineName,
            LPCWSTR                lpDatabaseName,
                DWORD                   dwDesiredAccess
    );




#line 1374 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winsvc.h"


__declspec(dllimport)
SC_HANDLE
__stdcall
OpenServiceA(
                SC_HANDLE               hSCManager,
                LPCSTR                lpServiceName,
                DWORD                   dwDesiredAccess
    );

__declspec(dllimport)
SC_HANDLE
__stdcall
OpenServiceW(
                SC_HANDLE               hSCManager,
                LPCWSTR                lpServiceName,
                DWORD                   dwDesiredAccess
    );




#line 1398 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winsvc.h"


__declspec(dllimport)
BOOL
__stdcall
QueryServiceConfigA(
                SC_HANDLE               hService,
    
                    LPQUERY_SERVICE_CONFIGA lpServiceConfig,
                DWORD                   cbBufSize,
               LPDWORD                 pcbBytesNeeded
    );

__declspec(dllimport)
BOOL
__stdcall
QueryServiceConfigW(
                SC_HANDLE               hService,
    
                    LPQUERY_SERVICE_CONFIGW lpServiceConfig,
                DWORD                   cbBufSize,
               LPDWORD                 pcbBytesNeeded
    );




#line 1426 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winsvc.h"









__declspec(dllimport)
BOOL
__stdcall
QueryServiceConfig2A(
                SC_HANDLE               hService,
                DWORD                   dwInfoLevel,
    
                    LPBYTE                  lpBuffer,
                DWORD                   cbBufSize,
               LPDWORD                 pcbBytesNeeded
    );








__declspec(dllimport)
BOOL
__stdcall
QueryServiceConfig2W(
                SC_HANDLE               hService,
                DWORD                   dwInfoLevel,
    
                    LPBYTE                  lpBuffer,
                DWORD                   cbBufSize,
               LPDWORD                 pcbBytesNeeded
    );




#line 1470 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winsvc.h"

#line 1472 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winsvc.h"
#pragma endregion

#pragma region Desktop Family



__declspec(dllimport)
BOOL
__stdcall
QueryServiceLockStatusA(
                SC_HANDLE                       hSCManager,
    
                    LPQUERY_SERVICE_LOCK_STATUSA    lpLockStatus,
                DWORD                           cbBufSize,
               LPDWORD                         pcbBytesNeeded
    );

__declspec(dllimport)
BOOL
__stdcall
QueryServiceLockStatusW(
                SC_HANDLE                       hSCManager,
    
                    LPQUERY_SERVICE_LOCK_STATUSW    lpLockStatus,
                DWORD                           cbBufSize,
               LPDWORD                         pcbBytesNeeded
    );




#line 1504 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winsvc.h"

#line 1506 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winsvc.h"
#pragma endregion

#pragma region Desktop Family or OneCore Family



__declspec(dllimport)
BOOL
__stdcall
QueryServiceObjectSecurity(
                SC_HANDLE               hService,
                SECURITY_INFORMATION    dwSecurityInformation,
    
                    PSECURITY_DESCRIPTOR    lpSecurityDescriptor,
                DWORD                   cbBufSize,
               LPDWORD                 pcbBytesNeeded
    );


__declspec(dllimport)
BOOL
__stdcall
QueryServiceStatus(
                SC_HANDLE           hService,
               LPSERVICE_STATUS    lpServiceStatus
    );


__declspec(dllimport)
BOOL
__stdcall
QueryServiceStatusEx(
                SC_HANDLE           hService,
                SC_STATUS_TYPE      InfoLevel,
    
                    LPBYTE              lpBuffer,
                DWORD               cbBufSize,
               LPDWORD             pcbBytesNeeded
    );


__declspec(dllimport)
SERVICE_STATUS_HANDLE
__stdcall
RegisterServiceCtrlHandlerA(
        LPCSTR                    lpServiceName,
        
            LPHANDLER_FUNCTION          lpHandlerProc
    );

__declspec(dllimport)
SERVICE_STATUS_HANDLE
__stdcall
RegisterServiceCtrlHandlerW(
        LPCWSTR                    lpServiceName,
        
            LPHANDLER_FUNCTION          lpHandlerProc
    );




#line 1569 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winsvc.h"


__declspec(dllimport)
SERVICE_STATUS_HANDLE
__stdcall
RegisterServiceCtrlHandlerExA(
        LPCSTR                    lpServiceName,
        
            LPHANDLER_FUNCTION_EX       lpHandlerProc,
     LPVOID                     lpContext
    );

__declspec(dllimport)
SERVICE_STATUS_HANDLE
__stdcall
RegisterServiceCtrlHandlerExW(
        LPCWSTR                    lpServiceName,
        
            LPHANDLER_FUNCTION_EX       lpHandlerProc,
     LPVOID                     lpContext
    );




#line 1595 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winsvc.h"

__declspec(dllimport)
BOOL
__stdcall
SetServiceObjectSecurity(
            SC_HANDLE               hService,
            SECURITY_INFORMATION    dwSecurityInformation,
            PSECURITY_DESCRIPTOR    lpSecurityDescriptor
    );

__declspec(dllimport)
BOOL
__stdcall
SetServiceStatus(
            SERVICE_STATUS_HANDLE   hServiceStatus,
            LPSERVICE_STATUS        lpServiceStatus
    );

__declspec(dllimport)
BOOL
__stdcall
StartServiceCtrlDispatcherA(
     const  SERVICE_TABLE_ENTRYA    *lpServiceStartTable
    );
__declspec(dllimport)
BOOL
__stdcall
StartServiceCtrlDispatcherW(
     const  SERVICE_TABLE_ENTRYW    *lpServiceStartTable
    );




#line 1630 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winsvc.h"


__declspec(dllimport)
BOOL
__stdcall
StartServiceA(
                SC_HANDLE            hService,
                DWORD                dwNumServiceArgs,
    
                    LPCSTR             *lpServiceArgVectors
    );
__declspec(dllimport)
BOOL
__stdcall
StartServiceW(
                SC_HANDLE            hService,
                DWORD                dwNumServiceArgs,
    
                    LPCWSTR             *lpServiceArgVectors
    );




#line 1655 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winsvc.h"

#line 1657 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winsvc.h"
#pragma endregion

#pragma region Desktop Family


__declspec(dllimport)
BOOL
__stdcall
UnlockServiceDatabase(
                SC_LOCK             ScLock
    );

#line 1670 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winsvc.h"
#pragma endregion

#pragma region Desktop Family or OneCore Family




__declspec(dllimport)
DWORD
__stdcall
NotifyServiceStatusChangeA (
            SC_HANDLE               hService,
            DWORD                   dwNotifyMask,
            PSERVICE_NOTIFYA        pNotifyBuffer
    );
__declspec(dllimport)
DWORD
__stdcall
NotifyServiceStatusChangeW (
            SC_HANDLE               hService,
            DWORD                   dwNotifyMask,
            PSERVICE_NOTIFYW        pNotifyBuffer
    );




#line 1698 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winsvc.h"

__declspec(dllimport)
BOOL
__stdcall
ControlServiceExA(
            SC_HANDLE               hService,
            DWORD                   dwControl,
            DWORD                   dwInfoLevel,
         PVOID                   pControlParams
    );
__declspec(dllimport)
BOOL
__stdcall
ControlServiceExW(
            SC_HANDLE               hService,
            DWORD                   dwControl,
            DWORD                   dwInfoLevel,
         PVOID                   pControlParams
    );




#line 1722 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winsvc.h"

__declspec(dllimport)
BOOL
__stdcall
QueryServiceDynamicInformation (
            SERVICE_STATUS_HANDLE   hServiceStatus,
            DWORD                   dwInfoLevel,
        PVOID           *       ppDynamicInfo
    );

#line 1733 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winsvc.h"




















































#line 1786 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winsvc.h"























#line 1810 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winsvc.h"



















#line 1830 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winsvc.h"

#line 1832 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winsvc.h"
#pragma endregion


}
#line 1837 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winsvc.h"


#pragma warning(pop)
#line 1841 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winsvc.h"

#line 1843 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\winsvc.h"

#line 238 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\Windows.h"
#line 239 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\Windows.h"



#line 1 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\mcx.h"
/************************************************************************
*                                                                       *
*   mcx.h -- This module defines the 32-Bit Windows MCX APIs            *
*                                                                       *
*   Copyright (c) 1990-1999, Microsoft Corp. All rights reserved.       *
*                                                                       *
************************************************************************/





#pragma once
#line 15 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\mcx.h"


#pragma warning(push)
#pragma warning(disable:4820) 
#line 20 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\mcx.h"

typedef struct _MODEMDEVCAPS {
    DWORD   dwActualSize;
    DWORD   dwRequiredSize;
    DWORD   dwDevSpecificOffset;
    DWORD   dwDevSpecificSize;

    // product and version identification
    DWORD   dwModemProviderVersion;
    DWORD   dwModemManufacturerOffset;
    DWORD   dwModemManufacturerSize;
    DWORD   dwModemModelOffset;
    DWORD   dwModemModelSize;
    DWORD   dwModemVersionOffset;
    DWORD   dwModemVersionSize;

    // local option capabilities
    DWORD   dwDialOptions;          // bitmap of supported values
    DWORD   dwCallSetupFailTimer;   // maximum in seconds
    DWORD   dwInactivityTimeout;    // maximum in seconds
    DWORD   dwSpeakerVolume;        // bitmap of supported values
    DWORD   dwSpeakerMode;          // bitmap of supported values
    DWORD   dwModemOptions;         // bitmap of supported values
    DWORD   dwMaxDTERate;           // maximum value in bit/s
    DWORD   dwMaxDCERate;           // maximum value in bit/s

    // Variable portion for proprietary expansion
    BYTE    abVariablePortion [1];
} MODEMDEVCAPS, *PMODEMDEVCAPS, *LPMODEMDEVCAPS;

typedef struct _MODEMSETTINGS {
    DWORD   dwActualSize;
    DWORD   dwRequiredSize;
    DWORD   dwDevSpecificOffset;
    DWORD   dwDevSpecificSize;

    // static local options (read/write)
    DWORD   dwCallSetupFailTimer;       // seconds
    DWORD   dwInactivityTimeout;        // seconds
    DWORD   dwSpeakerVolume;            // level
    DWORD   dwSpeakerMode;              // mode
    DWORD   dwPreferredModemOptions;    // bitmap

    // negotiated options (read only) for current or last call
    DWORD   dwNegotiatedModemOptions;   // bitmap
    DWORD   dwNegotiatedDCERate;        // bit/s

    // Variable portion for proprietary expansion
    BYTE    abVariablePortion [1];
} MODEMSETTINGS, *PMODEMSETTINGS, *LPMODEMSETTINGS;

// Dial Options




// SpeakerVolume for MODEMDEVCAPS




// SpeakerVolume for MODEMSETTINGS




// SpeakerMode for MODEMDEVCAPS





// SpeakerMode for MODEMSETTINGS





// Modem Options














//=========================================================================
//
//
//      EXTENDED MODEM OPTIONS INFORMATION
//
//      THE following macros define additional bits in dwPreferredModemOptions.
//
//      These bits specify information relevant to making ISDN and GSM
//      calls, such as which protocol to use.
//
//=========================================================================










//
// PROTOCOLINFO is the union of PROTOCOLID and PROTOCOLDATA ...
//



//
// EXTENDEDINFO is the union of BEARERMODE and PROTOCOLINFO
//

























//
// MDM_GET_PROTOCOLINFO gets the protocol-id and info bits in
// their IN-PLACE form (preserving their place in dwModemPreferredOptions)
//



//
// MDM_SET_PROTOCOLINFO takes as its argument the protocol-id and info bits in
// their IN-PLACE form (final position within dwModemPreferredOptions)
//




//
// MDM_GEN_PROTOCOLINFO generates the  the protocol-id and info bits in
// their IN-PLACE form (final position  within dwModemPreferredOptions).
//




//
// MDM_GET_EXTENDEDIONFO gets the bearermode and protocol information in
// their IN-PLACE form (preserving their place in dwModemPreferredOptions)
//



//
// MDM_SET_PROTOCOLINFO takes as its argument the bearermode and
// protocol bits in their IN-PLACE form (final position within
// dwModemPreferredOptions)
//





//
// MDM_GEN_EXTENDEDINFO generates the bearermode and protocol information
// in their IN-PLACE form (final position within dwModemPreferredOptions0.
//





//=========================================================================
//  BEARER MODES
//=========================================================================
//





//=========================================================================
//  PROTOCOL IDs
//=========================================================================
//












//=========================================================================
//  HDLC PPP PROTOCOL INFORMATION
//=========================================================================
//
// Following are specific to the HDLC-PPP protocol.
// The shifts are w.r.t. the start of the PROTOCOLDATA field.



































































































































//=========================================================================
//  V120 PROTOCOL INFORMATION
//
// The shifts are w.r.t. the start of the PROTOCOLDATA field.
//
//=========================================================================



























































//=========================================================================
//  X75 PROTOCOL INFORMATION
//
// The shifts are w.r.t. the start of the PROTOCOLDATA field.
//
//=========================================================================
















































//=========================================================================
//  V110 PROTOCOL INFORMATION
//
// The shifts are w.r.t. the start of the PROTOCOLDATA field.
//
//=========================================================================





































































































//=========================================================================
//  AUTO PROTOCOL INFORMATION (ie, when the protocol is detected automatically)
//
// The shifts are w.r.t. the start of the PROTOCOLDATA field.
//
//=========================================================================
//
// Following are specific to the AUTO-protocol
//


































//=========================================================================
//  ANALOG PROTOCOL INFORMATION (Applicable only to GSM)
//=========================================================================
//
// Following are specific to GSM Analog protocol
//

























//
//  v34 anolog for isdn
//









//=========================================================================
//  GPRS PROTOCOL INFORMATION (Applicable only to GSM)
//=========================================================================
//
// Following are specific to GPRS protocol
//








//=========================================================================
//  PIAFS PROTOCOL INFORMATION
//=========================================================================
//
// Following are specific to PIAFS protocol
//

















#pragma warning(pop)
#line 730 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\mcx.h"

#line 732 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\mcx.h"
#line 243 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\Windows.h"
#line 244 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\Windows.h"


#line 1 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\imm.h"


/**********************************************************************/
/*      imm.h - Input Method Manager definitions                      */
/*                                                                    */
/*      Copyright (c) Microsoft Corporation. All rights reserved.     */
/**********************************************************************/






extern "C" {
#line 16 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\imm.h"


#pragma warning(push)
#pragma warning(disable:4820) 
#line 21 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\imm.h"






#pragma region Application Family



struct HIMC__{int unused;}; typedef struct HIMC__ *HIMC ;
struct HIMCC__{int unused;}; typedef struct HIMCC__ *HIMCC ;



#line 37 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\imm.h"

#line 39 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\imm.h"
#pragma endregion

#pragma region Desktop Family


typedef HKL   *LPHKL;
typedef UINT  *LPUINT;

#line 48 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\imm.h"
#pragma endregion

#pragma region Application Family


typedef struct tagCOMPOSITIONFORM {
    DWORD dwStyle;
    POINT ptCurrentPos;
    RECT  rcArea;
} COMPOSITIONFORM, *PCOMPOSITIONFORM,  *NPCOMPOSITIONFORM,  *LPCOMPOSITIONFORM;


typedef struct tagCANDIDATEFORM {
    DWORD dwIndex;
    DWORD dwStyle;
    POINT ptCurrentPos;
    RECT  rcArea;
} CANDIDATEFORM, *PCANDIDATEFORM,  *NPCANDIDATEFORM,  *LPCANDIDATEFORM;

#line 68 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\imm.h"
#pragma endregion



#pragma region Desktop Family


typedef struct tagCANDIDATELIST {
    DWORD dwSize;
    DWORD dwStyle;
    DWORD dwCount;
    DWORD dwSelection;
    DWORD dwPageStart;
    DWORD dwPageSize;
    DWORD dwOffset[1];
} CANDIDATELIST, *PCANDIDATELIST,  *NPCANDIDATELIST,  *LPCANDIDATELIST;

#line 86 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\imm.h"
#pragma endregion


#pragma region Application Family


typedef struct tagREGISTERWORDA {
    LPSTR   lpReading;
    LPSTR   lpWord;
} REGISTERWORDA, *PREGISTERWORDA,  *NPREGISTERWORDA,  *LPREGISTERWORDA;
typedef struct tagREGISTERWORDW {
    LPWSTR  lpReading;
    LPWSTR  lpWord;
} REGISTERWORDW, *PREGISTERWORDW,  *NPREGISTERWORDW,  *LPREGISTERWORDW;






typedef REGISTERWORDA REGISTERWORD;
typedef PREGISTERWORDA PREGISTERWORD;
typedef NPREGISTERWORDA NPREGISTERWORD;
typedef LPREGISTERWORDA LPREGISTERWORD;
#line 111 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\imm.h"

#line 113 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\imm.h"
#pragma endregion



#pragma region Desktop Family


typedef struct tagRECONVERTSTRING {
    DWORD dwSize;
    DWORD dwVersion;
    DWORD dwStrLen;
    DWORD dwStrOffset;
    DWORD dwCompStrLen;
    DWORD dwCompStrOffset;
    DWORD dwTargetStrLen;
    DWORD dwTargetStrOffset;
} RECONVERTSTRING, *PRECONVERTSTRING,  *NPRECONVERTSTRING,  *LPRECONVERTSTRING;

#line 132 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\imm.h"
#pragma endregion

#line 135 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\imm.h"



#pragma region Application Family


typedef struct tagSTYLEBUFA {
    DWORD       dwStyle;
    CHAR        szDescription[32 ];
} STYLEBUFA, *PSTYLEBUFA,  *NPSTYLEBUFA,  *LPSTYLEBUFA;
typedef struct tagSTYLEBUFW {
    DWORD       dwStyle;
    WCHAR       szDescription[32 ];
} STYLEBUFW, *PSTYLEBUFW,  *NPSTYLEBUFW,  *LPSTYLEBUFW;






typedef STYLEBUFA STYLEBUF;
typedef PSTYLEBUFA PSTYLEBUF;
typedef NPSTYLEBUFA NPSTYLEBUF;
typedef LPSTYLEBUFA LPSTYLEBUF;
#line 160 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\imm.h"

#line 162 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\imm.h"
#pragma endregion





#pragma region Desktop Family


typedef struct tagIMEMENUITEMINFOA {
    UINT        cbSize;
    UINT        fType;
    UINT        fState;
    UINT        wID;
    HBITMAP     hbmpChecked;
    HBITMAP     hbmpUnchecked;
    DWORD       dwItemData;
    CHAR        szString[80 ];
    HBITMAP     hbmpItem;
} IMEMENUITEMINFOA, *PIMEMENUITEMINFOA,  *NPIMEMENUITEMINFOA,  *LPIMEMENUITEMINFOA;
typedef struct tagIMEMENUITEMINFOW {
    UINT        cbSize;
    UINT        fType;
    UINT        fState;
    UINT        wID;
    HBITMAP     hbmpChecked;
    HBITMAP     hbmpUnchecked;
    DWORD       dwItemData;
    WCHAR       szString[80 ];
    HBITMAP     hbmpItem;
} IMEMENUITEMINFOW, *PIMEMENUITEMINFOW,  *NPIMEMENUITEMINFOW,  *LPIMEMENUITEMINFOW;






typedef IMEMENUITEMINFOA IMEMENUITEMINFO;
typedef PIMEMENUITEMINFOA PIMEMENUITEMINFO;
typedef NPIMEMENUITEMINFOA NPIMEMENUITEMINFO;
typedef LPIMEMENUITEMINFOA LPIMEMENUITEMINFO;
#line 204 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\imm.h"

typedef struct tagIMECHARPOSITION {
    DWORD       dwSize;
    DWORD       dwCharPos;
    POINT       pt;
    UINT        cLineHeight;
    RECT        rcDocument;
} IMECHARPOSITION, *PIMECHARPOSITION,  *NPIMECHARPOSITION,  *LPIMECHARPOSITION;

typedef BOOL    (__stdcall * IMCENUMPROC)(HIMC, LPARAM);

#line 216 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\imm.h"
#pragma endregion

#line 219 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\imm.h"



// prototype of IMM API

#pragma region Desktop Family


HKL  __stdcall ImmInstallIMEA( LPCSTR lpszIMEFileName,  LPCSTR lpszLayoutText);
HKL  __stdcall ImmInstallIMEW( LPCWSTR lpszIMEFileName,  LPCWSTR lpszLayoutText);




#line 234 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\imm.h"

HWND __stdcall ImmGetDefaultIMEWnd( HWND);

UINT __stdcall ImmGetDescriptionA( HKL,  LPSTR lpszDescription,  UINT uBufLen);
UINT __stdcall ImmGetDescriptionW( HKL,  LPWSTR lpszDescription,  UINT uBufLen);




#line 244 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\imm.h"

UINT __stdcall ImmGetIMEFileNameA( HKL,  LPSTR lpszFileName,  UINT uBufLen);
UINT __stdcall ImmGetIMEFileNameW( HKL,  LPWSTR lpszFileName,  UINT uBufLen);




#line 252 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\imm.h"

DWORD __stdcall ImmGetProperty( HKL,  DWORD);

BOOL __stdcall ImmIsIME( HKL);

BOOL __stdcall ImmSimulateHotKey( HWND,  DWORD);

HIMC __stdcall ImmCreateContext(void);
BOOL __stdcall ImmDestroyContext( HIMC);
HIMC __stdcall ImmGetContext( HWND);
BOOL __stdcall ImmReleaseContext( HWND,  HIMC);
HIMC __stdcall ImmAssociateContext( HWND,  HIMC);

BOOL __stdcall ImmAssociateContextEx( HWND,  HIMC,  DWORD);
#line 267 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\imm.h"

LONG  __stdcall ImmGetCompositionStringA( HIMC,  DWORD,  LPVOID lpBuf,  DWORD dwBufLen);
LONG  __stdcall ImmGetCompositionStringW( HIMC,  DWORD,  LPVOID lpBuf,  DWORD dwBufLen);




#line 275 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\imm.h"

BOOL  __stdcall ImmSetCompositionStringA( HIMC,  DWORD dwIndex,  LPVOID lpComp,  DWORD dwCompLen,  LPVOID lpRead,  DWORD dwReadLen);
BOOL  __stdcall ImmSetCompositionStringW( HIMC,  DWORD dwIndex,  LPVOID lpComp,  DWORD dwCompLen,  LPVOID lpRead,  DWORD dwReadLen);




#line 283 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\imm.h"

DWORD __stdcall ImmGetCandidateListCountA( HIMC,  LPDWORD lpdwListCount);
DWORD __stdcall ImmGetCandidateListCountW( HIMC,  LPDWORD lpdwListCount);




#line 291 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\imm.h"

DWORD __stdcall ImmGetCandidateListA( HIMC,  DWORD deIndex,  LPCANDIDATELIST lpCandList,  DWORD dwBufLen);
DWORD __stdcall ImmGetCandidateListW( HIMC,  DWORD deIndex,  LPCANDIDATELIST lpCandList,  DWORD dwBufLen);




#line 299 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\imm.h"

DWORD __stdcall ImmGetGuideLineA( HIMC,  DWORD dwIndex,  LPSTR lpBuf,  DWORD dwBufLen);
DWORD __stdcall ImmGetGuideLineW( HIMC,  DWORD dwIndex,  LPWSTR lpBuf,  DWORD dwBufLen);




#line 307 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\imm.h"

BOOL __stdcall ImmGetConversionStatus( HIMC,  LPDWORD lpfdwConversion,  LPDWORD lpfdwSentence);
BOOL __stdcall ImmSetConversionStatus( HIMC,  DWORD,  DWORD);
BOOL __stdcall ImmGetOpenStatus( HIMC);
BOOL __stdcall ImmSetOpenStatus( HIMC,  BOOL);


BOOL __stdcall ImmGetCompositionFontA( HIMC,  LPLOGFONTA lplf);
BOOL __stdcall ImmGetCompositionFontW( HIMC,  LPLOGFONTW lplf);




#line 321 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\imm.h"

BOOL __stdcall ImmSetCompositionFontA( HIMC,  LPLOGFONTA lplf);
BOOL __stdcall ImmSetCompositionFontW( HIMC,  LPLOGFONTW lplf);




#line 329 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\imm.h"
#line 330 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\imm.h"

BOOL    __stdcall ImmConfigureIMEA( HKL,  HWND,  DWORD,  LPVOID);
BOOL    __stdcall ImmConfigureIMEW( HKL,  HWND,  DWORD,  LPVOID);




#line 338 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\imm.h"

LRESULT __stdcall ImmEscapeA( HKL,  HIMC,  UINT,  LPVOID);
LRESULT __stdcall ImmEscapeW( HKL,  HIMC,  UINT,  LPVOID);




#line 346 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\imm.h"

DWORD   __stdcall ImmGetConversionListA( HKL,  HIMC,  LPCSTR lpSrc,  LPCANDIDATELIST lpDst,  DWORD dwBufLen,  UINT uFlag);
DWORD   __stdcall ImmGetConversionListW( HKL,  HIMC,  LPCWSTR lpSrc,  LPCANDIDATELIST lpDst,  DWORD dwBufLen,  UINT uFlag);




#line 354 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\imm.h"

BOOL    __stdcall ImmNotifyIME( HIMC,  DWORD dwAction,  DWORD dwIndex,  DWORD dwValue);

BOOL __stdcall ImmGetStatusWindowPos( HIMC,  LPPOINT lpptPos);
BOOL __stdcall ImmSetStatusWindowPos( HIMC,  LPPOINT lpptPos);
BOOL __stdcall ImmGetCompositionWindow( HIMC,  LPCOMPOSITIONFORM lpCompForm);
BOOL __stdcall ImmSetCompositionWindow( HIMC,  LPCOMPOSITIONFORM lpCompForm);
BOOL __stdcall ImmGetCandidateWindow( HIMC,  DWORD,  LPCANDIDATEFORM lpCandidate);
BOOL __stdcall ImmSetCandidateWindow( HIMC,  LPCANDIDATEFORM lpCandidate);

BOOL __stdcall ImmIsUIMessageA( HWND,  UINT,  WPARAM,  LPARAM);
BOOL __stdcall ImmIsUIMessageW( HWND,  UINT,  WPARAM,  LPARAM);




#line 371 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\imm.h"

UINT __stdcall ImmGetVirtualKey( HWND);

typedef int (__stdcall *REGISTERWORDENUMPROCA)( LPCSTR lpszReading, DWORD,  LPCSTR lpszString, LPVOID);
typedef int (__stdcall *REGISTERWORDENUMPROCW)( LPCWSTR lpszReading, DWORD,  LPCWSTR lpszString, LPVOID);




#line 381 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\imm.h"

BOOL __stdcall ImmRegisterWordA( HKL,  LPCSTR lpszReading,  DWORD,  LPCSTR lpszRegister);
BOOL __stdcall ImmRegisterWordW( HKL,  LPCWSTR lpszReading,  DWORD,  LPCWSTR lpszRegister);




#line 389 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\imm.h"

BOOL __stdcall ImmUnregisterWordA( HKL,  LPCSTR lpszReading,  DWORD,  LPCSTR lpszUnregister);
BOOL __stdcall ImmUnregisterWordW( HKL,  LPCWSTR lpszReading,  DWORD,  LPCWSTR lpszUnregister);




#line 397 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\imm.h"

UINT __stdcall ImmGetRegisterWordStyleA( HKL,  UINT nItem,  LPSTYLEBUFA lpStyleBuf);
UINT __stdcall ImmGetRegisterWordStyleW( HKL,  UINT nItem,  LPSTYLEBUFW lpStyleBuf);




#line 405 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\imm.h"

UINT __stdcall ImmEnumRegisterWordA( HKL,  REGISTERWORDENUMPROCA,  LPCSTR lpszReading,  DWORD,  LPCSTR lpszRegister,  LPVOID);
UINT __stdcall ImmEnumRegisterWordW( HKL,  REGISTERWORDENUMPROCW,  LPCWSTR lpszReading,  DWORD,  LPCWSTR lpszRegister,  LPVOID);




#line 413 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\imm.h"


BOOL __stdcall ImmDisableIME( DWORD);
BOOL __stdcall ImmEnumInputContext(DWORD idThread, IMCENUMPROC lpfn, LPARAM lParam);
DWORD __stdcall ImmGetImeMenuItemsA( HIMC,  DWORD,  DWORD,  LPIMEMENUITEMINFOA lpImeParentMenu,  LPIMEMENUITEMINFOA lpImeMenu,  DWORD dwSize);
DWORD __stdcall ImmGetImeMenuItemsW( HIMC,  DWORD,  DWORD,  LPIMEMENUITEMINFOW lpImeParentMenu,  LPIMEMENUITEMINFOW lpImeMenu,  DWORD dwSize);




#line 424 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\imm.h"

BOOL __stdcall ImmDisableTextFrameService(DWORD idThread);
#line 427 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\imm.h"



#line 431 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\imm.h"

#line 433 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\imm.h"
#pragma endregion

// wParam for WM_IME_CONTROL












// dwAction for ImmNotifyIME










// lParam for WM_IME_SETCONTEXT







// dwIndex for ImmNotifyIME/NI_COMPOSITIONSTR





// the modifiers of hot key











// Windows for Simplified Chinese Edition hot key ID from 0x10 - 0x2F




// Windows for Japanese Edition hot key ID from 0x30 - 0x4F


// Windows for Korean Edition hot key ID from 0x50 - 0x6F




// Windows for Traditional Chinese Edition hot key ID from 0x70 - 0x8F




// direct switch hot key ID from 0x100 - 0x11F



// IME private hot key from 0x200 - 0x21F








// parameter of ImmGetCompositionString













// style bit flags for WM_IME_COMPOSITION



// IME version constants




// IME property bits







// IME UICapability bits




// ImmSetCompositionString Capability bits





// IME WM_IME_SELECT inheritance Capability bits




// ID for deIndex of ImmGetGuideLine






// ID for dwLevel of GUIDELINE Structure







// ID for dwIndex of GUIDELINE Structure


















// ID for dwIndex of ImmGetProperty








// dwIndex for ImmSetCompositionString API






// attribute for COMPOSITIONSTRING Structure







// bit field for IMC_SETCOMPOSITIONWINDOW, IMC_SETCANDIDATEWINDOW







// conversion direction for ImmGetConversionList





#line 1 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\ime_cmodes.h"
//
//    Copyright (C) Microsoft.  All rights reserved.
//
#pragma once




// bit field for conversion mode













#line 24 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\ime_cmodes.h"

#line 636 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\imm.h"

// bit field for conversion mode
// IME_CMODE_HANGEUL is old name of IME_CMODE_HANGUL. It will be gone eventually.








// bit field for sentence mode









// style of candidate







// wParam of report message WM_IME_NOTIFY
















// wParam of report message WM_IME_REQUEST







#line 691 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\imm.h"

// error code of ImmGetCompositionString




// dialog mode of ImmConfigureIME





// flags for ImmEscape

















// style of word registration







// dwFlags for ImmAssociateContextEx




// dwFlags for ImmGetImeMenuItems


// dwType for ImmGetImeMenuItems








// fType of IMEMENUITEMINFO structure




// fState of IMEMENUITEMINFO structure









#line 762 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\imm.h"

// type of soft keyboard
// for Windows Tranditional Chinese Edition

// for Windows Simplified Chinese Edition



#line 771 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\imm.h"


#pragma warning(pop)
#line 775 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\imm.h"


}
#line 779 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\imm.h"

#line 781 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\imm.h"

#line 247 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\Windows.h"
#line 248 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\Windows.h"
#line 249 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\Windows.h"
#line 250 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\Windows.h"




#pragma warning(pop)





#line 261 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\Windows.h"
#line 262 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\Windows.h"
#line 263 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\Windows.h"

#line 265 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\Windows.h"

#line 267 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\Windows.h"
#pragma endregion

#line 270 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\Windows.h"

#line 272 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\Windows.h"

#line 12 "C:\\Users\\serpentiem\\source\\repos\\ddmk\\Core\\Includes.h"
#line 1 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\TlHelp32.h"
/****************************************************************************
**                                                                             *
* tlhelp32.h -  WIN32 tool help functions, types, and definitions             *
*                                                                             *
* Version 1.0                                                                 *
*                                                                             *
* NOTE: windows.h/winbase.h must be #included first                           *
*                                                                             *
* Copyright (c) Microsoft Corp.  All rights reserved.                         *
*                                                                             *
\*****************************************************************************/





#pragma once
#line 19 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\TlHelp32.h"


#pragma region Desktop Family




extern "C" {            /* Assume C declarations for C++ */
#line 28 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\TlHelp32.h"



/****** Shapshot function **********************************************/

HANDLE
__stdcall
CreateToolhelp32Snapshot(
    DWORD dwFlags,
    DWORD th32ProcessID
    );

//
// The th32ProcessID argument is only used if TH32CS_SNAPHEAPLIST or
// TH32CS_SNAPMODULE is specified. th32ProcessID == 0 means the current
// process.
//
// NOTE that all of the snapshots are global except for the heap and module
//      lists which are process specific. To enumerate the heap or module
//      state for all WIN32 processes call with TH32CS_SNAPALL and the
//      current process. Then for each process in the TH32CS_SNAPPROCESS
//      list that isn't the current process, do a call with just
//      TH32CS_SNAPHEAPLIST and/or TH32CS_SNAPMODULE.
//
// dwFlags
//







//
// Use CloseHandle to destroy the snapshot
//

/****** heap walking ***************************************************/

typedef struct tagHEAPLIST32
{
    SIZE_T dwSize;
    DWORD  th32ProcessID;   // owning process
    ULONG_PTR  th32HeapID;      // heap (in owning process's context!)
    DWORD  dwFlags;
} HEAPLIST32;
typedef HEAPLIST32 *  PHEAPLIST32;
typedef HEAPLIST32 *  LPHEAPLIST32;
//
// dwFlags
//



BOOL
__stdcall
Heap32ListFirst(
    HANDLE hSnapshot,
    LPHEAPLIST32 lphl
    );

BOOL
__stdcall
Heap32ListNext(
    HANDLE hSnapshot,
    LPHEAPLIST32 lphl
    );

typedef struct tagHEAPENTRY32
{
    SIZE_T dwSize;
    HANDLE hHandle;     // Handle of this heap block
    ULONG_PTR dwAddress;   // Linear address of start of block
    SIZE_T dwBlockSize; // Size of block in bytes
    DWORD  dwFlags;
    DWORD  dwLockCount;
    DWORD  dwResvd;
    DWORD  th32ProcessID;   // owning process
    ULONG_PTR  th32HeapID;      // heap block is in
} HEAPENTRY32;
typedef HEAPENTRY32 *  PHEAPENTRY32;
typedef HEAPENTRY32 *  LPHEAPENTRY32;
//
// dwFlags
//




BOOL
__stdcall
Heap32First(
    LPHEAPENTRY32 lphe,
    DWORD th32ProcessID,
    ULONG_PTR th32HeapID
    );

BOOL
__stdcall
Heap32Next(
    LPHEAPENTRY32 lphe
    );

BOOL
__stdcall
Toolhelp32ReadProcessMemory(
    DWORD th32ProcessID,
    LPCVOID lpBaseAddress,
    LPVOID lpBuffer,
    SIZE_T cbRead,
    SIZE_T* lpNumberOfBytesRead
    );


/***** Process walking *************************************************/

typedef struct tagPROCESSENTRY32W
{
    DWORD   dwSize;
    DWORD   cntUsage;
    DWORD   th32ProcessID;          // this process
    ULONG_PTR th32DefaultHeapID;
    DWORD   th32ModuleID;           // associated exe
    DWORD   cntThreads;
    DWORD   th32ParentProcessID;    // this process's parent process
    LONG    pcPriClassBase;         // Base priority of process's threads
    DWORD   dwFlags;
    WCHAR   szExeFile[260 ];    // Path
} PROCESSENTRY32W;
typedef PROCESSENTRY32W *  PPROCESSENTRY32W;
typedef PROCESSENTRY32W *  LPPROCESSENTRY32W;

BOOL
__stdcall
Process32FirstW(
    HANDLE hSnapshot,
    LPPROCESSENTRY32W lppe
    );

BOOL
__stdcall
Process32NextW(
    HANDLE hSnapshot,
    LPPROCESSENTRY32W lppe
    );

typedef struct tagPROCESSENTRY32
{
    DWORD   dwSize;
    DWORD   cntUsage;
    DWORD   th32ProcessID;          // this process
    ULONG_PTR th32DefaultHeapID;
    DWORD   th32ModuleID;           // associated exe
    DWORD   cntThreads;
    DWORD   th32ParentProcessID;    // this process's parent process
    LONG    pcPriClassBase;         // Base priority of process's threads
    DWORD   dwFlags;
    CHAR    szExeFile[260 ];    // Path
} PROCESSENTRY32;
typedef PROCESSENTRY32 *  PPROCESSENTRY32;
typedef PROCESSENTRY32 *  LPPROCESSENTRY32;

BOOL
__stdcall
Process32First(
    HANDLE hSnapshot,
    LPPROCESSENTRY32 lppe
    );

BOOL
__stdcall
Process32Next(
    HANDLE hSnapshot,
    LPPROCESSENTRY32 lppe
    );









/***** Thread walking **************************************************/

typedef struct tagTHREADENTRY32
{
    DWORD   dwSize;
    DWORD   cntUsage;
    DWORD   th32ThreadID;       // this thread
    DWORD   th32OwnerProcessID; // Process this thread is associated with
    LONG    tpBasePri;
    LONG    tpDeltaPri;
    DWORD   dwFlags;
} THREADENTRY32;
typedef THREADENTRY32 *  PTHREADENTRY32;
typedef THREADENTRY32 *  LPTHREADENTRY32;

BOOL
__stdcall
Thread32First(
    HANDLE hSnapshot,
    LPTHREADENTRY32 lpte
    );

BOOL
__stdcall
Thread32Next(
    HANDLE hSnapshot,
    LPTHREADENTRY32 lpte
    );

/***** Module walking *************************************************/

typedef struct tagMODULEENTRY32W
{
    DWORD   dwSize;
    DWORD   th32ModuleID;       // This module
    DWORD   th32ProcessID;      // owning process
    DWORD   GlblcntUsage;       // Global usage count on the module
    DWORD   ProccntUsage;       // Module usage count in th32ProcessID's context
    BYTE  * modBaseAddr;        // Base address of module in th32ProcessID's context
    DWORD   modBaseSize;        // Size in bytes of module starting at modBaseAddr
    HMODULE hModule;            // The hModule of this module in th32ProcessID's context
    WCHAR   szModule[255 + 1];
    WCHAR   szExePath[260 ];
} MODULEENTRY32W;
typedef MODULEENTRY32W *  PMODULEENTRY32W;
typedef MODULEENTRY32W *  LPMODULEENTRY32W;

BOOL
__stdcall
Module32FirstW(
    HANDLE hSnapshot,
    LPMODULEENTRY32W lpme
    );

BOOL
__stdcall
Module32NextW(
    HANDLE hSnapshot,
    LPMODULEENTRY32W lpme
    );


typedef struct tagMODULEENTRY32
{
    DWORD   dwSize;
    DWORD   th32ModuleID;       // This module
    DWORD   th32ProcessID;      // owning process
    DWORD   GlblcntUsage;       // Global usage count on the module
    DWORD   ProccntUsage;       // Module usage count in th32ProcessID's context
    BYTE  * modBaseAddr;        // Base address of module in th32ProcessID's context
    DWORD   modBaseSize;        // Size in bytes of module starting at modBaseAddr
    HMODULE hModule;            // The hModule of this module in th32ProcessID's context
    char    szModule[255 + 1];
    char    szExePath[260 ];
} MODULEENTRY32;
typedef MODULEENTRY32 *  PMODULEENTRY32;
typedef MODULEENTRY32 *  LPMODULEENTRY32;

//
// NOTE CAREFULLY that the modBaseAddr and hModule fields are valid ONLY
// in th32ProcessID's process context.
//

BOOL
__stdcall
Module32First(
    HANDLE hSnapshot,
    LPMODULEENTRY32 lpme
    );

BOOL
__stdcall
Module32Next(
    HANDLE hSnapshot,
    LPMODULEENTRY32 lpme
    );











}
#line 321 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\TlHelp32.h"


#line 324 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\TlHelp32.h"
#pragma endregion

#line 327 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\um\\TlHelp32.h"
#line 13 "C:\\Users\\serpentiem\\source\\repos\\ddmk\\Core\\Includes.h"



#line 1 "C:\\Users\\serpentiem\\source\\repos\\ddmk\\Core\\Datatypes.h"
#pragma once

typedef unsigned char      bool8;
typedef unsigned short     bool16;
typedef unsigned long      bool32;
typedef unsigned long long bool64;

typedef char      int8;
typedef short     int16;
typedef long      int32;
typedef long long int64;

typedef unsigned char      uint8;
typedef unsigned short     uint16;
typedef unsigned long      uint32;
typedef unsigned long long uint64;

typedef unsigned char      byte8;
typedef unsigned short     byte16;
typedef unsigned long      byte32;
typedef unsigned long long byte64;

typedef float float32;

struct vec4
{
	float32 x;
	float32 y;
	float32 z;
	float32 a;
};
#line 17 "C:\\Users\\serpentiem\\source\\repos\\ddmk\\Core\\Includes.h"
#line 1 "C:\\Users\\serpentiem\\source\\repos\\ddmk\\Core\\Macros.h"


#line 4 "C:\\Users\\serpentiem\\source\\repos\\ddmk\\Core\\Macros.h"
// #ifndef __INTELLISENSE__

// #else
// #define offsetof(s, m) reinterpret_cast<uint32>(&(*reinterpret_cast<s *>(0)).m)
// #endif




































































































































































































































































































































































































































































































































































































#line 18 "C:\\Users\\serpentiem\\source\\repos\\ddmk\\Core\\Includes.h"
#line 2 "C:\\Users\\serpentiem\\source\\repos\\ddmk\\Core\\Core.h"

import Core_File;
import Core_Log;
import Core_Memory;
import Core_Utility;
import Core_Vector;
import Core_Windows;
#line 11 "C:\\Users\\serpentiem\\source\\repos\\ddmk\\Mary\\Actor.ixx"

#line 1 "C:\\Users\\serpentiem\\source\\repos\\ddmk\\Mary\\Vars.h"
#pragma once


enum PLAYER
{
	MAX_PLAYER = 4,
};

enum ENTITY
{
	ENTITY_MAIN,
	ENTITY_CLONE,
	MAX_ENTITY,
};


enum CLONE_STATUS
{
	CLONE_STATUS_IDLE,
	CLONE_STATUS_ACTIVE,
	CLONE_STATUS_DECOMMISSION,
};

enum WALL_HIKE_DIRECTION
{
	WALL_HIKE_DIRECTION_RIGHT,
	WALL_HIKE_DIRECTION_LEFT,
	WALL_HIKE_DIRECTION_FORWARD,
};



enum CopyStateFlags
{
	CopyStateFlags_EventData = 1 << 0,
	CopyStateFlags_Mode      = 1 << 1,
};



enum
{
	DEVIL_FLUX_START = 1,
	DEVIL_FLUX_END   = 2,
};













enum ACTOR_DATA_SIZE
{
	ACTOR_DATA_SIZE_DANTE  = 47296,
	ACTOR_DATA_SIZE_BOB    = 46720,
	ACTOR_DATA_SIZE_LADY   = 33408,
	ACTOR_DATA_SIZE_VERGIL = 47296,
};






enum DOT_SHADOW
{
	DOT_SHADOW_ENABLE,
	DOT_SHADOW_DISABLE,
	DOT_SHADOW_DISABLE_ACTOR_ONLY,
};




enum
{
	PLAYER_COUNT = 4,
	ENTITY_COUNT = 2,
	CHARACTER_COUNT = 3,
	STYLE_COUNT = 4,
	WEAPON_COUNT = 10,
};







enum FILE_STATUS
{
	FILE_STATUS_READY = 3,
};

enum FILE_MODE
{
	FILE_MODE_MEMORY,
	FILE_MODE_ARCHIVE,
	FILE_MODE_LOCAL,
};





enum
{
	CHANNEL_SYSTEM,
	CHANNEL_COMMON,
	CHANNEL_STYLE_WEAPON,
	CHANNEL_WEAPON1,
	CHANNEL_WEAPON2,
	CHANNEL_WEAPON3,
	CHANNEL_WEAPON4,
	CHANNEL_ENEMY,
	CHANNEL_ROOM,
	CHANNEL_MUSIC,
	CHANNEL_DEMO,
	MAX_CHANNEL,
};












enum WEAPON_STATUS
{
	WEAPON_STATUS_READY,
	WEAPON_STATUS_ACTIVE,
	WEAPON_STATUS_RETURN,
	WEAPON_STATUS_END,
	WEAPON_STATUS_DISABLED,
};

enum MODE_
{
	MODE_EASY,
	MODE_NORMAL,
	MODE_HARD,
	MODE_VERY_HARD,
	MODE_DANTE_MUST_DIE,
	MAX_MODE,
};

enum CHAR_
{
	CHAR_DANTE,
	CHAR_BOB,
	CHAR_LADY,
	CHAR_VERGIL,
	CHAR_VOID = 255,
	MAX_CHAR = 4,
};

enum COSTUME_
{
	COSTUME_DANTE_DEFAULT,
	COSTUME_DANTE_DEFAULT_NO_COAT,
	COSTUME_DANTE_DEFAULT_TORN,
	COSTUME_DANTE_DMC1,
	COSTUME_DANTE_DMC1_NO_COAT,
	COSTUME_DANTE_SPARDA,
	COSTUME_DANTE_DEFAULT_TORN_INFINITE_MAGIC_POINTS,
	COSTUME_DANTE_SPARDA_INFINITE_MAGIC_POINTS,
	COSTUME_BOB_DEFAULT = 0,
	COSTUME_LADY_DEFAULT = 0,
	COSTUME_LADY_LEATHER_JUMPSUIT,
	COSTUME_VERGIL_DEFAULT = 0,
	COSTUME_VERGIL_DEFAULT_NO_COAT,
	COSTUME_VERGIL_DEFAULT_INFINITE_MAGIC_POINTS,
	COSTUME_VERGIL_NERO_ANGELO,
	COSTUME_VERGIL_NERO_ANGELO_INFINITE_MAGIC_POINTS,
	MAX_COSTUME = 8,
	MAX_COSTUME_DANTE = 8,
	MAX_COSTUME_BOB = 1,
	MAX_COSTUME_LADY = 2,
	MAX_COSTUME_VERGIL = 5,
};

enum DEVIL
{
	DEVIL_REBELLION,
	DEVIL_CERBERUS,
	DEVIL_AGNI_RUDRA,
	DEVIL_NEVAN,
	DEVIL_BEOWULF,
	DEVIL_SPARDA,
	DEVIL_NERO_ANGELO,
	DEVIL_YAMATO = 0,
	MAX_DEVIL = 7,
};

enum STYLE
{
	STYLE_SWORDMASTER,
	STYLE_GUNSLINGER,
	STYLE_TRICKSTER,
	STYLE_ROYALGUARD,
	STYLE_QUICKSILVER,
	STYLE_DOPPELGANGER,
	STYLE_DARK_SLAYER = 2,
	MAX_STYLE = 6,
};

enum WEAPON
{
	WEAPON_REBELLION,
	WEAPON_CERBERUS,
	WEAPON_AGNI_RUDRA,
	WEAPON_NEVAN,
	WEAPON_BEOWULF_DANTE,
	WEAPON_EBONY_IVORY,
	WEAPON_SHOTGUN,
	WEAPON_ARTEMIS,
	WEAPON_SPIRAL,
	WEAPON_KALINA_ANN,
	WEAPON_YAMATO_VERGIL = 11,
	WEAPON_BEOWULF_VERGIL,
	WEAPON_YAMATO_FORCE_EDGE,
	WEAPON_YAMATO_BOB,
	MAX_WEAPON,
	WEAPON_VOID = 255,
};

enum
{
	WEAPON_COUNT_DANTE = 10,
	WEAPON_COUNT_BOB = 1,
	WEAPON_COUNT_VERGIL = 3,
	MELEE_WEAPON_COUNT = 5,
	MELEE_WEAPON_COUNT_DANTE = 5,
	MELEE_WEAPON_COUNT_BOB = 1,
	MELEE_WEAPON_COUNT_VERGIL = 3,
	RANGED_WEAPON_COUNT = 5,
	RANGED_WEAPON_COUNT_DANTE = 5,
};





















// @Todo: Update.
enum MOTION_GROUP_
{
	MOTION_GROUP_DANTE_BASE,
	MOTION_GROUP_DANTE_DAMAGE,
	MOTION_GROUP_DANTE_TAUNTS,
	MOTION_GROUP_DANTE_REBELLION,
	MOTION_GROUP_DANTE_CERBERUS,
	MOTION_GROUP_DANTE_AGNI_RUDRA,
	MOTION_GROUP_DANTE_NEVAN,
	MOTION_GROUP_DANTE_BEOWULF,
	MOTION_GROUP_DANTE_EBONY_IVORY,
	MOTION_GROUP_DANTE_SHOTGUN,
	MOTION_GROUP_DANTE_ARTEMIS,
	MOTION_GROUP_DANTE_SPIRAL,
	MOTION_GROUP_DANTE_KALINA_ANN,
	MOTION_GROUP_DANTE_SWORDMASTER_REBELLION,
	MOTION_GROUP_DANTE_SWORDMASTER_CERBERUS,
	MOTION_GROUP_DANTE_SWORDMASTER_AGNI_RUDRA,
	MOTION_GROUP_DANTE_SWORDMASTER_NEVAN,
	MOTION_GROUP_DANTE_SWORDMASTER_BEOWULF,
	MOTION_GROUP_DANTE_GUNSLINGER_EBONY_IVORY,
	MOTION_GROUP_DANTE_GUNSLINGER_SHOTGUN,
	MOTION_GROUP_DANTE_GUNSLINGER_ARTEMIS,
	MOTION_GROUP_DANTE_GUNSLINGER_SPIRAL,
	MOTION_GROUP_DANTE_GUNSLINGER_KALINA_ANN,
	MOTION_GROUP_DANTE_TRICKSTER,
	MOTION_GROUP_DANTE_ROYALGUARD,
	MOTION_GROUP_DANTE_QUICKSILVER,
	MOTION_GROUP_DANTE_DOPPELGANGER,
	MOTION_GROUP_BOB_BASE = 0,
	MOTION_GROUP_BOB_DAMAGE,
	MOTION_GROUP_BOB_TAUNTS,
	MOTION_GROUP_BOB_YAMATO = 31,
	MOTION_GROUP_LADY_BASE = 0,
	MOTION_GROUP_LADY_DAMAGE,
	MOTION_GROUP_LADY_TAUNTS,
	MOTION_GROUP_VERGIL_BASE = 0,
	MOTION_GROUP_VERGIL_DAMAGE,
	MOTION_GROUP_VERGIL_TAUNTS,
	MOTION_GROUP_VERGIL_YAMATO,
	MOTION_GROUP_VERGIL_BEOWULF,
	MOTION_GROUP_VERGIL_FORCE_EDGE,
	MOTION_GROUP_VERGIL_DARK_SLAYER,
	MOTION_GROUP_VERGIL_NERO_ANGELO_YAMATO,
	MOTION_GROUP_VERGIL_NERO_ANGELO_BEOWULF,
	MOTION_GROUP_VERGIL_NERO_ANGELO_FORCE_EDGE,
	MOTION_GROUP_IN_GAME_CUTSCENE = 33,
	MAX_MOTION_GROUP = 34,
};

enum NEXT_ACTION_REQUEST_POLICY
{
	NEXT_ACTION_REQUEST_POLICY_IGNORE,
	NEXT_ACTION_REQUEST_POLICY_BUFFER,
	NEXT_ACTION_REQUEST_POLICY_EXECUTE,
	// Indices
	NEXT_ACTION_REQUEST_POLICY_MELEE_ATTACK = 0,
	NEXT_ACTION_REQUEST_POLICY_SWORDMASTER_GUNSLINGER = 4,
	NEXT_ACTION_REQUEST_POLICY_JUMP_ROLL = 5,
	NEXT_ACTION_REQUEST_POLICY_ROYALGUARD = 6,
	NEXT_ACTION_REQUEST_POLICY_TRICKSTER_DARK_SLAYER = 8,
	NEXT_ACTION_REQUEST_POLICY_RANGED_ATTACK = 10,
	NEXT_ACTION_REQUEST_POLICY_END = 15,
};

enum ACTION
{
	ACTION_DANTE_REBELLION_COMBO_1_PART_1 = 1,
	ACTION_DANTE_REBELLION_COMBO_1_PART_2,
	ACTION_DANTE_REBELLION_COMBO_1_PART_3,
	ACTION_DANTE_REBELLION_COMBO_2_PART_2,
	ACTION_DANTE_REBELLION_COMBO_2_PART_3,
	ACTION_DANTE_REBELLION_HELM_BREAKER,
	ACTION_DANTE_REBELLION_STINGER_LEVEL_1,
	ACTION_DANTE_REBELLION_STINGER_LEVEL_2,
	ACTION_DANTE_REBELLION_LEAP,
	ACTION_DANTE_REBELLION_HIGH_TIME,
	ACTION_DANTE_REBELLION_HIGH_TIME_LAUNCH,
	ACTION_DANTE_REBELLION_KICK_1,
	ACTION_DANTE_REBELLION_DRIVE_1,
	ACTION_DANTE_REBELLION_MILLION_STAB,
	ACTION_DANTE_REBELLION_SWORD_PIERCE,
	ACTION_DANTE_REBELLION_PROP_SHREDDER_1,
	ACTION_DANTE_REBELLION_DIVEKICK,
	ACTION_DANTE_REBELLION_KICK_2,
	ACTION_DANTE_REBELLION_AERIAL_RAVE_PART_1,
	ACTION_DANTE_REBELLION_AERIAL_RAVE_PART_2,
	ACTION_DANTE_REBELLION_AERIAL_RAVE_PART_3,
	ACTION_DANTE_REBELLION_AERIAL_RAVE_PART_4,
	ACTION_DANTE_REBELLION_SWORD_PIERCE_RETURN,
	ACTION_DANTE_REBELLION_PROP_SHREDDER_2,
	ACTION_DANTE_REBELLION_DRIVE_2,
	ACTION_DANTE_CERBERUS_COMBO_1_PART_1 = 30,
	ACTION_DANTE_CERBERUS_COMBO_1_PART_2,
	ACTION_DANTE_CERBERUS_COMBO_1_PART_3,
	ACTION_DANTE_CERBERUS_COMBO_1_PART_4,
	ACTION_DANTE_CERBERUS_COMBO_1_PART_5,
	ACTION_DANTE_CERBERUS_COMBO_2_PART_3,
	ACTION_DANTE_CERBERUS_COMBO_2_PART_4,
	ACTION_DANTE_CERBERUS_WINDMILL,
	ACTION_DANTE_CERBERUS_REVOLVER_LEVEL_1,
	ACTION_DANTE_CERBERUS_REVOLVER_LEVEL_2,
	ACTION_DANTE_CERBERUS_SWING,
	ACTION_DANTE_CERBERUS_SATELLITE,
	ACTION_DANTE_CERBERUS_FLICKER,
	ACTION_DANTE_CERBERUS_AIR_FLICKER,
	ACTION_DANTE_CERBERUS_CRYSTAL,
	ACTION_DANTE_CERBERUS_MILLION_CARATS,
	ACTION_DANTE_CERBERUS_ICE_AGE,
	ACTION_DANTE_AGNI_RUDRA_COMBO_1_PART_1 = 50,
	ACTION_DANTE_AGNI_RUDRA_COMBO_1_PART_2,
	ACTION_DANTE_AGNI_RUDRA_COMBO_1_PART_3,
	ACTION_DANTE_AGNI_RUDRA_COMBO_1_PART_4,
	ACTION_DANTE_AGNI_RUDRA_COMBO_1_PART_5,
	ACTION_DANTE_AGNI_RUDRA_COMBO_2_PART_2,
	ACTION_DANTE_AGNI_RUDRA_COMBO_2_PART_3,
	ACTION_DANTE_AGNI_RUDRA_COMBO_3_PART_3,
	ACTION_DANTE_AGNI_RUDRA_JET_STREAM_LEVEL_1,
	ACTION_DANTE_AGNI_RUDRA_JET_STREAM_LEVEL_2,
	ACTION_DANTE_AGNI_RUDRA_JET_STREAM_LEVEL_3,
	ACTION_DANTE_AGNI_RUDRA_AERIAL_CROSS,
	ACTION_DANTE_AGNI_RUDRA_WHIRLWIND,
	ACTION_DANTE_AGNI_RUDRA_WHIRLWIND_LAUNCH,
	ACTION_DANTE_AGNI_RUDRA_MILLION_SLASH,
	ACTION_DANTE_AGNI_RUDRA_CROSSED_SWORDS,
	ACTION_DANTE_AGNI_RUDRA_CRAWLER,
	ACTION_DANTE_AGNI_RUDRA_TWISTER,
	ACTION_DANTE_AGNI_RUDRA_SKY_DANCE_PART_1,
	ACTION_DANTE_AGNI_RUDRA_SKY_DANCE_PART_2,
	ACTION_DANTE_AGNI_RUDRA_SKY_DANCE_PART_3,
	ACTION_DANTE_AGNI_RUDRA_TEMPEST,
	ACTION_DANTE_NEVAN_TUNE_UP = 80,
	ACTION_DANTE_NEVAN_COMBO_1,
	ACTION_DANTE_NEVAN_COMBO_2,
	ACTION_DANTE_NEVAN_JAM_SESSION,
	ACTION_DANTE_NEVAN_BAT_RIFT_LEVEL_1,
	ACTION_DANTE_NEVAN_BAT_RIFT_LEVEL_2,
	ACTION_DANTE_NEVAN_REVERB_SHOCK_LEVEL_1,
	ACTION_DANTE_NEVAN_REVERB_SHOCK_LEVEL_2,
	ACTION_DANTE_NEVAN_AIR_PLAY,
	ACTION_DANTE_NEVAN_SLASH,
	ACTION_DANTE_NEVAN_AIR_SLASH_PART_1,
	ACTION_DANTE_NEVAN_AIR_SLASH_PART_2,
	ACTION_DANTE_NEVAN_FEEDBACK,
	ACTION_DANTE_NEVAN_CRAZY_ROLL,
	ACTION_DANTE_NEVAN_DISTORTION,
	ACTION_DANTE_NEVAN_VORTEX,
	ACTION_DANTE_NEVAN_THUNDER_BOLT,
	ACTION_DANTE_BEOWULF_COMBO_1_PART_1 = 110,
	ACTION_DANTE_BEOWULF_COMBO_1_PART_2,
	ACTION_DANTE_BEOWULF_COMBO_1_PART_3,
	ACTION_DANTE_BEOWULF_COMBO_2_PART_3,
	ACTION_DANTE_BEOWULF_COMBO_2_PART_4,
	ACTION_DANTE_BEOWULF_HYPER_FIST,
	ACTION_DANTE_BEOWULF_KILLER_BEE,
	ACTION_DANTE_BEOWULF_BEAST_UPPERCUT,
	ACTION_DANTE_BEOWULF_RISING_DRAGON,
	ACTION_DANTE_BEOWULF_RISING_DRAGON_LAUNCH,
	ACTION_DANTE_BEOWULF_RISING_DRAGON_WHIRLWIND,
	ACTION_DANTE_BEOWULF_STRAIGHT_LEVEL_1,
	ACTION_DANTE_BEOWULF_STRAIGHT_LEVEL_2,
	ACTION_DANTE_BEOWULF_ZODIAC,
	ACTION_DANTE_BEOWULF_VOLCANO,
	ACTION_DANTE_BEOWULF_AIR_VOLCANO,
	ACTION_DANTE_BEOWULF_TORNADO,
	ACTION_DANTE_BEOWULF_THE_HAMMER,
	ACTION_DANTE_BEOWULF_REAL_IMPACT,
	ACTION_DANTE_EBONY_IVORY_NORMAL_SHOT = 130,
	ACTION_DANTE_EBONY_IVORY_CHARGED_SHOT,
	ACTION_DANTE_EBONY_IVORY_AIR_NORMAL_SHOT,
	ACTION_DANTE_EBONY_IVORY_AIR_CHARGED_SHOT,
	ACTION_DANTE_EBONY_IVORY_TWOSOME_TIME,
	ACTION_DANTE_EBONY_IVORY_RAIN_STORM,
	ACTION_DANTE_EBONY_IVORY_WILD_STOMP,
	ACTION_DANTE_SHOTGUN_NORMAL_SHOT = 140,
	ACTION_DANTE_SHOTGUN_CHARGED_SHOT,
	ACTION_DANTE_SHOTGUN_AIR_NORMAL_SHOT,
	ACTION_DANTE_SHOTGUN_AIR_CHARGED_SHOT,
	ACTION_DANTE_SHOTGUN_FIREWORKS,
	ACTION_DANTE_SHOTGUN_AIR_FIREWORKS,
	ACTION_DANTE_SHOTGUN_GUN_STINGER,
	ACTION_DANTE_SHOTGUN_POINT_BLANK,
	ACTION_DANTE_ARTEMIS_NORMAL_SHOT = 150,
	ACTION_DANTE_ARTEMIS_AIR_NORMAL_SHOT,
	ACTION_DANTE_ARTEMIS_MULTI_LOCK_SHOT,
	ACTION_DANTE_ARTEMIS_AIR_MULTI_LOCK_SHOT,
	ACTION_DANTE_ARTEMIS_SPHERE,
	ACTION_DANTE_ARTEMIS_ACID_RAIN,
	ACTION_DANTE_SPIRAL_NORMAL_SHOT = 160,
	ACTION_DANTE_SPIRAL_SNIPER,
	ACTION_DANTE_SPIRAL_TRICK_SHOT,
	ACTION_DANTE_KALINA_ANN_NORMAL_SHOT = 170,
	ACTION_DANTE_KALINA_ANN_HYSTERIC,
	ACTION_DANTE_KALINA_ANN_GRAPPLE,
	ACTION_DANTE_TRICKSTER_DASH = 180,
	ACTION_DANTE_TRICKSTER_SKY_STAR,
	ACTION_DANTE_TRICKSTER_AIR_TRICK,
	ACTION_DANTE_TRICKSTER_WALL_HIKE,
	ACTION_DANTE_ROYALGUARD_RELEASE_1 = 190,
	ACTION_DANTE_ROYALGUARD_RELEASE_2,
	ACTION_DANTE_ROYALGUARD_RELEASE_3,
	ACTION_DANTE_ROYALGUARD_RELEASE_4,
	ACTION_DANTE_ROYALGUARD_AIR_RELEASE_1,
	ACTION_DANTE_ROYALGUARD_AIR_RELEASE_2,
	ACTION_DANTE_ROYALGUARD_AIR_RELEASE_3,
	ACTION_DANTE_ROYALGUARD_AIR_RELEASE_4,
	ACTION_DANTE_REBELLION_DANCE_MACABRE_PART_1 = 200,
	ACTION_DANTE_REBELLION_DANCE_MACABRE_PART_2,
	ACTION_DANTE_REBELLION_DANCE_MACABRE_PART_3,
	ACTION_DANTE_REBELLION_DANCE_MACABRE_PART_4,
	ACTION_DANTE_REBELLION_DANCE_MACABRE_PART_5,
	ACTION_DANTE_REBELLION_DANCE_MACABRE_PART_6,
	ACTION_DANTE_REBELLION_DANCE_MACABRE_PART_7,
	ACTION_DANTE_REBELLION_DANCE_MACABRE_PART_8,
	ACTION_DANTE_REBELLION_CRAZY_DANCE,
	ACTION_DANTE_POLE_PLAY,
	ACTION_VERGIL_YAMATO_COMBO_PART_1 = 1,
	ACTION_VERGIL_YAMATO_COMBO_PART_2,
	ACTION_VERGIL_YAMATO_COMBO_PART_3,
	ACTION_VERGIL_YAMATO_RAPID_SLASH_LEVEL_1,
	ACTION_VERGIL_YAMATO_RAPID_SLASH_LEVEL_2,
	ACTION_VERGIL_YAMATO_LEAP,
	ACTION_VERGIL_YAMATO_UPPER_SLASH_PART_1,
	ACTION_VERGIL_YAMATO_UPPER_SLASH_PART_2,
	ACTION_VERGIL_YAMATO_JUDGEMENT_CUT_LEVEL_1,
	ACTION_VERGIL_YAMATO_JUDGEMENT_CUT_LEVEL_2,
	ACTION_VERGIL_YAMATO_AERIAL_RAVE_PART_1,
	ACTION_VERGIL_YAMATO_AERIAL_RAVE_PART_2,
	ACTION_VERGIL_BEOWULF_COMBO_PART_1 = 20,
	ACTION_VERGIL_BEOWULF_COMBO_PART_2,
	ACTION_VERGIL_BEOWULF_COMBO_PART_3,
	ACTION_VERGIL_BEOWULF_STARFALL_LEVEL_1,
	ACTION_VERGIL_BEOWULF_STARFALL_LEVEL_2,
	ACTION_VERGIL_BEOWULF_RISING_SUN,
	ACTION_VERGIL_BEOWULF_LUNAR_PHASE_LEVEL_1,
	ACTION_VERGIL_BEOWULF_LUNAR_PHASE_LEVEL_2,
	ACTION_VERGIL_FORCE_EDGE_COMBO_PART_1 = 30,
	ACTION_VERGIL_FORCE_EDGE_COMBO_PART_2,
	ACTION_VERGIL_FORCE_EDGE_COMBO_PART_3,
	ACTION_VERGIL_FORCE_EDGE_COMBO_PART_4,
	ACTION_VERGIL_FORCE_EDGE_HELM_BREAKER_LEVEL_1,
	ACTION_VERGIL_FORCE_EDGE_HELM_BREAKER_LEVEL_2,
	ACTION_VERGIL_FORCE_EDGE_HIGH_TIME,
	ACTION_VERGIL_FORCE_EDGE_HIGH_TIME_LAUNCH,
	ACTION_VERGIL_FORCE_EDGE_STINGER_LEVEL_1,
	ACTION_VERGIL_FORCE_EDGE_STINGER_LEVEL_2,
	ACTION_VERGIL_FORCE_EDGE_ROUND_TRIP,
	ACTION_VERGIL_FORCE_EDGE_KICK,
	ACTION_VERGIL_SUMMONED_SWORDS_SHOOT = 52,
	ACTION_VERGIL_SUMMONED_SWORDS_SPIRAL_SWORDS,
	ACTION_VERGIL_SUMMONED_SWORDS_BLISTERING_SWORDS,
	ACTION_VERGIL_SUMMONED_SWORDS_SWORD_STORM,
	ACTION_VERGIL_DARK_SLAYER_AIR_TRICK = 60,
	ACTION_VERGIL_DARK_SLAYER_TRICK_UP,
	ACTION_VERGIL_DARK_SLAYER_TRICK_DOWN,
	ACTION_VERGIL_NERO_ANGELO_COMBO_1_PART_1 = 70,
	ACTION_VERGIL_NERO_ANGELO_COMBO_1_PART_2,
	ACTION_VERGIL_NERO_ANGELO_COMBO_1_PART_3,
	ACTION_VERGIL_NERO_ANGELO_HELM_BREAKER,
	ACTION_VERGIL_NERO_ANGELO_HIGH_TIME,
	ACTION_VERGIL_NERO_ANGELO_HIGH_TIME_LAUNCH,
	ACTION_VERGIL_NERO_ANGELO_STINGER,
	ACTION_VERGIL_NERO_ANGELO_FIREBALL_1,
	ACTION_VERGIL_NERO_ANGELO_COMBO_2_PART_1 = 90,
	ACTION_VERGIL_NERO_ANGELO_COMBO_2_PART_2,
	ACTION_VERGIL_NERO_ANGELO_COMBO_2_PART_3,
	ACTION_VERGIL_NERO_ANGELO_DIVEKICK,
	ACTION_VERGIL_NERO_ANGELO_ROUNDHOUSE_KICK,
	ACTION_VERGIL_NERO_ANGELO_UPPERCUT,
	ACTION_VERGIL_NERO_ANGELO_FIREBALL_2,
};

enum PERMISSION
{
	PERMISSION_UPDATE = 1,
	PERMISSION_WALK_RUN = 2,
	PERMISSION_JUMP_ROLL = 8,
	PERMISSION_TARGET = 0x10,
	PERMISSION_RELEASE = 0x20,
	PERMISSION_INTERACTION_STYLE_ATTACK = 0x400,
	PERMISSION_TRICKSTER_DARK_SLAYER = 0x1000000,
};

enum STATE
{
	STATE_ON_FLOOR = 1,
	STATE_IN_AIR = 2,
	STATE_BUSY = 0x10000,
};





enum BODY_PART
{
	LOWER_BODY,
	UPPER_BODY,
	MAX_BODY_PART,
};




enum HUD_TOP
{
	HUD_TOP_UPPER_HIT_POINTS_FRAME,
	HUD_TOP_UPPER_HIT_POINTS_BAR,
	HUD_TOP_UPPER_HIT_POINTS_BACKGROUND,
	HUD_TOP_LOWER_HIT_POINTS_FRAME,
	HUD_TOP_LOWER_HIT_POINTS_BAR,
	HUD_TOP_LOWER_HIT_POINTS_BACKGROUND,
	HUD_TOP_MAGIC_ORBS,
	HUD_TOP_STYLE_ICON,
	HUD_TOP_RED_ORB_COUNTER,
	HUD_TOP_UNKNOWN_1,
	HUD_TOP_UNKNOWN_2,
	HUD_TOP_FLUX,
	HUD_TOP_UNKNOWN_3,
};

enum HUD_BOTTOM
{
	HUD_BOTTOM_RANGED_WEAPON_1,
	HUD_BOTTOM_RANGED_WEAPON_2,
	HUD_BOTTOM_MELEE_WEAPON_1,
	HUD_BOTTOM_MELEE_WEAPON_2,
};








// $CacheFileStart

enum CACHE_FILE
{
	pl000,
	pl011,
	pl013,
	pl015,
	pl016,
	pl018,
	pl005,
	pl006,
	pl007,
	pl008,
	pl009,
	pl017,
	pl000_00_0,
	pl000_00_1,
	pl000_00_2,
	pl000_00_3,
	pl000_00_4,
	pl000_00_5,
	pl000_00_6,
	pl000_00_7,
	pl000_00_8,
	pl000_00_9,
	pl000_00_10,
	pl000_00_11,
	pl000_00_12,
	pl000_00_13,
	pl000_00_14,
	pl000_00_15,
	pl000_00_16,
	pl000_00_17,
	pl000_00_18,
	pl000_00_19,
	pl000_00_20,
	pl000_00_21,
	pl000_00_22,
	pl000_00_23,
	pl000_00_24,
	pl000_00_25,
	pl000_00_26,
	plwp_sword,
	plwp_sword2,
	plwp_sword3,
	plwp_nunchaku,
	plwp_2sword,
	plwp_guitar,
	plwp_fight,
	plwp_gun,
	plwp_shotgun,
	plwp_laser,
	plwp_rifle,
	plwp_ladygun,
	snd_com0,
	snd_com0a,
	snd_sty02,
	snd_sty03,
	snd_sty04,
	snd_sty05,
	snd_sty06,
	snd_wp00b,
	snd_wp01b,
	snd_wp02b,
	snd_wp03b,
	snd_wp04b,
	snd_wp05b,
	snd_wp06b,
	snd_wp07b,
	snd_wp08b,
	snd_wp09b,
	pl001,
	pl001_00_0,
	pl001_00_1,
	pl001_00_2,
	pl001_00_31,
	plwp_vergilsword,
	pl002,
	pl002_00_0,
	pl002_00_1,
	pl002_00_2,
	pl021,
	pl023,
	pl026,
	pl010,
	pl014,
	pl025,
	pl021_00_0,
	pl021_00_1,
	pl021_00_2,
	pl021_00_3,
	pl021_00_4,
	pl021_00_5,
	pl021_00_6,
	pl021_00_7,
	pl021_00_8,
	pl021_00_9,
	plwp_newvergilsword,
	plwp_newvergilfight,
	plwp_forceedge,
	plwp_nerosword,
	snd_com3,
	snd_com3a,
	snd_sty07,
	snd_sty08,
	snd_wp11a,
	snd_wp11b,
	snd_wp12a,
	snd_wp12b,
	snd_wp13a,
	snd_wp13b,
	em034,
	id100,
	id100V,
	MAX_CACHE_FILE,
};

struct CacheFileHelper
{
	const char * name;
	const char * type;
};

constexpr CacheFileHelper cacheFileHelper[MAX_CACHE_FILE] =
{
	{ "pl000.pac", "obj\\pl000.pac" },
	{ "pl011.pac", "obj\\pl011.pac" },
	{ "pl013.pac", "obj\\pl013.pac" },
	{ "pl015.pac", "obj\\pl015.pac" },
	{ "pl016.pac", "obj\\pl016.pac" },
	{ "pl018.pac", "obj\\pl018.pac" },
	{ "pl005.pac", "obj\\pl005.pac" },
	{ "pl006.pac", "obj\\pl006.pac" },
	{ "pl007.pac", "obj\\pl007.pac" },
	{ "pl008.pac", "obj\\pl008.pac" },
	{ "pl009.pac", "obj\\pl009.pac" },
	{ "pl017.pac", "obj\\pl017.pac" },
	{ "pl000_00_0.pac", "motion\\pl000\\pl000_00_0.pac" },
	{ "pl000_00_1.pac", "motion\\pl000\\pl000_00_1.pac" },
	{ "pl000_00_2.pac", "motion\\pl000\\pl000_00_2.pac" },
	{ "pl000_00_3.pac", "motion\\pl000\\pl000_00_3.pac" },
	{ "pl000_00_4.pac", "motion\\pl000\\pl000_00_4.pac" },
	{ "pl000_00_5.pac", "motion\\pl000\\pl000_00_5.pac" },
	{ "pl000_00_6.pac", "motion\\pl000\\pl000_00_6.pac" },
	{ "pl000_00_7.pac", "motion\\pl000\\pl000_00_7.pac" },
	{ "pl000_00_8.pac", "motion\\pl000\\pl000_00_8.pac" },
	{ "pl000_00_9.pac", "motion\\pl000\\pl000_00_9.pac" },
	{ "pl000_00_10.pac", "motion\\pl000\\pl000_00_10.pac" },
	{ "pl000_00_11.pac", "motion\\pl000\\pl000_00_11.pac" },
	{ "pl000_00_12.pac", "motion\\pl000\\pl000_00_12.pac" },
	{ "pl000_00_13.pac", "motion\\pl000\\pl000_00_13.pac" },
	{ "pl000_00_14.pac", "motion\\pl000\\pl000_00_14.pac" },
	{ "pl000_00_15.pac", "motion\\pl000\\pl000_00_15.pac" },
	{ "pl000_00_16.pac", "motion\\pl000\\pl000_00_16.pac" },
	{ "pl000_00_17.pac", "motion\\pl000\\pl000_00_17.pac" },
	{ "pl000_00_18.pac", "motion\\pl000\\pl000_00_18.pac" },
	{ "pl000_00_19.pac", "motion\\pl000\\pl000_00_19.pac" },
	{ "pl000_00_20.pac", "motion\\pl000\\pl000_00_20.pac" },
	{ "pl000_00_21.pac", "motion\\pl000\\pl000_00_21.pac" },
	{ "pl000_00_22.pac", "motion\\pl000\\pl000_00_22.pac" },
	{ "pl000_00_23.pac", "motion\\pl000\\pl000_00_23.pac" },
	{ "pl000_00_24.pac", "motion\\pl000\\pl000_00_24.pac" },
	{ "pl000_00_25.pac", "motion\\pl000\\pl000_00_25.pac" },
	{ "pl000_00_26.pac", "motion\\pl000\\pl000_00_26.pac" },
	{ "plwp_sword.pac", "obj\\plwp_sword.pac" },
	{ "plwp_sword2.pac", "obj\\plwp_sword2.pac" },
	{ "plwp_sword3.pac", "obj\\plwp_sword3.pac" },
	{ "plwp_nunchaku.pac", "obj\\plwp_nunchaku.pac" },
	{ "plwp_2sword.pac", "obj\\plwp_2sword.pac" },
	{ "plwp_guitar.pac", "obj\\plwp_guitar.pac" },
	{ "plwp_fight.pac", "obj\\plwp_fight.pac" },
	{ "plwp_gun.pac", "obj\\plwp_gun.pac" },
	{ "plwp_shotgun.pac", "obj\\plwp_shotgun.pac" },
	{ "plwp_laser.pac", "obj\\plwp_laser.pac" },
	{ "plwp_rifle.pac", "obj\\plwp_rifle.pac" },
	{ "plwp_ladygun.pac", "obj\\plwp_ladygun.pac" },
	{ "snd_com0.pac", "se\\snd_com0.pac" },
	{ "snd_com0a.pac", "se\\snd_com0a.pac" },
	{ "snd_sty02.pac", "se\\snd_sty02.pac" },
	{ "snd_sty03.pac", "se\\snd_sty03.pac" },
	{ "snd_sty04.pac", "se\\snd_sty04.pac" },
	{ "snd_sty05.pac", "se\\snd_sty05.pac" },
	{ "snd_sty06.pac", "se\\snd_sty06.pac" },
	{ "snd_wp00b.pac", "se\\snd_wp00b.pac" },
	{ "snd_wp01b.pac", "se\\snd_wp01b.pac" },
	{ "snd_wp02b.pac", "se\\snd_wp02b.pac" },
	{ "snd_wp03b.pac", "se\\snd_wp03b.pac" },
	{ "snd_wp04b.pac", "se\\snd_wp04b.pac" },
	{ "snd_wp05b.pac", "se\\snd_wp05b.pac" },
	{ "snd_wp06b.pac", "se\\snd_wp06b.pac" },
	{ "snd_wp07b.pac", "se\\snd_wp07b.pac" },
	{ "snd_wp08b.pac", "se\\snd_wp08b.pac" },
	{ "snd_wp09b.pac", "se\\snd_wp09b.pac" },
	{ "pl001.pac", "obj\\pl001.pac" },
	{ "pl001_00_0.pac", "motion\\pl001\\pl001_00_0.pac" },
	{ "pl001_00_1.pac", "motion\\pl001\\pl001_00_1.pac" },
	{ "pl001_00_2.pac", "motion\\pl001\\pl001_00_2.pac" },
	{ "pl001_00_31.pac", "motion\\pl001\\pl001_00_31.pac" },
	{ "plwp_vergilsword.pac", "obj\\plwp_vergilsword.pac" },
	{ "pl002.pac", "obj\\pl002.pac" },
	{ "pl002_00_0.pac", "motion\\pl002\\pl002_00_0.pac" },
	{ "pl002_00_1.pac", "motion\\pl002\\pl002_00_1.pac" },
	{ "pl002_00_2.pac", "motion\\pl002\\pl002_00_2.pac" },
	{ "pl021.pac", "obj\\pl021.pac" },
	{ "pl023.pac", "obj\\pl023.pac" },
	{ "pl026.pac", "obj\\pl026.pac" },
	{ "pl010.pac", "obj\\pl010.pac" },
	{ "pl014.pac", "obj\\pl014.pac" },
	{ "pl025.pac", "obj\\pl025.pac" },
	{ "pl021_00_0.pac", "motion\\pl021\\pl021_00_0.pac" },
	{ "pl021_00_1.pac", "motion\\pl021\\pl021_00_1.pac" },
	{ "pl021_00_2.pac", "motion\\pl021\\pl021_00_2.pac" },
	{ "pl021_00_3.pac", "motion\\pl021\\pl021_00_3.pac" },
	{ "pl021_00_4.pac", "motion\\pl021\\pl021_00_4.pac" },
	{ "pl021_00_5.pac", "motion\\pl021\\pl021_00_5.pac" },
	{ "pl021_00_6.pac", "motion\\pl021\\pl021_00_6.pac" },
	{ "pl021_00_7.pac", "motion\\pl021\\pl021_00_7.pac" },
	{ "pl021_00_8.pac", "motion\\pl021\\pl021_00_8.pac" },
	{ "pl021_00_9.pac", "motion\\pl021\\pl021_00_9.pac" },
	{ "plwp_newvergilsword.pac", "obj\\plwp_newvergilsword.pac" },
	{ "plwp_newvergilfight.pac", "obj\\plwp_newvergilfight.pac" },
	{ "plwp_forceedge.pac", "obj\\plwp_forceedge.pac" },
	{ "plwp_nerosword.pac", "obj\\plwp_nerosword.pac" },
	{ "snd_com3.pac", "se\\snd_com3.pac" },
	{ "snd_com3a.pac", "se\\snd_com3a.pac" },
	{ "snd_sty07.pac", "se\\snd_sty07.pac" },
	{ "snd_sty08.pac", "se\\snd_sty08.pac" },
	{ "snd_wp11a.pac", "se\\snd_wp11a.pac" },
	{ "snd_wp11b.pac", "se\\snd_wp11b.pac" },
	{ "snd_wp12a.pac", "se\\snd_wp12a.pac" },
	{ "snd_wp12b.pac", "se\\snd_wp12b.pac" },
	{ "snd_wp13a.pac", "se\\snd_wp13a.pac" },
	{ "snd_wp13b.pac", "se\\snd_wp13b.pac" },
	{ "em034.pac", "obj\\em034.pac" },
	{ "id100.pac", "id\\id100\\id100.pac" },
	{ "id100V.pac", "id\\id100\\id100V.pac" },
};

// $CacheFileEnd













enum SCENE
{
	SCENE_BOOT,
	SCENE_INTRO,
	SCENE_MAIN,
	SCENE_MISSION_SELECT,
	SCENE_LOAD,
	SCENE_GAME,
	SCENE_CUTSCENE,
	SCENE_MISSION_START,
	SCENE_MISSION_RESULT,
	SCENE_GAME_OVER,
	MAX_SCENE,
};

enum EVENT
{
	EVENT_INIT,
	EVENT_MAIN,
	EVENT_TELEPORT,
	EVENT_PAUSE,
	EVENT_STATUS,
	EVENT_OPTIONS,
	EVENT_DEATH,
	EVENT_GET_ITEM,
	EVENT_MESSAGE,
	EVENT_CUSTOMIZE,
	EVENT_SAVE,
	EVENT_DELETE,
	EVENT_END,
	MAX_EVENT,
};

enum SUBEVENT
{
	SUBEVENT_MISSION_START  = 7,
	SUBEVENT_MISSION_SELECT = 8,
};





















enum GAMEPAD
{
	GAMEPAD_LEFT_TRIGGER   = 0x0001,
	GAMEPAD_RIGHT_TRIGGER  = 0x0002,
	GAMEPAD_LEFT_SHOULDER  = 0x0004,
	GAMEPAD_RIGHT_SHOULDER = 0x0008,
	GAMEPAD_Y              = 0x0010,
	GAMEPAD_B              = 0x0020,
	GAMEPAD_A              = 0x0040,
	GAMEPAD_X              = 0x0080,
	GAMEPAD_BACK           = 0x0100,
	GAMEPAD_LEFT_THUMB     = 0x0200,
	GAMEPAD_RIGHT_THUMB    = 0x0400,
	GAMEPAD_START          = 0x0800,
	// Direction ids are the same for dpad, left stick and right stick.
	GAMEPAD_UP             = 0x1000,
	GAMEPAD_RIGHT          = 0x2000,
	GAMEPAD_DOWN           = 0x4000,
	GAMEPAD_LEFT           = 0x8000,
};




enum DIRECTION
{
	DIRECTION_UP,
	DIRECTION_RIGHT,
	DIRECTION_DOWN,
	DIRECTION_LEFT,
	MAX_DIRECTION,
};


enum LEFT_STICK
{
	LEFT_STICK_DEADZONE = 52,
};

enum BINDING
{
	BINDING_ITEM_SCREEN,
	BINDING_EQUIP_SCREEN,
	BINDING_MAP_SCREEN,
	BINDING_FILE_SCREEN,
	BINDING_MELEE_ATTACK,
	BINDING_JUMP,
	BINDING_STYLE_ACTION,
	BINDING_SHOOT,
	BINDING_DEVIL_TRIGGER,
	BINDING_CHANGE_GUN,
	BINDING_CHANGE_TARGET,
	BINDING_LOCK_ON,
	BINDING_CHANGE_DEVIL_ARMS,
	BINDING_DEFAULT_CAMERA,
	BINDING_TAUNT,
};

enum DEVIL_SPEED
{
	DEVIL_SPEED_DANTE_REBELLION,
	DEVIL_SPEED_DANTE_CERBERUS,
	DEVIL_SPEED_DANTE_AGNI_RUDRA,
	DEVIL_SPEED_DANTE_NEVAN,
	DEVIL_SPEED_DANTE_BEOWULF,
	DEVIL_SPEED_DANTE_SPARDA,
	DEVIL_SPEED_VERGIL_YAMATO = 0,
	DEVIL_SPEED_VERGIL_BEOWULF,
	DEVIL_SPEED_VERGIL_YAMATO_FORCE_EDGE,
	DEVIL_SPEED_VERGIL_NERO_ANGELO_YAMATO,
	DEVIL_SPEED_VERGIL_NERO_ANGELO_BEOWULF,
};

enum ACTOR_EVENT
{
	ACTOR_EVENT_DANTE_AIR_HIKE = 7,
	ACTOR_EVENT_DANTE_DASH = 22,
	ACTOR_EVENT_DANTE_SKY_STAR,
	ACTOR_EVENT_DANTE_AIR_TRICK,
	ACTOR_EVENT_VERGIL_AIR_TRICK = 27,
	ACTOR_EVENT_VERGIL_TRICK_UP,
	ACTOR_EVENT_VERGIL_TRICK_DOWN,
};

enum ACTOR_MODE
{
	ACTOR_MODE_DEFAULT,
	ACTOR_MODE_MISSION_12,
	ACTOR_MODE_MISSION_18,
	ACTOR_MODE_MISSION_19,
};















constexpr uint16 costumeFileIdsDante[MAX_COSTUME_DANTE] =
{
	pl000,
	pl011,
	pl013,
	pl015,
	pl016,
	pl018,
	pl013,
	pl018,
};

constexpr uint16 costumeFileIdsBob[MAX_COSTUME_BOB] =
{
	pl001,
};

constexpr uint16 costumeFileIdsLady[MAX_COSTUME_LADY] =
{
	pl002,
	em034,
};

constexpr uint16 costumeFileIdsVergil[MAX_COSTUME_VERGIL] =
{
	pl021,
	pl023,
	pl021,
	pl026,
	pl026,
};



constexpr uint16 devilFileIdsDante[6] =
{
	pl005,
	pl006,
	pl007,
	pl008,
	pl009,
	pl017,
};






constexpr uint8 weaponDevilIds[MAX_WEAPON] =
{
	DEVIL_REBELLION,
	DEVIL_CERBERUS,
	DEVIL_AGNI_RUDRA,
	DEVIL_NEVAN,
	DEVIL_BEOWULF,
	0,
	0,
	0,
	0,
	0,
	0,
	DEVIL_YAMATO,
	DEVIL_BEOWULF,
	DEVIL_YAMATO,
	DEVIL_YAMATO,
};







constexpr uint32 hudTopOffs[] =
{
	0x700,
	0xE80,
	0x1600,
	0x1D80,
	0x2500,
	0x2C80,
	0x3400,
	0x3B80,
	0x4300,
	0x4A80,
	0x5200,
	0x5980,
	0x6100,
};

constexpr uint32 hudBottomOffs[] =
{
	0x880,
	0x1000,
	0x1780,
	0x1F00,
};





































#pragma pack(push, 1)




struct Size_32{ byte8 data[32]; operator byte8 *() { return reinterpret_cast<byte8 *>(this); }} ;
struct Size_112{ byte8 data[112]; operator byte8 *() { return reinterpret_cast<byte8 *>(this); }} ;
struct Size_192{ byte8 data[192]; operator byte8 *() { return reinterpret_cast<byte8 *>(this); }} ;
struct Size_240{ byte8 data[240]; operator byte8 *() { return reinterpret_cast<byte8 *>(this); }} ;
struct Size_288{ byte8 data[288]; operator byte8 *() { return reinterpret_cast<byte8 *>(this); }} ;
struct Size_768{ byte8 data[768]; operator byte8 *() { return reinterpret_cast<byte8 *>(this); }} ;







// $SessionDataStart

struct SessionData
{
	uint32 mission; // 0
	struct { byte8 padding_1185[8]; } ;
	uint32 mode; // 0xC
	bool oneHitKill; // 0x10
	struct { byte8 padding_1188[1]; } ;
	bool enableTutorial; // 0x12
	bool useGoldOrb; // 0x13
	uint8 character; // 0x14
	struct { byte8 padding_1192[7]; } ;
	bool bloodyPalace; // 0x1C
	struct { byte8 padding_1194[24]; } ;
	uint8 goldOrbCount; // 0x35
	struct { byte8 padding_1196[16]; } ;
	bool unlock[14]; // 0x46
	struct { byte8 padding_1198[48]; } ;
	uint8 weapons[4]; // 0x84
	struct { byte8 padding_1200[72]; } ;
	uint8 costume; // 0xD0
	bool unlockDevilTrigger; // 0xD1
	struct { byte8 padding_1203[2]; } ;
	float hitPoints; // 0xD4
	float magicPoints; // 0xD8
	uint32 style; // 0xDC
	uint32 styleLevel[6]; // 0xE0
	float styleExperience[6]; // 0xF8
	byte32 expertise[8]; // 0x110
};

static_assert(__builtin_offsetof(SessionData, mission) == 0);
static_assert(__builtin_offsetof(SessionData, mode) == 0xC);
static_assert(__builtin_offsetof(SessionData, oneHitKill) == 0x10);
static_assert(__builtin_offsetof(SessionData, enableTutorial) == 0x12);
static_assert(__builtin_offsetof(SessionData, useGoldOrb) == 0x13);
static_assert(__builtin_offsetof(SessionData, character) == 0x14);
static_assert(__builtin_offsetof(SessionData, bloodyPalace) == 0x1C);
static_assert(__builtin_offsetof(SessionData, goldOrbCount) == 0x35);
static_assert(__builtin_offsetof(SessionData, unlock) == 0x46);
static_assert(__builtin_offsetof(SessionData, weapons) == 0x84);
static_assert(__builtin_offsetof(SessionData, costume) == 0xD0);
static_assert(__builtin_offsetof(SessionData, unlockDevilTrigger) == 0xD1);
static_assert(__builtin_offsetof(SessionData, hitPoints) == 0xD4);
static_assert(__builtin_offsetof(SessionData, magicPoints) == 0xD8);
static_assert(__builtin_offsetof(SessionData, style) == 0xDC);
static_assert(__builtin_offsetof(SessionData, styleLevel) == 0xE0);
static_assert(__builtin_offsetof(SessionData, styleExperience) == 0xF8);
static_assert(__builtin_offsetof(SessionData, expertise) == 0x110);
static_assert(sizeof(SessionData) == 304);

// $SessionDataEnd



// $MissionDataStart

struct MissionData
{
	struct { byte8 padding_1240[56]; } ;
	uint32 orbs; // 0x38
	struct { byte8 padding_1242[108]; } ;
	uint32 frameCount; // 0xA8
	uint32 damage; // 0xAC
	uint32 orbsCollected; // 0xB0
	uint32 itemsUsed; // 0xB4
	uint32 killCount; // 0xB8
	struct { byte8 padding_1248[4]; } ;
};

static_assert(__builtin_offsetof(MissionData, orbs) == 0x38);
static_assert(__builtin_offsetof(MissionData, frameCount) == 0xA8);
static_assert(__builtin_offsetof(MissionData, damage) == 0xAC);
static_assert(__builtin_offsetof(MissionData, orbsCollected) == 0xB0);
static_assert(__builtin_offsetof(MissionData, itemsUsed) == 0xB4);
static_assert(__builtin_offsetof(MissionData, killCount) == 0xB8);
static_assert(sizeof(MissionData) == 192);

// $MissionDataEnd










// $MissionActorDataStart

struct QueuedMissionActorData
{
	uint8 weapons[5]; // 0
	struct { byte8 padding_1275[75]; } ;
	float hitPoints; // 0x50
	float magicPoints; // 0x54
	uint32 style; // 0x58
	uint32 styleLevel[6]; // 0x5C
	float styleExperience[6]; // 0x74
	byte32 expertise[8]; // 0x8C
};

static_assert(__builtin_offsetof(QueuedMissionActorData, weapons) == 0);
static_assert(__builtin_offsetof(QueuedMissionActorData, hitPoints) == 0x50);
static_assert(__builtin_offsetof(QueuedMissionActorData, magicPoints) == 0x54);
static_assert(__builtin_offsetof(QueuedMissionActorData, style) == 0x58);
static_assert(__builtin_offsetof(QueuedMissionActorData, styleLevel) == 0x5C);
static_assert(__builtin_offsetof(QueuedMissionActorData, styleExperience) == 0x74);
static_assert(__builtin_offsetof(QueuedMissionActorData, expertise) == 0x8C);
static_assert(sizeof(QueuedMissionActorData) == 172);

struct ActiveMissionActorData
{
	uint8 weapons[5]; // 0
	struct { byte8 padding_1296[51]; } ;
	uint32 style; // 0x38
	uint32 styleLevel; // 0x3C
	byte32 expertise[8]; // 0x40
	float styleExperience; // 0x60
	float hitPoints; // 0x64
	float maxHitPoints; // 0x68
	float magicPoints; // 0x6C
	float maxMagicPoints; // 0x70
};

static_assert(__builtin_offsetof(ActiveMissionActorData, weapons) == 0);
static_assert(__builtin_offsetof(ActiveMissionActorData, style) == 0x38);
static_assert(__builtin_offsetof(ActiveMissionActorData, styleLevel) == 0x3C);
static_assert(__builtin_offsetof(ActiveMissionActorData, expertise) == 0x40);
static_assert(__builtin_offsetof(ActiveMissionActorData, styleExperience) == 0x60);
static_assert(__builtin_offsetof(ActiveMissionActorData, hitPoints) == 0x64);
static_assert(__builtin_offsetof(ActiveMissionActorData, maxHitPoints) == 0x68);
static_assert(__builtin_offsetof(ActiveMissionActorData, magicPoints) == 0x6C);
static_assert(__builtin_offsetof(ActiveMissionActorData, maxMagicPoints) == 0x70);
static_assert(sizeof(ActiveMissionActorData) == 116);

// $MissionActorDataEnd











// $StyleDataStart

struct StyleData
{
	uint32 rank; // 0
	float meter; // 4
	struct { byte8 padding_1336[328]; } ;
	float quotient; // 0x150
	float dividend; // 0x154
	float divisor; // 0x158
	struct { byte8 padding_1340[4]; } ;
};

static_assert(__builtin_offsetof(StyleData, rank) == 0);
static_assert(__builtin_offsetof(StyleData, meter) == 4);
static_assert(__builtin_offsetof(StyleData, quotient) == 0x150);
static_assert(__builtin_offsetof(StyleData, dividend) == 0x154);
static_assert(__builtin_offsetof(StyleData, divisor) == 0x158);
static_assert(sizeof(StyleData) == 352);

// $StyleDataEnd

// @Todo: Create scripts.
struct EventData
{
	struct { byte8 padding_1355[24]; } ;
	uint32 room;
	uint32 position;
	uint32 event;
	struct { byte8 padding_1359[8]; } ;
	uint32 subevent;
};

struct NextEventData
{
	struct { byte8 padding_1365[356]; } ;
	uint16 room;
	uint16 position;
};








































// $CollisionDataStart

struct CollisionData
{
	struct { byte8 padding_1413[4]; } ;
	uint32 index; // 4
	struct { byte8 padding_1415[520]; } ;
	vec4 data; // 0x210
	struct { byte8 padding_1417[112]; } ;
};

static_assert(__builtin_offsetof(CollisionData, index) == 4);
static_assert(__builtin_offsetof(CollisionData, data) == 0x210);
static_assert(sizeof(CollisionData) == 656);

// $CollisionDataEnd

// $CameraDataStart

struct CameraData
{
	struct { byte8 padding_1430[176]; } ;
	byte8 * targetBaseAddr; // 0xB0
	struct { byte8 padding_1432[24]; } ;
	float height; // 0xD0
	float tilt; // 0xD4
	float zoom; // 0xD8
	struct { byte8 padding_1436[4]; } ;
	float zoomLockOn; // 0xE0
};

static_assert(__builtin_offsetof(CameraData, targetBaseAddr) == 0xB0);
static_assert(__builtin_offsetof(CameraData, height) == 0xD0);
static_assert(__builtin_offsetof(CameraData, tilt) == 0xD4);
static_assert(__builtin_offsetof(CameraData, zoom) == 0xD8);
static_assert(__builtin_offsetof(CameraData, zoomLockOn) == 0xE0);
static_assert(sizeof(CameraData) == 228);

// $CameraDataEnd
























/*
dmc3.exe+23E691 - 48 8D 93 80010000 - lea rdx,[rbx+00000180]
*/

struct ArchiveData
{
	byte8 signature[4];
	uint32 fileCount;
	uint32 fileOff[128];
};

struct StringData
{
	struct { byte8 padding_1485[8]; } ;
	const char * string;
};

struct FileData
{
	uint32 category;
	uint32 status;
	uint16 id;
	struct { byte8 padding_1494[6]; } ;
	void * callback;
	StringData * stringData;
	byte8 * file;
	struct { byte8 padding_1498[32]; } ;
};

// @Todo: Update names.

struct MEMORY_OBJECT
{
	byte8 * addr;
	byte8 * end;
	uint32 last;
	uint32 boundary;
	uint32 size;
	uint32 pipe;
	uint32 count;
	byte8 padding[4];
};

struct PS2_GAMEPAD
{
	struct { byte8 padding_1517[16]; } ;
	uint8  vibration[4];
	byte16 buttons[6];
	uint8  rightStickX;
	uint8  rightStickY;
	uint8  leftStickX;
	uint8  leftStickY;
	struct { byte8 padding_1524[12]; } ;
	uint16 rightStickDirection[4];
	uint16 leftStickDirection[4];
	uint16 rightStickDirectionFast[2];
	uint16 leftStickDirectionFast[2];
	uint16 rightStickPosition;
	uint16 leftStickPosition;
	uint16 rightStickDifference;
	uint16 leftStickDifference;
};

struct ENGINE_GAMEPAD
{
	byte16 buttons[4];
	uint16 buttonsTimer[2];
	uint16 rightStickDirection[4];
	uint16 rightStickTimer[2];
	uint16 rightStickPosition;
	uint16 rightStickRadius;
	uint16 leftStickDirection[4];
	uint16 leftStickTimer[2];
	uint16 leftStickPosition;
	uint16 leftStickRadius;
};

// @Todo: Order.

struct ActorEventData
{
	uint32 event;
	uint32 lastEvent;
};

struct MotionData
{
	uint8 index;
	uint8 group;
};

struct InputData
{
	byte8 flags[8];
	float32 value;
};

struct ShadowData
{
	struct { byte8 padding_1571[192]; } ;
};

static_assert(sizeof(ShadowData) == 0xC0);

struct PhysicsData
{
	struct { byte8 padding_1578[240]; } ;
};

static_assert(sizeof(PhysicsData) == 0xF0);

struct PhysicsLinkData
{
	struct { byte8 padding_1585[40]; } ;
	bool32 enable;
	struct { byte8 padding_1587[4]; } ;
	PhysicsData * physicsData;
	struct { byte8 padding_1589[72]; } ;
	vec4 data[4];
};

static_assert(__builtin_offsetof(PhysicsLinkData, enable) == 0x28);
static_assert(__builtin_offsetof(PhysicsLinkData, physicsData) == 0x30);
static_assert(__builtin_offsetof(PhysicsLinkData, data) == 0x80);
static_assert(sizeof(PhysicsLinkData) == 0xC0);

struct PhysicsMetadata
{
	struct { byte8 padding_1600[256]; } ;
	PhysicsLinkData * physicsLinkData;
	vec4 * vertices;
	PhysicsData * physicsData;
	struct { byte8 padding_1604[40]; } ;
};

static_assert(__builtin_offsetof(PhysicsMetadata, physicsLinkData) == 0x100);
static_assert(__builtin_offsetof(PhysicsMetadata, vertices) == 0x108);
static_assert(__builtin_offsetof(PhysicsMetadata, physicsData) == 0x110);
static_assert(sizeof(PhysicsMetadata) == 0x140);

struct BodyPartData
{
	struct { byte8 padding_1614[104]; } ;
	byte8 ** motionArchives;
	struct { byte8 padding_1616[176]; } ;
	//_(288);
};

static_assert(sizeof(BodyPartData) == 0x120);

struct ModelMetadata
{
	uint8 count;
	struct { byte8 padding_1625[15]; } ;
	vec4 vertices[3];
	struct { byte8 padding_1627[16]; } ;
};

static_assert(sizeof(ModelMetadata) == 80);

struct DevilModelMetadata
{
	uint8 modelIndex;
	uint8 modelPhysicsMetadataIndex;
};

struct DevilSubmodelMetadata
{
	uint8 submodelIndex;
	uint8 devilModelPhysicsMetadataIndex;
	uint8 devilSubmodelIndex;
};

struct DevilModelMetadata1 : DevilModelMetadata
{
	DevilSubmodelMetadata devilSubmodelMetadata;
};

struct DevilModelMetadata2 : DevilModelMetadata
{
	DevilSubmodelMetadata devilSubmodelMetadata[2];
};

struct DevilModelMetadataDante
{
	DevilModelMetadata2 Rebellion;
	DevilModelMetadata1 Cerberus;
	DevilModelMetadata  AgniRudra;
	DevilModelMetadata2 Nevan;
	DevilModelMetadata1 Beowulf;
	DevilModelMetadata1 Sparda;

	DevilModelMetadata2 & operator[](uint8 index)
	{
		switch (index)
		{
		case DEVIL_REBELLION:
		{
			return Rebellion;
		}
		case DEVIL_CERBERUS:
		{
			return *reinterpret_cast<DevilModelMetadata2 *>(&Cerberus);
		}
		case DEVIL_AGNI_RUDRA:
		{
			return *reinterpret_cast<DevilModelMetadata2 *>(&AgniRudra);
		}
		case DEVIL_NEVAN:
		{
			return Nevan;
		}
		case DEVIL_BEOWULF:
		{
			return *reinterpret_cast<DevilModelMetadata2 *>(&Beowulf);
		}
		case DEVIL_SPARDA:
		{
			return *reinterpret_cast<DevilModelMetadata2 *>(&Sparda);
		}
		}
		return Rebellion;
	}
};

static_assert(sizeof(DevilModelMetadataDante) == 33);

struct ModelPartitionData
{
	uint8 value;
	struct { byte8 padding_1702[895]; } ;
};

static_assert(sizeof(ModelPartitionData) == 0x380);

struct ModelData
{
	struct { byte8 padding_1709[8]; } ;
	byte8 ** functions;
	struct { byte8 padding_1711[8]; } ;
	bool visible;
	bool physics;
	struct { byte8 padding_1714[358]; } ;
	ModelPartitionData * modelPartitionData;
	struct { byte8 padding_1716[888]; } ;
	struct
	{
		struct { byte8 padding_1719[84]; } ;
		float32 duration1[2];
		struct { byte8 padding_1721[56]; } ;
		float32 duration2[2];
		struct { byte8 padding_1723[244]; } ;
		bool init;
		struct { byte8 padding_1725[35]; } ;
		float32 timer[2];
		struct { byte8 padding_1727[196]; } ;
	}
	Motion;
};

static_assert(__builtin_offsetof(ModelData, functions) == 8);
static_assert(__builtin_offsetof(ModelData, visible) == 0x18);
static_assert(__builtin_offsetof(ModelData, physics) == 0x19);
static_assert(__builtin_offsetof(ModelData, Motion) == 0x500);
static_assert(__builtin_offsetof(ModelData, Motion.duration1) == 0x554);
static_assert(__builtin_offsetof(ModelData, Motion.duration2) == 0x594);
static_assert(__builtin_offsetof(ModelData, Motion.init) == 0x690);
static_assert(__builtin_offsetof(ModelData, Motion.timer) == 0x6B4);
static_assert(sizeof(ModelData) == 0x780);

struct RecoveryData
{
	byte8 ** functions;
	struct { byte8 padding_1745[24]; } ;
	bool init;
	struct { byte8 padding_1747[15]; } ;
	vec4 data[4];
};

static_assert(__builtin_offsetof(RecoveryData, init) == 0x20);
static_assert(__builtin_offsetof(RecoveryData, data) == 0x30);
static_assert(sizeof(RecoveryData) == 0x70);

struct WeaponData
{
	struct { byte8 padding_1757[274]; } ;
	uint8 weapon;
	struct { byte8 padding_1759[5]; } ;
	uint8 value;
	struct { byte8 padding_1761[7]; } ;
	byte8 * actorBaseAddr;
};

static_assert(__builtin_offsetof(WeaponData, weapon) == 0x112);
static_assert(__builtin_offsetof(WeaponData, value) == 0x118);
static_assert(__builtin_offsetof(WeaponData, actorBaseAddr) == 0x120);



struct SummonedSwordsData
{
	struct { byte8 padding_1773[1376]; } ;
	byte8 * actorBaseAddr;
};

static_assert(__builtin_offsetof(SummonedSwordsData, actorBaseAddr) == 0x560);













struct CharacterData
{
	uint8 character;
	uint8 costume;
	bool forceFiles;
	uint8 forceFilesCharacter;

	uint8 styles[STYLE_COUNT][2];
	uint8 styleIndices[STYLE_COUNT];
	byte16 styleButtons[STYLE_COUNT];
	uint8 styleButtonIndex;

	uint8 meleeWeaponCount;
	uint8 meleeWeapons[MELEE_WEAPON_COUNT];
	uint8 meleeWeaponIndex;

	uint8 rangedWeaponCount;
	uint8 rangedWeapons[RANGED_WEAPON_COUNT];
	uint8 rangedWeaponIndex;
};

struct PlayerData
{
	byte16 button;

	uint8 characterCount;
	uint8 characterIndex;
	uint8 lastCharacterIndex;
	uint8 activeCharacterIndex;

	CharacterData characterData[CHARACTER_COUNT][ENTITY_COUNT];
};

// $ActorDataStart

struct ActorData
{
	struct { byte8 padding_1828[8]; } ;
	uint8 status; // 8
	struct { byte8 padding_1830[11]; } ;
	float speed; // 0x14
	float speedMultiplier; // 0x18
	struct { byte8 padding_1833[92]; } ;
	uint32 character; // 0x78
	struct { byte8 padding_1835[4]; } ;
	vec4 position; // 0x80
	struct { byte8 padding_1837[4]; } ;
	float pull; // 0x94
	struct { byte8 padding_1839[12]; } ;
	float pullMultiplier; // 0xA4
	struct { byte8 padding_1841[24]; } ;
	uint16 rotation; // 0xC0
	struct { byte8 padding_1843[86]; } ;
	uint8 id; // 0x118
	struct { byte8 padding_1845[3]; } ;
	bool32 isClone; // 0x11C
	uint32 visibility; // 0x120
	struct { byte8 padding_1848[156]; } ;
	float var_1C0; // 0x1C0
	float var_1C4; // 0x1C4
	struct { byte8 padding_1851[56]; } ;
	ModelData modelData[3]; // 0x200
	PhysicsMetadata * modelPhysicsMetadataPool[4][24]; // 0x1880
	uint32 modelAllocationDataCount; // 0x1B80
	struct { byte8 padding_1855[4]; } ;
	Size_32 modelAllocationData[209]; // 0x1B88
	struct { byte8 padding_1857[748]; } ;
	float motionSpeed; // 0x3894
	float motionSpeedMultiplier; // 0x3898
	struct { byte8 padding_1860[4]; } ;
	byte8 * motionArchives[34]; // 0x38A0
	MotionData motionData[2]; // 0x39B0
	MotionData motionDataMirror[3]; // 0x39B4
	struct { byte8 padding_1864[2]; } ;
	uint32 var_39BC; // 0x39BC
	uint8 var_39C0[16]; // 0x39C0
	uint32 nextActionRequestPolicy[16]; // 0x39D0
	uint8 var_3A10[8]; // 0x3A10
	uint32 shadow; // 0x3A18
	uint32 lastShadow; // 0x3A1C
	struct { byte8 padding_1871[8]; } ;
	byte32 color; // 0x3A28
	struct { byte8 padding_1873[212]; } ;
	RecoveryData recoveryData[3]; // 0x3B00
	byte8 var_3C50[2]; // 0x3C50
	struct { byte8 padding_1876[382]; } ;
	byte8 * actionData[6]; // 0x3DD0
	ActorEventData eventData[2]; // 0x3E00
	uint8 var_3E10[32]; // 0x3E10
	struct { byte8 padding_1880[4]; } ;
	float motionTimer; // 0x3E34
	float idleTimer; // 0x3E38
	struct { byte8 padding_1883[36]; } ;
	byte32 permissions; // 0x3E60
	byte32 state; // 0x3E64
	byte32 lastState; // 0x3E68
	uint32 activeModelIndex; // 0x3E6C
	uint32 queuedModelIndex; // 0x3E70
	uint32 devilModels[3]; // 0x3E74
	uint8 modelState; // 0x3E80
	struct { byte8 padding_1891[3]; } ;
	bool32 lockOn; // 0x3E84
	uint32 activeModelIndexMirror; // 0x3E88
	uint32 activeDevil; // 0x3E8C
	uint32 airRaid; // 0x3E90
	uint32 mode; // 0x3E94
	struct { byte8 padding_1897[1]; } ;
	bool dead; // 0x3E99
	struct { byte8 padding_1899[1]; } ;
	bool devil; // 0x3E9B
	struct { byte8 padding_1901[2]; } ;
	uint8 costume; // 0x3E9E
	union
	{
		bool sparda; // 0x3E9F
		bool neroAngelo; // 0x3E9F
	};
	struct { byte8 padding_1908[4]; } ;
	bool useHolyWater; // 0x3EA4
	struct { byte8 padding_1910[19]; } ;
	float magicPoints; // 0x3EB8
	float maxMagicPoints; // 0x3EBC
	struct { byte8 padding_1913[4]; } ;
	float var_3EC4; // 0x3EC4
	float var_3EC8; // 0x3EC8
	struct { byte8 padding_1916[6]; } ;
	uint16 var_3ED2; // 0x3ED2
	struct { byte8 padding_1918[4]; } ;
	uint16 cameraDirection; // 0x3ED8
	struct { byte8 padding_1920[2]; } ;
	float var_3EDC; // 0x3EDC
	struct { byte8 padding_1922[49]; } ;
	uint8 airHikeCount; // 0x3F11
	uint8 kickJumpCount; // 0x3F12
	uint8 wallHikeCount; // 0x3F13
	bool enableAirRaid; // 0x3F14
	struct { byte8 padding_1927[4]; } ;
	bool var_3F19; // 0x3F19
	struct { byte8 padding_1929[138]; } ;
	uint8 action; // 0x3FA4
	uint8 lastAction; // 0x3FA5
	struct { byte8 padding_1932[2]; } ;
	uint8 bufferedAction; // 0x3FA8
	struct { byte8 padding_1934[3]; } ;
	uint8 chainCount; // 0x3FAC
	struct { byte8 padding_1936[63]; } ;
	byte32 expertise[16]; // 0x3FEC
	struct { byte8 padding_1938[192]; } ;
	float maxHitPoints; // 0x40EC
	struct { byte8 padding_1940[44]; } ;
	float hitPoints; // 0x411C
	struct { byte8 padding_1942[8712]; } ;
	byte8 * targetBaseAddr; // 0x6328
	struct { byte8 padding_1944[8]; } ;
	uint32 style; // 0x6338
	uint32 wallHikeDirection; // 0x633C
	uint32 var_6340; // 0x6340
	struct { byte8 padding_1948[20]; } ;
	uint32 styleLevel; // 0x6358
	uint8 dashCount; // 0x635C
	uint8 skyStarCount; // 0x635D
	uint8 airTrickCount; // 0x635E
	uint8 trickUpCount; // 0x635F
	uint8 trickDownCount; // 0x6360
	bool quicksilver; // 0x6361
	bool doppelganger; // 0x6362
	struct { byte8 padding_1957[1]; } ;
	float styleExperience; // 0x6364
	struct { byte8 padding_1959[108]; } ;
	uint32 speedMode; // 0x63D4
	struct { byte8 padding_1961[56]; } ;
	byte8 var_6410[40]; // 0x6410
	byte8 * var_6438; // 0x6438
	uint32 var_6440; // 0x6440
	struct { byte8 padding_1965[12]; } ;
	uint32 cloneRate; // 0x6450
	uint32 cloneStatus; // 0x6454
	byte8 var_6458[32]; // 0x6458
	byte8 * cloneActorBaseAddr; // 0x6478
	bool cloneIsControlledByPlayer; // 0x6480
	struct { byte8 padding_1971[3]; } ;
	uint32 activeMeleeWeaponIndex; // 0x6484
	uint32 queuedMeleeWeaponIndex; // 0x6488
	struct { byte8 padding_1974[1]; } ;
	uint8 activeWeapon; // 0x648D
	struct { byte8 padding_1976[2]; } ;
	uint32 meleeWeaponIndex; // 0x6490
	uint32 rangedWeaponIndex; // 0x6494
	uint8 weapons[5]; // 0x6498
	struct { byte8 padding_1980[3]; } ;
	WeaponData * weaponDataAddr[5]; // 0x64A0
	uint32 weaponStatus[5]; // 0x64C8
	uint32 weaponLevels[5]; // 0x64DC
	uint8 activeMeleeWeapon; // 0x64F0
	uint8 activeRangedWeapon; // 0x64F1
	struct { byte8 padding_1986[2]; } ;
	float weaponTimers[5]; // 0x64F4
	float meleeWeaponSwitchTimeout; // 0x6508
	float rangedWeaponSwitchTimeout; // 0x650C
	StyleData styleData; // 0x6510
	float var_6670; // 0x6670
	InputData inputData[58]; // 0x6674
	struct { byte8 padding_1993[36]; } ;
	BodyPartData bodyPartData[3][2]; // 0x6950
	struct { byte8 padding_1995[576]; } ;
	CollisionData collisionData; // 0x7250
	byte16 buttons[4]; // 0x74E0
	struct { byte8 padding_1998[16]; } ;
	uint16 rightStickPosition; // 0x74F8
	uint16 rightStickRadius; // 0x74FA
	struct { byte8 padding_2001[12]; } ;
	uint16 leftStickPosition; // 0x7508
	uint16 leftStickRadius; // 0x750A
	uint16 actorCameraDirection; // 0x750C
	struct { byte8 padding_2005[14]; } ;
	uint32 leftStickDirection[2]; // 0x751C
	struct { byte8 padding_2007[28]; } ;
	ModelData submodelData[5]; // 0x7540
	bool submodelInit[5]; // 0x9AC0
	struct { byte8 padding_2010[7675]; } ;
	uint32 newFirstVar; // 0xB8C0
	struct { byte8 padding_2012[12]; } ;
	ModelData newModelData[6]; // 0xB8D0
	PhysicsMetadata * newModelPhysicsMetadataPool[7][24]; // 0xE5D0
	Size_32 newModelAllocationData[512]; // 0xEB10
	RecoveryData newRecoveryData[6]; // 0x12B10
	uint32 newDevilModels[6]; // 0x12DB0
	struct { byte8 padding_2018[8]; } ;
	BodyPartData newBodyPartData[7][2]; // 0x12DD0
	ModelData newSubmodelData[11]; // 0x13D90
	bool newSubmodelInit[11]; // 0x19010
	struct { byte8 padding_2022[5]; } ;
	ShadowData newModelShadowData[6]; // 0x19020
	ShadowData newSubmodelShadowData[11]; // 0x194A0
	PhysicsMetadata * newDevilModelPhysicsMetadataPool[5][36]; // 0x19CE0
	PhysicsData newDevilSubmodelPhysicsData[10]; // 0x1A280
	PhysicsLinkData newDevilSubmodelPhysicsLinkData[10][4]; // 0x1ABE0
	uint8 newWeapons[10]; // 0x1C9E0
	struct { byte8 padding_2029[6]; } ;
	WeaponData * newWeaponDataAddr[10]; // 0x1C9F0
	uint32 newWeaponStatus[10]; // 0x1CA40
	struct { byte8 padding_2032[8]; } ;
	uint32 newWeaponLevels[10]; // 0x1CA70
	struct { byte8 padding_2034[8]; } ;
	float newWeaponTimers[10]; // 0x1CAA0
	bool32 newIsClone; // 0x1CAC8
	uint8 newPlayerIndex; // 0x1CACC
	uint8 newCharacterIndex; // 0x1CACD
	uint8 newEntityIndex; // 0x1CACE
	bool newForceFiles; // 0x1CACF
	uint8 newForceFilesCharacter; // 0x1CAD0
	bool newEnableVisibility; // 0x1CAD1
	uint8 newGamepad; // 0x1CAD2
	byte16 newButtonMask; // 0x1CAD3
	bool newEnableRightStick; // 0x1CAD5
	bool newEnableLeftStick; // 0x1CAD6
	bool newExecuteStyleSwitch; // 0x1CAD7
	bool newExecuteRemoveBusyFlag; // 0x1CAD8
	uint8 newAirStingerCount; // 0x1CAD9
	bool newEnableCollision; // 0x1CADA
	bool newActorLoopRun; // 0x1CADB
	uint8 newAirHikeCount; // 0x1CADC
	uint8 newKickJumpCount; // 0x1CADD
	uint8 newWallHikeCount; // 0x1CADE
	uint8 newDashCount; // 0x1CADF
	uint8 newSkyStarCount; // 0x1CAE0
	uint8 newAirTrickCount; // 0x1CAE1
	uint8 newTrickUpCount; // 0x1CAE2
	uint8 newTrickDownCount; // 0x1CAE3
	struct { byte8 padding_2060[12]; } ;
	uint32 newEffectIndices[12]; // 0x1CAF0
	uint32 newLastVar; // 0x1CB20

	operator byte8 *()
	{
		return reinterpret_cast<byte8 *>(this);
	}
};

struct ActorDataDante
{
	struct { byte8 padding_2072[8]; } ;
	uint8 status; // 8
	struct { byte8 padding_2074[11]; } ;
	float speed; // 0x14
	float speedMultiplier; // 0x18
	struct { byte8 padding_2077[92]; } ;
	uint32 character; // 0x78
	struct { byte8 padding_2079[4]; } ;
	vec4 position; // 0x80
	struct { byte8 padding_2081[4]; } ;
	float pull; // 0x94
	struct { byte8 padding_2083[12]; } ;
	float pullMultiplier; // 0xA4
	struct { byte8 padding_2085[24]; } ;
	uint16 rotation; // 0xC0
	struct { byte8 padding_2087[86]; } ;
	uint8 id; // 0x118
	struct { byte8 padding_2089[3]; } ;
	bool32 isClone; // 0x11C
	uint32 visibility; // 0x120
	struct { byte8 padding_2092[156]; } ;
	float var_1C0; // 0x1C0
	float var_1C4; // 0x1C4
	struct { byte8 padding_2095[56]; } ;
	ModelData modelData[3]; // 0x200
	PhysicsMetadata * modelPhysicsMetadataPool[4][24]; // 0x1880
	uint32 modelAllocationDataCount; // 0x1B80
	struct { byte8 padding_2099[4]; } ;
	Size_32 modelAllocationData[209]; // 0x1B88
	struct { byte8 padding_2101[748]; } ;
	float motionSpeed; // 0x3894
	float motionSpeedMultiplier; // 0x3898
	struct { byte8 padding_2104[4]; } ;
	byte8 * motionArchives[34]; // 0x38A0
	MotionData motionData[2]; // 0x39B0
	MotionData motionDataMirror[3]; // 0x39B4
	struct { byte8 padding_2108[2]; } ;
	uint32 var_39BC; // 0x39BC
	uint8 var_39C0[16]; // 0x39C0
	uint32 nextActionRequestPolicy[16]; // 0x39D0
	uint8 var_3A10[8]; // 0x3A10
	uint32 shadow; // 0x3A18
	uint32 lastShadow; // 0x3A1C
	struct { byte8 padding_2115[8]; } ;
	byte32 color; // 0x3A28
	struct { byte8 padding_2117[212]; } ;
	RecoveryData recoveryData[3]; // 0x3B00
	byte8 var_3C50[2]; // 0x3C50
	struct { byte8 padding_2120[382]; } ;
	byte8 * actionData[6]; // 0x3DD0
	ActorEventData eventData[2]; // 0x3E00
	uint8 var_3E10[32]; // 0x3E10
	struct { byte8 padding_2124[4]; } ;
	float motionTimer; // 0x3E34
	float idleTimer; // 0x3E38
	struct { byte8 padding_2127[36]; } ;
	byte32 permissions; // 0x3E60
	byte32 state; // 0x3E64
	byte32 lastState; // 0x3E68
	uint32 activeModelIndex; // 0x3E6C
	uint32 queuedModelIndex; // 0x3E70
	uint32 devilModels[3]; // 0x3E74
	uint8 modelState; // 0x3E80
	struct { byte8 padding_2135[3]; } ;
	bool32 lockOn; // 0x3E84
	uint32 activeModelIndexMirror; // 0x3E88
	uint32 activeDevil; // 0x3E8C
	uint32 airRaid; // 0x3E90
	uint32 mode; // 0x3E94
	struct { byte8 padding_2141[1]; } ;
	bool dead; // 0x3E99
	struct { byte8 padding_2143[1]; } ;
	bool devil; // 0x3E9B
	struct { byte8 padding_2145[2]; } ;
	uint8 costume; // 0x3E9E
	union
	{
		bool sparda; // 0x3E9F
		bool neroAngelo; // 0x3E9F
	};
	struct { byte8 padding_2152[4]; } ;
	bool useHolyWater; // 0x3EA4
	struct { byte8 padding_2154[19]; } ;
	float magicPoints; // 0x3EB8
	float maxMagicPoints; // 0x3EBC
	struct { byte8 padding_2157[4]; } ;
	float var_3EC4; // 0x3EC4
	float var_3EC8; // 0x3EC8
	struct { byte8 padding_2160[6]; } ;
	uint16 var_3ED2; // 0x3ED2
	struct { byte8 padding_2162[4]; } ;
	uint16 cameraDirection; // 0x3ED8
	struct { byte8 padding_2164[2]; } ;
	float var_3EDC; // 0x3EDC
	struct { byte8 padding_2166[49]; } ;
	uint8 airHikeCount; // 0x3F11
	uint8 kickJumpCount; // 0x3F12
	uint8 wallHikeCount; // 0x3F13
	bool enableAirRaid; // 0x3F14
	struct { byte8 padding_2171[4]; } ;
	bool var_3F19; // 0x3F19
	struct { byte8 padding_2173[138]; } ;
	uint8 action; // 0x3FA4
	uint8 lastAction; // 0x3FA5
	struct { byte8 padding_2176[2]; } ;
	uint8 bufferedAction; // 0x3FA8
	struct { byte8 padding_2178[3]; } ;
	uint8 chainCount; // 0x3FAC
	struct { byte8 padding_2180[63]; } ;
	byte32 expertise[16]; // 0x3FEC
	struct { byte8 padding_2182[192]; } ;
	float maxHitPoints; // 0x40EC
	struct { byte8 padding_2184[44]; } ;
	float hitPoints; // 0x411C
	struct { byte8 padding_2186[8712]; } ;
	byte8 * targetBaseAddr; // 0x6328
	struct { byte8 padding_2188[8]; } ;
	uint32 style; // 0x6338
	uint32 wallHikeDirection; // 0x633C
	uint32 var_6340; // 0x6340
	struct { byte8 padding_2192[20]; } ;
	uint32 styleLevel; // 0x6358
	uint8 dashCount; // 0x635C
	uint8 skyStarCount; // 0x635D
	uint8 airTrickCount; // 0x635E
	uint8 trickUpCount; // 0x635F
	uint8 trickDownCount; // 0x6360
	bool quicksilver; // 0x6361
	bool doppelganger; // 0x6362
	struct { byte8 padding_2201[1]; } ;
	float styleExperience; // 0x6364
	struct { byte8 padding_2203[108]; } ;
	uint32 speedMode; // 0x63D4
	struct { byte8 padding_2205[56]; } ;
	byte8 var_6410[40]; // 0x6410
	byte8 * var_6438; // 0x6438
	uint32 var_6440; // 0x6440
	struct { byte8 padding_2209[12]; } ;
	uint32 cloneRate; // 0x6450
	uint32 cloneStatus; // 0x6454
	byte8 var_6458[32]; // 0x6458
	byte8 * cloneActorBaseAddr; // 0x6478
	bool cloneIsControlledByPlayer; // 0x6480
	struct { byte8 padding_2215[3]; } ;
	uint32 activeMeleeWeaponIndex; // 0x6484
	uint32 queuedMeleeWeaponIndex; // 0x6488
	struct { byte8 padding_2218[1]; } ;
	uint8 activeWeapon; // 0x648D
	struct { byte8 padding_2220[2]; } ;
	uint32 meleeWeaponIndex; // 0x6490
	uint32 rangedWeaponIndex; // 0x6494
	uint8 weapons[5]; // 0x6498
	struct { byte8 padding_2224[3]; } ;
	WeaponData * weaponDataAddr[5]; // 0x64A0
	uint32 weaponStatus[5]; // 0x64C8
	uint32 weaponLevels[5]; // 0x64DC
	uint8 activeMeleeWeapon; // 0x64F0
	uint8 activeRangedWeapon; // 0x64F1
	struct { byte8 padding_2230[2]; } ;
	float weaponTimers[5]; // 0x64F4
	float meleeWeaponSwitchTimeout; // 0x6508
	float rangedWeaponSwitchTimeout; // 0x650C
	StyleData styleData; // 0x6510
	float var_6670; // 0x6670
	InputData inputData[58]; // 0x6674
	struct { byte8 padding_2237[36]; } ;
	BodyPartData bodyPartData[3][2]; // 0x6950
	struct { byte8 padding_2239[576]; } ;
	CollisionData collisionData; // 0x7250
	byte16 buttons[4]; // 0x74E0
	struct { byte8 padding_2242[16]; } ;
	uint16 rightStickPosition; // 0x74F8
	uint16 rightStickRadius; // 0x74FA
	struct { byte8 padding_2245[12]; } ;
	uint16 leftStickPosition; // 0x7508
	uint16 leftStickRadius; // 0x750A
	uint16 actorCameraDirection; // 0x750C
	struct { byte8 padding_2249[14]; } ;
	uint32 leftStickDirection[2]; // 0x751C
	struct { byte8 padding_2251[28]; } ;
	ModelData submodelData[5]; // 0x7540
	bool submodelInit[5]; // 0x9AC0
	struct { byte8 padding_2254[11]; } ;
	ShadowData modelShadowData[3]; // 0x9AD0
	ShadowData submodelShadowData[5]; // 0x9D10
	PhysicsMetadata * submodelPhysicsMetadataPool[39]; // 0xA0D0
	struct { byte8 padding_2258[8]; } ;
	PhysicsData submodelPhysicsData; // 0xA210
	PhysicsMetadata * devilModelPhysicsMetadataPool[2][36]; // 0xA300
	PhysicsData devilSubmodelPhysicsData[4]; // 0xA540
	struct { byte8 padding_2262[256]; } ;
	PhysicsLinkData devilSubmodelPhysicsLinkData[4][4]; // 0xAA00
	DevilModelMetadataDante devilModelMetadata; // 0xB600
	struct { byte8 padding_2265[15]; } ;
	ModelMetadata modelMetadata[6]; // 0xB630
	struct { byte8 padding_2267[88]; } ;
	float artemisChargeValue[2]; // 0xB868
	struct { byte8 padding_2269[12]; } ;
	byte32 artemisChargeFlags[2]; // 0xB87C
	struct { byte8 padding_2271[60]; } ;
	uint32 newFirstVar; // 0xB8C0
	struct { byte8 padding_2273[12]; } ;
	ModelData newModelData[6]; // 0xB8D0
	PhysicsMetadata * newModelPhysicsMetadataPool[7][24]; // 0xE5D0
	Size_32 newModelAllocationData[512]; // 0xEB10
	RecoveryData newRecoveryData[6]; // 0x12B10
	uint32 newDevilModels[6]; // 0x12DB0
	struct { byte8 padding_2279[8]; } ;
	BodyPartData newBodyPartData[7][2]; // 0x12DD0
	ModelData newSubmodelData[11]; // 0x13D90
	bool newSubmodelInit[11]; // 0x19010
	struct { byte8 padding_2283[5]; } ;
	ShadowData newModelShadowData[6]; // 0x19020
	ShadowData newSubmodelShadowData[11]; // 0x194A0
	PhysicsMetadata * newDevilModelPhysicsMetadataPool[5][36]; // 0x19CE0
	PhysicsData newDevilSubmodelPhysicsData[10]; // 0x1A280
	PhysicsLinkData newDevilSubmodelPhysicsLinkData[10][4]; // 0x1ABE0
	uint8 newWeapons[10]; // 0x1C9E0
	struct { byte8 padding_2290[6]; } ;
	WeaponData * newWeaponDataAddr[10]; // 0x1C9F0
	uint32 newWeaponStatus[10]; // 0x1CA40
	struct { byte8 padding_2293[8]; } ;
	uint32 newWeaponLevels[10]; // 0x1CA70
	struct { byte8 padding_2295[8]; } ;
	float newWeaponTimers[10]; // 0x1CAA0
	bool32 newIsClone; // 0x1CAC8
	uint8 newPlayerIndex; // 0x1CACC
	uint8 newCharacterIndex; // 0x1CACD
	uint8 newEntityIndex; // 0x1CACE
	bool newForceFiles; // 0x1CACF
	uint8 newForceFilesCharacter; // 0x1CAD0
	bool newEnableVisibility; // 0x1CAD1
	uint8 newGamepad; // 0x1CAD2
	byte16 newButtonMask; // 0x1CAD3
	bool newEnableRightStick; // 0x1CAD5
	bool newEnableLeftStick; // 0x1CAD6
	bool newExecuteStyleSwitch; // 0x1CAD7
	bool newExecuteRemoveBusyFlag; // 0x1CAD8
	uint8 newAirStingerCount; // 0x1CAD9
	bool newEnableCollision; // 0x1CADA
	bool newActorLoopRun; // 0x1CADB
	uint8 newAirHikeCount; // 0x1CADC
	uint8 newKickJumpCount; // 0x1CADD
	uint8 newWallHikeCount; // 0x1CADE
	uint8 newDashCount; // 0x1CADF
	uint8 newSkyStarCount; // 0x1CAE0
	uint8 newAirTrickCount; // 0x1CAE1
	uint8 newTrickUpCount; // 0x1CAE2
	uint8 newTrickDownCount; // 0x1CAE3
	struct { byte8 padding_2321[12]; } ;
	uint32 newEffectIndices[12]; // 0x1CAF0
	uint32 newLastVar; // 0x1CB20

	operator byte8 *()
	{
		return reinterpret_cast<byte8 *>(this);
	}
};

struct ActorDataBob
{
	struct { byte8 padding_2333[8]; } ;
	uint8 status; // 8
	struct { byte8 padding_2335[11]; } ;
	float speed; // 0x14
	float speedMultiplier; // 0x18
	struct { byte8 padding_2338[92]; } ;
	uint32 character; // 0x78
	struct { byte8 padding_2340[4]; } ;
	vec4 position; // 0x80
	struct { byte8 padding_2342[4]; } ;
	float pull; // 0x94
	struct { byte8 padding_2344[12]; } ;
	float pullMultiplier; // 0xA4
	struct { byte8 padding_2346[24]; } ;
	uint16 rotation; // 0xC0
	struct { byte8 padding_2348[86]; } ;
	uint8 id; // 0x118
	struct { byte8 padding_2350[3]; } ;
	bool32 isClone; // 0x11C
	uint32 visibility; // 0x120
	struct { byte8 padding_2353[156]; } ;
	float var_1C0; // 0x1C0
	float var_1C4; // 0x1C4
	struct { byte8 padding_2356[56]; } ;
	ModelData modelData[3]; // 0x200
	PhysicsMetadata * modelPhysicsMetadataPool[4][24]; // 0x1880
	uint32 modelAllocationDataCount; // 0x1B80
	struct { byte8 padding_2360[4]; } ;
	Size_32 modelAllocationData[209]; // 0x1B88
	struct { byte8 padding_2362[748]; } ;
	float motionSpeed; // 0x3894
	float motionSpeedMultiplier; // 0x3898
	struct { byte8 padding_2365[4]; } ;
	byte8 * motionArchives[34]; // 0x38A0
	MotionData motionData[2]; // 0x39B0
	MotionData motionDataMirror[3]; // 0x39B4
	struct { byte8 padding_2369[2]; } ;
	uint32 var_39BC; // 0x39BC
	uint8 var_39C0[16]; // 0x39C0
	uint32 nextActionRequestPolicy[16]; // 0x39D0
	uint8 var_3A10[8]; // 0x3A10
	uint32 shadow; // 0x3A18
	uint32 lastShadow; // 0x3A1C
	struct { byte8 padding_2376[8]; } ;
	byte32 color; // 0x3A28
	struct { byte8 padding_2378[212]; } ;
	RecoveryData recoveryData[3]; // 0x3B00
	byte8 var_3C50[2]; // 0x3C50
	struct { byte8 padding_2381[382]; } ;
	byte8 * actionData[6]; // 0x3DD0
	ActorEventData eventData[2]; // 0x3E00
	uint8 var_3E10[32]; // 0x3E10
	struct { byte8 padding_2385[4]; } ;
	float motionTimer; // 0x3E34
	float idleTimer; // 0x3E38
	struct { byte8 padding_2388[36]; } ;
	byte32 permissions; // 0x3E60
	byte32 state; // 0x3E64
	byte32 lastState; // 0x3E68
	uint32 activeModelIndex; // 0x3E6C
	uint32 queuedModelIndex; // 0x3E70
	uint32 devilModels[3]; // 0x3E74
	uint8 modelState; // 0x3E80
	struct { byte8 padding_2396[3]; } ;
	bool32 lockOn; // 0x3E84
	uint32 activeModelIndexMirror; // 0x3E88
	uint32 activeDevil; // 0x3E8C
	uint32 airRaid; // 0x3E90
	uint32 mode; // 0x3E94
	struct { byte8 padding_2402[1]; } ;
	bool dead; // 0x3E99
	struct { byte8 padding_2404[1]; } ;
	bool devil; // 0x3E9B
	struct { byte8 padding_2406[2]; } ;
	uint8 costume; // 0x3E9E
	union
	{
		bool sparda; // 0x3E9F
		bool neroAngelo; // 0x3E9F
	};
	struct { byte8 padding_2413[4]; } ;
	bool useHolyWater; // 0x3EA4
	struct { byte8 padding_2415[19]; } ;
	float magicPoints; // 0x3EB8
	float maxMagicPoints; // 0x3EBC
	struct { byte8 padding_2418[4]; } ;
	float var_3EC4; // 0x3EC4
	float var_3EC8; // 0x3EC8
	struct { byte8 padding_2421[6]; } ;
	uint16 var_3ED2; // 0x3ED2
	struct { byte8 padding_2423[4]; } ;
	uint16 cameraDirection; // 0x3ED8
	struct { byte8 padding_2425[2]; } ;
	float var_3EDC; // 0x3EDC
	struct { byte8 padding_2427[49]; } ;
	uint8 airHikeCount; // 0x3F11
	uint8 kickJumpCount; // 0x3F12
	uint8 wallHikeCount; // 0x3F13
	bool enableAirRaid; // 0x3F14
	struct { byte8 padding_2432[4]; } ;
	bool var_3F19; // 0x3F19
	struct { byte8 padding_2434[138]; } ;
	uint8 action; // 0x3FA4
	uint8 lastAction; // 0x3FA5
	struct { byte8 padding_2437[2]; } ;
	uint8 bufferedAction; // 0x3FA8
	struct { byte8 padding_2439[3]; } ;
	uint8 chainCount; // 0x3FAC
	struct { byte8 padding_2441[63]; } ;
	byte32 expertise[16]; // 0x3FEC
	struct { byte8 padding_2443[192]; } ;
	float maxHitPoints; // 0x40EC
	struct { byte8 padding_2445[44]; } ;
	float hitPoints; // 0x411C
	struct { byte8 padding_2447[8712]; } ;
	byte8 * targetBaseAddr; // 0x6328
	struct { byte8 padding_2449[8]; } ;
	uint32 style; // 0x6338
	uint32 wallHikeDirection; // 0x633C
	uint32 var_6340; // 0x6340
	struct { byte8 padding_2453[20]; } ;
	uint32 styleLevel; // 0x6358
	uint8 dashCount; // 0x635C
	uint8 skyStarCount; // 0x635D
	uint8 airTrickCount; // 0x635E
	uint8 trickUpCount; // 0x635F
	uint8 trickDownCount; // 0x6360
	bool quicksilver; // 0x6361
	bool doppelganger; // 0x6362
	struct { byte8 padding_2462[1]; } ;
	float styleExperience; // 0x6364
	struct { byte8 padding_2464[108]; } ;
	uint32 speedMode; // 0x63D4
	struct { byte8 padding_2466[56]; } ;
	byte8 var_6410[40]; // 0x6410
	byte8 * var_6438; // 0x6438
	uint32 var_6440; // 0x6440
	struct { byte8 padding_2470[12]; } ;
	uint32 cloneRate; // 0x6450
	uint32 cloneStatus; // 0x6454
	byte8 var_6458[32]; // 0x6458
	byte8 * cloneActorBaseAddr; // 0x6478
	bool cloneIsControlledByPlayer; // 0x6480
	struct { byte8 padding_2476[3]; } ;
	uint32 activeMeleeWeaponIndex; // 0x6484
	uint32 queuedMeleeWeaponIndex; // 0x6488
	struct { byte8 padding_2479[1]; } ;
	uint8 activeWeapon; // 0x648D
	struct { byte8 padding_2481[2]; } ;
	uint32 meleeWeaponIndex; // 0x6490
	uint32 rangedWeaponIndex; // 0x6494
	uint8 weapons[5]; // 0x6498
	struct { byte8 padding_2485[3]; } ;
	WeaponData * weaponDataAddr[5]; // 0x64A0
	uint32 weaponStatus[5]; // 0x64C8
	uint32 weaponLevels[5]; // 0x64DC
	uint8 activeMeleeWeapon; // 0x64F0
	uint8 activeRangedWeapon; // 0x64F1
	struct { byte8 padding_2491[2]; } ;
	float weaponTimers[5]; // 0x64F4
	float meleeWeaponSwitchTimeout; // 0x6508
	float rangedWeaponSwitchTimeout; // 0x650C
	StyleData styleData; // 0x6510
	float var_6670; // 0x6670
	InputData inputData[58]; // 0x6674
	struct { byte8 padding_2498[36]; } ;
	BodyPartData bodyPartData[3][2]; // 0x6950
	struct { byte8 padding_2500[576]; } ;
	CollisionData collisionData; // 0x7250
	byte16 buttons[4]; // 0x74E0
	struct { byte8 padding_2503[16]; } ;
	uint16 rightStickPosition; // 0x74F8
	uint16 rightStickRadius; // 0x74FA
	struct { byte8 padding_2506[12]; } ;
	uint16 leftStickPosition; // 0x7508
	uint16 leftStickRadius; // 0x750A
	uint16 actorCameraDirection; // 0x750C
	struct { byte8 padding_2510[14]; } ;
	uint32 leftStickDirection[2]; // 0x751C
	struct { byte8 padding_2512[28]; } ;
	ModelData submodelData[5]; // 0x7540
	bool submodelInit[5]; // 0x9AC0
	struct { byte8 padding_2515[7675]; } ;
	uint32 newFirstVar; // 0xB8C0
	struct { byte8 padding_2517[12]; } ;
	ModelData newModelData[6]; // 0xB8D0
	PhysicsMetadata * newModelPhysicsMetadataPool[7][24]; // 0xE5D0
	Size_32 newModelAllocationData[512]; // 0xEB10
	RecoveryData newRecoveryData[6]; // 0x12B10
	uint32 newDevilModels[6]; // 0x12DB0
	struct { byte8 padding_2523[8]; } ;
	BodyPartData newBodyPartData[7][2]; // 0x12DD0
	ModelData newSubmodelData[11]; // 0x13D90
	bool newSubmodelInit[11]; // 0x19010
	struct { byte8 padding_2527[5]; } ;
	ShadowData newModelShadowData[6]; // 0x19020
	ShadowData newSubmodelShadowData[11]; // 0x194A0
	PhysicsMetadata * newDevilModelPhysicsMetadataPool[5][36]; // 0x19CE0
	PhysicsData newDevilSubmodelPhysicsData[10]; // 0x1A280
	PhysicsLinkData newDevilSubmodelPhysicsLinkData[10][4]; // 0x1ABE0
	uint8 newWeapons[10]; // 0x1C9E0
	struct { byte8 padding_2534[6]; } ;
	WeaponData * newWeaponDataAddr[10]; // 0x1C9F0
	uint32 newWeaponStatus[10]; // 0x1CA40
	struct { byte8 padding_2537[8]; } ;
	uint32 newWeaponLevels[10]; // 0x1CA70
	struct { byte8 padding_2539[8]; } ;
	float newWeaponTimers[10]; // 0x1CAA0
	bool32 newIsClone; // 0x1CAC8
	uint8 newPlayerIndex; // 0x1CACC
	uint8 newCharacterIndex; // 0x1CACD
	uint8 newEntityIndex; // 0x1CACE
	bool newForceFiles; // 0x1CACF
	uint8 newForceFilesCharacter; // 0x1CAD0
	bool newEnableVisibility; // 0x1CAD1
	uint8 newGamepad; // 0x1CAD2
	byte16 newButtonMask; // 0x1CAD3
	bool newEnableRightStick; // 0x1CAD5
	bool newEnableLeftStick; // 0x1CAD6
	bool newExecuteStyleSwitch; // 0x1CAD7
	bool newExecuteRemoveBusyFlag; // 0x1CAD8
	uint8 newAirStingerCount; // 0x1CAD9
	bool newEnableCollision; // 0x1CADA
	bool newActorLoopRun; // 0x1CADB
	uint8 newAirHikeCount; // 0x1CADC
	uint8 newKickJumpCount; // 0x1CADD
	uint8 newWallHikeCount; // 0x1CADE
	uint8 newDashCount; // 0x1CADF
	uint8 newSkyStarCount; // 0x1CAE0
	uint8 newAirTrickCount; // 0x1CAE1
	uint8 newTrickUpCount; // 0x1CAE2
	uint8 newTrickDownCount; // 0x1CAE3
	struct { byte8 padding_2565[12]; } ;
	uint32 newEffectIndices[12]; // 0x1CAF0
	uint32 newLastVar; // 0x1CB20

	operator byte8 *()
	{
		return reinterpret_cast<byte8 *>(this);
	}
};

struct ActorDataLady
{
	struct { byte8 padding_2577[8]; } ;
	uint8 status; // 8
	struct { byte8 padding_2579[11]; } ;
	float speed; // 0x14
	float speedMultiplier; // 0x18
	struct { byte8 padding_2582[92]; } ;
	uint32 character; // 0x78
	struct { byte8 padding_2584[4]; } ;
	vec4 position; // 0x80
	struct { byte8 padding_2586[4]; } ;
	float pull; // 0x94
	struct { byte8 padding_2588[12]; } ;
	float pullMultiplier; // 0xA4
	struct { byte8 padding_2590[24]; } ;
	uint16 rotation; // 0xC0
	struct { byte8 padding_2592[86]; } ;
	uint8 id; // 0x118
	struct { byte8 padding_2594[3]; } ;
	bool32 isClone; // 0x11C
	uint32 visibility; // 0x120
	struct { byte8 padding_2597[156]; } ;
	float var_1C0; // 0x1C0
	float var_1C4; // 0x1C4
	struct { byte8 padding_2600[56]; } ;
	ModelData modelData[3]; // 0x200
	PhysicsMetadata * modelPhysicsMetadataPool[4][24]; // 0x1880
	uint32 modelAllocationDataCount; // 0x1B80
	struct { byte8 padding_2604[4]; } ;
	Size_32 modelAllocationData[209]; // 0x1B88
	struct { byte8 padding_2606[748]; } ;
	float motionSpeed; // 0x3894
	float motionSpeedMultiplier; // 0x3898
	struct { byte8 padding_2609[4]; } ;
	byte8 * motionArchives[34]; // 0x38A0
	MotionData motionData[2]; // 0x39B0
	MotionData motionDataMirror[3]; // 0x39B4
	struct { byte8 padding_2613[2]; } ;
	uint32 var_39BC; // 0x39BC
	uint8 var_39C0[16]; // 0x39C0
	uint32 nextActionRequestPolicy[16]; // 0x39D0
	uint8 var_3A10[8]; // 0x3A10
	uint32 shadow; // 0x3A18
	uint32 lastShadow; // 0x3A1C
	struct { byte8 padding_2620[8]; } ;
	byte32 color; // 0x3A28
	struct { byte8 padding_2622[212]; } ;
	RecoveryData recoveryData[3]; // 0x3B00
	byte8 var_3C50[2]; // 0x3C50
	struct { byte8 padding_2625[382]; } ;
	byte8 * actionData[6]; // 0x3DD0
	ActorEventData eventData[2]; // 0x3E00
	uint8 var_3E10[32]; // 0x3E10
	struct { byte8 padding_2629[4]; } ;
	float motionTimer; // 0x3E34
	float idleTimer; // 0x3E38
	struct { byte8 padding_2632[36]; } ;
	byte32 permissions; // 0x3E60
	byte32 state; // 0x3E64
	byte32 lastState; // 0x3E68
	uint32 activeModelIndex; // 0x3E6C
	uint32 queuedModelIndex; // 0x3E70
	uint32 devilModels[3]; // 0x3E74
	uint8 modelState; // 0x3E80
	struct { byte8 padding_2640[3]; } ;
	bool32 lockOn; // 0x3E84
	uint32 activeModelIndexMirror; // 0x3E88
	uint32 activeDevil; // 0x3E8C
	uint32 airRaid; // 0x3E90
	uint32 mode; // 0x3E94
	struct { byte8 padding_2646[1]; } ;
	bool dead; // 0x3E99
	struct { byte8 padding_2648[1]; } ;
	bool devil; // 0x3E9B
	struct { byte8 padding_2650[2]; } ;
	uint8 costume; // 0x3E9E
	union
	{
		bool sparda; // 0x3E9F
		bool neroAngelo; // 0x3E9F
	};
	struct { byte8 padding_2657[4]; } ;
	bool useHolyWater; // 0x3EA4
	struct { byte8 padding_2659[19]; } ;
	float magicPoints; // 0x3EB8
	float maxMagicPoints; // 0x3EBC
	struct { byte8 padding_2662[4]; } ;
	float var_3EC4; // 0x3EC4
	float var_3EC8; // 0x3EC8
	struct { byte8 padding_2665[6]; } ;
	uint16 var_3ED2; // 0x3ED2
	struct { byte8 padding_2667[4]; } ;
	uint16 cameraDirection; // 0x3ED8
	struct { byte8 padding_2669[2]; } ;
	float var_3EDC; // 0x3EDC
	struct { byte8 padding_2671[49]; } ;
	uint8 airHikeCount; // 0x3F11
	uint8 kickJumpCount; // 0x3F12
	uint8 wallHikeCount; // 0x3F13
	bool enableAirRaid; // 0x3F14
	struct { byte8 padding_2676[4]; } ;
	bool var_3F19; // 0x3F19
	struct { byte8 padding_2678[138]; } ;
	uint8 action; // 0x3FA4
	uint8 lastAction; // 0x3FA5
	struct { byte8 padding_2681[2]; } ;
	uint8 bufferedAction; // 0x3FA8
	struct { byte8 padding_2683[3]; } ;
	uint8 chainCount; // 0x3FAC
	struct { byte8 padding_2685[63]; } ;
	byte32 expertise[16]; // 0x3FEC
	struct { byte8 padding_2687[192]; } ;
	float maxHitPoints; // 0x40EC
	struct { byte8 padding_2689[44]; } ;
	float hitPoints; // 0x411C
	struct { byte8 padding_2691[8712]; } ;
	byte8 * targetBaseAddr; // 0x6328
	struct { byte8 padding_2693[8]; } ;
	uint32 style; // 0x6338
	uint32 wallHikeDirection; // 0x633C
	uint32 var_6340; // 0x6340
	struct { byte8 padding_2697[20]; } ;
	uint32 styleLevel; // 0x6358
	uint8 dashCount; // 0x635C
	uint8 skyStarCount; // 0x635D
	uint8 airTrickCount; // 0x635E
	uint8 trickUpCount; // 0x635F
	uint8 trickDownCount; // 0x6360
	bool quicksilver; // 0x6361
	bool doppelganger; // 0x6362
	struct { byte8 padding_2706[1]; } ;
	float styleExperience; // 0x6364
	struct { byte8 padding_2708[108]; } ;
	uint32 speedMode; // 0x63D4
	struct { byte8 padding_2710[56]; } ;
	byte8 var_6410[40]; // 0x6410
	byte8 * var_6438; // 0x6438
	uint32 var_6440; // 0x6440
	struct { byte8 padding_2714[12]; } ;
	uint32 cloneRate; // 0x6450
	uint32 cloneStatus; // 0x6454
	byte8 var_6458[32]; // 0x6458
	byte8 * cloneActorBaseAddr; // 0x6478
	bool cloneIsControlledByPlayer; // 0x6480
	struct { byte8 padding_2720[3]; } ;
	uint32 activeMeleeWeaponIndex; // 0x6484
	uint32 queuedMeleeWeaponIndex; // 0x6488
	struct { byte8 padding_2723[1]; } ;
	uint8 activeWeapon; // 0x648D
	struct { byte8 padding_2725[2]; } ;
	uint32 meleeWeaponIndex; // 0x6490
	uint32 rangedWeaponIndex; // 0x6494
	uint8 weapons[5]; // 0x6498
	struct { byte8 padding_2729[3]; } ;
	WeaponData * weaponDataAddr[5]; // 0x64A0
	uint32 weaponStatus[5]; // 0x64C8
	uint32 weaponLevels[5]; // 0x64DC
	uint8 activeMeleeWeapon; // 0x64F0
	uint8 activeRangedWeapon; // 0x64F1
	struct { byte8 padding_2735[2]; } ;
	float weaponTimers[5]; // 0x64F4
	float meleeWeaponSwitchTimeout; // 0x6508
	float rangedWeaponSwitchTimeout; // 0x650C
	StyleData styleData; // 0x6510
	float var_6670; // 0x6670
	InputData inputData[58]; // 0x6674
	struct { byte8 padding_2742[36]; } ;
	BodyPartData bodyPartData[3][2]; // 0x6950
	struct { byte8 padding_2744[576]; } ;
	CollisionData collisionData; // 0x7250
	byte16 buttons[4]; // 0x74E0
	struct { byte8 padding_2747[16]; } ;
	uint16 rightStickPosition; // 0x74F8
	uint16 rightStickRadius; // 0x74FA
	struct { byte8 padding_2750[12]; } ;
	uint16 leftStickPosition; // 0x7508
	uint16 leftStickRadius; // 0x750A
	uint16 actorCameraDirection; // 0x750C
	struct { byte8 padding_2754[14]; } ;
	uint32 leftStickDirection[2]; // 0x751C
	struct { byte8 padding_2756[28]; } ;
	ModelData submodelData[5]; // 0x7540
	bool submodelInit[5]; // 0x9AC0
	struct { byte8 padding_2759[7675]; } ;
	uint32 newFirstVar; // 0xB8C0
	struct { byte8 padding_2761[12]; } ;
	ModelData newModelData[6]; // 0xB8D0
	PhysicsMetadata * newModelPhysicsMetadataPool[7][24]; // 0xE5D0
	Size_32 newModelAllocationData[512]; // 0xEB10
	RecoveryData newRecoveryData[6]; // 0x12B10
	uint32 newDevilModels[6]; // 0x12DB0
	struct { byte8 padding_2767[8]; } ;
	BodyPartData newBodyPartData[7][2]; // 0x12DD0
	ModelData newSubmodelData[11]; // 0x13D90
	bool newSubmodelInit[11]; // 0x19010
	struct { byte8 padding_2771[5]; } ;
	ShadowData newModelShadowData[6]; // 0x19020
	ShadowData newSubmodelShadowData[11]; // 0x194A0
	PhysicsMetadata * newDevilModelPhysicsMetadataPool[5][36]; // 0x19CE0
	PhysicsData newDevilSubmodelPhysicsData[10]; // 0x1A280
	PhysicsLinkData newDevilSubmodelPhysicsLinkData[10][4]; // 0x1ABE0
	uint8 newWeapons[10]; // 0x1C9E0
	struct { byte8 padding_2778[6]; } ;
	WeaponData * newWeaponDataAddr[10]; // 0x1C9F0
	uint32 newWeaponStatus[10]; // 0x1CA40
	struct { byte8 padding_2781[8]; } ;
	uint32 newWeaponLevels[10]; // 0x1CA70
	struct { byte8 padding_2783[8]; } ;
	float newWeaponTimers[10]; // 0x1CAA0
	bool32 newIsClone; // 0x1CAC8
	uint8 newPlayerIndex; // 0x1CACC
	uint8 newCharacterIndex; // 0x1CACD
	uint8 newEntityIndex; // 0x1CACE
	bool newForceFiles; // 0x1CACF
	uint8 newForceFilesCharacter; // 0x1CAD0
	bool newEnableVisibility; // 0x1CAD1
	uint8 newGamepad; // 0x1CAD2
	byte16 newButtonMask; // 0x1CAD3
	bool newEnableRightStick; // 0x1CAD5
	bool newEnableLeftStick; // 0x1CAD6
	bool newExecuteStyleSwitch; // 0x1CAD7
	bool newExecuteRemoveBusyFlag; // 0x1CAD8
	uint8 newAirStingerCount; // 0x1CAD9
	bool newEnableCollision; // 0x1CADA
	bool newActorLoopRun; // 0x1CADB
	uint8 newAirHikeCount; // 0x1CADC
	uint8 newKickJumpCount; // 0x1CADD
	uint8 newWallHikeCount; // 0x1CADE
	uint8 newDashCount; // 0x1CADF
	uint8 newSkyStarCount; // 0x1CAE0
	uint8 newAirTrickCount; // 0x1CAE1
	uint8 newTrickUpCount; // 0x1CAE2
	uint8 newTrickDownCount; // 0x1CAE3
	struct { byte8 padding_2809[12]; } ;
	uint32 newEffectIndices[12]; // 0x1CAF0
	uint32 newLastVar; // 0x1CB20

	operator byte8 *()
	{
		return reinterpret_cast<byte8 *>(this);
	}
};

struct ActorDataVergil
{
	struct { byte8 padding_2821[8]; } ;
	uint8 status; // 8
	struct { byte8 padding_2823[11]; } ;
	float speed; // 0x14
	float speedMultiplier; // 0x18
	struct { byte8 padding_2826[92]; } ;
	uint32 character; // 0x78
	struct { byte8 padding_2828[4]; } ;
	vec4 position; // 0x80
	struct { byte8 padding_2830[4]; } ;
	float pull; // 0x94
	struct { byte8 padding_2832[12]; } ;
	float pullMultiplier; // 0xA4
	struct { byte8 padding_2834[24]; } ;
	uint16 rotation; // 0xC0
	struct { byte8 padding_2836[86]; } ;
	uint8 id; // 0x118
	struct { byte8 padding_2838[3]; } ;
	bool32 isClone; // 0x11C
	uint32 visibility; // 0x120
	struct { byte8 padding_2841[156]; } ;
	float var_1C0; // 0x1C0
	float var_1C4; // 0x1C4
	struct { byte8 padding_2844[56]; } ;
	ModelData modelData[3]; // 0x200
	PhysicsMetadata * modelPhysicsMetadataPool[4][24]; // 0x1880
	uint32 modelAllocationDataCount; // 0x1B80
	struct { byte8 padding_2848[4]; } ;
	Size_32 modelAllocationData[209]; // 0x1B88
	struct { byte8 padding_2850[748]; } ;
	float motionSpeed; // 0x3894
	float motionSpeedMultiplier; // 0x3898
	struct { byte8 padding_2853[4]; } ;
	byte8 * motionArchives[34]; // 0x38A0
	MotionData motionData[2]; // 0x39B0
	MotionData motionDataMirror[3]; // 0x39B4
	struct { byte8 padding_2857[2]; } ;
	uint32 var_39BC; // 0x39BC
	uint8 var_39C0[16]; // 0x39C0
	uint32 nextActionRequestPolicy[16]; // 0x39D0
	uint8 var_3A10[8]; // 0x3A10
	uint32 shadow; // 0x3A18
	uint32 lastShadow; // 0x3A1C
	struct { byte8 padding_2864[8]; } ;
	byte32 color; // 0x3A28
	struct { byte8 padding_2866[212]; } ;
	RecoveryData recoveryData[3]; // 0x3B00
	byte8 var_3C50[2]; // 0x3C50
	struct { byte8 padding_2869[382]; } ;
	byte8 * actionData[6]; // 0x3DD0
	ActorEventData eventData[2]; // 0x3E00
	uint8 var_3E10[32]; // 0x3E10
	struct { byte8 padding_2873[4]; } ;
	float motionTimer; // 0x3E34
	float idleTimer; // 0x3E38
	struct { byte8 padding_2876[36]; } ;
	byte32 permissions; // 0x3E60
	byte32 state; // 0x3E64
	byte32 lastState; // 0x3E68
	uint32 activeModelIndex; // 0x3E6C
	uint32 queuedModelIndex; // 0x3E70
	uint32 devilModels[3]; // 0x3E74
	uint8 modelState; // 0x3E80
	struct { byte8 padding_2884[3]; } ;
	bool32 lockOn; // 0x3E84
	uint32 activeModelIndexMirror; // 0x3E88
	uint32 activeDevil; // 0x3E8C
	uint32 airRaid; // 0x3E90
	uint32 mode; // 0x3E94
	struct { byte8 padding_2890[1]; } ;
	bool dead; // 0x3E99
	struct { byte8 padding_2892[1]; } ;
	bool devil; // 0x3E9B
	struct { byte8 padding_2894[2]; } ;
	uint8 costume; // 0x3E9E
	union
	{
		bool sparda; // 0x3E9F
		bool neroAngelo; // 0x3E9F
	};
	struct { byte8 padding_2901[4]; } ;
	bool useHolyWater; // 0x3EA4
	struct { byte8 padding_2903[19]; } ;
	float magicPoints; // 0x3EB8
	float maxMagicPoints; // 0x3EBC
	struct { byte8 padding_2906[4]; } ;
	float var_3EC4; // 0x3EC4
	float var_3EC8; // 0x3EC8
	struct { byte8 padding_2909[6]; } ;
	uint16 var_3ED2; // 0x3ED2
	struct { byte8 padding_2911[4]; } ;
	uint16 cameraDirection; // 0x3ED8
	struct { byte8 padding_2913[2]; } ;
	float var_3EDC; // 0x3EDC
	struct { byte8 padding_2915[49]; } ;
	uint8 airHikeCount; // 0x3F11
	uint8 kickJumpCount; // 0x3F12
	uint8 wallHikeCount; // 0x3F13
	bool enableAirRaid; // 0x3F14
	struct { byte8 padding_2920[4]; } ;
	bool var_3F19; // 0x3F19
	struct { byte8 padding_2922[138]; } ;
	uint8 action; // 0x3FA4
	uint8 lastAction; // 0x3FA5
	struct { byte8 padding_2925[2]; } ;
	uint8 bufferedAction; // 0x3FA8
	struct { byte8 padding_2927[3]; } ;
	uint8 chainCount; // 0x3FAC
	struct { byte8 padding_2929[63]; } ;
	byte32 expertise[16]; // 0x3FEC
	struct { byte8 padding_2931[192]; } ;
	float maxHitPoints; // 0x40EC
	struct { byte8 padding_2933[44]; } ;
	float hitPoints; // 0x411C
	struct { byte8 padding_2935[8712]; } ;
	byte8 * targetBaseAddr; // 0x6328
	struct { byte8 padding_2937[8]; } ;
	uint32 style; // 0x6338
	uint32 wallHikeDirection; // 0x633C
	uint32 var_6340; // 0x6340
	struct { byte8 padding_2941[20]; } ;
	uint32 styleLevel; // 0x6358
	uint8 dashCount; // 0x635C
	uint8 skyStarCount; // 0x635D
	uint8 airTrickCount; // 0x635E
	uint8 trickUpCount; // 0x635F
	uint8 trickDownCount; // 0x6360
	bool quicksilver; // 0x6361
	bool doppelganger; // 0x6362
	struct { byte8 padding_2950[1]; } ;
	float styleExperience; // 0x6364
	struct { byte8 padding_2952[108]; } ;
	uint32 speedMode; // 0x63D4
	struct { byte8 padding_2954[56]; } ;
	byte8 var_6410[40]; // 0x6410
	byte8 * var_6438; // 0x6438
	uint32 var_6440; // 0x6440
	struct { byte8 padding_2958[12]; } ;
	uint32 cloneRate; // 0x6450
	uint32 cloneStatus; // 0x6454
	byte8 var_6458[32]; // 0x6458
	byte8 * cloneActorBaseAddr; // 0x6478
	bool cloneIsControlledByPlayer; // 0x6480
	struct { byte8 padding_2964[3]; } ;
	uint32 activeMeleeWeaponIndex; // 0x6484
	uint32 queuedMeleeWeaponIndex; // 0x6488
	struct { byte8 padding_2967[1]; } ;
	uint8 activeWeapon; // 0x648D
	struct { byte8 padding_2969[2]; } ;
	uint32 meleeWeaponIndex; // 0x6490
	uint32 rangedWeaponIndex; // 0x6494
	uint8 weapons[5]; // 0x6498
	struct { byte8 padding_2973[3]; } ;
	WeaponData * weaponDataAddr[5]; // 0x64A0
	uint32 weaponStatus[5]; // 0x64C8
	uint32 weaponLevels[5]; // 0x64DC
	uint8 activeMeleeWeapon; // 0x64F0
	uint8 activeRangedWeapon; // 0x64F1
	struct { byte8 padding_2979[2]; } ;
	float weaponTimers[5]; // 0x64F4
	float meleeWeaponSwitchTimeout; // 0x6508
	float rangedWeaponSwitchTimeout; // 0x650C
	StyleData styleData; // 0x6510
	float var_6670; // 0x6670
	InputData inputData[58]; // 0x6674
	struct { byte8 padding_2986[36]; } ;
	BodyPartData bodyPartData[3][2]; // 0x6950
	struct { byte8 padding_2988[576]; } ;
	CollisionData collisionData; // 0x7250
	byte16 buttons[4]; // 0x74E0
	struct { byte8 padding_2991[16]; } ;
	uint16 rightStickPosition; // 0x74F8
	uint16 rightStickRadius; // 0x74FA
	struct { byte8 padding_2994[12]; } ;
	uint16 leftStickPosition; // 0x7508
	uint16 leftStickRadius; // 0x750A
	uint16 actorCameraDirection; // 0x750C
	struct { byte8 padding_2998[14]; } ;
	uint32 leftStickDirection[2]; // 0x751C
	struct { byte8 padding_3000[28]; } ;
	ModelData submodelData[5]; // 0x7540
	bool submodelInit[5]; // 0x9AC0
	struct { byte8 padding_3003[43]; } ;
	ShadowData modelShadowData[3]; // 0x9AF0
	ShadowData submodelShadowData[5]; // 0x9D30
	PhysicsMetadata * submodelPhysicsMetadataPool[39]; // 0xA0F0
	struct { byte8 padding_3007[8]; } ;
	PhysicsData submodelPhysicsData; // 0xA230
	struct { byte8 padding_3009[4896]; } ;
	ModelMetadata modelMetadata[6]; // 0xB640
	struct { byte8 padding_3011[160]; } ;
	uint32 newFirstVar; // 0xB8C0
	struct { byte8 padding_3013[12]; } ;
	ModelData newModelData[6]; // 0xB8D0
	PhysicsMetadata * newModelPhysicsMetadataPool[7][24]; // 0xE5D0
	Size_32 newModelAllocationData[512]; // 0xEB10
	RecoveryData newRecoveryData[6]; // 0x12B10
	uint32 newDevilModels[6]; // 0x12DB0
	struct { byte8 padding_3019[8]; } ;
	BodyPartData newBodyPartData[7][2]; // 0x12DD0
	ModelData newSubmodelData[11]; // 0x13D90
	bool newSubmodelInit[11]; // 0x19010
	struct { byte8 padding_3023[5]; } ;
	ShadowData newModelShadowData[6]; // 0x19020
	ShadowData newSubmodelShadowData[11]; // 0x194A0
	PhysicsMetadata * newDevilModelPhysicsMetadataPool[5][36]; // 0x19CE0
	PhysicsData newDevilSubmodelPhysicsData[10]; // 0x1A280
	PhysicsLinkData newDevilSubmodelPhysicsLinkData[10][4]; // 0x1ABE0
	uint8 newWeapons[10]; // 0x1C9E0
	struct { byte8 padding_3030[6]; } ;
	WeaponData * newWeaponDataAddr[10]; // 0x1C9F0
	uint32 newWeaponStatus[10]; // 0x1CA40
	struct { byte8 padding_3033[8]; } ;
	uint32 newWeaponLevels[10]; // 0x1CA70
	struct { byte8 padding_3035[8]; } ;
	float newWeaponTimers[10]; // 0x1CAA0
	bool32 newIsClone; // 0x1CAC8
	uint8 newPlayerIndex; // 0x1CACC
	uint8 newCharacterIndex; // 0x1CACD
	uint8 newEntityIndex; // 0x1CACE
	bool newForceFiles; // 0x1CACF
	uint8 newForceFilesCharacter; // 0x1CAD0
	bool newEnableVisibility; // 0x1CAD1
	uint8 newGamepad; // 0x1CAD2
	byte16 newButtonMask; // 0x1CAD3
	bool newEnableRightStick; // 0x1CAD5
	bool newEnableLeftStick; // 0x1CAD6
	bool newExecuteStyleSwitch; // 0x1CAD7
	bool newExecuteRemoveBusyFlag; // 0x1CAD8
	uint8 newAirStingerCount; // 0x1CAD9
	bool newEnableCollision; // 0x1CADA
	bool newActorLoopRun; // 0x1CADB
	uint8 newAirHikeCount; // 0x1CADC
	uint8 newKickJumpCount; // 0x1CADD
	uint8 newWallHikeCount; // 0x1CADE
	uint8 newDashCount; // 0x1CADF
	uint8 newSkyStarCount; // 0x1CAE0
	uint8 newAirTrickCount; // 0x1CAE1
	uint8 newTrickUpCount; // 0x1CAE2
	uint8 newTrickDownCount; // 0x1CAE3
	struct { byte8 padding_3061[12]; } ;
	uint32 newEffectIndices[12]; // 0x1CAF0
	uint32 newLastVar; // 0x1CB20

	operator byte8 *()
	{
		return reinterpret_cast<byte8 *>(this);
	}
};

static_assert(__builtin_offsetof(ActorData, status) == 8);
static_assert(__builtin_offsetof(ActorData, speed) == 0x14);
static_assert(__builtin_offsetof(ActorData, speedMultiplier) == 0x18);
static_assert(__builtin_offsetof(ActorData, character) == 0x78);
static_assert(__builtin_offsetof(ActorData, position) == 0x80);
static_assert(__builtin_offsetof(ActorData, pull) == 0x94);
static_assert(__builtin_offsetof(ActorData, pullMultiplier) == 0xA4);
static_assert(__builtin_offsetof(ActorData, rotation) == 0xC0);
static_assert(__builtin_offsetof(ActorData, id) == 0x118);
static_assert(__builtin_offsetof(ActorData, isClone) == 0x11C);
static_assert(__builtin_offsetof(ActorData, visibility) == 0x120);
static_assert(__builtin_offsetof(ActorData, var_1C0) == 0x1C0);
static_assert(__builtin_offsetof(ActorData, var_1C4) == 0x1C4);
static_assert(__builtin_offsetof(ActorData, modelData) == 0x200);
static_assert(__builtin_offsetof(ActorData, modelPhysicsMetadataPool) == 0x1880);
static_assert(__builtin_offsetof(ActorData, modelAllocationDataCount) == 0x1B80);
static_assert(__builtin_offsetof(ActorData, modelAllocationData) == 0x1B88);
static_assert(__builtin_offsetof(ActorData, motionSpeed) == 0x3894);
static_assert(__builtin_offsetof(ActorData, motionSpeedMultiplier) == 0x3898);
static_assert(__builtin_offsetof(ActorData, motionArchives) == 0x38A0);
static_assert(__builtin_offsetof(ActorData, motionData) == 0x39B0);
static_assert(__builtin_offsetof(ActorData, motionDataMirror) == 0x39B4);
static_assert(__builtin_offsetof(ActorData, var_39BC) == 0x39BC);
static_assert(__builtin_offsetof(ActorData, var_39C0) == 0x39C0);
static_assert(__builtin_offsetof(ActorData, nextActionRequestPolicy) == 0x39D0);
static_assert(__builtin_offsetof(ActorData, var_3A10) == 0x3A10);
static_assert(__builtin_offsetof(ActorData, shadow) == 0x3A18);
static_assert(__builtin_offsetof(ActorData, lastShadow) == 0x3A1C);
static_assert(__builtin_offsetof(ActorData, color) == 0x3A28);
static_assert(__builtin_offsetof(ActorData, recoveryData) == 0x3B00);
static_assert(__builtin_offsetof(ActorData, var_3C50) == 0x3C50);
static_assert(__builtin_offsetof(ActorData, actionData) == 0x3DD0);
static_assert(__builtin_offsetof(ActorData, eventData) == 0x3E00);
static_assert(__builtin_offsetof(ActorData, var_3E10) == 0x3E10);
static_assert(__builtin_offsetof(ActorData, motionTimer) == 0x3E34);
static_assert(__builtin_offsetof(ActorData, idleTimer) == 0x3E38);
static_assert(__builtin_offsetof(ActorData, permissions) == 0x3E60);
static_assert(__builtin_offsetof(ActorData, state) == 0x3E64);
static_assert(__builtin_offsetof(ActorData, lastState) == 0x3E68);
static_assert(__builtin_offsetof(ActorData, activeModelIndex) == 0x3E6C);
static_assert(__builtin_offsetof(ActorData, queuedModelIndex) == 0x3E70);
static_assert(__builtin_offsetof(ActorData, devilModels) == 0x3E74);
static_assert(__builtin_offsetof(ActorData, modelState) == 0x3E80);
static_assert(__builtin_offsetof(ActorData, lockOn) == 0x3E84);
static_assert(__builtin_offsetof(ActorData, activeModelIndexMirror) == 0x3E88);
static_assert(__builtin_offsetof(ActorData, activeDevil) == 0x3E8C);
static_assert(__builtin_offsetof(ActorData, airRaid) == 0x3E90);
static_assert(__builtin_offsetof(ActorData, mode) == 0x3E94);
static_assert(__builtin_offsetof(ActorData, dead) == 0x3E99);
static_assert(__builtin_offsetof(ActorData, devil) == 0x3E9B);
static_assert(__builtin_offsetof(ActorData, costume) == 0x3E9E);
static_assert(__builtin_offsetof(ActorData, sparda) == 0x3E9F);
static_assert(__builtin_offsetof(ActorData, neroAngelo) == 0x3E9F);
static_assert(__builtin_offsetof(ActorData, useHolyWater) == 0x3EA4);
static_assert(__builtin_offsetof(ActorData, magicPoints) == 0x3EB8);
static_assert(__builtin_offsetof(ActorData, maxMagicPoints) == 0x3EBC);
static_assert(__builtin_offsetof(ActorData, var_3EC4) == 0x3EC4);
static_assert(__builtin_offsetof(ActorData, var_3EC8) == 0x3EC8);
static_assert(__builtin_offsetof(ActorData, var_3ED2) == 0x3ED2);
static_assert(__builtin_offsetof(ActorData, cameraDirection) == 0x3ED8);
static_assert(__builtin_offsetof(ActorData, var_3EDC) == 0x3EDC);
static_assert(__builtin_offsetof(ActorData, airHikeCount) == 0x3F11);
static_assert(__builtin_offsetof(ActorData, kickJumpCount) == 0x3F12);
static_assert(__builtin_offsetof(ActorData, wallHikeCount) == 0x3F13);
static_assert(__builtin_offsetof(ActorData, enableAirRaid) == 0x3F14);
static_assert(__builtin_offsetof(ActorData, var_3F19) == 0x3F19);
static_assert(__builtin_offsetof(ActorData, action) == 0x3FA4);
static_assert(__builtin_offsetof(ActorData, lastAction) == 0x3FA5);
static_assert(__builtin_offsetof(ActorData, bufferedAction) == 0x3FA8);
static_assert(__builtin_offsetof(ActorData, chainCount) == 0x3FAC);
static_assert(__builtin_offsetof(ActorData, expertise) == 0x3FEC);
static_assert(__builtin_offsetof(ActorData, maxHitPoints) == 0x40EC);
static_assert(__builtin_offsetof(ActorData, hitPoints) == 0x411C);
static_assert(__builtin_offsetof(ActorData, targetBaseAddr) == 0x6328);
static_assert(__builtin_offsetof(ActorData, style) == 0x6338);
static_assert(__builtin_offsetof(ActorData, wallHikeDirection) == 0x633C);
static_assert(__builtin_offsetof(ActorData, var_6340) == 0x6340);
static_assert(__builtin_offsetof(ActorData, styleLevel) == 0x6358);
static_assert(__builtin_offsetof(ActorData, dashCount) == 0x635C);
static_assert(__builtin_offsetof(ActorData, skyStarCount) == 0x635D);
static_assert(__builtin_offsetof(ActorData, airTrickCount) == 0x635E);
static_assert(__builtin_offsetof(ActorData, trickUpCount) == 0x635F);
static_assert(__builtin_offsetof(ActorData, trickDownCount) == 0x6360);
static_assert(__builtin_offsetof(ActorData, quicksilver) == 0x6361);
static_assert(__builtin_offsetof(ActorData, doppelganger) == 0x6362);
static_assert(__builtin_offsetof(ActorData, styleExperience) == 0x6364);
static_assert(__builtin_offsetof(ActorData, speedMode) == 0x63D4);
static_assert(__builtin_offsetof(ActorData, var_6410) == 0x6410);
static_assert(__builtin_offsetof(ActorData, var_6438) == 0x6438);
static_assert(__builtin_offsetof(ActorData, var_6440) == 0x6440);
static_assert(__builtin_offsetof(ActorData, cloneRate) == 0x6450);
static_assert(__builtin_offsetof(ActorData, cloneStatus) == 0x6454);
static_assert(__builtin_offsetof(ActorData, var_6458) == 0x6458);
static_assert(__builtin_offsetof(ActorData, cloneActorBaseAddr) == 0x6478);
static_assert(__builtin_offsetof(ActorData, cloneIsControlledByPlayer) == 0x6480);
static_assert(__builtin_offsetof(ActorData, activeMeleeWeaponIndex) == 0x6484);
static_assert(__builtin_offsetof(ActorData, queuedMeleeWeaponIndex) == 0x6488);
static_assert(__builtin_offsetof(ActorData, activeWeapon) == 0x648D);
static_assert(__builtin_offsetof(ActorData, meleeWeaponIndex) == 0x6490);
static_assert(__builtin_offsetof(ActorData, rangedWeaponIndex) == 0x6494);
static_assert(__builtin_offsetof(ActorData, weapons) == 0x6498);
static_assert(__builtin_offsetof(ActorData, weaponDataAddr) == 0x64A0);
static_assert(__builtin_offsetof(ActorData, weaponStatus) == 0x64C8);
static_assert(__builtin_offsetof(ActorData, weaponLevels) == 0x64DC);
static_assert(__builtin_offsetof(ActorData, activeMeleeWeapon) == 0x64F0);
static_assert(__builtin_offsetof(ActorData, activeRangedWeapon) == 0x64F1);
static_assert(__builtin_offsetof(ActorData, weaponTimers) == 0x64F4);
static_assert(__builtin_offsetof(ActorData, meleeWeaponSwitchTimeout) == 0x6508);
static_assert(__builtin_offsetof(ActorData, rangedWeaponSwitchTimeout) == 0x650C);
static_assert(__builtin_offsetof(ActorData, styleData) == 0x6510);
static_assert(__builtin_offsetof(ActorData, var_6670) == 0x6670);
static_assert(__builtin_offsetof(ActorData, inputData) == 0x6674);
static_assert(__builtin_offsetof(ActorData, bodyPartData) == 0x6950);
static_assert(__builtin_offsetof(ActorData, collisionData) == 0x7250);
static_assert(__builtin_offsetof(ActorData, buttons) == 0x74E0);
static_assert(__builtin_offsetof(ActorData, rightStickPosition) == 0x74F8);
static_assert(__builtin_offsetof(ActorData, rightStickRadius) == 0x74FA);
static_assert(__builtin_offsetof(ActorData, leftStickPosition) == 0x7508);
static_assert(__builtin_offsetof(ActorData, leftStickRadius) == 0x750A);
static_assert(__builtin_offsetof(ActorData, actorCameraDirection) == 0x750C);
static_assert(__builtin_offsetof(ActorData, leftStickDirection) == 0x751C);
static_assert(__builtin_offsetof(ActorData, submodelData) == 0x7540);
static_assert(__builtin_offsetof(ActorData, submodelInit) == 0x9AC0);
static_assert(__builtin_offsetof(ActorData, newFirstVar) == 0xB8C0);
static_assert(__builtin_offsetof(ActorData, newModelData) == 0xB8D0);
static_assert(__builtin_offsetof(ActorData, newModelPhysicsMetadataPool) == 0xE5D0);
static_assert(__builtin_offsetof(ActorData, newModelAllocationData) == 0xEB10);
static_assert(__builtin_offsetof(ActorData, newRecoveryData) == 0x12B10);
static_assert(__builtin_offsetof(ActorData, newDevilModels) == 0x12DB0);
static_assert(__builtin_offsetof(ActorData, newBodyPartData) == 0x12DD0);
static_assert(__builtin_offsetof(ActorData, newSubmodelData) == 0x13D90);
static_assert(__builtin_offsetof(ActorData, newSubmodelInit) == 0x19010);
static_assert(__builtin_offsetof(ActorData, newModelShadowData) == 0x19020);
static_assert(__builtin_offsetof(ActorData, newSubmodelShadowData) == 0x194A0);
static_assert(__builtin_offsetof(ActorData, newDevilModelPhysicsMetadataPool) == 0x19CE0);
static_assert(__builtin_offsetof(ActorData, newDevilSubmodelPhysicsData) == 0x1A280);
static_assert(__builtin_offsetof(ActorData, newDevilSubmodelPhysicsLinkData) == 0x1ABE0);
static_assert(__builtin_offsetof(ActorData, newWeapons) == 0x1C9E0);
static_assert(__builtin_offsetof(ActorData, newWeaponDataAddr) == 0x1C9F0);
static_assert(__builtin_offsetof(ActorData, newWeaponStatus) == 0x1CA40);
static_assert(__builtin_offsetof(ActorData, newWeaponLevels) == 0x1CA70);
static_assert(__builtin_offsetof(ActorData, newWeaponTimers) == 0x1CAA0);
static_assert(__builtin_offsetof(ActorData, newIsClone) == 0x1CAC8);
static_assert(__builtin_offsetof(ActorData, newPlayerIndex) == 0x1CACC);
static_assert(__builtin_offsetof(ActorData, newCharacterIndex) == 0x1CACD);
static_assert(__builtin_offsetof(ActorData, newEntityIndex) == 0x1CACE);
static_assert(__builtin_offsetof(ActorData, newForceFiles) == 0x1CACF);
static_assert(__builtin_offsetof(ActorData, newForceFilesCharacter) == 0x1CAD0);
static_assert(__builtin_offsetof(ActorData, newEnableVisibility) == 0x1CAD1);
static_assert(__builtin_offsetof(ActorData, newGamepad) == 0x1CAD2);
static_assert(__builtin_offsetof(ActorData, newButtonMask) == 0x1CAD3);
static_assert(__builtin_offsetof(ActorData, newEnableRightStick) == 0x1CAD5);
static_assert(__builtin_offsetof(ActorData, newEnableLeftStick) == 0x1CAD6);
static_assert(__builtin_offsetof(ActorData, newExecuteStyleSwitch) == 0x1CAD7);
static_assert(__builtin_offsetof(ActorData, newExecuteRemoveBusyFlag) == 0x1CAD8);
static_assert(__builtin_offsetof(ActorData, newAirStingerCount) == 0x1CAD9);
static_assert(__builtin_offsetof(ActorData, newEnableCollision) == 0x1CADA);
static_assert(__builtin_offsetof(ActorData, newActorLoopRun) == 0x1CADB);
static_assert(__builtin_offsetof(ActorData, newAirHikeCount) == 0x1CADC);
static_assert(__builtin_offsetof(ActorData, newKickJumpCount) == 0x1CADD);
static_assert(__builtin_offsetof(ActorData, newWallHikeCount) == 0x1CADE);
static_assert(__builtin_offsetof(ActorData, newDashCount) == 0x1CADF);
static_assert(__builtin_offsetof(ActorData, newSkyStarCount) == 0x1CAE0);
static_assert(__builtin_offsetof(ActorData, newAirTrickCount) == 0x1CAE1);
static_assert(__builtin_offsetof(ActorData, newTrickUpCount) == 0x1CAE2);
static_assert(__builtin_offsetof(ActorData, newTrickDownCount) == 0x1CAE3);
static_assert(__builtin_offsetof(ActorData, newEffectIndices) == 0x1CAF0);
static_assert(__builtin_offsetof(ActorData, newLastVar) == 0x1CB20);

static_assert(__builtin_offsetof(ActorDataDante, status) == 8);
static_assert(__builtin_offsetof(ActorDataDante, speed) == 0x14);
static_assert(__builtin_offsetof(ActorDataDante, speedMultiplier) == 0x18);
static_assert(__builtin_offsetof(ActorDataDante, character) == 0x78);
static_assert(__builtin_offsetof(ActorDataDante, position) == 0x80);
static_assert(__builtin_offsetof(ActorDataDante, pull) == 0x94);
static_assert(__builtin_offsetof(ActorDataDante, pullMultiplier) == 0xA4);
static_assert(__builtin_offsetof(ActorDataDante, rotation) == 0xC0);
static_assert(__builtin_offsetof(ActorDataDante, id) == 0x118);
static_assert(__builtin_offsetof(ActorDataDante, isClone) == 0x11C);
static_assert(__builtin_offsetof(ActorDataDante, visibility) == 0x120);
static_assert(__builtin_offsetof(ActorDataDante, var_1C0) == 0x1C0);
static_assert(__builtin_offsetof(ActorDataDante, var_1C4) == 0x1C4);
static_assert(__builtin_offsetof(ActorDataDante, modelData) == 0x200);
static_assert(__builtin_offsetof(ActorDataDante, modelPhysicsMetadataPool) == 0x1880);
static_assert(__builtin_offsetof(ActorDataDante, modelAllocationDataCount) == 0x1B80);
static_assert(__builtin_offsetof(ActorDataDante, modelAllocationData) == 0x1B88);
static_assert(__builtin_offsetof(ActorDataDante, motionSpeed) == 0x3894);
static_assert(__builtin_offsetof(ActorDataDante, motionSpeedMultiplier) == 0x3898);
static_assert(__builtin_offsetof(ActorDataDante, motionArchives) == 0x38A0);
static_assert(__builtin_offsetof(ActorDataDante, motionData) == 0x39B0);
static_assert(__builtin_offsetof(ActorDataDante, motionDataMirror) == 0x39B4);
static_assert(__builtin_offsetof(ActorDataDante, var_39BC) == 0x39BC);
static_assert(__builtin_offsetof(ActorDataDante, var_39C0) == 0x39C0);
static_assert(__builtin_offsetof(ActorDataDante, nextActionRequestPolicy) == 0x39D0);
static_assert(__builtin_offsetof(ActorDataDante, var_3A10) == 0x3A10);
static_assert(__builtin_offsetof(ActorDataDante, shadow) == 0x3A18);
static_assert(__builtin_offsetof(ActorDataDante, lastShadow) == 0x3A1C);
static_assert(__builtin_offsetof(ActorDataDante, color) == 0x3A28);
static_assert(__builtin_offsetof(ActorDataDante, recoveryData) == 0x3B00);
static_assert(__builtin_offsetof(ActorDataDante, var_3C50) == 0x3C50);
static_assert(__builtin_offsetof(ActorDataDante, actionData) == 0x3DD0);
static_assert(__builtin_offsetof(ActorDataDante, eventData) == 0x3E00);
static_assert(__builtin_offsetof(ActorDataDante, var_3E10) == 0x3E10);
static_assert(__builtin_offsetof(ActorDataDante, motionTimer) == 0x3E34);
static_assert(__builtin_offsetof(ActorDataDante, idleTimer) == 0x3E38);
static_assert(__builtin_offsetof(ActorDataDante, permissions) == 0x3E60);
static_assert(__builtin_offsetof(ActorDataDante, state) == 0x3E64);
static_assert(__builtin_offsetof(ActorDataDante, lastState) == 0x3E68);
static_assert(__builtin_offsetof(ActorDataDante, activeModelIndex) == 0x3E6C);
static_assert(__builtin_offsetof(ActorDataDante, queuedModelIndex) == 0x3E70);
static_assert(__builtin_offsetof(ActorDataDante, devilModels) == 0x3E74);
static_assert(__builtin_offsetof(ActorDataDante, modelState) == 0x3E80);
static_assert(__builtin_offsetof(ActorDataDante, lockOn) == 0x3E84);
static_assert(__builtin_offsetof(ActorDataDante, activeModelIndexMirror) == 0x3E88);
static_assert(__builtin_offsetof(ActorDataDante, activeDevil) == 0x3E8C);
static_assert(__builtin_offsetof(ActorDataDante, airRaid) == 0x3E90);
static_assert(__builtin_offsetof(ActorDataDante, mode) == 0x3E94);
static_assert(__builtin_offsetof(ActorDataDante, dead) == 0x3E99);
static_assert(__builtin_offsetof(ActorDataDante, devil) == 0x3E9B);
static_assert(__builtin_offsetof(ActorDataDante, costume) == 0x3E9E);
static_assert(__builtin_offsetof(ActorDataDante, sparda) == 0x3E9F);
static_assert(__builtin_offsetof(ActorDataDante, neroAngelo) == 0x3E9F);
static_assert(__builtin_offsetof(ActorDataDante, useHolyWater) == 0x3EA4);
static_assert(__builtin_offsetof(ActorDataDante, magicPoints) == 0x3EB8);
static_assert(__builtin_offsetof(ActorDataDante, maxMagicPoints) == 0x3EBC);
static_assert(__builtin_offsetof(ActorDataDante, var_3EC4) == 0x3EC4);
static_assert(__builtin_offsetof(ActorDataDante, var_3EC8) == 0x3EC8);
static_assert(__builtin_offsetof(ActorDataDante, var_3ED2) == 0x3ED2);
static_assert(__builtin_offsetof(ActorDataDante, cameraDirection) == 0x3ED8);
static_assert(__builtin_offsetof(ActorDataDante, var_3EDC) == 0x3EDC);
static_assert(__builtin_offsetof(ActorDataDante, airHikeCount) == 0x3F11);
static_assert(__builtin_offsetof(ActorDataDante, kickJumpCount) == 0x3F12);
static_assert(__builtin_offsetof(ActorDataDante, wallHikeCount) == 0x3F13);
static_assert(__builtin_offsetof(ActorDataDante, enableAirRaid) == 0x3F14);
static_assert(__builtin_offsetof(ActorDataDante, var_3F19) == 0x3F19);
static_assert(__builtin_offsetof(ActorDataDante, action) == 0x3FA4);
static_assert(__builtin_offsetof(ActorDataDante, lastAction) == 0x3FA5);
static_assert(__builtin_offsetof(ActorDataDante, bufferedAction) == 0x3FA8);
static_assert(__builtin_offsetof(ActorDataDante, chainCount) == 0x3FAC);
static_assert(__builtin_offsetof(ActorDataDante, expertise) == 0x3FEC);
static_assert(__builtin_offsetof(ActorDataDante, maxHitPoints) == 0x40EC);
static_assert(__builtin_offsetof(ActorDataDante, hitPoints) == 0x411C);
static_assert(__builtin_offsetof(ActorDataDante, targetBaseAddr) == 0x6328);
static_assert(__builtin_offsetof(ActorDataDante, style) == 0x6338);
static_assert(__builtin_offsetof(ActorDataDante, wallHikeDirection) == 0x633C);
static_assert(__builtin_offsetof(ActorDataDante, var_6340) == 0x6340);
static_assert(__builtin_offsetof(ActorDataDante, styleLevel) == 0x6358);
static_assert(__builtin_offsetof(ActorDataDante, dashCount) == 0x635C);
static_assert(__builtin_offsetof(ActorDataDante, skyStarCount) == 0x635D);
static_assert(__builtin_offsetof(ActorDataDante, airTrickCount) == 0x635E);
static_assert(__builtin_offsetof(ActorDataDante, trickUpCount) == 0x635F);
static_assert(__builtin_offsetof(ActorDataDante, trickDownCount) == 0x6360);
static_assert(__builtin_offsetof(ActorDataDante, quicksilver) == 0x6361);
static_assert(__builtin_offsetof(ActorDataDante, doppelganger) == 0x6362);
static_assert(__builtin_offsetof(ActorDataDante, styleExperience) == 0x6364);
static_assert(__builtin_offsetof(ActorDataDante, speedMode) == 0x63D4);
static_assert(__builtin_offsetof(ActorDataDante, var_6410) == 0x6410);
static_assert(__builtin_offsetof(ActorDataDante, var_6438) == 0x6438);
static_assert(__builtin_offsetof(ActorDataDante, var_6440) == 0x6440);
static_assert(__builtin_offsetof(ActorDataDante, cloneRate) == 0x6450);
static_assert(__builtin_offsetof(ActorDataDante, cloneStatus) == 0x6454);
static_assert(__builtin_offsetof(ActorDataDante, var_6458) == 0x6458);
static_assert(__builtin_offsetof(ActorDataDante, cloneActorBaseAddr) == 0x6478);
static_assert(__builtin_offsetof(ActorDataDante, cloneIsControlledByPlayer) == 0x6480);
static_assert(__builtin_offsetof(ActorDataDante, activeMeleeWeaponIndex) == 0x6484);
static_assert(__builtin_offsetof(ActorDataDante, queuedMeleeWeaponIndex) == 0x6488);
static_assert(__builtin_offsetof(ActorDataDante, activeWeapon) == 0x648D);
static_assert(__builtin_offsetof(ActorDataDante, meleeWeaponIndex) == 0x6490);
static_assert(__builtin_offsetof(ActorDataDante, rangedWeaponIndex) == 0x6494);
static_assert(__builtin_offsetof(ActorDataDante, weapons) == 0x6498);
static_assert(__builtin_offsetof(ActorDataDante, weaponDataAddr) == 0x64A0);
static_assert(__builtin_offsetof(ActorDataDante, weaponStatus) == 0x64C8);
static_assert(__builtin_offsetof(ActorDataDante, weaponLevels) == 0x64DC);
static_assert(__builtin_offsetof(ActorDataDante, activeMeleeWeapon) == 0x64F0);
static_assert(__builtin_offsetof(ActorDataDante, activeRangedWeapon) == 0x64F1);
static_assert(__builtin_offsetof(ActorDataDante, weaponTimers) == 0x64F4);
static_assert(__builtin_offsetof(ActorDataDante, meleeWeaponSwitchTimeout) == 0x6508);
static_assert(__builtin_offsetof(ActorDataDante, rangedWeaponSwitchTimeout) == 0x650C);
static_assert(__builtin_offsetof(ActorDataDante, styleData) == 0x6510);
static_assert(__builtin_offsetof(ActorDataDante, var_6670) == 0x6670);
static_assert(__builtin_offsetof(ActorDataDante, inputData) == 0x6674);
static_assert(__builtin_offsetof(ActorDataDante, bodyPartData) == 0x6950);
static_assert(__builtin_offsetof(ActorDataDante, collisionData) == 0x7250);
static_assert(__builtin_offsetof(ActorDataDante, buttons) == 0x74E0);
static_assert(__builtin_offsetof(ActorDataDante, rightStickPosition) == 0x74F8);
static_assert(__builtin_offsetof(ActorDataDante, rightStickRadius) == 0x74FA);
static_assert(__builtin_offsetof(ActorDataDante, leftStickPosition) == 0x7508);
static_assert(__builtin_offsetof(ActorDataDante, leftStickRadius) == 0x750A);
static_assert(__builtin_offsetof(ActorDataDante, actorCameraDirection) == 0x750C);
static_assert(__builtin_offsetof(ActorDataDante, leftStickDirection) == 0x751C);
static_assert(__builtin_offsetof(ActorDataDante, submodelData) == 0x7540);
static_assert(__builtin_offsetof(ActorDataDante, submodelInit) == 0x9AC0);
static_assert(__builtin_offsetof(ActorDataDante, modelShadowData) == 0x9AD0);
static_assert(__builtin_offsetof(ActorDataDante, submodelShadowData) == 0x9D10);
static_assert(__builtin_offsetof(ActorDataDante, submodelPhysicsMetadataPool) == 0xA0D0);
static_assert(__builtin_offsetof(ActorDataDante, submodelPhysicsData) == 0xA210);
static_assert(__builtin_offsetof(ActorDataDante, devilModelPhysicsMetadataPool) == 0xA300);
static_assert(__builtin_offsetof(ActorDataDante, devilSubmodelPhysicsData) == 0xA540);
static_assert(__builtin_offsetof(ActorDataDante, devilSubmodelPhysicsLinkData) == 0xAA00);
static_assert(__builtin_offsetof(ActorDataDante, devilModelMetadata) == 0xB600);
static_assert(__builtin_offsetof(ActorDataDante, modelMetadata) == 0xB630);
static_assert(__builtin_offsetof(ActorDataDante, artemisChargeValue) == 0xB868);
static_assert(__builtin_offsetof(ActorDataDante, artemisChargeFlags) == 0xB87C);
static_assert(__builtin_offsetof(ActorDataDante, newFirstVar) == 0xB8C0);
static_assert(__builtin_offsetof(ActorDataDante, newModelData) == 0xB8D0);
static_assert(__builtin_offsetof(ActorDataDante, newModelPhysicsMetadataPool) == 0xE5D0);
static_assert(__builtin_offsetof(ActorDataDante, newModelAllocationData) == 0xEB10);
static_assert(__builtin_offsetof(ActorDataDante, newRecoveryData) == 0x12B10);
static_assert(__builtin_offsetof(ActorDataDante, newDevilModels) == 0x12DB0);
static_assert(__builtin_offsetof(ActorDataDante, newBodyPartData) == 0x12DD0);
static_assert(__builtin_offsetof(ActorDataDante, newSubmodelData) == 0x13D90);
static_assert(__builtin_offsetof(ActorDataDante, newSubmodelInit) == 0x19010);
static_assert(__builtin_offsetof(ActorDataDante, newModelShadowData) == 0x19020);
static_assert(__builtin_offsetof(ActorDataDante, newSubmodelShadowData) == 0x194A0);
static_assert(__builtin_offsetof(ActorDataDante, newDevilModelPhysicsMetadataPool) == 0x19CE0);
static_assert(__builtin_offsetof(ActorDataDante, newDevilSubmodelPhysicsData) == 0x1A280);
static_assert(__builtin_offsetof(ActorDataDante, newDevilSubmodelPhysicsLinkData) == 0x1ABE0);
static_assert(__builtin_offsetof(ActorDataDante, newWeapons) == 0x1C9E0);
static_assert(__builtin_offsetof(ActorDataDante, newWeaponDataAddr) == 0x1C9F0);
static_assert(__builtin_offsetof(ActorDataDante, newWeaponStatus) == 0x1CA40);
static_assert(__builtin_offsetof(ActorDataDante, newWeaponLevels) == 0x1CA70);
static_assert(__builtin_offsetof(ActorDataDante, newWeaponTimers) == 0x1CAA0);
static_assert(__builtin_offsetof(ActorDataDante, newIsClone) == 0x1CAC8);
static_assert(__builtin_offsetof(ActorDataDante, newPlayerIndex) == 0x1CACC);
static_assert(__builtin_offsetof(ActorDataDante, newCharacterIndex) == 0x1CACD);
static_assert(__builtin_offsetof(ActorDataDante, newEntityIndex) == 0x1CACE);
static_assert(__builtin_offsetof(ActorDataDante, newForceFiles) == 0x1CACF);
static_assert(__builtin_offsetof(ActorDataDante, newForceFilesCharacter) == 0x1CAD0);
static_assert(__builtin_offsetof(ActorDataDante, newEnableVisibility) == 0x1CAD1);
static_assert(__builtin_offsetof(ActorDataDante, newGamepad) == 0x1CAD2);
static_assert(__builtin_offsetof(ActorDataDante, newButtonMask) == 0x1CAD3);
static_assert(__builtin_offsetof(ActorDataDante, newEnableRightStick) == 0x1CAD5);
static_assert(__builtin_offsetof(ActorDataDante, newEnableLeftStick) == 0x1CAD6);
static_assert(__builtin_offsetof(ActorDataDante, newExecuteStyleSwitch) == 0x1CAD7);
static_assert(__builtin_offsetof(ActorDataDante, newExecuteRemoveBusyFlag) == 0x1CAD8);
static_assert(__builtin_offsetof(ActorDataDante, newAirStingerCount) == 0x1CAD9);
static_assert(__builtin_offsetof(ActorDataDante, newEnableCollision) == 0x1CADA);
static_assert(__builtin_offsetof(ActorDataDante, newActorLoopRun) == 0x1CADB);
static_assert(__builtin_offsetof(ActorDataDante, newAirHikeCount) == 0x1CADC);
static_assert(__builtin_offsetof(ActorDataDante, newKickJumpCount) == 0x1CADD);
static_assert(__builtin_offsetof(ActorDataDante, newWallHikeCount) == 0x1CADE);
static_assert(__builtin_offsetof(ActorDataDante, newDashCount) == 0x1CADF);
static_assert(__builtin_offsetof(ActorDataDante, newSkyStarCount) == 0x1CAE0);
static_assert(__builtin_offsetof(ActorDataDante, newAirTrickCount) == 0x1CAE1);
static_assert(__builtin_offsetof(ActorDataDante, newTrickUpCount) == 0x1CAE2);
static_assert(__builtin_offsetof(ActorDataDante, newTrickDownCount) == 0x1CAE3);
static_assert(__builtin_offsetof(ActorDataDante, newEffectIndices) == 0x1CAF0);
static_assert(__builtin_offsetof(ActorDataDante, newLastVar) == 0x1CB20);

static_assert(__builtin_offsetof(ActorDataBob, status) == 8);
static_assert(__builtin_offsetof(ActorDataBob, speed) == 0x14);
static_assert(__builtin_offsetof(ActorDataBob, speedMultiplier) == 0x18);
static_assert(__builtin_offsetof(ActorDataBob, character) == 0x78);
static_assert(__builtin_offsetof(ActorDataBob, position) == 0x80);
static_assert(__builtin_offsetof(ActorDataBob, pull) == 0x94);
static_assert(__builtin_offsetof(ActorDataBob, pullMultiplier) == 0xA4);
static_assert(__builtin_offsetof(ActorDataBob, rotation) == 0xC0);
static_assert(__builtin_offsetof(ActorDataBob, id) == 0x118);
static_assert(__builtin_offsetof(ActorDataBob, isClone) == 0x11C);
static_assert(__builtin_offsetof(ActorDataBob, visibility) == 0x120);
static_assert(__builtin_offsetof(ActorDataBob, var_1C0) == 0x1C0);
static_assert(__builtin_offsetof(ActorDataBob, var_1C4) == 0x1C4);
static_assert(__builtin_offsetof(ActorDataBob, modelData) == 0x200);
static_assert(__builtin_offsetof(ActorDataBob, modelPhysicsMetadataPool) == 0x1880);
static_assert(__builtin_offsetof(ActorDataBob, modelAllocationDataCount) == 0x1B80);
static_assert(__builtin_offsetof(ActorDataBob, modelAllocationData) == 0x1B88);
static_assert(__builtin_offsetof(ActorDataBob, motionSpeed) == 0x3894);
static_assert(__builtin_offsetof(ActorDataBob, motionSpeedMultiplier) == 0x3898);
static_assert(__builtin_offsetof(ActorDataBob, motionArchives) == 0x38A0);
static_assert(__builtin_offsetof(ActorDataBob, motionData) == 0x39B0);
static_assert(__builtin_offsetof(ActorDataBob, motionDataMirror) == 0x39B4);
static_assert(__builtin_offsetof(ActorDataBob, var_39BC) == 0x39BC);
static_assert(__builtin_offsetof(ActorDataBob, var_39C0) == 0x39C0);
static_assert(__builtin_offsetof(ActorDataBob, nextActionRequestPolicy) == 0x39D0);
static_assert(__builtin_offsetof(ActorDataBob, var_3A10) == 0x3A10);
static_assert(__builtin_offsetof(ActorDataBob, shadow) == 0x3A18);
static_assert(__builtin_offsetof(ActorDataBob, lastShadow) == 0x3A1C);
static_assert(__builtin_offsetof(ActorDataBob, color) == 0x3A28);
static_assert(__builtin_offsetof(ActorDataBob, recoveryData) == 0x3B00);
static_assert(__builtin_offsetof(ActorDataBob, var_3C50) == 0x3C50);
static_assert(__builtin_offsetof(ActorDataBob, actionData) == 0x3DD0);
static_assert(__builtin_offsetof(ActorDataBob, eventData) == 0x3E00);
static_assert(__builtin_offsetof(ActorDataBob, var_3E10) == 0x3E10);
static_assert(__builtin_offsetof(ActorDataBob, motionTimer) == 0x3E34);
static_assert(__builtin_offsetof(ActorDataBob, idleTimer) == 0x3E38);
static_assert(__builtin_offsetof(ActorDataBob, permissions) == 0x3E60);
static_assert(__builtin_offsetof(ActorDataBob, state) == 0x3E64);
static_assert(__builtin_offsetof(ActorDataBob, lastState) == 0x3E68);
static_assert(__builtin_offsetof(ActorDataBob, activeModelIndex) == 0x3E6C);
static_assert(__builtin_offsetof(ActorDataBob, queuedModelIndex) == 0x3E70);
static_assert(__builtin_offsetof(ActorDataBob, devilModels) == 0x3E74);
static_assert(__builtin_offsetof(ActorDataBob, modelState) == 0x3E80);
static_assert(__builtin_offsetof(ActorDataBob, lockOn) == 0x3E84);
static_assert(__builtin_offsetof(ActorDataBob, activeModelIndexMirror) == 0x3E88);
static_assert(__builtin_offsetof(ActorDataBob, activeDevil) == 0x3E8C);
static_assert(__builtin_offsetof(ActorDataBob, airRaid) == 0x3E90);
static_assert(__builtin_offsetof(ActorDataBob, mode) == 0x3E94);
static_assert(__builtin_offsetof(ActorDataBob, dead) == 0x3E99);
static_assert(__builtin_offsetof(ActorDataBob, devil) == 0x3E9B);
static_assert(__builtin_offsetof(ActorDataBob, costume) == 0x3E9E);
static_assert(__builtin_offsetof(ActorDataBob, sparda) == 0x3E9F);
static_assert(__builtin_offsetof(ActorDataBob, neroAngelo) == 0x3E9F);
static_assert(__builtin_offsetof(ActorDataBob, useHolyWater) == 0x3EA4);
static_assert(__builtin_offsetof(ActorDataBob, magicPoints) == 0x3EB8);
static_assert(__builtin_offsetof(ActorDataBob, maxMagicPoints) == 0x3EBC);
static_assert(__builtin_offsetof(ActorDataBob, var_3EC4) == 0x3EC4);
static_assert(__builtin_offsetof(ActorDataBob, var_3EC8) == 0x3EC8);
static_assert(__builtin_offsetof(ActorDataBob, var_3ED2) == 0x3ED2);
static_assert(__builtin_offsetof(ActorDataBob, cameraDirection) == 0x3ED8);
static_assert(__builtin_offsetof(ActorDataBob, var_3EDC) == 0x3EDC);
static_assert(__builtin_offsetof(ActorDataBob, airHikeCount) == 0x3F11);
static_assert(__builtin_offsetof(ActorDataBob, kickJumpCount) == 0x3F12);
static_assert(__builtin_offsetof(ActorDataBob, wallHikeCount) == 0x3F13);
static_assert(__builtin_offsetof(ActorDataBob, enableAirRaid) == 0x3F14);
static_assert(__builtin_offsetof(ActorDataBob, var_3F19) == 0x3F19);
static_assert(__builtin_offsetof(ActorDataBob, action) == 0x3FA4);
static_assert(__builtin_offsetof(ActorDataBob, lastAction) == 0x3FA5);
static_assert(__builtin_offsetof(ActorDataBob, bufferedAction) == 0x3FA8);
static_assert(__builtin_offsetof(ActorDataBob, chainCount) == 0x3FAC);
static_assert(__builtin_offsetof(ActorDataBob, expertise) == 0x3FEC);
static_assert(__builtin_offsetof(ActorDataBob, maxHitPoints) == 0x40EC);
static_assert(__builtin_offsetof(ActorDataBob, hitPoints) == 0x411C);
static_assert(__builtin_offsetof(ActorDataBob, targetBaseAddr) == 0x6328);
static_assert(__builtin_offsetof(ActorDataBob, style) == 0x6338);
static_assert(__builtin_offsetof(ActorDataBob, wallHikeDirection) == 0x633C);
static_assert(__builtin_offsetof(ActorDataBob, var_6340) == 0x6340);
static_assert(__builtin_offsetof(ActorDataBob, styleLevel) == 0x6358);
static_assert(__builtin_offsetof(ActorDataBob, dashCount) == 0x635C);
static_assert(__builtin_offsetof(ActorDataBob, skyStarCount) == 0x635D);
static_assert(__builtin_offsetof(ActorDataBob, airTrickCount) == 0x635E);
static_assert(__builtin_offsetof(ActorDataBob, trickUpCount) == 0x635F);
static_assert(__builtin_offsetof(ActorDataBob, trickDownCount) == 0x6360);
static_assert(__builtin_offsetof(ActorDataBob, quicksilver) == 0x6361);
static_assert(__builtin_offsetof(ActorDataBob, doppelganger) == 0x6362);
static_assert(__builtin_offsetof(ActorDataBob, styleExperience) == 0x6364);
static_assert(__builtin_offsetof(ActorDataBob, speedMode) == 0x63D4);
static_assert(__builtin_offsetof(ActorDataBob, var_6410) == 0x6410);
static_assert(__builtin_offsetof(ActorDataBob, var_6438) == 0x6438);
static_assert(__builtin_offsetof(ActorDataBob, var_6440) == 0x6440);
static_assert(__builtin_offsetof(ActorDataBob, cloneRate) == 0x6450);
static_assert(__builtin_offsetof(ActorDataBob, cloneStatus) == 0x6454);
static_assert(__builtin_offsetof(ActorDataBob, var_6458) == 0x6458);
static_assert(__builtin_offsetof(ActorDataBob, cloneActorBaseAddr) == 0x6478);
static_assert(__builtin_offsetof(ActorDataBob, cloneIsControlledByPlayer) == 0x6480);
static_assert(__builtin_offsetof(ActorDataBob, activeMeleeWeaponIndex) == 0x6484);
static_assert(__builtin_offsetof(ActorDataBob, queuedMeleeWeaponIndex) == 0x6488);
static_assert(__builtin_offsetof(ActorDataBob, activeWeapon) == 0x648D);
static_assert(__builtin_offsetof(ActorDataBob, meleeWeaponIndex) == 0x6490);
static_assert(__builtin_offsetof(ActorDataBob, rangedWeaponIndex) == 0x6494);
static_assert(__builtin_offsetof(ActorDataBob, weapons) == 0x6498);
static_assert(__builtin_offsetof(ActorDataBob, weaponDataAddr) == 0x64A0);
static_assert(__builtin_offsetof(ActorDataBob, weaponStatus) == 0x64C8);
static_assert(__builtin_offsetof(ActorDataBob, weaponLevels) == 0x64DC);
static_assert(__builtin_offsetof(ActorDataBob, activeMeleeWeapon) == 0x64F0);
static_assert(__builtin_offsetof(ActorDataBob, activeRangedWeapon) == 0x64F1);
static_assert(__builtin_offsetof(ActorDataBob, weaponTimers) == 0x64F4);
static_assert(__builtin_offsetof(ActorDataBob, meleeWeaponSwitchTimeout) == 0x6508);
static_assert(__builtin_offsetof(ActorDataBob, rangedWeaponSwitchTimeout) == 0x650C);
static_assert(__builtin_offsetof(ActorDataBob, styleData) == 0x6510);
static_assert(__builtin_offsetof(ActorDataBob, var_6670) == 0x6670);
static_assert(__builtin_offsetof(ActorDataBob, inputData) == 0x6674);
static_assert(__builtin_offsetof(ActorDataBob, bodyPartData) == 0x6950);
static_assert(__builtin_offsetof(ActorDataBob, collisionData) == 0x7250);
static_assert(__builtin_offsetof(ActorDataBob, buttons) == 0x74E0);
static_assert(__builtin_offsetof(ActorDataBob, rightStickPosition) == 0x74F8);
static_assert(__builtin_offsetof(ActorDataBob, rightStickRadius) == 0x74FA);
static_assert(__builtin_offsetof(ActorDataBob, leftStickPosition) == 0x7508);
static_assert(__builtin_offsetof(ActorDataBob, leftStickRadius) == 0x750A);
static_assert(__builtin_offsetof(ActorDataBob, actorCameraDirection) == 0x750C);
static_assert(__builtin_offsetof(ActorDataBob, leftStickDirection) == 0x751C);
static_assert(__builtin_offsetof(ActorDataBob, submodelData) == 0x7540);
static_assert(__builtin_offsetof(ActorDataBob, submodelInit) == 0x9AC0);
static_assert(__builtin_offsetof(ActorDataBob, newFirstVar) == 0xB8C0);
static_assert(__builtin_offsetof(ActorDataBob, newModelData) == 0xB8D0);
static_assert(__builtin_offsetof(ActorDataBob, newModelPhysicsMetadataPool) == 0xE5D0);
static_assert(__builtin_offsetof(ActorDataBob, newModelAllocationData) == 0xEB10);
static_assert(__builtin_offsetof(ActorDataBob, newRecoveryData) == 0x12B10);
static_assert(__builtin_offsetof(ActorDataBob, newDevilModels) == 0x12DB0);
static_assert(__builtin_offsetof(ActorDataBob, newBodyPartData) == 0x12DD0);
static_assert(__builtin_offsetof(ActorDataBob, newSubmodelData) == 0x13D90);
static_assert(__builtin_offsetof(ActorDataBob, newSubmodelInit) == 0x19010);
static_assert(__builtin_offsetof(ActorDataBob, newModelShadowData) == 0x19020);
static_assert(__builtin_offsetof(ActorDataBob, newSubmodelShadowData) == 0x194A0);
static_assert(__builtin_offsetof(ActorDataBob, newDevilModelPhysicsMetadataPool) == 0x19CE0);
static_assert(__builtin_offsetof(ActorDataBob, newDevilSubmodelPhysicsData) == 0x1A280);
static_assert(__builtin_offsetof(ActorDataBob, newDevilSubmodelPhysicsLinkData) == 0x1ABE0);
static_assert(__builtin_offsetof(ActorDataBob, newWeapons) == 0x1C9E0);
static_assert(__builtin_offsetof(ActorDataBob, newWeaponDataAddr) == 0x1C9F0);
static_assert(__builtin_offsetof(ActorDataBob, newWeaponStatus) == 0x1CA40);
static_assert(__builtin_offsetof(ActorDataBob, newWeaponLevels) == 0x1CA70);
static_assert(__builtin_offsetof(ActorDataBob, newWeaponTimers) == 0x1CAA0);
static_assert(__builtin_offsetof(ActorDataBob, newIsClone) == 0x1CAC8);
static_assert(__builtin_offsetof(ActorDataBob, newPlayerIndex) == 0x1CACC);
static_assert(__builtin_offsetof(ActorDataBob, newCharacterIndex) == 0x1CACD);
static_assert(__builtin_offsetof(ActorDataBob, newEntityIndex) == 0x1CACE);
static_assert(__builtin_offsetof(ActorDataBob, newForceFiles) == 0x1CACF);
static_assert(__builtin_offsetof(ActorDataBob, newForceFilesCharacter) == 0x1CAD0);
static_assert(__builtin_offsetof(ActorDataBob, newEnableVisibility) == 0x1CAD1);
static_assert(__builtin_offsetof(ActorDataBob, newGamepad) == 0x1CAD2);
static_assert(__builtin_offsetof(ActorDataBob, newButtonMask) == 0x1CAD3);
static_assert(__builtin_offsetof(ActorDataBob, newEnableRightStick) == 0x1CAD5);
static_assert(__builtin_offsetof(ActorDataBob, newEnableLeftStick) == 0x1CAD6);
static_assert(__builtin_offsetof(ActorDataBob, newExecuteStyleSwitch) == 0x1CAD7);
static_assert(__builtin_offsetof(ActorDataBob, newExecuteRemoveBusyFlag) == 0x1CAD8);
static_assert(__builtin_offsetof(ActorDataBob, newAirStingerCount) == 0x1CAD9);
static_assert(__builtin_offsetof(ActorDataBob, newEnableCollision) == 0x1CADA);
static_assert(__builtin_offsetof(ActorDataBob, newActorLoopRun) == 0x1CADB);
static_assert(__builtin_offsetof(ActorDataBob, newAirHikeCount) == 0x1CADC);
static_assert(__builtin_offsetof(ActorDataBob, newKickJumpCount) == 0x1CADD);
static_assert(__builtin_offsetof(ActorDataBob, newWallHikeCount) == 0x1CADE);
static_assert(__builtin_offsetof(ActorDataBob, newDashCount) == 0x1CADF);
static_assert(__builtin_offsetof(ActorDataBob, newSkyStarCount) == 0x1CAE0);
static_assert(__builtin_offsetof(ActorDataBob, newAirTrickCount) == 0x1CAE1);
static_assert(__builtin_offsetof(ActorDataBob, newTrickUpCount) == 0x1CAE2);
static_assert(__builtin_offsetof(ActorDataBob, newTrickDownCount) == 0x1CAE3);
static_assert(__builtin_offsetof(ActorDataBob, newEffectIndices) == 0x1CAF0);
static_assert(__builtin_offsetof(ActorDataBob, newLastVar) == 0x1CB20);

static_assert(__builtin_offsetof(ActorDataLady, status) == 8);
static_assert(__builtin_offsetof(ActorDataLady, speed) == 0x14);
static_assert(__builtin_offsetof(ActorDataLady, speedMultiplier) == 0x18);
static_assert(__builtin_offsetof(ActorDataLady, character) == 0x78);
static_assert(__builtin_offsetof(ActorDataLady, position) == 0x80);
static_assert(__builtin_offsetof(ActorDataLady, pull) == 0x94);
static_assert(__builtin_offsetof(ActorDataLady, pullMultiplier) == 0xA4);
static_assert(__builtin_offsetof(ActorDataLady, rotation) == 0xC0);
static_assert(__builtin_offsetof(ActorDataLady, id) == 0x118);
static_assert(__builtin_offsetof(ActorDataLady, isClone) == 0x11C);
static_assert(__builtin_offsetof(ActorDataLady, visibility) == 0x120);
static_assert(__builtin_offsetof(ActorDataLady, var_1C0) == 0x1C0);
static_assert(__builtin_offsetof(ActorDataLady, var_1C4) == 0x1C4);
static_assert(__builtin_offsetof(ActorDataLady, modelData) == 0x200);
static_assert(__builtin_offsetof(ActorDataLady, modelPhysicsMetadataPool) == 0x1880);
static_assert(__builtin_offsetof(ActorDataLady, modelAllocationDataCount) == 0x1B80);
static_assert(__builtin_offsetof(ActorDataLady, modelAllocationData) == 0x1B88);
static_assert(__builtin_offsetof(ActorDataLady, motionSpeed) == 0x3894);
static_assert(__builtin_offsetof(ActorDataLady, motionSpeedMultiplier) == 0x3898);
static_assert(__builtin_offsetof(ActorDataLady, motionArchives) == 0x38A0);
static_assert(__builtin_offsetof(ActorDataLady, motionData) == 0x39B0);
static_assert(__builtin_offsetof(ActorDataLady, motionDataMirror) == 0x39B4);
static_assert(__builtin_offsetof(ActorDataLady, var_39BC) == 0x39BC);
static_assert(__builtin_offsetof(ActorDataLady, var_39C0) == 0x39C0);
static_assert(__builtin_offsetof(ActorDataLady, nextActionRequestPolicy) == 0x39D0);
static_assert(__builtin_offsetof(ActorDataLady, var_3A10) == 0x3A10);
static_assert(__builtin_offsetof(ActorDataLady, shadow) == 0x3A18);
static_assert(__builtin_offsetof(ActorDataLady, lastShadow) == 0x3A1C);
static_assert(__builtin_offsetof(ActorDataLady, color) == 0x3A28);
static_assert(__builtin_offsetof(ActorDataLady, recoveryData) == 0x3B00);
static_assert(__builtin_offsetof(ActorDataLady, var_3C50) == 0x3C50);
static_assert(__builtin_offsetof(ActorDataLady, actionData) == 0x3DD0);
static_assert(__builtin_offsetof(ActorDataLady, eventData) == 0x3E00);
static_assert(__builtin_offsetof(ActorDataLady, var_3E10) == 0x3E10);
static_assert(__builtin_offsetof(ActorDataLady, motionTimer) == 0x3E34);
static_assert(__builtin_offsetof(ActorDataLady, idleTimer) == 0x3E38);
static_assert(__builtin_offsetof(ActorDataLady, permissions) == 0x3E60);
static_assert(__builtin_offsetof(ActorDataLady, state) == 0x3E64);
static_assert(__builtin_offsetof(ActorDataLady, lastState) == 0x3E68);
static_assert(__builtin_offsetof(ActorDataLady, activeModelIndex) == 0x3E6C);
static_assert(__builtin_offsetof(ActorDataLady, queuedModelIndex) == 0x3E70);
static_assert(__builtin_offsetof(ActorDataLady, devilModels) == 0x3E74);
static_assert(__builtin_offsetof(ActorDataLady, modelState) == 0x3E80);
static_assert(__builtin_offsetof(ActorDataLady, lockOn) == 0x3E84);
static_assert(__builtin_offsetof(ActorDataLady, activeModelIndexMirror) == 0x3E88);
static_assert(__builtin_offsetof(ActorDataLady, activeDevil) == 0x3E8C);
static_assert(__builtin_offsetof(ActorDataLady, airRaid) == 0x3E90);
static_assert(__builtin_offsetof(ActorDataLady, mode) == 0x3E94);
static_assert(__builtin_offsetof(ActorDataLady, dead) == 0x3E99);
static_assert(__builtin_offsetof(ActorDataLady, devil) == 0x3E9B);
static_assert(__builtin_offsetof(ActorDataLady, costume) == 0x3E9E);
static_assert(__builtin_offsetof(ActorDataLady, sparda) == 0x3E9F);
static_assert(__builtin_offsetof(ActorDataLady, neroAngelo) == 0x3E9F);
static_assert(__builtin_offsetof(ActorDataLady, useHolyWater) == 0x3EA4);
static_assert(__builtin_offsetof(ActorDataLady, magicPoints) == 0x3EB8);
static_assert(__builtin_offsetof(ActorDataLady, maxMagicPoints) == 0x3EBC);
static_assert(__builtin_offsetof(ActorDataLady, var_3EC4) == 0x3EC4);
static_assert(__builtin_offsetof(ActorDataLady, var_3EC8) == 0x3EC8);
static_assert(__builtin_offsetof(ActorDataLady, var_3ED2) == 0x3ED2);
static_assert(__builtin_offsetof(ActorDataLady, cameraDirection) == 0x3ED8);
static_assert(__builtin_offsetof(ActorDataLady, var_3EDC) == 0x3EDC);
static_assert(__builtin_offsetof(ActorDataLady, airHikeCount) == 0x3F11);
static_assert(__builtin_offsetof(ActorDataLady, kickJumpCount) == 0x3F12);
static_assert(__builtin_offsetof(ActorDataLady, wallHikeCount) == 0x3F13);
static_assert(__builtin_offsetof(ActorDataLady, enableAirRaid) == 0x3F14);
static_assert(__builtin_offsetof(ActorDataLady, var_3F19) == 0x3F19);
static_assert(__builtin_offsetof(ActorDataLady, action) == 0x3FA4);
static_assert(__builtin_offsetof(ActorDataLady, lastAction) == 0x3FA5);
static_assert(__builtin_offsetof(ActorDataLady, bufferedAction) == 0x3FA8);
static_assert(__builtin_offsetof(ActorDataLady, chainCount) == 0x3FAC);
static_assert(__builtin_offsetof(ActorDataLady, expertise) == 0x3FEC);
static_assert(__builtin_offsetof(ActorDataLady, maxHitPoints) == 0x40EC);
static_assert(__builtin_offsetof(ActorDataLady, hitPoints) == 0x411C);
static_assert(__builtin_offsetof(ActorDataLady, targetBaseAddr) == 0x6328);
static_assert(__builtin_offsetof(ActorDataLady, style) == 0x6338);
static_assert(__builtin_offsetof(ActorDataLady, wallHikeDirection) == 0x633C);
static_assert(__builtin_offsetof(ActorDataLady, var_6340) == 0x6340);
static_assert(__builtin_offsetof(ActorDataLady, styleLevel) == 0x6358);
static_assert(__builtin_offsetof(ActorDataLady, dashCount) == 0x635C);
static_assert(__builtin_offsetof(ActorDataLady, skyStarCount) == 0x635D);
static_assert(__builtin_offsetof(ActorDataLady, airTrickCount) == 0x635E);
static_assert(__builtin_offsetof(ActorDataLady, trickUpCount) == 0x635F);
static_assert(__builtin_offsetof(ActorDataLady, trickDownCount) == 0x6360);
static_assert(__builtin_offsetof(ActorDataLady, quicksilver) == 0x6361);
static_assert(__builtin_offsetof(ActorDataLady, doppelganger) == 0x6362);
static_assert(__builtin_offsetof(ActorDataLady, styleExperience) == 0x6364);
static_assert(__builtin_offsetof(ActorDataLady, speedMode) == 0x63D4);
static_assert(__builtin_offsetof(ActorDataLady, var_6410) == 0x6410);
static_assert(__builtin_offsetof(ActorDataLady, var_6438) == 0x6438);
static_assert(__builtin_offsetof(ActorDataLady, var_6440) == 0x6440);
static_assert(__builtin_offsetof(ActorDataLady, cloneRate) == 0x6450);
static_assert(__builtin_offsetof(ActorDataLady, cloneStatus) == 0x6454);
static_assert(__builtin_offsetof(ActorDataLady, var_6458) == 0x6458);
static_assert(__builtin_offsetof(ActorDataLady, cloneActorBaseAddr) == 0x6478);
static_assert(__builtin_offsetof(ActorDataLady, cloneIsControlledByPlayer) == 0x6480);
static_assert(__builtin_offsetof(ActorDataLady, activeMeleeWeaponIndex) == 0x6484);
static_assert(__builtin_offsetof(ActorDataLady, queuedMeleeWeaponIndex) == 0x6488);
static_assert(__builtin_offsetof(ActorDataLady, activeWeapon) == 0x648D);
static_assert(__builtin_offsetof(ActorDataLady, meleeWeaponIndex) == 0x6490);
static_assert(__builtin_offsetof(ActorDataLady, rangedWeaponIndex) == 0x6494);
static_assert(__builtin_offsetof(ActorDataLady, weapons) == 0x6498);
static_assert(__builtin_offsetof(ActorDataLady, weaponDataAddr) == 0x64A0);
static_assert(__builtin_offsetof(ActorDataLady, weaponStatus) == 0x64C8);
static_assert(__builtin_offsetof(ActorDataLady, weaponLevels) == 0x64DC);
static_assert(__builtin_offsetof(ActorDataLady, activeMeleeWeapon) == 0x64F0);
static_assert(__builtin_offsetof(ActorDataLady, activeRangedWeapon) == 0x64F1);
static_assert(__builtin_offsetof(ActorDataLady, weaponTimers) == 0x64F4);
static_assert(__builtin_offsetof(ActorDataLady, meleeWeaponSwitchTimeout) == 0x6508);
static_assert(__builtin_offsetof(ActorDataLady, rangedWeaponSwitchTimeout) == 0x650C);
static_assert(__builtin_offsetof(ActorDataLady, styleData) == 0x6510);
static_assert(__builtin_offsetof(ActorDataLady, var_6670) == 0x6670);
static_assert(__builtin_offsetof(ActorDataLady, inputData) == 0x6674);
static_assert(__builtin_offsetof(ActorDataLady, bodyPartData) == 0x6950);
static_assert(__builtin_offsetof(ActorDataLady, collisionData) == 0x7250);
static_assert(__builtin_offsetof(ActorDataLady, buttons) == 0x74E0);
static_assert(__builtin_offsetof(ActorDataLady, rightStickPosition) == 0x74F8);
static_assert(__builtin_offsetof(ActorDataLady, rightStickRadius) == 0x74FA);
static_assert(__builtin_offsetof(ActorDataLady, leftStickPosition) == 0x7508);
static_assert(__builtin_offsetof(ActorDataLady, leftStickRadius) == 0x750A);
static_assert(__builtin_offsetof(ActorDataLady, actorCameraDirection) == 0x750C);
static_assert(__builtin_offsetof(ActorDataLady, leftStickDirection) == 0x751C);
static_assert(__builtin_offsetof(ActorDataLady, submodelData) == 0x7540);
static_assert(__builtin_offsetof(ActorDataLady, submodelInit) == 0x9AC0);
static_assert(__builtin_offsetof(ActorDataLady, newFirstVar) == 0xB8C0);
static_assert(__builtin_offsetof(ActorDataLady, newModelData) == 0xB8D0);
static_assert(__builtin_offsetof(ActorDataLady, newModelPhysicsMetadataPool) == 0xE5D0);
static_assert(__builtin_offsetof(ActorDataLady, newModelAllocationData) == 0xEB10);
static_assert(__builtin_offsetof(ActorDataLady, newRecoveryData) == 0x12B10);
static_assert(__builtin_offsetof(ActorDataLady, newDevilModels) == 0x12DB0);
static_assert(__builtin_offsetof(ActorDataLady, newBodyPartData) == 0x12DD0);
static_assert(__builtin_offsetof(ActorDataLady, newSubmodelData) == 0x13D90);
static_assert(__builtin_offsetof(ActorDataLady, newSubmodelInit) == 0x19010);
static_assert(__builtin_offsetof(ActorDataLady, newModelShadowData) == 0x19020);
static_assert(__builtin_offsetof(ActorDataLady, newSubmodelShadowData) == 0x194A0);
static_assert(__builtin_offsetof(ActorDataLady, newDevilModelPhysicsMetadataPool) == 0x19CE0);
static_assert(__builtin_offsetof(ActorDataLady, newDevilSubmodelPhysicsData) == 0x1A280);
static_assert(__builtin_offsetof(ActorDataLady, newDevilSubmodelPhysicsLinkData) == 0x1ABE0);
static_assert(__builtin_offsetof(ActorDataLady, newWeapons) == 0x1C9E0);
static_assert(__builtin_offsetof(ActorDataLady, newWeaponDataAddr) == 0x1C9F0);
static_assert(__builtin_offsetof(ActorDataLady, newWeaponStatus) == 0x1CA40);
static_assert(__builtin_offsetof(ActorDataLady, newWeaponLevels) == 0x1CA70);
static_assert(__builtin_offsetof(ActorDataLady, newWeaponTimers) == 0x1CAA0);
static_assert(__builtin_offsetof(ActorDataLady, newIsClone) == 0x1CAC8);
static_assert(__builtin_offsetof(ActorDataLady, newPlayerIndex) == 0x1CACC);
static_assert(__builtin_offsetof(ActorDataLady, newCharacterIndex) == 0x1CACD);
static_assert(__builtin_offsetof(ActorDataLady, newEntityIndex) == 0x1CACE);
static_assert(__builtin_offsetof(ActorDataLady, newForceFiles) == 0x1CACF);
static_assert(__builtin_offsetof(ActorDataLady, newForceFilesCharacter) == 0x1CAD0);
static_assert(__builtin_offsetof(ActorDataLady, newEnableVisibility) == 0x1CAD1);
static_assert(__builtin_offsetof(ActorDataLady, newGamepad) == 0x1CAD2);
static_assert(__builtin_offsetof(ActorDataLady, newButtonMask) == 0x1CAD3);
static_assert(__builtin_offsetof(ActorDataLady, newEnableRightStick) == 0x1CAD5);
static_assert(__builtin_offsetof(ActorDataLady, newEnableLeftStick) == 0x1CAD6);
static_assert(__builtin_offsetof(ActorDataLady, newExecuteStyleSwitch) == 0x1CAD7);
static_assert(__builtin_offsetof(ActorDataLady, newExecuteRemoveBusyFlag) == 0x1CAD8);
static_assert(__builtin_offsetof(ActorDataLady, newAirStingerCount) == 0x1CAD9);
static_assert(__builtin_offsetof(ActorDataLady, newEnableCollision) == 0x1CADA);
static_assert(__builtin_offsetof(ActorDataLady, newActorLoopRun) == 0x1CADB);
static_assert(__builtin_offsetof(ActorDataLady, newAirHikeCount) == 0x1CADC);
static_assert(__builtin_offsetof(ActorDataLady, newKickJumpCount) == 0x1CADD);
static_assert(__builtin_offsetof(ActorDataLady, newWallHikeCount) == 0x1CADE);
static_assert(__builtin_offsetof(ActorDataLady, newDashCount) == 0x1CADF);
static_assert(__builtin_offsetof(ActorDataLady, newSkyStarCount) == 0x1CAE0);
static_assert(__builtin_offsetof(ActorDataLady, newAirTrickCount) == 0x1CAE1);
static_assert(__builtin_offsetof(ActorDataLady, newTrickUpCount) == 0x1CAE2);
static_assert(__builtin_offsetof(ActorDataLady, newTrickDownCount) == 0x1CAE3);
static_assert(__builtin_offsetof(ActorDataLady, newEffectIndices) == 0x1CAF0);
static_assert(__builtin_offsetof(ActorDataLady, newLastVar) == 0x1CB20);

static_assert(__builtin_offsetof(ActorDataVergil, status) == 8);
static_assert(__builtin_offsetof(ActorDataVergil, speed) == 0x14);
static_assert(__builtin_offsetof(ActorDataVergil, speedMultiplier) == 0x18);
static_assert(__builtin_offsetof(ActorDataVergil, character) == 0x78);
static_assert(__builtin_offsetof(ActorDataVergil, position) == 0x80);
static_assert(__builtin_offsetof(ActorDataVergil, pull) == 0x94);
static_assert(__builtin_offsetof(ActorDataVergil, pullMultiplier) == 0xA4);
static_assert(__builtin_offsetof(ActorDataVergil, rotation) == 0xC0);
static_assert(__builtin_offsetof(ActorDataVergil, id) == 0x118);
static_assert(__builtin_offsetof(ActorDataVergil, isClone) == 0x11C);
static_assert(__builtin_offsetof(ActorDataVergil, visibility) == 0x120);
static_assert(__builtin_offsetof(ActorDataVergil, var_1C0) == 0x1C0);
static_assert(__builtin_offsetof(ActorDataVergil, var_1C4) == 0x1C4);
static_assert(__builtin_offsetof(ActorDataVergil, modelData) == 0x200);
static_assert(__builtin_offsetof(ActorDataVergil, modelPhysicsMetadataPool) == 0x1880);
static_assert(__builtin_offsetof(ActorDataVergil, modelAllocationDataCount) == 0x1B80);
static_assert(__builtin_offsetof(ActorDataVergil, modelAllocationData) == 0x1B88);
static_assert(__builtin_offsetof(ActorDataVergil, motionSpeed) == 0x3894);
static_assert(__builtin_offsetof(ActorDataVergil, motionSpeedMultiplier) == 0x3898);
static_assert(__builtin_offsetof(ActorDataVergil, motionArchives) == 0x38A0);
static_assert(__builtin_offsetof(ActorDataVergil, motionData) == 0x39B0);
static_assert(__builtin_offsetof(ActorDataVergil, motionDataMirror) == 0x39B4);
static_assert(__builtin_offsetof(ActorDataVergil, var_39BC) == 0x39BC);
static_assert(__builtin_offsetof(ActorDataVergil, var_39C0) == 0x39C0);
static_assert(__builtin_offsetof(ActorDataVergil, nextActionRequestPolicy) == 0x39D0);
static_assert(__builtin_offsetof(ActorDataVergil, var_3A10) == 0x3A10);
static_assert(__builtin_offsetof(ActorDataVergil, shadow) == 0x3A18);
static_assert(__builtin_offsetof(ActorDataVergil, lastShadow) == 0x3A1C);
static_assert(__builtin_offsetof(ActorDataVergil, color) == 0x3A28);
static_assert(__builtin_offsetof(ActorDataVergil, recoveryData) == 0x3B00);
static_assert(__builtin_offsetof(ActorDataVergil, var_3C50) == 0x3C50);
static_assert(__builtin_offsetof(ActorDataVergil, actionData) == 0x3DD0);
static_assert(__builtin_offsetof(ActorDataVergil, eventData) == 0x3E00);
static_assert(__builtin_offsetof(ActorDataVergil, var_3E10) == 0x3E10);
static_assert(__builtin_offsetof(ActorDataVergil, motionTimer) == 0x3E34);
static_assert(__builtin_offsetof(ActorDataVergil, idleTimer) == 0x3E38);
static_assert(__builtin_offsetof(ActorDataVergil, permissions) == 0x3E60);
static_assert(__builtin_offsetof(ActorDataVergil, state) == 0x3E64);
static_assert(__builtin_offsetof(ActorDataVergil, lastState) == 0x3E68);
static_assert(__builtin_offsetof(ActorDataVergil, activeModelIndex) == 0x3E6C);
static_assert(__builtin_offsetof(ActorDataVergil, queuedModelIndex) == 0x3E70);
static_assert(__builtin_offsetof(ActorDataVergil, devilModels) == 0x3E74);
static_assert(__builtin_offsetof(ActorDataVergil, modelState) == 0x3E80);
static_assert(__builtin_offsetof(ActorDataVergil, lockOn) == 0x3E84);
static_assert(__builtin_offsetof(ActorDataVergil, activeModelIndexMirror) == 0x3E88);
static_assert(__builtin_offsetof(ActorDataVergil, activeDevil) == 0x3E8C);
static_assert(__builtin_offsetof(ActorDataVergil, airRaid) == 0x3E90);
static_assert(__builtin_offsetof(ActorDataVergil, mode) == 0x3E94);
static_assert(__builtin_offsetof(ActorDataVergil, dead) == 0x3E99);
static_assert(__builtin_offsetof(ActorDataVergil, devil) == 0x3E9B);
static_assert(__builtin_offsetof(ActorDataVergil, costume) == 0x3E9E);
static_assert(__builtin_offsetof(ActorDataVergil, sparda) == 0x3E9F);
static_assert(__builtin_offsetof(ActorDataVergil, neroAngelo) == 0x3E9F);
static_assert(__builtin_offsetof(ActorDataVergil, useHolyWater) == 0x3EA4);
static_assert(__builtin_offsetof(ActorDataVergil, magicPoints) == 0x3EB8);
static_assert(__builtin_offsetof(ActorDataVergil, maxMagicPoints) == 0x3EBC);
static_assert(__builtin_offsetof(ActorDataVergil, var_3EC4) == 0x3EC4);
static_assert(__builtin_offsetof(ActorDataVergil, var_3EC8) == 0x3EC8);
static_assert(__builtin_offsetof(ActorDataVergil, var_3ED2) == 0x3ED2);
static_assert(__builtin_offsetof(ActorDataVergil, cameraDirection) == 0x3ED8);
static_assert(__builtin_offsetof(ActorDataVergil, var_3EDC) == 0x3EDC);
static_assert(__builtin_offsetof(ActorDataVergil, airHikeCount) == 0x3F11);
static_assert(__builtin_offsetof(ActorDataVergil, kickJumpCount) == 0x3F12);
static_assert(__builtin_offsetof(ActorDataVergil, wallHikeCount) == 0x3F13);
static_assert(__builtin_offsetof(ActorDataVergil, enableAirRaid) == 0x3F14);
static_assert(__builtin_offsetof(ActorDataVergil, var_3F19) == 0x3F19);
static_assert(__builtin_offsetof(ActorDataVergil, action) == 0x3FA4);
static_assert(__builtin_offsetof(ActorDataVergil, lastAction) == 0x3FA5);
static_assert(__builtin_offsetof(ActorDataVergil, bufferedAction) == 0x3FA8);
static_assert(__builtin_offsetof(ActorDataVergil, chainCount) == 0x3FAC);
static_assert(__builtin_offsetof(ActorDataVergil, expertise) == 0x3FEC);
static_assert(__builtin_offsetof(ActorDataVergil, maxHitPoints) == 0x40EC);
static_assert(__builtin_offsetof(ActorDataVergil, hitPoints) == 0x411C);
static_assert(__builtin_offsetof(ActorDataVergil, targetBaseAddr) == 0x6328);
static_assert(__builtin_offsetof(ActorDataVergil, style) == 0x6338);
static_assert(__builtin_offsetof(ActorDataVergil, wallHikeDirection) == 0x633C);
static_assert(__builtin_offsetof(ActorDataVergil, var_6340) == 0x6340);
static_assert(__builtin_offsetof(ActorDataVergil, styleLevel) == 0x6358);
static_assert(__builtin_offsetof(ActorDataVergil, dashCount) == 0x635C);
static_assert(__builtin_offsetof(ActorDataVergil, skyStarCount) == 0x635D);
static_assert(__builtin_offsetof(ActorDataVergil, airTrickCount) == 0x635E);
static_assert(__builtin_offsetof(ActorDataVergil, trickUpCount) == 0x635F);
static_assert(__builtin_offsetof(ActorDataVergil, trickDownCount) == 0x6360);
static_assert(__builtin_offsetof(ActorDataVergil, quicksilver) == 0x6361);
static_assert(__builtin_offsetof(ActorDataVergil, doppelganger) == 0x6362);
static_assert(__builtin_offsetof(ActorDataVergil, styleExperience) == 0x6364);
static_assert(__builtin_offsetof(ActorDataVergil, speedMode) == 0x63D4);
static_assert(__builtin_offsetof(ActorDataVergil, var_6410) == 0x6410);
static_assert(__builtin_offsetof(ActorDataVergil, var_6438) == 0x6438);
static_assert(__builtin_offsetof(ActorDataVergil, var_6440) == 0x6440);
static_assert(__builtin_offsetof(ActorDataVergil, cloneRate) == 0x6450);
static_assert(__builtin_offsetof(ActorDataVergil, cloneStatus) == 0x6454);
static_assert(__builtin_offsetof(ActorDataVergil, var_6458) == 0x6458);
static_assert(__builtin_offsetof(ActorDataVergil, cloneActorBaseAddr) == 0x6478);
static_assert(__builtin_offsetof(ActorDataVergil, cloneIsControlledByPlayer) == 0x6480);
static_assert(__builtin_offsetof(ActorDataVergil, activeMeleeWeaponIndex) == 0x6484);
static_assert(__builtin_offsetof(ActorDataVergil, queuedMeleeWeaponIndex) == 0x6488);
static_assert(__builtin_offsetof(ActorDataVergil, activeWeapon) == 0x648D);
static_assert(__builtin_offsetof(ActorDataVergil, meleeWeaponIndex) == 0x6490);
static_assert(__builtin_offsetof(ActorDataVergil, rangedWeaponIndex) == 0x6494);
static_assert(__builtin_offsetof(ActorDataVergil, weapons) == 0x6498);
static_assert(__builtin_offsetof(ActorDataVergil, weaponDataAddr) == 0x64A0);
static_assert(__builtin_offsetof(ActorDataVergil, weaponStatus) == 0x64C8);
static_assert(__builtin_offsetof(ActorDataVergil, weaponLevels) == 0x64DC);
static_assert(__builtin_offsetof(ActorDataVergil, activeMeleeWeapon) == 0x64F0);
static_assert(__builtin_offsetof(ActorDataVergil, activeRangedWeapon) == 0x64F1);
static_assert(__builtin_offsetof(ActorDataVergil, weaponTimers) == 0x64F4);
static_assert(__builtin_offsetof(ActorDataVergil, meleeWeaponSwitchTimeout) == 0x6508);
static_assert(__builtin_offsetof(ActorDataVergil, rangedWeaponSwitchTimeout) == 0x650C);
static_assert(__builtin_offsetof(ActorDataVergil, styleData) == 0x6510);
static_assert(__builtin_offsetof(ActorDataVergil, var_6670) == 0x6670);
static_assert(__builtin_offsetof(ActorDataVergil, inputData) == 0x6674);
static_assert(__builtin_offsetof(ActorDataVergil, bodyPartData) == 0x6950);
static_assert(__builtin_offsetof(ActorDataVergil, collisionData) == 0x7250);
static_assert(__builtin_offsetof(ActorDataVergil, buttons) == 0x74E0);
static_assert(__builtin_offsetof(ActorDataVergil, rightStickPosition) == 0x74F8);
static_assert(__builtin_offsetof(ActorDataVergil, rightStickRadius) == 0x74FA);
static_assert(__builtin_offsetof(ActorDataVergil, leftStickPosition) == 0x7508);
static_assert(__builtin_offsetof(ActorDataVergil, leftStickRadius) == 0x750A);
static_assert(__builtin_offsetof(ActorDataVergil, actorCameraDirection) == 0x750C);
static_assert(__builtin_offsetof(ActorDataVergil, leftStickDirection) == 0x751C);
static_assert(__builtin_offsetof(ActorDataVergil, submodelData) == 0x7540);
static_assert(__builtin_offsetof(ActorDataVergil, submodelInit) == 0x9AC0);
static_assert(__builtin_offsetof(ActorDataVergil, modelShadowData) == 0x9AF0);
static_assert(__builtin_offsetof(ActorDataVergil, submodelShadowData) == 0x9D30);
static_assert(__builtin_offsetof(ActorDataVergil, submodelPhysicsMetadataPool) == 0xA0F0);
static_assert(__builtin_offsetof(ActorDataVergil, submodelPhysicsData) == 0xA230);
static_assert(__builtin_offsetof(ActorDataVergil, modelMetadata) == 0xB640);
static_assert(__builtin_offsetof(ActorDataVergil, newFirstVar) == 0xB8C0);
static_assert(__builtin_offsetof(ActorDataVergil, newModelData) == 0xB8D0);
static_assert(__builtin_offsetof(ActorDataVergil, newModelPhysicsMetadataPool) == 0xE5D0);
static_assert(__builtin_offsetof(ActorDataVergil, newModelAllocationData) == 0xEB10);
static_assert(__builtin_offsetof(ActorDataVergil, newRecoveryData) == 0x12B10);
static_assert(__builtin_offsetof(ActorDataVergil, newDevilModels) == 0x12DB0);
static_assert(__builtin_offsetof(ActorDataVergil, newBodyPartData) == 0x12DD0);
static_assert(__builtin_offsetof(ActorDataVergil, newSubmodelData) == 0x13D90);
static_assert(__builtin_offsetof(ActorDataVergil, newSubmodelInit) == 0x19010);
static_assert(__builtin_offsetof(ActorDataVergil, newModelShadowData) == 0x19020);
static_assert(__builtin_offsetof(ActorDataVergil, newSubmodelShadowData) == 0x194A0);
static_assert(__builtin_offsetof(ActorDataVergil, newDevilModelPhysicsMetadataPool) == 0x19CE0);
static_assert(__builtin_offsetof(ActorDataVergil, newDevilSubmodelPhysicsData) == 0x1A280);
static_assert(__builtin_offsetof(ActorDataVergil, newDevilSubmodelPhysicsLinkData) == 0x1ABE0);
static_assert(__builtin_offsetof(ActorDataVergil, newWeapons) == 0x1C9E0);
static_assert(__builtin_offsetof(ActorDataVergil, newWeaponDataAddr) == 0x1C9F0);
static_assert(__builtin_offsetof(ActorDataVergil, newWeaponStatus) == 0x1CA40);
static_assert(__builtin_offsetof(ActorDataVergil, newWeaponLevels) == 0x1CA70);
static_assert(__builtin_offsetof(ActorDataVergil, newWeaponTimers) == 0x1CAA0);
static_assert(__builtin_offsetof(ActorDataVergil, newIsClone) == 0x1CAC8);
static_assert(__builtin_offsetof(ActorDataVergil, newPlayerIndex) == 0x1CACC);
static_assert(__builtin_offsetof(ActorDataVergil, newCharacterIndex) == 0x1CACD);
static_assert(__builtin_offsetof(ActorDataVergil, newEntityIndex) == 0x1CACE);
static_assert(__builtin_offsetof(ActorDataVergil, newForceFiles) == 0x1CACF);
static_assert(__builtin_offsetof(ActorDataVergil, newForceFilesCharacter) == 0x1CAD0);
static_assert(__builtin_offsetof(ActorDataVergil, newEnableVisibility) == 0x1CAD1);
static_assert(__builtin_offsetof(ActorDataVergil, newGamepad) == 0x1CAD2);
static_assert(__builtin_offsetof(ActorDataVergil, newButtonMask) == 0x1CAD3);
static_assert(__builtin_offsetof(ActorDataVergil, newEnableRightStick) == 0x1CAD5);
static_assert(__builtin_offsetof(ActorDataVergil, newEnableLeftStick) == 0x1CAD6);
static_assert(__builtin_offsetof(ActorDataVergil, newExecuteStyleSwitch) == 0x1CAD7);
static_assert(__builtin_offsetof(ActorDataVergil, newExecuteRemoveBusyFlag) == 0x1CAD8);
static_assert(__builtin_offsetof(ActorDataVergil, newAirStingerCount) == 0x1CAD9);
static_assert(__builtin_offsetof(ActorDataVergil, newEnableCollision) == 0x1CADA);
static_assert(__builtin_offsetof(ActorDataVergil, newActorLoopRun) == 0x1CADB);
static_assert(__builtin_offsetof(ActorDataVergil, newAirHikeCount) == 0x1CADC);
static_assert(__builtin_offsetof(ActorDataVergil, newKickJumpCount) == 0x1CADD);
static_assert(__builtin_offsetof(ActorDataVergil, newWallHikeCount) == 0x1CADE);
static_assert(__builtin_offsetof(ActorDataVergil, newDashCount) == 0x1CADF);
static_assert(__builtin_offsetof(ActorDataVergil, newSkyStarCount) == 0x1CAE0);
static_assert(__builtin_offsetof(ActorDataVergil, newAirTrickCount) == 0x1CAE1);
static_assert(__builtin_offsetof(ActorDataVergil, newTrickUpCount) == 0x1CAE2);
static_assert(__builtin_offsetof(ActorDataVergil, newTrickDownCount) == 0x1CAE3);
static_assert(__builtin_offsetof(ActorDataVergil, newEffectIndices) == 0x1CAF0);
static_assert(__builtin_offsetof(ActorDataVergil, newLastVar) == 0x1CB20);

// $ActorDataEnd












#pragma pack(pop)





// @Todo: Update.

struct MotionArchiveHelper
{
	uint8 group;
	uint16 cacheFileId;
};

constexpr MotionArchiveHelper motionArchiveHelperDante[] =
{
	{ MOTION_GROUP_DANTE_BASE                  , pl000_00_0  },
	{ MOTION_GROUP_DANTE_DAMAGE                , pl000_00_1  },
	{ MOTION_GROUP_DANTE_TAUNTS                , pl000_00_2  },
	{ MOTION_GROUP_DANTE_REBELLION             , pl000_00_3  },
	{ MOTION_GROUP_DANTE_CERBERUS              , pl000_00_4  },
	{ MOTION_GROUP_DANTE_AGNI_RUDRA            , pl000_00_5  },
	{ MOTION_GROUP_DANTE_NEVAN                 , pl000_00_6  },
	{ MOTION_GROUP_DANTE_BEOWULF               , pl000_00_7  },
	{ MOTION_GROUP_DANTE_EBONY_IVORY           , pl000_00_8  },
	{ MOTION_GROUP_DANTE_SHOTGUN               , pl000_00_9  },
	{ MOTION_GROUP_DANTE_ARTEMIS               , pl000_00_10 },
	{ MOTION_GROUP_DANTE_SPIRAL                , pl000_00_11 },
	{ MOTION_GROUP_DANTE_KALINA_ANN            , pl000_00_12 },
	{ MOTION_GROUP_DANTE_SWORDMASTER_REBELLION , pl000_00_13 },
	{ MOTION_GROUP_DANTE_SWORDMASTER_CERBERUS  , pl000_00_14 },
	{ MOTION_GROUP_DANTE_SWORDMASTER_AGNI_RUDRA, pl000_00_15 },
	{ MOTION_GROUP_DANTE_SWORDMASTER_NEVAN     , pl000_00_16 },
	{ MOTION_GROUP_DANTE_SWORDMASTER_BEOWULF   , pl000_00_17 },
	{ MOTION_GROUP_DANTE_GUNSLINGER_EBONY_IVORY, pl000_00_18 },
	{ MOTION_GROUP_DANTE_GUNSLINGER_SHOTGUN    , pl000_00_19 },
	{ MOTION_GROUP_DANTE_GUNSLINGER_ARTEMIS    , pl000_00_20 },
	{ MOTION_GROUP_DANTE_GUNSLINGER_SPIRAL     , pl000_00_21 },
	{ MOTION_GROUP_DANTE_GUNSLINGER_KALINA_ANN , pl000_00_22 },
	{ MOTION_GROUP_DANTE_TRICKSTER             , pl000_00_23 },
	{ MOTION_GROUP_DANTE_ROYALGUARD            , pl000_00_24 },
	{ MOTION_GROUP_DANTE_QUICKSILVER           , pl000_00_25 },
	{ MOTION_GROUP_DANTE_DOPPELGANGER          , pl000_00_26 },
};

constexpr MotionArchiveHelper motionArchiveHelperBob[] =
{
	{ MOTION_GROUP_BOB_BASE   , pl001_00_0  },
	{ MOTION_GROUP_BOB_DAMAGE , pl001_00_1  },
	{ MOTION_GROUP_BOB_TAUNTS , pl001_00_2  },
	{ MOTION_GROUP_BOB_YAMATO , pl001_00_31 },
};

constexpr MotionArchiveHelper motionArchiveHelperLady[] =
{
	{ MOTION_GROUP_LADY_BASE      , pl002_00_0  },
	{ MOTION_GROUP_LADY_DAMAGE    , pl002_00_1  },
	{ MOTION_GROUP_LADY_TAUNTS    , pl002_00_2  },
};

constexpr MotionArchiveHelper motionArchiveHelperVergil[] =
{
	{ MOTION_GROUP_VERGIL_BASE                  , pl021_00_0 },
	{ MOTION_GROUP_VERGIL_DAMAGE                , pl021_00_1 },
	{ MOTION_GROUP_VERGIL_TAUNTS                , pl021_00_2 },
	{ MOTION_GROUP_VERGIL_YAMATO                , pl021_00_3 },
	{ MOTION_GROUP_VERGIL_BEOWULF               , pl021_00_4 },
	{ MOTION_GROUP_VERGIL_FORCE_EDGE            , pl021_00_5 },
	{ MOTION_GROUP_VERGIL_DARK_SLAYER           , pl021_00_6 },
	{ MOTION_GROUP_VERGIL_NERO_ANGELO_YAMATO    , pl021_00_7 },
	{ MOTION_GROUP_VERGIL_NERO_ANGELO_BEOWULF   , pl021_00_8 },
	{ MOTION_GROUP_VERGIL_NERO_ANGELO_FORCE_EDGE, pl021_00_9 }, // @Todo: Review.
};




struct MissionStartHelper
{
	uint16 room;
	uint16 position;
};

constexpr MissionStartHelper missionStartHelper[] =
{
	{ 0  , 0 }, // Movie
	{ 0  , 0 }, // Mission 1
	{ 1  , 0 }, // Mission 2
	{ 2  , 0 }, // Mission 3
	{ 100, 0 }, // Mission 4
	{ 111, 2 }, // Mission 5
	{ 122, 0 }, // Mission 6
	{ 127, 2 }, // Mission 7
	{ 300, 0 }, // Mission 8
	{ 201, 0 }, // Mission 9
	{ 209, 2 }, // Mission 10
	{ 212, 1 }, // Mission 11
	{ 217, 1 }, // Mission 12
	{ 229, 0 }, // Mission 13
	{ 237, 1 }, // Mission 14
	{ 222, 1 }, // Mission 15
	{ 106, 0 }, // Mission 16
	{ 133, 1 }, // Mission 17
	{ 400, 0 }, // Mission 18
	{ 406, 0 }, // Mission 19
	{ 411, 0 }, // Mission 20
	{ 423, 0 }, // Bloody Palace
};




















struct FloorHelper
{
	uint16 room;
	uint16 position;
};

constexpr FloorHelper Arcade_floorHelper[] =
{
	{ 423, 0 }, // Floor 1
	{ 424, 0 }, // Floor 2
	{ 425, 0 }, // Floor 3
	{ 426, 0 }, // Floor 4
	{ 427, 0 }, // Floor 5
	{ 428, 0 }, // Floor 6
	{ 429, 0 }, // Floor 7
	{ 430, 0 }, // Floor 8
	{ 431, 0 }, // Floor 9
	{ 432, 0 }, // Floor 10
	{ 433, 0 }, // Cerberus
	{ 434, 0 }, // Gigapede
	{ 435, 0 }, // Agni & Rudra
	{ 436, 0 }, // Nevan
	{ 437, 0 }, // Beowulf
	{ 438, 2 }, // Geryon
	{ 439, 0 }, // Doppelganger
	{ 440, 0 }, // Heart of Leviathan
	{ 441, 0 }, // Damned Chessmen
	{ 442, 0 }, // Vergil 1
	{ 443, 0 }, // Vergil 2
	{ 444, 0 }, // Vergil 3
	{ 445, 2 }, // Lady
	{ 446, 0 }, // Arkham
	{ 422, 0 }, // Jester 1
	{ 448, 0 }, // Jester 2
	{ 449, 0 }, // Jester 3
};










enum BOSS
{
	BOSS_CERBERUS,
	BOSS_GIGAPEDE,
	BOSS_JESTER_1,
	BOSS_AGNI_RUDRA,
	BOSS_VERGIL_1,
	BOSS_LEVIATHAN,
	BOSS_NEVAN,
	BOSS_BEOWULF,
	BOSS_JESTER_2,
	BOSS_GERYON_PART_1,
	BOSS_GERYON_PART_2,
	BOSS_VERGIL_2,
	BOSS_LADY,
	BOSS_JESTER_3,
	BOSS_DOPPELGANGER,
	BOSS_TAIZAI_REBORN,
	BOSS_CERBERUS_REBORN,
	BOSS_GIGAPEDE_REBORN,
	BOSS_AGNI_RUDRA_REBORN,
	BOSS_LEVIATHAN_REBORN,
	BOSS_NEVAN_REBORN,
	BOSS_BEOWULF_REBORN,
	BOSS_GERYON_REBORN,
	BOSS_DOPPELGANGER_REBORN,
	BOSS_ARKHAM_PART_1,
	BOSS_ARKHAM_PART_2,
	BOSS_VERGIL_3,
};

struct BossHelper
{
	uint16 room;
	uint16 position;
	const char * track;
};

constexpr BossHelper bossHelper[] =
{
	{ 6  , 2, "afs/sound/Boss_01.adx"    }, // Cerberus
	{ 111, 0, "afs/sound/T_Boss.adx"     }, // Gigapede
	{ 422, 0, "afs/sound/Jester.adx"     }, // Jester 1
	{ 121, 3, "afs/sound/Boss_02.adx"    }, // Agni & Rudra
	{ 144, 0, "afs/sound/Versil_01.adx"  }, // Vergil 1
	{ 302, 0, "afs/sound/Boss_08.adx"    }, // Leviathan
	{ 210, 2, "afs/sound/Boss_03.adx"    }, // Nevan
	{ 217, 2, "afs/sound/Boss_04.adx"    }, // Beowulf
	{ 448, 0, "afs/sound/Jester.adx"     }, // Jester 2
	{ 228, 0, "afs/sound/Boss_05.adx"    }, // Geryon Part 1
	{ 228, 2, "afs/sound/Boss_05.adx"    }, // Geryon Part 2
	{ 234, 0, "afs/sound/Versil_02.adx"  }, // Vergil 2
	{ 115, 2, "afs/sound/Lady.adx"       }, // Lady
	{ 449, 0, "afs/sound/Jester.adx"     }, // Jester 3
	{ 139, 0, "afs/sound/Boss_06.adx"    }, // Doppelganger
	{ 420, 0, "afs/sound/Battle_01B.adx" }, // Taizai Reborn
	{ 412, 0, "afs/sound/Boss_01B.adx"   }, // Cerberus Reborn
	{ 413, 0, "afs/sound/T_BossB.adx"    }, // Gigapede Reborn
	{ 414, 0, "afs/sound/Boss_02B.adx"   }, // Agni & Rudra Reborn
	{ 419, 0, "afs/sound/Boss_08B.adx"   }, // Leviathan Reborn
	{ 415, 0, "afs/sound/Boss_03B.adx"   }, // Nevan Reborn
	{ 416, 0, "afs/sound/Boss_04B.adx"   }, // Beowulf Reborn
	{ 417, 0, "afs/sound/Boss_05B.adx"   }, // Geryon Reborn
	{ 418, 0, "afs/sound/Boss_06B.adx"   }, // Doppelganger Reborn
	{ 421, 0, "afs/sound/Hine_01.adx"    }, // Arkham Part 1
	{ 421, 0, "afs/sound/Hine_02.adx"    }, // Arkham Part 2
	{ 411, 0, "afs/sound/Versil_03.adx"  }, // Vergil 3
};




































#line 13 "C:\\Users\\serpentiem\\source\\repos\\ddmk\\Mary\\Actor.ixx"
export module Actor;

import Config;
import File;
import Global;
import HUD;
import Internal;
import Input;
import Memory;
import Model;



#pragma region Main

export Vector<byte8 *> Actor_actorBaseAddr;

typedef byte8 *(__fastcall * GetActorBaseAddressByEffectData_t)(byte8 * effectDataAddr);

GetActorBaseAddressByEffectData_t GetActorBaseAddressByEffectData = 0;

export template <typename T>
void SetMainActor(T & actorData)
{


	if constexpr (false )
	{
		LogFunctionHelper(__FUNCTION__, actorData.operator byte8 *()) ;
	}



	auto actorBaseAddr = reinterpret_cast<byte8 *>(&actorData);

	//LogFunction(actorBaseAddr);

	// Main
	[&]()
	{
		auto pool = *reinterpret_cast<byte8 ***>(appBaseAddr + 0xC90E28);
		if (!pool)
		{
			return;
		}
		pool[3] = actorBaseAddr;
	}();

	// Life
	[&]()
	{
		auto pool = *reinterpret_cast<byte8 ***>(appBaseAddr + 0xC90E10);
		if (!pool)
		{
			return;
		}
		if (!pool[5])
		{
			return;
		}
		*reinterpret_cast<byte8 **>(pool[5] + 0x2CB8) = actorBaseAddr;
	}();

	// Style Data
	[&]()
	{
		auto pool = *reinterpret_cast<byte8 ***>(appBaseAddr + 0xC90E28);
		if (!pool)
		{
			return;
		}
		if (!pool[12])
		{
			return;
		}
		auto dest = *reinterpret_cast<byte8 **>(pool[12]);
		if (!dest)
		{
			return;
		}
		*reinterpret_cast<StyleData **>(dest + 0x3D10) = &actorData.styleData;
	}();
}

export void SetMainActor(uint32 index)
{
	auto actorBaseAddr = Actor_actorBaseAddr[index];if (!actorBaseAddr){ return;}auto & actorData = *reinterpret_cast<ActorData *>(actorBaseAddr) ;

	SetMainActor(actorData);
}















template
<
	typename T1,
	typename T2
>
void CopyState
(
	T1 & activeActorData,
	T2 & idleActorData,
	byte32 flags = 0
)
{
	idleActorData.position       = activeActorData.position;
	idleActorData.pull           = activeActorData.pull;
	idleActorData.pullMultiplier = activeActorData.pullMultiplier;
	idleActorData.rotation       = activeActorData.rotation;

	if (flags & CopyStateFlags_EventData)
	{
		memcpy
		(
			idleActorData.eventData,
			activeActorData.eventData,
			sizeof(idleActorData.eventData)
		);

		memcpy
		(
			idleActorData.var_3E10,
			activeActorData.var_3E10,
			sizeof(idleActorData.var_3E10)
		);
	}
	else if (flags & CopyStateFlags_Mode)
	{
		idleActorData.mode = activeActorData.mode;
	}

	idleActorData.dead = activeActorData.dead;

	idleActorData.kickJumpCount = activeActorData.kickJumpCount;
	idleActorData.wallHikeCount = activeActorData.wallHikeCount;
	idleActorData.airTrickCount = activeActorData.airTrickCount;

	idleActorData.hitPoints      = activeActorData.hitPoints;
	idleActorData.maxHitPoints   = activeActorData.maxHitPoints;
	idleActorData.magicPoints    = activeActorData.magicPoints;
	idleActorData.maxMagicPoints = activeActorData.maxMagicPoints;

	// idleActorData.styleRank  = activeActorData.styleRank;
	// idleActorData.styleMeter = activeActorData.styleMeter;

	idleActorData.styleData.rank     = activeActorData.styleData.rank;
	idleActorData.styleData.meter    = activeActorData.styleData.meter;
	idleActorData.styleData.quotient = activeActorData.styleData.quotient;
	idleActorData.styleData.dividend = activeActorData.styleData.dividend;
	idleActorData.styleData.divisor  = activeActorData.styleData.divisor;








	memcpy
	(
		idleActorData.nextActionRequestPolicy,
		activeActorData.nextActionRequestPolicy,
		sizeof(activeActorData.nextActionRequestPolicy)
	);

	idleActorData.idleTimer = 600.0f;

	idleActorData.permissions = activeActorData.permissions;
	idleActorData.state       = activeActorData.state;
	idleActorData.lastState   = activeActorData.lastState;

	[&]()
	{
		auto actorBaseAddr = Actor_actorBaseAddr[2];if (!actorBaseAddr){ return;}auto & actorData = *reinterpret_cast<ActorData *>(actorBaseAddr) ;

		idleActorData.speedMode = actorData.speedMode;
		idleActorData.quicksilver = actorData.quicksilver;
	}();
}

template<typename T>
void UpdatePermissions(T & actorData)
{
	if (actorData.state & STATE_ON_FLOOR)
	{
		if (actorData.permissions == 0x1C19)
		{
			actorData.permissions = 0x1C1B;
		}
	}
}

template <typename T>
void EndMotion(T & actorData)
{
	actorData.eventData[0].event = 2;
}

template <typename T>
void ToggleInput
(
	T & actorData,
	bool enable
)
{
	actorData.newButtonMask = (enable) ? 0xFFFF : 0;
	actorData.newEnableRightStick = enable;
	actorData.newEnableLeftStick = enable;
}

export template <typename T>
void ToggleActor
(
	T & actorData,
	bool enable
)
{
	actorData.newEnableCollision = enable;

	actorData.newEnableVisibility = enable;

	if (enable)
	{
		actorData.visibility = (g_quicksilver) ? 2 : 1;
	}
	else
	{
		actorData.visibility = 0;
	}

	if
	(
		enable &&
		!actorData.doppelganger
	)
	{
		actorData.shadow = 1;
	}
	else
	{
		actorData.shadow = 0;
	}

	actorData.lastShadow = 0;

	ToggleInput(actorData, enable);
}

export void ToggleActor
(
	uint32 index,
	bool enable
)
{
	auto actorBaseAddr = Actor_actorBaseAddr[index];if (!actorBaseAddr){ return;}auto & actorData = *reinterpret_cast<ActorData *>(actorBaseAddr) ;

	ToggleActor(actorData, enable);
}

template <typename T>
void CommissionActor
(
	T & actorData
	// bool copyState = false
)
{
	LogFunctionHelper(__FUNCTION__, actorData.operator byte8 *()) ;

	auto & playerData = GetPlayerData(actorData);

	if
	(
		//!InCutscene() &&
		(actorData.newCharacterIndex == playerData.activeCharacterIndex) &&
		(actorData.newEntityIndex == ENTITY_MAIN)
	)
	{
		ToggleActor(actorData, true);

		if (actorData.newPlayerIndex == 0)
		{
			SetMainActor(actorData);
		}
	}
	else
	{
		ToggleActor(actorData, false);
	}

	//if (copyState)
	{
		auto actorBaseAddr2 = Actor_actorBaseAddr[0];if (!actorBaseAddr2){ return;}auto & actorData2 = *reinterpret_cast<ActorData *>(actorBaseAddr2) ;

		CopyState
		(
			actorData2,
			actorData,
			CopyStateFlags_EventData | CopyStateFlags_Mode
		);
	}

	if (actorData.mode == ACTOR_MODE_MISSION_19)
	{
		actorData.mode = ACTOR_MODE_DEFAULT;
	}
}


































export template <typename T>
struct GetCharacterId
{
	enum
	{
		value =
		(TypeMatch<T, ActorDataDante >::value) ? CHAR_DANTE  :
		(TypeMatch<T, ActorDataBob   >::value) ? CHAR_BOB    :
		(TypeMatch<T, ActorDataLady  >::value) ? CHAR_LADY   :
		(TypeMatch<T, ActorDataVergil>::value) ? CHAR_VERGIL :
		0
	};
};



// @Todo: Use CharacterData.
// @Todo: 2 or CharacterModelData.
struct CharacterModelData
{
	uint8 character;
	uint8 costume;
	uint16 costumeFileId;
	bool coat;

	template <typename T>
	void Update(T & actorData);
};

// @Todo: Prefer switch for coat.
template <typename T>
void CharacterModelData::Update(T & actorData)
{
	character = (actorData.newForceFiles) ? actorData.newForceFilesCharacter : static_cast<uint8>(actorData.character);
	if (character >= MAX_CHAR)
	{
		character = 0;
	}
	costume = actorData.costume;
	costumeFileId = 0;
	coat = false;

	switch (character)
	{
	case CHAR_DANTE:
	{
		if (costume >= MAX_COSTUME_DANTE)
		{
			costume = 0;
		}
		costumeFileId = costumeFileIdsDante[costume];
		coat =
		(
			(costume == COSTUME_DANTE_DEFAULT                           ) ||
			(costume == COSTUME_DANTE_DEFAULT_TORN                      ) ||
			(costume == COSTUME_DANTE_DMC1                              ) ||
			(costume == COSTUME_DANTE_SPARDA                            ) ||
			(costume == COSTUME_DANTE_DEFAULT_TORN_INFINITE_MAGIC_POINTS) ||
			(costume == COSTUME_DANTE_SPARDA_INFINITE_MAGIC_POINTS      )
		)
		? true : false;
		break;
	}
	case CHAR_BOB:
	{
		if (costume >= MAX_COSTUME_BOB)
		{
			costume = 0;
		}
		costumeFileId = costumeFileIdsBob[costume];
		coat = false; // @Research: Compare coat vars.
		break;
	}
	case CHAR_LADY:
	{
		if (costume >= MAX_COSTUME_LADY)
		{
			costume = 0;
		}
		costumeFileId = costumeFileIdsLady[costume];
		coat = false;
		break;
	}
	case CHAR_VERGIL:
	{
		if (costume >= MAX_COSTUME_VERGIL)
		{
			costume = 0;
		}
		costumeFileId = costumeFileIdsVergil[costume];
		coat =
		(
			(costume == COSTUME_VERGIL_DEFAULT                      ) ||
			(costume == COSTUME_VERGIL_DEFAULT_INFINITE_MAGIC_POINTS) ||
			(costume == COSTUME_VERGIL_NERO_ANGELO                       ) ||
			(costume == COSTUME_VERGIL_NERO_ANGELO_INFINITE_MAGIC_POINTS )
		)
		? true : false;
		break;
	}
	}
}



typedef WeaponData *(__fastcall * RegisterWeapon_t)
(
	byte8 * actorData,
	uint32 weapon
);

RegisterWeapon_t RegisterWeapon[MAX_WEAPON] = {};

void InitRegisterWeapon()
{
	RegisterWeapon[WEAPON_REBELLION        ] = func_2310B0;
	RegisterWeapon[WEAPON_CERBERUS         ] = func_22EC90;
	RegisterWeapon[WEAPON_AGNI_RUDRA       ] = func_227870;
	RegisterWeapon[WEAPON_NEVAN            ] = func_22A1E0;
	RegisterWeapon[WEAPON_BEOWULF_DANTE    ] = func_228CF0;
	RegisterWeapon[WEAPON_EBONY_IVORY      ] = func_22B0C0;
	RegisterWeapon[WEAPON_SHOTGUN          ] = func_2306B0;
	RegisterWeapon[WEAPON_ARTEMIS          ] = func_22C4A0;
	RegisterWeapon[WEAPON_SPIRAL           ] = func_2300A0;
	RegisterWeapon[WEAPON_KALINA_ANN       ] = func_22BA30;
	RegisterWeapon[WEAPON_YAMATO_VERGIL    ] = func_22D960;
	RegisterWeapon[WEAPON_BEOWULF_VERGIL   ] = func_228CF0;
	RegisterWeapon[WEAPON_YAMATO_FORCE_EDGE] = func_2298E0;
	RegisterWeapon[WEAPON_YAMATO_BOB       ] = func_231A30;
}

// @Todo: Move.
void ToggleFixWeaponShadows(bool enable)
{
	LogFunctionHelper(__FUNCTION__, enable) ;

	// Rebellion
	WriteAddress((appBaseAddr + 0x2313A6), (enable) ? (appBaseAddr + 0x2313A8) : (appBaseAddr + 0x231419), 2);
	/*
	dmc3.exe+2313A6 - 75 71    - jne dmc3.exe+231419
	dmc3.exe+2313A8 - 49 8B 10 - mov rdx,[r8]
	*/

	// Cerberus
	WriteAddress((appBaseAddr + 0x22F23C), (enable) ? (appBaseAddr + 0x22F23E) : (appBaseAddr + 0x22F2A3), 2);
	/*
	dmc3.exe+22F23C - 75 65    - jne dmc3.exe+22F2A3
	dmc3.exe+22F23E - 48 8B 11 - mov rdx,[rcx]
	*/

	// Agni & Rudra
	WriteAddress((appBaseAddr + 0x227B6F), (enable) ? (appBaseAddr + 0x227B71) : (appBaseAddr + 0x227BDB), 2);
	/*
	dmc3.exe+227B6F - 75 6A    - jne dmc3.exe+227BDB
	dmc3.exe+227B71 - 48 8B 11 - mov rdx,[rcx]
	*/

	// Nevan
	WriteAddress((appBaseAddr + 0x22A4EC), (enable) ? (appBaseAddr + 0x22A4EE) : (appBaseAddr + 0x22A560), 2);
	/*
	dmc3.exe+22A4EC - 75 72    - jne dmc3.exe+22A560
	dmc3.exe+22A4EE - 49 8B 10 - mov rdx,[r8]
	*/

	// Ebony & Ivory
	WriteAddress((appBaseAddr + 0x22B2FD), (enable) ? (appBaseAddr + 0x22B303) : (appBaseAddr + 0x22B40D), 6);
	/*
	dmc3.exe+22B2FD - 0F85 0A010000 - jne dmc3.exe+22B40D
	dmc3.exe+22B303 - 48 8B 01      - mov rax,[rcx]
	*/

	// Shotgun
	WriteAddress((appBaseAddr + 0x23096E), (enable) ? (appBaseAddr + 0x230974) : (appBaseAddr + 0x230A0D), 6);
	/*
	dmc3.exe+23096E - 0F85 99000000 - jne dmc3.exe+230A0D
	dmc3.exe+230974 - 48 8B 01      - mov rax,[rcx]
	*/

	// Artemis
	WriteAddress((appBaseAddr + 0x22C770), (enable) ? (appBaseAddr + 0x22C776) : (appBaseAddr + 0x22C811), 6);
	/*
	dmc3.exe+22C770 - 0F85 9B000000 - jne dmc3.exe+22C811
	dmc3.exe+22C776 - 49 8B 00      - mov rax,[r8]
	*/

	// Spiral
	WriteAddress((appBaseAddr + 0x23026C), (enable) ? (appBaseAddr + 0x230272) : (appBaseAddr + 0x23030B), 6);
	/*
	dmc3.exe+23026C - 0F85 99000000 - jne dmc3.exe+23030B
	dmc3.exe+230272 - 48 8B 01      - mov rax,[rcx]
	*/

	// Kalina Ann
	WriteAddress((appBaseAddr + 0x22BD2E), (enable) ? (appBaseAddr + 0x22BD30) : (appBaseAddr + 0x22BDA1), 2);
	/*
	dmc3.exe+22BD2E - 75 71    - jne dmc3.exe+22BDA1
	dmc3.exe+22BD30 - 48 8B 11 - mov rdx,[rcx]
	*/

	// Yamato
	WriteAddress((appBaseAddr + 0x22E53B), (enable) ? (appBaseAddr + 0x22E541) : (appBaseAddr + 0x22E5EE), 6);
	/*
	dmc3.exe+22E53B - 0F85 AD000000 - jne dmc3.exe+22E5EE
	dmc3.exe+22E541 - 0FB7 45 78    - movzx eax,word ptr [rbp+78]
	*/

	// Yamato & Force Edge
	WriteAddress((appBaseAddr + 0x229B92), (enable) ? (appBaseAddr + 0x229B94) : (appBaseAddr + 0x229C05), 2);
	/*
	dmc3.exe+229B92 - 75 71    - jne dmc3.exe+229C05
	dmc3.exe+229B94 - 49 8B 10 - mov rdx,[r8]
	*/
}






























/*
agni rudra
dmc3.exe+227B68 - 83 B9 183A0000 01     - cmp dword ptr [rcx+00003A18],01 { 1 }

nevan
dmc3.exe+22A4E4 - 41 83 B8 183A0000 01  - cmp dword ptr [r8+00003A18],01 { 1 }

ebony ivory
dmc3.exe+22B2F6 - 83 B9 183A0000 01     - cmp dword ptr [rcx+00003A18],01 { 1 }

shotgun
dmc3.exe+230967 - 83 B9 183A0000 01     - cmp dword ptr [rcx+00003A18],01 { 1 }

artemis
dmc3.exe+22C768 - 41 83 B8 183A0000 01  - cmp dword ptr [r8+00003A18],01 { 1 }

spiral
dmc3.exe+230265 - 83 B9 183A0000 01     - cmp dword ptr [rcx+00003A18],01 { 1 }

kalina ann
dmc3.exe+22BD27 - 83 B9 183A0000 01     - cmp dword ptr [rcx+00003A18],01 { 1 }

yamato
dmc3.exe+22E534 - 83 B8 183A0000 01     - cmp dword ptr [rax+00003A18],01 { 1 }

yamato force edge
dmc3.exe+229B8A - 41 83 B8 183A0000 01  - cmp dword ptr [r8+00003A18],01 { 1 }
*/




























bool IsDanteMeleeWeapon(uint8 weapon)
{
	if
	(
		(weapon >= WEAPON_REBELLION    ) &&
		(weapon <= WEAPON_BEOWULF_DANTE)
	)
	{
		return true;
	}

	return false;
}

bool IsVergilMeleeWeapon(uint8 weapon)
{
	if
	(
		(weapon >= WEAPON_YAMATO_VERGIL) &&
		(weapon <= WEAPON_YAMATO_FORCE_EDGE   )
	)
	{
		return true;
	}

	return false;
}

bool IsDanteRangedWeapon(uint8 weapon)
{
	if
	(
		(weapon >= WEAPON_EBONY_IVORY) &&
		(weapon <= WEAPON_KALINA_ANN )
	)
	{
		return true;
	}

	return false;
}

bool IsDanteWeapon(uint8 weapon)
{
	if (IsDanteMeleeWeapon(weapon))
	{
		return true;
	}
	else if (IsDanteRangedWeapon(weapon))
	{
		return true;
	}

	return false;
}

bool IsVergilWeapon(uint8 weapon)
{
	if (IsVergilMeleeWeapon(weapon))
	{
		return true;
	}

	return false;
}









template <typename T>
bool IsWeaponActive
(
	T & actorData,
	uint8 weapon
)
{
	auto & motionData = actorData.motionData[UPPER_BODY];

	if (motionData.index == 0)
	{
		return false;
	}

	switch (actorData.character)
	{
		case CHAR_DANTE:
		{

			if (!IsDanteWeapon(weapon))
			{
				return false;
			}

			if (motionData.group == (MOTION_GROUP_DANTE_REBELLION + weapon))
			{
				return true;
			}
			else if (motionData.group == (MOTION_GROUP_DANTE_SWORDMASTER_REBELLION + weapon))
			{
				return true;
			}

			break;
		}
		case CHAR_VERGIL:
		{
			if (!IsVergilWeapon(weapon))
			{
				return false;
			}

			if (motionData.group == (MOTION_GROUP_VERGIL_YAMATO + (weapon - WEAPON_YAMATO_VERGIL)))
			{
				return true;
			}

			break;
		}
	}

	return false;
}

template <typename T>
bool IsWeaponActive(T & actorData)
{
	auto & motionData = actorData.motionData[UPPER_BODY];

	switch (actorData.character)
	{
		case CHAR_DANTE:
		{
			if
			(
				(motionData.group >= MOTION_GROUP_DANTE_REBELLION ) &&
				(motionData.group <= MOTION_GROUP_DANTE_KALINA_ANN) &&
				(motionData.index > 0)
			)
			{
				return true;
			}
			else if
			(
				(motionData.group >= MOTION_GROUP_DANTE_SWORDMASTER_REBELLION) &&
				(motionData.group <= MOTION_GROUP_DANTE_GUNSLINGER_KALINA_ANN)
			)
			{
				return true;
			}

			break;
		}
		case CHAR_BOB:
		{
			if
			(
				(motionData.group == MOTION_GROUP_BOB_YAMATO ) &&
				(motionData.index > 0)
			)
			{
				return true;
			}

			break;
		}
		case CHAR_VERGIL:
		{
			if
			(
				(motionData.group >= MOTION_GROUP_VERGIL_YAMATO    ) &&
				(motionData.group <= MOTION_GROUP_VERGIL_FORCE_EDGE) &&
				(motionData.index > 0)
			)
			{
				return true;
			}
			else if
			(
				(motionData.group >= MOTION_GROUP_VERGIL_NERO_ANGELO_YAMATO ) &&
				(motionData.group <= MOTION_GROUP_VERGIL_NERO_ANGELO_BEOWULF) &&
				(motionData.index > 0)
			)
			{
				return true;
			}

			break;
		}
	}

	return false;
}

template <typename T>
bool IsActive(T & actorData)
{
	auto & motionData = actorData.motionData[UPPER_BODY];

	switch (actorData.character)
	{
		case CHAR_DANTE:
		{
			if (motionData.group == MOTION_GROUP_DANTE_BASE)
			{
				switch (motionData.index)
				{
					case 0:
					case 3:
					{
						return false;
					}
				}

				return true;
			}
			else if
			(
				(motionData.group >= MOTION_GROUP_DANTE_DAMAGE) &&
				(motionData.group <= MOTION_GROUP_DANTE_TAUNTS)
			)
			{
				return true;
			}
			else if (IsWeaponActive(actorData))
			{
				return true;
			}
			else if
			(
				(motionData.group >= MOTION_GROUP_DANTE_TRICKSTER   ) &&
				(motionData.group <= MOTION_GROUP_DANTE_DOPPELGANGER)
			)
			{
				return true;
			}

			break;
		}
		case CHAR_BOB:
		{
			if (motionData.group == MOTION_GROUP_BOB_BASE)
			{
				switch (motionData.index)
				{
					case 0:
					case 3:
					{
						return false;
					}
				}

				return true;
			}
			else if
			(
				(motionData.group >= MOTION_GROUP_BOB_DAMAGE) &&
				(motionData.group <= MOTION_GROUP_BOB_TAUNTS)
			)
			{
				return true;
			}
			else if (IsWeaponActive(actorData))
			{
				return true;
			}

			break;
		}
		case CHAR_LADY:
		{
			if (motionData.group == MOTION_GROUP_LADY_BASE)
			{
				switch (motionData.index)
				{
					case 0:
					case 3:
					{
						return false;
					}
				}

				return true;
			}
			else if
			(
				(motionData.group >= MOTION_GROUP_LADY_DAMAGE) &&
				(motionData.group <= MOTION_GROUP_LADY_TAUNTS)
			)
			{
				return true;
			}

			break;
		}
		case CHAR_VERGIL:
		{
			if (motionData.group == MOTION_GROUP_VERGIL_BASE)
			{
				switch (motionData.index)
				{
					case 0:
					case 3:
					{
						return false;
					}
				}

				return true;
			}
			else if
			(
				(motionData.group >= MOTION_GROUP_VERGIL_DAMAGE) &&
				(motionData.group <= MOTION_GROUP_VERGIL_TAUNTS)
			)
			{
				return true;
			}
			else if (IsWeaponActive(actorData))
			{
				return true;
			}
			else if (motionData.group == MOTION_GROUP_VERGIL_DARK_SLAYER)
			{
				return true;
			}

			break;
		}
	}

	return false;
}

#pragma region IsWeaponReady

bool IsMeleeWeaponReady
(
	ActorData & actorData,
	uint8 weapon
)
{
	if (weapon >= MAX_WEAPON)
	{
		return true;
	}

	switch (actorData.character)
	{
		case CHAR_DANTE:
		{
			if (actorData.devil)
			{
				if (actorData.sparda)
				{
					if (weapon == WEAPON_BEOWULF_DANTE)
					{
						return false;
					}
				}
				else
				{
					if (actorData.activeDevil == weaponDevilIds[weapon])
					{
						return true;
					}
				}
			}
			else
			{
				if ((weapon == WEAPON_BEOWULF_DANTE) && activeConfig.BeowulfDante.hide)
				{
					return false;
				}
			}

			if (IsWeaponActive(actorData, weapon))
			{
				return true;
			}

			for (uint8 index = 0; index < MELEE_WEAPON_COUNT_DANTE; index++)
			{
				uint8 weapon2 = (WEAPON_REBELLION + index);

				if (weapon2 == weapon)
				{
					continue;
				}

				if (IsWeaponActive(actorData, weapon2))
				{
					return false;
				}
			}

			if (actorData.devil && actorData.sparda)
			{
				return false;
			}

			if (actorData.meleeWeaponIndex == weapon)
			{
				return true;
			}

			break;
		}
		case CHAR_VERGIL:
		{
			if (actorData.devil)
			{
				if (actorData.neroAngelo)
				{
					return false;
				}
				else
				{
					if (actorData.activeDevil == weaponDevilIds[weapon])
					{
						return true;
					}
				}
			}
			else
			{
				if ((weapon == WEAPON_BEOWULF_VERGIL) && activeConfig.BeowulfVergil.hide)
				{
					return false;
				}
			}

			if (IsWeaponActive(actorData, weapon))
			{
				return true;
			}

			for (uint8 index = 0; index < MELEE_WEAPON_COUNT_VERGIL; index++)
			{
				uint8 weapon2 = (WEAPON_YAMATO_VERGIL + index);

				if (weapon2 == weapon)
				{
					continue;
				}

				if (IsWeaponActive(actorData, weapon2))
				{
					return false;
				}
			}

			if (actorData.activeMeleeWeaponIndex == (weapon - WEAPON_YAMATO_VERGIL))
			{
				return true;
			}

			break;
		}
	}

	return false;
}

bool IsMeleeWeaponReadyProxy(WeaponData & weaponData)
{
	auto actorBaseAddr = weaponData.actorBaseAddr;
	if (!actorBaseAddr)
	{
		return true;
	}
	auto & actorData = *reinterpret_cast<ActorData *>(actorBaseAddr);

	return IsMeleeWeaponReady(actorData, weaponData.weapon);
}

bool IsRangedWeaponReady
(
	ActorDataDante & actorData,
	uint8 weapon
)
{
	if (IsWeaponActive(actorData, weapon))
	{
		return true;
	}

	for (uint8 index = 0; index < RANGED_WEAPON_COUNT_DANTE; index++)
	{
		uint8 weapon2 = (WEAPON_EBONY_IVORY + index);

		if (weapon2 == weapon)
		{
			continue;
		}

		if (IsWeaponActive(actorData, weapon2))
		{
			return false;
		}
	}

	if (actorData.rangedWeaponIndex == weapon)
	{
		return true;
	}

	return false;
}

bool IsRangedWeaponReadyProxy(WeaponData & weaponData)
{
	if (!weaponData.actorBaseAddr)
	{
		return true;
	}
	auto & actorData = *reinterpret_cast<ActorDataDante *>(weaponData.actorBaseAddr);

	return IsRangedWeaponReady(actorData, weaponData.weapon);
}

void IsMeleeWeaponReadyVergilFix(ActorData & actorData)
{
	if (actorData.activeMeleeWeaponIndex != actorData.queuedMeleeWeaponIndex)
	{
		uint8 weapon = (WEAPON_YAMATO_VERGIL + static_cast<uint8>(actorData.activeMeleeWeaponIndex));

		if (!IsWeaponActive(actorData, weapon))
		{
			actorData.activeMeleeWeaponIndex = actorData.queuedMeleeWeaponIndex;
		}
	}
}

byte8 * IsMeleeWeaponReadyProxyAddr      = 0;
byte8 * IsMeleeWeaponReadyProxyShowAddr  = 0;
byte8 * IsRangedWeaponReadyProxyAddr     = 0;
byte8 * IsRangedWeaponReadyProxyShowAddr = 0;

void InitIsWeaponReady()
{
	LogFunctionHelper(__FUNCTION__) ;

	// Melee
	{
		auto func = CreateFunction(IsMeleeWeaponReadyProxy, 0, true, false);
		IsMeleeWeaponReadyProxyAddr = func.addr;
	}
	{
		constexpr byte8 sect2[] =
		{
			0x84, 0xC0,                   // test al,al
			0x74, 0x05,                   // je short
			0xE9, 0x00, 0x00, 0x00, 0x00, // jmp dmc3.exe+1FDE10
		};
		auto func = CreateFunction(IsMeleeWeaponReadyProxy, 0, true, false, 0, 0, sizeof(sect2));
		memcpy(func.sect2, sect2, sizeof(sect2));
		WriteJump((func.sect2 + 4), (appBaseAddr + 0x1FDE10));
		IsMeleeWeaponReadyProxyShowAddr = func.addr;
	}

	// Ranged
	{
		auto func = CreateFunction(IsRangedWeaponReadyProxy, 0, true, false);
		IsRangedWeaponReadyProxyAddr = func.addr;
	}
	{
		constexpr byte8 sect2[] =
		{
			0x84, 0xC0,                   // test al,al
			0x74, 0x05,                   // je short
			0xE9, 0x00, 0x00, 0x00, 0x00, // jmp dmc3.exe+1FDE10
		};
		auto func = CreateFunction(IsRangedWeaponReadyProxy, 0, true, false, 0, 0, sizeof(sect2));
		memcpy(func.sect2, sect2, sizeof(sect2));
		WriteJump((func.sect2 + 4), (appBaseAddr + 0x1FDE10));
		IsRangedWeaponReadyProxyAddr = func.addr;
	}
}

void ToggleIsWeaponReady(bool enable)
{
	LogFunctionHelper(__FUNCTION__, enable) ;

	// Rebellion
	WriteCall((appBaseAddr + 0x23162E), (enable) ? IsMeleeWeaponReadyProxyAddr : (appBaseAddr + 0x1FD3E0));
	/*
	dmc3.exe+23162E - E8 ADBDFCFF - call dmc3.exe+1FD3E0
	*/

	// Cerberus
	WriteCall((appBaseAddr + 0x22FAD4), (enable) ? IsMeleeWeaponReadyProxyAddr : (appBaseAddr + 0x1FD3E0));
	/*
	dmc3.exe+22FAD4 - E8 07D9FCFF - call dmc3.exe+1FD3E0
	*/

	// Agni & Rudra
	WriteCall((appBaseAddr + 0x2288A4), (enable) ? IsMeleeWeaponReadyProxyAddr : (appBaseAddr + 0x1FD3E0));
	/*
	dmc3.exe+2288A4 - E8 374BFDFF - call dmc3.exe+1FD3E0
	*/

	// Nevan
	WriteCall((appBaseAddr + 0x22AD2D), (enable) ? IsMeleeWeaponReadyProxyAddr : (appBaseAddr + 0x1FD3E0));
	/*
	dmc3.exe+22AD2D - E8 AE26FDFF - call dmc3.exe+1FD3E0
	*/

	// Beowulf
	WriteCall((appBaseAddr + 0x2295B7), (enable) ? IsMeleeWeaponReadyProxyShowAddr : (appBaseAddr + 0x1FDE10));
	/*
	dmc3.exe+2295B7 - E8 5448FDFF - call dmc3.exe+1FDE10
	*/

	// Artemis
	WriteCall((appBaseAddr + 0x22CBC8), (enable) ? IsRangedWeaponReadyProxyAddr : (appBaseAddr + 0x1FDE10));
	/*
	dmc3.exe+22CBC8 - E8 4312FDFF - call dmc3.exe+1FDE10
	*/
}

#pragma endregion







































template <typename T>
bool SystemButtonCheck(T & actorData)
{
	// switch (activeConfig.Actor.system)
	// {
	// 	case ACTOR_SYSTEM_DOPPELGANGER:
	// 	{
	// 		if (actorData.newIndex == ENTITY_MAIN)
	// 		{
	// 			if (actorData.buttons[0] & GetBinding(BINDING_DEFAULT_CAMERA))
	// 			{
	// 				return false;
	// 			}
	// 		}
	// 		else
	// 		{
	// 			if (!(actorData.buttons[0] & GetBinding(BINDING_DEFAULT_CAMERA)))
	// 			{
	// 				return false;
	// 			}
	// 		}

	// 		break;
	// 	}
	// 	case ACTOR_SYSTEM_CHARACTER_SWITCHER:
	// 	{
	// 		if (actorData.buttons[0] & GetBinding(BINDING_DEFAULT_CAMERA))
	// 		{
	// 			return false;
	// 		}

	// 		break;
	// 	}
	// }

	return true;
}




template <typename T>
bool IsNeroAngelo(T & actorData)
{
	return
	(
		(actorData.character == CHAR_VERGIL) &&
		actorData.neroAngelo &&
		actorData.devil
	);
}













#pragma endregion

#pragma region File

struct FileDataHelper
{
	uint16 fileDataId;
	uint16 fileId;
};

constexpr FileDataHelper fileDataHelperDante[] =
{
	{ 0  , pl000         },
	{ 200, pl005         },
	{ 201, pl006         },
	{ 202, pl007         },
	{ 203, pl008         },
	{ 204, pl009         },
	{ 205, pl017         },
	{ 140, plwp_sword    },
	{ 141, plwp_nunchaku },
	{ 142, plwp_2sword   },
	{ 143, plwp_guitar   },
	{ 144, plwp_fight    },
	{ 145, plwp_gun      },
	{ 146, plwp_shotgun  },
	{ 147, plwp_laser    },
	{ 148, plwp_rifle    },
	{ 149, plwp_ladygun  },
};

constexpr FileDataHelper fileDataHelperBob[] =
{
	{ 1  , pl001            },
	{ 207, pl010            },
	{ 169, plwp_vergilsword },
};

constexpr FileDataHelper fileDataHelperLady[] =
{
	{ 2, pl002 },
};

constexpr FileDataHelper fileDataHelperVergil[] =
{
	{ 3  , pl021               },
	{ 221, pl010               },
	{ 222, pl014               },
	{ 223, pl025               },
	{ 196, plwp_newvergilsword },
	{ 189, plwp_newvergilfight },
	{ 198, plwp_forceedge      },
	{ 187, plwp_nerosword      },
};

template<uint8 itemCount>
void UpdateFileDataFunction(const FileDataHelper(&items)[itemCount])
{
	for (uint8 itemIndex = 0; itemIndex < itemCount; itemIndex++)
	{
		File_UpdateFileData
		(
			items[itemIndex].fileDataId,
			items[itemIndex].fileId
		);
	}
}

template <typename T>
void UpdateFileData(T & actorData)
{
	if constexpr (TypeMatch<T, ActorDataDante>::value)
	{
		UpdateFileDataFunction(fileDataHelperDante);
	}
	else if constexpr (TypeMatch<T, ActorDataBob>::value)
	{
		UpdateFileDataFunction(fileDataHelperBob);
	}
	else if constexpr (TypeMatch<T, ActorDataLady>::value)
	{
		UpdateFileDataFunction(fileDataHelperLady);
	}
	else if constexpr (TypeMatch<T, ActorDataVergil>::value)
	{
		UpdateFileDataFunction(fileDataHelperVergil);
	}
}

template <typename T>
void UpdateCostumeFileData(T & actorData)
{
	auto & sessionData = *reinterpret_cast<SessionData *>(appBaseAddr + 0xC8F250) ;

	CharacterModelData characterData;

	characterData.Update(actorData);

	auto & character     = characterData.character;
	auto & costume       = characterData.costume;
	auto & costumeFileId = characterData.costumeFileId;
	auto & coat          = characterData.coat;

	File_UpdateFileData(static_cast<uint16>(character), costumeFileId);

	if constexpr (TypeMatch<T, ActorDataDante>::value)
	{
		uint16 swordFileId = plwp_sword;

		if (sessionData.unlockDevilTrigger)
		{
			swordFileId = plwp_sword2;
		}

		if (actorData.sparda)
		{
			swordFileId = plwp_sword3;
		}

		File_UpdateFileData(140, swordFileId);
	}
}

#pragma endregion

#pragma region Actor Management

template <typename T>
void InitActor
(
	T & actorData,
	ActiveMissionActorData & activeMissionActorData
)
{
	if constexpr      (TypeMatch<T, ActorDataDante >::value) { func_217B90(actorData, activeMissionActorData); }
	else if constexpr (TypeMatch<T, ActorDataBob   >::value) { func_226F10(actorData, activeMissionActorData); }
	else if constexpr (TypeMatch<T, ActorDataLady  >::value) { func_219660(actorData, activeMissionActorData); }
	else if constexpr (TypeMatch<T, ActorDataVergil>::value) { func_223CB0(actorData, activeMissionActorData); }
}

template <typename T>
void UpdateActor(T & actorData)
{
	if constexpr      (TypeMatch<T, ActorDataDante >::value) { func_212BE0(actorData); }
	else if constexpr (TypeMatch<T, ActorDataBob   >::value) { func_225D70(actorData); }
	else if constexpr (TypeMatch<T, ActorDataLady  >::value) { func_219260(actorData); }
	else if constexpr (TypeMatch<T, ActorDataVergil>::value) { func_220970(actorData); }
}

template <typename T>
void InitModel
(
	T & actorData,
	uint32 modelIndex
)
{
	func_8A000
	(
		actorData.newModelData[modelIndex],
		actorData.motionArchives[0],
		actorData.newModelPhysicsMetadataPool[modelIndex]
	);

	actorData.newModelData[modelIndex].Motion.init = false;

	// Not sure if required, but legit.
	{
		auto dest = reinterpret_cast<byte8 *>(actorData.newModelPhysicsMetadataPool[0][(1 + modelIndex)]);
		*reinterpret_cast<RecoveryData **>(dest + 0x100) = &actorData.newRecoveryData[modelIndex];
	}

	auto & recoveryData = actorData.newRecoveryData[modelIndex];
	recoveryData.init = false;
	memset(recoveryData.data, 0, 32);

	auto file = File_staticFiles[pl000][5]; // @Todo: Update.

	func_594B0
	(
		actorData.newBodyPartData[modelIndex][UPPER_BODY],
		file,
		UPPER_BODY,
		0,
		actorData.motionArchives,
		&actorData.newModelData[modelIndex].functions,
		actorData.newModelPhysicsMetadataPool[modelIndex],
		&actorData.motionSpeed,
		&actorData.collisionData
	);

	func_594B0
	(
		actorData.newBodyPartData[modelIndex][LOWER_BODY],
		file,
		LOWER_BODY,
		0,
		actorData.motionArchives,
		&actorData.newModelData[modelIndex].functions,
		actorData.newModelPhysicsMetadataPool[modelIndex],
		&actorData.motionSpeed,
		0
	);

	auto dest = func_8A520(actorData.newModelData[modelIndex]);
	func_30E630(dest, 0);
}

template <typename T>
void UpdateModel(T & actorData)
{
	if constexpr (false )
	{
		LogFunctionHelper(__FUNCTION__, actorData.operator byte8 *()) ;
	}

	CharacterModelData characterModelData;

	characterModelData.Update(actorData);

	auto & character     = characterModelData.character;
	auto & costume       = characterModelData.costume;
	auto & costumeFileId = characterModelData.costumeFileId;
	auto & coat          = characterModelData.coat;

	auto & file = File_staticFiles[costumeFileId];

	byte8 * modelFile   = 0;
	byte8 * textureFile = 0;
	byte8 * shadowFile  = 0;
	byte8 * physicsFile = 0;

	uint8 modelIndex    = 0;
	uint8 submodelIndex = 0;

	// Main

	modelFile   = file[1];
	textureFile = file[0];
	shadowFile  = file[8];

	if ((character == CHAR_LADY) && (costume == COSTUME_LADY_LEATHER_JUMPSUIT))
	{
		modelFile   = file[32];
		textureFile = file[31];
		shadowFile  = file[16];
	}

	RegisterModel
	(
		actorData.newModelData[modelIndex],
		modelFile,
		textureFile
	);

	RegisterShadow
	(
		actorData.newModelData[modelIndex],
		actorData.newModelShadowData[modelIndex],
		shadowFile
	);

	{
		auto g_vertices = reinterpret_cast<vec4 *>(appBaseAddr + 0x58B260);

		for (uint8 index = 0; index < 6; index++)
		{
			uint8 off = (index * 3);
			actorData.modelMetadata[index].count = 4;
			actorData.modelMetadata[index].vertices[0] = g_vertices[(off + 0)];
			actorData.modelMetadata[index].vertices[1] = g_vertices[(off + 1)];
			actorData.modelMetadata[index].vertices[2] = g_vertices[(off + 2)];
		}
	}

	// Coat

	modelFile   = file[12];
	textureFile = file[0 ];
	//shadowFile  = (coat) ? file[14] : 0;
	shadowFile  = file[14];
	physicsFile = file[13];

	if ((character == CHAR_LADY) && (costume == COSTUME_LADY_LEATHER_JUMPSUIT))
	{
		modelFile   = file[17];
		textureFile = file[31];
		physicsFile = file[18];
	}

	RegisterModel
	(
		actorData.newSubmodelData[submodelIndex],
		modelFile,
		textureFile
	);

	func_8A000
	(
		actorData.newSubmodelData[submodelIndex],
		0,
		&actorData.submodelPhysicsMetadataPool[0]
	);

	if ((character == CHAR_LADY))
	{
		return;
	}

	if (coat && shadowFile)
	{
		RegisterShadow
		(
			actorData.newSubmodelData[submodelIndex],
			actorData.newSubmodelShadowData[submodelIndex],
			shadowFile
		);
	}

	actorData.newSubmodelInit[submodelIndex] = true;

	RegisterPhysics
	(
		physicsFile,
		&actorData.submodelPhysicsData,
		&actorData.submodelPhysicsMetadataPool[0]
	);

	func_2CA2F0
	(
		actorData.submodelPhysicsData,
		actorData.newModelPhysicsMetadataPool[modelIndex],
		(appBaseAddr + ((coat) ? 0x58B380 : 0x58B054)),
		actorData.modelMetadata,
		(coat) ? 6 : 1
	);

	if (coat)
	{
		auto g_vertices = reinterpret_cast<vec4 *>(appBaseAddr + 0x35D580);
		auto & submodelPhysicsMetadata = *actorData.submodelPhysicsMetadataPool[0];

		submodelPhysicsMetadata.vertices[0] = g_vertices[0];
		submodelPhysicsMetadata.vertices[1] = g_vertices[1];
		submodelPhysicsMetadata.vertices[2] = g_vertices[2];
		submodelPhysicsMetadata.vertices[3] = g_vertices[3];
	}
	else
	{
		auto g_vertices = reinterpret_cast<vec4 *>(appBaseAddr + 0x58B260);

		actorData.modelMetadata[0].count = 4;
		actorData.modelMetadata[0].vertices[0] = g_vertices[23];
		actorData.modelMetadata[0].vertices[1] = g_vertices[24];
		actorData.modelMetadata[0].vertices[2] = g_vertices[25];
	}
}

template <typename T>
void UpdateDevilModel
(
	T & actorData,
	uint8 devil,
	uint8 devilModelIndex
)
{
	if constexpr (false )
	{
		LogFunctionHelper(__FUNCTION__, actorData.operator byte8 *()) ;
	}

	auto devilFileId = devilFileIdsDante[devil];

	auto & file = File_staticFiles[devilFileId];

	byte8 * modelFile = 0;
	byte8 * textureFile = 0;
	byte8 * shadowFile = 0;
	byte8 * physicsFile = 0;

	//uint8 modelIndex = (devilModelIndex == 0) ? 1 : 2;
	//uint8 submodelIndex = (devilModelIndex == 0) ? 1 : 3;
	//uint8 devilSubmodelIndex = (devilModelIndex == 0) ? 0 : 2;

	auto & devilModelMetadata = actorData.devilModelMetadata[devil];

	uint8 modelIndex = (1 + devilModelIndex);
	uint8 submodelIndex = (1 + (devilModelIndex * 2));
	uint8 devilSubmodelIndex = (devilModelIndex * 2);

	uint8 modelPhysicsMetadataIndex = 0;
	uint8 devilModelPhysicsMetadataIndex = 0;

	// @Todo: Update.
	auto LinkModelPhysicsData = [&]
	(
		uint8 _devilSubmodelPhysicsLinkDataIndex,
		uint8 _modelPhysicsMetadataIndex,
		uint8 _devilModelPhysicsMetadataIndex
	)
	{
		auto & devilSubmodelPhysicsLinkData = actorData.newDevilSubmodelPhysicsLinkData[devilSubmodelIndex][_devilSubmodelPhysicsLinkDataIndex];

		auto modelPhysicsMetadataAddr = actorData.newModelPhysicsMetadataPool[modelIndex][(modelPhysicsMetadataIndex + _modelPhysicsMetadataIndex)];
		if (!modelPhysicsMetadataAddr)
		{
			Log("LinkModelPhysicsData failed.");
			Log("modelPhysicsMetadataAddr");
			return;
		}
		auto & modelPhysicsMetadata = *modelPhysicsMetadataAddr;

		auto devilModelPhysicsMetadataAddr = actorData.newDevilModelPhysicsMetadataPool[devilModelIndex][(devilModelPhysicsMetadataIndex + _devilModelPhysicsMetadataIndex)];
		if (!devilModelPhysicsMetadataAddr)
		{
			Log("LinkModelPhysicsData failed.");
			Log("devilModelPhysicsMetadataAddr");
			return;
		}
		auto & devilPhysicsMetadata = *devilModelPhysicsMetadataAddr;

		devilSubmodelPhysicsLinkData.enable = 1;
		devilSubmodelPhysicsLinkData.physicsData = modelPhysicsMetadata.physicsData;
		memcpy(devilSubmodelPhysicsLinkData.data, (appBaseAddr + 0x35D580), 64);

		devilPhysicsMetadata.physicsLinkData = &devilSubmodelPhysicsLinkData;
	};

	actorData.newDevilModels[modelIndex] = devil;

	// Main

	modelFile = file[1];
	textureFile = file[0];

	if (devil == DEVIL_AGNI_RUDRA)
	{
		shadowFile = file[2];
	}
	else if
	(
		(devil == DEVIL_CERBERUS) ||
		(devil == DEVIL_BEOWULF ) ||
		(devil == DEVIL_SPARDA  )
	)
	{
		shadowFile = file[4];
	}
	else if
	(
		(devil == DEVIL_REBELLION) ||
		(devil == DEVIL_NEVAN    )
	)
	{
		shadowFile = file[6];
	}

	RegisterModel
	(
		actorData.newModelData[modelIndex],
		modelFile,
		textureFile
	);

	InitModel
	(
		actorData,
		modelIndex
	);

	RegisterShadow
	(
		actorData.newModelData[modelIndex],
		actorData.newModelShadowData[modelIndex],
		shadowFile
	);

	devilModelMetadata.modelIndex = modelIndex;
	devilModelMetadata.modelPhysicsMetadataIndex = ((modelIndex * 24) + modelPhysicsMetadataIndex);

	if (devil == DEVIL_AGNI_RUDRA)
	{
		return;
	}

	// Wings

	modelFile   = file[2];
	textureFile = file[0];
	physicsFile = file[3];

	if
	(
		(devil == DEVIL_REBELLION) ||
		(devil == DEVIL_NEVAN    )
	)
	{
		shadowFile = file[7];
	}
	else if
	(
		(devil == DEVIL_CERBERUS) ||
		(devil == DEVIL_BEOWULF ) ||
		(devil == DEVIL_SPARDA  )
	)
	{
		shadowFile = file[5];
	}

	RegisterModel
	(
		actorData.newSubmodelData[submodelIndex],
		modelFile,
		textureFile
	);

	func_8A000
	(
		actorData.newSubmodelData[submodelIndex],
		0,
		&actorData.newDevilModelPhysicsMetadataPool[devilModelIndex][devilModelPhysicsMetadataIndex]
	);

	RegisterShadow
	(
		actorData.newSubmodelData[submodelIndex],
		actorData.newSubmodelShadowData[submodelIndex],
		shadowFile
	);

	actorData.newSubmodelInit[submodelIndex] = true;

	RegisterPhysics
	(
		physicsFile,
		&actorData.newDevilSubmodelPhysicsData[devilSubmodelIndex],
		&actorData.newDevilModelPhysicsMetadataPool[devilModelIndex][devilModelPhysicsMetadataIndex]
	);

	if
	(
		(devil == DEVIL_REBELLION) ||
		(devil == DEVIL_NEVAN    )
	)
	{
		LinkModelPhysicsData(0, 3, 1 );
		LinkModelPhysicsData(1, 2, 12);
	}
	else if
	(
		(devil == DEVIL_CERBERUS) ||
		(devil == DEVIL_BEOWULF )
	)
	{
		LinkModelPhysicsData(0, 3 , 1);
		LinkModelPhysicsData(1, 6 , 2);
		LinkModelPhysicsData(2, 10, 8);
	}

	devilModelMetadata.devilSubmodelMetadata[0].submodelIndex = submodelIndex;
	devilModelMetadata.devilSubmodelMetadata[0].devilModelPhysicsMetadataIndex = ((devilModelIndex * 36) + devilModelPhysicsMetadataIndex);
	devilModelMetadata.devilSubmodelMetadata[0].devilSubmodelIndex = devilSubmodelIndex;

	submodelIndex++;
	devilModelPhysicsMetadataIndex += 9;
	devilSubmodelIndex++;

	// Coat

	if
	(
	!(
		(devil == DEVIL_REBELLION) ||
		(devil == DEVIL_NEVAN    )
	)
	)
	{
		return;
	}

	modelFile   = file[4];
	textureFile = file[0];
	shadowFile  = file[8];
	physicsFile = file[5];

	RegisterModel
	(
		actorData.newSubmodelData[submodelIndex],
		modelFile,
		textureFile
	);

	func_8A000
	(
		actorData.newSubmodelData[submodelIndex],
		0,
		&actorData.newDevilModelPhysicsMetadataPool[devilModelIndex][devilModelPhysicsMetadataIndex]
	);

	RegisterShadow
	(
		actorData.newSubmodelData[submodelIndex],
		actorData.newSubmodelShadowData[submodelIndex],
		shadowFile
	);

	actorData.newSubmodelInit[submodelIndex] = true;

	RegisterPhysics
	(
		physicsFile,
		&actorData.newDevilSubmodelPhysicsData[devilSubmodelIndex],
		&actorData.newDevilModelPhysicsMetadataPool[devilModelIndex][devilModelPhysicsMetadataIndex]
	);

	func_2CA2F0
	(
		actorData.newDevilSubmodelPhysicsData[devilSubmodelIndex],
		actorData.newModelPhysicsMetadataPool[modelIndex],
		(appBaseAddr + 0x58B380),
		actorData.modelMetadata,
		6
	);

	LinkModelPhysicsData(0, 2 , 1);
	LinkModelPhysicsData(1, 14, 2);

	devilModelMetadata.devilSubmodelMetadata[1].submodelIndex = submodelIndex;
	devilModelMetadata.devilSubmodelMetadata[1].devilModelPhysicsMetadataIndex = ((devilModelIndex * 36) + devilModelPhysicsMetadataIndex);
	devilModelMetadata.devilSubmodelMetadata[1].devilSubmodelIndex = devilSubmodelIndex;
}

void UpdateModelPartitions(ActorData & actorData)
{
	auto & sessionData = *reinterpret_cast<SessionData *>(appBaseAddr + 0xC8F250) ;

	CharacterModelData characterModelData;

	characterModelData.Update(actorData);

	auto & character     = characterModelData.character;
	auto & costume       = characterModelData.costume;
	auto & costumeFileId = characterModelData.costumeFileId;
	auto & coat          = characterModelData.coat;

	auto modelPartitionData = actorData.newModelData[0].modelPartitionData;
	if (!modelPartitionData)
	{
		return;
	}

	bool beowulf = false;

	switch (actorData.character)
	{
		case CHAR_DANTE:
		{
			beowulf = IsMeleeWeaponReady(actorData, WEAPON_BEOWULF_DANTE);

			break;
		}
		case CHAR_VERGIL:
		{
			beowulf = IsMeleeWeaponReady(actorData, WEAPON_BEOWULF_VERGIL);

			break;
		}
	}

	switch (character)
	{
		case CHAR_DANTE:
		{
			switch (costume)
			{
				case COSTUME_DANTE_DEFAULT:
				{
					modelPartitionData[0 ].value = (beowulf) ? 2 : 3; // Hands
					modelPartitionData[1 ].value = (beowulf) ? 3 : 2; // Fists
					modelPartitionData[2 ].value = 3; // Shoulders
					modelPartitionData[3 ].value = (beowulf) ? 2 : 3; // Lower Arms
					modelPartitionData[4 ].value = (beowulf) ? 3 : 2; // Lower Arms Half
					modelPartitionData[5 ].value = (beowulf) ? 3 : 2; // Lower Legs Half
					modelPartitionData[6 ].value = (beowulf) ? 2 : 3; // Lower Legs and Feet
					modelPartitionData[7 ].value = 3; // Upper Legs
					modelPartitionData[8 ].value = 3; // Accessories
					modelPartitionData[9 ].value = 3; // Upper Body
					modelPartitionData[10].value = 3; // Face
					modelPartitionData[11].value = 3; // Hair Base
					modelPartitionData[12].value = 3; // Hair Back Layer 1
					modelPartitionData[13].value = 3; // Hair Back Layer 2
					modelPartitionData[14].value = 3; // Hair Sides
					modelPartitionData[15].value = 3; // Hair Back Layer 3
					modelPartitionData[16].value = 3; // Hair Main

					break;
				}
				case COSTUME_DANTE_DEFAULT_NO_COAT:
				{
					modelPartitionData[0 ].value = (beowulf) ? 2 : 3; // Hands
					modelPartitionData[1 ].value = (beowulf) ? 3 : 2; // Fists
					modelPartitionData[2 ].value = 3; // Upper Body
					modelPartitionData[3 ].value = 2; // Filler
					modelPartitionData[4 ].value = 2; // Filler
					modelPartitionData[5 ].value = (beowulf) ? 3 : 2; // Lower Legs Half
					modelPartitionData[6 ].value = (beowulf) ? 2 : 3; // Lower Legs and Feet
					modelPartitionData[7 ].value = 3; // Upper Legs
					modelPartitionData[8 ].value = 3; // Accessories
					modelPartitionData[9 ].value = 3; // Face
					modelPartitionData[10].value = 3; // Hair Base
					modelPartitionData[11].value = 3; // Hair Back Layer 1
					modelPartitionData[12].value = 3; // Hair Back Layer 2
					modelPartitionData[13].value = 3; // Hair Sides
					modelPartitionData[14].value = 3; // Hair Back Layer 3
					modelPartitionData[15].value = 3; // Hair Main

					break;
				}
				case COSTUME_DANTE_DEFAULT_TORN:
				case COSTUME_DANTE_DEFAULT_TORN_INFINITE_MAGIC_POINTS:
				{
					modelPartitionData[0 ].value = (beowulf) ? 2 : 3; // Hands
					modelPartitionData[1 ].value = (beowulf) ? 3 : 2; // Fists
					modelPartitionData[2 ].value = 3; // Shoulders
					modelPartitionData[3 ].value = (beowulf) ? 2 : 3; // Lower Arms
					modelPartitionData[4 ].value = (beowulf) ? 3 : 2; // Lower Arms Half
					modelPartitionData[5 ].value = (beowulf) ? 3 : 2; // Lower Legs Half
					modelPartitionData[6 ].value = (beowulf) ? 2 : 3; // Lower Legs and Feet
					modelPartitionData[7 ].value = 3; // Upper Legs
					modelPartitionData[8 ].value = 3; // Accessories
					modelPartitionData[9 ].value = 3; // Upper Body
					modelPartitionData[10].value = 3; // Lower Right Arm
					modelPartitionData[11].value = 3; // Face
					modelPartitionData[12].value = 3; // Hair Base
					modelPartitionData[13].value = 3; // Hair Back Layer 1
					modelPartitionData[14].value = 3; // Hair Back Layer 2
					modelPartitionData[15].value = 3; // Hair Sides
					modelPartitionData[16].value = 3; // Hair Back Layer 3
					modelPartitionData[17].value = 3; // Hair Main

					break;
				}
				case COSTUME_DANTE_DMC1:
				{
					modelPartitionData[0 ].value = (beowulf) ? 2 : 3; // Hands
					modelPartitionData[1 ].value = (beowulf) ? 3 : 2; // Fists
					modelPartitionData[2 ].value = 3; // Shoulders and Arms
					modelPartitionData[3 ].value = 2; // Filler
					modelPartitionData[4 ].value = 2; // Filler
					modelPartitionData[5 ].value = (beowulf) ? 3 : 2; // Lower Legs Half
					modelPartitionData[6 ].value = (beowulf) ? 2 : 3; // Lower Legs and Feet
					modelPartitionData[7 ].value = 3; // Upper Legs
					modelPartitionData[8 ].value = 3; // Vest
					modelPartitionData[9 ].value = 3; // Upper Body
					modelPartitionData[10].value = 3; // Face
					modelPartitionData[11].value = 3; // Hair Base
					modelPartitionData[12].value = 3; // Hair Back Layer 1
					modelPartitionData[13].value = 3; // Hair Back Layer 2
					modelPartitionData[14].value = 3; // Hair Back Layer 3
					modelPartitionData[15].value = 3; // Hair Main

					break;
				}
				case COSTUME_DANTE_DMC1_NO_COAT:
				{
					modelPartitionData[0 ].value = (beowulf) ? 2 : 3; // Hands
					modelPartitionData[1 ].value = (beowulf) ? 3 : 2; // Fists
					modelPartitionData[2 ].value = 3; // Upper Body
					modelPartitionData[3 ].value = 2; // Filler
					modelPartitionData[4 ].value = 2; // Filler
					modelPartitionData[5 ].value = (beowulf) ? 3 : 2; // Lower Legs Half
					modelPartitionData[6 ].value = (beowulf) ? 2 : 3; // Lower Legs and Feet
					modelPartitionData[7 ].value = 3; // Upper Legs
					modelPartitionData[8 ].value = 3; // Collar
					modelPartitionData[9 ].value = 3; // Face
					modelPartitionData[10].value = 3; // Hair Base
					modelPartitionData[11].value = 3; // Hair Back Layer 1
					modelPartitionData[12].value = 3; // Hair Back Layer 2
					modelPartitionData[13].value = 3; // Hair Back Layer 3
					modelPartitionData[14].value = 3; // Hair Main

					break;
				}
				case COSTUME_DANTE_SPARDA:
				case COSTUME_DANTE_SPARDA_INFINITE_MAGIC_POINTS:
				{
					modelPartitionData[0 ].value = (beowulf) ? 2 : 3; // Hands
					modelPartitionData[1 ].value = (beowulf) ? 3 : 2; // Fists
					modelPartitionData[2 ].value = 3; // Shoulders
					modelPartitionData[3 ].value = (beowulf) ? 2 : 3; // Lower Arms
					modelPartitionData[4 ].value = (beowulf) ? 3 : 2; // Lower Arms Half
					modelPartitionData[5 ].value = (beowulf) ? 3 : 2; // Lower Legs Half
					modelPartitionData[6 ].value = (beowulf) ? 2 : 3; // Lower Legs and Feet
					modelPartitionData[7 ].value = 3; // Upper Legs
					modelPartitionData[8 ].value = 3; // Upper Body
					modelPartitionData[9 ].value = 3; // Monocle
					modelPartitionData[10].value = 3; // Collar
					modelPartitionData[11].value = 3; // Neck
					modelPartitionData[12].value = 3; // Face
					modelPartitionData[13].value = 3; // Hair
					
					break;
				}
			}

			break;
		}
		case CHAR_LADY:
		{
			switch (costume)
			{
				case COSTUME_LADY_DEFAULT:
				{
					modelPartitionData[0].value = 3; // Body
					modelPartitionData[1].value = 3; // Face
					modelPartitionData[2].value = 3; // Hands
					modelPartitionData[3].value = 3; // Accessories
					modelPartitionData[4].value = (sessionData.mission >= 14) ? 3 : 2; // Bandage

					break;
				}
				case COSTUME_LADY_LEATHER_JUMPSUIT:
				{
					modelPartitionData[0].value = 3; // Body
					modelPartitionData[1].value = 3; // Face
					modelPartitionData[2].value = 3; // Hands
					modelPartitionData[3].value = 3; // Accessories
					modelPartitionData[4].value = 2; // Millenium Puzzle
					modelPartitionData[5].value = 3; // Feet
					modelPartitionData[6].value = 3; // Belt
					modelPartitionData[7].value = 3; // Zippers

					break;
				}
			}

			break;
		}
		case CHAR_VERGIL:
		{
			switch (costume)
			{
				case COSTUME_VERGIL_DEFAULT:
				case COSTUME_VERGIL_DEFAULT_INFINITE_MAGIC_POINTS:
				{
					modelPartitionData[0 ].value = 3; // Body
					modelPartitionData[1 ].value = 3; // Shoulders
					modelPartitionData[2 ].value = (beowulf) ? 2 : 3; // Hands
					modelPartitionData[3 ].value = 3; // Face
					modelPartitionData[4 ].value = (beowulf) ? 3 : 2; // Fists
					modelPartitionData[5 ].value = 3; // Hair Base
					modelPartitionData[6 ].value = 3; // Hair Main
					modelPartitionData[7 ].value = (beowulf) ? 3 : 2; // Lower Legs Half
					modelPartitionData[8 ].value = (beowulf) ? 2 : 3; // Lower Legs and Feet
					modelPartitionData[9 ].value = (beowulf) ? 3 : 2; // Lower Arms Half
					modelPartitionData[10].value = (beowulf) ? 2 : 3; // Lower Arms

					break;
				}
				case COSTUME_VERGIL_DEFAULT_NO_COAT:
				{
					modelPartitionData[0 ].value = 3; // Body
					modelPartitionData[1 ].value = 3; // Arms
					modelPartitionData[2 ].value = (beowulf) ? 2 : 3; // Hands
					modelPartitionData[3 ].value = 3; // Face
					modelPartitionData[4 ].value = (beowulf) ? 3 : 2; // Fists
					modelPartitionData[5 ].value = 3; // Hair Base
					modelPartitionData[6 ].value = 3; // Hair Main
					modelPartitionData[7 ].value = (beowulf) ? 3 : 2; // Lower Legs Half
					modelPartitionData[8 ].value = (beowulf) ? 2 : 3; // Lower Legs and Feet
					modelPartitionData[9 ].value = 2; // Filler
					modelPartitionData[10].value = 2; // Filler

					break;
				}
				case COSTUME_VERGIL_NERO_ANGELO:
				case COSTUME_VERGIL_NERO_ANGELO_INFINITE_MAGIC_POINTS:
				{
					modelPartitionData[0 ].value = 3; // Neck
					modelPartitionData[1 ].value = 3; // Face
					modelPartitionData[2 ].value = (beowulf) ? 2 : 3; // Hands
					modelPartitionData[3 ].value = 3; // Eyes
					modelPartitionData[4 ].value = (beowulf) ? 3 : 2; // Fists
					modelPartitionData[5 ].value = 3; // Hair Base
					modelPartitionData[6 ].value = 3; // Hair Main
					modelPartitionData[7 ].value = (beowulf) ? 3 : 2; // Lower Legs Half
					modelPartitionData[8 ].value = (beowulf) ? 2 : 3; // Lower Legs and Feet
					modelPartitionData[9 ].value = (beowulf) ? 3 : 2; // Lower Arms Half
					modelPartitionData[10].value = (beowulf) ? 2 : 3; // Lower Arms
					modelPartitionData[11].value = 3; // Collar
					modelPartitionData[12].value = 3; // Lower Legs
					modelPartitionData[13].value = 3; // Shoulders
					modelPartitionData[14].value = 3; // Body

					break;
				}
			}

			break;
		}
	}
}

















void UpdateActorDante(ActorDataDante & actorData)
{
	LogFunctionHelper(__FUNCTION__, actorData.operator byte8 *()) ;

	actorData.devilModelMetadata.Rebellion.devilSubmodelMetadata[0].submodelIndex = 255;
	actorData.devilModelMetadata.Rebellion.devilSubmodelMetadata[1].submodelIndex = 255;
	actorData.devilModelMetadata.Cerberus.devilSubmodelMetadata.submodelIndex = 255;
	actorData.devilModelMetadata.Nevan.devilSubmodelMetadata[0].submodelIndex = 255;
	actorData.devilModelMetadata.Nevan.devilSubmodelMetadata[1].submodelIndex = 255;
	actorData.devilModelMetadata.Beowulf.devilSubmodelMetadata.submodelIndex = 255;
	actorData.devilModelMetadata.Sparda.devilSubmodelMetadata.submodelIndex = 255;
	/*
	dmc3.exe+212C20 - C6 81 02B60000 FF - mov byte ptr [rcx+0000B602],-01
	dmc3.exe+212C2B - C6 81 05B60000 FF - mov byte ptr [rcx+0000B605],-01
	dmc3.exe+212C32 - C6 81 0AB60000 FF - mov byte ptr [rcx+0000B60A],-01
	dmc3.exe+212C39 - C6 81 11B60000 FF - mov byte ptr [rcx+0000B611],-01
	dmc3.exe+212C40 - C6 81 14B60000 FF - mov byte ptr [rcx+0000B614],-01
	dmc3.exe+212C47 - C6 81 19B60000 FF - mov byte ptr [rcx+0000B619],-01
	dmc3.exe+212C4E - C6 81 1EB60000 FF - mov byte ptr [rcx+0000B61E],-01
	*/

	UpdateModel(actorData);

	func_1EF040(actorData, 0);
	func_1EEF80(actorData);
	func_1EF040(actorData, 3);

	if (actorData.sparda)
	{
		UpdateDevilModel(actorData, DEVIL_SPARDA, 0);
	}
	else
	{
		for (uint8 index = 0; index < 5; index++)
		{
			UpdateDevilModel(actorData, (DEVIL_REBELLION + index), index);
		}
	}

	// func_2EE060(actorData.var_6410, 60);
	// /*
	// dmc3.exe+2134C6 - 48 8D 8E 10640000 - lea rcx,[rsi+00006410]
	// dmc3.exe+2134CD - BA 3C000000       - mov edx,0000003C
	// dmc3.exe+2134D2 - E8 89AB0D00       - call dmc3.exe+2EE060
	// */

	// func_2C6150(actorData.var_6458, 0x49000, -2);
	// /*
	// dmc3.exe+214B37 - 48 8D 8E 58640000 - lea rcx,[rsi+00006458]
	// dmc3.exe+214B3E - BA 00900400       - mov edx,00049000
	// dmc3.exe+214B43 - 41 B8 FEFFFFFF    - mov r8d,FFFFFFFE
	// dmc3.exe+214B49 - E8 02160B00       - call dmc3.exe+2C6150
	// */

	actorData.actionData[0] = *reinterpret_cast<byte8 **>(appBaseAddr + 0x590598);
	actorData.actionData[1] = *reinterpret_cast<byte8 **>(appBaseAddr + 0x58A2A0);
	actorData.actionData[2] = (appBaseAddr + 0x5905B0);
	actorData.actionData[3] = File_staticFiles[pl000][9];
	actorData.actionData[4] = File_staticFiles[pl000][10];
	actorData.actionData[5] = File_staticFiles[pl000][11];
	/*
	dmc3.exe+214B50 - 48 8B 05 41BA3700 - mov rax,[dmc3.exe+590598]
	dmc3.exe+214B5E - 48 89 86 D03D0000 - mov [rsi+00003DD0],rax

	dmc3.exe+214B65 - 48 8B 05 34573700 - mov rax,[dmc3.exe+58A2A0]
	dmc3.exe+214B6C - 48 89 86 D83D0000 - mov [rsi+00003DD8],rax

	dmc3.exe+214B73 - 48 8D 05 36BA3700 - lea rax,[dmc3.exe+5905B0]
	dmc3.exe+214B7A - 48 89 86 E03D0000 - mov [rsi+00003DE0],rax

	dmc3.exe+212C27 - 45 8D 4F 09       - lea r9d,[r15+09]
	dmc3.exe+212C5C - E8 5F56FAFF       - call __GET_FILE__
	dmc3.exe+212C6C - 48 89 86 E83D0000 - mov [rsi+00003DE8],rax

	dmc3.exe+212C66 - 45 8D 4F 0A       - lea r9d,[r15+0A]
	dmc3.exe+212C7A - E8 4156FAFF       - call __GET_FILE__
	dmc3.exe+212C8A - 48 89 86 F03D0000 - mov [rsi+00003DF0],rax

	dmc3.exe+212C84 - 45 8D 4F 0B       - lea r9d,[r15+0B]
	dmc3.exe+212C98 - E8 2356FAFF       - call __GET_FILE__
	dmc3.exe+212CA0 - 48 89 86 F83D0000 - mov [rsi+00003DF8],rax
	*/

	func_2EE3D0(actorData.var_3C50);
	/*
	dmc3.exe+214B57 - 48 8D 8E 503C0000 - lea rcx,[rsi+00003C50]
	dmc3.exe+214B81 - E8 4A980D00       - call dmc3.exe+2EE3D0
	*/

	func_1FAF40(actorData);
}

// @Todo: Update.
template <typename T>
void UpdateForm
(
	T & actorData
)
{
	actorData.queuedModelIndex       = 0;
	actorData.activeModelIndexMirror = 0;
	actorData.airRaid                = 0;

	if (actorData.devil)
	{
		if constexpr (TypeMatch<T, ActorDataDante>::value)
		{
			if (actorData.sparda)
			{
				actorData.queuedModelIndex       = 1;
				actorData.activeModelIndexMirror = 1;
				actorData.activeDevil            = DEVIL_SPARDA;
				actorData.airRaid                = 0;
			}
			else
			{
				auto weapon = (WEAPON_REBELLION + actorData.meleeWeaponIndex);
				if (weapon > WEAPON_BEOWULF_DANTE)
				{
					weapon = WEAPON_REBELLION;
				}

				actorData.queuedModelIndex       = (1 + weapon);
				actorData.activeModelIndexMirror = (1 + weapon);
				actorData.activeDevil            = static_cast<uint32>(weaponDevilIds[weapon]);
				actorData.airRaid                = 0;

				func_1F97F0(actorData, true);
			}
		}
		else if constexpr (TypeMatch<T, ActorDataVergil>::value)
		{
			if (actorData.neroAngelo)
			{
				actorData.queuedModelIndex       = 1;
				actorData.activeModelIndexMirror = 1;
				actorData.activeDevil            = DEVIL_NERO_ANGELO;
				actorData.airRaid                = 0;
			}
			else
			{
				auto weapon = (WEAPON_YAMATO_VERGIL + actorData.queuedMeleeWeaponIndex);
				if
				(
					(weapon < WEAPON_YAMATO_VERGIL    ) ||
					(weapon > WEAPON_YAMATO_FORCE_EDGE)
				)
				{
					weapon = WEAPON_YAMATO_VERGIL;
				}

				actorData.queuedModelIndex       = (weapon == WEAPON_BEOWULF_VERGIL) ? 2 : 1;
				actorData.activeModelIndexMirror = (weapon == WEAPON_BEOWULF_VERGIL) ? 2 : 1;
				actorData.activeDevil            = static_cast<uint32>(weaponDevilIds[weapon]);
				actorData.airRaid                = 0;

				func_1F97F0(actorData, true);
			}
		}
	}
}

template <typename T>
void UpdateMotionArchives(T & actorData)
{
	constexpr uint8 count =
	(TypeMatch<T, ActorDataDante >::value) ? static_cast<uint8>(countof(motionArchiveHelperDante )) :
	(TypeMatch<T, ActorDataBob   >::value) ? static_cast<uint8>(countof(motionArchiveHelperBob   )) :
	(TypeMatch<T, ActorDataLady  >::value) ? static_cast<uint8>(countof(motionArchiveHelperLady  )) :
	(TypeMatch<T, ActorDataVergil>::value) ? static_cast<uint8>(countof(motionArchiveHelperVergil)) :
	0;

	const MotionArchiveHelper * motionArchiveHelper =
	(TypeMatch<T, ActorDataDante >::value) ? motionArchiveHelperDante  :
	(TypeMatch<T, ActorDataBob   >::value) ? motionArchiveHelperBob    :
	(TypeMatch<T, ActorDataLady  >::value) ? motionArchiveHelperLady   :
	(TypeMatch<T, ActorDataVergil>::value) ? motionArchiveHelperVergil :
	0;

	for (uint8 index = 0; index < count; index++)
	{
		auto & group = motionArchiveHelper[index].group;
		auto & cacheFileId = motionArchiveHelper[index].cacheFileId;

		auto & metadata = File_staticFiles[cacheFileId];

		actorData.motionArchives[group] = File_dynamicFiles.Push(metadata.addr, metadata.size);
	}
}

// template <typename T>
// void InitStyle(T & actorData)
// {
// 	if constexpr (TypeMatch<T, ActorDataDante>::value)
// 	{
// 		actorData.style = STYLE_TRICKSTER;
// 	}
// 	else if constexpr (TypeMatch<T, ActorDataBob>::value)
// 	{
// 		actorData.style = STYLE_DARK_SLAYER;
// 	}
// 	else if constexpr (TypeMatch<T, ActorDataVergil>::value)
// 	{
// 		actorData.style = STYLE_DARK_SLAYER;
// 	}
// }

// @Todo: Update.
template <typename T>
void InitWeapons(T & actorData)
{
	memset
	(
		(reinterpret_cast<byte8 *>(&actorData) + __builtin_offsetof(ActorDataVergil, activeMeleeWeaponIndex) ),
		0,
		(__builtin_offsetof(ActorDataVergil, styleData) - __builtin_offsetof(ActorDataVergil, activeMeleeWeaponIndex) )
	);
	memset(actorData.newWeapons, WEAPON_VOID, sizeof(actorData.newWeapons));
	memset(actorData.newWeaponStatus, WEAPON_STATUS_DISABLED, sizeof(actorData.newWeaponStatus));

	constexpr uint8 count =
	(TypeMatch<T, ActorDataDante >::value) ? WEAPON_COUNT_DANTE  :
	(TypeMatch<T, ActorDataBob >::value) ? WEAPON_COUNT_BOB  :
	(TypeMatch<T, ActorDataVergil>::value) ? WEAPON_COUNT_VERGIL :
	0;

	for (uint8 index = 0; index < count; index++)
	{
		uint8 weapon =
		(TypeMatch<T, ActorDataDante >::value) ? (WEAPON_REBELLION     + index) :
		(TypeMatch<T, ActorDataBob >::value) ? (WEAPON_YAMATO_BOB     + index) :
		(TypeMatch<T, ActorDataVergil>::value) ? (WEAPON_YAMATO_VERGIL + index) :
		0;

		actorData.newWeapons[index] = weapon;
		actorData.newWeaponDataAddr[index] = RegisterWeapon[weapon](actorData, weapon);
		actorData.newWeaponStatus[index] = WEAPON_STATUS_READY;
	}

	if constexpr (TypeMatch<T, ActorDataDante>::value)
	{
		actorData.meleeWeaponIndex = 0;
		actorData.rangedWeaponIndex = 5;
	}
	else if constexpr (TypeMatch<T, ActorDataBob>::value)
	{
		actorData.meleeWeaponIndex = 0;
	}
	else if constexpr (TypeMatch<T, ActorDataVergil>::value)
	{
		actorData.activeMeleeWeaponIndex = 0;
		actorData.queuedMeleeWeaponIndex = 0;

		if (actorData.neroAngelo)
		{
			actorData.newWeaponDataAddr[3] = func_22CF00(actorData, 0);
		}
	}
}







auto GetStyle(CharacterData & characterData)
{
	auto & styleIndex = characterData.styleIndices[characterData.styleButtonIndex];

	return characterData.styles[characterData.styleButtonIndex][styleIndex];
}

template <typename T>
auto GetStyle(T & actorData)
{
	auto & characterData = GetCharacterData(actorData);

	return GetStyle(characterData);
}

template <typename T>
auto GetMeleeWeapon(T & actorData)
{
	auto & characterData = GetCharacterData(actorData);

	return characterData.meleeWeapons[characterData.meleeWeaponIndex];
}

template <typename T>
auto GetRangedWeapon(T & actorData)
{
	auto & characterData = GetCharacterData(actorData);

	return characterData.rangedWeapons[characterData.rangedWeaponIndex];
}












template <typename T>
void UpdateStyle(T & actorData)
{
	LogFunctionHelper(__FUNCTION__, actorData.operator byte8 *()) ;
	// auto & characterData = GetCharacterData(actorData);

	// auto & styleIndex = characterData.styleIndices[characterData.styleButtonIndex];
	// auto & style = characterData.styles[characterData.styleButtonIndex][styleIndex];

	actorData.style = GetStyle(actorData);
}

template <typename T>
void UpdateMeleeWeapon(T & actorData)
{
	LogFunctionHelper(__FUNCTION__, actorData.operator byte8 *()) ;
	auto & characterData = GetCharacterData(actorData);

	if (characterData.meleeWeaponIndex >= characterData.meleeWeaponCount)
	{
		characterData.meleeWeaponIndex = 0;
	}

	//auto weapon = characterData.meleeWeapons[characterData.meleeWeaponIndex];

	auto weapon = GetMeleeWeapon(actorData);




	// weapon = 3;

	// Log("weapon %u", weapon);

	// Log("meleeWeapon %u", characterData.meleeWeapons[characterData.meleeWeaponIndex]);

	if constexpr (TypeMatch<T, ActorDataDante>::value)
	{
		if (IsDanteMeleeWeapon(weapon))
		{
			actorData.meleeWeaponIndex = weapon;
		}
	}
	else if constexpr (TypeMatch<T, ActorDataVergil>::value)
	{
		if (IsVergilMeleeWeapon(weapon))
		{
			actorData.queuedMeleeWeaponIndex = (weapon - WEAPON_YAMATO_VERGIL);
		}
	}
}

template <typename T>
void UpdateRangedWeapon(T & actorData)
{
	LogFunctionHelper(__FUNCTION__, actorData.operator byte8 *()) ;
	auto & characterData = GetCharacterData(actorData);

	if (characterData.rangedWeaponIndex >= characterData.rangedWeaponCount)
	{
		characterData.rangedWeaponIndex = 0;
	}

	//auto weapon = characterData.rangedWeapons[characterData.rangedWeaponIndex];

	auto weapon = GetRangedWeapon(actorData);

	if constexpr (TypeMatch<T, ActorDataDante>::value)
	{
		if (IsDanteRangedWeapon(weapon))
		{
			actorData.rangedWeaponIndex = weapon;
		}
	}
}

template <typename T>
void UpdateWeapons(T & actorData)
{
	LogFunctionHelper(__FUNCTION__, actorData.operator byte8 *()) ;
	UpdateMeleeWeapon (actorData);
	UpdateRangedWeapon(actorData);
}












template <typename T>
byte8 * CreateActor
(
	uint8 playerIndex,
	uint8 characterIndex,
	uint8 entityIndex
)
{
	// LogFunction
	// (
	// 	playerIndex,
	// 	characterIndex,
	// 	entityIndex
	// );

	auto & playerData = GetPlayerData(playerIndex);
	auto & characterData = GetCharacterData
	(
		playerIndex,
		characterIndex,
		entityIndex
	);

	auto pool_2737 = *reinterpret_cast<byte8 **>(appBaseAddr + 0xC90E30);if (!pool_2737){ return 0;}auto & queuedMissionActorData = *reinterpret_cast<QueuedMissionActorData *>(pool_2737 + 0xC0 );auto & activeMissionActorData = *reinterpret_cast<ActiveMissionActorData *>(pool_2737 + 0x16C) ;

	auto actorBaseAddr = func_1DE820(characterData.character, 0, false);
	if (!actorBaseAddr)
	{
		return 0;
	}
	auto & actorData = *reinterpret_cast<T *>(actorBaseAddr);

	UpdateFileData(actorData);

	InitActor(actorData, activeMissionActorData);

	actorData.shadow = 1;
	actorData.lastShadow = 1;
	actorData.costume = characterData.costume;

	{
		bool value = false;

		if constexpr (TypeMatch<T, ActorDataDante>::value)
		{
			switch (actorData.costume)
			{
				case COSTUME_DANTE_DMC1:
				case COSTUME_DANTE_DMC1_NO_COAT:
				case COSTUME_DANTE_SPARDA:
				case COSTUME_DANTE_SPARDA_INFINITE_MAGIC_POINTS:
				{
					value = true;

					break;
				}
			}

			actorData.sparda = value;
		}
		else if constexpr (TypeMatch<T, ActorDataVergil>::value)
		{
			switch (actorData.costume)
			{
				case COSTUME_VERGIL_NERO_ANGELO:
				case COSTUME_VERGIL_NERO_ANGELO_INFINITE_MAGIC_POINTS:
				{
					value = true;

					break;
				}
			}

			actorData.neroAngelo = value;
		}
	}

	UpdateCostumeFileData(actorData);

	actorData.newPlayerIndex         = playerIndex;
	actorData.newCharacterIndex      = characterIndex;
	actorData.newEntityIndex         = entityIndex;
	actorData.newForceFiles          = characterData.forceFiles;
	actorData.newForceFilesCharacter = characterData.forceFilesCharacter;
	actorData.newGamepad             = playerIndex;

	if constexpr (TypeMatch<T, ActorDataDante>::value)
	{
		UpdateActorDante(actorData);
	}
	else
	{
		UpdateActor(actorData);
	}

	if (entityIndex == ENTITY_MAIN)
	{
		func_2EE060(actorData.var_6410, 60);
		/*
		dmc3.exe+2134C6 - 48 8D 8E 10640000 - lea rcx,[rsi+00006410]
		dmc3.exe+2134CD - BA 3C000000       - mov edx,0000003C
		dmc3.exe+2134D2 - E8 89AB0D00       - call dmc3.exe+2EE060
		*/

		func_2C6150(actorData.var_6458, 0x49000, -2);
		/*
		dmc3.exe+214B37 - 48 8D 8E 58640000 - lea rcx,[rsi+00006458]
		dmc3.exe+214B3E - BA 00900400       - mov edx,00049000
		dmc3.exe+214B43 - 41 B8 FEFFFFFF    - mov r8d,FFFFFFFE
		dmc3.exe+214B49 - E8 02160B00       - call dmc3.exe+2C6150
		*/
	}

	UpdateMotionArchives(actorData);

	UpdateStyle(actorData);

	if
	(
		(playerIndex == 0) &&
		(characterIndex == playerData.activeCharacterIndex) &&
		(entityIndex == ENTITY_MAIN)
	)
	{
		HUD_UpdateStyleIcon
		(
			GetStyle(actorData),
			characterData.character
		);
	}

	InitWeapons(actorData);

	UpdateWeapons(actorData);

	memset
	(
		actorData.expertise,
		0xFF,
		sizeof(actorData.expertise)
	);

	actorData.styleLevel = 2;

	if constexpr (TypeMatch<T, ActorDataDante>::value)
	{
		for (uint8 weaponIndex = WEAPON_EBONY_IVORY; weaponIndex < WEAPON_COUNT_DANTE; weaponIndex++)
		{
			actorData.newWeaponLevels[weaponIndex] = 2;
		}
	}

	if (entityIndex == ENTITY_CLONE)
	{
		actorData.newIsClone = true;
	}

	func_1DFC20(actorData);

	CommissionActor(actorData);

	Actor_actorBaseAddr.Push(actorBaseAddr);

	return actorBaseAddr;
}





byte8 * SpawnActor
(
	uint8 playerIndex,
	uint8 characterIndex,
	uint8 entityIndex
)
{
	byte8 * actorBaseAddr = 0;

	auto & characterData = GetCharacterData
	(
		playerIndex,
		characterIndex,
		entityIndex
	);

	switch (characterData.character)
	{
		case CHAR_DANTE:
		{
			actorBaseAddr = CreateActor<ActorDataDante>
			(
				playerIndex,
				characterIndex,
				entityIndex
			);

			break;
		}
		case CHAR_BOB:
		{
			actorBaseAddr = CreateActor<ActorDataBob>
			(
				playerIndex,
				characterIndex,
				entityIndex
			);

			break;
		}
		case CHAR_LADY:
		{
			actorBaseAddr = CreateActor<ActorDataLady>
			(
				playerIndex,
				characterIndex,
				entityIndex
			);

			break;
		}
		case CHAR_VERGIL:
		{
			actorBaseAddr = CreateActor<ActorDataVergil>
			(
				playerIndex,
				characterIndex,
				entityIndex
			);

			break;
		}
	}

	return actorBaseAddr;
}






export void SpawnActors()
{
	LogFunctionHelper(__FUNCTION__) ;

	// auto mainActorBaseAddr = Actor_actorBaseAddr[0];
	// if (!mainActorBaseAddr)
	// {
	// 	return;
	// }
	// auto & mainActorData = *reinterpret_cast<ActorData *>(mainActorBaseAddr);



	for (uint8 playerIndex = 0; playerIndex < activeConfig.Actor.playerCount; playerIndex++)
	{
		auto & playerData = GetPlayerData(playerIndex);

		if (playerData.characterIndex >= playerData.characterCount)
		{
			playerData.characterIndex = 0;
		}

		playerData.activeCharacterIndex = playerData.lastCharacterIndex = playerData.characterIndex;



		for (uint8 characterIndex = 0; characterIndex < playerData.characterCount; characterIndex++)
		{
			auto actorBaseAddr = SpawnActor
			(
				playerIndex,
				characterIndex,
				ENTITY_MAIN
			);
			if (!actorBaseAddr)
			{
				continue;
			}
			auto & actorData = *reinterpret_cast<ActorData *>(actorBaseAddr);

			actorData.cloneActorBaseAddr = SpawnActor
			(
				playerIndex,
				characterIndex,
				ENTITY_CLONE
			);
			if (!actorData.cloneActorBaseAddr)
			{
				continue;
			}
			//auto & cloneActorData = *reinterpret_cast<ActorData *>(cloneActorBaseAddr);

			// actorData.position = mainActorData.position;
			// actorData.rotation = mainActorData.rotation;
			//actorData.cloneActorBaseAddr = cloneActorBaseAddr;

			// cloneActorData.position = mainActorData.position;
			// cloneActorData.rotation = mainActorData.rotation;
		}
	}
}

#pragma endregion







#pragma region Controllers





// void RemoveBusyFlagController(byte8 * baseAddr)
// {
// 	if (!activeConfig.RemoveBusyFlag.enable)
// 	{
// 		return;
// 	}

// 	if (!baseAddr)
// 	{
// 		return;
// 	}
// 	if (baseAddr == Actor_actorBaseAddr[0])
// 	{
// 		return;
// 	}
// 	if (baseAddr == Actor_actorBaseAddr[1])
// 	{
// 		return;
// 	}
// 	auto & actorData = *reinterpret_cast<ActorData *>(baseAddr);

// 	if (actorData.buttons[2] & activeConfig.RemoveBusyFlag.button)
// 	{
// 		actorData.state &= ~STATE_BUSY;
// 	}
// }

void ResetPermissionsController(byte8 * baseAddr)
{
	if (!activeConfig.ResetPermissions.enable)
	{
		return;
	}

	if (!baseAddr)
	{
		return;
	}
	if (baseAddr == Actor_actorBaseAddr[0])
	{
		return;
	}
	if (baseAddr == Actor_actorBaseAddr[1])
	{
		return;
	}
	auto & actorData = *reinterpret_cast<ActorData *>(baseAddr);

	if (actorData.buttons[2] & activeConfig.ResetPermissions.button)
	{
		actorData.permissions = 0x1C1B;
	}
}




























template <typename T>
void StyleSwitchController(T & actorData)
{
	auto & playerData = GetPlayerData(actorData);
	auto & characterData = GetCharacterData(actorData);

	bool update = false;

	{
		bool condition = (actorData.buttons[0] & playerData.button);

		if (actorData.newEntityIndex == ENTITY_MAIN)
		{
			if (condition)
			{
				return;
			}
		}
		else
		{
			if (!condition)
			{
				return;
			}
		}
	}

	for (uint8 styleButtonIndex = 0; styleButtonIndex < STYLE_COUNT; styleButtonIndex++)
	{
		auto & styleButton = characterData.styleButtons[styleButtonIndex];
		auto & styleIndex = characterData.styleIndices[styleButtonIndex];

		auto lastStyleIndex = styleIndex;

		if (actorData.buttons[2] & styleButton)
		{
			if (characterData.styleButtonIndex == styleButtonIndex)
			{
				styleIndex++;

				if (styleIndex >= 2)
				{
					styleIndex = 0;
				}
			}
			else
			{
				styleIndex = 0;
			}

			auto style = characterData.styles[styleButtonIndex][styleIndex];

			switch (style)
			{
				case STYLE_QUICKSILVER:
				{
					if
					(
						(actorData.newPlayerIndex != 0) ||
						(actorData.newCharacterIndex != 0) ||
						(actorData.newEntityIndex != ENTITY_MAIN)
					)
					{
						styleIndex = lastStyleIndex;

						goto LoopContinue;
					}

					break;
				}
				case STYLE_DOPPELGANGER:
				{
					if (actorData.newEntityIndex != ENTITY_MAIN)
					{
						styleIndex = lastStyleIndex;

						goto LoopContinue;
					}

					break;
				}
			}

			characterData.styleButtonIndex = styleButtonIndex;

			update = true;

			break;
		}

		LoopContinue:;
	}

	if (!update)
	{
		return;
	}

	UpdateStyle(actorData);

	if (activeConfig.removeBusyFlag)
	{
		actorData.state &= ~STATE_BUSY;

		Log("%llX Remove Busy Flag", actorData.operator byte8 *());
	}

	if (actorData.newPlayerIndex != 0)
	{
		return;
	}
	else if (actorData.newEntityIndex != ENTITY_MAIN)
	{
		return;
	}

	HUD_UpdateStyleIcon
	(
		GetStyle(actorData),
		characterData.character
	);
}

template <typename T>
void MeleeWeaponSwitchController(T & actorData)
{
	auto & playerData = GetPlayerData(actorData);
	auto & characterData = GetCharacterData(actorData);

	bool update = false;

	bool forward = false;
	bool back = false;

	{
		bool condition = (actorData.buttons[0] & playerData.button);

		if (actorData.newEntityIndex == ENTITY_MAIN)
		{
			if (condition)
			{
				return;
			}
		}
		else
		{
			if (!condition)
			{
				return;
			}
		}
	}

	if (0 < actorData.meleeWeaponSwitchTimeout)
	{
		return;
	}
	else if (characterData.meleeWeaponCount < 2)
	{
		return;
	}

	auto Forward = [&]()
	{
		if (characterData.meleeWeaponIndex == (characterData.meleeWeaponCount - 1))
		{
			characterData.meleeWeaponIndex = 0;
		}
		else
		{
			characterData.meleeWeaponIndex++;
		}
		update = true;

		forward = true;
	};

	auto Back = [&]()
	{
		if (characterData.meleeWeaponIndex == 0)
		{
			characterData.meleeWeaponIndex = (characterData.meleeWeaponCount - 1);
		}
		else
		{
			characterData.meleeWeaponIndex--;
		}
		update = true;

		back = true;
	};

	if (actorData.buttons[2] & GetBinding(BINDING_CHANGE_DEVIL_ARMS))
	{
		if (actorData.buttons[0] & GetBinding(BINDING_TAUNT))
		{
			Back();
		}
		else
		{
			Forward();
		}
	}
	else if (actorData.buttons[2] & GetBinding(BINDING_CHANGE_GUN))
	{
		if constexpr (TypeMatch<T, ActorDataVergil>::value)
		{
			Back();
		}
	}

	if (!update)
	{
		return;
	}

	actorData.meleeWeaponSwitchTimeout = activeConfig.weaponSwitchTimeout;

	// Nero Angelo Fix
	{
		auto weapon = GetMeleeWeapon(actorData);

		if
		(
			IsNeroAngelo(actorData) &&
			(weapon == WEAPON_YAMATO_FORCE_EDGE)
		)
		{
			if (forward)
			{
				Forward();
			}
			else if (back)
			{
				Back();
			}
		}
	}

	UpdateMeleeWeapon(actorData);

	UpdateForm(actorData);

	if (actorData.newPlayerIndex != 0)
	{
		return;
	}
	else if (actorData.newEntityIndex != ENTITY_MAIN)
	{
		return;
	}

	[&]()
	{
		auto pool_3367 = *reinterpret_cast<byte8 **>(appBaseAddr + 0xC90E28);if (!pool_3367){ return;}pool_3367 -= 0x180;auto hudTop = *reinterpret_cast<byte8 **>(pool_3367 + 0x1B070);auto hudBottom = *reinterpret_cast<byte8 **>(pool_3367 + 0x1B078) ;

		if
		(
			HUD_UpdateWeaponIcon
			(
				HUD_BOTTOM_MELEE_WEAPON_1,
				GetMeleeWeapon(actorData)
			)
		)
		{
			func_280120(hudBottom, 1, 0); // @Todo: Enums.
		}
	}();

	func_1EB0E0(actorData, 4);
}

template <typename T>
void RangedWeaponSwitchController(T & actorData)
{
	auto & playerData = GetPlayerData(actorData);
	auto & characterData = GetCharacterData(actorData);

	bool update = false;

	{
		bool condition = (actorData.buttons[0] & playerData.button);

		if (actorData.newEntityIndex == ENTITY_MAIN)
		{
			if (condition)
			{
				return;
			}
		}
		else
		{
			if (!condition)
			{
				return;
			}
		}
	}

	if (0 < actorData.rangedWeaponSwitchTimeout)
	{
		return;
	}
	else if (characterData.rangedWeaponCount < 2)
	{
		return;
	}

	auto Forward = [&]()
	{
		if (characterData.rangedWeaponIndex == (characterData.rangedWeaponCount - 1))
		{
			characterData.rangedWeaponIndex = 0;
		}
		else
		{
			characterData.rangedWeaponIndex++;
		}
		update = true;
	};

	auto Back = [&]()
	{
		if (characterData.rangedWeaponIndex == 0)
		{
			characterData.rangedWeaponIndex = (characterData.rangedWeaponCount - 1);
		}
		else
		{
			characterData.rangedWeaponIndex--;
		}
		update = true;
	};

	if (actorData.buttons[2] & GetBinding(BINDING_CHANGE_GUN))
	{
		if (actorData.buttons[0] & GetBinding(BINDING_TAUNT))
		{
			Back();
		}
		else
		{
			Forward();
		}
	}

	if (!update)
	{
		return;
	}

	actorData.rangedWeaponSwitchTimeout = activeConfig.weaponSwitchTimeout;

	UpdateRangedWeapon(actorData);

	if (actorData.newPlayerIndex != 0)
	{
		return;
	}
	else if (actorData.newEntityIndex != ENTITY_MAIN)
	{
		return;
	}

	[&]()
	{
		auto pool_3479 = *reinterpret_cast<byte8 **>(appBaseAddr + 0xC90E28);if (!pool_3479){ return;}pool_3479 -= 0x180;auto hudTop = *reinterpret_cast<byte8 **>(pool_3479 + 0x1B070);auto hudBottom = *reinterpret_cast<byte8 **>(pool_3479 + 0x1B078) ;

		if
		(
			HUD_UpdateWeaponIcon
			(
				HUD_BOTTOM_RANGED_WEAPON_1,
				GetRangedWeapon(actorData)
			)
		)
		{
			func_280120(hudBottom, 0, 0); // @Todo: Enums.
		}
	}();

	func_1EB0E0(actorData, 4);
}

template <typename T>
bool WeaponSwitchController(byte8 * actorBaseAddr)
{
	if
	(
		!actorBaseAddr ||
		(actorBaseAddr == Actor_actorBaseAddr[0]) ||
		(actorBaseAddr == Actor_actorBaseAddr[1])
	)
	{
		return true;
	}
	auto & actorData = *reinterpret_cast<T *>(actorBaseAddr);

	if (actorData.mode == ACTOR_MODE_MISSION_18)
	{
		return true;
	}
	else if (actorData.var_3F19)
	{
		return false;
	}

	StyleSwitchController(actorData);

	MeleeWeaponSwitchController(actorData);

	if constexpr (TypeMatch<T, ActorDataDante>::value)
	{
		RangedWeaponSwitchController(actorData);
	}

	ResetPermissionsController(actorData);

	return true;
}















export bool g_executeButton[PLAYER_COUNT] = {};
export bool g_executeFunction[PLAYER_COUNT] = {};

export void CharacterSwitchController()
{
	if (!activeConfig.Actor.enable)
	{
		return;
	}

	for (uint8 playerIndex = 0; playerIndex < activeConfig.Actor.playerCount; playerIndex++)
	{
		auto & playerData = GetPlayerData(playerIndex);

		auto & gamepad = GetGamepad(playerIndex);

		auto & executeButton   = g_executeButton  [playerIndex];
		auto & executeFunction = g_executeFunction[playerIndex];

		byte8 * activeActorBaseAddr = 0;
		byte8 * idleActorBaseAddr   = 0;

		for (uint32 index = 2; index < Actor_actorBaseAddr.count; index++)
		{
			auto actorBaseAddr = Actor_actorBaseAddr[index];if (!actorBaseAddr){ continue;}auto & actorData = *reinterpret_cast<ActorData *>(actorBaseAddr) ;

			if
			(
				InCutscene() ||
				(actorData.mode == ACTOR_MODE_MISSION_18) ||
				actorData.var_3F19
			)
			{
				continue;
			}
			else if
			(
				(actorData.newPlayerIndex == playerIndex) &&
				(actorData.newEntityIndex == ENTITY_MAIN) &&
				(actorData.newCharacterIndex == playerData.activeCharacterIndex)
			)
			{
				activeActorBaseAddr = actorBaseAddr;

				break;
			}
		}

		if (!activeActorBaseAddr)
		{
			continue;
		}
		auto & activeActorData = *reinterpret_cast<ActorData *>(activeActorBaseAddr);



		[&]()
		{
			if (playerData.characterCount < 2)
			{
				return;
			}
			else if (activeActorData.doppelganger)
			{
				return;
			}

			if (gamepad.buttons[0] & playerData.button)
			{
				if (executeButton)
				{
					executeButton = false;

					playerData.characterIndex++;

					if (playerData.characterIndex >= playerData.characterCount)
					{
						playerData.characterIndex = 0;
					}
				}
			}
			else
			{
				executeButton = true;
			}

			for (uint32 index = 2; index < Actor_actorBaseAddr.count; index++)
			{
				auto actorBaseAddr = Actor_actorBaseAddr[index];if (!actorBaseAddr){ continue;}auto & actorData = *reinterpret_cast<ActorData *>(actorBaseAddr) ;
				//IntroduceActorData(actorBaseAddr, actorData, index, continue);
				// auto actorBaseAddr = Actor_actorBaseAddr[index];
				// if (!actorBaseAddr)
				// {
				// 	continue;
				// }
				// auto & actorData = *reinterpret_cast<ActorData *>(actorBaseAddr);

				if (actorData.newPlayerIndex != playerIndex)
				{
					continue;
				}
				else if (actorData.newEntityIndex != ENTITY_MAIN)
				{
					continue;
				}
				else if (actorData.newCharacterIndex == playerData.characterIndex)
				{
					idleActorBaseAddr = actorBaseAddr;

					break;
				}
			}

			if (!idleActorBaseAddr)
			{
				return;
			}
			auto & idleActorData = *reinterpret_cast<ActorData *>(idleActorBaseAddr);

			if (playerData.lastCharacterIndex != playerData.characterIndex)
			{
				playerData.lastCharacterIndex = playerData.characterIndex;

				ToggleInput(activeActorData, false);
				ToggleInput(idleActorData  , true );

				executeFunction = true;
			}

			if (!executeFunction)
			{
				return;
			}

			// @Todo: Create function.
			if (IsActive(activeActorData))
			{
				if (IsActive(idleActorData))
				{
					executeFunction = false;

					playerData.activeCharacterIndex = playerData.characterIndex;

					ToggleActor(activeActorData, false);
					ToggleActor(idleActorData  , true );

					EndMotion(activeActorData);

					UpdatePermissions(idleActorData);

					if (playerIndex == 0)
					{
						auto & characterData = GetCharacterData(idleActorData);

						HUD_UpdateStyleIcon
						(
							GetStyle(characterData),
							characterData.character
						);

						SetMainActor(idleActorData);
					}
				}
			}
			else
			{
				executeFunction = false;

				playerData.activeCharacterIndex = playerData.characterIndex;

				ToggleActor(activeActorData, false);
				ToggleActor(idleActorData  , true );

				EndMotion(activeActorData);

				UpdatePermissions(idleActorData);

				if (playerIndex == 0)
				{
					auto & characterData = GetCharacterData(idleActorData);

					HUD_UpdateStyleIcon
					(
						GetStyle(characterData),
						characterData.character
					);

					SetMainActor(idleActorData);
				}
			}
		}();



		for (uint32 index = 2; index < Actor_actorBaseAddr.count; index++)
		{
			//IntroduceActorData(actorBaseAddr, actorData, index, continue);
			auto actorBaseAddr = Actor_actorBaseAddr[index];if (!actorBaseAddr){ continue;}auto & actorData = *reinterpret_cast<ActorData *>(actorBaseAddr) ;
			// auto actorBaseAddr = Actor_actorBaseAddr[index];
			// if (!actorBaseAddr)
			// {
			// 	continue;
			// }
			// auto & actorData = *reinterpret_cast<ActorData *>(actorBaseAddr);

			if (InCutscene())
			{
				continue;
			}
			else if (actorData.newPlayerIndex != playerIndex)
			{
				continue;
			}
			else if
			(
				(actorData.newCharacterIndex == playerData.activeCharacterIndex) &&
				(actorData.newEntityIndex == ENTITY_MAIN)
			)
			{
				continue;
			}
			else if
			(
				(actorData.newCharacterIndex == playerData.activeCharacterIndex) &&
				(actorData.newEntityIndex == ENTITY_CLONE) &&
				actorData.doppelganger
			)
			{
				continue;
			}

			CopyState(activeActorData, actorData);
		}
	}
}

#pragma endregion

#pragma region Relocations

export void ToggleRelocations(bool enable)
{
	LogFunctionHelper(__FUNCTION__, enable) ;
	// 0x200
	{
		constexpr auto off = __builtin_offsetof(ActorData, modelData[0]) ;
		constexpr auto newOff = __builtin_offsetof(ActorData, newModelData[0]) ;
		static_assert(off == 0x200);
		// Update Actor Dante
		Write<uint32>((appBaseAddr + 0x2131D9 + 3), (enable) ? newOff : off); // dmc3.exe+2131D9 - 49 81 C4 00020000 - ADD R12,00000200
		Write<uint32>((appBaseAddr + 0x2135D4 + 3), (enable) ? newOff : off); // dmc3.exe+2135D4 - 49 81 C4 00020000 - ADD R12,00000200
		Write<uint32>((appBaseAddr + 0x2139E1 + 3), (enable) ? newOff : off); // dmc3.exe+2139E1 - 49 81 C4 00020000 - ADD R12,00000200
		Write<uint32>((appBaseAddr + 0x214037 + 3), (enable) ? newOff : off); // dmc3.exe+214037 - 49 81 C4 00020000 - ADD R12,00000200
		Write<uint32>((appBaseAddr + 0x214165 + 3), (enable) ? newOff : off); // dmc3.exe+214165 - 49 81 C4 00020000 - ADD R12,00000200
		Write<uint32>((appBaseAddr + 0x214558 + 3), (enable) ? newOff : off); // dmc3.exe+214558 - 49 81 C4 00020000 - ADD R12,00000200
		Write<uint32>((appBaseAddr + 0x214BE7 + 3), (enable) ? newOff : off); // dmc3.exe+214BE7 - 48 8D 8E 00020000 - LEA RCX,[RSI+00000200]
		Write<uint32>((appBaseAddr + 0x214C00 + 3), (enable) ? newOff : off); // dmc3.exe+214C00 - 48 8D 8E 00020000 - LEA RCX,[RSI+00000200]
		Write<uint32>((appBaseAddr + 0x214C19 + 3), (enable) ? newOff : off); // dmc3.exe+214C19 - 48 8D 8E 00020000 - LEA RCX,[RSI+00000200]
		Write<uint32>((appBaseAddr + 0x214C32 + 3), (enable) ? newOff : off); // dmc3.exe+214C32 - 48 8D 8E 00020000 - LEA RCX,[RSI+00000200]
		Write<uint32>((appBaseAddr + 0x214CC2 + 3), (enable) ? newOff : off); // dmc3.exe+214CC2 - 48 8D 8E 00020000 - LEA RCX,[RSI+00000200]
		Write<uint32>((appBaseAddr + 0x214CDB + 3), (enable) ? newOff : off); // dmc3.exe+214CDB - 48 8D 8E 00020000 - LEA RCX,[RSI+00000200]
		Write<uint32>((appBaseAddr + 0x214CF4 + 3), (enable) ? newOff : off); // dmc3.exe+214CF4 - 48 8D 8E 00020000 - LEA RCX,[RSI+00000200]
		Write<uint32>((appBaseAddr + 0x214D0D + 3), (enable) ? newOff : off); // dmc3.exe+214D0D - 48 8D 8E 00020000 - LEA RCX,[RSI+00000200]
		// Update Actor Bob
		Write<uint32>((appBaseAddr + 0x225E61 + 3), (enable) ? newOff : off); // dmc3.exe+225E61 - 49 8D B6 00020000 - LEA RSI,[R14+00000200]
		Write<uint32>((appBaseAddr + 0x226414 + 3), (enable) ? newOff : off); // dmc3.exe+226414 - 4C 8B 83 00020000 - MOV R8,[RBX+00000200]
		Write<uint32>((appBaseAddr + 0x22641B + 3), (enable) ? newOff : off); // dmc3.exe+22641B - 48 8D 8B 00020000 - LEA RCX,[RBX+00000200]
		Write<uint32>((appBaseAddr + 0x226426 + 3), (enable) ? newOff : off); // dmc3.exe+226426 - 4C 8B 8B 00020000 - MOV R9,[RBX+00000200]
		Write<uint32>((appBaseAddr + 0x22642D + 3), (enable) ? newOff : off); // dmc3.exe+22642D - 48 8D 8B 00020000 - LEA RCX,[RBX+00000200]
		// Write<uint32>((appBaseAddr + 0x226988 + 3), (enable) ? newOff : off); // dmc3.exe+226988 - 4C 8B 83 00020000 - MOV R8,[RBX+00000200]
		// Write<uint32>((appBaseAddr + 0x22698F + 3), (enable) ? newOff : off); // dmc3.exe+22698F - 48 8D 8B 00020000 - LEA RCX,[RBX+00000200]
		// Write<uint32>((appBaseAddr + 0x22699A + 3), (enable) ? newOff : off); // dmc3.exe+22699A - 4C 8B 8B 00020000 - MOV R9,[RBX+00000200]
		// Write<uint32>((appBaseAddr + 0x2269A1 + 3), (enable) ? newOff : off); // dmc3.exe+2269A1 - 48 8D 8B 00020000 - LEA RCX,[RBX+00000200]
		Write<uint32>((appBaseAddr + 0x226C65 + 3), (enable) ? newOff : off); // dmc3.exe+226C65 - 49 8D 8E 00020000 - LEA RCX,[R14+00000200]
		Write<uint32>((appBaseAddr + 0x226C7D + 3), (enable) ? newOff : off); // dmc3.exe+226C7D - 49 8D 8E 00020000 - LEA RCX,[R14+00000200]
		// Update Actor Lady
		Write<uint32>((appBaseAddr + 0x219318 + 3), (enable) ? newOff : off); // dmc3.exe+219318 - 4C 8D A5 00020000 - LEA R12,[RBP+00000200]
		// Update Actor Vergil
		Write<uint32>((appBaseAddr + 0x220E21 + 3), (enable) ? newOff : off); // dmc3.exe+220E21 - 49 81 C6 00020000 - ADD R14,00000200
		Write<uint32>((appBaseAddr + 0x2211EB + 3), (enable) ? newOff : off); // dmc3.exe+2211EB - 49 81 C6 00020000 - ADD R14,00000200
		Write<uint32>((appBaseAddr + 0x2215F0 + 3), (enable) ? newOff : off); // dmc3.exe+2215F0 - 49 81 C6 00020000 - ADD R14,00000200
		// Update Model Dante
		Write<uint32>((appBaseAddr + 0x214D95 + 3), (enable) ? newOff : off); // dmc3.exe+214D95 - 49 8D B6 00020000 - LEA RSI,[R14+00000200]
		// Update Model Vergil
		Write<uint32>((appBaseAddr + 0x22202B + 3), (enable) ? newOff : off); // dmc3.exe+22202B - 4C 8D B5 00020000 - LEA R14,[RBP+00000200]
		// func_1DDAF0
		Write<uint32>((appBaseAddr + 0x1DDB4B + 3), (enable) ? newOff : off); // dmc3.exe+1DDB4B - 48 8D 8E 00020000 - LEA RCX,[RSI+00000200]
		// func_1DE280
		Write<uint32>((appBaseAddr + 0x1DE41A + 3), (enable) ? newOff : off); // dmc3.exe+1DE41A - 48 8D 8F 00020000 - LEA RCX,[RDI+00000200]
		// func_1DE750
		Write<uint32>((appBaseAddr + 0x1DE764 + 3), (enable) ? newOff : off); // dmc3.exe+1DE764 - 48 8D 99 00020000 - LEA RBX,[RCX+00000200]
		// func_1EF040
		Write<uint32>((appBaseAddr + 0x1EF09A + 3), (enable) ? newOff : off); // dmc3.exe+1EF09A - 48 81 C1 00020000 - ADD RCX,00000200
		Write<uint32>((appBaseAddr + 0x1EF3E0 + 3), (enable) ? newOff : off); // dmc3.exe+1EF3E0 - 4D 8D BD 00020000 - LEA R15,[R13+00000200]
		// Other
		Write<uint32>((appBaseAddr + 0xC9F2B + 3), (enable) ? newOff : off); // dmc3.exe+C9F2B - 49 8D 8F 00020000 - LEA RCX,[R15+00000200]
		Write<uint32>((appBaseAddr + 0x1DFD29 + 3), (enable) ? newOff : off); // dmc3.exe+1DFD29 - 48 81 C1 00020000 - ADD RCX,00000200
		Write<uint32>((appBaseAddr + 0x1EEF16 + 3), (enable) ? newOff : off); // dmc3.exe+1EEF16 - 48 81 C1 00020000 - ADD RCX,00000200
		Write<uint32>((appBaseAddr + 0x1EEF4D + 3), (enable) ? newOff : off); // dmc3.exe+1EEF4D - 48 81 C1 00020000 - ADD RCX,00000200
		Write<uint32>((appBaseAddr + 0x1EF566 + 3), (enable) ? newOff : off); // dmc3.exe+1EF566 - 48 81 C1 00020000 - ADD RCX,00000200
		Write<uint32>((appBaseAddr + 0x1EF5CC + 3), (enable) ? newOff : off); // dmc3.exe+1EF5CC - 48 81 C1 00020000 - ADD RCX,00000200
		Write<uint32>((appBaseAddr + 0x1EF6DC + 3), (enable) ? newOff : off); // dmc3.exe+1EF6DC - 48 81 C1 00020000 - ADD RCX,00000200
		Write<uint32>((appBaseAddr + 0x1EF8B3 + 3), (enable) ? newOff : off); // dmc3.exe+1EF8B3 - 48 81 C1 00020000 - ADD RCX,00000200
		Write<uint32>((appBaseAddr + 0x1FB570 + 3), (enable) ? newOff : off); // dmc3.exe+1FB570 - 48 81 C1 00020000 - ADD RCX,00000200
		Write<uint32>((appBaseAddr + 0x1FB7C3 + 3), (enable) ? newOff : off); // dmc3.exe+1FB7C3 - 48 8D B3 00020000 - LEA RSI,[RBX+00000200]
		Write<uint32>((appBaseAddr + 0x1FB946 + 3), (enable) ? newOff : off); // dmc3.exe+1FB946 - 48 8D B3 00020000 - LEA RSI,[RBX+00000200]
		Write<uint32>((appBaseAddr + 0x1FB9D1 + 3), (enable) ? newOff : off); // dmc3.exe+1FB9D1 - 48 81 C3 00020000 - ADD RBX,00000200
		Write<uint32>((appBaseAddr + 0x1FC3CB + 3), (enable) ? newOff : off); // dmc3.exe+1FC3CB - 48 81 C1 00020000 - ADD RCX,00000200
		Write<uint32>((appBaseAddr + 0x1FC525 + 3), (enable) ? newOff : off); // dmc3.exe+1FC525 - 48 81 C1 00020000 - ADD RCX,00000200
		Write<uint32>((appBaseAddr + 0x1FCA34 + 3), (enable) ? newOff : off); // dmc3.exe+1FCA34 - 48 8D B1 00020000 - LEA RSI,[RCX+00000200]
		Write<uint32>((appBaseAddr + 0x1FCB5B + 3), (enable) ? newOff : off); // dmc3.exe+1FCB5B - 4C 8D B7 00020000 - LEA R14,[RDI+00000200]
		Write<uint32>((appBaseAddr + 0x1FCC97 + 3), (enable) ? newOff : off); // dmc3.exe+1FCC97 - 4C 8D B7 00020000 - LEA R14,[RDI+00000200]
		Write<uint32>((appBaseAddr + 0x1FCCFC + 3), (enable) ? newOff : off); // dmc3.exe+1FCCFC - 4C 8D B7 00020000 - LEA R14,[RDI+00000200]
		Write<uint32>((appBaseAddr + 0x1FCD6A + 3), (enable) ? newOff : off); // dmc3.exe+1FCD6A - 4C 8D B7 00020000 - LEA R14,[RDI+00000200]
		Write<uint32>((appBaseAddr + 0x1FCDEC + 3), (enable) ? newOff : off); // dmc3.exe+1FCDEC - 4C 8D B7 00020000 - LEA R14,[RDI+00000200]
		Write<uint32>((appBaseAddr + 0x1FCE63 + 3), (enable) ? newOff : off); // dmc3.exe+1FCE63 - 4C 8D B7 00020000 - LEA R14,[RDI+00000200]
		Write<uint32>((appBaseAddr + 0x2005C0 + 3), (enable) ? newOff : off); // dmc3.exe+2005C0 - 48 8D 83 00020000 - LEA RAX,[RBX+00000200]
		Write<uint32>((appBaseAddr + 0x216A1E + 3), (enable) ? newOff : off); // dmc3.exe+216A1E - 48 8D 99 00020000 - LEA RBX,[RCX+00000200]
		Write<uint32>((appBaseAddr + 0x216A55 + 3), (enable) ? newOff : off); // dmc3.exe+216A55 - 48 8D 99 00020000 - LEA RBX,[RCX+00000200]
		Write<uint32>((appBaseAddr + 0x218A2F + 3), (enable) ? newOff : off); // dmc3.exe+218A2F - 48 81 C1 00020000 - ADD RCX,00000200
		Write<uint32>((appBaseAddr + 0x219AA1 + 3), (enable) ? newOff : off); // dmc3.exe+219AA1 - 48 8D 8F 00020000 - LEA RCX,[RDI+00000200]
		Write<uint32>((appBaseAddr + 0x223455 + 3), (enable) ? newOff : off); // dmc3.exe+223455 - 48 81 C1 00020000 - ADD RCX,00000200
		Write<uint32>((appBaseAddr + 0x22347F + 3), (enable) ? newOff : off); // dmc3.exe+22347F - 48 81 C1 00020000 - ADD RCX,00000200
		Write<uint32>((appBaseAddr + 0x2234A7 + 3), (enable) ? newOff : off); // dmc3.exe+2234A7 - 48 81 C1 00020000 - ADD RCX,00000200
		Write<uint32>((appBaseAddr + 0x2234D1 + 3), (enable) ? newOff : off); // dmc3.exe+2234D1 - 48 81 C1 00020000 - ADD RCX,00000200
		Write<uint32>((appBaseAddr + 0x22350F + 3), (enable) ? newOff : off); // dmc3.exe+22350F - 48 81 C1 00020000 - ADD RCX,00000200
		Write<uint32>((appBaseAddr + 0x223528 + 3), (enable) ? newOff : off); // dmc3.exe+223528 - 48 8D 8F 00020000 - LEA RCX,[RDI+00000200]
		Write<uint32>((appBaseAddr + 0x223543 + 3), (enable) ? newOff : off); // dmc3.exe+223543 - 48 81 C1 00020000 - ADD RCX,00000200
		Write<uint32>((appBaseAddr + 0x22355C + 3), (enable) ? newOff : off); // dmc3.exe+22355C - 48 8D 8F 00020000 - LEA RCX,[RDI+00000200]
		Write<uint32>((appBaseAddr + 0x223590 + 3), (enable) ? newOff : off); // dmc3.exe+223590 - 48 81 C1 00020000 - ADD RCX,00000200
		Write<uint32>((appBaseAddr + 0x2235BA + 3), (enable) ? newOff : off); // dmc3.exe+2235BA - 48 81 C1 00020000 - ADD RCX,00000200
		Write<uint32>((appBaseAddr + 0x2235DF + 3), (enable) ? newOff : off); // dmc3.exe+2235DF - 48 8D 8F 00020000 - LEA RCX,[RDI+00000200]
		Write<uint32>((appBaseAddr + 0x2235F8 + 3), (enable) ? newOff : off); // dmc3.exe+2235F8 - 48 8D 8F 00020000 - LEA RCX,[RDI+00000200]
		Write<uint32>((appBaseAddr + 0x223611 + 3), (enable) ? newOff : off); // dmc3.exe+223611 - 48 8D 8F 00020000 - LEA RCX,[RDI+00000200]
		Write<uint32>((appBaseAddr + 0x22362A + 3), (enable) ? newOff : off); // dmc3.exe+22362A - 48 8D 8F 00020000 - LEA RCX,[RDI+00000200]
		Write<uint32>((appBaseAddr + 0x22364D + 3), (enable) ? newOff : off); // dmc3.exe+22364D - 48 8D 8F 00020000 - LEA RCX,[RDI+00000200]
		Write<uint32>((appBaseAddr + 0x223666 + 3), (enable) ? newOff : off); // dmc3.exe+223666 - 48 8D 8F 00020000 - LEA RCX,[RDI+00000200]
		Write<uint32>((appBaseAddr + 0x22367F + 3), (enable) ? newOff : off); // dmc3.exe+22367F - 48 8D 8F 00020000 - LEA RCX,[RDI+00000200]
		Write<uint32>((appBaseAddr + 0x223698 + 3), (enable) ? newOff : off); // dmc3.exe+223698 - 48 8D 8F 00020000 - LEA RCX,[RDI+00000200]
		// Unknown
		// Write<uint32>((appBaseAddr + 0x23470 + 3), (enable) ? newOff : off); // dmc3.exe+23470 - 48 89 8B 00020000 - MOV [RBX+00000200],RCX
		// Write<uint32>((appBaseAddr + 0xDB2A9 + 3), (enable) ? newOff : off); // dmc3.exe+DB2A9 - 48 8B 89 00020000 - MOV RCX,[RCX+00000200]
		// Write<uint32>((appBaseAddr + 0x101747 + 3), (enable) ? newOff : off); // dmc3.exe+101747 - 4C 8D 83 00020000 - LEA R8,[RBX+00000200]
		// Write<uint32>((appBaseAddr + 0x102544 + 3), (enable) ? newOff : off); // dmc3.exe+102544 - 48 8D B1 00020000 - LEA RSI,[RCX+00000200]
		// Write<uint32>((appBaseAddr + 0x102E9F + 3), (enable) ? newOff : off); // dmc3.exe+102E9F - 4C 8D 83 00020000 - LEA R8,[RBX+00000200]
		// Write<uint32>((appBaseAddr + 0x102EE2 + 3), (enable) ? newOff : off); // dmc3.exe+102EE2 - 48 8D 91 00020000 - LEA RDX,[RCX+00000200]
		// Write<uint32>((appBaseAddr + 0x104A5F + 3), (enable) ? newOff : off); // dmc3.exe+104A5F - 4C 8D 8B 00020000 - LEA R9,[RBX+00000200]
		// Write<uint32>((appBaseAddr + 0x104A99 + 3), (enable) ? newOff : off); // dmc3.exe+104A99 - 4C 8D 8B 00020000 - LEA R9,[RBX+00000200]
		// Write<uint32>((appBaseAddr + 0x104AFF + 3), (enable) ? newOff : off); // dmc3.exe+104AFF - 48 81 C1 00020000 - ADD RCX,00000200
		// Write<uint32>((appBaseAddr + 0x104C6F + 3), (enable) ? newOff : off); // dmc3.exe+104C6F - 48 8D B7 00020000 - LEA RSI,[RDI+00000200]
		// Write<uint32>((appBaseAddr + 0x105025 + 3), (enable) ? newOff : off); // dmc3.exe+105025 - 48 8D B7 00020000 - LEA RSI,[RDI+00000200]
		// Write<uint32>((appBaseAddr + 0x105518 + 3), (enable) ? newOff : off); // dmc3.exe+105518 - 48 81 C1 00020000 - ADD RCX,00000200
		// Write<uint32>((appBaseAddr + 0x105A02 + 3), (enable) ? newOff : off); // dmc3.exe+105A02 - 4C 8D 8F 00020000 - LEA R9,[RDI+00000200]
		// Write<uint32>((appBaseAddr + 0x105B4B + 3), (enable) ? newOff : off); // dmc3.exe+105B4B - 4C 8D 87 00020000 - LEA R8,[RDI+00000200]
		// Write<uint32>((appBaseAddr + 0x10630A + 3), (enable) ? newOff : off); // dmc3.exe+10630A - 48 8D B7 00020000 - LEA RSI,[RDI+00000200]
		// Write<uint32>((appBaseAddr + 0x1EF762 + 3), (enable) ? newOff : off); // dmc3.exe+1EF762 - 48 81 C1 00020000 - ADD RCX,00000200
		// Write<uint32>((appBaseAddr + 0x1EF7B3 + 3), (enable) ? newOff : off); // dmc3.exe+1EF7B3 - 48 81 C1 00020000 - ADD RCX,00000200
		// Write<uint32>((appBaseAddr + 0x1EF7F3 + 3), (enable) ? newOff : off); // dmc3.exe+1EF7F3 - 48 81 C1 00020000 - ADD RCX,00000200
		// Write<uint32>((appBaseAddr + 0x1EF82E + 3), (enable) ? newOff : off); // dmc3.exe+1EF82E - 48 81 C1 00020000 - ADD RCX,00000200
		// Write<uint32>((appBaseAddr + 0x1EF867 + 3), (enable) ? newOff : off); // dmc3.exe+1EF867 - 48 81 C1 00020000 - ADD RCX,00000200
		// Write<uint32>((appBaseAddr + 0x1FB70B + 3), (enable) ? newOff : off); // dmc3.exe+1FB70B - 48 8D B3 00020000 - LEA RSI,[RBX+00000200]
		// Write<uint32>((appBaseAddr + 0x1FB88C + 3), (enable) ? newOff : off); // dmc3.exe+1FB88C - 48 8D B3 00020000 - LEA RSI,[RBX+00000200]
		// Write<uint32>((appBaseAddr + 0x1FCBC7 + 3), (enable) ? newOff : off); // dmc3.exe+1FCBC7 - 4C 8D B7 00020000 - LEA R14,[RDI+00000200]
		// Write<uint32>((appBaseAddr + 0x1FCC2D + 3), (enable) ? newOff : off); // dmc3.exe+1FCC2D - 4C 8D B7 00020000 - LEA R14,[RDI+00000200]
		// Write<uint32>((appBaseAddr + 0x2DC32D + 2), (enable) ? newOff : off); // dmc3.exe+2DC32D - 48 05 00020000 - ADD RAX,00000200
		// Write<uint32>((appBaseAddr + 0x2DE765 + 2), (enable) ? newOff : off); // dmc3.exe+2DE765 - 48 05 00020000 - ADD RAX,00000200
		// Write<uint32>((appBaseAddr + 0x2DE827 + 2), (enable) ? newOff : off); // dmc3.exe+2DE827 - 48 05 00020000 - ADD RAX,00000200
		// Write<uint32>((appBaseAddr + 0x2DEB27 + 2), (enable) ? newOff : off); // dmc3.exe+2DEB27 - 48 05 00020000 - ADD RAX,00000200
		// Write<uint32>((appBaseAddr + 0x2FB2DB + 4), (enable) ? newOff : off); // dmc3.exe+2FB2DB - 48 8D 84 01 00020000 - LEA RAX,[RCX+RAX+00000200]
		// Write<uint32>((appBaseAddr + 0x2FB30E + 4), (enable) ? newOff : off); // dmc3.exe+2FB30E - 48 8D 84 01 00020000 - LEA RAX,[RCX+RAX+00000200]
		// Write<uint32>((appBaseAddr + 0x2FB341 + 4), (enable) ? newOff : off); // dmc3.exe+2FB341 - 48 8D 84 01 00020000 - LEA RAX,[RCX+RAX+00000200]
		// Write<uint32>((appBaseAddr + 0x2FB374 + 4), (enable) ? newOff : off); // dmc3.exe+2FB374 - 48 8D 84 01 00020000 - LEA RAX,[RCX+RAX+00000200]
		// Write<uint32>((appBaseAddr + 0x2FB3AC + 4), (enable) ? newOff : off); // dmc3.exe+2FB3AC - 48 8D 84 01 00020000 - LEA RAX,[RCX+RAX+00000200]
		// Write<uint32>((appBaseAddr + 0x2FB3DF + 4), (enable) ? newOff : off); // dmc3.exe+2FB3DF - 48 8D 84 01 00020000 - LEA RAX,[RCX+RAX+00000200]
		// Write<uint32>((appBaseAddr + 0x2FB412 + 4), (enable) ? newOff : off); // dmc3.exe+2FB412 - 48 8D 84 01 00020000 - LEA RAX,[RCX+RAX+00000200]
		// Write<uint32>((appBaseAddr + 0x2FB445 + 4), (enable) ? newOff : off); // dmc3.exe+2FB445 - 48 8D 84 01 00020000 - LEA RAX,[RCX+RAX+00000200]
		// Write<uint32>((appBaseAddr + 0x2FB47D + 4), (enable) ? newOff : off); // dmc3.exe+2FB47D - 48 8D 84 01 00020000 - LEA RAX,[RCX+RAX+00000200]
		// Write<uint32>((appBaseAddr + 0x2FB4B0 + 4), (enable) ? newOff : off); // dmc3.exe+2FB4B0 - 48 8D 84 01 00020000 - LEA RAX,[RCX+RAX+00000200]
		// Write<uint32>((appBaseAddr + 0x2FB4E3 + 4), (enable) ? newOff : off); // dmc3.exe+2FB4E3 - 48 8D 84 01 00020000 - LEA RAX,[RCX+RAX+00000200]
		// Write<uint32>((appBaseAddr + 0x2FB516 + 4), (enable) ? newOff : off); // dmc3.exe+2FB516 - 48 8D 84 01 00020000 - LEA RAX,[RCX+RAX+00000200]
		// Write<uint32>((appBaseAddr + 0x2FB54E + 4), (enable) ? newOff : off); // dmc3.exe+2FB54E - 48 8D 84 01 00020000 - LEA RAX,[RCX+RAX+00000200]
		// Write<uint32>((appBaseAddr + 0x2FB583 + 4), (enable) ? newOff : off); // dmc3.exe+2FB583 - 48 8D 84 01 00020000 - LEA RAX,[RCX+RAX+00000200]
		// Write<uint32>((appBaseAddr + 0x2FB5B8 + 4), (enable) ? newOff : off); // dmc3.exe+2FB5B8 - 48 8D 84 01 00020000 - LEA RAX,[RCX+RAX+00000200]
		// Write<uint32>((appBaseAddr + 0x2FB5ED + 4), (enable) ? newOff : off); // dmc3.exe+2FB5ED - 48 8D 84 01 00020000 - LEA RAX,[RCX+RAX+00000200]
		// Write<uint32>((appBaseAddr + 0x2FB622 + 4), (enable) ? newOff : off); // dmc3.exe+2FB622 - 48 8D 84 01 00020000 - LEA RAX,[RCX+RAX+00000200]
		// Write<uint32>((appBaseAddr + 0x2FB657 + 4), (enable) ? newOff : off); // dmc3.exe+2FB657 - 48 8D 84 01 00020000 - LEA RAX,[RCX+RAX+00000200]
		// Write<uint32>((appBaseAddr + 0x2FB68C + 4), (enable) ? newOff : off); // dmc3.exe+2FB68C - 48 8D 84 01 00020000 - LEA RAX,[RCX+RAX+00000200]
		// Write<uint32>((appBaseAddr + 0x2FB6C1 + 4), (enable) ? newOff : off); // dmc3.exe+2FB6C1 - 48 8D 84 01 00020000 - LEA RAX,[RCX+RAX+00000200]
		// Write<uint32>((appBaseAddr + 0x2FB6F6 + 4), (enable) ? newOff : off); // dmc3.exe+2FB6F6 - 48 8D 84 01 00020000 - LEA RAX,[RCX+RAX+00000200]
		// Write<uint32>((appBaseAddr + 0x2FB72B + 4), (enable) ? newOff : off); // dmc3.exe+2FB72B - 48 8D 84 01 00020000 - LEA RAX,[RCX+RAX+00000200]
		// Write<uint32>((appBaseAddr + 0x2FB760 + 4), (enable) ? newOff : off); // dmc3.exe+2FB760 - 48 8D 84 01 00020000 - LEA RAX,[RCX+RAX+00000200]
		// Write<uint32>((appBaseAddr + 0x2FB795 + 4), (enable) ? newOff : off); // dmc3.exe+2FB795 - 48 8D 84 01 00020000 - LEA RAX,[RCX+RAX+00000200]
		// Write<uint32>((appBaseAddr + 0x2FB7CA + 4), (enable) ? newOff : off); // dmc3.exe+2FB7CA - 48 8D 84 01 00020000 - LEA RAX,[RCX+RAX+00000200]
		// Write<uint32>((appBaseAddr + 0x2FB7FF + 4), (enable) ? newOff : off); // dmc3.exe+2FB7FF - 48 8D 84 01 00020000 - LEA RAX,[RCX+RAX+00000200]
		// Write<uint32>((appBaseAddr + 0x2FB834 + 4), (enable) ? newOff : off); // dmc3.exe+2FB834 - 48 8D 84 01 00020000 - LEA RAX,[RCX+RAX+00000200]
		// Write<uint32>((appBaseAddr + 0x2FB869 + 4), (enable) ? newOff : off); // dmc3.exe+2FB869 - 48 8D 84 01 00020000 - LEA RAX,[RCX+RAX+00000200]
	}
	// 0x208
	{
		constexpr auto off = (__builtin_offsetof(ActorData, modelData[0]) + 8);
		constexpr auto newOff = (__builtin_offsetof(ActorData, newModelData[0]) + 8);
		static_assert(off == 0x208);
		// func_1EF040
		Write<uint32>((appBaseAddr + 0x1EF412 + 3), (enable) ? newOff : off); // dmc3.exe+1EF412 - 49 8D AD 08020000 - LEA RBP,[R13+00000208]
		// Other
		Write<uint32>((appBaseAddr + 0x2005B9 + 3), (enable) ? newOff : off); // dmc3.exe+2005B9 - 48 8D 8B 08020000 - LEA RCX,[RBX+00000208]
		// Unknown
		// Write<uint32>((appBaseAddr + 0x2A108 + 3), (enable) ? newOff : off); // dmc3.exe+2A108 - 48 81 C2 08020000 - ADD RDX,00000208
		// Write<uint32>((appBaseAddr + 0x2A83B + 3), (enable) ? newOff : off); // dmc3.exe+2A83B - 48 81 C3 08020000 - ADD RBX,00000208
		// Write<uint32>((appBaseAddr + 0x2DE34 + 3), (enable) ? newOff : off); // dmc3.exe+2DE34 - 41 B8 08020000 - MOV R8D,00000208
		// Write<uint32>((appBaseAddr + 0x10135F + 3), (enable) ? newOff : off); // dmc3.exe+10135F - 48 89 B9 08020000 - MOV [RCX+00000208],RDI
		// Write<uint32>((appBaseAddr + 0x10461F + 3), (enable) ? newOff : off); // dmc3.exe+10461F - 48 8B 81 08020000 - MOV RAX,[RCX+00000208]
		// Write<uint32>((appBaseAddr + 0x10463F + 3), (enable) ? newOff : off); // dmc3.exe+10463F - 48 89 B1 08020000 - MOV [RCX+00000208],RSI
		// Write<uint32>((appBaseAddr + 0x104646 + 3), (enable) ? newOff : off); // dmc3.exe+104646 - 48 39 B1 08020000 - CMP [RCX+00000208],RSI
		// Write<uint32>((appBaseAddr + 0x1046D3 + 3), (enable) ? newOff : off); // dmc3.exe+1046D3 - 48 8B 87 08020000 - MOV RAX,[RDI+00000208]
		// Write<uint32>((appBaseAddr + 0x104701 + 3), (enable) ? newOff : off); // dmc3.exe+104701 - 48 8B 87 08020000 - MOV RAX,[RDI+00000208]
		// Write<uint32>((appBaseAddr + 0x1050AB + 3), (enable) ? newOff : off); // dmc3.exe+1050AB - F3 0F59 97 08020000 - MULSS XMM2,[RDI+00000208]
		// Write<uint32>((appBaseAddr + 0x105EBF + 3), (enable) ? newOff : off); // dmc3.exe+105EBF - 48 8B 81 08020000 - MOV RAX,[RCX+00000208]
		// Write<uint32>((appBaseAddr + 0x105EDF + 3), (enable) ? newOff : off); // dmc3.exe+105EDF - 48 89 B1 08020000 - MOV [RCX+00000208],RSI
		// Write<uint32>((appBaseAddr + 0x105EE6 + 3), (enable) ? newOff : off); // dmc3.exe+105EE6 - 48 39 B1 08020000 - CMP [RCX+00000208],RSI
		// Write<uint32>((appBaseAddr + 0x105F4E + 3), (enable) ? newOff : off); // dmc3.exe+105F4E - 48 8B 83 08020000 - MOV RAX,[RBX+00000208]
		// Write<uint32>((appBaseAddr + 0x22EE29 + 3), (enable) ? newOff : off); // dmc3.exe+22EE29 - 48 8D 81 08020000 - LEA RAX,[RCX+00000208]
		// Write<uint32>((appBaseAddr + 0x22EF4F + 3), (enable) ? newOff : off); // dmc3.exe+22EF4F - 48 05 08020000 - ADD RAX,00000208
		// Write<uint32>((appBaseAddr + 0x24297E + 3), (enable) ? newOff : off); // dmc3.exe+24297E - 48 8D 8F 08020000 - LEA RCX,[RDI+00000208]
		// Write<uint32>((appBaseAddr + 0x2429A4 + 3), (enable) ? newOff : off); // dmc3.exe+2429A4 - 48 8D 8F 08020000 - LEA RCX,[RDI+00000208]
		// Write<uint32>((appBaseAddr + 0x2429B5 + 3), (enable) ? newOff : off); // dmc3.exe+2429B5 - 48 8D 8F 08020000 - LEA RCX,[RDI+00000208]
		// Write<uint32>((appBaseAddr + 0x242AC0 + 3), (enable) ? newOff : off); // dmc3.exe+242AC0 - 48 8D 8F 08020000 - LEA RCX,[RDI+00000208]
		// Write<uint32>((appBaseAddr + 0x242ADA + 3), (enable) ? newOff : off); // dmc3.exe+242ADA - 48 8D 8F 08020000 - LEA RCX,[RDI+00000208]
		// Write<uint32>((appBaseAddr + 0x242AEB + 3), (enable) ? newOff : off); // dmc3.exe+242AEB - 48 8D 8F 08020000 - LEA RCX,[RDI+00000208]
	}
	// 0x980
	{
		constexpr auto off = __builtin_offsetof(ActorData, modelData[1]) ;
		constexpr auto newOff = __builtin_offsetof(ActorData, newModelData[1]) ;
		static_assert(off == 0x980);
		// func_1EF040
		Write<uint32>((appBaseAddr + 0x1EF2B4 + 3), (enable) ? newOff : off); // dmc3.exe+1EF2B4 - 49 8B 85 80090000 - MOV RAX,[R13+00000980]
		Write<uint32>((appBaseAddr + 0x1EF2C8 + 3), (enable) ? newOff : off); // dmc3.exe+1EF2C8 - 49 8D 8D 80090000 - LEA RCX,[R13+00000980]
		Write<uint32>((appBaseAddr + 0x1EF2D5 + 3), (enable) ? newOff : off); // dmc3.exe+1EF2D5 - 49 8D 8D 80090000 - LEA RCX,[R13+00000980]
		Write<uint32>((appBaseAddr + 0x1EF2EB + 3), (enable) ? newOff : off); // dmc3.exe+1EF2EB - 4D 8D B5 80090000 - LEA R14,[R13+00000980]
	}
	// 0x988
	{
		constexpr auto off = (__builtin_offsetof(ActorData, modelData[1]) + 8);
		constexpr auto newOff = (__builtin_offsetof(ActorData, newModelData[1]) + 8);
		static_assert(off == 0x988);
		// func_1EF040
		Write<uint32>((appBaseAddr + 0x1EF2F2 + 3), (enable) ? newOff : off); // dmc3.exe+1EF2F2 - 49 8D AD 88090000 - lea rbp,[r13+00000988]
	}
	// 0x1100
	{
		constexpr auto off = __builtin_offsetof(ActorData, modelData[2]) ;
		constexpr auto newOff = __builtin_offsetof(ActorData, newModelData[2]) ;
		static_assert(off == 0x1100);
		// func_1EF040
		Write<uint32>((appBaseAddr + 0x1EF188 + 3), (enable) ? newOff : off); // dmc3.exe+1EF188 - 49 8B 85 00110000 - MOV RAX,[R13+00001100]
		Write<uint32>((appBaseAddr + 0x1EF19C + 3), (enable) ? newOff : off); // dmc3.exe+1EF19C - 49 8D 8D 00110000 - LEA RCX,[R13+00001100]
		Write<uint32>((appBaseAddr + 0x1EF1A9 + 3), (enable) ? newOff : off); // dmc3.exe+1EF1A9 - 49 8D 8D 00110000 - LEA RCX,[R13+00001100]
		Write<uint32>((appBaseAddr + 0x1EF1BF + 3), (enable) ? newOff : off); // dmc3.exe+1EF1BF - 4D 8D B5 00110000 - LEA R14,[R13+00001100]
		// Unknown
		// Write<uint32>((appBaseAddr + 0x1400C4 + 3), (enable) ? newOff : off); // dmc3.exe+1400C4 - 48 8B 96 00110000 - MOV RDX,[RSI+00001100]
		// Write<uint32>((appBaseAddr + 0x14051A + 3), (enable) ? newOff : off); // dmc3.exe+14051A - 48 8B 93 00110000 - MOV RDX,[RBX+00001100]
		// Write<uint32>((appBaseAddr + 0x1405E5 + 3), (enable) ? newOff : off); // dmc3.exe+1405E5 - 48 8B 93 00110000 - MOV RDX,[RBX+00001100]
		// Write<uint32>((appBaseAddr + 0x141E29 + 3), (enable) ? newOff : off); // dmc3.exe+141E29 - 48 8B 93 00110000 - MOV RDX,[RBX+00001100]
		// Write<uint32>((appBaseAddr + 0x165F5A + 3), (enable) ? newOff : off); // dmc3.exe+165F5A - 48 8B 81 00110000 - MOV RAX,[RCX+00001100]
		// Write<uint32>((appBaseAddr + 0x165F7A + 3), (enable) ? newOff : off); // dmc3.exe+165F7A - 48 89 B9 00110000 - MOV [RCX+00001100],RDI
		// Write<uint32>((appBaseAddr + 0x165F81 + 3), (enable) ? newOff : off); // dmc3.exe+165F81 - 48 8B 89 00110000 - MOV RCX,[RCX+00001100]
		// Write<uint32>((appBaseAddr + 0x165F92 + 3), (enable) ? newOff : off); // dmc3.exe+165F92 - 48 89 BB 00110000 - MOV [RBX+00001100],RDI
		// Write<uint32>((appBaseAddr + 0x16601A + 3), (enable) ? newOff : off); // dmc3.exe+16601A - 48 8B 81 00110000 - MOV RAX,[RCX+00001100]
		// Write<uint32>((appBaseAddr + 0x16603A + 3), (enable) ? newOff : off); // dmc3.exe+16603A - 48 89 B9 00110000 - MOV [RCX+00001100],RDI
		// Write<uint32>((appBaseAddr + 0x166041 + 3), (enable) ? newOff : off); // dmc3.exe+166041 - 48 39 B9 00110000 - CMP [RCX+00001100],RDI
		// Write<uint32>((appBaseAddr + 0x166061 + 3), (enable) ? newOff : off); // dmc3.exe+166061 - 48 89 83 00110000 - MOV [RBX+00001100],RAX
		// Write<uint32>((appBaseAddr + 0x16608C + 3), (enable) ? newOff : off); // dmc3.exe+16608C - 48 8B 83 00110000 - MOV RAX,[RBX+00001100]
	}
	// 0x1108
	{
		constexpr auto off = (__builtin_offsetof(ActorData, modelData[2]) + 8);
		constexpr auto newOff = (__builtin_offsetof(ActorData, newModelData[2]) + 8);
		static_assert(off == 0x1108);
		// func_1EF040
		Write<uint32>((appBaseAddr + 0x1EF1C6 + 3), (enable) ? newOff : off); // dmc3.exe+1EF1C6 - 49 8D AD 08110000 - lea rbp,[r13+00001108]
	}
	// 0x1880
	{
		constexpr auto off = __builtin_offsetof(ActorData, modelPhysicsMetadataPool[0][0]) ;
		constexpr auto newOff = __builtin_offsetof(ActorData, newModelPhysicsMetadataPool[0][0]) ;
		static_assert(off == 0x1880);
		// Create Actor Dante
		Write<uint32>((appBaseAddr + 0x1DEC5C + 3), (enable) ? newOff : off); // dmc3.exe+1DEC5C - 48 8D 90 80180000 - LEA RDX,[RAX+00001880]
		// Create Actor Bob
		Write<uint32>((appBaseAddr + 0x1DEB43 + 3), (enable) ? newOff : off); // dmc3.exe+1DEB43 - 48 8D 90 80180000 - LEA RDX,[RAX+00001880]
		// Create Actor Lady
		Write<uint32>((appBaseAddr + 0x1DEA47 + 3), (enable) ? newOff : off); // dmc3.exe+1DEA47 - 48 8D 90 80180000 - LEA RDX,[RAX+00001880]
		// Create Actor Vergil
		Write<uint32>((appBaseAddr + 0x1DE92E + 3), (enable) ? newOff : off); // dmc3.exe+1DE92E - 48 8D 90 80180000 - LEA RDX,[RAX+00001880]
		// Update Actor Dante
		Write<uint32>((appBaseAddr + 0x213814 + 4), (enable) ? newOff : off); // dmc3.exe+213814 - 48 8B 8C C6 80180000 - MOV RCX,[RSI+RAX*8+00001880]
		Write<uint32>((appBaseAddr + 0x213873 + 4), (enable) ? newOff : off); // dmc3.exe+213873 - 48 8B 8C C6 80180000 - MOV RCX,[RSI+RAX*8+00001880]
		Write<uint32>((appBaseAddr + 0x2138D2 + 4), (enable) ? newOff : off); // dmc3.exe+2138D2 - 48 8B 8C C6 80180000 - MOV RCX,[RSI+RAX*8+00001880]
		Write<uint32>((appBaseAddr + 0x213C18 + 4), (enable) ? newOff : off); // dmc3.exe+213C18 - 48 8B 8C C6 80180000 - MOV RCX,[RSI+RAX*8+00001880]
		Write<uint32>((appBaseAddr + 0x213C79 + 4), (enable) ? newOff : off); // dmc3.exe+213C79 - 48 8B 8C C6 80180000 - MOV RCX,[RSI+RAX*8+00001880]
		Write<uint32>((appBaseAddr + 0x213ECF + 4), (enable) ? newOff : off); // dmc3.exe+213ECF - 48 8B 8C C6 80180000 - MOV RCX,[RSI+RAX*8+00001880]
		Write<uint32>((appBaseAddr + 0x213F30 + 4), (enable) ? newOff : off); // dmc3.exe+213F30 - 48 8B 8C C6 80180000 - MOV RCX,[RSI+RAX*8+00001880]
		Write<uint32>((appBaseAddr + 0x21440F + 4), (enable) ? newOff : off); // dmc3.exe+21440F - 48 8B 8C C6 80180000 - MOV RCX,[RSI+RAX*8+00001880]
		Write<uint32>((appBaseAddr + 0x21446B + 4), (enable) ? newOff : off); // dmc3.exe+21446B - 48 8B 8C C6 80180000 - MOV RCX,[RSI+RAX*8+00001880]
		Write<uint32>((appBaseAddr + 0x2144C7 + 4), (enable) ? newOff : off); // dmc3.exe+2144C7 - 48 8B 8C C6 80180000 - MOV RCX,[RSI+RAX*8+00001880]
		Write<uint32>((appBaseAddr + 0x2147EC + 4), (enable) ? newOff : off); // dmc3.exe+2147EC - 48 8B 8C C6 80180000 - MOV RCX,[RSI+RAX*8+00001880]
		Write<uint32>((appBaseAddr + 0x21484D + 4), (enable) ? newOff : off); // dmc3.exe+21484D - 48 8B 8C C6 80180000 - MOV RCX,[RSI+RAX*8+00001880]
		Write<uint32>((appBaseAddr + 0x214A9A + 4), (enable) ? newOff : off); // dmc3.exe+214A9A - 48 8B 8C C6 80180000 - MOV RCX,[RSI+RAX*8+00001880]
		Write<uint32>((appBaseAddr + 0x214AF8 + 4), (enable) ? newOff : off); // dmc3.exe+214AF8 - 48 8B 8C C6 80180000 - MOV RCX,[RSI+RAX*8+00001880]
		// Update Actor Bob
		Write<uint32>((appBaseAddr + 0x2261BE + 3), (enable) ? newOff : off); // dmc3.exe+2261BE - 49 8D 96 80180000 - LEA RDX,[R14+00001880]
		Write<uint32>((appBaseAddr + 0x2265C7 + 4), (enable) ? newOff : off); // dmc3.exe+2265C7 - 49 8B 8C C6 80180000 - MOV RCX,[R14+RAX*8+00001880]
		Write<uint32>((appBaseAddr + 0x226638 + 4), (enable) ? newOff : off); // dmc3.exe+226638 - 49 8B 8C C6 80180000 - MOV RCX,[R14+RAX*8+00001880]
		Write<uint32>((appBaseAddr + 0x2267CD + 4), (enable) ? newOff : off); // dmc3.exe+2267CD - 49 8B 8C C6 80180000 - MOV RCX,[R14+RAX*8+00001880]
		Write<uint32>((appBaseAddr + 0x22683E + 4), (enable) ? newOff : off); // dmc3.exe+22683E - 49 8B 8C C6 80180000 - MOV RCX,[R14+RAX*8+00001880]
		// Write<uint32>((appBaseAddr + 0x226B37 + 4), (enable) ? newOff : off); // dmc3.exe+226B37 - 49 8B 8C C6 80180000 - MOV RCX,[R14+RAX*8+00001880]
		// Write<uint32>((appBaseAddr + 0x226BA0 + 4), (enable) ? newOff : off); // dmc3.exe+226BA0 - 49 8B 8C C6 80180000 - MOV RCX,[R14+RAX*8+00001880]
		// Write<uint32>((appBaseAddr + 0x226BFD + 4), (enable) ? newOff : off); // dmc3.exe+226BFD - 49 8B 8C C6 80180000 - MOV RCX,[R14+RAX*8+00001880]
		// Update Actor Lady
		Write<uint32>((appBaseAddr + 0x2194B2 + 3), (enable) ? newOff : off); // dmc3.exe+2194B2 - 48 8D 95 80180000 - LEA RDX,[RBP+00001880]
		// Update Actor Vergil
		Write<uint32>((appBaseAddr + 0x22112F + 4), (enable) ? newOff : off); // dmc3.exe+22112F - 49 8B 8C C4 80180000 - MOV RCX,[R12+RAX*8+00001880]
		Write<uint32>((appBaseAddr + 0x22148C + 4), (enable) ? newOff : off); // dmc3.exe+22148C - 49 8B 8C C4 80180000 - MOV RCX,[R12+RAX*8+00001880]
		Write<uint32>((appBaseAddr + 0x2214E5 + 4), (enable) ? newOff : off); // dmc3.exe+2214E5 - 49 8B 8C C4 80180000 - MOV RCX,[R12+RAX*8+00001880]
		Write<uint32>((appBaseAddr + 0x221551 + 4), (enable) ? newOff : off); // dmc3.exe+221551 - 49 8B 8C C4 80180000 - MOV RCX,[R12+RAX*8+00001880]
		Write<uint32>((appBaseAddr + 0x22188B + 4), (enable) ? newOff : off); // dmc3.exe+22188B - 49 8B 8C C4 80180000 - MOV RCX,[R12+RAX*8+00001880]
		Write<uint32>((appBaseAddr + 0x2218F9 + 4), (enable) ? newOff : off); // dmc3.exe+2218F9 - 49 8B 8C C4 80180000 - MOV RCX,[R12+RAX*8+00001880]
		Write<uint32>((appBaseAddr + 0x221B09 + 4), (enable) ? newOff : off); // dmc3.exe+221B09 - 49 8B 8C C4 80180000 - MOV RCX,[R12+RAX*8+00001880]
		Write<uint32>((appBaseAddr + 0x221B71 + 4), (enable) ? newOff : off); // dmc3.exe+221B71 - 49 8B 8C C4 80180000 - MOV RCX,[R12+RAX*8+00001880]
		// Update Model Dante
		Write<uint32>((appBaseAddr + 0x2151C3 + 3), (enable) ? newOff : off); // dmc3.exe+2151C3 - 49 8D 96 80180000 - LEA RDX,[R14+00001880]
		Write<uint32>((appBaseAddr + 0x215373 + 3), (enable) ? newOff : off); // dmc3.exe+215373 - 49 8D 96 80180000 - LEA RDX,[R14+00001880]
		// Update Model Vergil
		Write<uint32>((appBaseAddr + 0x222653 + 3), (enable) ? newOff : off); // dmc3.exe+222653 - 48 8D 95 80180000 - LEA RDX,[RBP+00001880]
		Write<uint32>((appBaseAddr + 0x2227D3 + 3), (enable) ? newOff : off); // dmc3.exe+2227D3 - 48 8D 95 80180000 - LEA RDX,[RBP+00001880]
		// func_1EF040
		Write<uint32>((appBaseAddr + 0x1EF3ED + 3), (enable) ? newOff : off); // dmc3.exe+1EF3ED - 4D 8D B5 80180000 - LEA R14,[R13+00001880]
		// func_1F7BE0
		Write<uint32>((appBaseAddr + 0x1F7CEE + 4), (enable) ? newOff : off); // dmc3.exe+1F7CEE - 48 8B 94 C3 80180000 - MOV RDX,[RBX+RAX*8+00001880]
		Write<uint32>((appBaseAddr + 0x1F81DE + 4), (enable) ? newOff : off); // dmc3.exe+1F81DE - 48 8B 8C C3 80180000 - MOV RCX,[RBX+RAX*8+00001880]
		// Other
		Write<uint32>((appBaseAddr + 0x8C3B9 + 4), (enable) ? newOff : off); // dmc3.exe+8C3B9 - 49 8B 94 C4 80180000 - MOV RDX,[R12+RAX*8+00001880]
		Write<uint32>((appBaseAddr + 0x8CB96 + 4), (enable) ? newOff : off); // dmc3.exe+8CB96 - 48 8B 8C C3 80180000 - MOV RCX,[RBX+RAX*8+00001880]
		Write<uint32>((appBaseAddr + 0x8FA6B + 4), (enable) ? newOff : off); // dmc3.exe+8FA6B - 49 8B 94 C6 80180000 - MOV RDX,[R14+RAX*8+00001880]
		Write<uint32>((appBaseAddr + 0x8FC47 + 4), (enable) ? newOff : off); // dmc3.exe+8FC47 - 49 8B 94 C6 80180000 - MOV RDX,[R14+RAX*8+00001880]
		Write<uint32>((appBaseAddr + 0x9176B + 4), (enable) ? newOff : off); // dmc3.exe+9176B - 49 8B 94 C6 80180000 - MOV RDX,[R14+RAX*8+00001880]
		Write<uint32>((appBaseAddr + 0x91D6F + 4), (enable) ? newOff : off); // dmc3.exe+91D6F - 49 8B 94 C6 80180000 - MOV RDX,[R14+RAX*8+00001880]
		Write<uint32>((appBaseAddr + 0x91E9D + 4), (enable) ? newOff : off); // dmc3.exe+91E9D - 49 8B 94 C6 80180000 - MOV RDX,[R14+RAX*8+00001880]
		Write<uint32>((appBaseAddr + 0x92289 + 4), (enable) ? newOff : off); // dmc3.exe+92289 - 49 8B 94 C6 80180000 - MOV RDX,[R14+RAX*8+00001880]
		Write<uint32>((appBaseAddr + 0xB9F5A + 3), (enable) ? newOff : off); // dmc3.exe+B9F5A - 48 8B 87 80180000 - MOV RAX,[RDI+00001880]
		Write<uint32>((appBaseAddr + 0xDA8A9 + 4), (enable) ? newOff : off); // dmc3.exe+DA8A9 - 48 8B 94 C7 80180000 - MOV RDX,[RDI+RAX*8+00001880]
		Write<uint32>((appBaseAddr + 0xDA8C5 + 4), (enable) ? newOff : off); // dmc3.exe+DA8C5 - 48 8B 8C C7 80180000 - MOV RCX,[RDI+RAX*8+00001880]
		Write<uint32>((appBaseAddr + 0xDA8E7 + 4), (enable) ? newOff : off); // dmc3.exe+DA8E7 - 48 8B 8C C7 80180000 - MOV RCX,[RDI+RAX*8+00001880]
		Write<uint32>((appBaseAddr + 0x150370 + 4), (enable) ? newOff : off); // dmc3.exe+150370 - 48 8B 8C C3 80180000 - MOV RCX,[RBX+RAX*8+00001880]
		Write<uint32>((appBaseAddr + 0x150395 + 4), (enable) ? newOff : off); // dmc3.exe+150395 - 48 8B 8C C3 80180000 - MOV RCX,[RBX+RAX*8+00001880]
		Write<uint32>((appBaseAddr + 0x16FC58 + 4), (enable) ? newOff : off); // dmc3.exe+16FC58 - 48 8B 8C C3 80180000 - MOV RCX,[RBX+RAX*8+00001880]
		Write<uint32>((appBaseAddr + 0x173072 + 4), (enable) ? newOff : off); // dmc3.exe+173072 - 48 8B 8C C3 80180000 - MOV RCX,[RBX+RAX*8+00001880]
		Write<uint32>((appBaseAddr + 0x173D52 + 4), (enable) ? newOff : off); // dmc3.exe+173D52 - 48 8B 8C C3 80180000 - MOV RCX,[RBX+RAX*8+00001880]
		Write<uint32>((appBaseAddr + 0x17C39B + 4), (enable) ? newOff : off); // dmc3.exe+17C39B - 48 8B 8C C3 80180000 - MOV RCX,[RBX+RAX*8+00001880]
		Write<uint32>((appBaseAddr + 0x17C784 + 4), (enable) ? newOff : off); // dmc3.exe+17C784 - 48 8B 8C C3 80180000 - MOV RCX,[RBX+RAX*8+00001880]
		Write<uint32>((appBaseAddr + 0x17D694 + 4), (enable) ? newOff : off); // dmc3.exe+17D694 - 48 8B 8C C3 80180000 - MOV RCX,[RBX+RAX*8+00001880]
		Write<uint32>((appBaseAddr + 0x17DA05 + 4), (enable) ? newOff : off); // dmc3.exe+17DA05 - 48 8B 8C C3 80180000 - MOV RCX,[RBX+RAX*8+00001880]
		Write<uint32>((appBaseAddr + 0x188FB0 + 4), (enable) ? newOff : off); // dmc3.exe+188FB0 - 48 8B 8C C3 80180000 - MOV RCX,[RBX+RAX*8+00001880]
		Write<uint32>((appBaseAddr + 0x1892AF + 4), (enable) ? newOff : off); // dmc3.exe+1892AF - 48 8B 8C C3 80180000 - MOV RCX,[RBX+RAX*8+00001880]
		Write<uint32>((appBaseAddr + 0x1A35EB + 4), (enable) ? newOff : off); // dmc3.exe+1A35EB - 48 8B 8C C7 80180000 - MOV RCX,[RDI+RAX*8+00001880]
		Write<uint32>((appBaseAddr + 0x1A36FF + 4), (enable) ? newOff : off); // dmc3.exe+1A36FF - 48 8B 8C C7 80180000 - MOV RCX,[RDI+RAX*8+00001880]
		Write<uint32>((appBaseAddr + 0x1B2266 + 4), (enable) ? newOff : off); // dmc3.exe+1B2266 - 48 8B 94 C3 80180000 - MOV RDX,[RBX+RAX*8+00001880]
		Write<uint32>((appBaseAddr + 0x1E946F + 4), (enable) ? newOff : off); // dmc3.exe+1E946F - 48 8B 8C C7 80180000 - MOV RCX,[RDI+RAX*8+00001880]
		Write<uint32>((appBaseAddr + 0x1EAE89 + 4), (enable) ? newOff : off); // dmc3.exe+1EAE89 - 48 8B 94 C3 80180000 - MOV RDX,[RBX+RAX*8+00001880]
		Write<uint32>((appBaseAddr + 0x1EAEE9 + 4), (enable) ? newOff : off); // dmc3.exe+1EAEE9 - 4C 8D 0C C5 80180000 - LEA R9,[RAX*8+00001880]
		Write<uint32>((appBaseAddr + 0x1EAF20 + 4), (enable) ? newOff : off); // dmc3.exe+1EAF20 - 48 8B 94 C3 80180000 - MOV RDX,[RBX+RAX*8+00001880]
		Write<uint32>((appBaseAddr + 0x1EAF79 + 4), (enable) ? newOff : off); // dmc3.exe+1EAF79 - 48 8D 0C C5 80180000 - LEA RCX,[RAX*8+00001880]
		Write<uint32>((appBaseAddr + 0x1ED840 + 4), (enable) ? newOff : off); // dmc3.exe+1ED840 - 48 8B 94 C3 80180000 - MOV RDX,[RBX+RAX*8+00001880]
		Write<uint32>((appBaseAddr + 0x1ED8E2 + 4), (enable) ? newOff : off); // dmc3.exe+1ED8E2 - 48 8B 8C C3 80180000 - MOV RCX,[RBX+RAX*8+00001880]
		Write<uint32>((appBaseAddr + 0x1ED920 + 4), (enable) ? newOff : off); // dmc3.exe+1ED920 - 48 8B 8C C3 80180000 - MOV RCX,[RBX+RAX*8+00001880]
		Write<uint32>((appBaseAddr + 0x1ED9AA + 4), (enable) ? newOff : off); // dmc3.exe+1ED9AA - 48 8B 94 C3 80180000 - MOV RDX,[RBX+RAX*8+00001880]
		Write<uint32>((appBaseAddr + 0x1EDACF + 4), (enable) ? newOff : off); // dmc3.exe+1EDACF - 48 8B 94 CF 80180000 - MOV RDX,[RDI+RCX*8+00001880]
		Write<uint32>((appBaseAddr + 0x1EDB5B + 4), (enable) ? newOff : off); // dmc3.exe+1EDB5B - 48 8B 8C C7 80180000 - MOV RCX,[RDI+RAX*8+00001880]
		Write<uint32>((appBaseAddr + 0x1EDCB4 + 4), (enable) ? newOff : off); // dmc3.exe+1EDCB4 - 48 8B 94 C7 80180000 - MOV RDX,[RDI+RAX*8+00001880]
		Write<uint32>((appBaseAddr + 0x1EE62E + 4), (enable) ? newOff : off); // dmc3.exe+1EE62E - 48 8B 8C C3 80180000 - MOV RCX,[RBX+RAX*8+00001880]
		Write<uint32>((appBaseAddr + 0x1EE690 + 4), (enable) ? newOff : off); // dmc3.exe+1EE690 - 48 8B 94 C3 80180000 - MOV RDX,[RBX+RAX*8+00001880]
		Write<uint32>((appBaseAddr + 0x1EE6ED + 4), (enable) ? newOff : off); // dmc3.exe+1EE6ED - 48 8B 8C C3 80180000 - MOV RCX,[RBX+RAX*8+00001880]
		Write<uint32>((appBaseAddr + 0x1F0764 + 4), (enable) ? newOff : off); // dmc3.exe+1F0764 - 4C 8B 84 C3 80180000 - MOV R8,[RBX+RAX*8+00001880]
		Write<uint32>((appBaseAddr + 0x1F08D5 + 4), (enable) ? newOff : off); // dmc3.exe+1F08D5 - 48 8B 94 C3 80180000 - MOV RDX,[RBX+RAX*8+00001880]
		Write<uint32>((appBaseAddr + 0x1F0D12 + 4), (enable) ? newOff : off); // dmc3.exe+1F0D12 - 48 8B 94 C3 80180000 - MOV RDX,[RBX+RAX*8+00001880]
		Write<uint32>((appBaseAddr + 0x1F0D94 + 4), (enable) ? newOff : off); // dmc3.exe+1F0D94 - 48 8B 94 C3 80180000 - MOV RDX,[RBX+RAX*8+00001880]
		Write<uint32>((appBaseAddr + 0x1F0DC6 + 4), (enable) ? newOff : off); // dmc3.exe+1F0DC6 - 4C 8B 84 C3 80180000 - MOV R8,[RBX+RAX*8+00001880]
		Write<uint32>((appBaseAddr + 0x1F0FE6 + 4), (enable) ? newOff : off); // dmc3.exe+1F0FE6 - 48 8B 8C C3 80180000 - MOV RCX,[RBX+RAX*8+00001880]
		Write<uint32>((appBaseAddr + 0x1F15D5 + 4), (enable) ? newOff : off); // dmc3.exe+1F15D5 - 48 8B 8C C3 80180000 - MOV RCX,[RBX+RAX*8+00001880]
		Write<uint32>((appBaseAddr + 0x1F1B2B + 4), (enable) ? newOff : off); // dmc3.exe+1F1B2B - 48 8B 94 C3 80180000 - MOV RDX,[RBX+RAX*8+00001880]
		Write<uint32>((appBaseAddr + 0x1F1EC0 + 4), (enable) ? newOff : off); // dmc3.exe+1F1EC0 - 48 8B 94 C3 80180000 - MOV RDX,[RBX+RAX*8+00001880]
		Write<uint32>((appBaseAddr + 0x1F22E4 + 4), (enable) ? newOff : off); // dmc3.exe+1F22E4 - 4C 8B 84 C7 80180000 - MOV R8,[RDI+RAX*8+00001880]
		Write<uint32>((appBaseAddr + 0x1F2ECB + 4), (enable) ? newOff : off); // dmc3.exe+1F2ECB - 48 8B 94 C3 80180000 - MOV RDX,[RBX+RAX*8+00001880]
		Write<uint32>((appBaseAddr + 0x1F2FEC + 4), (enable) ? newOff : off); // dmc3.exe+1F2FEC - 48 8B 94 C3 80180000 - MOV RDX,[RBX+RAX*8+00001880]
		Write<uint32>((appBaseAddr + 0x1F353C + 4), (enable) ? newOff : off); // dmc3.exe+1F353C - 48 8B 8C C3 80180000 - MOV RCX,[RBX+RAX*8+00001880]
		Write<uint32>((appBaseAddr + 0x1F359E + 4), (enable) ? newOff : off); // dmc3.exe+1F359E - 48 8B 94 C3 80180000 - MOV RDX,[RBX+RAX*8+00001880]
		Write<uint32>((appBaseAddr + 0x1F35EB + 4), (enable) ? newOff : off); // dmc3.exe+1F35EB - 48 8B 8C C3 80180000 - MOV RCX,[RBX+RAX*8+00001880]
		Write<uint32>((appBaseAddr + 0x1F3669 + 4), (enable) ? newOff : off); // dmc3.exe+1F3669 - 48 8B 8C C3 80180000 - MOV RCX,[RBX+RAX*8+00001880]
		Write<uint32>((appBaseAddr + 0x1F3721 + 4), (enable) ? newOff : off); // dmc3.exe+1F3721 - 4C 8B 84 C3 80180000 - MOV R8,[RBX+RAX*8+00001880]
		Write<uint32>((appBaseAddr + 0x1F39F4 + 4), (enable) ? newOff : off); // dmc3.exe+1F39F4 - 48 8B 94 C3 80180000 - MOV RDX,[RBX+RAX*8+00001880]
		Write<uint32>((appBaseAddr + 0x1F4118 + 4), (enable) ? newOff : off); // dmc3.exe+1F4118 - 4C 8B 84 C3 80180000 - MOV R8,[RBX+RAX*8+00001880]
		Write<uint32>((appBaseAddr + 0x1F4218 + 4), (enable) ? newOff : off); // dmc3.exe+1F4218 - 4C 8B 84 D3 80180000 - MOV R8,[RBX+RDX*8+00001880]
		Write<uint32>((appBaseAddr + 0x1F425D + 4), (enable) ? newOff : off); // dmc3.exe+1F425D - 48 8B 94 C3 80180000 - MOV RDX,[RBX+RAX*8+00001880]
		Write<uint32>((appBaseAddr + 0x1F5721 + 4), (enable) ? newOff : off); // dmc3.exe+1F5721 - 48 8B 94 C6 80180000 - MOV RDX,[RSI+RAX*8+00001880]
		Write<uint32>((appBaseAddr + 0x1F62DD + 4), (enable) ? newOff : off); // dmc3.exe+1F62DD - 48 8B 94 C3 80180000 - MOV RDX,[RBX+RAX*8+00001880]
		Write<uint32>((appBaseAddr + 0x1F6306 + 4), (enable) ? newOff : off); // dmc3.exe+1F6306 - 48 8B 94 C3 80180000 - MOV RDX,[RBX+RAX*8+00001880]
		Write<uint32>((appBaseAddr + 0x1F6350 + 4), (enable) ? newOff : off); // dmc3.exe+1F6350 - 4C 8B 84 C3 80180000 - MOV R8,[RBX+RAX*8+00001880]
		Write<uint32>((appBaseAddr + 0x1F65BE + 4), (enable) ? newOff : off); // dmc3.exe+1F65BE - 48 8B 8C C3 80180000 - MOV RCX,[RBX+RAX*8+00001880]
		Write<uint32>((appBaseAddr + 0x1F7846 + 4), (enable) ? newOff : off); // dmc3.exe+1F7846 - 48 8B 8C C3 80180000 - MOV RCX,[RBX+RAX*8+00001880]
		Write<uint32>((appBaseAddr + 0x1F9791 + 4), (enable) ? newOff : off); // dmc3.exe+1F9791 - 48 8B 94 C3 80180000 - MOV RDX,[RBX+RAX*8+00001880]
		Write<uint32>((appBaseAddr + 0x1FA61A + 4), (enable) ? newOff : off); // dmc3.exe+1FA61A - 48 8B 94 CB 80180000 - MOV RDX,[RBX+RCX*8+00001880]
		Write<uint32>((appBaseAddr + 0x1FAA81 + 4), (enable) ? newOff : off); // dmc3.exe+1FAA81 - 48 8B 84 C1 80180000 - MOV RAX,[RCX+RAX*8+00001880]
		Write<uint32>((appBaseAddr + 0x1FAAA5 + 4), (enable) ? newOff : off); // dmc3.exe+1FAAA5 - 4A 8B 84 C1 80180000 - MOV RAX,[RCX+R8*8+00001880]
		Write<uint32>((appBaseAddr + 0x1FB059 + 4), (enable) ? newOff : off); // dmc3.exe+1FB059 - 4E 8B 8C CB 80180000 - MOV R9,[RBX+R9*8+00001880]
		Write<uint32>((appBaseAddr + 0x1FB065 + 4), (enable) ? newOff : off); // dmc3.exe+1FB065 - 4E 8B 84 C3 80180000 - MOV R8,[RBX+R8*8+00001880]
		Write<uint32>((appBaseAddr + 0x1FB070 + 4), (enable) ? newOff : off); // dmc3.exe+1FB070 - 48 8B 94 C3 80180000 - MOV RDX,[RBX+RAX*8+00001880]
		Write<uint32>((appBaseAddr + 0x1FB09B + 4), (enable) ? newOff : off); // dmc3.exe+1FB09B - 4E 8B 8C CB 80180000 - MOV R9,[RBX+R9*8+00001880]
		Write<uint32>((appBaseAddr + 0x1FB0A7 + 4), (enable) ? newOff : off); // dmc3.exe+1FB0A7 - 4E 8B 84 C3 80180000 - MOV R8,[RBX+R8*8+00001880]
		Write<uint32>((appBaseAddr + 0x1FB0B2 + 4), (enable) ? newOff : off); // dmc3.exe+1FB0B2 - 48 8B 94 C3 80180000 - MOV RDX,[RBX+RAX*8+00001880]
		Write<uint32>((appBaseAddr + 0x1FBAE5 + 4), (enable) ? newOff : off); // dmc3.exe+1FBAE5 - 48 8B 8C C3 80180000 - MOV RCX,[RBX+RAX*8+00001880]
		Write<uint32>((appBaseAddr + 0x1FBBE3 + 4), (enable) ? newOff : off); // dmc3.exe+1FBBE3 - 48 8B 8C CB 80180000 - MOV RCX,[RBX+RCX*8+00001880]
		Write<uint32>((appBaseAddr + 0x1FEE63 + 4), (enable) ? newOff : off); // dmc3.exe+1FEE63 - 48 8B 94 C3 80180000 - MOV RDX,[RBX+RAX*8+00001880]
		Write<uint32>((appBaseAddr + 0x1FEF97 + 4), (enable) ? newOff : off); // dmc3.exe+1FEF97 - 48 8B 94 C3 80180000 - MOV RDX,[RBX+RAX*8+00001880]
		Write<uint32>((appBaseAddr + 0x1FFB74 + 4), (enable) ? newOff : off); // dmc3.exe+1FFB74 - 48 8B 94 C3 80180000 - MOV RDX,[RBX+RAX*8+00001880]
		Write<uint32>((appBaseAddr + 0x1FFD5B + 4), (enable) ? newOff : off); // dmc3.exe+1FFD5B - 48 8B 94 C3 80180000 - MOV RDX,[RBX+RAX*8+00001880]
		Write<uint32>((appBaseAddr + 0x1FFFCC + 4), (enable) ? newOff : off); // dmc3.exe+1FFFCC - 48 8B 94 C3 80180000 - MOV RDX,[RBX+RAX*8+00001880]
		Write<uint32>((appBaseAddr + 0x200604 + 4), (enable) ? newOff : off); // dmc3.exe+200604 - 48 8B 94 C3 80180000 - MOV RDX,[RBX+RAX*8+00001880]
		Write<uint32>((appBaseAddr + 0x20121A + 4), (enable) ? newOff : off); // dmc3.exe+20121A - 48 8B 8C C3 80180000 - MOV RCX,[RBX+RAX*8+00001880]
		Write<uint32>((appBaseAddr + 0x20136A + 4), (enable) ? newOff : off); // dmc3.exe+20136A - 48 8B 94 C3 80180000 - MOV RDX,[RBX+RAX*8+00001880]
		Write<uint32>((appBaseAddr + 0x201471 + 4), (enable) ? newOff : off); // dmc3.exe+201471 - 4C 8B 84 C3 80180000 - MOV R8,[RBX+RAX*8+00001880]
		Write<uint32>((appBaseAddr + 0x201659 + 4), (enable) ? newOff : off); // dmc3.exe+201659 - 48 8B 94 C3 80180000 - MOV RDX,[RBX+RAX*8+00001880]
		Write<uint32>((appBaseAddr + 0x201696 + 4), (enable) ? newOff : off); // dmc3.exe+201696 - 48 8B 94 C3 80180000 - MOV RDX,[RBX+RAX*8+00001880]
		Write<uint32>((appBaseAddr + 0x201B74 + 4), (enable) ? newOff : off); // dmc3.exe+201B74 - 48 8B 94 C7 80180000 - MOV RDX,[RDI+RAX*8+00001880]
		Write<uint32>((appBaseAddr + 0x201D2E + 4), (enable) ? newOff : off); // dmc3.exe+201D2E - 48 8B 94 C7 80180000 - MOV RDX,[RDI+RAX*8+00001880]
		Write<uint32>((appBaseAddr + 0x202155 + 4), (enable) ? newOff : off); // dmc3.exe+202155 - 48 8B 94 C3 80180000 - MOV RDX,[RBX+RAX*8+00001880]
		Write<uint32>((appBaseAddr + 0x2021F9 + 4), (enable) ? newOff : off); // dmc3.exe+2021F9 - 48 8B 94 C3 80180000 - MOV RDX,[RBX+RAX*8+00001880]
		Write<uint32>((appBaseAddr + 0x2026ED + 4), (enable) ? newOff : off); // dmc3.exe+2026ED - 48 8B 94 C3 80180000 - MOV RDX,[RBX+RAX*8+00001880]
		Write<uint32>((appBaseAddr + 0x202974 + 4), (enable) ? newOff : off); // dmc3.exe+202974 - 48 8B 94 C3 80180000 - MOV RDX,[RBX+RAX*8+00001880]
		Write<uint32>((appBaseAddr + 0x202A64 + 4), (enable) ? newOff : off); // dmc3.exe+202A64 - 48 8B 94 C3 80180000 - MOV RDX,[RBX+RAX*8+00001880]
		Write<uint32>((appBaseAddr + 0x203160 + 4), (enable) ? newOff : off); // dmc3.exe+203160 - 48 8B 94 C3 80180000 - MOV RDX,[RBX+RAX*8+00001880]
		Write<uint32>((appBaseAddr + 0x2032F2 + 4), (enable) ? newOff : off); // dmc3.exe+2032F2 - 48 8B 94 C3 80180000 - MOV RDX,[RBX+RAX*8+00001880]
		Write<uint32>((appBaseAddr + 0x20381D + 4), (enable) ? newOff : off); // dmc3.exe+20381D - 48 8B 94 C3 80180000 - MOV RDX,[RBX+RAX*8+00001880]
		Write<uint32>((appBaseAddr + 0x203A34 + 4), (enable) ? newOff : off); // dmc3.exe+203A34 - 48 8B 94 C7 80180000 - MOV RDX,[RDI+RAX*8+00001880]
		Write<uint32>((appBaseAddr + 0x203AE7 + 4), (enable) ? newOff : off); // dmc3.exe+203AE7 - 48 8B 94 C7 80180000 - MOV RDX,[RDI+RAX*8+00001880]
		Write<uint32>((appBaseAddr + 0x204159 + 4), (enable) ? newOff : off); // dmc3.exe+204159 - 48 8B 94 C3 80180000 - MOV RDX,[RBX+RAX*8+00001880]
		Write<uint32>((appBaseAddr + 0x2041CE + 4), (enable) ? newOff : off); // dmc3.exe+2041CE - 48 8B 94 C3 80180000 - MOV RDX,[RBX+RAX*8+00001880]
		Write<uint32>((appBaseAddr + 0x20445E + 4), (enable) ? newOff : off); // dmc3.exe+20445E - 48 8B 94 C3 80180000 - MOV RDX,[RBX+RAX*8+00001880]
		Write<uint32>((appBaseAddr + 0x20454F + 4), (enable) ? newOff : off); // dmc3.exe+20454F - 48 8B 94 C3 80180000 - MOV RDX,[RBX+RAX*8+00001880]
		Write<uint32>((appBaseAddr + 0x2049FF + 4), (enable) ? newOff : off); // dmc3.exe+2049FF - 48 8B 94 C3 80180000 - MOV RDX,[RBX+RAX*8+00001880]
		Write<uint32>((appBaseAddr + 0x205A15 + 4), (enable) ? newOff : off); // dmc3.exe+205A15 - 48 8B 94 C7 80180000 - MOV RDX,[RDI+RAX*8+00001880]
		Write<uint32>((appBaseAddr + 0x205BF3 + 4), (enable) ? newOff : off); // dmc3.exe+205BF3 - 48 8B 94 C7 80180000 - MOV RDX,[RDI+RAX*8+00001880]
		Write<uint32>((appBaseAddr + 0x205D66 + 4), (enable) ? newOff : off); // dmc3.exe+205D66 - 48 8B 94 C3 80180000 - MOV RDX,[RBX+RAX*8+00001880]
		Write<uint32>((appBaseAddr + 0x207241 + 4), (enable) ? newOff : off); // dmc3.exe+207241 - 48 8B 94 C3 80180000 - MOV RDX,[RBX+RAX*8+00001880]
		Write<uint32>((appBaseAddr + 0x209391 + 4), (enable) ? newOff : off); // dmc3.exe+209391 - 48 8B 94 C7 80180000 - MOV RDX,[RDI+RAX*8+00001880]
		Write<uint32>((appBaseAddr + 0x209AD0 + 4), (enable) ? newOff : off); // dmc3.exe+209AD0 - 48 8B 94 C3 80180000 - MOV RDX,[RBX+RAX*8+00001880]
		Write<uint32>((appBaseAddr + 0x209E14 + 4), (enable) ? newOff : off); // dmc3.exe+209E14 - 48 8B 94 C3 80180000 - MOV RDX,[RBX+RAX*8+00001880]
		Write<uint32>((appBaseAddr + 0x209E67 + 4), (enable) ? newOff : off); // dmc3.exe+209E67 - 48 8B 94 C3 80180000 - MOV RDX,[RBX+RAX*8+00001880]
		Write<uint32>((appBaseAddr + 0x209FBA + 4), (enable) ? newOff : off); // dmc3.exe+209FBA - 48 8B 94 C3 80180000 - MOV RDX,[RBX+RAX*8+00001880]
		Write<uint32>((appBaseAddr + 0x20A0A0 + 4), (enable) ? newOff : off); // dmc3.exe+20A0A0 - 48 8B 94 C3 80180000 - MOV RDX,[RBX+RAX*8+00001880]
		Write<uint32>((appBaseAddr + 0x20A127 + 4), (enable) ? newOff : off); // dmc3.exe+20A127 - 48 8B 94 C3 80180000 - MOV RDX,[RBX+RAX*8+00001880]
		Write<uint32>((appBaseAddr + 0x20A230 + 4), (enable) ? newOff : off); // dmc3.exe+20A230 - 48 8B 94 C3 80180000 - MOV RDX,[RBX+RAX*8+00001880]
		Write<uint32>((appBaseAddr + 0x20A301 + 4), (enable) ? newOff : off); // dmc3.exe+20A301 - 48 8B 94 C3 80180000 - MOV RDX,[RBX+RAX*8+00001880]
		Write<uint32>((appBaseAddr + 0x20A7F4 + 4), (enable) ? newOff : off); // dmc3.exe+20A7F4 - 48 8B 94 C3 80180000 - MOV RDX,[RBX+RAX*8+00001880]
		Write<uint32>((appBaseAddr + 0x20AA63 + 4), (enable) ? newOff : off); // dmc3.exe+20AA63 - 48 8B 94 C7 80180000 - MOV RDX,[RDI+RAX*8+00001880]
		Write<uint32>((appBaseAddr + 0x20ABFC + 4), (enable) ? newOff : off); // dmc3.exe+20ABFC - 48 8B 94 C7 80180000 - MOV RDX,[RDI+RAX*8+00001880]
		Write<uint32>((appBaseAddr + 0x20AF79 + 4), (enable) ? newOff : off); // dmc3.exe+20AF79 - 48 8B 94 C3 80180000 - MOV RDX,[RBX+RAX*8+00001880]
		Write<uint32>((appBaseAddr + 0x20B02B + 4), (enable) ? newOff : off); // dmc3.exe+20B02B - 48 8B 94 C3 80180000 - MOV RDX,[RBX+RAX*8+00001880]
		Write<uint32>((appBaseAddr + 0x20B230 + 4), (enable) ? newOff : off); // dmc3.exe+20B230 - 48 8B 94 C3 80180000 - MOV RDX,[RBX+RAX*8+00001880]
		Write<uint32>((appBaseAddr + 0x20B283 + 4), (enable) ? newOff : off); // dmc3.exe+20B283 - 48 8B 94 C3 80180000 - MOV RDX,[RBX+RAX*8+00001880]
		Write<uint32>((appBaseAddr + 0x20B7A4 + 4), (enable) ? newOff : off); // dmc3.exe+20B7A4 - 48 8B 94 C3 80180000 - MOV RDX,[RBX+RAX*8+00001880]
		Write<uint32>((appBaseAddr + 0x20B7CA + 4), (enable) ? newOff : off); // dmc3.exe+20B7CA - 48 8B 94 C3 80180000 - MOV RDX,[RBX+RAX*8+00001880]
		Write<uint32>((appBaseAddr + 0x20BD9F + 4), (enable) ? newOff : off); // dmc3.exe+20BD9F - 48 8B 94 C3 80180000 - MOV RDX,[RBX+RAX*8+00001880]
		Write<uint32>((appBaseAddr + 0x20BDC5 + 4), (enable) ? newOff : off); // dmc3.exe+20BDC5 - 48 8B 94 C3 80180000 - MOV RDX,[RBX+RAX*8+00001880]
		Write<uint32>((appBaseAddr + 0x20C322 + 4), (enable) ? newOff : off); // dmc3.exe+20C322 - 48 8B 94 C3 80180000 - MOV RDX,[RBX+RAX*8+00001880]
		Write<uint32>((appBaseAddr + 0x20C359 + 4), (enable) ? newOff : off); // dmc3.exe+20C359 - 48 8B 94 C3 80180000 - MOV RDX,[RBX+RAX*8+00001880]
		Write<uint32>((appBaseAddr + 0x20C411 + 4), (enable) ? newOff : off); // dmc3.exe+20C411 - 48 8B 94 C3 80180000 - MOV RDX,[RBX+RAX*8+00001880]
		Write<uint32>((appBaseAddr + 0x20C51B + 4), (enable) ? newOff : off); // dmc3.exe+20C51B - 48 8B 94 C3 80180000 - MOV RDX,[RBX+RAX*8+00001880]
		Write<uint32>((appBaseAddr + 0x20C72B + 4), (enable) ? newOff : off); // dmc3.exe+20C72B - 48 8B 94 C7 80180000 - MOV RDX,[RDI+RAX*8+00001880]
		Write<uint32>((appBaseAddr + 0x20CAA2 + 4), (enable) ? newOff : off); // dmc3.exe+20CAA2 - 48 8B 94 C7 80180000 - MOV RDX,[RDI+RAX*8+00001880]
		Write<uint32>((appBaseAddr + 0x20D75E + 4), (enable) ? newOff : off); // dmc3.exe+20D75E - 48 8B 94 C7 80180000 - MOV RDX,[RDI+RAX*8+00001880]
		Write<uint32>((appBaseAddr + 0x20DBFE + 4), (enable) ? newOff : off); // dmc3.exe+20DBFE - 48 8B 94 CB 80180000 - MOV RDX,[RBX+RCX*8+00001880]
		Write<uint32>((appBaseAddr + 0x20DD00 + 4), (enable) ? newOff : off); // dmc3.exe+20DD00 - 48 8B 94 C3 80180000 - MOV RDX,[RBX+RAX*8+00001880]
		Write<uint32>((appBaseAddr + 0x20DFED + 4), (enable) ? newOff : off); // dmc3.exe+20DFED - 48 8B 94 C3 80180000 - MOV RDX,[RBX+RAX*8+00001880]
		Write<uint32>((appBaseAddr + 0x20E1AB + 4), (enable) ? newOff : off); // dmc3.exe+20E1AB - 48 8B 94 C3 80180000 - MOV RDX,[RBX+RAX*8+00001880]
		Write<uint32>((appBaseAddr + 0x20E6C6 + 4), (enable) ? newOff : off); // dmc3.exe+20E6C6 - 48 8B 94 C3 80180000 - MOV RDX,[RBX+RAX*8+00001880]
		Write<uint32>((appBaseAddr + 0x20EC4F + 4), (enable) ? newOff : off); // dmc3.exe+20EC4F - 48 8B 94 C7 80180000 - MOV RDX,[RDI+RAX*8+00001880]
		Write<uint32>((appBaseAddr + 0x20EE46 + 4), (enable) ? newOff : off); // dmc3.exe+20EE46 - 48 8B 94 C3 80180000 - MOV RDX,[RBX+RAX*8+00001880]
		Write<uint32>((appBaseAddr + 0x20F166 + 4), (enable) ? newOff : off); // dmc3.exe+20F166 - 48 8B 94 C7 80180000 - MOV RDX,[RDI+RAX*8+00001880]
		Write<uint32>((appBaseAddr + 0x20F3B2 + 4), (enable) ? newOff : off); // dmc3.exe+20F3B2 - 48 8B 94 C7 80180000 - MOV RDX,[RDI+RAX*8+00001880]
		Write<uint32>((appBaseAddr + 0x20FCAA + 4), (enable) ? newOff : off); // dmc3.exe+20FCAA - 48 8B 8C C3 80180000 - MOV RCX,[RBX+RAX*8+00001880]
		Write<uint32>((appBaseAddr + 0x20FDFA + 4), (enable) ? newOff : off); // dmc3.exe+20FDFA - 48 8B 94 C3 80180000 - MOV RDX,[RBX+RAX*8+00001880]
		Write<uint32>((appBaseAddr + 0x20FF43 + 4), (enable) ? newOff : off); // dmc3.exe+20FF43 - 48 8B 94 C3 80180000 - MOV RDX,[RBX+RAX*8+00001880]
		Write<uint32>((appBaseAddr + 0x2101E2 + 4), (enable) ? newOff : off); // dmc3.exe+2101E2 - 48 8B 94 C7 80180000 - MOV RDX,[RDI+RAX*8+00001880]
		Write<uint32>((appBaseAddr + 0x2106FE + 4), (enable) ? newOff : off); // dmc3.exe+2106FE - 48 8B 94 C3 80180000 - MOV RDX,[RBX+RAX*8+00001880]
		Write<uint32>((appBaseAddr + 0x210829 + 4), (enable) ? newOff : off); // dmc3.exe+210829 - 48 8B 94 C3 80180000 - MOV RDX,[RBX+RAX*8+00001880]
		Write<uint32>((appBaseAddr + 0x210CA2 + 4), (enable) ? newOff : off); // dmc3.exe+210CA2 - 48 8B 94 C3 80180000 - MOV RDX,[RBX+RAX*8+00001880]
		Write<uint32>((appBaseAddr + 0x2114AC + 4), (enable) ? newOff : off); // dmc3.exe+2114AC - 48 8B 94 C6 80180000 - MOV RDX,[RSI+RAX*8+00001880]
		Write<uint32>((appBaseAddr + 0x2119E6 + 4), (enable) ? newOff : off); // dmc3.exe+2119E6 - 48 8B 94 C3 80180000 - MOV RDX,[RBX+RAX*8+00001880]
		Write<uint32>((appBaseAddr + 0x211BAC + 4), (enable) ? newOff : off); // dmc3.exe+211BAC - 48 8B 94 C3 80180000 - MOV RDX,[RBX+RAX*8+00001880]
		Write<uint32>((appBaseAddr + 0x212190 + 4), (enable) ? newOff : off); // dmc3.exe+212190 - 4C 8B 84 C6 80180000 - MOV R8,[RSI+RAX*8+00001880]
		Write<uint32>((appBaseAddr + 0x2121F3 + 4), (enable) ? newOff : off); // dmc3.exe+2121F3 - 48 8B 94 C6 80180000 - MOV RDX,[RSI+RAX*8+00001880]
		Write<uint32>((appBaseAddr + 0x212272 + 4), (enable) ? newOff : off); // dmc3.exe+212272 - 4C 8B 84 C6 80180000 - MOV R8,[RSI+RAX*8+00001880]
		Write<uint32>((appBaseAddr + 0x2122D5 + 4), (enable) ? newOff : off); // dmc3.exe+2122D5 - 48 8B 94 C6 80180000 - MOV RDX,[RSI+RAX*8+00001880]
		Write<uint32>((appBaseAddr + 0x212340 + 4), (enable) ? newOff : off); // dmc3.exe+212340 - 4C 8B 84 C1 80180000 - MOV R8,[RCX+RAX*8+00001880]
		Write<uint32>((appBaseAddr + 0x2123A3 + 4), (enable) ? newOff : off); // dmc3.exe+2123A3 - 48 8B 94 C6 80180000 - MOV RDX,[RSI+RAX*8+00001880]
		Write<uint32>((appBaseAddr + 0x212422 + 4), (enable) ? newOff : off); // dmc3.exe+212422 - 4C 8B 84 C6 80180000 - MOV R8,[RSI+RAX*8+00001880]
		Write<uint32>((appBaseAddr + 0x212485 + 4), (enable) ? newOff : off); // dmc3.exe+212485 - 48 8B 94 C6 80180000 - MOV RDX,[RSI+RAX*8+00001880]
		Write<uint32>((appBaseAddr + 0x212504 + 4), (enable) ? newOff : off); // dmc3.exe+212504 - 4C 8B 84 C6 80180000 - MOV R8,[RSI+RAX*8+00001880]
		Write<uint32>((appBaseAddr + 0x212567 + 4), (enable) ? newOff : off); // dmc3.exe+212567 - 48 8B 94 C6 80180000 - MOV RDX,[RSI+RAX*8+00001880]
		Write<uint32>((appBaseAddr + 0x2125CF + 4), (enable) ? newOff : off); // dmc3.exe+2125CF - 4C 8B 84 C1 80180000 - MOV R8,[RCX+RAX*8+00001880]
		Write<uint32>((appBaseAddr + 0x212632 + 4), (enable) ? newOff : off); // dmc3.exe+212632 - 48 8B 94 C6 80180000 - MOV RDX,[RSI+RAX*8+00001880]
		Write<uint32>((appBaseAddr + 0x21266C + 4), (enable) ? newOff : off); // dmc3.exe+21266C - 48 8B 94 C6 80180000 - MOV RDX,[RSI+RAX*8+00001880]
		Write<uint32>((appBaseAddr + 0x2126D7 + 4), (enable) ? newOff : off); // dmc3.exe+2126D7 - 4C 8B 84 C6 80180000 - MOV R8,[RSI+RAX*8+00001880]
		Write<uint32>((appBaseAddr + 0x21273A + 4), (enable) ? newOff : off); // dmc3.exe+21273A - 48 8B 94 C6 80180000 - MOV RDX,[RSI+RAX*8+00001880]
		Write<uint32>((appBaseAddr + 0x2129AA + 4), (enable) ? newOff : off); // dmc3.exe+2129AA - 48 8B 94 C7 80180000 - MOV RDX,[RDI+RAX*8+00001880]
		Write<uint32>((appBaseAddr + 0x21544F + 4), (enable) ? newOff : off); // dmc3.exe+21544F - 48 8B 94 C7 80180000 - MOV RDX,[RDI+RAX*8+00001880]
		Write<uint32>((appBaseAddr + 0x2160EF + 4), (enable) ? newOff : off); // dmc3.exe+2160EF - 48 8B 94 C7 80180000 - MOV RDX,[RDI+RAX*8+00001880]
		Write<uint32>((appBaseAddr + 0x216157 + 4), (enable) ? newOff : off); // dmc3.exe+216157 - 48 8B 94 C7 80180000 - MOV RDX,[RDI+RAX*8+00001880]
		Write<uint32>((appBaseAddr + 0x216289 + 4), (enable) ? newOff : off); // dmc3.exe+216289 - 48 8B 94 C7 80180000 - MOV RDX,[RDI+RAX*8+00001880]
		Write<uint32>((appBaseAddr + 0x2162F1 + 4), (enable) ? newOff : off); // dmc3.exe+2162F1 - 48 8B 94 C7 80180000 - MOV RDX,[RDI+RAX*8+00001880]
		Write<uint32>((appBaseAddr + 0x21636C + 4), (enable) ? newOff : off); // dmc3.exe+21636C - 48 8B 94 C7 80180000 - MOV RDX,[RDI+RAX*8+00001880]
		Write<uint32>((appBaseAddr + 0x216493 + 4), (enable) ? newOff : off); // dmc3.exe+216493 - 48 8B 94 C7 80180000 - MOV RDX,[RDI+RAX*8+00001880]
		Write<uint32>((appBaseAddr + 0x2166C0 + 4), (enable) ? newOff : off); // dmc3.exe+2166C0 - 4C 8B 84 C7 80180000 - MOV R8,[RDI+RAX*8+00001880]
		Write<uint32>((appBaseAddr + 0x21670F + 4), (enable) ? newOff : off); // dmc3.exe+21670F - 4C 8B 84 C7 80180000 - MOV R8,[RDI+RAX*8+00001880]
		Write<uint32>((appBaseAddr + 0x21677F + 4), (enable) ? newOff : off); // dmc3.exe+21677F - 4C 8B 84 C7 80180000 - MOV R8,[RDI+RAX*8+00001880]
		Write<uint32>((appBaseAddr + 0x2167EF + 4), (enable) ? newOff : off); // dmc3.exe+2167EF - 4C 8B 84 C7 80180000 - MOV R8,[RDI+RAX*8+00001880]
		Write<uint32>((appBaseAddr + 0x21685F + 4), (enable) ? newOff : off); // dmc3.exe+21685F - 4C 8B 84 C7 80180000 - MOV R8,[RDI+RAX*8+00001880]
		Write<uint32>((appBaseAddr + 0x2168CF + 4), (enable) ? newOff : off); // dmc3.exe+2168CF - 4C 8B 84 C7 80180000 - MOV R8,[RDI+RAX*8+00001880]
		Write<uint32>((appBaseAddr + 0x21693F + 4), (enable) ? newOff : off); // dmc3.exe+21693F - 4C 8B 84 C7 80180000 - MOV R8,[RDI+RAX*8+00001880]
		Write<uint32>((appBaseAddr + 0x2169AF + 4), (enable) ? newOff : off); // dmc3.exe+2169AF - 4C 8B 84 C7 80180000 - MOV R8,[RDI+RAX*8+00001880]
		Write<uint32>((appBaseAddr + 0x216BB5 + 4), (enable) ? newOff : off); // dmc3.exe+216BB5 - 48 8B 8C C3 80180000 - MOV RCX,[RBX+RAX*8+00001880]
		Write<uint32>((appBaseAddr + 0x216D3B + 4), (enable) ? newOff : off); // dmc3.exe+216D3B - 48 8B 94 C7 80180000 - MOV RDX,[RDI+RAX*8+00001880]
		Write<uint32>((appBaseAddr + 0x216D8A + 4), (enable) ? newOff : off); // dmc3.exe+216D8A - 48 8B 94 C7 80180000 - MOV RDX,[RDI+RAX*8+00001880]
		Write<uint32>((appBaseAddr + 0x216EF2 + 4), (enable) ? newOff : off); // dmc3.exe+216EF2 - 48 8B 8C C7 80180000 - MOV RCX,[RDI+RAX*8+00001880]
		Write<uint32>((appBaseAddr + 0x21709C + 4), (enable) ? newOff : off); // dmc3.exe+21709C - 48 8B 8C C7 80180000 - MOV RCX,[RDI+RAX*8+00001880]
		Write<uint32>((appBaseAddr + 0x21723B + 4), (enable) ? newOff : off); // dmc3.exe+21723B - 48 8B 8C C7 80180000 - MOV RCX,[RDI+RAX*8+00001880]
		Write<uint32>((appBaseAddr + 0x217387 + 4), (enable) ? newOff : off); // dmc3.exe+217387 - 48 8B 8C C7 80180000 - MOV RCX,[RDI+RAX*8+00001880]
		Write<uint32>((appBaseAddr + 0x218087 + 4), (enable) ? newOff : off); // dmc3.exe+218087 - 48 8B 8C C3 80180000 - MOV RCX,[RBX+RAX*8+00001880]
		Write<uint32>((appBaseAddr + 0x218278 + 4), (enable) ? newOff : off); // dmc3.exe+218278 - 48 8B 8C C3 80180000 - MOV RCX,[RBX+RAX*8+00001880]
		Write<uint32>((appBaseAddr + 0x218358 + 4), (enable) ? newOff : off); // dmc3.exe+218358 - 48 8B 8C C3 80180000 - MOV RCX,[RBX+RAX*8+00001880]
		Write<uint32>((appBaseAddr + 0x218A97 + 4), (enable) ? newOff : off); // dmc3.exe+218A97 - 48 8B 94 C7 80180000 - MOV RDX,[RDI+RAX*8+00001880]
		Write<uint32>((appBaseAddr + 0x218B2D + 4), (enable) ? newOff : off); // dmc3.exe+218B2D - 48 8B 94 C7 80180000 - MOV RDX,[RDI+RAX*8+00001880]
		Write<uint32>((appBaseAddr + 0x218BE0 + 4), (enable) ? newOff : off); // dmc3.exe+218BE0 - 48 8B 94 C7 80180000 - MOV RDX,[RDI+RAX*8+00001880]
		Write<uint32>((appBaseAddr + 0x218C76 + 4), (enable) ? newOff : off); // dmc3.exe+218C76 - 48 8B 94 C7 80180000 - MOV RDX,[RDI+RAX*8+00001880]
		Write<uint32>((appBaseAddr + 0x218D0C + 4), (enable) ? newOff : off); // dmc3.exe+218D0C - 48 8B 94 C7 80180000 - MOV RDX,[RDI+RAX*8+00001880]
		Write<uint32>((appBaseAddr + 0x218DBC + 4), (enable) ? newOff : off); // dmc3.exe+218DBC - 48 8B 94 C7 80180000 - MOV RDX,[RDI+RAX*8+00001880]
		Write<uint32>((appBaseAddr + 0x218E52 + 4), (enable) ? newOff : off); // dmc3.exe+218E52 - 48 8B 94 C7 80180000 - MOV RDX,[RDI+RAX*8+00001880]
		Write<uint32>((appBaseAddr + 0x21A3CA + 4), (enable) ? newOff : off); // dmc3.exe+21A3CA - 48 8B 94 C3 80180000 - MOV RDX,[RBX+RAX*8+00001880]
		Write<uint32>((appBaseAddr + 0x21B1EE + 4), (enable) ? newOff : off); // dmc3.exe+21B1EE - 48 8B 94 C3 80180000 - MOV RDX,[RBX+RAX*8+00001880]
		Write<uint32>((appBaseAddr + 0x21B9DD + 4), (enable) ? newOff : off); // dmc3.exe+21B9DD - 48 8B 94 C3 80180000 - MOV RDX,[RBX+RAX*8+00001880]
		Write<uint32>((appBaseAddr + 0x21BD4F + 4), (enable) ? newOff : off); // dmc3.exe+21BD4F - 48 8B 94 C3 80180000 - MOV RDX,[RBX+RAX*8+00001880]
		Write<uint32>((appBaseAddr + 0x21C0F6 + 4), (enable) ? newOff : off); // dmc3.exe+21C0F6 - 48 8B 94 C3 80180000 - MOV RDX,[RBX+RAX*8+00001880]
		Write<uint32>((appBaseAddr + 0x21C4ED + 4), (enable) ? newOff : off); // dmc3.exe+21C4ED - 48 8B 94 C3 80180000 - MOV RDX,[RBX+RAX*8+00001880]
		Write<uint32>((appBaseAddr + 0x21C801 + 4), (enable) ? newOff : off); // dmc3.exe+21C801 - 48 8B 94 C3 80180000 - MOV RDX,[RBX+RAX*8+00001880]
		Write<uint32>((appBaseAddr + 0x21C9A4 + 4), (enable) ? newOff : off); // dmc3.exe+21C9A4 - 48 8B 94 C3 80180000 - MOV RDX,[RBX+RAX*8+00001880]
		Write<uint32>((appBaseAddr + 0x21CBC0 + 4), (enable) ? newOff : off); // dmc3.exe+21CBC0 - 48 8B 8C C3 80180000 - MOV RCX,[RBX+RAX*8+00001880]
		Write<uint32>((appBaseAddr + 0x21CCF1 + 4), (enable) ? newOff : off); // dmc3.exe+21CCF1 - 48 8B 8C C3 80180000 - MOV RCX,[RBX+RAX*8+00001880]
		Write<uint32>((appBaseAddr + 0x21CDE5 + 4), (enable) ? newOff : off); // dmc3.exe+21CDE5 - 48 8B 94 C3 80180000 - MOV RDX,[RBX+RAX*8+00001880]
		Write<uint32>((appBaseAddr + 0x21CE48 + 4), (enable) ? newOff : off); // dmc3.exe+21CE48 - 48 8B 94 C3 80180000 - MOV RDX,[RBX+RAX*8+00001880]
		Write<uint32>((appBaseAddr + 0x21D214 + 4), (enable) ? newOff : off); // dmc3.exe+21D214 - 48 8B 94 C7 80180000 - MOV RDX,[RDI+RAX*8+00001880]
		Write<uint32>((appBaseAddr + 0x21D314 + 4), (enable) ? newOff : off); // dmc3.exe+21D314 - 48 8B 94 C7 80180000 - MOV RDX,[RDI+RAX*8+00001880]
		Write<uint32>((appBaseAddr + 0x21DA7A + 4), (enable) ? newOff : off); // dmc3.exe+21DA7A - 48 8B 94 C3 80180000 - MOV RDX,[RBX+RAX*8+00001880]
		Write<uint32>((appBaseAddr + 0x21DAED + 4), (enable) ? newOff : off); // dmc3.exe+21DAED - 48 8B 8C C3 80180000 - MOV RCX,[RBX+RAX*8+00001880]
		Write<uint32>((appBaseAddr + 0x21DD32 + 4), (enable) ? newOff : off); // dmc3.exe+21DD32 - 48 8B 94 C3 80180000 - MOV RDX,[RBX+RAX*8+00001880]
		Write<uint32>((appBaseAddr + 0x21DDF0 + 4), (enable) ? newOff : off); // dmc3.exe+21DDF0 - 48 8B 94 C3 80180000 - MOV RDX,[RBX+RAX*8+00001880]
		Write<uint32>((appBaseAddr + 0x21DF4B + 4), (enable) ? newOff : off); // dmc3.exe+21DF4B - 48 8B 94 C3 80180000 - MOV RDX,[RBX+RAX*8+00001880]
		Write<uint32>((appBaseAddr + 0x21E0D3 + 4), (enable) ? newOff : off); // dmc3.exe+21E0D3 - 48 8B 94 C3 80180000 - MOV RDX,[RBX+RAX*8+00001880]
		Write<uint32>((appBaseAddr + 0x21E3A2 + 4), (enable) ? newOff : off); // dmc3.exe+21E3A2 - 48 8B 94 C3 80180000 - MOV RDX,[RBX+RAX*8+00001880]
		Write<uint32>((appBaseAddr + 0x21EB05 + 4), (enable) ? newOff : off); // dmc3.exe+21EB05 - 48 8B 94 C3 80180000 - MOV RDX,[RBX+RAX*8+00001880]
		Write<uint32>((appBaseAddr + 0x21ED0A + 4), (enable) ? newOff : off); // dmc3.exe+21ED0A - 48 8B 94 C7 80180000 - MOV RDX,[RDI+RAX*8+00001880]
		Write<uint32>((appBaseAddr + 0x21EECA + 4), (enable) ? newOff : off); // dmc3.exe+21EECA - 48 8B 94 C7 80180000 - MOV RDX,[RDI+RAX*8+00001880]
		Write<uint32>((appBaseAddr + 0x21F014 + 4), (enable) ? newOff : off); // dmc3.exe+21F014 - 48 8B 94 C3 80180000 - MOV RDX,[RBX+RAX*8+00001880]
		Write<uint32>((appBaseAddr + 0x21F6EC + 4), (enable) ? newOff : off); // dmc3.exe+21F6EC - 48 8B 94 C7 80180000 - MOV RDX,[RDI+RAX*8+00001880]
		Write<uint32>((appBaseAddr + 0x21F8FE + 4), (enable) ? newOff : off); // dmc3.exe+21F8FE - 48 8B 94 C3 80180000 - MOV RDX,[RBX+RAX*8+00001880]
		Write<uint32>((appBaseAddr + 0x21F9EF + 4), (enable) ? newOff : off); // dmc3.exe+21F9EF - 48 8B 94 C3 80180000 - MOV RDX,[RBX+RAX*8+00001880]
		Write<uint32>((appBaseAddr + 0x21FADF + 4), (enable) ? newOff : off); // dmc3.exe+21FADF - 48 8B 94 C3 80180000 - MOV RDX,[RBX+RAX*8+00001880]
		Write<uint32>((appBaseAddr + 0x21FC5B + 4), (enable) ? newOff : off); // dmc3.exe+21FC5B - 48 8B 94 C3 80180000 - MOV RDX,[RBX+RAX*8+00001880]
		Write<uint32>((appBaseAddr + 0x21FCD1 + 4), (enable) ? newOff : off); // dmc3.exe+21FCD1 - 48 8B 8C C3 80180000 - MOV RCX,[RBX+RAX*8+00001880]
		Write<uint32>((appBaseAddr + 0x21FF27 + 4), (enable) ? newOff : off); // dmc3.exe+21FF27 - 48 8B 94 C3 80180000 - MOV RDX,[RBX+RAX*8+00001880]
		Write<uint32>((appBaseAddr + 0x220032 + 4), (enable) ? newOff : off); // dmc3.exe+220032 - 48 8B 94 C3 80180000 - MOV RDX,[RBX+RAX*8+00001880]
		Write<uint32>((appBaseAddr + 0x220059 + 4), (enable) ? newOff : off); // dmc3.exe+220059 - 48 8B 94 C3 80180000 - MOV RDX,[RBX+RAX*8+00001880]
		Write<uint32>((appBaseAddr + 0x22019D + 4), (enable) ? newOff : off); // dmc3.exe+22019D - 48 8B 94 C3 80180000 - MOV RDX,[RBX+RAX*8+00001880]
		Write<uint32>((appBaseAddr + 0x2201D0 + 4), (enable) ? newOff : off); // dmc3.exe+2201D0 - 48 8B 94 C3 80180000 - MOV RDX,[RBX+RAX*8+00001880]
		Write<uint32>((appBaseAddr + 0x2202A5 + 4), (enable) ? newOff : off); // dmc3.exe+2202A5 - 48 8B 94 C3 80180000 - MOV RDX,[RBX+RAX*8+00001880]
		Write<uint32>((appBaseAddr + 0x220595 + 4), (enable) ? newOff : off); // dmc3.exe+220595 - 4C 8B 84 C6 80180000 - MOV R8,[RSI+RAX*8+00001880]
		Write<uint32>((appBaseAddr + 0x2205EA + 4), (enable) ? newOff : off); // dmc3.exe+2205EA - 48 8B 94 C6 80180000 - MOV RDX,[RSI+RAX*8+00001880]
		Write<uint32>((appBaseAddr + 0x22060A + 4), (enable) ? newOff : off); // dmc3.exe+22060A - 48 8B 94 C6 80180000 - MOV RDX,[RSI+RAX*8+00001880]
		Write<uint32>((appBaseAddr + 0x220644 + 4), (enable) ? newOff : off); // dmc3.exe+220644 - 4C 8B 84 C6 80180000 - MOV R8,[RSI+RAX*8+00001880]
		Write<uint32>((appBaseAddr + 0x22069D + 4), (enable) ? newOff : off); // dmc3.exe+22069D - 48 8B 94 C6 80180000 - MOV RDX,[RSI+RAX*8+00001880]
		Write<uint32>((appBaseAddr + 0x2206BD + 4), (enable) ? newOff : off); // dmc3.exe+2206BD - 48 8B 94 C6 80180000 - MOV RDX,[RSI+RAX*8+00001880]
		Write<uint32>((appBaseAddr + 0x22071E + 4), (enable) ? newOff : off); // dmc3.exe+22071E - 4C 8B 84 C6 80180000 - MOV R8,[RSI+RAX*8+00001880]
		Write<uint32>((appBaseAddr + 0x220777 + 4), (enable) ? newOff : off); // dmc3.exe+220777 - 48 8B 94 C6 80180000 - MOV RDX,[RSI+RAX*8+00001880]
		Write<uint32>((appBaseAddr + 0x220797 + 4), (enable) ? newOff : off); // dmc3.exe+220797 - 48 8B 94 C6 80180000 - MOV RDX,[RSI+RAX*8+00001880]
		Write<uint32>((appBaseAddr + 0x2207C3 + 4), (enable) ? newOff : off); // dmc3.exe+2207C3 - 4C 8B 84 C6 80180000 - MOV R8,[RSI+RAX*8+00001880]
		Write<uint32>((appBaseAddr + 0x22081C + 4), (enable) ? newOff : off); // dmc3.exe+22081C - 48 8B 94 C6 80180000 - MOV RDX,[RSI+RAX*8+00001880]
		Write<uint32>((appBaseAddr + 0x22083C + 4), (enable) ? newOff : off); // dmc3.exe+22083C - 48 8B 94 C6 80180000 - MOV RDX,[RSI+RAX*8+00001880]
		Write<uint32>((appBaseAddr + 0x220894 + 4), (enable) ? newOff : off); // dmc3.exe+220894 - 48 8B 94 C6 80180000 - MOV RDX,[RSI+RAX*8+00001880]
		Write<uint32>((appBaseAddr + 0x222C61 + 4), (enable) ? newOff : off); // dmc3.exe+222C61 - 48 8B 94 C7 80180000 - MOV RDX,[RDI+RAX*8+00001880]
		Write<uint32>((appBaseAddr + 0x22316A + 4), (enable) ? newOff : off); // dmc3.exe+22316A - 4C 8B 84 C3 80180000 - MOV R8,[RBX+RAX*8+00001880]
		Write<uint32>((appBaseAddr + 0x2231DB + 4), (enable) ? newOff : off); // dmc3.exe+2231DB - 4C 8B 84 C3 80180000 - MOV R8,[RBX+RAX*8+00001880]
		Write<uint32>((appBaseAddr + 0x223223 + 4), (enable) ? newOff : off); // dmc3.exe+223223 - 48 8B 94 C3 80180000 - MOV RDX,[RBX+RAX*8+00001880]
		Write<uint32>((appBaseAddr + 0x223295 + 4), (enable) ? newOff : off); // dmc3.exe+223295 - 4C 8B 84 C3 80180000 - MOV R8,[RBX+RAX*8+00001880]
		Write<uint32>((appBaseAddr + 0x2232D9 + 4), (enable) ? newOff : off); // dmc3.exe+2232D9 - 4C 8B 84 C3 80180000 - MOV R8,[RBX+RAX*8+00001880]
		Write<uint32>((appBaseAddr + 0x223335 + 4), (enable) ? newOff : off); // dmc3.exe+223335 - 48 8B 94 C3 80180000 - MOV RDX,[RBX+RAX*8+00001880]
		Write<uint32>((appBaseAddr + 0x2233A8 + 4), (enable) ? newOff : off); // dmc3.exe+2233A8 - 4C 8B 84 C3 80180000 - MOV R8,[RBX+RAX*8+00001880]
		Write<uint32>((appBaseAddr + 0x2233EF + 4), (enable) ? newOff : off); // dmc3.exe+2233EF - 48 8B 94 C3 80180000 - MOV RDX,[RBX+RAX*8+00001880]
		Write<uint32>((appBaseAddr + 0x22464B + 4), (enable) ? newOff : off); // dmc3.exe+22464B - 48 8B 94 C3 80180000 - MOV RDX,[RBX+RAX*8+00001880]
		Write<uint32>((appBaseAddr + 0x2246DD + 4), (enable) ? newOff : off); // dmc3.exe+2246DD - 48 8B 94 C3 80180000 - MOV RDX,[RBX+RAX*8+00001880]
		Write<uint32>((appBaseAddr + 0x224D88 + 4), (enable) ? newOff : off); // dmc3.exe+224D88 - 48 8B 94 C3 80180000 - MOV RDX,[RBX+RAX*8+00001880]
		Write<uint32>((appBaseAddr + 0x2251F2 + 4), (enable) ? newOff : off); // dmc3.exe+2251F2 - 48 8B 8C C3 80180000 - MOV RCX,[RBX+RAX*8+00001880]
		Write<uint32>((appBaseAddr + 0x22531D + 4), (enable) ? newOff : off); // dmc3.exe+22531D - 48 8B 94 C3 80180000 - MOV RDX,[RBX+RAX*8+00001880]
		Write<uint32>((appBaseAddr + 0x22553B + 4), (enable) ? newOff : off); // dmc3.exe+22553B - 48 8B 94 C3 80180000 - MOV RDX,[RBX+RAX*8+00001880]
		Write<uint32>((appBaseAddr + 0x225602 + 4), (enable) ? newOff : off); // dmc3.exe+225602 - 48 8B 94 C3 80180000 - MOV RDX,[RBX+RAX*8+00001880]
		Write<uint32>((appBaseAddr + 0x225846 + 4), (enable) ? newOff : off); // dmc3.exe+225846 - 48 8B 94 C3 80180000 - MOV RDX,[RBX+RAX*8+00001880]
		Write<uint32>((appBaseAddr + 0x2258AE + 4), (enable) ? newOff : off); // dmc3.exe+2258AE - 4C 8B 84 C3 80180000 - MOV R8,[RBX+RAX*8+00001880]
		Write<uint32>((appBaseAddr + 0x225A40 + 3), (enable) ? newOff : off); // dmc3.exe+225A40 - 4C 8B 83 80180000 - MOV R8,[RBX+00001880]
		Write<uint32>((appBaseAddr + 0x225A93 + 3), (enable) ? newOff : off); // dmc3.exe+225A93 - 48 8B 93 80180000 - MOV RDX,[RBX+00001880]
		Write<uint32>((appBaseAddr + 0x225BDD + 4), (enable) ? newOff : off); // dmc3.exe+225BDD - 4C 8B 84 C3 80180000 - MOV R8,[RBX+RAX*8+00001880]
		Write<uint32>((appBaseAddr + 0x225C36 + 4), (enable) ? newOff : off); // dmc3.exe+225C36 - 48 8B 94 C3 80180000 - MOV RDX,[RBX+RAX*8+00001880]
		Write<uint32>((appBaseAddr + 0x225C56 + 4), (enable) ? newOff : off); // dmc3.exe+225C56 - 48 8B 94 C3 80180000 - MOV RDX,[RBX+RAX*8+00001880]
		Write<uint32>((appBaseAddr + 0x225C82 + 4), (enable) ? newOff : off); // dmc3.exe+225C82 - 4C 8B 84 C3 80180000 - MOV R8,[RBX+RAX*8+00001880]
		Write<uint32>((appBaseAddr + 0x225CDB + 4), (enable) ? newOff : off); // dmc3.exe+225CDB - 48 8B 94 C3 80180000 - MOV RDX,[RBX+RAX*8+00001880]
		Write<uint32>((appBaseAddr + 0x225CFB + 4), (enable) ? newOff : off); // dmc3.exe+225CFB - 48 8B 94 C3 80180000 - MOV RDX,[RBX+RAX*8+00001880]
		Write<uint32>((appBaseAddr + 0x225D47 + 4), (enable) ? newOff : off); // dmc3.exe+225D47 - 48 8B 94 C3 80180000 - MOV RDX,[RBX+RAX*8+00001880]
		Write<uint32>((appBaseAddr + 0x226E08 + 4), (enable) ? newOff : off); // dmc3.exe+226E08 - 4C 8B 84 C3 80180000 - MOV R8,[RBX+RAX*8+00001880]
		Write<uint32>((appBaseAddr + 0x226E75 + 4), (enable) ? newOff : off); // dmc3.exe+226E75 - 4C 8B 84 C3 80180000 - MOV R8,[RBX+RAX*8+00001880]
		Write<uint32>((appBaseAddr + 0x22737C + 4), (enable) ? newOff : off); // dmc3.exe+22737C - 48 8B 94 C3 80180000 - MOV RDX,[RBX+RAX*8+00001880]
		Write<uint32>((appBaseAddr + 0x27A7E8 + 4), (enable) ? newOff : off); // dmc3.exe+27A7E8 - 48 8B 94 C3 80180000 - MOV RDX,[RBX+RAX*8+00001880]
		// Unknown
		// Write<uint32>((appBaseAddr + 0x8CBB3 + 4), (enable) ? newOff : off); // dmc3.exe+8CBB3 - 48 8B 8C C3 80180000 - MOV RCX,[RBX+RAX*8+00001880]
		// Write<uint32>((appBaseAddr + 0x1F61AF + 4), (enable) ? newOff : off); // dmc3.exe+1F61AF - 48 8B 94 C3 80180000 - MOV RDX,[RBX+RAX*8+00001880]
		// Write<uint32>((appBaseAddr + 0x216129 + 4), (enable) ? newOff : off); // dmc3.exe+216129 - 48 8B 94 C7 80180000 - MOV RDX,[RDI+RAX*8+00001880]
		// Write<uint32>((appBaseAddr + 0x2162C3 + 4), (enable) ? newOff : off); // dmc3.exe+2162C3 - 48 8B 94 C7 80180000 - MOV RDX,[RDI+RAX*8+00001880]
		// Write<uint32>((appBaseAddr + 0x224ED8 + 4), (enable) ? newOff : off); // dmc3.exe+224ED8 - 48 8B 94 C3 80180000 - MOV RDX,[RBX+RAX*8+00001880]
		// Write<uint32>((appBaseAddr + 0x225028 + 4), (enable) ? newOff : off); // dmc3.exe+225028 - 48 8B 94 C3 80180000 - MOV RDX,[RBX+RAX*8+00001880]
		// Write<uint32>((appBaseAddr + 0x225B03 + 4), (enable) ? newOff : off); // dmc3.exe+225B03 - 4C 8B 84 C3 80180000 - MOV R8,[RBX+RAX*8+00001880]
		// Write<uint32>((appBaseAddr + 0x225B5C + 4), (enable) ? newOff : off); // dmc3.exe+225B5C - 48 8B 94 C3 80180000 - MOV RDX,[RBX+RAX*8+00001880]
		// Write<uint32>((appBaseAddr + 0x225B83 + 4), (enable) ? newOff : off); // dmc3.exe+225B83 - 48 8B 94 C3 80180000 - MOV RDX,[RBX+RAX*8+00001880]
		// Write<uint32>((appBaseAddr + 0x226EE2 + 4), (enable) ? newOff : off); // dmc3.exe+226EE2 - 4C 8B 84 C3 80180000 - MOV R8,[RBX+RAX*8+00001880]
		// 0x310
		{
			constexpr auto off = (__builtin_offsetof(ActorData, modelPhysicsMetadataPool[0][0]) / 8);
			constexpr auto newOff = (__builtin_offsetof(ActorData, newModelPhysicsMetadataPool[0][0]) / 8);
			static_assert(off == 0x310);
			// Update Actor Dante
			Write<uint32>((appBaseAddr + 0x213E42 + 2), (enable) ? newOff : off); // dmc3.exe+213E42 - 48 05 10030000 - ADD RAX,00000310
			Write<uint32>((appBaseAddr + 0x214A06 + 2), (enable) ? newOff : off); // dmc3.exe+214A06 - 48 05 10030000 - ADD RAX,00000310
			// Update Actor Vergil
			Write<uint32>((appBaseAddr + 0x221077 + 2), (enable) ? newOff : off); // dmc3.exe+221077 - 48 05 10030000 - ADD RAX,00000310
			// Other
			Write<uint32>((appBaseAddr + 0x1DF131 + 3), (enable) ? newOff : off); // dmc3.exe+1DF131 - 48 81 C3 10030000 - ADD RBX,00000310
			// Unknown
			// Write<uint32>((appBaseAddr + 0x271850 + 3), (enable) ? newOff : off); // dmc3.exe+271850 - 48 81 C1 10030000 - ADD RCX,00000310
		}
		// 0x1820
		{
			constexpr auto off = (__builtin_offsetof(ActorData, modelPhysicsMetadataPool[0][0]) - 0x60);
			constexpr auto newOff = (__builtin_offsetof(ActorData, newModelPhysicsMetadataPool[0][0]) - 0x60);
			static_assert(off == 0x1820);
			// Other
			Write<uint32>((appBaseAddr + 0x1ED65A + 4), (enable) ? newOff : off); // dmc3.exe+1ED65A - 48 8B 94 C3 20180000 - MOV RDX,[RBX+RAX*8+00001820]
			// Unknown
			// Write<uint32>((appBaseAddr + 0xFA7F2 + 3), (enable) ? newOff : off); // dmc3.exe+FA7F2 - 48 8D 8E 20180000 - LEA RCX,[RSI+00001820]
			// Write<uint32>((appBaseAddr + 0xFA8B2 + 3), (enable) ? newOff : off); // dmc3.exe+FA8B2 - 48 8D 8E 20180000 - LEA RCX,[RSI+00001820]
		}
	}
	// 0x1888
	{
		constexpr auto off = __builtin_offsetof(ActorData, modelPhysicsMetadataPool[0][1]) ;
		constexpr auto newOff = __builtin_offsetof(ActorData, newModelPhysicsMetadataPool[0][1]) ;
		static_assert(off == 0x1888);
		// func_1EF040
		Write<uint32>((appBaseAddr + 0x1EF434 + 3), (enable) ? newOff : off); // dmc3.exe+1EF434 - 49 8B 85 88180000 - MOV RAX,[R13+00001888]
		// Other
		Write<uint32>((appBaseAddr + 0xBA9DE + 3), (enable) ? newOff : off); // dmc3.exe+BA9DE - 48 8B 96 88180000 - MOV RDX,[RSI+00001888]
		Write<uint32>((appBaseAddr + 0xBAAE5 + 3), (enable) ? newOff : off); // dmc3.exe+BAAE5 - 48 8B 96 88180000 - MOV RDX,[RSI+00001888]
		Write<uint32>((appBaseAddr + 0x212096 + 3), (enable) ? newOff : off); // dmc3.exe+212096 - 4C 8B 86 88180000 - MOV R8,[RSI+00001888]
		Write<uint32>((appBaseAddr + 0x2120E6 + 3), (enable) ? newOff : off); // dmc3.exe+2120E6 - 48 8B 96 88180000 - MOV RDX,[RSI+00001888]
		Write<uint32>((appBaseAddr + 0x2191DF + 3), (enable) ? newOff : off); // dmc3.exe+2191DF - 4C 8B 81 88180000 - MOV R8,[RCX+00001888]
		Write<uint32>((appBaseAddr + 0x21922C + 3), (enable) ? newOff : off); // dmc3.exe+21922C - 48 8B 97 88180000 - MOV RDX,[RDI+00001888]
		Write<uint32>((appBaseAddr + 0x2204D4 + 3), (enable) ? newOff : off); // dmc3.exe+2204D4 - 4C 8B 81 88180000 - MOV R8,[RCX+00001888]
		Write<uint32>((appBaseAddr + 0x220528 + 3), (enable) ? newOff : off); // dmc3.exe+220528 - 48 8B 96 88180000 - MOV RDX,[RSI+00001888]
	}
	// 0x1890
	{
		constexpr auto off = __builtin_offsetof(ActorData, modelPhysicsMetadataPool[0][2]) ;
		constexpr auto newOff = __builtin_offsetof(ActorData, newModelPhysicsMetadataPool[0][2]) ;
		static_assert(off == 0x1890);
		// func_1EF040
		Write<uint32>((appBaseAddr + 0x1EF30A + 3), (enable) ? newOff : off); // dmc3.exe+1EF30A - 49 8B 85 90180000 - MOV RAX,[R13+00001890]
	}
	// 0x1898
	{
		constexpr auto off = __builtin_offsetof(ActorData, modelPhysicsMetadataPool[0][3]) ;
		constexpr auto newOff = __builtin_offsetof(ActorData, newModelPhysicsMetadataPool[0][3]) ;
		static_assert(off == 0x1898);
		// func_1EF040
		Write<uint32>((appBaseAddr + 0x1EF1DE + 3), (enable) ? newOff : off); // dmc3.exe+1EF1DE - 49 8B 85 98180000 - MOV RAX,[R13+00001898]
		// Other
		Write<uint32>((appBaseAddr + 0xB9DF1 + 3), (enable) ? newOff : off); // dmc3.exe+B9DF1 - 48 8B 87 98180000 - MOV RAX,[RDI+00001898]
		Write<uint32>((appBaseAddr + 0xBA06E + 3), (enable) ? newOff : off); // dmc3.exe+BA06E - 48 8B 8F 98180000 - MOV RCX,[RDI+00001898]
		Write<uint32>((appBaseAddr + 0xBA9F4 + 3), (enable) ? newOff : off); // dmc3.exe+BA9F4 - 48 8B 96 98180000 - MOV RDX,[RSI+00001898]
		Write<uint32>((appBaseAddr + 0xBAAFB + 3), (enable) ? newOff : off); // dmc3.exe+BAAFB - 48 8B 96 98180000 - MOV RDX,[RSI+00001898]
		Write<uint32>((appBaseAddr + 0xC75A7 + 3), (enable) ? newOff : off); // dmc3.exe+C75A7 - 48 8B 96 98180000 - MOV RDX,[RSI+00001898]
		Write<uint32>((appBaseAddr + 0xC7A1D + 3), (enable) ? newOff : off); // dmc3.exe+C7A1D - 48 8B 97 98180000 - MOV RDX,[RDI+00001898]
		Write<uint32>((appBaseAddr + 0xCB18E + 3), (enable) ? newOff : off); // dmc3.exe+CB18E - 48 8B 8E 98180000 - MOV RCX,[RSI+00001898]
		Write<uint32>((appBaseAddr + 0x2120C4 + 3), (enable) ? newOff : off); // dmc3.exe+2120C4 - 48 8B 96 98180000 - MOV RDX,[RSI+00001898]
		Write<uint32>((appBaseAddr + 0x218EFD + 3), (enable) ? newOff : off); // dmc3.exe+218EFD - 48 8B 97 98180000 - MOV RDX,[RDI+00001898]
		Write<uint32>((appBaseAddr + 0x218F67 + 3), (enable) ? newOff : off); // dmc3.exe+218F67 - 48 8B 97 98180000 - MOV RDX,[RDI+00001898]
		Write<uint32>((appBaseAddr + 0x220506 + 3), (enable) ? newOff : off); // dmc3.exe+220506 - 48 8B 96 98180000 - MOV RDX,[RSI+00001898]
		Write<uint32>((appBaseAddr + 0x223068 + 3), (enable) ? newOff : off); // dmc3.exe+223068 - 4C 8B 81 98180000 - MOV R8,[RCX+00001898]
		Write<uint32>((appBaseAddr + 0x2230AA + 3), (enable) ? newOff : off); // dmc3.exe+2230AA - 4C 8B 83 98180000 - MOV R8,[RBX+00001898]
		Write<uint32>((appBaseAddr + 0x2230E0 + 3), (enable) ? newOff : off); // dmc3.exe+2230E0 - 48 8B 93 98180000 - MOV RDX,[RBX+00001898]
		Write<uint32>((appBaseAddr + 0x2243FB + 3), (enable) ? newOff : off); // dmc3.exe+2243FB - 48 8B 93 98180000 - MOV RDX,[RBX+00001898]
		Write<uint32>((appBaseAddr + 0x22445B + 3), (enable) ? newOff : off); // dmc3.exe+22445B - 48 8B 93 98180000 - MOV RDX,[RBX+00001898]
		Write<uint32>((appBaseAddr + 0x225A71 + 3), (enable) ? newOff : off); // dmc3.exe+225A71 - 48 8B 93 98180000 - MOV RDX,[RBX+00001898]
		Write<uint32>((appBaseAddr + 0x226D86 + 3), (enable) ? newOff : off); // dmc3.exe+226D86 - 4C 8B 81 98180000 - MOV R8,[RCX+00001898]
		Write<uint32>((appBaseAddr + 0x2272D1 + 3), (enable) ? newOff : off); // dmc3.exe+2272D1 - 48 8B 93 98180000 - MOV RDX,[RBX+00001898]
		// Unknown
		// Write<uint32>((appBaseAddr + 0xC823B + 3), (enable) ? newOff : off); // dmc3.exe+C823B - 48 8B 85 98180000 - MOV RAX,[RBP+00001898]
	}
	// 0x18A8
	{
		constexpr auto off = __builtin_offsetof(ActorData, modelPhysicsMetadataPool[0][5]) ;
		constexpr auto newOff = __builtin_offsetof(ActorData, newModelPhysicsMetadataPool[0][5]) ;
		static_assert(off == 0x18A8);
		// Other
		Write<uint32>((appBaseAddr + 0x986CE + 3), (enable) ? newOff : off); // dmc3.exe+986CE - 48 8B 81 A8180000 - MOV RAX,[RCX+000018A8]
		Write<uint32>((appBaseAddr + 0x9DB24 + 3), (enable) ? newOff : off); // dmc3.exe+9DB24 - 48 8B 81 A8180000 - MOV RAX,[RCX+000018A8]
		Write<uint32>((appBaseAddr + 0xA2A55 + 3), (enable) ? newOff : off); // dmc3.exe+A2A55 - 48 8B 81 A8180000 - MOV RAX,[RCX+000018A8]
		Write<uint32>((appBaseAddr + 0xA78C7 + 3), (enable) ? newOff : off); // dmc3.exe+A78C7 - 48 8B 81 A8180000 - MOV RAX,[RCX+000018A8]
		Write<uint32>((appBaseAddr + 0xA8F8D + 3), (enable) ? newOff : off); // dmc3.exe+A8F8D - 48 8B 81 A8180000 - MOV RAX,[RCX+000018A8]
		Write<uint32>((appBaseAddr + 0xAB6DA + 3), (enable) ? newOff : off); // dmc3.exe+AB6DA - 48 8B 81 A8180000 - MOV RAX,[RCX+000018A8]
		Write<uint32>((appBaseAddr + 0xB04AF + 3), (enable) ? newOff : off); // dmc3.exe+B04AF - 48 8B 81 A8180000 - MOV RAX,[RCX+000018A8]
		Write<uint32>((appBaseAddr + 0xB2B09 + 3), (enable) ? newOff : off); // dmc3.exe+B2B09 - 48 8B 81 A8180000 - MOV RAX,[RCX+000018A8]
		Write<uint32>((appBaseAddr + 0xB685E + 3), (enable) ? newOff : off); // dmc3.exe+B685E - 48 8B 81 A8180000 - MOV RAX,[RCX+000018A8]
		Write<uint32>((appBaseAddr + 0x1FAF4F + 3), (enable) ? newOff : off); // dmc3.exe+1FAF4F - 48 8B 81 A8180000 - MOV RAX,[RCX+000018A8]
		Write<uint32>((appBaseAddr + 0x1FAF93 + 3), (enable) ? newOff : off); // dmc3.exe+1FAF93 - 48 8B 81 A8180000 - MOV RAX,[RCX+000018A8]
		Write<uint32>((appBaseAddr + 0x1FAFA4 + 3), (enable) ? newOff : off); // dmc3.exe+1FAFA4 - 48 8B 81 A8180000 - MOV RAX,[RCX+000018A8]
		Write<uint32>((appBaseAddr + 0x1FC8F3 + 3), (enable) ? newOff : off); // dmc3.exe+1FC8F3 - 48 8B 81 A8180000 - MOV RAX,[RCX+000018A8]
		Write<uint32>((appBaseAddr + 0x21920A + 3), (enable) ? newOff : off); // dmc3.exe+21920A - 48 8B 97 A8180000 - MOV RDX,[RDI+000018A8]
		Write<uint32>((appBaseAddr + 0x219ACB + 3), (enable) ? newOff : off); // dmc3.exe+219ACB - 48 8B 97 A8180000 - MOV RDX,[RDI+000018A8]
	}
	// 0x18F8
	{
		constexpr auto off = __builtin_offsetof(ActorData, modelPhysicsMetadataPool[0][15]) ;
		constexpr auto newOff = __builtin_offsetof(ActorData, newModelPhysicsMetadataPool[0][15]) ;
		static_assert(off == 0x18F8);
		// Other
		Write<uint32>((appBaseAddr + 0xBAA0B + 3), (enable) ? newOff : off); // dmc3.exe+BAA0B - 48 8B 96 F8180000 - MOV RDX,[RSI+000018F8]
		Write<uint32>((appBaseAddr + 0xBAB12 + 3), (enable) ? newOff : off); // dmc3.exe+BAB12 - 48 8B 96 F8180000 - MOV RDX,[RSI+000018F8]
		// Unknown
		// Write<uint32>((appBaseAddr + 0x25AD52 + 3), (enable) ? newOff : off); // dmc3.exe+25AD52 - 48 8D B3 F8180000 - LEA RSI,[RBX+000018F8]
		// Write<uint32>((appBaseAddr + 0x25C5EC + 3), (enable) ? newOff : off); // dmc3.exe+25C5EC - 48 8D B7 F8180000 - LEA RSI,[RDI+000018F8]
		// Write<uint32>((appBaseAddr + 0x25D0C2 + 4), (enable) ? newOff : off); // dmc3.exe+25D0C2 - 48 89 84 CF F8180000 - MOV [RDI+RCX*8+000018F8],RAX
		// Write<uint32>((appBaseAddr + 0x25D0D1 + 4), (enable) ? newOff : off); // dmc3.exe+25D0D1 - 48 8B 8C C7 F8180000 - MOV RCX,[RDI+RAX*8+000018F8]
		// Write<uint32>((appBaseAddr + 0x25D0FA + 4), (enable) ? newOff : off); // dmc3.exe+25D0FA - 48 8B 8C C7 F8180000 - MOV RCX,[RDI+RAX*8+000018F8]
		// Write<uint32>((appBaseAddr + 0x25D2E2 + 3), (enable) ? newOff : off); // dmc3.exe+25D2E2 - 48 8D 8F F8180000 - LEA RCX,[RDI+000018F8]
		// Write<uint32>((appBaseAddr + 0x25D55C + 3), (enable) ? newOff : off); // dmc3.exe+25D55C - 48 8D BB F8180000 - LEA RDI,[RBX+000018F8]
		// Write<uint32>((appBaseAddr + 0x25D5A3 + 3), (enable) ? newOff : off); // dmc3.exe+25D5A3 - 48 8D BB F8180000 - LEA RDI,[RBX+000018F8]
		// Write<uint32>((appBaseAddr + 0x2920B4 + 2), (enable) ? newOff : off); // dmc3.exe+2920B4 - 83 BB F8180000 02 - CMP DWORD PTR [RBX+000018F8],02
		// Write<uint32>((appBaseAddr + 0x292858 + 2), (enable) ? newOff : off); // dmc3.exe+292858 - C7 83 F8180000 04000000 - MOV [RBX+000018F8],00000004
		// Write<uint32>((appBaseAddr + 0x292864 + 2), (enable) ? newOff : off); // dmc3.exe+292864 - C7 83 F8180000 03000000 - MOV [RBX+000018F8],00000003
		// Write<uint32>((appBaseAddr + 0x292D91 + 2), (enable) ? newOff : off); // dmc3.exe+292D91 - C7 83 F8180000 04000000 - MOV [RBX+000018F8],00000004
		// Write<uint32>((appBaseAddr + 0x292DB8 + 2), (enable) ? newOff : off); // dmc3.exe+292DB8 - C7 83 F8180000 03000000 - MOV [RBX+000018F8],00000003
		// Write<uint32>((appBaseAddr + 0x292E00 + 2), (enable) ? newOff : off); // dmc3.exe+292E00 - C7 83 F8180000 02000000 - MOV [RBX+000018F8],00000002
		// Write<uint32>((appBaseAddr + 0x292F97 + 2), (enable) ? newOff : off); // dmc3.exe+292F97 - C7 83 F8180000 04000000 - MOV [RBX+000018F8],00000004
		// Write<uint32>((appBaseAddr + 0x292FA3 + 2), (enable) ? newOff : off); // dmc3.exe+292FA3 - C7 83 F8180000 03000000 - MOV [RBX+000018F8],00000003
	}
	// 0x1900
	{
		constexpr auto off = __builtin_offsetof(ActorData, modelPhysicsMetadataPool[0][16]) ;
		constexpr auto newOff = __builtin_offsetof(ActorData, newModelPhysicsMetadataPool[0][16]) ;
		static_assert(off == 0x1900);
		// Other
		Write<uint32>((appBaseAddr + 0xBAA25 + 3), (enable) ? newOff : off); // dmc3.exe+BAA25 - 48 8B 96 00190000 - MOV RDX,[RSI+00001900]
		Write<uint32>((appBaseAddr + 0xBAB2C + 3), (enable) ? newOff : off); // dmc3.exe+BAB2C - 48 8B 96 00190000 - MOV RDX,[RSI+00001900]
		// Unknown
		// Write<uint32>((appBaseAddr + 0x292170 + 2), (enable) ? newOff : off); // dmc3.exe+292170 - C7 83 00190000 05000000 - MOV [RBX+00001900],00000005
		// Write<uint32>((appBaseAddr + 0x292189 + 2), (enable) ? newOff : off); // dmc3.exe+292189 - C7 83 00190000 06000000 - MOV [RBX+00001900],00000006
	}
	// 0x1918
	{
		constexpr auto off = __builtin_offsetof(ActorData, modelPhysicsMetadataPool[0][19]) ;
		constexpr auto newOff = __builtin_offsetof(ActorData, newModelPhysicsMetadataPool[0][19]) ;
		static_assert(off == 0x1918);
		// Other
		Write<uint32>((appBaseAddr + 0xBAA3F + 3), (enable) ? newOff : off); // dmc3.exe+BAA3F - 48 8B 96 18190000 - MOV RDX,[RSI+00001918]
		Write<uint32>((appBaseAddr + 0xBAB46 + 3), (enable) ? newOff : off); // dmc3.exe+BAB46 - 48 8B 96 18190000 - MOV RDX,[RSI+00001918]
	}
	// 0x1920
	{
		constexpr auto off = __builtin_offsetof(ActorData, modelPhysicsMetadataPool[0][20]) ;
		constexpr auto newOff = __builtin_offsetof(ActorData, newModelPhysicsMetadataPool[0][20]) ;
		static_assert(off == 0x1920);
		// Other
		Write<uint32>((appBaseAddr + 0xBAA59 + 3), (enable) ? newOff : off); // dmc3.exe+BAA59 - 48 8B 96 20190000 - MOV RDX,[RSI+00001920]
		Write<uint32>((appBaseAddr + 0xBAB60 + 3), (enable) ? newOff : off); // dmc3.exe+BAB60 - 48 8B 96 20190000 - MOV RDX,[RSI+00001920]
	}
	// 0x1940
	{
		constexpr auto off = __builtin_offsetof(ActorData, modelPhysicsMetadataPool[1][0]) ;
		constexpr auto newOff = __builtin_offsetof(ActorData, newModelPhysicsMetadataPool[1][0]) ;
		static_assert(off == 0x1940);
		// func_1EF040
		Write<uint32>((appBaseAddr + 0x1EF2BB + 3), (enable) ? newOff : off); // dmc3.exe+1EF2BB - 4D 8D BD 40190000 - LEA R15,[R13+00001940]
	}
	// 0x1A00
	{
		constexpr auto off = __builtin_offsetof(ActorData, modelPhysicsMetadataPool[2][0]) ;
		constexpr auto newOff = __builtin_offsetof(ActorData, newModelPhysicsMetadataPool[2][0]) ;
		static_assert(off == 0x1A00);
		// func_1EF040
		Write<uint32>((appBaseAddr + 0x1EF18F + 3), (enable) ? newOff : off); // dmc3.exe+1EF18F - 4D 8D BD 001A0000 - LEA R15,[R13+00001A00]
	}
	// 0x1AC0
	{
		constexpr auto off = __builtin_offsetof(ActorData, modelPhysicsMetadataPool[3][0]) ;
		constexpr auto newOff = __builtin_offsetof(ActorData, newModelPhysicsMetadataPool[6][0]) ; // [3] -> [6]
		static_assert(off == 0x1AC0);
		// func_1EF040
		Write<uint32>((appBaseAddr + 0x1EF0A9 + 3), (enable) ? newOff : off); // dmc3.exe+1EF0A9 - 49 8D AD C01A0000 - LEA RBP,[R13+00001AC0]
	}
	// 0x1B88
	{
		constexpr auto off = __builtin_offsetof(ActorData, modelAllocationData[0]) ;
		constexpr auto newOff = __builtin_offsetof(ActorData, newModelAllocationData[0]) ;
		static_assert(off == 0x1B88);
		// func_1DD140
		Write<uint32>((appBaseAddr + 0x1DD1AA + 3), (enable) ? newOff : off); // dmc3.exe+1DD1AA - 49 8D 8E 881B0000 - LEA RCX,[R14+00001B88]
		// func_1DD210
		Write<uint32>((appBaseAddr + 0x1DD27A + 3), (enable) ? newOff : off); // dmc3.exe+1DD27A - 49 8D 8E 881B0000 - LEA RCX,[R14+00001B88]
		// func_1DD2E0
		Write<uint32>((appBaseAddr + 0x1DD34A + 3), (enable) ? newOff : off); // dmc3.exe+1DD34A - 49 8D 8E 881B0000 - LEA RCX,[R14+00001B88]
		// func_1DD3B0
		Write<uint32>((appBaseAddr + 0x1DD41A + 3), (enable) ? newOff : off); // dmc3.exe+1DD41A - 49 8D 8E 881B0000 - LEA RCX,[R14+00001B88]
		// func_1DDAF0
		Write<uint32>((appBaseAddr + 0x1DDB76 + 3), (enable) ? newOff : off); // dmc3.exe+1DDB76 - 48 8D 8E 881B0000 - LEA RCX,[RSI+00001B88]
		// func_1DE280
		Write<uint32>((appBaseAddr + 0x1DE3FB + 3), (enable) ? newOff : off); // dmc3.exe+1DE3FB - 48 8D 8F 881B0000 - LEA RCX,[RDI+00001B88]
		// func_1DE750
		Write<uint32>((appBaseAddr + 0x1DE7B3 + 3), (enable) ? newOff : off); // dmc3.exe+1DE7B3 - 48 8D 8F 881B0000 - LEA RCX,[RDI+00001B88]
		// Other
		Write<uint32>((appBaseAddr + 0x1DFAEE + 3), (enable) ? newOff : off); // dmc3.exe+1DFAEE - 48 81 C1 881B0000 - ADD RCX,00001B88
	}
	// 0x1B98
	{
		constexpr auto off = (__builtin_offsetof(ActorData, modelAllocationData[0]) + 0x10);
		constexpr auto newOff = (__builtin_offsetof(ActorData, newModelAllocationData[0]) + 0x10);
		static_assert(off == 0x1B98);
		// func_1DD140
		Write<uint32>((appBaseAddr + 0x1DD1BB + 3), (enable) ? newOff : off); // dmc3.exe+1DD1BB - 49 8B 8E 981B0000 - MOV RCX,[R14+00001B98]
		// func_1DD210
		Write<uint32>((appBaseAddr + 0x1DD28B + 3), (enable) ? newOff : off); // dmc3.exe+1DD28B - 49 8B 8E 981B0000 - MOV RCX,[R14+00001B98]
		// func_1DD2E0
		Write<uint32>((appBaseAddr + 0x1DD35B + 3), (enable) ? newOff : off); // dmc3.exe+1DD35B - 49 8B 8E 981B0000 - MOV RCX,[R14+00001B98]
		// func_1DD3B0
		Write<uint32>((appBaseAddr + 0x1DD42B + 3), (enable) ? newOff : off); // dmc3.exe+1DD42B - 49 8B 8E 981B0000 - MOV RCX,[R14+00001B98]
	}
	// 0x3B00
	{
		constexpr auto off = __builtin_offsetof(ActorData, recoveryData[0]) ;
		constexpr auto newOff = __builtin_offsetof(ActorData, newRecoveryData[0]) ;
		static_assert(off == 0x3B00);
		// func_1DDAF0
		Write<uint32>((appBaseAddr + 0x1DDC09 + 3), (enable) ? newOff : off); // dmc3.exe+1DDC09 - 48 8D 8E 003B0000 - LEA RCX,[RSI+00003B00]
		// func_1DE280
		Write<uint32>((appBaseAddr + 0x1DE3AD + 3), (enable) ? newOff : off); // dmc3.exe+1DE3AD - 48 8D 8F 003B0000 - LEA RCX,[RDI+00003B00]
		// func_1EF040
		Write<uint32>((appBaseAddr + 0x1EF408 + 3), (enable) ? newOff : off); // dmc3.exe+1EF408 - 49 8D 8D 003B0000 - LEA RCX,[R13+00003B00]
	}
	// 0x3B70
	{
		constexpr auto off = __builtin_offsetof(ActorData, recoveryData[1]) ;
		constexpr auto newOff = __builtin_offsetof(ActorData, newRecoveryData[1]) ;
		static_assert(off == 0x3B70);
		// func_1EF040
		Write<uint32>((appBaseAddr + 0x1EF2E1 + 3), (enable) ? newOff : off); // dmc3.exe+1EF2E1 - 49 8D 8D 703B0000 - LEA RCX,[R13+00003B70]
	}
	// 0x3BE0
	{
		constexpr auto off = __builtin_offsetof(ActorData, recoveryData[2]) ;
		constexpr auto newOff = __builtin_offsetof(ActorData, newRecoveryData[2]) ;
		static_assert(off == 0x3BE0);
		// func_1EF040
		Write<uint32>((appBaseAddr + 0x1EF1B5 + 3), (enable) ? newOff : off); // dmc3.exe+1EF1B5 - 49 8D 8D E03B0000 - LEA RCX,[R13+00003BE0]
	}
	// 0x3E74
	{
		constexpr auto off = __builtin_offsetof(ActorData, devilModels[0]) ;
		constexpr auto newOff = __builtin_offsetof(ActorData, newDevilModels[0]) ;
		static_assert(off == 0x3E74);
		// Update Actor Dante
		Write<uint32>((appBaseAddr + 0x213181 + 3), (enable) ? newOff : off); // dmc3.exe+213181 - C7 84 BE 743E0000 05000000 - MOV [RSI+RDI*4+00003E74],00000005
		Write<uint32>((appBaseAddr + 0x213580 + 3), (enable) ? newOff : off); // dmc3.exe+213580 - C7 84 BE 743E0000 04000000 - MOV [RSI+RDI*4+00003E74],00000004
		Write<uint32>((appBaseAddr + 0x213989 + 3), (enable) ? newOff : off); // dmc3.exe+213989 - C7 84 BE 743E0000 03000000 - MOV [RSI+RDI*4+00003E74],00000003
		Write<uint32>((appBaseAddr + 0x213FE0 + 4), (enable) ? newOff : off); // dmc3.exe+213FE0 - 42 C7 84 AE 743E0000 02000000 - MOV [RSI+R13*4+00003E74],00000002
		Write<uint32>((appBaseAddr + 0x21410F + 3), (enable) ? newOff : off); // dmc3.exe+21410F - C7 84 BE 743E0000 01000000 - MOV [RSI+RDI*4+00003E74],00000001
		Write<uint32>((appBaseAddr + 0x21450A + 3), (enable) ? newOff : off); // dmc3.exe+21450A - C7 84 BE 743E0000 00000000 - MOV [RSI+RDI*4+00003E74],00000000
		// Update Actor Bob
		Write<uint32>((appBaseAddr + 0x2263C0 + 4), (enable) ? newOff : off); // dmc3.exe+2263C0 - 41 C7 84 9E 743E0000 00000000 - MOV [R14+RBX*4+00003E74],00000000
		// Write<uint32>((appBaseAddr + 0x22692E + 4), (enable) ? newOff : off); // dmc3.exe+22692E - 41 C7 84 9E 743E0000 04000000 - MOV [R14+RBX*4+00003E74],00000004
		// Update Actor Vergil
		Write<uint32>((appBaseAddr + 0x220D9E + 4), (enable) ? newOff : off); // dmc3.exe+220D9E - 41 C7 84 BC 743E0000 06000000 - MOV [R12+RDI*4+00003E74],00000006
		Write<uint32>((appBaseAddr + 0x221198 + 4), (enable) ? newOff : off); // dmc3.exe+221198 - 41 C7 84 BC 743E0000 04000000 - MOV [R12+RDI*4+00003E74],00000004
		Write<uint32>((appBaseAddr + 0x2215A0 + 4), (enable) ? newOff : off); // dmc3.exe+2215A0 - 45 89 B4 BC 743E0000 - MOV [R12+RDI*4+00003E74],R14D
		// func_1F7BE0
		Write<uint32>((appBaseAddr + 0x1F7E5A + 2), (enable) ? newOff : off); // dmc3.exe+1F7E5A - C7 83 743E0000 FFFFFFFF - MOV [RBX+00003E74],FFFFFFFF
		// Other
		Write<uint32>((appBaseAddr + 0x90B67 + 4), (enable) ? newOff : off); // dmc3.exe+90B67 - 41 8B 8C 86 743E0000 - MOV ECX,[R14+RAX*4+00003E74]
		Write<uint32>((appBaseAddr + 0x1FAB17 + 3), (enable) ? newOff : off); // dmc3.exe+1FAB17 - 8B 84 81 743E0000 - MOV EAX,[RCX+RAX*4+00003E74]
		Write<uint32>((appBaseAddr + 0x1FAB34 + 4), (enable) ? newOff : off); // dmc3.exe+1FAB34 - 48 63 94 81 743E0000 - MOVSXD RDX,DWORD PTR [RCX+RAX*4+00003E74]
		Write<uint32>((appBaseAddr + 0x212110 + 3), (enable) ? newOff : off); // dmc3.exe+212110 - 8B 94 81 743E0000 - MOV EDX,[RCX+RAX*4+00003E74]
		Write<uint32>((appBaseAddr + 0x2189B0 + 3), (enable) ? newOff : off); // dmc3.exe+2189B0 - 8B 94 8F 743E0000 - MOV EDX,[RDI+RCX*4+00003E74]
		Write<uint32>((appBaseAddr + 0x220552 + 3), (enable) ? newOff : off); // dmc3.exe+220552 - 8B 8C 81 743E0000 - MOV ECX,[RCX+RAX*4+00003E74]
		Write<uint32>((appBaseAddr + 0x2244A8 + 3), (enable) ? newOff : off); // dmc3.exe+2244A8 - 8B 8C 83 743E0000 - MOV ECX,[RBX+RAX*4+00003E74]
		Write<uint32>((appBaseAddr + 0x2296B3 + 3), (enable) ? newOff : off); // dmc3.exe+2296B3 - 83 BC 81 743E0000 04 - CMP DWORD PTR [RCX+RAX*4+00003E74],04
		// Unknown
		// Write<uint32>((appBaseAddr + 0x4B950 + 2), (enable) ? newOff : off); // dmc3.exe+4B950 - C7 83 743E0000 01000000 - MOV [RBX+00003E74],00000001
	}
	// 0x6498
	{
		constexpr auto off = __builtin_offsetof(ActorData, weapons[0]) ;
		constexpr auto newOff = __builtin_offsetof(ActorData, newWeapons[0]) ;
		static_assert(off == 0x6498);
		// Init Actor Dante
		Write<uint32>((appBaseAddr + 0x217BF4 + 2), (enable) ? newOff : off); // dmc3.exe+217BF4 - 88 81 98640000 - MOV [RCX+00006498],AL
		// Init Actor Bob
		Write<uint32>((appBaseAddr + 0x226F53 + 2), (enable) ? newOff : off); // dmc3.exe+226F53 - C7 81 98640000 0EFFFFFF - MOV [RCX+00006498],FFFFFF0E
		// Init Actor Lady
		Write<uint32>((appBaseAddr + 0x2196AA + 2), (enable) ? newOff : off); // dmc3.exe+2196AA - C7 81 98640000 FFFF090A - MOV [RCX+00006498],0A09FFFF
		// Init Actor Vergil
		Write<uint32>((appBaseAddr + 0x223D11 + 2), (enable) ? newOff : off); // dmc3.exe+223D11 - C7 81 98640000 0B0C0DFF - MOV [RCX+00006498],FF0D0C0B
		// Update Actor Dante
		Write<uint32>((appBaseAddr + 0x212D9A + 3), (enable) ? newOff : off); // dmc3.exe+212D9A - 4C 8D A6 98640000 - LEA R12,[RSI+00006498]
		Write<uint32>((appBaseAddr + 0x213423 + 3), (enable) ? newOff : off); // dmc3.exe+213423 - 4C 8D A6 98640000 - LEA R12,[RSI+00006498]
		Write<uint32>((appBaseAddr + 0x2143AC + 3), (enable) ? newOff : off); // dmc3.exe+2143AC - 4C 8D A6 98640000 - LEA R12,[RSI+00006498]
		Write<uint32>((appBaseAddr + 0x214A5F + 3), (enable) ? newOff : off); // dmc3.exe+214A5F - 4C 8D A6 98640000 - LEA R12,[RSI+00006498]
		Write<uint32>((appBaseAddr + 0x214BD2 + 3), (enable) ? newOff : off); // dmc3.exe+214BD2 - 80 BC 30 98640000 04 - CMP BYTE PTR [RAX+RSI+00006498],04
		// Update Actor Bob
		Write<uint32>((appBaseAddr + 0x22629D + 3), (enable) ? newOff : off); // dmc3.exe+22629D - 49 8D 86 98640000 - LEA RAX,[R14+00006498]
		Write<uint32>((appBaseAddr + 0x22639B + 5), (enable) ? newOff : off); // dmc3.exe+22639B - 42 0FB6 84 31 98640000 - MOVZX EAX,BYTE PTR [RCX+R14+00006498]
		// Update Actor Lady
		Write<uint32>((appBaseAddr + 0x21959D + 3), (enable) ? newOff : off); // dmc3.exe+21959D - 48 8D 9D 98640000 - LEA RBX,[RBP+00006498]
		// Register Weapons
		Write<uint32>((appBaseAddr + 0x1DED41 + 3), (enable) ? newOff : off); // dmc3.exe+1DED41 - 48 8D A9 98640000 - LEA RBP,[RCX+00006498]
		// Weapon Switch Controller Dante
		Write<uint32>((appBaseAddr + 0x1EA987 + 5), (enable) ? newOff : off); // dmc3.exe+1EA987 - 44 0FB6 84 3B 98640000 - MOVZX R8D,BYTE PTR [RBX+RDI+00006498]
		Write<uint32>((appBaseAddr + 0x1EA99D + 3), (enable) ? newOff : off); // dmc3.exe+1EA99D - 80 BC 38 98640000 FF - CMP BYTE PTR [RAX+RDI+00006498],-01
		Write<uint32>((appBaseAddr + 0x1EA9AF + 4), (enable) ? newOff : off); // dmc3.exe+1EA9AF - 44 3A 84 38 98640000 - CMP R8L,[RAX+RDI+00006498]
		Write<uint32>((appBaseAddr + 0x1EAA74 + 4), (enable) ? newOff : off); // dmc3.exe+1EAA74 - 0FB6 8C 3B 98640000 - MOVZX ECX,BYTE PTR [RBX+RDI+00006498]
		Write<uint32>((appBaseAddr + 0x1EAA8A + 3), (enable) ? newOff : off); // dmc3.exe+1EAA8A - 80 BC 3B 98640000 FF - CMP BYTE PTR [RBX+RDI+00006498],-01
		Write<uint32>((appBaseAddr + 0x1EAA9F + 3), (enable) ? newOff : off); // dmc3.exe+1EAA9F - 3A 8C 3B 98640000 - CMP CL,[RBX+RDI+00006498]
		// func_1F7BE0
		Write<uint32>((appBaseAddr + 0x1F80B1 + 4), (enable) ? newOff : off); // dmc3.exe+1F80B1 - 0FB6 84 19 98640000 - MOVZX EAX,BYTE PTR [RCX+RBX+00006498]
		Write<uint32>((appBaseAddr + 0x1F80BF + 4), (enable) ? newOff : off); // dmc3.exe+1F80BF - 0FB6 84 19 98640000 - MOVZX EAX,BYTE PTR [RCX+RBX+00006498]
		Write<uint32>((appBaseAddr + 0x1F80D4 + 4), (enable) ? newOff : off); // dmc3.exe+1F80D4 - 0FB6 8C 18 98640000 - MOVZX ECX,BYTE PTR [RAX+RBX+00006498]
		// func_2198D0
		Write<uint32>((appBaseAddr + 0x2198D0 + 3), (enable) ? newOff : off); // dmc3.exe+2198D0 - 0FB6 81 98640000 - MOVZX EAX,BYTE PTR [RCX+00006498]
		// func_2241F0
		Write<uint32>((appBaseAddr + 0x2241F0 + 3), (enable) ? newOff : off); // dmc3.exe+2241F0 - 0FB6 81 98640000 - MOVZX EAX,BYTE PTR [RCX+00006498]
		// Other
		Write<uint32>((appBaseAddr + 0x1D91E0 + 3), (enable) ? newOff : off); // dmc3.exe+1D91E0 - 80 BC 11 98640000 0D - CMP BYTE PTR [RCX+RDX+00006498],0D
		Write<uint32>((appBaseAddr + 0x1E02A2 + 4), (enable) ? newOff : off); // dmc3.exe+1E02A2 - 40 38 B4 18 98640000 - CMP [RAX+RBX+00006498],SIL
		Write<uint32>((appBaseAddr + 0x1E088D + 3), (enable) ? newOff : off); // dmc3.exe+1E088D - 80 BC 18 98640000 05 - CMP BYTE PTR [RAX+RBX+00006498],05
		Write<uint32>((appBaseAddr + 0x1E090C + 4), (enable) ? newOff : off); // dmc3.exe+1E090C - 0FB6 8C 18 98640000 - MOVZX ECX,BYTE PTR [RAX+RBX+00006498]
		Write<uint32>((appBaseAddr + 0x1E0923 + 4), (enable) ? newOff : off); // dmc3.exe+1E0923 - 0FB6 8C 18 98640000 - MOVZX ECX,BYTE PTR [RAX+RBX+00006498]
		Write<uint32>((appBaseAddr + 0x1E28E6 + 4), (enable) ? newOff : off); // dmc3.exe+1E28E6 - 0FB6 B4 08 98640000 - MOVZX ESI,BYTE PTR [RAX+RCX+00006498]
		Write<uint32>((appBaseAddr + 0x1E64DB + 4), (enable) ? newOff : off); // dmc3.exe+1E64DB - 0FB6 8C 18 98640000 - MOVZX ECX,BYTE PTR [RAX+RBX+00006498]
		Write<uint32>((appBaseAddr + 0x1E64FB + 4), (enable) ? newOff : off); // dmc3.exe+1E64FB - 0FB6 8C 18 98640000 - MOVZX ECX,BYTE PTR [RAX+RBX+00006498]
		Write<uint32>((appBaseAddr + 0x1E657D + 3), (enable) ? newOff : off); // dmc3.exe+1E657D - 80 BC 18 98640000 07 - CMP BYTE PTR [RAX+RBX+00006498],07
		Write<uint32>((appBaseAddr + 0x1E6BB8 + 4), (enable) ? newOff : off); // dmc3.exe+1E6BB8 - 0FB6 8C 1A 98640000 - MOVZX ECX,BYTE PTR [RDX+RBX+00006498]
		Write<uint32>((appBaseAddr + 0x1E6C03 + 4), (enable) ? newOff : off); // dmc3.exe+1E6C03 - 0FB6 8C 18 98640000 - MOVZX ECX,BYTE PTR [RAX+RBX+00006498]
		Write<uint32>((appBaseAddr + 0x1E6C35 + 4), (enable) ? newOff : off); // dmc3.exe+1E6C35 - 0FB6 84 1A 98640000 - MOVZX EAX,BYTE PTR [RDX+RBX+00006498]
		Write<uint32>((appBaseAddr + 0x1E6D9B + 4), (enable) ? newOff : off); // dmc3.exe+1E6D9B - 0FB6 8C 18 98640000 - MOVZX ECX,BYTE PTR [RAX+RBX+00006498]
		Write<uint32>((appBaseAddr + 0x1E70DD + 4), (enable) ? newOff : off); // dmc3.exe+1E70DD - 40 3A BC 18 98640000 - CMP DIL,[RAX+RBX+00006498]
		Write<uint32>((appBaseAddr + 0x1E70EE + 4), (enable) ? newOff : off); // dmc3.exe+1E70EE - 40 3A BC 18 98640000 - CMP DIL,[RAX+RBX+00006498]
		Write<uint32>((appBaseAddr + 0x1E711C + 4), (enable) ? newOff : off); // dmc3.exe+1E711C - 40 3A BC 18 98640000 - CMP DIL,[RAX+RBX+00006498]
		Write<uint32>((appBaseAddr + 0x1E714A + 4), (enable) ? newOff : off); // dmc3.exe+1E714A - 40 3A BC 18 98640000 - CMP DIL,[RAX+RBX+00006498]
		Write<uint32>((appBaseAddr + 0x1E7174 + 4), (enable) ? newOff : off); // dmc3.exe+1E7174 - 40 3A BC 18 98640000 - CMP DIL,[RAX+RBX+00006498]
		Write<uint32>((appBaseAddr + 0x1E7185 + 4), (enable) ? newOff : off); // dmc3.exe+1E7185 - 40 3A BC 18 98640000 - CMP DIL,[RAX+RBX+00006498]
		Write<uint32>((appBaseAddr + 0x1E7E93 + 3), (enable) ? newOff : off); // dmc3.exe+1E7E93 - 80 BC 18 98640000 03 - CMP BYTE PTR [RAX+RBX+00006498],03
		Write<uint32>((appBaseAddr + 0x1E927F + 5), (enable) ? newOff : off); // dmc3.exe+1E927F - 42 0FB6 8C 00 98640000 - MOVZX ECX,BYTE PTR [RAX+R8+00006498]
		Write<uint32>((appBaseAddr + 0x1E9B04 + 4), (enable) ? newOff : off); // dmc3.exe+1E9B04 - 0FB6 8C 18 98640000 - MOVZX ECX,BYTE PTR [RAX+RBX+00006498]
		Write<uint32>((appBaseAddr + 0x1EADEA + 4), (enable) ? newOff : off); // dmc3.exe+1EADEA - 0FBE 8C 08 98640000 - MOVSX ECX,BYTE PTR [RAX+RCX+00006498]
		Write<uint32>((appBaseAddr + 0x1EAE10 + 3), (enable) ? newOff : off); // dmc3.exe+1EAE10 - 80 BC 11 98640000 05 - CMP BYTE PTR [RCX+RDX+00006498],05
		Write<uint32>((appBaseAddr + 0x1EB1E5 + 3), (enable) ? newOff : off); // dmc3.exe+1EB1E5 - 80 BC 18 98640000 07 - CMP BYTE PTR [RAX+RBX+00006498],07
		Write<uint32>((appBaseAddr + 0x1F59B1 + 3), (enable) ? newOff : off); // dmc3.exe+1F59B1 - 80 BC 31 98640000 05 - CMP BYTE PTR [RCX+RSI+00006498],05
		Write<uint32>((appBaseAddr + 0x1F59D7 + 3), (enable) ? newOff : off); // dmc3.exe+1F59D7 - 80 BC 30 98640000 05 - CMP BYTE PTR [RAX+RSI+00006498],05
		Write<uint32>((appBaseAddr + 0x1F6674 + 4), (enable) ? newOff : off); // dmc3.exe+1F6674 - 40 38 BC 18 98640000 - CMP [RAX+RBX+00006498],DIL
		Write<uint32>((appBaseAddr + 0x1F66A9 + 4), (enable) ? newOff : off); // dmc3.exe+1F66A9 - 40 38 BC 18 98640000 - CMP [RAX+RBX+00006498],DIL
		Write<uint32>((appBaseAddr + 0x1F7607 + 3), (enable) ? newOff : off); // dmc3.exe+1F7607 - 80 BC 18 98640000 07 - CMP BYTE PTR [RAX+RBX+00006498],07
		Write<uint32>((appBaseAddr + 0x1F762A + 3), (enable) ? newOff : off); // dmc3.exe+1F762A - 80 BC 18 98640000 07 - CMP BYTE PTR [RAX+RBX+00006498],07
		Write<uint32>((appBaseAddr + 0x1F9445 + 4), (enable) ? newOff : off); // dmc3.exe+1F9445 - 0FBE 94 08 98640000 - MOVSX EDX,BYTE PTR [RAX+RCX+00006498]
		Write<uint32>((appBaseAddr + 0x1FACA0 + 3), (enable) ? newOff : off); // dmc3.exe+1FACA0 - 38 94 08 98640000 - CMP [RAX+RCX+00006498],DL
		Write<uint32>((appBaseAddr + 0x1FAD00 + 3), (enable) ? newOff : off); // dmc3.exe+1FAD00 - 38 94 08 98640000 - CMP [RAX+RCX+00006498],DL
		Write<uint32>((appBaseAddr + 0x1FAD40 + 3), (enable) ? newOff : off); // dmc3.exe+1FAD40 - 38 94 08 98640000 - CMP [RAX+RCX+00006498],DL
		Write<uint32>((appBaseAddr + 0x1FB13F + 3), (enable) ? newOff : off); // dmc3.exe+1FB13F - 80 BC 08 98640000 00 - CMP BYTE PTR [RAX+RCX+00006498],00
		Write<uint32>((appBaseAddr + 0x1FD143 + 3), (enable) ? newOff : off); // dmc3.exe+1FD143 - 38 94 08 98640000 - CMP [RAX+RCX+00006498],DL
		Write<uint32>((appBaseAddr + 0x1FD173 + 4), (enable) ? newOff : off); // dmc3.exe+1FD173 - 41 38 94 09 98640000 - CMP [R9+RCX+00006498],DL
		Write<uint32>((appBaseAddr + 0x1FD1A6 + 4), (enable) ? newOff : off); // dmc3.exe+1FD1A6 - 0FB6 8C 08 98640000 - MOVZX ECX,BYTE PTR [RAX+RCX+00006498]
		Write<uint32>((appBaseAddr + 0x1FD1D0 + 3), (enable) ? newOff : off); // dmc3.exe+1FD1D0 - 38 94 08 98640000 - CMP [RAX+RCX+00006498],DL
		Write<uint32>((appBaseAddr + 0x1FD651 + 4), (enable) ? newOff : off); // dmc3.exe+1FD651 - 44 38 84 10 98640000 - CMP [RAX+RDX+00006498],R8L
		Write<uint32>((appBaseAddr + 0x20477A + 4), (enable) ? newOff : off); // dmc3.exe+20477A - 0FB6 8C 18 98640000 - MOVZX ECX,BYTE PTR [RAX+RBX+00006498]
		Write<uint32>((appBaseAddr + 0x204A45 + 4), (enable) ? newOff : off); // dmc3.exe+204A45 - 0FB6 8C 18 98640000 - MOVZX ECX,BYTE PTR [RAX+RBX+00006498]
		Write<uint32>((appBaseAddr + 0x204AD4 + 3), (enable) ? newOff : off); // dmc3.exe+204AD4 - 80 BC 18 98640000 03 - CMP BYTE PTR [RAX+RBX+00006498],03
		Write<uint32>((appBaseAddr + 0x204B4A + 3), (enable) ? newOff : off); // dmc3.exe+204B4A - 80 BC 18 98640000 03 - CMP BYTE PTR [RAX+RBX+00006498],03
		Write<uint32>((appBaseAddr + 0x20511E + 3), (enable) ? newOff : off); // dmc3.exe+20511E - 80 BC 18 98640000 05 - CMP BYTE PTR [RAX+RBX+00006498],05
		Write<uint32>((appBaseAddr + 0x205273 + 3), (enable) ? newOff : off); // dmc3.exe+205273 - 80 BC 18 98640000 05 - CMP BYTE PTR [RAX+RBX+00006498],05
		Write<uint32>((appBaseAddr + 0x20530B + 3), (enable) ? newOff : off); // dmc3.exe+20530B - 80 BC 18 98640000 05 - CMP BYTE PTR [RAX+RBX+00006498],05
		Write<uint32>((appBaseAddr + 0x2054D1 + 3), (enable) ? newOff : off); // dmc3.exe+2054D1 - 80 BC 18 98640000 05 - CMP BYTE PTR [RAX+RBX+00006498],05
		Write<uint32>((appBaseAddr + 0x206172 + 3), (enable) ? newOff : off); // dmc3.exe+206172 - 80 BC 18 98640000 09 - CMP BYTE PTR [RAX+RBX+00006498],09
		Write<uint32>((appBaseAddr + 0x206192 + 3), (enable) ? newOff : off); // dmc3.exe+206192 - 80 BC 18 98640000 09 - CMP BYTE PTR [RAX+RBX+00006498],09
		Write<uint32>((appBaseAddr + 0x2063A0 + 3), (enable) ? newOff : off); // dmc3.exe+2063A0 - 80 BC 19 98640000 09 - CMP BYTE PTR [RCX+RBX+00006498],09
		Write<uint32>((appBaseAddr + 0x206510 + 3), (enable) ? newOff : off); // dmc3.exe+206510 - 80 BC 19 98640000 09 - CMP BYTE PTR [RCX+RBX+00006498],09
		Write<uint32>((appBaseAddr + 0x208220 + 3), (enable) ? newOff : off); // dmc3.exe+208220 - 80 BC 1F 98640000 00 - CMP BYTE PTR [RDI+RBX+00006498],00
		Write<uint32>((appBaseAddr + 0x208281 + 3), (enable) ? newOff : off); // dmc3.exe+208281 - 80 BC 18 98640000 00 - CMP BYTE PTR [RAX+RBX+00006498],00
		Write<uint32>((appBaseAddr + 0x2086E5 + 3), (enable) ? newOff : off); // dmc3.exe+2086E5 - 80 BC 18 98640000 08 - CMP BYTE PTR [RAX+RBX+00006498],08
		Write<uint32>((appBaseAddr + 0x208713 + 3), (enable) ? newOff : off); // dmc3.exe+208713 - 80 BC 18 98640000 08 - CMP BYTE PTR [RAX+RBX+00006498],08
		Write<uint32>((appBaseAddr + 0x208CF8 + 3), (enable) ? newOff : off); // dmc3.exe+208CF8 - 80 BC 18 98640000 06 - CMP BYTE PTR [RAX+RBX+00006498],06
		Write<uint32>((appBaseAddr + 0x208DFF + 3), (enable) ? newOff : off); // dmc3.exe+208DFF - 80 BC 18 98640000 06 - CMP BYTE PTR [RAX+RBX+00006498],06
		Write<uint32>((appBaseAddr + 0x20D1B2 + 3), (enable) ? newOff : off); // dmc3.exe+20D1B2 - 80 BC 18 98640000 05 - CMP BYTE PTR [RAX+RBX+00006498],05
		Write<uint32>((appBaseAddr + 0x20E302 + 3), (enable) ? newOff : off); // dmc3.exe+20E302 - 80 BC 18 98640000 08 - CMP BYTE PTR [RAX+RBX+00006498],08
		Write<uint32>((appBaseAddr + 0x20E662 + 3), (enable) ? newOff : off); // dmc3.exe+20E662 - 80 BC 18 98640000 08 - CMP BYTE PTR [RAX+RBX+00006498],08
		Write<uint32>((appBaseAddr + 0x20E713 + 3), (enable) ? newOff : off); // dmc3.exe+20E713 - 80 BC 18 98640000 08 - CMP BYTE PTR [RAX+RBX+00006498],08
		Write<uint32>((appBaseAddr + 0x210A22 + 4), (enable) ? newOff : off); // dmc3.exe+210A22 - 44 38 84 18 98640000 - CMP [RAX+RBX+00006498],R8L
		Write<uint32>((appBaseAddr + 0x210C00 + 3), (enable) ? newOff : off); // dmc3.exe+210C00 - 80 BC 1F 98640000 00 - CMP BYTE PTR [RDI+RBX+00006498],00
		Write<uint32>((appBaseAddr + 0x210C40 + 3), (enable) ? newOff : off); // dmc3.exe+210C40 - 80 BC 19 98640000 00 - CMP BYTE PTR [RCX+RBX+00006498],00
		Write<uint32>((appBaseAddr + 0x2113D1 + 3), (enable) ? newOff : off); // dmc3.exe+2113D1 - 80 BC 37 98640000 00 - CMP BYTE PTR [RDI+RSI+00006498],00
		Write<uint32>((appBaseAddr + 0x2114C0 + 3), (enable) ? newOff : off); // dmc3.exe+2114C0 - 80 BC 37 98640000 00 - CMP BYTE PTR [RDI+RSI+00006498],00
		Write<uint32>((appBaseAddr + 0x2115E0 + 3), (enable) ? newOff : off); // dmc3.exe+2115E0 - 80 BC 37 98640000 00 - CMP BYTE PTR [RDI+RSI+00006498],00
		Write<uint32>((appBaseAddr + 0x211682 + 4), (enable) ? newOff : off); // dmc3.exe+211682 - 40 38 BC 30 98640000 - CMP [RAX+RSI+00006498],DIL
		Write<uint32>((appBaseAddr + 0x211723 + 3), (enable) ? newOff : off); // dmc3.exe+211723 - 80 BC 37 98640000 00 - CMP BYTE PTR [RDI+RSI+00006498],00
		Write<uint32>((appBaseAddr + 0x211782 + 4), (enable) ? newOff : off); // dmc3.exe+211782 - 40 38 BC 30 98640000 - CMP [RAX+RSI+00006498],DIL
		Write<uint32>((appBaseAddr + 0x212A3C + 3), (enable) ? newOff : off); // dmc3.exe+212A3C - 0FB6 81 98640000 - MOVZX EAX,BYTE PTR [RCX+00006498]
		Write<uint32>((appBaseAddr + 0x2155F6 + 3), (enable) ? newOff : off); // dmc3.exe+2155F6 - 48 81 C1 98640000 - ADD RCX,00006498
		Write<uint32>((appBaseAddr + 0x215702 + 4), (enable) ? newOff : off); // dmc3.exe+215702 - 44 38 B4 38 98640000 - CMP [RAX+RDI+00006498],R14L
		Write<uint32>((appBaseAddr + 0x215899 + 4), (enable) ? newOff : off); // dmc3.exe+215899 - 44 38 B4 38 98640000 - CMP [RAX+RDI+00006498],R14L
		Write<uint32>((appBaseAddr + 0x2158B2 + 4), (enable) ? newOff : off); // dmc3.exe+2158B2 - 44 38 B4 38 98640000 - CMP [RAX+RDI+00006498],R14L
		Write<uint32>((appBaseAddr + 0x215948 + 4), (enable) ? newOff : off); // dmc3.exe+215948 - 44 38 B4 38 98640000 - CMP [RAX+RDI+00006498],R14L
		Write<uint32>((appBaseAddr + 0x215972 + 4), (enable) ? newOff : off); // dmc3.exe+215972 - 44 38 B4 38 98640000 - CMP [RAX+RDI+00006498],R14L
		Write<uint32>((appBaseAddr + 0x2159CE + 4), (enable) ? newOff : off); // dmc3.exe+2159CE - 44 38 B4 38 98640000 - CMP [RAX+RDI+00006498],R14L
		Write<uint32>((appBaseAddr + 0x2159E2 + 4), (enable) ? newOff : off); // dmc3.exe+2159E2 - 44 38 B4 38 98640000 - CMP [RAX+RDI+00006498],R14L
		Write<uint32>((appBaseAddr + 0x215BD2 + 3), (enable) ? newOff : off); // dmc3.exe+215BD2 - 80 BC 38 98640000 07 - CMP BYTE PTR [RAX+RDI+00006498],07
		Write<uint32>((appBaseAddr + 0x215C1D + 4), (enable) ? newOff : off); // dmc3.exe+215C1D - 0FB6 9C 38 98640000 - MOVZX EBX,BYTE PTR [RAX+RDI+00006498]
		Write<uint32>((appBaseAddr + 0x215E82 + 3), (enable) ? newOff : off); // dmc3.exe+215E82 - 80 BC 38 98640000 07 - CMP BYTE PTR [RAX+RDI+00006498],07
		Write<uint32>((appBaseAddr + 0x215EA2 + 3), (enable) ? newOff : off); // dmc3.exe+215EA2 - 80 BC 38 98640000 07 - CMP BYTE PTR [RAX+RDI+00006498],07
		Write<uint32>((appBaseAddr + 0x21609D + 4), (enable) ? newOff : off); // dmc3.exe+21609D - 0FB6 B4 38 98640000 - MOVZX ESI,BYTE PTR [RAX+RDI+00006498]
		Write<uint32>((appBaseAddr + 0x2161D2 + 5), (enable) ? newOff : off); // dmc3.exe+2161D2 - 44 0FBE 8C 38 98640000 - MOVSX R9D,BYTE PTR [RAX+RDI+00006498]
		Write<uint32>((appBaseAddr + 0x2163E7 + 5), (enable) ? newOff : off); // dmc3.exe+2163E7 - 44 0FBE 8C 38 98640000 - MOVSX R9D,BYTE PTR [RAX+RDI+00006498]
		Write<uint32>((appBaseAddr + 0x216E42 + 3), (enable) ? newOff : off); // dmc3.exe+216E42 - 80 BC 38 98640000 05 - CMP BYTE PTR [RAX+RDI+00006498],05
		Write<uint32>((appBaseAddr + 0x217012 + 3), (enable) ? newOff : off); // dmc3.exe+217012 - 80 BC 38 98640000 05 - CMP BYTE PTR [RAX+RDI+00006498],05
		Write<uint32>((appBaseAddr + 0x2171E2 + 3), (enable) ? newOff : off); // dmc3.exe+2171E2 - 80 BC 38 98640000 05 - CMP BYTE PTR [RAX+RDI+00006498],05
		Write<uint32>((appBaseAddr + 0x217362 + 3), (enable) ? newOff : off); // dmc3.exe+217362 - 80 BC 38 98640000 05 - CMP BYTE PTR [RAX+RDI+00006498],05
		Write<uint32>((appBaseAddr + 0x217473 + 3), (enable) ? newOff : off); // dmc3.exe+217473 - 80 BC 38 98640000 05 - CMP BYTE PTR [RAX+RDI+00006498],05
		Write<uint32>((appBaseAddr + 0x218192 + 3), (enable) ? newOff : off); // dmc3.exe+218192 - 80 BC 18 98640000 06 - CMP BYTE PTR [RAX+RBX+00006498],06
		Write<uint32>((appBaseAddr + 0x218312 + 3), (enable) ? newOff : off); // dmc3.exe+218312 - 80 BC 18 98640000 06 - CMP BYTE PTR [RAX+RBX+00006498],06
		Write<uint32>((appBaseAddr + 0x2183E5 + 3), (enable) ? newOff : off); // dmc3.exe+2183E5 - 80 BC 18 98640000 06 - CMP BYTE PTR [RAX+RBX+00006498],06
		Write<uint32>((appBaseAddr + 0x218422 + 3), (enable) ? newOff : off); // dmc3.exe+218422 - 80 BC 18 98640000 06 - CMP BYTE PTR [RAX+RBX+00006498],06
		Write<uint32>((appBaseAddr + 0x218456 + 3), (enable) ? newOff : off); // dmc3.exe+218456 - 80 BC 18 98640000 06 - CMP BYTE PTR [RAX+RBX+00006498],06
		Write<uint32>((appBaseAddr + 0x2184B2 + 3), (enable) ? newOff : off); // dmc3.exe+2184B2 - 80 BC 18 98640000 06 - CMP BYTE PTR [RAX+RBX+00006498],06
		Write<uint32>((appBaseAddr + 0x2184F2 + 3), (enable) ? newOff : off); // dmc3.exe+2184F2 - 80 BC 18 98640000 06 - CMP BYTE PTR [RAX+RBX+00006498],06
		Write<uint32>((appBaseAddr + 0x218532 + 3), (enable) ? newOff : off); // dmc3.exe+218532 - 80 BC 18 98640000 06 - CMP BYTE PTR [RAX+RBX+00006498],06
		Write<uint32>((appBaseAddr + 0x21A462 + 3), (enable) ? newOff : off); // dmc3.exe+21A462 - 80 BC 18 98640000 0B - CMP BYTE PTR [RAX+RBX+00006498],0B
		Write<uint32>((appBaseAddr + 0x21A4B2 + 3), (enable) ? newOff : off); // dmc3.exe+21A4B2 - 80 BC 18 98640000 0B - CMP BYTE PTR [RAX+RBX+00006498],0B
		Write<uint32>((appBaseAddr + 0x21B7F4 + 3), (enable) ? newOff : off); // dmc3.exe+21B7F4 - 80 BC 18 98640000 0B - CMP BYTE PTR [RAX+RBX+00006498],0B
		Write<uint32>((appBaseAddr + 0x21B8C2 + 3), (enable) ? newOff : off); // dmc3.exe+21B8C2 - 80 BC 18 98640000 0B - CMP BYTE PTR [RAX+RBX+00006498],0B
		Write<uint32>((appBaseAddr + 0x21B8F2 + 3), (enable) ? newOff : off); // dmc3.exe+21B8F2 - 80 BC 18 98640000 0B - CMP BYTE PTR [RAX+RBX+00006498],0B
		Write<uint32>((appBaseAddr + 0x21BBB0 + 3), (enable) ? newOff : off); // dmc3.exe+21BBB0 - 80 BC 19 98640000 0B - CMP BYTE PTR [RCX+RBX+00006498],0B
		Write<uint32>((appBaseAddr + 0x21BBE0 + 3), (enable) ? newOff : off); // dmc3.exe+21BBE0 - 80 BC 19 98640000 0B - CMP BYTE PTR [RCX+RBX+00006498],0B
		Write<uint32>((appBaseAddr + 0x21C0A2 + 3), (enable) ? newOff : off); // dmc3.exe+21C0A2 - 80 BC 18 98640000 0B - CMP BYTE PTR [RAX+RBX+00006498],0B
		Write<uint32>((appBaseAddr + 0x21C3D2 + 3), (enable) ? newOff : off); // dmc3.exe+21C3D2 - 80 BC 18 98640000 0B - CMP BYTE PTR [RAX+RBX+00006498],0B
		Write<uint32>((appBaseAddr + 0x21C402 + 3), (enable) ? newOff : off); // dmc3.exe+21C402 - 80 BC 18 98640000 0B - CMP BYTE PTR [RAX+RBX+00006498],0B
		Write<uint32>((appBaseAddr + 0x21C6A3 + 3), (enable) ? newOff : off); // dmc3.exe+21C6A3 - 80 BC 18 98640000 0B - CMP BYTE PTR [RAX+RBX+00006498],0B
		Write<uint32>((appBaseAddr + 0x21C745 + 3), (enable) ? newOff : off); // dmc3.exe+21C745 - 80 BC 18 98640000 0B - CMP BYTE PTR [RAX+RBX+00006498],0B
		Write<uint32>((appBaseAddr + 0x21C842 + 3), (enable) ? newOff : off); // dmc3.exe+21C842 - 80 BC 18 98640000 0B - CMP BYTE PTR [RAX+RBX+00006498],0B
		Write<uint32>((appBaseAddr + 0x21D0D4 + 3), (enable) ? newOff : off); // dmc3.exe+21D0D4 - 80 BC 38 98640000 0B - CMP BYTE PTR [RAX+RDI+00006498],0B
		Write<uint32>((appBaseAddr + 0x21D102 + 3), (enable) ? newOff : off); // dmc3.exe+21D102 - 80 BC 38 98640000 0B - CMP BYTE PTR [RAX+RDI+00006498],0B
		Write<uint32>((appBaseAddr + 0x21E904 + 3), (enable) ? newOff : off); // dmc3.exe+21E904 - 80 BC 18 98640000 0B - CMP BYTE PTR [RAX+RBX+00006498],0B
		Write<uint32>((appBaseAddr + 0x21E932 + 3), (enable) ? newOff : off); // dmc3.exe+21E932 - 80 BC 18 98640000 0B - CMP BYTE PTR [RAX+RBX+00006498],0B
		Write<uint32>((appBaseAddr + 0x21F226 + 3), (enable) ? newOff : off); // dmc3.exe+21F226 - 80 BC 1F 98640000 0D - CMP BYTE PTR [RDI+RBX+00006498],0D
		Write<uint32>((appBaseAddr + 0x21F250 + 3), (enable) ? newOff : off); // dmc3.exe+21F250 - 80 BC 19 98640000 0D - CMP BYTE PTR [RCX+RBX+00006498],0D
		Write<uint32>((appBaseAddr + 0x2228F3 + 3), (enable) ? newOff : off); // dmc3.exe+2228F3 - 48 81 C1 98640000 - ADD RCX,00006498
		Write<uint32>((appBaseAddr + 0x2229A2 + 3), (enable) ? newOff : off); // dmc3.exe+2229A2 - 80 BC 38 98640000 0D - CMP BYTE PTR [RAX+RDI+00006498],0D
		Write<uint32>((appBaseAddr + 0x222B46 + 3), (enable) ? newOff : off); // dmc3.exe+222B46 - 80 BC 38 98640000 0B - CMP BYTE PTR [RAX+RDI+00006498],0B
		Write<uint32>((appBaseAddr + 0x222E92 + 3), (enable) ? newOff : off); // dmc3.exe+222E92 - 80 BC 38 98640000 0D - CMP BYTE PTR [RAX+RDI+00006498],0D
		Write<uint32>((appBaseAddr + 0x222F34 + 3), (enable) ? newOff : off); // dmc3.exe+222F34 - 80 BC 38 98640000 0D - CMP BYTE PTR [RAX+RDI+00006498],0D
		// Unknown
		// Write<uint32>((appBaseAddr + 0x1E2C33 + 4), (enable) ? newOff : off); // dmc3.exe+1E2C33 - 41 3A 84 18 98640000 - CMP AL,[R8+RBX+00006498]
		// Write<uint32>((appBaseAddr + 0x1E2CEA + 5), (enable) ? newOff : off); // dmc3.exe+1E2CEA - 41 0FB6 84 18 98640000 - MOVZX EAX,BYTE PTR [R8+RBX+00006498]
		// Write<uint32>((appBaseAddr + 0x1E3F9D + 4), (enable) ? newOff : off); // dmc3.exe+1E3F9D - 0FB6 8C 18 98640000 - MOVZX ECX,BYTE PTR [RAX+RBX+00006498]
		// Write<uint32>((appBaseAddr + 0x1FAB48 + 4), (enable) ? newOff : off); // dmc3.exe+1FAB48 - 0FB6 84 08 98640000 - MOVZX EAX,BYTE PTR [RAX+RCX+00006498]
		// Write<uint32>((appBaseAddr + 0x1FCFD4 + 2), (enable) ? newOff : off); // dmc3.exe+1FCFD4 - 80 B9 98640000 FF - CMP BYTE PTR [RCX+00006498],-01
		// Write<uint32>((appBaseAddr + 0x1FCFDD + 2), (enable) ? newOff : off); // dmc3.exe+1FCFDD - 88 91 98640000 - MOV [RCX+00006498],DL
		// Write<uint32>((appBaseAddr + 0x1FD4D9 + 3), (enable) ? newOff : off); // dmc3.exe+1FD4D9 - 38 94 08 98640000 - CMP [RAX+RCX+00006498],DL
		// Write<uint32>((appBaseAddr + 0x20E332 + 3), (enable) ? newOff : off); // dmc3.exe+20E332 - 80 BC 18 98640000 08 - CMP BYTE PTR [RAX+RBX+00006498],08
		// Write<uint32>((appBaseAddr + 0x20E363 + 3), (enable) ? newOff : off); // dmc3.exe+20E363 - 80 BC 18 98640000 08 - CMP BYTE PTR [RAX+RBX+00006498],08
		// Write<uint32>((appBaseAddr + 0x20EF5F + 3), (enable) ? newOff : off); // dmc3.exe+20EF5F - 80 BC 38 98640000 06 - CMP BYTE PTR [RAX+RDI+00006498],06
	}
	// 0x6499
	{
		constexpr auto off = __builtin_offsetof(ActorData, weapons[1]) ;
		constexpr auto newOff = __builtin_offsetof(ActorData, newWeapons[1]) ;
		static_assert(off == 0x6499);
		// Init Actor Dante
		Write<uint32>((appBaseAddr + 0x217C07 + 2), (enable) ? newOff : off); // dmc3.exe+217C07 - 88 81 99640000 - MOV [RCX+00006499],AL
		// Update Actor
		Write<uint32>((appBaseAddr + 0x1DF2E9 + 2), (enable) ? newOff : off); // dmc3.exe+1DF2E9 - C6 83 99640000 FF - MOV BYTE PTR [RBX+00006499],-01
		// func_2198D0
		Write<uint32>((appBaseAddr + 0x2198E5 + 3), (enable) ? newOff : off); // dmc3.exe+2198E5 - 0FB6 81 99640000 - MOVZX EAX,BYTE PTR [RCX+00006499]
		// func_2241F0
		Write<uint32>((appBaseAddr + 0x224205 + 3), (enable) ? newOff : off); // dmc3.exe+224205 - 0FB6 81 99640000 - MOVZX EAX,BYTE PTR [RCX+00006499]
		// Unknown
		// Write<uint32>((appBaseAddr + 0x1FCFE6 + 2), (enable) ? newOff : off); // dmc3.exe+1FCFE6 - 80 B9 99640000 FF - CMP BYTE PTR [RCX+00006499],-01
		// Write<uint32>((appBaseAddr + 0x1FCFEF + 2), (enable) ? newOff : off); // dmc3.exe+1FCFEF - 88 91 99640000 - MOV [RCX+00006499],DL
	}
	// 0x649A
	{
		constexpr auto off = __builtin_offsetof(ActorData, weapons[2]) ;
		constexpr auto newOff = __builtin_offsetof(ActorData, newWeapons[2]) ;
		static_assert(off == 0x649A);
		// Init Actor Dante
		Write<uint32>((appBaseAddr + 0x217C1A + 2), (enable) ? newOff : off); // dmc3.exe+217C1A - 88 81 9A640000 - MOV [RCX+0000649A],AL
		// Update Actor Dante
		Write<uint32>((appBaseAddr + 0x212F12 + 3), (enable) ? newOff : off); // dmc3.exe+212F12 - 48 8D 9E 9A640000 - LEA RBX,[RSI+0000649A]
		// Register Weapons
		Write<uint32>((appBaseAddr + 0x1DEE2A + 3), (enable) ? newOff : off); // dmc3.exe+1DEE2A - 48 8D AB 9A640000 - LEA RBP,[RBX+0000649A]
		// func_2198D0
		Write<uint32>((appBaseAddr + 0x2198F8 + 3), (enable) ? newOff : off); // dmc3.exe+2198F8 - 0FB6 81 9A640000 - MOVZX EAX,BYTE PTR [RCX+0000649A]
		// func_2241F0
		Write<uint32>((appBaseAddr + 0x224218 + 3), (enable) ? newOff : off); // dmc3.exe+224218 - 0FB6 81 9A640000 - MOVZX EAX,BYTE PTR [RCX+0000649A]
		// Unknown
		// Write<uint32>((appBaseAddr + 0x1FCFB0 + 2), (enable) ? newOff : off); // dmc3.exe+1FCFB0 - 80 B9 9A640000 FF - CMP BYTE PTR [RCX+0000649A],-01
		// Write<uint32>((appBaseAddr + 0x1FCFB9 + 2), (enable) ? newOff : off); // dmc3.exe+1FCFB9 - 88 91 9A640000 - MOV [RCX+0000649A],DL
	}
	// 0x649B
	{
		constexpr auto off = __builtin_offsetof(ActorData, weapons[3]) ;
		constexpr auto newOff = __builtin_offsetof(ActorData, newWeapons[3]) ;
		static_assert(off == 0x649B);
		// Init Actor Dante
		Write<uint32>((appBaseAddr + 0x217C2D + 2), (enable) ? newOff : off); // dmc3.exe+217C2D - 88 81 9B640000 - MOV [RCX+0000649B],AL
		// Update Actor
		Write<uint32>((appBaseAddr + 0x1DF2F9 + 2), (enable) ? newOff : off); // dmc3.exe+1DF2F9 - C6 83 9B640000 FF - MOV BYTE PTR [RBX+0000649B],-01
		// func_2198D0
		Write<uint32>((appBaseAddr + 0x21990B + 3), (enable) ? newOff : off); // dmc3.exe+21990B - 0FB6 81 9B640000 - MOVZX EAX,BYTE PTR [RCX+0000649B]
		// func_2241F0
		Write<uint32>((appBaseAddr + 0x22422B + 3), (enable) ? newOff : off); // dmc3.exe+22422B - 0FB6 81 9B640000 - MOVZX EAX,BYTE PTR [RCX+0000649B]
		// Unknown
		// Write<uint32>((appBaseAddr + 0x1FCFC2 + 2), (enable) ? newOff : off); // dmc3.exe+1FCFC2 - 80 B9 9B640000 FF - CMP BYTE PTR [RCX+0000649B],-01
		// Write<uint32>((appBaseAddr + 0x1FCFCB + 2), (enable) ? newOff : off); // dmc3.exe+1FCFCB - 88 91 9B640000 - MOV [RCX+0000649B],DL
	}
	// 0x649C
	{
		constexpr auto off = __builtin_offsetof(ActorData, weapons[4]) ;
		constexpr auto newOff = __builtin_offsetof(ActorData, newWeapons[4]) ;
		static_assert(off == 0x649C);
		// Init Actor Dante
		Write<uint32>((appBaseAddr + 0x217C40 + 2), (enable) ? newOff : off); // dmc3.exe+217C40 - 88 81 9C640000 - MOV [RCX+0000649C],AL
		// Init Actor Bob
		Write<uint32>((appBaseAddr + 0x226F5D + 2), (enable) ? newOff : off); // dmc3.exe+226F5D - C6 81 9C640000 FF - MOV BYTE PTR [RCX+0000649C],-01
		// Init Actor Lady
		Write<uint32>((appBaseAddr + 0x2196B4 + 2), (enable) ? newOff : off); // dmc3.exe+2196B4 - C6 81 9C640000 0B - MOV BYTE PTR [RCX+0000649C],0B
		// Init Actor Vergil
		Write<uint32>((appBaseAddr + 0x223D1B + 2), (enable) ? newOff : off); // dmc3.exe+223D1B - C6 81 9C640000 FF - MOV BYTE PTR [RCX+0000649C],-01
		// func_2198D0
		Write<uint32>((appBaseAddr + 0x21991E + 3), (enable) ? newOff : off); // dmc3.exe+21991E - 0FB6 81 9C640000 - MOVZX EAX,BYTE PTR [RCX+0000649C]
		// func_2241F0
		Write<uint32>((appBaseAddr + 0x22423E + 3), (enable) ? newOff : off); // dmc3.exe+22423E - 0FB6 81 9C640000 - MOVZX EAX,BYTE PTR [RCX+0000649C]
	}
	// 0x64A0
	{
		constexpr auto off = __builtin_offsetof(ActorData, weaponDataAddr[0]) ;
		constexpr auto newOff = __builtin_offsetof(ActorData, newWeaponDataAddr[0]) ;
		static_assert(off == 0x64A0);
		// Register Weapons
		Write<uint32>((appBaseAddr + 0x1DED55 + 3), (enable) ? newOff : off); // dmc3.exe+1DED55 - 48 8D B1 A0640000 - LEA RSI,[RCX+000064A0]
		// Other
		Write<uint32>((appBaseAddr + 0x1DFB82 + 3), (enable) ? newOff : off); // dmc3.exe+1DFB82 - 48 8D 99 A0640000 - LEA RBX,[RCX+000064A0]
		Write<uint32>((appBaseAddr + 0x1FACBB + 4), (enable) ? newOff : off); // dmc3.exe+1FACBB - 49 8B 8C CA A0640000 - MOV RCX,[R10+RCX*8+000064A0]
		Write<uint32>((appBaseAddr + 0x1FAD5B + 4), (enable) ? newOff : off); // dmc3.exe+1FAD5B - 49 8B 8C C9 A0640000 - MOV RCX,[R9+RCX*8+000064A0]
		Write<uint32>((appBaseAddr + 0x1FB84C + 3), (enable) ? newOff : off); // dmc3.exe+1FB84C - 48 8D B3 A0640000 - LEA RSI,[RBX+000064A0]
		Write<uint32>((appBaseAddr + 0x1FB9A7 + 3), (enable) ? newOff : off); // dmc3.exe+1FB9A7 - 48 8D B3 A0640000 - LEA RSI,[RBX+000064A0]
		Write<uint32>((appBaseAddr + 0x1FCAD4 + 3), (enable) ? newOff : off); // dmc3.exe+1FCAD4 - 49 8D 9E A0640000 - LEA RBX,[R14+000064A0]
		Write<uint32>((appBaseAddr + 0x1FCEC8 + 3), (enable) ? newOff : off); // dmc3.exe+1FCEC8 - 48 81 C7 A0640000 - ADD RDI,000064A0
		Write<uint32>((appBaseAddr + 0x2061AE + 4), (enable) ? newOff : off); // dmc3.exe+2061AE - 4C 8B 94 C3 A0640000 - MOV R10,[RBX+RAX*8+000064A0]
		Write<uint32>((appBaseAddr + 0x210A48 + 4), (enable) ? newOff : off); // dmc3.exe+210A48 - 48 8B 8C C3 A0640000 - MOV RCX,[RBX+RAX*8+000064A0]
		Write<uint32>((appBaseAddr + 0x210D2B + 4), (enable) ? newOff : off); // dmc3.exe+210D2B - 48 8B 8C C3 A0640000 - MOV RCX,[RBX+RAX*8+000064A0]
		Write<uint32>((appBaseAddr + 0x2113FC + 4), (enable) ? newOff : off); // dmc3.exe+2113FC - 48 8B 8C C6 A0640000 - MOV RCX,[RSI+RAX*8+000064A0]
		Write<uint32>((appBaseAddr + 0x2114DD + 4), (enable) ? newOff : off); // dmc3.exe+2114DD - 48 8B 8C C6 A0640000 - MOV RCX,[RSI+RAX*8+000064A0]
		Write<uint32>((appBaseAddr + 0x21160F + 4), (enable) ? newOff : off); // dmc3.exe+21160F - 48 8B 8C C6 A0640000 - MOV RCX,[RSI+RAX*8+000064A0]
		Write<uint32>((appBaseAddr + 0x21169E + 4), (enable) ? newOff : off); // dmc3.exe+21169E - 48 8B 8C C6 A0640000 - MOV RCX,[RSI+RAX*8+000064A0]
		Write<uint32>((appBaseAddr + 0x21174E + 4), (enable) ? newOff : off); // dmc3.exe+21174E - 48 8B 8C C6 A0640000 - MOV RCX,[RSI+RAX*8+000064A0]
		Write<uint32>((appBaseAddr + 0x2117B5 + 4), (enable) ? newOff : off); // dmc3.exe+2117B5 - 48 8B 8C C6 A0640000 - MOV RCX,[RSI+RAX*8+000064A0]
		Write<uint32>((appBaseAddr + 0x2158CE + 4), (enable) ? newOff : off); // dmc3.exe+2158CE - 48 8B 8C C7 A0640000 - MOV RCX,[RDI+RAX*8+000064A0]
		Write<uint32>((appBaseAddr + 0x2159FE + 4), (enable) ? newOff : off); // dmc3.exe+2159FE - 48 8B 8C C7 A0640000 - MOV RCX,[RDI+RAX*8+000064A0]
		Write<uint32>((appBaseAddr + 0x216EA9 + 4), (enable) ? newOff : off); // dmc3.exe+216EA9 - 48 8B 8C C7 A0640000 - MOV RCX,[RDI+RAX*8+000064A0]
		Write<uint32>((appBaseAddr + 0x218443 + 4), (enable) ? newOff : off); // dmc3.exe+218443 - 48 8B BC C3 A0640000 - MOV RDI,[RBX+RAX*8+000064A0]
		Write<uint32>((appBaseAddr + 0x218472 + 4), (enable) ? newOff : off); // dmc3.exe+218472 - 48 8B BC C3 A0640000 - MOV RDI,[RBX+RAX*8+000064A0]
		Write<uint32>((appBaseAddr + 0x2184D6 + 4), (enable) ? newOff : off); // dmc3.exe+2184D6 - 48 8B BC C3 A0640000 - MOV RDI,[RBX+RAX*8+000064A0]
		Write<uint32>((appBaseAddr + 0x218516 + 4), (enable) ? newOff : off); // dmc3.exe+218516 - 48 8B BC C3 A0640000 - MOV RDI,[RBX+RAX*8+000064A0]
		Write<uint32>((appBaseAddr + 0x21854E + 4), (enable) ? newOff : off); // dmc3.exe+21854E - 48 8B BC C3 A0640000 - MOV RDI,[RBX+RAX*8+000064A0]
		Write<uint32>((appBaseAddr + 0x21A48F + 4), (enable) ? newOff : off); // dmc3.exe+21A48F - 4C 8B 8C C3 A0640000 - MOV R9,[RBX+RAX*8+000064A0]
		Write<uint32>((appBaseAddr + 0x21A4DF + 4), (enable) ? newOff : off); // dmc3.exe+21A4DF - 4C 8B 8C C3 A0640000 - MOV R9,[RBX+RAX*8+000064A0]
		Write<uint32>((appBaseAddr + 0x21B810 + 4), (enable) ? newOff : off); // dmc3.exe+21B810 - 4C 8B 8C C3 A0640000 - MOV R9,[RBX+RAX*8+000064A0]
		Write<uint32>((appBaseAddr + 0x21B8E1 + 4), (enable) ? newOff : off); // dmc3.exe+21B8E1 - 4C 8B 8C C3 A0640000 - MOV R9,[RBX+RAX*8+000064A0]
		Write<uint32>((appBaseAddr + 0x21B90E + 4), (enable) ? newOff : off); // dmc3.exe+21B90E - 4C 8B 8C C3 A0640000 - MOV R9,[RBX+RAX*8+000064A0]
		Write<uint32>((appBaseAddr + 0x21BBD4 + 4), (enable) ? newOff : off); // dmc3.exe+21BBD4 - 48 8B 8C C3 A0640000 - MOV RCX,[RBX+RAX*8+000064A0]
		Write<uint32>((appBaseAddr + 0x21BC78 + 4), (enable) ? newOff : off); // dmc3.exe+21BC78 - 48 8B 8C C3 A0640000 - MOV RCX,[RBX+RAX*8+000064A0]
		Write<uint32>((appBaseAddr + 0x21C0BE + 4), (enable) ? newOff : off); // dmc3.exe+21C0BE - 48 8B BC C3 A0640000 - MOV RDI,[RBX+RAX*8+000064A0]
		Write<uint32>((appBaseAddr + 0x21C3F1 + 4), (enable) ? newOff : off); // dmc3.exe+21C3F1 - 4C 8B 8C C3 A0640000 - MOV R9,[RBX+RAX*8+000064A0]
		Write<uint32>((appBaseAddr + 0x21C41E + 4), (enable) ? newOff : off); // dmc3.exe+21C41E - 4C 8B 8C C3 A0640000 - MOV R9,[RBX+RAX*8+000064A0]
		Write<uint32>((appBaseAddr + 0x21C6BF + 4), (enable) ? newOff : off); // dmc3.exe+21C6BF - 48 8B BC C3 A0640000 - MOV RDI,[RBX+RAX*8+000064A0]
		Write<uint32>((appBaseAddr + 0x21C761 + 4), (enable) ? newOff : off); // dmc3.exe+21C761 - 48 8B BC C3 A0640000 - MOV RDI,[RBX+RAX*8+000064A0]
		Write<uint32>((appBaseAddr + 0x21C85E + 4), (enable) ? newOff : off); // dmc3.exe+21C85E - 48 8B BC C3 A0640000 - MOV RDI,[RBX+RAX*8+000064A0]
		Write<uint32>((appBaseAddr + 0x21D0F3 + 4), (enable) ? newOff : off); // dmc3.exe+21D0F3 - 4C 8B 8C C7 A0640000 - MOV R9,[RDI+RAX*8+000064A0]
		Write<uint32>((appBaseAddr + 0x21D11E + 4), (enable) ? newOff : off); // dmc3.exe+21D11E - 4C 8B 8C C7 A0640000 - MOV R9,[RDI+RAX*8+000064A0]
		Write<uint32>((appBaseAddr + 0x21E923 + 4), (enable) ? newOff : off); // dmc3.exe+21E923 - 4C 8B 8C C3 A0640000 - MOV R9,[RBX+RAX*8+000064A0]
		Write<uint32>((appBaseAddr + 0x21E94E + 4), (enable) ? newOff : off); // dmc3.exe+21E94E - 4C 8B 8C C3 A0640000 - MOV R9,[RBX+RAX*8+000064A0]
		Write<uint32>((appBaseAddr + 0x21F2F7 + 4), (enable) ? newOff : off); // dmc3.exe+21F2F7 - 48 8B 8C C3 A0640000 - MOV RCX,[RBX+RAX*8+000064A0]
		Write<uint32>((appBaseAddr + 0x222B62 + 4), (enable) ? newOff : off); // dmc3.exe+222B62 - 48 8B 8C C7 A0640000 - MOV RCX,[RDI+RAX*8+000064A0]
		// Unknown
		// Write<uint32>((appBaseAddr + 0x1FB777 + 3), (enable) ? newOff : off); // dmc3.exe+1FB777 - 48 8D B3 A0640000 - LEA RSI,[RBX+000064A0]
		// Write<uint32>((appBaseAddr + 0x1FB8F8 + 3), (enable) ? newOff : off); // dmc3.exe+1FB8F8 - 48 8D B3 A0640000 - LEA RSI,[RBX+000064A0]
	}
	// 0x64B0
	{
		constexpr auto off = __builtin_offsetof(ActorData, weaponDataAddr[2]) ;
		constexpr auto newOff = __builtin_offsetof(ActorData, newWeaponDataAddr[2]) ;
		static_assert(off == 0x64B0);
		// Register Weapons
		Write<uint32>((appBaseAddr + 0x1DEE3E + 3), (enable) ? newOff : off); // dmc3.exe+1DEE3E - 48 8D B3 B0640000 - LEA RSI,[RBX+000064B0]
	}
	// 0x64B8
	{
		constexpr auto off = __builtin_offsetof(ActorData, weaponDataAddr[3]) ;
		constexpr auto newOff = __builtin_offsetof(ActorData, newWeaponDataAddr[3]) ;
		static_assert(off == 0x64B8);
		// Register Weapons
		Write<uint32>((appBaseAddr + 0x1DEF27 + 3), (enable) ? newOff : off); // dmc3.exe+1DEF27 - 48 89 83 B8640000 - MOV [RBX+000064B8],RAX
		// Other
		Write<uint32>((appBaseAddr + 0x21AF95 + 3), (enable) ? newOff : off); // dmc3.exe+21AF95 - 48 8B 8F B8640000 - MOV RCX,[RDI+000064B8]
	}
	// 0x64C8
	{
		constexpr auto off = __builtin_offsetof(ActorData, weaponStatus[0]) ;
		constexpr auto newOff = __builtin_offsetof(ActorData, newWeaponStatus[0]) ;
		static_assert(off == 0x64C8);
		// Register Weapons
		Write<uint32>((appBaseAddr + 0x1DED48 + 3), (enable) ? newOff : off); // dmc3.exe+1DED48 - 48 8D B9 C8640000 - LEA RDI,[RCX+000064C8]
		// Other
		Write<uint32>((appBaseAddr + 0x1D9203 + 3), (enable) ? newOff : off); // dmc3.exe+1D9203 - C7 84 82 C8640000 00000000 - MOV [RDX+RAX*4+000064C8],00000000
		Write<uint32>((appBaseAddr + 0x1FAD1E + 4), (enable) ? newOff : off); // dmc3.exe+1FAD1E - 41 8B 84 89 C8640000 - MOV EAX,[R9+RCX*4+000064C8]
		Write<uint32>((appBaseAddr + 0x1FD162 + 4), (enable) ? newOff : off); // dmc3.exe+1FD162 - 44 39 8C 81 C8640000 - CMP [RCX+RAX*4+000064C8],R9D
		Write<uint32>((appBaseAddr + 0x1FD1E9 + 4), (enable) ? newOff : off); // dmc3.exe+1FD1E9 - 41 83 BC 8A C8640000 04 - CMP DWORD PTR [R10+RCX*4+000064C8],04
		Write<uint32>((appBaseAddr + 0x1FD1F4 + 4), (enable) ? newOff : off); // dmc3.exe+1FD1F4 - 45 89 84 8A C8640000 - MOV [R10+RCX*4+000064C8],R8D
		Write<uint32>((appBaseAddr + 0x2063BA + 3), (enable) ? newOff : off); // dmc3.exe+2063BA - 83 BC BB C8640000 01 - CMP DWORD PTR [RBX+RDI*4+000064C8],01
		Write<uint32>((appBaseAddr + 0x206418 + 3), (enable) ? newOff : off); // dmc3.exe+206418 - C7 84 BB C8640000 02000000 - MOV [RBX+RDI*4+000064C8],00000002
		Write<uint32>((appBaseAddr + 0x20644C + 3), (enable) ? newOff : off); // dmc3.exe+20644C - 83 BC BB C8640000 03 - CMP DWORD PTR [RBX+RDI*4+000064C8],03
		Write<uint32>((appBaseAddr + 0x206532 + 3), (enable) ? newOff : off); // dmc3.exe+206532 - C7 84 83 C8640000 01000000 - MOV [RBX+RAX*4+000064C8],00000001
		Write<uint32>((appBaseAddr + 0x210CDF + 3), (enable) ? newOff : off); // dmc3.exe+210CDF - C7 84 93 C8640000 01000000 - MOV [RBX+RDX*4+000064C8],00000001
		Write<uint32>((appBaseAddr + 0x215650 + 3), (enable) ? newOff : off); // dmc3.exe+215650 - 48 8D 87 C8640000 - LEA RAX,[RDI+000064C8]
		Write<uint32>((appBaseAddr + 0x215725 + 3), (enable) ? newOff : off); // dmc3.exe+215725 - 83 BC 9F C8640000 01 - CMP DWORD PTR [RDI+RBX*4+000064C8],01
		Write<uint32>((appBaseAddr + 0x215770 + 3), (enable) ? newOff : off); // dmc3.exe+215770 - C7 84 9F C8640000 02000000 - MOV [RDI+RBX*4+000064C8],00000002
		Write<uint32>((appBaseAddr + 0x215995 + 4), (enable) ? newOff : off); // dmc3.exe+215995 - 44 39 B4 87 C8640000 - CMP [RDI+RAX*4+000064C8],R14D
		Write<uint32>((appBaseAddr + 0x21F29E + 3), (enable) ? newOff : off); // dmc3.exe+21F29E - C7 84 93 C8640000 01000000 - MOV [RBX+RDX*4+000064C8],00000001
		Write<uint32>((appBaseAddr + 0x222941 + 3), (enable) ? newOff : off); // dmc3.exe+222941 - 48 8D 87 C8640000 - LEA RAX,[RDI+000064C8]
		Write<uint32>((appBaseAddr + 0x2229BE + 3), (enable) ? newOff : off); // dmc3.exe+2229BE - 39 B4 87 C8640000 - CMP [RDI+RAX*4+000064C8],ESI
		Write<uint32>((appBaseAddr + 0x222EAF + 3), (enable) ? newOff : off); // dmc3.exe+222EAF - 83 BC 87 C8640000 00 - CMP DWORD PTR [RDI+RAX*4+000064C8],00
		Write<uint32>((appBaseAddr + 0x222F57 + 3), (enable) ? newOff : off); // dmc3.exe+222F57 - 39 B4 87 C8640000 - CMP [RDI+RAX*4+000064C8],ESI
	}
	// 0x64D0
	{
		constexpr auto off = __builtin_offsetof(ActorData, weaponStatus[2]) ;
		constexpr auto newOff = __builtin_offsetof(ActorData, newWeaponStatus[2]) ;
		static_assert(off == 0x64D0);
		// Register Weapons
		Write<uint32>((appBaseAddr + 0x1DEE37 + 3), (enable) ? newOff : off); // dmc3.exe+1DEE37 - 48 8D BB D0640000 - LEA RDI,[RBX+000064D0]
	}
	// 0x64DC
	{
		constexpr auto off = __builtin_offsetof(ActorData, weaponLevels[0]) ;
		constexpr auto newOff = __builtin_offsetof(ActorData, newWeaponLevels[0]) ;
		static_assert(off == 0x64DC);
		// Init Actor Dante
		Write<uint32>((appBaseAddr + 0x217BFD + 2), (enable) ? newOff : off); // dmc3.exe+217BFD - 89 81 DC640000 - MOV [RCX+000064DC],EAX
		// Init Actor Bob
		Write<uint32>((appBaseAddr + 0x226F64 + 3), (enable) ? newOff : off); // dmc3.exe+226F64 - 4C 89 A1 DC640000 - MOV [RCX+000064DC],R12
		// Init Actor Lady
		Write<uint32>((appBaseAddr + 0x2196BB + 3), (enable) ? newOff : off); // dmc3.exe+2196BB - 4C 89 A1 DC640000 - MOV [RCX+000064DC],R12
		// Init Actor Vergil
		Write<uint32>((appBaseAddr + 0x223D25 + 2), (enable) ? newOff : off); // dmc3.exe+223D25 - 89 81 DC640000 - MOV [RCX+000064DC],EAX
		// func_2198D0
		Write<uint32>((appBaseAddr + 0x2198DC + 2), (enable) ? newOff : off); // dmc3.exe+2198DC - 8B 81 DC640000 - MOV EAX,[RCX+000064DC]
		// func_2241F0
		Write<uint32>((appBaseAddr + 0x2241FC + 2), (enable) ? newOff : off); // dmc3.exe+2241FC - 8B 81 DC640000 - MOV EAX,[RCX+000064DC]
		// Other
		Write<uint32>((appBaseAddr + 0x2061C1 + 4), (enable) ? newOff : off); // dmc3.exe+2061C1 - 44 8B 84 83 DC640000 - MOV R8D,[RBX+RAX*4+000064DC]
		Write<uint32>((appBaseAddr + 0x208704 + 4), (enable) ? newOff : off); // dmc3.exe+208704 - 44 8B 84 83 DC640000 - MOV R8D,[RBX+RAX*4+000064DC]
		Write<uint32>((appBaseAddr + 0x20E321 + 4), (enable) ? newOff : off); // dmc3.exe+20E321 - 44 8B 84 83 DC640000 - MOV R8D,[RBX+RAX*4+000064DC]
		Write<uint32>((appBaseAddr + 0x20E684 + 3), (enable) ? newOff : off); // dmc3.exe+20E684 - 8B BC 83 DC640000 - MOV EDI,[RBX+RAX*4+000064DC]
		Write<uint32>((appBaseAddr + 0x20E72F + 3), (enable) ? newOff : off); // dmc3.exe+20E72F - 8B BC 83 DC640000 - MOV EDI,[RBX+RAX*4+000064DC]
		Write<uint32>((appBaseAddr + 0x215EBE + 3), (enable) ? newOff : off); // dmc3.exe+215EBE - 83 BC 87 DC640000 01 - CMP DWORD PTR [RDI+RAX*4+000064DC],01
		Write<uint32>((appBaseAddr + 0x215ED5 + 3), (enable) ? newOff : off); // dmc3.exe+215ED5 - 83 BC 87 DC640000 02 - CMP DWORD PTR [RDI+RAX*4+000064DC],02
		Write<uint32>((appBaseAddr + 0x217496 + 3), (enable) ? newOff : off); // dmc3.exe+217496 - 8B 8C 87 DC640000 - MOV ECX,[RDI+RAX*4+000064DC]
		Write<uint32>((appBaseAddr + 0x218408 + 3), (enable) ? newOff : off); // dmc3.exe+218408 - 8B 8C 83 DC640000 - MOV ECX,[RBX+RAX*4+000064DC]
		// Unknown
		// Write<uint32>((appBaseAddr + 0x20872F + 4), (enable) ? newOff : off); // dmc3.exe+20872F - 44 8B 84 83 DC640000 - MOV R8D,[RBX+RAX*4+000064DC]
		// Write<uint32>((appBaseAddr + 0x20E351 + 4), (enable) ? newOff : off); // dmc3.exe+20E351 - 44 8B 84 83 DC640000 - MOV R8D,[RBX+RAX*4+000064DC]
		// Write<uint32>((appBaseAddr + 0x20E37F + 4), (enable) ? newOff : off); // dmc3.exe+20E37F - 44 8B 84 83 DC640000 - MOV R8D,[RBX+RAX*4+000064DC]
	}
	// 0x64E0
	{
		constexpr auto off = __builtin_offsetof(ActorData, weaponLevels[1]) ;
		constexpr auto newOff = __builtin_offsetof(ActorData, newWeaponLevels[1]) ;
		static_assert(off == 0x64E0);
		// Init Actor Dante
		Write<uint32>((appBaseAddr + 0x217C10 + 2), (enable) ? newOff : off); // dmc3.exe+217C10 - 89 81 E0640000 - MOV [RCX+000064E0],EAX
		// Init Actor Vergil
		Write<uint32>((appBaseAddr + 0x223D2E + 2), (enable) ? newOff : off); // dmc3.exe+223D2E - 89 81 E0640000 - MOV [RCX+000064E0],EAX
		// func_2198D0
		Write<uint32>((appBaseAddr + 0x2198EF + 2), (enable) ? newOff : off); // dmc3.exe+2198EF - 8B 81 E0640000 - MOV EAX,[RCX+000064E0]
		// func_2241F0
		Write<uint32>((appBaseAddr + 0x22420F + 2), (enable) ? newOff : off); // dmc3.exe+22420F - 8B 81 E0640000 - MOV EAX,[RCX+000064E0]
	}
	// 0x64E4
	{
		constexpr auto off = __builtin_offsetof(ActorData, weaponLevels[2]) ;
		constexpr auto newOff = __builtin_offsetof(ActorData, newWeaponLevels[2]) ;
		static_assert(off == 0x64E4);
		// Init Actor Dante
		Write<uint32>((appBaseAddr + 0x217C23 + 2), (enable) ? newOff : off); // dmc3.exe+217C23 - 89 81 E4640000 - MOV [RCX+000064E4],EAX
		// Init Actor Bob
		Write<uint32>((appBaseAddr + 0x226F6B + 3), (enable) ? newOff : off); // dmc3.exe+226F6B - 4C 89 A1 E4640000 - MOV [RCX+000064E4],R12
		// Init Actor Lady
		Write<uint32>((appBaseAddr + 0x2196C2 + 3), (enable) ? newOff : off); // dmc3.exe+2196C2 - 4C 89 A1 E4640000 - MOV [RCX+000064E4],R12
		// Init Actor Vergil
		Write<uint32>((appBaseAddr + 0x223D37 + 2), (enable) ? newOff : off); // dmc3.exe+223D37 - 89 81 E4640000 - MOV [RCX+000064E4],EAX
		// func_2198D0
		Write<uint32>((appBaseAddr + 0x219902 + 2), (enable) ? newOff : off); // dmc3.exe+219902 - 8B 81 E4640000 - MOV EAX,[RCX+000064E4]
		// func_2241F0
		Write<uint32>((appBaseAddr + 0x224222 + 2), (enable) ? newOff : off); // dmc3.exe+224222 - 8B 81 E4640000 - MOV EAX,[RCX+000064E4]
	}
	// 0x64E8
	{
		constexpr auto off = __builtin_offsetof(ActorData, weaponLevels[3]) ;
		constexpr auto newOff = __builtin_offsetof(ActorData, newWeaponLevels[3]) ;
		static_assert(off == 0x64E8);
		// Init Actor Dante
		Write<uint32>((appBaseAddr + 0x217C36 + 2), (enable) ? newOff : off); // dmc3.exe+217C36 - 89 81 E8640000 - MOV [RCX+000064E8],EAX
		// Init Actor Vergil
		Write<uint32>((appBaseAddr + 0x223D40 + 2), (enable) ? newOff : off); // dmc3.exe+223D40 - 89 81 E8640000 - MOV [RCX+000064E8],EAX
		// func_2198D0
		Write<uint32>((appBaseAddr + 0x219915 + 2), (enable) ? newOff : off); // dmc3.exe+219915 - 8B 81 E8640000 - MOV EAX,[RCX+000064E8]
		// func_2241F0
		Write<uint32>((appBaseAddr + 0x224235 + 2), (enable) ? newOff : off); // dmc3.exe+224235 - 8B 81 E8640000 - MOV EAX,[RCX+000064E8]
	}
	// 0x64EC
	{
		constexpr auto off = __builtin_offsetof(ActorData, weaponLevels[4]) ;
		constexpr auto newOff = __builtin_offsetof(ActorData, newWeaponLevels[4]) ;
		static_assert(off == 0x64EC);
		// Init Actor Dante
		Write<uint32>((appBaseAddr + 0x217C49 + 2), (enable) ? newOff : off); // dmc3.exe+217C49 - 89 81 EC640000 - MOV [RCX+000064EC],EAX
		// Init Actor Bob
		Write<uint32>((appBaseAddr + 0x226F72 + 3), (enable) ? newOff : off); // dmc3.exe+226F72 - 44 89 A1 EC640000 - MOV [RCX+000064EC],R12D
		// Init Actor Lady
		Write<uint32>((appBaseAddr + 0x2196C9 + 3), (enable) ? newOff : off); // dmc3.exe+2196C9 - 44 89 A1 EC640000 - MOV [RCX+000064EC],R12D
		// Init Actor Vergil
		Write<uint32>((appBaseAddr + 0x223D49 + 2), (enable) ? newOff : off); // dmc3.exe+223D49 - 89 81 EC640000 - MOV [RCX+000064EC],EAX
		// func_2198D0
		Write<uint32>((appBaseAddr + 0x219928 + 2), (enable) ? newOff : off); // dmc3.exe+219928 - 8B 81 EC640000 - MOV EAX,[RCX+000064EC]
		// func_2241F0
		Write<uint32>((appBaseAddr + 0x224248 + 2), (enable) ? newOff : off); // dmc3.exe+224248 - 8B 81 EC640000 - MOV EAX,[RCX+000064EC]
	}
	// 0x64F4
	{
		constexpr auto off = __builtin_offsetof(ActorData, weaponTimers[0]) ;
		constexpr auto newOff = __builtin_offsetof(ActorData, newWeaponTimers[0]) ;
		static_assert(off == 0x64F4);
		// Register Weapons
		Write<uint32>((appBaseAddr + 0x1DEF3D + 3), (enable) ? newOff : off); // dmc3.exe+1DEF3D - 4C 89 BB F4640000 - MOV [RBX+000064F4],R15
		// Other
		Write<uint32>((appBaseAddr + 0x2063C2 + 3), (enable) ? newOff : off); // dmc3.exe+2063C2 - C7 84 BB F4640000 00002041 - MOV [RBX+RDI*4+000064F4],41200000
		Write<uint32>((appBaseAddr + 0x206527 + 3), (enable) ? newOff : off); // dmc3.exe+206527 - C7 84 83 F4640000 00002042 - MOV [RBX+RAX*4+000064F4],42200000
		Write<uint32>((appBaseAddr + 0x210CD8 + 3), (enable) ? newOff : off); // dmc3.exe+210CD8 - 89 8C 93 F4640000 - MOV [RBX+RDX*4+000064F4],ECX
		Write<uint32>((appBaseAddr + 0x21560F + 3), (enable) ? newOff : off); // dmc3.exe+21560F - 48 8D 87 F4640000 - LEA RAX,[RDI+000064F4]
		Write<uint32>((appBaseAddr + 0x21577B + 3), (enable) ? newOff : off); // dmc3.exe+21577B - C7 84 9F F4640000 00009644 - MOV [RDI+RBX*4+000064F4],44960000
		Write<uint32>((appBaseAddr + 0x21F297 + 3), (enable) ? newOff : off); // dmc3.exe+21F297 - 89 8C 93 F4640000 - MOV [RBX+RDX*4+000064F4],ECX
		Write<uint32>((appBaseAddr + 0x22290C + 3), (enable) ? newOff : off); // dmc3.exe+22290C - 48 8D 87 F4640000 - LEA RAX,[RDI+000064F4]
	}
	// 0x64FC
	{
		constexpr auto off = __builtin_offsetof(ActorData, weaponTimers[2]) ;
		constexpr auto newOff = __builtin_offsetof(ActorData, newWeaponTimers[2]) ;
		static_assert(off == 0x64FC);
		// Register Weapons
		Write<uint32>((appBaseAddr + 0x1DEF44 + 3), (enable) ? newOff : off); // dmc3.exe+1DEF44 - 4C 89 BB FC640000 - MOV [RBX+000064FC],R15
	}
	// 0x6504
	{
		constexpr auto off = __builtin_offsetof(ActorData, weaponTimers[4]) ;
		constexpr auto newOff = __builtin_offsetof(ActorData, newWeaponTimers[4]) ;
		static_assert(off == 0x6504);
		// Register Weapons
		Write<uint32>((appBaseAddr + 0x1DEF4B + 3), (enable) ? newOff : off); // dmc3.exe+1DEF4B - 44 89 BB 04650000 - MOV [RBX+00006504],R15D
	}
	// 0x6950
	{
		constexpr auto off = __builtin_offsetof(ActorData, bodyPartData[0][0]) ;
		constexpr auto newOff = __builtin_offsetof(ActorData, newBodyPartData[0][0]) ;
		static_assert(off == 0x6950);
		// func_1DDAF0
		Write<uint32>((appBaseAddr + 0x1DDD63 + 3), (enable) ? newOff : off); // dmc3.exe+1DDD63 - 48 8D 8E 50690000 - LEA RCX,[RSI+00006950]
		// func_1DE280
		Write<uint32>((appBaseAddr + 0x1DE2F4 + 3), (enable) ? newOff : off); // dmc3.exe+1DE2F4 - 48 8D 8F 50690000 - LEA RCX,[RDI+00006950]
		// func_1EF040
		Write<uint32>((appBaseAddr + 0x1EF4CE + 3), (enable) ? newOff : off); // dmc3.exe+1EF4CE - 49 8D 8D 50690000 - LEA RCX,[R13+00006950]
		// Other
		Write<uint32>((appBaseAddr + 0x1EF90E + 3), (enable) ? newOff : off); // dmc3.exe+1EF90E - 48 8D 8B 50690000 - LEA RCX,[RBX+00006950]
		Write<uint32>((appBaseAddr + 0x1EF947 + 3), (enable) ? newOff : off); // dmc3.exe+1EF947 - 48 81 C1 50690000 - ADD RCX,00006950
		Write<uint32>((appBaseAddr + 0x1EFAC0 + 3), (enable) ? newOff : off); // dmc3.exe+1EFAC0 - 48 81 C1 50690000 - ADD RCX,00006950
		Write<uint32>((appBaseAddr + 0x1EFADE + 3), (enable) ? newOff : off); // dmc3.exe+1EFADE - 48 8D 8B 50690000 - LEA RCX,[RBX+00006950]
		Write<uint32>((appBaseAddr + 0x1EFB0E + 3), (enable) ? newOff : off); // dmc3.exe+1EFB0E - 48 81 C3 50690000 - ADD RBX,00006950
		Write<uint32>((appBaseAddr + 0x1EFC62 + 3), (enable) ? newOff : off); // dmc3.exe+1EFC62 - 48 81 C1 50690000 - ADD RCX,00006950
		Write<uint32>((appBaseAddr + 0x1EFD36 + 3), (enable) ? newOff : off); // dmc3.exe+1EFD36 - 48 81 C1 50690000 - ADD RCX,00006950
		Write<uint32>((appBaseAddr + 0x1EFFFE + 3), (enable) ? newOff : off); // dmc3.exe+1EFFFE - 48 81 C1 50690000 - ADD RCX,00006950
		Write<uint32>((appBaseAddr + 0x1F0052 + 3), (enable) ? newOff : off); // dmc3.exe+1F0052 - 48 81 C1 50690000 - ADD RCX,00006950
		Write<uint32>((appBaseAddr + 0x1F906A + 3), (enable) ? newOff : off); // dmc3.exe+1F906A - 48 81 C1 50690000 - ADD RCX,00006950
		Write<uint32>((appBaseAddr + 0x1F9080 + 3), (enable) ? newOff : off); // dmc3.exe+1F9080 - 48 8D 97 50690000 - LEA RDX,[RDI+00006950]
		// Unknown
		// Write<uint32>((appBaseAddr + 0x1F0446 + 3), (enable) ? newOff : off); // dmc3.exe+1F0446 - 48 81 C1 50690000 - ADD RCX,00006950
	}
	// 0x6A70
	{
		constexpr auto off = __builtin_offsetof(ActorData, bodyPartData[0][1]) ;
		constexpr auto newOff = __builtin_offsetof(ActorData, newBodyPartData[0][1]) ;
		static_assert(off == 0x6A70);
		// func_1EF040
		Write<uint32>((appBaseAddr + 0x1EF477 + 3), (enable) ? newOff : off); // dmc3.exe+1EF477 - 49 8D 8D 706A0000 - LEA RCX,[R13+00006A70]
		// Other
		Write<uint32>((appBaseAddr + 0xB9C7C + 3), (enable) ? newOff : off); // dmc3.exe+B9C7C - 4C 8D B7 706A0000 - LEA R14,[RDI+00006A70]
		Write<uint32>((appBaseAddr + 0xCA512 + 3), (enable) ? newOff : off); // dmc3.exe+CA512 - 48 8D 8E 706A0000 - LEA RCX,[RSI+00006A70]
		Write<uint32>((appBaseAddr + 0xCA62B + 3), (enable) ? newOff : off); // dmc3.exe+CA62B - 48 8D 8E 706A0000 - LEA RCX,[RSI+00006A70]
		Write<uint32>((appBaseAddr + 0xCA97E + 3), (enable) ? newOff : off); // dmc3.exe+CA97E - 48 8D 8D 706A0000 - LEA RCX,[RBP+00006A70]
		Write<uint32>((appBaseAddr + 0x1EF8F0 + 3), (enable) ? newOff : off); // dmc3.exe+1EF8F0 - 48 81 C1 706A0000 - ADD RCX,00006A70
		Write<uint32>((appBaseAddr + 0x1EF969 + 3), (enable) ? newOff : off); // dmc3.exe+1EF969 - 48 81 C3 706A0000 - ADD RBX,00006A70
		Write<uint32>((appBaseAddr + 0x1EFB40 + 3), (enable) ? newOff : off); // dmc3.exe+1EFB40 - 48 81 C1 706A0000 - ADD RCX,00006A70
		Write<uint32>((appBaseAddr + 0x1EFB6B + 3), (enable) ? newOff : off); // dmc3.exe+1EFB6B - 48 8D 8B 706A0000 - LEA RCX,[RBX+00006A70]
		Write<uint32>((appBaseAddr + 0x1EFC24 + 3), (enable) ? newOff : off); // dmc3.exe+1EFC24 - 48 81 C1 706A0000 - ADD RCX,00006A70
		Write<uint32>((appBaseAddr + 0x1F0102 + 3), (enable) ? newOff : off); // dmc3.exe+1F0102 - 48 81 C1 706A0000 - ADD RCX,00006A70
		Write<uint32>((appBaseAddr + 0x1F0211 + 3), (enable) ? newOff : off); // dmc3.exe+1F0211 - 48 81 C1 706A0000 - ADD RCX,00006A70
		Write<uint32>((appBaseAddr + 0x1F025C + 3), (enable) ? newOff : off); // dmc3.exe+1F025C - 48 81 C1 706A0000 - ADD RCX,00006A70
		Write<uint32>((appBaseAddr + 0x1F02A5 + 3), (enable) ? newOff : off); // dmc3.exe+1F02A5 - 48 81 C1 706A0000 - ADD RCX,00006A70
		Write<uint32>((appBaseAddr + 0x1F030D + 3), (enable) ? newOff : off); // dmc3.exe+1F030D - 48 81 C1 706A0000 - ADD RCX,00006A70
		Write<uint32>((appBaseAddr + 0x1F0331 + 3), (enable) ? newOff : off); // dmc3.exe+1F0331 - 48 81 C1 706A0000 - ADD RCX,00006A70
		Write<uint32>((appBaseAddr + 0x1F035B + 3), (enable) ? newOff : off); // dmc3.exe+1F035B - 48 81 C1 706A0000 - ADD RCX,00006A70
		Write<uint32>((appBaseAddr + 0x1F0385 + 3), (enable) ? newOff : off); // dmc3.exe+1F0385 - 48 81 C1 706A0000 - ADD RCX,00006A70
		Write<uint32>((appBaseAddr + 0x1F03B7 + 3), (enable) ? newOff : off); // dmc3.exe+1F03B7 - 48 81 C1 706A0000 - ADD RCX,00006A70
		Write<uint32>((appBaseAddr + 0x1F903D + 3), (enable) ? newOff : off); // dmc3.exe+1F903D - 48 81 C1 706A0000 - ADD RCX,00006A70
	}
	// 0x6B90
	{
		constexpr auto off = __builtin_offsetof(ActorData, bodyPartData[1][0]) ;
		constexpr auto newOff = __builtin_offsetof(ActorData, newBodyPartData[1][0]) ;
		static_assert(off == 0x6B90);
		// func_1EF040
		Write<uint32>((appBaseAddr + 0x1EF3AE + 3), (enable) ? newOff : off); // dmc3.exe+1EF3AE - 49 8D 8D 906B0000 - LEA RCX,[R13+00006B90]
	}
	// 0x6CB0
	{
		constexpr auto off = __builtin_offsetof(ActorData, bodyPartData[1][1]) ;
		constexpr auto newOff = __builtin_offsetof(ActorData, newBodyPartData[1][1]) ;
		static_assert(off == 0x6CB0);
		// func_1EF040
		Write<uint32>((appBaseAddr + 0x1EF357 + 3), (enable) ? newOff : off); // dmc3.exe+1EF357 - 49 8D 8D B06C0000 - LEA RCX,[R13+00006CB0]
	}
	// 0x6DD0
	{
		constexpr auto off = __builtin_offsetof(ActorData, bodyPartData[2][0]) ;
		constexpr auto newOff = __builtin_offsetof(ActorData, newBodyPartData[2][0]) ;
		static_assert(off == 0x6DD0);
		// func_1EF040
		Write<uint32>((appBaseAddr + 0x1EF282 + 3), (enable) ? newOff : off); // dmc3.exe+1EF282 - 49 8D 8D D06D0000 - LEA RCX,[R13+00006DD0]
	}
	// 0x6EF0
	{
		constexpr auto off = __builtin_offsetof(ActorData, bodyPartData[2][1]) ;
		constexpr auto newOff = __builtin_offsetof(ActorData, newBodyPartData[2][1]) ;
		static_assert(off == 0x6EF0);
		// func_1EF040
		Write<uint32>((appBaseAddr + 0x1EF22B + 3), (enable) ? newOff : off); // dmc3.exe+1EF22B - 49 8D 8D F06E0000 - LEA RCX,[R13+00006EF0]
	}
	// 0x7540
	{
		constexpr auto off = __builtin_offsetof(ActorData, submodelData[0]) ;
		constexpr auto newOff = __builtin_offsetof(ActorData, newSubmodelData[0]) ;
		static_assert(off == 0x7540);
		// Update Actor Dante
		Write<uint32>((appBaseAddr + 0x2132C5 + 3), (enable) ? newOff : off); // dmc3.exe+2132C5 - 49 81 C4 40750000 - ADD R12,00007540
		Write<uint32>((appBaseAddr + 0x2136BF + 3), (enable) ? newOff : off); // dmc3.exe+2136BF - 49 81 C4 40750000 - ADD R12,00007540
		Write<uint32>((appBaseAddr + 0x213ACD + 3), (enable) ? newOff : off); // dmc3.exe+213ACD - 49 81 C4 40750000 - ADD R12,00007540
		Write<uint32>((appBaseAddr + 0x213D57 + 3), (enable) ? newOff : off); // dmc3.exe+213D57 - 49 81 C4 40750000 - ADD R12,00007540
		Write<uint32>((appBaseAddr + 0x21424F + 3), (enable) ? newOff : off); // dmc3.exe+21424F - 49 81 C4 40750000 - ADD R12,00007540
		Write<uint32>((appBaseAddr + 0x21463A + 3), (enable) ? newOff : off); // dmc3.exe+21463A - 49 81 C4 40750000 - ADD R12,00007540
		Write<uint32>((appBaseAddr + 0x2148B6 + 3), (enable) ? newOff : off); // dmc3.exe+2148B6 - 49 81 C4 40750000 - ADD R12,00007540
		// Update Actor Bob
		Write<uint32>((appBaseAddr + 0x2260CA + 3), (enable) ? newOff : off); // dmc3.exe+2260CA - 49 8D B6 40750000 - LEA RSI,[R14+00007540]
		Write<uint32>((appBaseAddr + 0x22648D + 3), (enable) ? newOff : off); // dmc3.exe+22648D - 48 81 C7 40750000 - ADD RDI,00007540
		Write<uint32>((appBaseAddr + 0x22669C + 3), (enable) ? newOff : off); // dmc3.exe+22669C - 48 81 C7 40750000 - ADD RDI,00007540
		Write<uint32>((appBaseAddr + 0x2268A2 + 3), (enable) ? newOff : off); // dmc3.exe+2268A2 - 48 81 C7 40750000 - ADD RDI,00007540
		// Write<uint32>((appBaseAddr + 0x226A03 + 3), (enable) ? newOff : off); // dmc3.exe+226A03 - 48 81 C7 40750000 - ADD RDI,00007540
		Write<uint32>((appBaseAddr + 0x226C92 + 3), (enable) ? newOff : off); // dmc3.exe+226C92 - 49 8D 8E 40750000 - LEA RCX,[R14+00007540]
		// Update Actor Lady
		Write<uint32>((appBaseAddr + 0x2193C2 + 3), (enable) ? newOff : off); // dmc3.exe+2193C2 - 48 8D B5 40750000 - LEA RSI,[RBP+00007540]
		// Update Actor Vergil
		Write<uint32>((appBaseAddr + 0x220F35 + 3), (enable) ? newOff : off); // dmc3.exe+220F35 - 49 81 C6 40750000 - ADD R14,00007540
		Write<uint32>((appBaseAddr + 0x2212C8 + 3), (enable) ? newOff : off); // dmc3.exe+2212C8 - 49 81 C6 40750000 - ADD R14,00007540
		Write<uint32>((appBaseAddr + 0x2216C3 + 3), (enable) ? newOff : off); // dmc3.exe+2216C3 - 49 81 C6 40750000 - ADD R14,00007540
		Write<uint32>((appBaseAddr + 0x22195B + 3), (enable) ? newOff : off); // dmc3.exe+22195B - 49 81 C6 40750000 - ADD R14,00007540
		Write<uint32>((appBaseAddr + 0x221BC4 + 4), (enable) ? newOff : off); // dmc3.exe+221BC4 - 4D 8D B4 24 40750000 - LEA R14,[R12+00007540]
		// Update Model Dante
		Write<uint32>((appBaseAddr + 0x214FAB + 3), (enable) ? newOff : off); // dmc3.exe+214FAB - 4D 8D AE 40750000 - LEA R13,[R14+00007540]
		Write<uint32>((appBaseAddr + 0x2152A1 + 3), (enable) ? newOff : off); // dmc3.exe+2152A1 - 49 8D B6 40750000 - LEA RSI,[R14+00007540]
		// Update Model Vergil
		Write<uint32>((appBaseAddr + 0x22221B + 3), (enable) ? newOff : off); // dmc3.exe+22221B - 4C 8D AD 40750000 - LEA R13,[RBP+00007540]
		Write<uint32>((appBaseAddr + 0x222449 + 3), (enable) ? newOff : off); // dmc3.exe+222449 - 4C 8D AD 40750000 - LEA R13,[RBP+00007540]
		Write<uint32>((appBaseAddr + 0x222702 + 3), (enable) ? newOff : off); // dmc3.exe+222702 - 48 8D B5 40750000 - LEA RSI,[RBP+00007540]
		// func_1DD480
		Write<uint32>((appBaseAddr + 0x1DD4D2 + 3), (enable) ? newOff : off); // dmc3.exe+1DD4D2 - 48 8D 8B 40750000 - LEA RCX,[RBX+00007540]
		// func_1DDE40
		Write<uint32>((appBaseAddr + 0x1DDF1E + 3), (enable) ? newOff : off); // dmc3.exe+1DDF1E - 48 8D 8B 40750000 - LEA RCX,[RBX+00007540]
		// func_1DE160
		Write<uint32>((appBaseAddr + 0x1DE24C + 3), (enable) ? newOff : off); // dmc3.exe+1DE24C - 48 8D 8B 40750000 - LEA RCX,[RBX+00007540]
		// func_211F20
		Write<uint32>((appBaseAddr + 0x211F4D + 3), (enable) ? newOff : off); // dmc3.exe+211F4D - 4C 8D B9 40750000 - LEA R15,[RCX+00007540]
		Write<uint32>((appBaseAddr + 0x211F68 + 3), (enable) ? newOff : off); // dmc3.exe+211F68 - 48 8D 8B 40750000 - LEA RCX,[RBX+00007540]
		// Other
		Write<uint32>((appBaseAddr + 0x1DD642 + 3), (enable) ? newOff : off); // dmc3.exe+1DD642 - 48 8D 8B 40750000 - LEA RCX,[RBX+00007540]
		Write<uint32>((appBaseAddr + 0x1DD7F2 + 3), (enable) ? newOff : off); // dmc3.exe+1DD7F2 - 48 8D 8B 40750000 - LEA RCX,[RBX+00007540]
		Write<uint32>((appBaseAddr + 0x1DD9A2 + 3), (enable) ? newOff : off); // dmc3.exe+1DD9A2 - 48 8D 8B 40750000 - LEA RCX,[RBX+00007540]
		Write<uint32>((appBaseAddr + 0x1DDFF0 + 3), (enable) ? newOff : off); // dmc3.exe+1DDFF0 - 48 8D 8B 40750000 - LEA RCX,[RBX+00007540]
		Write<uint32>((appBaseAddr + 0x1DE126 + 3), (enable) ? newOff : off); // dmc3.exe+1DE126 - 48 8D 8B 40750000 - LEA RCX,[RBX+00007540]
		Write<uint32>((appBaseAddr + 0x21209D + 3), (enable) ? newOff : off); // dmc3.exe+21209D - 48 8D 96 40750000 - LEA RDX,[RSI+00007540]
		Write<uint32>((appBaseAddr + 0x2120CB + 3), (enable) ? newOff : off); // dmc3.exe+2120CB - 48 8D 8E 40750000 - LEA RCX,[RSI+00007540]
		Write<uint32>((appBaseAddr + 0x2120D2 + 3), (enable) ? newOff : off); // dmc3.exe+2120D2 - 48 8B 86 40750000 - MOV RAX,[RSI+00007540]
		Write<uint32>((appBaseAddr + 0x212176 + 3), (enable) ? newOff : off); // dmc3.exe+212176 - 48 8D 96 40750000 - LEA RDX,[RSI+00007540]
		Write<uint32>((appBaseAddr + 0x2121E7 + 3), (enable) ? newOff : off); // dmc3.exe+2121E7 - 48 81 C1 40750000 - ADD RCX,00007540
		Write<uint32>((appBaseAddr + 0x212258 + 3), (enable) ? newOff : off); // dmc3.exe+212258 - 48 8D 96 40750000 - LEA RDX,[RSI+00007540]
		Write<uint32>((appBaseAddr + 0x2122C9 + 3), (enable) ? newOff : off); // dmc3.exe+2122C9 - 48 81 C1 40750000 - ADD RCX,00007540
		Write<uint32>((appBaseAddr + 0x212326 + 3), (enable) ? newOff : off); // dmc3.exe+212326 - 48 8D 96 40750000 - LEA RDX,[RSI+00007540]
		Write<uint32>((appBaseAddr + 0x212397 + 3), (enable) ? newOff : off); // dmc3.exe+212397 - 48 81 C1 40750000 - ADD RCX,00007540
		Write<uint32>((appBaseAddr + 0x212408 + 3), (enable) ? newOff : off); // dmc3.exe+212408 - 48 8D 96 40750000 - LEA RDX,[RSI+00007540]
		Write<uint32>((appBaseAddr + 0x212479 + 3), (enable) ? newOff : off); // dmc3.exe+212479 - 48 81 C1 40750000 - ADD RCX,00007540
		Write<uint32>((appBaseAddr + 0x2124EA + 3), (enable) ? newOff : off); // dmc3.exe+2124EA - 48 8D 96 40750000 - LEA RDX,[RSI+00007540]
		Write<uint32>((appBaseAddr + 0x21255B + 3), (enable) ? newOff : off); // dmc3.exe+21255B - 48 81 C1 40750000 - ADD RCX,00007540
		Write<uint32>((appBaseAddr + 0x2125B5 + 3), (enable) ? newOff : off); // dmc3.exe+2125B5 - 48 8D 96 40750000 - LEA RDX,[RSI+00007540]
		Write<uint32>((appBaseAddr + 0x212626 + 3), (enable) ? newOff : off); // dmc3.exe+212626 - 48 81 C1 40750000 - ADD RCX,00007540
		Write<uint32>((appBaseAddr + 0x2126BD + 3), (enable) ? newOff : off); // dmc3.exe+2126BD - 48 8D 96 40750000 - LEA RDX,[RSI+00007540]
		Write<uint32>((appBaseAddr + 0x21272E + 3), (enable) ? newOff : off); // dmc3.exe+21272E - 48 81 C1 40750000 - ADD RCX,00007540
		Write<uint32>((appBaseAddr + 0x21557C + 3), (enable) ? newOff : off); // dmc3.exe+21557C - 48 81 C7 40750000 - ADD RDI,00007540
		Write<uint32>((appBaseAddr + 0x2166B2 + 3), (enable) ? newOff : off); // dmc3.exe+2166B2 - 48 8D 97 40750000 - LEA RDX,[RDI+00007540]
		Write<uint32>((appBaseAddr + 0x2166EC + 3), (enable) ? newOff : off); // dmc3.exe+2166EC - 48 8D 97 40750000 - LEA RDX,[RDI+00007540]
		Write<uint32>((appBaseAddr + 0x21675C + 3), (enable) ? newOff : off); // dmc3.exe+21675C - 48 8D 97 40750000 - LEA RDX,[RDI+00007540]
		Write<uint32>((appBaseAddr + 0x2167CC + 3), (enable) ? newOff : off); // dmc3.exe+2167CC - 48 8D 97 40750000 - LEA RDX,[RDI+00007540]
		Write<uint32>((appBaseAddr + 0x21683C + 3), (enable) ? newOff : off); // dmc3.exe+21683C - 48 8D 97 40750000 - LEA RDX,[RDI+00007540]
		Write<uint32>((appBaseAddr + 0x2168AC + 3), (enable) ? newOff : off); // dmc3.exe+2168AC - 48 8D 97 40750000 - LEA RDX,[RDI+00007540]
		Write<uint32>((appBaseAddr + 0x21691C + 3), (enable) ? newOff : off); // dmc3.exe+21691C - 48 8D 97 40750000 - LEA RDX,[RDI+00007540]
		Write<uint32>((appBaseAddr + 0x21698C + 3), (enable) ? newOff : off); // dmc3.exe+21698C - 48 8D 97 40750000 - LEA RDX,[RDI+00007540]
		Write<uint32>((appBaseAddr + 0x2189F2 + 3), (enable) ? newOff : off); // dmc3.exe+2189F2 - 48 81 C1 40750000 - ADD RCX,00007540
		Write<uint32>((appBaseAddr + 0x218A55 + 3), (enable) ? newOff : off); // dmc3.exe+218A55 - 48 8D 8F 40750000 - LEA RCX,[RDI+00007540]
		Write<uint32>((appBaseAddr + 0x218A8B + 3), (enable) ? newOff : off); // dmc3.exe+218A8B - 48 81 C1 40750000 - ADD RCX,00007540
		Write<uint32>((appBaseAddr + 0x218AD9 + 3), (enable) ? newOff : off); // dmc3.exe+218AD9 - 48 81 C1 40750000 - ADD RCX,00007540
		Write<uint32>((appBaseAddr + 0x218B21 + 3), (enable) ? newOff : off); // dmc3.exe+218B21 - 48 81 C1 40750000 - ADD RCX,00007540
		Write<uint32>((appBaseAddr + 0x218B8C + 3), (enable) ? newOff : off); // dmc3.exe+218B8C - 48 81 C1 40750000 - ADD RCX,00007540
		Write<uint32>((appBaseAddr + 0x218BD4 + 3), (enable) ? newOff : off); // dmc3.exe+218BD4 - 48 81 C1 40750000 - ADD RCX,00007540
		Write<uint32>((appBaseAddr + 0x218C22 + 3), (enable) ? newOff : off); // dmc3.exe+218C22 - 48 81 C1 40750000 - ADD RCX,00007540
		Write<uint32>((appBaseAddr + 0x218C6A + 3), (enable) ? newOff : off); // dmc3.exe+218C6A - 48 81 C1 40750000 - ADD RCX,00007540
		Write<uint32>((appBaseAddr + 0x218CB8 + 3), (enable) ? newOff : off); // dmc3.exe+218CB8 - 48 81 C1 40750000 - ADD RCX,00007540
		Write<uint32>((appBaseAddr + 0x218D00 + 3), (enable) ? newOff : off); // dmc3.exe+218D00 - 48 81 C1 40750000 - ADD RCX,00007540
		Write<uint32>((appBaseAddr + 0x218D68 + 3), (enable) ? newOff : off); // dmc3.exe+218D68 - 48 81 C1 40750000 - ADD RCX,00007540
		Write<uint32>((appBaseAddr + 0x218DB0 + 3), (enable) ? newOff : off); // dmc3.exe+218DB0 - 48 81 C1 40750000 - ADD RCX,00007540
		Write<uint32>((appBaseAddr + 0x218DFE + 3), (enable) ? newOff : off); // dmc3.exe+218DFE - 48 81 C1 40750000 - ADD RCX,00007540
		Write<uint32>((appBaseAddr + 0x218E46 + 3), (enable) ? newOff : off); // dmc3.exe+218E46 - 48 81 C1 40750000 - ADD RCX,00007540
		Write<uint32>((appBaseAddr + 0x218ED5 + 3), (enable) ? newOff : off); // dmc3.exe+218ED5 - 48 8D 9F 40750000 - LEA RBX,[RDI+00007540]
		Write<uint32>((appBaseAddr + 0x218F3F + 3), (enable) ? newOff : off); // dmc3.exe+218F3F - 48 8D 9F 40750000 - LEA RBX,[RDI+00007540]
		Write<uint32>((appBaseAddr + 0x21914B + 3), (enable) ? newOff : off); // dmc3.exe+21914B - 48 81 C1 40750000 - ADD RCX,00007540
		Write<uint32>((appBaseAddr + 0x2191FE + 3), (enable) ? newOff : off); // dmc3.exe+2191FE - 48 8D 97 40750000 - LEA RDX,[RDI+00007540]
		Write<uint32>((appBaseAddr + 0x219211 + 3), (enable) ? newOff : off); // dmc3.exe+219211 - 48 8D 8F 40750000 - LEA RCX,[RDI+00007540]
		Write<uint32>((appBaseAddr + 0x219218 + 3), (enable) ? newOff : off); // dmc3.exe+219218 - 48 8B 87 40750000 - MOV RAX,[RDI+00007540]
		Write<uint32>((appBaseAddr + 0x219A76 + 3), (enable) ? newOff : off); // dmc3.exe+219A76 - 48 8D B1 40750000 - LEA RSI,[RCX+00007540]
		Write<uint32>((appBaseAddr + 0x219BFC + 3), (enable) ? newOff : off); // dmc3.exe+219BFC - 48 81 C1 40750000 - ADD RCX,00007540
		Write<uint32>((appBaseAddr + 0x2203D7 + 3), (enable) ? newOff : off); // dmc3.exe+2203D7 - 4C 8D B9 40750000 - LEA R15,[RCX+00007540]
		Write<uint32>((appBaseAddr + 0x2203F0 + 3), (enable) ? newOff : off); // dmc3.exe+2203F0 - 48 8D 8B 40750000 - LEA RCX,[RBX+00007540]
		Write<uint32>((appBaseAddr + 0x2204E2 + 3), (enable) ? newOff : off); // dmc3.exe+2204E2 - 48 8D 91 40750000 - LEA RDX,[RCX+00007540]
		Write<uint32>((appBaseAddr + 0x22050D + 3), (enable) ? newOff : off); // dmc3.exe+22050D - 48 8D 8E 40750000 - LEA RCX,[RSI+00007540]
		Write<uint32>((appBaseAddr + 0x220514 + 3), (enable) ? newOff : off); // dmc3.exe+220514 - 48 8B 86 40750000 - MOV RAX,[RSI+00007540]
		Write<uint32>((appBaseAddr + 0x220580 + 3), (enable) ? newOff : off); // dmc3.exe+220580 - 48 8D 96 40750000 - LEA RDX,[RSI+00007540]
		Write<uint32>((appBaseAddr + 0x2205E0 + 3), (enable) ? newOff : off); // dmc3.exe+2205E0 - 48 81 C1 40750000 - ADD RCX,00007540
		Write<uint32>((appBaseAddr + 0x22062F + 3), (enable) ? newOff : off); // dmc3.exe+22062F - 48 8D 96 40750000 - LEA RDX,[RSI+00007540]
		Write<uint32>((appBaseAddr + 0x220691 + 3), (enable) ? newOff : off); // dmc3.exe+220691 - 48 81 C1 40750000 - ADD RCX,00007540
		Write<uint32>((appBaseAddr + 0x2206F9 + 3), (enable) ? newOff : off); // dmc3.exe+2206F9 - 48 8D 96 40750000 - LEA RDX,[RSI+00007540]
		Write<uint32>((appBaseAddr + 0x22076B + 3), (enable) ? newOff : off); // dmc3.exe+22076B - 48 81 C1 40750000 - ADD RCX,00007540
		Write<uint32>((appBaseAddr + 0x220810 + 3), (enable) ? newOff : off); // dmc3.exe+220810 - 48 81 C1 40750000 - ADD RCX,00007540
		Write<uint32>((appBaseAddr + 0x220888 + 3), (enable) ? newOff : off); // dmc3.exe+220888 - 48 81 C1 40750000 - ADD RCX,00007540
		Write<uint32>((appBaseAddr + 0x222861 + 3), (enable) ? newOff : off); // dmc3.exe+222861 - 48 8D B7 40750000 - LEA RSI,[RDI+00007540]
		Write<uint32>((appBaseAddr + 0x22306F + 3), (enable) ? newOff : off); // dmc3.exe+22306F - 48 8D 91 40750000 - LEA RDX,[RCX+00007540]
		Write<uint32>((appBaseAddr + 0x2230B8 + 3), (enable) ? newOff : off); // dmc3.exe+2230B8 - 48 8D 93 40750000 - LEA RDX,[RBX+00007540]
		Write<uint32>((appBaseAddr + 0x2230E7 + 3), (enable) ? newOff : off); // dmc3.exe+2230E7 - 48 8D 8B 40750000 - LEA RCX,[RBX+00007540]
		Write<uint32>((appBaseAddr + 0x2230EE + 3), (enable) ? newOff : off); // dmc3.exe+2230EE - 48 8B 83 40750000 - MOV RAX,[RBX+00007540]
		Write<uint32>((appBaseAddr + 0x22314B + 3), (enable) ? newOff : off); // dmc3.exe+22314B - 48 8D 93 40750000 - LEA RDX,[RBX+00007540]
		Write<uint32>((appBaseAddr + 0x2231BC + 3), (enable) ? newOff : off); // dmc3.exe+2231BC - 48 8D 93 40750000 - LEA RDX,[RBX+00007540]
		Write<uint32>((appBaseAddr + 0x223217 + 3), (enable) ? newOff : off); // dmc3.exe+223217 - 48 81 C1 40750000 - ADD RCX,00007540
		Write<uint32>((appBaseAddr + 0x223276 + 3), (enable) ? newOff : off); // dmc3.exe+223276 - 48 8D 93 40750000 - LEA RDX,[RBX+00007540]
		Write<uint32>((appBaseAddr + 0x2232C4 + 3), (enable) ? newOff : off); // dmc3.exe+2232C4 - 48 8D 93 40750000 - LEA RDX,[RBX+00007540]
		Write<uint32>((appBaseAddr + 0x223329 + 3), (enable) ? newOff : off); // dmc3.exe+223329 - 48 81 C1 40750000 - ADD RCX,00007540
		Write<uint32>((appBaseAddr + 0x22338D + 3), (enable) ? newOff : off); // dmc3.exe+22338D - 48 8D 93 40750000 - LEA RDX,[RBX+00007540]
		Write<uint32>((appBaseAddr + 0x2233E5 + 3), (enable) ? newOff : off); // dmc3.exe+2233E5 - 48 81 C1 40750000 - ADD RCX,00007540
		Write<uint32>((appBaseAddr + 0x223780 + 3), (enable) ? newOff : off); // dmc3.exe+223780 - 48 81 C1 40750000 - ADD RCX,00007540
		Write<uint32>((appBaseAddr + 0x2237DF + 3), (enable) ? newOff : off); // dmc3.exe+2237DF - 48 8D B1 40750000 - LEA RSI,[RCX+00007540]
		Write<uint32>((appBaseAddr + 0x2238C3 + 3), (enable) ? newOff : off); // dmc3.exe+2238C3 - 48 8D B5 40750000 - LEA RSI,[RBP+00007540]
		Write<uint32>((appBaseAddr + 0x223919 + 3), (enable) ? newOff : off); // dmc3.exe+223919 - 48 8D B5 40750000 - LEA RSI,[RBP+00007540]
		Write<uint32>((appBaseAddr + 0x22397A + 3), (enable) ? newOff : off); // dmc3.exe+22397A - 48 8D B5 40750000 - LEA RSI,[RBP+00007540]
		Write<uint32>((appBaseAddr + 0x2239DF + 3), (enable) ? newOff : off); // dmc3.exe+2239DF - 48 8D B5 40750000 - LEA RSI,[RBP+00007540]
		Write<uint32>((appBaseAddr + 0x223A46 + 3), (enable) ? newOff : off); // dmc3.exe+223A46 - 48 8D B5 40750000 - LEA RSI,[RBP+00007540]
		Write<uint32>((appBaseAddr + 0x2243CA + 3), (enable) ? newOff : off); // dmc3.exe+2243CA - 48 8D BB 40750000 - LEA RDI,[RBX+00007540]
		Write<uint32>((appBaseAddr + 0x2244D7 + 3), (enable) ? newOff : off); // dmc3.exe+2244D7 - 48 81 C1 40750000 - ADD RCX,00007540
		Write<uint32>((appBaseAddr + 0x22451B + 3), (enable) ? newOff : off); // dmc3.exe+22451B - 48 81 C1 40750000 - ADD RCX,00007540
		Write<uint32>((appBaseAddr + 0x22456E + 3), (enable) ? newOff : off); // dmc3.exe+22456E - 48 81 C1 40750000 - ADD RCX,00007540
		Write<uint32>((appBaseAddr + 0x2245B2 + 3), (enable) ? newOff : off); // dmc3.exe+2245B2 - 48 81 C1 40750000 - ADD RCX,00007540
		Write<uint32>((appBaseAddr + 0x2245F9 + 3), (enable) ? newOff : off); // dmc3.exe+2245F9 - 48 81 C1 40750000 - ADD RCX,00007540
		Write<uint32>((appBaseAddr + 0x22463F + 3), (enable) ? newOff : off); // dmc3.exe+22463F - 48 81 C1 40750000 - ADD RCX,00007540
		Write<uint32>((appBaseAddr + 0x22468B + 3), (enable) ? newOff : off); // dmc3.exe+22468B - 48 81 C1 40750000 - ADD RCX,00007540
		Write<uint32>((appBaseAddr + 0x2246D1 + 3), (enable) ? newOff : off); // dmc3.exe+2246D1 - 48 81 C1 40750000 - ADD RCX,00007540
		Write<uint32>((appBaseAddr + 0x22472C + 3), (enable) ? newOff : off); // dmc3.exe+22472C - 48 81 C1 40750000 - ADD RCX,00007540
		Write<uint32>((appBaseAddr + 0x224770 + 3), (enable) ? newOff : off); // dmc3.exe+224770 - 48 81 C1 40750000 - ADD RCX,00007540
		Write<uint32>((appBaseAddr + 0x2259A0 + 3), (enable) ? newOff : off); // dmc3.exe+2259A0 - 48 8D B1 40750000 - LEA RSI,[RCX+00007540]
		Write<uint32>((appBaseAddr + 0x2259AF + 3), (enable) ? newOff : off); // dmc3.exe+2259AF - 48 8D 8D 40750000 - LEA RCX,[RBP+00007540]
		Write<uint32>((appBaseAddr + 0x225A4E + 3), (enable) ? newOff : off); // dmc3.exe+225A4E - 48 8D 93 40750000 - LEA RDX,[RBX+00007540]
		Write<uint32>((appBaseAddr + 0x225A78 + 3), (enable) ? newOff : off); // dmc3.exe+225A78 - 48 8D 8B 40750000 - LEA RCX,[RBX+00007540]
		Write<uint32>((appBaseAddr + 0x225A7F + 3), (enable) ? newOff : off); // dmc3.exe+225A7F - 48 8B 83 40750000 - MOV RAX,[RBX+00007540]
		Write<uint32>((appBaseAddr + 0x225BB8 + 3), (enable) ? newOff : off); // dmc3.exe+225BB8 - 48 8D 93 40750000 - LEA RDX,[RBX+00007540]
		Write<uint32>((appBaseAddr + 0x225C2A + 3), (enable) ? newOff : off); // dmc3.exe+225C2A - 48 81 C1 40750000 - ADD RCX,00007540
		Write<uint32>((appBaseAddr + 0x225CCF + 3), (enable) ? newOff : off); // dmc3.exe+225CCF - 48 81 C1 40750000 - ADD RCX,00007540
		Write<uint32>((appBaseAddr + 0x225D3B + 3), (enable) ? newOff : off); // dmc3.exe+225D3B - 48 81 C1 40750000 - ADD RCX,00007540
		Write<uint32>((appBaseAddr + 0x226D9F + 3), (enable) ? newOff : off); // dmc3.exe+226D9F - 48 8D 91 40750000 - LEA RDX,[RCX+00007540]
		Write<uint32>((appBaseAddr + 0x226DE9 + 3), (enable) ? newOff : off); // dmc3.exe+226DE9 - 48 8D 93 40750000 - LEA RDX,[RBX+00007540]
		Write<uint32>((appBaseAddr + 0x226E56 + 3), (enable) ? newOff : off); // dmc3.exe+226E56 - 48 8D 93 40750000 - LEA RDX,[RBX+00007540]
		Write<uint32>((appBaseAddr + 0x2272D8 + 3), (enable) ? newOff : off); // dmc3.exe+2272D8 - 48 81 C1 40750000 - ADD RCX,00007540
		Write<uint32>((appBaseAddr + 0x227370 + 3), (enable) ? newOff : off); // dmc3.exe+227370 - 48 81 C1 40750000 - ADD RCX,00007540
		Write<uint32>((appBaseAddr + 0x2273A8 + 3), (enable) ? newOff : off); // dmc3.exe+2273A8 - 48 81 C1 40750000 - ADD RCX,00007540
		// Unknown
		// Write<uint32>((appBaseAddr + 0x180ABD + 3), (enable) ? newOff : off); // dmc3.exe+180ABD - 48 8D 8F 40750000 - LEA RCX,[RDI+00007540]
		// Write<uint32>((appBaseAddr + 0x225AEE + 3), (enable) ? newOff : off); // dmc3.exe+225AEE - 48 8D 93 40750000 - LEA RDX,[RBX+00007540]
		// Write<uint32>((appBaseAddr + 0x225B50 + 3), (enable) ? newOff : off); // dmc3.exe+225B50 - 48 81 C1 40750000 - ADD RCX,00007540
		// Write<uint32>((appBaseAddr + 0x226EC3 + 3), (enable) ? newOff : off); // dmc3.exe+226EC3 - 48 8D 93 40750000 - LEA RDX,[RBX+00007540]
	}
	// 0x7548
	{
		constexpr auto off = (__builtin_offsetof(ActorData, submodelData[0]) + 8);
		constexpr auto newOff = (__builtin_offsetof(ActorData, newSubmodelData[0]) + 8);
		static_assert(off == 0x7548);
		// Update Actor Vergil
		Write<uint32>((appBaseAddr + 0x221D07 + 3), (enable) ? newOff : off); // dmc3.exe+221D07 - 48 81 C7 48750000 - add rdi,00007548
	}
	// 0x9AC0
	{
		constexpr auto off = __builtin_offsetof(ActorData, submodelInit[0]) ;
		constexpr auto newOff = __builtin_offsetof(ActorData, newSubmodelInit[0]) ;
		static_assert(off == 0x9AC0);
		// Update Actor Dante
		Write<uint32>((appBaseAddr + 0x212C0D + 3), (enable) ? newOff : off); // dmc3.exe+212C0D - 44 89 B9 C09A0000 - MOV [RCX+00009AC0],R15D
		Write<uint32>((appBaseAddr + 0x21338B + 4), (enable) ? newOff : off); // dmc3.exe+21338B - 42 C6 84 2E C09A0000 01 - MOV BYTE PTR [RSI+R13+00009AC0],01
		Write<uint32>((appBaseAddr + 0x213709 + 3), (enable) ? newOff : off); // dmc3.exe+213709 - C6 84 37 C09A0000 01 - MOV BYTE PTR [RDI+RSI+00009AC0],01
		Write<uint32>((appBaseAddr + 0x213B1D + 3), (enable) ? newOff : off); // dmc3.exe+213B1D - C6 84 37 C09A0000 01 - MOV BYTE PTR [RDI+RSI+00009AC0],01
		Write<uint32>((appBaseAddr + 0x213D9E + 4), (enable) ? newOff : off); // dmc3.exe+213D9E - 41 C6 84 36 C09A0000 01 - MOV BYTE PTR [R14+RSI+00009AC0],01
		Write<uint32>((appBaseAddr + 0x214315 + 4), (enable) ? newOff : off); // dmc3.exe+214315 - 42 C6 84 2E C09A0000 01 - MOV BYTE PTR [RSI+R13+00009AC0],01
		Write<uint32>((appBaseAddr + 0x2146FC + 4), (enable) ? newOff : off); // dmc3.exe+2146FC - 42 C6 84 2E C09A0000 01 - MOV BYTE PTR [RSI+R13+00009AC0],01
		Write<uint32>((appBaseAddr + 0x214978 + 4), (enable) ? newOff : off); // dmc3.exe+214978 - 42 C6 84 36 C09A0000 01 - MOV BYTE PTR [RSI+R14+00009AC0],01
		// Update Actor Bob
		Write<uint32>((appBaseAddr + 0x225D8A + 2), (enable) ? newOff : off); // dmc3.exe+225D8A - C7 81 C09A0000 00000000 - MOV [RCX+00009AC0],00000000
		Write<uint32>((appBaseAddr + 0x226107 + 3), (enable) ? newOff : off); // dmc3.exe+226107 - 41 C6 86 C09A0000 01 - MOV BYTE PTR [R14+00009AC0],01
		Write<uint32>((appBaseAddr + 0x2264D6 + 4), (enable) ? newOff : off); // dmc3.exe+2264D6 - 42 C6 84 36 C09A0000 01 - MOV BYTE PTR [RSI+R14+00009AC0],01
		Write<uint32>((appBaseAddr + 0x2266EB + 4), (enable) ? newOff : off); // dmc3.exe+2266EB - 43 C6 84 34 C09A0000 01 - MOV BYTE PTR [R12+R14+00009AC0],01
		Write<uint32>((appBaseAddr + 0x2268F7 + 4), (enable) ? newOff : off); // dmc3.exe+2268F7 - 43 C6 84 34 C09A0000 01 - MOV BYTE PTR [R12+R14+00009AC0],01
		// Write<uint32>((appBaseAddr + 0x226A43 + 4), (enable) ? newOff : off); // dmc3.exe+226A43 - 42 C6 84 36 C09A0000 01 - MOV BYTE PTR [RSI+R14+00009AC0],01
		// Update Actor Vergil
		Write<uint32>((appBaseAddr + 0x22098E + 3), (enable) ? newOff : off); // dmc3.exe+22098E - 44 89 B1 C09A0000 - MOV [RCX+00009AC0],R14D
		Write<uint32>((appBaseAddr + 0x22116B + 4), (enable) ? newOff : off); // dmc3.exe+22116B - 42 88 9C 20 C09A0000 - MOV [RAX+R12+00009AC0],BL
		Write<uint32>((appBaseAddr + 0x22136C + 4), (enable) ? newOff : off); // dmc3.exe+22136C - 43 C6 84 27 C09A0000 01 - MOV BYTE PTR [R15+R12+00009AC0],01
		Write<uint32>((appBaseAddr + 0x221770 + 4), (enable) ? newOff : off); // dmc3.exe+221770 - 43 C6 84 27 C09A0000 01 - MOV BYTE PTR [R15+R12+00009AC0],01
		Write<uint32>((appBaseAddr + 0x221A0A + 4), (enable) ? newOff : off); // dmc3.exe+221A0A - 42 C6 84 25 C09A0000 01 - MOV BYTE PTR [RBP+R12+00009AC0],01
		Write<uint32>((appBaseAddr + 0x221DF9 + 4), (enable) ? newOff : off); // dmc3.exe+221DF9 - 42 C6 84 25 C09A0000 01 - MOV BYTE PTR [RBP+R12+00009AC0],01
		// Update Model Dante
		Write<uint32>((appBaseAddr + 0x214FE3 + 3), (enable) ? newOff : off); // dmc3.exe+214FE3 - 41 C6 86 C09A0000 01 - MOV BYTE PTR [R14+00009AC0],01
		Write<uint32>((appBaseAddr + 0x2152D6 + 3), (enable) ? newOff : off); // dmc3.exe+2152D6 - 41 C6 86 C09A0000 01 - MOV BYTE PTR [R14+00009AC0],01
		// Update Model Vergil
		Write<uint32>((appBaseAddr + 0x222253 + 2), (enable) ? newOff : off); // dmc3.exe+222253 - C6 85 C09A0000 01 - MOV BYTE PTR [RBP+00009AC0],01
		Write<uint32>((appBaseAddr + 0x222481 + 2), (enable) ? newOff : off); // dmc3.exe+222481 - C6 85 C09A0000 01 - MOV BYTE PTR [RBP+00009AC0],01
		Write<uint32>((appBaseAddr + 0x222737 + 2), (enable) ? newOff : off); // dmc3.exe+222737 - C6 85 C09A0000 01 - MOV BYTE PTR [RBP+00009AC0],01
		// func_211F20
		Write<uint32>((appBaseAddr + 0x211F3A + 3), (enable) ? newOff : off); // dmc3.exe+211F3A - 48 8D B9 C09A0000 - LEA RDI,[RCX+00009AC0]
		// Other
		Write<uint32>((appBaseAddr + 0x2203BD + 3), (enable) ? newOff : off); // dmc3.exe+2203BD - 48 8D B1 C09A0000 - LEA RSI,[RCX+00009AC0]
		Write<uint32>((appBaseAddr + 0x225997 + 3), (enable) ? newOff : off); // dmc3.exe+225997 - 48 8D 99 C09A0000 - LEA RBX,[RCX+00009AC0]
	}
	// 0x9AC4
	{
		constexpr auto off = __builtin_offsetof(ActorData, submodelInit[4]) ;
		constexpr auto newOff = __builtin_offsetof(ActorData, newSubmodelInit[4]) ;
		static_assert(off == 0x9AC4);
		// Update Actor Dante
		Write<uint32>((appBaseAddr + 0x212C14 + 3), (enable) ? newOff : off); // dmc3.exe+212C14 - 44 88 B9 C49A0000 - MOV [RCX+00009AC4],R15L
		// Update Actor Bob
		Write<uint32>((appBaseAddr + 0x225D97 + 2), (enable) ? newOff : off); // dmc3.exe+225D97 - C6 81 C49A0000 00 - MOV BYTE PTR [RCX+00009AC4],00
		// Update Actor Vergil
		Write<uint32>((appBaseAddr + 0x220997 + 3), (enable) ? newOff : off); // dmc3.exe+220997 - 44 88 B1 C49A0000 - MOV [RCX+00009AC4],R14L
	}
	// 0x9AC8
	{
		constexpr auto off = __builtin_offsetof(ActorData, submodelInit[8]) ;
		constexpr auto newOff = __builtin_offsetof(ActorData, newSubmodelInit[8]) ;
		static_assert(off == 0x9AC8);
		// Update Actor Bob
		Write<uint32>((appBaseAddr + 0x226318 + 3), (enable) ? newOff : off); // dmc3.exe+226318 - 49 89 B6 C89A0000 - MOV [R14+00009AC8],RSI
		// Update Actor Vergil
		Write<uint32>((appBaseAddr + 0x220CC4 + 4), (enable) ? newOff : off); // dmc3.exe+220CC4 - 4D 89 B4 24 C89A0000 - MOV [R12+00009AC8],R14
	}
	// 0x9AD0
	{
		constexpr auto off = __builtin_offsetof(ActorDataDante, modelShadowData[0]) ;
		constexpr auto newOff = __builtin_offsetof(ActorDataDante, newModelShadowData[0]) ;
		static_assert(off == 0x9AD0);
		// Update Actor Dante
		Write<uint32>((appBaseAddr + 0x213262 + 4), (enable) ? newOff : off); // dmc3.exe+213262 - 48 8B BC 33 D09A0000 - MOV RDI,[RBX+RSI+00009AD0]
		Write<uint32>((appBaseAddr + 0x21326D + 3), (enable) ? newOff : off); // dmc3.exe+21326D - 48 8D 8E D09A0000 - LEA RCX,[RSI+00009AD0]
		Write<uint32>((appBaseAddr + 0x21365C + 4), (enable) ? newOff : off); // dmc3.exe+21365C - 48 8B BC 33 D09A0000 - MOV RDI,[RBX+RSI+00009AD0]
		Write<uint32>((appBaseAddr + 0x213667 + 3), (enable) ? newOff : off); // dmc3.exe+213667 - 48 8D 8E D09A0000 - LEA RCX,[RSI+00009AD0]
		Write<uint32>((appBaseAddr + 0x213A6A + 4), (enable) ? newOff : off); // dmc3.exe+213A6A - 48 8B BC 33 D09A0000 - MOV RDI,[RBX+RSI+00009AD0]
		Write<uint32>((appBaseAddr + 0x213A75 + 3), (enable) ? newOff : off); // dmc3.exe+213A75 - 48 8D 8E D09A0000 - LEA RCX,[RSI+00009AD0]
		Write<uint32>((appBaseAddr + 0x2140CD + 4), (enable) ? newOff : off); // dmc3.exe+2140CD - 48 8B BC 33 D09A0000 - MOV RDI,[RBX+RSI+00009AD0]
		Write<uint32>((appBaseAddr + 0x2140DD + 3), (enable) ? newOff : off); // dmc3.exe+2140DD - 48 8D 8E D09A0000 - LEA RCX,[RSI+00009AD0]
		Write<uint32>((appBaseAddr + 0x2141ED + 4), (enable) ? newOff : off); // dmc3.exe+2141ED - 48 8B BC 33 D09A0000 - MOV RDI,[RBX+RSI+00009AD0]
		Write<uint32>((appBaseAddr + 0x2141F8 + 3), (enable) ? newOff : off); // dmc3.exe+2141F8 - 48 8D 8E D09A0000 - LEA RCX,[RSI+00009AD0]
		Write<uint32>((appBaseAddr + 0x2145DC + 4), (enable) ? newOff : off); // dmc3.exe+2145DC - 48 8B BC 33 D09A0000 - MOV RDI,[RBX+RSI+00009AD0]
		Write<uint32>((appBaseAddr + 0x2145E7 + 3), (enable) ? newOff : off); // dmc3.exe+2145E7 - 48 8D 8E D09A0000 - LEA RCX,[RSI+00009AD0]
		// Update Actor Bob
		// Write<uint32>((appBaseAddr + 0x22631F + 3), (enable) ? newOff : off); // dmc3.exe+22631F - 49 89 B6 D09A0000 - MOV [R14+00009AD0],RSI - Ignore!
		// Update Actor Vergil
		// Write<uint32>((appBaseAddr + 0x220CCF + 4), (enable) ? newOff : off); // dmc3.exe+220CCF - 4D 89 B4 24 D09A0000 - MOV [R12+00009AD0],R14 - Ignore!
		// Update Model Dante
		Write<uint32>((appBaseAddr + 0x214DED + 3), (enable) ? newOff : off); // dmc3.exe+214DED - 49 8B BE D09A0000 - MOV RDI,[R14+00009AD0]
		Write<uint32>((appBaseAddr + 0x214DFA + 3), (enable) ? newOff : off); // dmc3.exe+214DFA - 49 8D 8E D09A0000 - LEA RCX,[R14+00009AD0]
		// func_1DD480
		Write<uint32>((appBaseAddr + 0x1DD4FD + 3), (enable) ? newOff : off); // dmc3.exe+1DD4FD - 48 8D 8B D09A0000 - LEA RCX,[RBX+00009AD0]
		// func_1DDE40
		Write<uint32>((appBaseAddr + 0x1DDEFF + 3), (enable) ? newOff : off); // dmc3.exe+1DDEFF - 48 8D 8B D09A0000 - LEA RCX,[RBX+00009AD0]
		// func_211F20
		Write<uint32>((appBaseAddr + 0x211FC7 + 3), (enable) ? newOff : off); // dmc3.exe+211FC7 - 48 8D B3 D09A0000 - LEA RSI,[RBX+00009AD0]
		Write<uint32>((appBaseAddr + 0x211FF8 + 3), (enable) ? newOff : off); // dmc3.exe+211FF8 - 48 81 C1 D09A0000 - ADD RCX,00009AD0
		// Other
		Write<uint32>((appBaseAddr + 0x218999 + 3), (enable) ? newOff : off); // dmc3.exe+218999 - 48 81 C1 D09A0000 - ADD RCX,00009AD0
		Write<uint32>((appBaseAddr + 0x218EAC + 3), (enable) ? newOff : off); // dmc3.exe+218EAC - 48 8D 8F D09A0000 - LEA RCX,[RDI+00009AD0]
	}
	// 0x9AF0
	{
		constexpr auto off = __builtin_offsetof(ActorDataVergil, modelShadowData[0]) ;
		constexpr auto newOff = __builtin_offsetof(ActorDataVergil, newModelShadowData[0]) ;
		static_assert(off == 0x9AF0);
		// Update Actor Vergil
		Write<uint32>((appBaseAddr + 0x220ED2 + 4), (enable) ? newOff : off); // dmc3.exe+220ED2 - 4A 8B BC 23 F09A0000 - MOV RDI,[RBX+R12+00009AF0]
		Write<uint32>((appBaseAddr + 0x220EDD + 3), (enable) ? newOff : off); // dmc3.exe+220EDD - 48 8D 8B F09A0000 - LEA RCX,[RBX+00009AF0]
		Write<uint32>((appBaseAddr + 0x221262 + 4), (enable) ? newOff : off); // dmc3.exe+221262 - 4A 8B BC 23 F09A0000 - MOV RDI,[RBX+R12+00009AF0]
		Write<uint32>((appBaseAddr + 0x22126D + 3), (enable) ? newOff : off); // dmc3.exe+22126D - 48 8D 8B F09A0000 - LEA RCX,[RBX+00009AF0]
		Write<uint32>((appBaseAddr + 0x221663 + 4), (enable) ? newOff : off); // dmc3.exe+221663 - 4A 8B BC 23 F09A0000 - MOV RDI,[RBX+R12+00009AF0]
		Write<uint32>((appBaseAddr + 0x22166E + 3), (enable) ? newOff : off); // dmc3.exe+22166E - 48 8D 8B F09A0000 - LEA RCX,[RBX+00009AF0]
		// Update Model Vergil
		Write<uint32>((appBaseAddr + 0x222073 + 3), (enable) ? newOff : off); // dmc3.exe+222073 - 48 8B B5 F09A0000 - MOV RSI,[RBP+00009AF0]
		Write<uint32>((appBaseAddr + 0x222083 + 3), (enable) ? newOff : off); // dmc3.exe+222083 - 48 8D 8D F09A0000 - LEA RCX,[RBP+00009AF0]
		// func_1DE160
		Write<uint32>((appBaseAddr + 0x1DE22D + 3), (enable) ? newOff : off); // dmc3.exe+1DE22D - 48 8D 8B F09A0000 - LEA RCX,[RBX+00009AF0]
		// Other
		Write<uint32>((appBaseAddr + 0x1DD81D + 3), (enable) ? newOff : off); // dmc3.exe+1DD81D - 48 8D 8B F09A0000 - LEA RCX,[RBX+00009AF0]
		Write<uint32>((appBaseAddr + 0x1DD9CD + 3), (enable) ? newOff : off); // dmc3.exe+1DD9CD - 48 8D 8B F09A0000 - LEA RCX,[RBX+00009AF0]
		Write<uint32>((appBaseAddr + 0x1DE107 + 3), (enable) ? newOff : off); // dmc3.exe+1DE107 - 48 8D 8B F09A0000 - LEA RCX,[RBX+00009AF0]
		Write<uint32>((appBaseAddr + 0x22045C + 3), (enable) ? newOff : off); // dmc3.exe+22045C - 48 8D B3 F09A0000 - LEA RSI,[RBX+00009AF0]
		Write<uint32>((appBaseAddr + 0x22048A + 3), (enable) ? newOff : off); // dmc3.exe+22048A - 48 81 C1 F09A0000 - ADD RCX,00009AF0
		Write<uint32>((appBaseAddr + 0x2243B1 + 3), (enable) ? newOff : off); // dmc3.exe+2243B1 - 48 81 C1 F09A0000 - ADD RCX,00009AF0
		Write<uint32>((appBaseAddr + 0x224491 + 3), (enable) ? newOff : off); // dmc3.exe+224491 - 48 81 C1 F09A0000 - ADD RCX,00009AF0
	}
	// 0x9D10
	{
		constexpr auto off = __builtin_offsetof(ActorDataDante, submodelShadowData[0]) ;
		constexpr auto newOff = __builtin_offsetof(ActorDataDante, newSubmodelShadowData[0]) ;
		static_assert(off == 0x9D10);
		// Update Actor Dante
		Write<uint32>((appBaseAddr + 0x21335B + 4), (enable) ? newOff : off); // dmc3.exe+21335B - 48 8B BC 33 109D0000 - MOV RDI,[RBX+RSI+00009D10]
		Write<uint32>((appBaseAddr + 0x21336B + 3), (enable) ? newOff : off); // dmc3.exe+21336B - 48 8D 8E 109D0000 - LEA RCX,[RSI+00009D10]
		Write<uint32>((appBaseAddr + 0x213931 + 4), (enable) ? newOff : off); // dmc3.exe+213931 - 48 8B BC 33 109D0000 - MOV RDI,[RBX+RSI+00009D10]
		Write<uint32>((appBaseAddr + 0x21393C + 3), (enable) ? newOff : off); // dmc3.exe+21393C - 48 8D 8E 109D0000 - LEA RCX,[RSI+00009D10]
		Write<uint32>((appBaseAddr + 0x213CD8 + 4), (enable) ? newOff : off); // dmc3.exe+213CD8 - 48 8B BC 33 109D0000 - MOV RDI,[RBX+RSI+00009D10]
		Write<uint32>((appBaseAddr + 0x213CE3 + 3), (enable) ? newOff : off); // dmc3.exe+213CE3 - 48 8D 8E 109D0000 - LEA RCX,[RSI+00009D10]
		Write<uint32>((appBaseAddr + 0x213F8F + 4), (enable) ? newOff : off); // dmc3.exe+213F8F - 48 8B BC 33 109D0000 - MOV RDI,[RBX+RSI+00009D10]
		Write<uint32>((appBaseAddr + 0x213F9A + 3), (enable) ? newOff : off); // dmc3.exe+213F9A - 48 8D 8E 109D0000 - LEA RCX,[RSI+00009D10]
		Write<uint32>((appBaseAddr + 0x2142E5 + 4), (enable) ? newOff : off); // dmc3.exe+2142E5 - 48 8B BC 33 109D0000 - MOV RDI,[RBX+RSI+00009D10]
		Write<uint32>((appBaseAddr + 0x2142F5 + 3), (enable) ? newOff : off); // dmc3.exe+2142F5 - 48 8D 8E 109D0000 - LEA RCX,[RSI+00009D10]
		Write<uint32>((appBaseAddr + 0x2146CC + 4), (enable) ? newOff : off); // dmc3.exe+2146CC - 48 8B BC 33 109D0000 - MOV RDI,[RBX+RSI+00009D10]
		Write<uint32>((appBaseAddr + 0x2146DC + 3), (enable) ? newOff : off); // dmc3.exe+2146DC - 48 8D 8E 109D0000 - LEA RCX,[RSI+00009D10]
		Write<uint32>((appBaseAddr + 0x214948 + 4), (enable) ? newOff : off); // dmc3.exe+214948 - 48 8B BC 33 109D0000 - MOV RDI,[RBX+RSI+00009D10]
		Write<uint32>((appBaseAddr + 0x214958 + 3), (enable) ? newOff : off); // dmc3.exe+214958 - 48 8D 8E 109D0000 - LEA RCX,[RSI+00009D10]
		// Update Model Dante
		Write<uint32>((appBaseAddr + 0x21522A + 3), (enable) ? newOff : off); // dmc3.exe+21522A - 49 8B BE 109D0000 - MOV RDI,[R14+00009D10]
		Write<uint32>((appBaseAddr + 0x215237 + 3), (enable) ? newOff : off); // dmc3.exe+215237 - 49 8D 8E 109D0000 - LEA RCX,[R14+00009D10]
		// func_1DD480
		Write<uint32>((appBaseAddr + 0x1DD528 + 3), (enable) ? newOff : off); // dmc3.exe+1DD528 - 48 8D 8B 109D0000 - LEA RCX,[RBX+00009D10]
		// func_1DDE40
		Write<uint32>((appBaseAddr + 0x1DDEE0 + 3), (enable) ? newOff : off); // dmc3.exe+1DDEE0 - 48 8D 8B 109D0000 - LEA RCX,[RBX+00009D10]
		// func_211F20
		Write<uint32>((appBaseAddr + 0x211F46 + 3), (enable) ? newOff : off); // dmc3.exe+211F46 - 4C 8D B1 109D0000 - LEA R14,[RCX+00009D10]
		Write<uint32>((appBaseAddr + 0x211F9D + 3), (enable) ? newOff : off); // dmc3.exe+211F9D - 48 8D 8B 109D0000 - LEA RCX,[RBX+00009D10]
		// Other
		Write<uint32>((appBaseAddr + 0x218E88 + 3), (enable) ? newOff : off); // dmc3.exe+218E88 - 48 81 C1 109D0000 - ADD RCX,00009D10
		Write<uint32>((appBaseAddr + 0x218F20 + 3), (enable) ? newOff : off); // dmc3.exe+218F20 - 48 8D 8F 109D0000 - LEA RCX,[RDI+00009D10]
	}
	// 0x9D30
	{
		constexpr auto off = __builtin_offsetof(ActorDataVergil, submodelShadowData[0]) ;
		constexpr auto newOff = __builtin_offsetof(ActorDataVergil, newSubmodelShadowData[0]) ;
		static_assert(off == 0x9D30);
		// Update Actor Vergil
		Write<uint32>((appBaseAddr + 0x220FB4 + 4), (enable) ? newOff : off); // dmc3.exe+220FB4 - 4A 8B BC 23 309D0000 - MOV RDI,[RBX+R12+00009D30]
		Write<uint32>((appBaseAddr + 0x220FBF + 4), (enable) ? newOff : off); // dmc3.exe+220FBF - 49 8D 8C 24 309D0000 - LEA RCX,[R12+00009D30]
		Write<uint32>((appBaseAddr + 0x22133E + 4), (enable) ? newOff : off); // dmc3.exe+22133E - 4A 8B BC 23 309D0000 - MOV RDI,[RBX+R12+00009D30]
		Write<uint32>((appBaseAddr + 0x221349 + 3), (enable) ? newOff : off); // dmc3.exe+221349 - 48 8D 8B 309D0000 - LEA RCX,[RBX+00009D30]
		Write<uint32>((appBaseAddr + 0x221741 + 4), (enable) ? newOff : off); // dmc3.exe+221741 - 4A 8B BC 23 309D0000 - MOV RDI,[RBX+R12+00009D30]
		Write<uint32>((appBaseAddr + 0x22174C + 4), (enable) ? newOff : off); // dmc3.exe+22174C - 49 8D 8C 24 309D0000 - LEA RCX,[R12+00009D30]
		Write<uint32>((appBaseAddr + 0x2219DB + 4), (enable) ? newOff : off); // dmc3.exe+2219DB - 4A 8B BC 23 309D0000 - MOV RDI,[RBX+R12+00009D30]
		Write<uint32>((appBaseAddr + 0x2219E6 + 4), (enable) ? newOff : off); // dmc3.exe+2219E6 - 49 8D 8C 24 309D0000 - LEA RCX,[R12+00009D30]
		Write<uint32>((appBaseAddr + 0x221DAD + 4), (enable) ? newOff : off); // dmc3.exe+221DAD - 4A 8B BC 23 309D0000 - MOV RDI,[RBX+R12+00009D30]
		Write<uint32>((appBaseAddr + 0x221DB8 + 4), (enable) ? newOff : off); // dmc3.exe+221DB8 - 49 8D 8C 24 309D0000 - LEA RCX,[R12+00009D30]
		// Update Model Vergil
		Write<uint32>((appBaseAddr + 0x222698 + 3), (enable) ? newOff : off); // dmc3.exe+222698 - 48 8B B5 309D0000 - MOV RSI,[RBP+00009D30]
		Write<uint32>((appBaseAddr + 0x2226A8 + 3), (enable) ? newOff : off); // dmc3.exe+2226A8 - 48 8D 8D 309D0000 - LEA RCX,[RBP+00009D30]
		// func_1DE160
		Write<uint32>((appBaseAddr + 0x1DE20E + 3), (enable) ? newOff : off); // dmc3.exe+1DE20E - 48 8D 8B 309D0000 - LEA RCX,[RBX+00009D30]
		// Other
		Write<uint32>((appBaseAddr + 0x1DD848 + 3), (enable) ? newOff : off); // dmc3.exe+1DD848 - 48 8D 8B 309D0000 - LEA RCX,[RBX+00009D30]
		Write<uint32>((appBaseAddr + 0x1DD9F8 + 3), (enable) ? newOff : off); // dmc3.exe+1DD9F8 - 48 8D 8B 309D0000 - LEA RCX,[RBX+00009D30]
		Write<uint32>((appBaseAddr + 0x1DE0E8 + 3), (enable) ? newOff : off); // dmc3.exe+1DE0E8 - 48 8D 8B 309D0000 - LEA RCX,[RBX+00009D30]
		Write<uint32>((appBaseAddr + 0x2203D0 + 3), (enable) ? newOff : off); // dmc3.exe+2203D0 - 4C 8D B1 309D0000 - LEA R14,[RCX+00009D30]
		Write<uint32>((appBaseAddr + 0x220425 + 3), (enable) ? newOff : off); // dmc3.exe+220425 - 48 8D 8B 309D0000 - LEA RCX,[RBX+00009D30]
		Write<uint32>((appBaseAddr + 0x22441E + 3), (enable) ? newOff : off); // dmc3.exe+22441E - 48 8D 8B 309D0000 - LEA RCX,[RBX+00009D30]
		Write<uint32>((appBaseAddr + 0x22454A + 3), (enable) ? newOff : off); // dmc3.exe+22454A - 48 81 C1 309D0000 - ADD RCX,00009D30
		Write<uint32>((appBaseAddr + 0x22470E + 3), (enable) ? newOff : off); // dmc3.exe+22470E - 48 81 C1 309D0000 - ADD RCX,00009D30
	}
	// 0xA300
	{
		constexpr auto off = __builtin_offsetof(ActorDataDante, devilModelPhysicsMetadataPool[0][0]) ;
		constexpr auto newOff = __builtin_offsetof(ActorDataDante, newDevilModelPhysicsMetadataPool[0][0]) ;
		static_assert(off == 0xA300);
		// Create Actor Dante
		Write<uint32>((appBaseAddr + 0x1DEC79 + 3), (enable) ? newOff : off); // dmc3.exe+1DEC79 - 48 81 C2 00A30000 - ADD RDX,0000A300
		// Update Actor Dante
		Write<uint32>((appBaseAddr + 0x2136FC + 3), (enable) ? newOff : off); // dmc3.exe+2136FC - 4D 8D 85 00A30000 - LEA R8,[R13+0000A300]
		Write<uint32>((appBaseAddr + 0x213773 + 3), (enable) ? newOff : off); // dmc3.exe+213773 - 49 8D 95 00A30000 - LEA RDX,[R13+0000A300]
		Write<uint32>((appBaseAddr + 0x2137DA + 4), (enable) ? newOff : off); // dmc3.exe+2137DA - 48 8B 84 C6 00A30000 - MOV RAX,[RSI+RAX*8+0000A300]
		Write<uint32>((appBaseAddr + 0x21383C + 4), (enable) ? newOff : off); // dmc3.exe+21383C - 48 8B 84 C6 00A30000 - MOV RAX,[RSI+RAX*8+0000A300]
		Write<uint32>((appBaseAddr + 0x21389B + 4), (enable) ? newOff : off); // dmc3.exe+21389B - 48 8B 84 C6 00A30000 - MOV RAX,[RSI+RAX*8+0000A300]
		Write<uint32>((appBaseAddr + 0x213B0A + 3), (enable) ? newOff : off); // dmc3.exe+213B0A - 4D 8D 85 00A30000 - LEA R8,[R13+0000A300]
		Write<uint32>((appBaseAddr + 0x213B73 + 3), (enable) ? newOff : off); // dmc3.exe+213B73 - 49 8D 95 00A30000 - LEA RDX,[R13+0000A300]
		Write<uint32>((appBaseAddr + 0x213BDC + 4), (enable) ? newOff : off); // dmc3.exe+213BDC - 48 8B 84 C6 00A30000 - MOV RAX,[RSI+RAX*8+0000A300]
		Write<uint32>((appBaseAddr + 0x213C40 + 4), (enable) ? newOff : off); // dmc3.exe+213C40 - 48 8B 84 C6 00A30000 - MOV RAX,[RSI+RAX*8+0000A300]
		Write<uint32>((appBaseAddr + 0x213D8C + 3), (enable) ? newOff : off); // dmc3.exe+213D8C - 4D 8D 85 00A30000 - LEA R8,[R13+0000A300]
		Write<uint32>((appBaseAddr + 0x213E03 + 3), (enable) ? newOff : off); // dmc3.exe+213E03 - 49 8D 95 00A30000 - LEA RDX,[R13+0000A300]
		Write<uint32>((appBaseAddr + 0x213E93 + 4), (enable) ? newOff : off); // dmc3.exe+213E93 - 48 8B 84 C6 00A30000 - MOV RAX,[RSI+RAX*8+0000A300]
		Write<uint32>((appBaseAddr + 0x213EF7 + 4), (enable) ? newOff : off); // dmc3.exe+213EF7 - 48 8B 84 C6 00A30000 - MOV RAX,[RSI+RAX*8+0000A300]
		Write<uint32>((appBaseAddr + 0x2143D5 + 4), (enable) ? newOff : off); // dmc3.exe+2143D5 - 48 8B 84 C6 00A30000 - MOV RAX,[RSI+RAX*8+0000A300]
		Write<uint32>((appBaseAddr + 0x214434 + 4), (enable) ? newOff : off); // dmc3.exe+214434 - 48 8B 84 C6 00A30000 - MOV RAX,[RSI+RAX*8+0000A300]
		Write<uint32>((appBaseAddr + 0x214490 + 4), (enable) ? newOff : off); // dmc3.exe+214490 - 48 8B 84 C6 00A30000 - MOV RAX,[RSI+RAX*8+0000A300]
		Write<uint32>((appBaseAddr + 0x2147B0 + 4), (enable) ? newOff : off); // dmc3.exe+2147B0 - 48 8B 84 C6 00A30000 - MOV RAX,[RSI+RAX*8+0000A300]
		Write<uint32>((appBaseAddr + 0x214814 + 4), (enable) ? newOff : off); // dmc3.exe+214814 - 48 8B 84 C6 00A30000 - MOV RAX,[RSI+RAX*8+0000A300]
		Write<uint32>((appBaseAddr + 0x214A57 + 4), (enable) ? newOff : off); // dmc3.exe+214A57 - 48 8B 84 C6 00A30000 - MOV RAX,[RSI+RAX*8+0000A300]
		Write<uint32>((appBaseAddr + 0x214ABF + 4), (enable) ? newOff : off); // dmc3.exe+214ABF - 48 8B 84 C6 00A30000 - MOV RAX,[RSI+RAX*8+0000A300]
		// 0x1460
		{
			constexpr auto off = (__builtin_offsetof(ActorDataDante, devilModelPhysicsMetadataPool[0][0]) / 8);
			constexpr auto newOff = (__builtin_offsetof(ActorDataDante, newDevilModelPhysicsMetadataPool[0][0]) / 8);
			static_assert(off == 0x1460);
			// Update Actor Dante
			Write<uint32>((appBaseAddr + 0x2132F2 + 2), (enable) ? newOff : off); // dmc3.exe+2132F2 - 48 05 60140000 - ADD RAX,00001460
			Write<uint32>((appBaseAddr + 0x21427C + 2), (enable) ? newOff : off); // dmc3.exe+21427C - 48 05 60140000 - ADD RAX,00001460
			Write<uint32>((appBaseAddr + 0x214667 + 2), (enable) ? newOff : off); // dmc3.exe+214667 - 48 05 60140000 - ADD RAX,00001460
			Write<uint32>((appBaseAddr + 0x2148E3 + 2), (enable) ? newOff : off); // dmc3.exe+2148E3 - 48 05 60140000 - ADD RAX,00001460
		}
	}
	// 0xA540
	{
		constexpr auto off = __builtin_offsetof(ActorDataDante, devilSubmodelPhysicsData[0]) ;
		constexpr auto newOff = __builtin_offsetof(ActorDataDante, newDevilSubmodelPhysicsData[0]) ;
		static_assert(off == 0xA540);
		// Update Actor Dante
		Write<uint32>((appBaseAddr + 0x2133CA + 3), (enable) ? newOff : off); // dmc3.exe+2133CA - 48 8D BE 40A50000 - LEA RDI,[RSI+0000A540]
		Write<uint32>((appBaseAddr + 0x213746 + 3), (enable) ? newOff : off); // dmc3.exe+213746 - 48 8D BE 40A50000 - LEA RDI,[RSI+0000A540]
		Write<uint32>((appBaseAddr + 0x213B53 + 3), (enable) ? newOff : off); // dmc3.exe+213B53 - 48 8D BE 40A50000 - LEA RDI,[RSI+0000A540]
		Write<uint32>((appBaseAddr + 0x213DDD + 3), (enable) ? newOff : off); // dmc3.exe+213DDD - 48 8D BE 40A50000 - LEA RDI,[RSI+0000A540]
		Write<uint32>((appBaseAddr + 0x213E60 + 3), (enable) ? newOff : off); // dmc3.exe+213E60 - 48 81 C1 40A50000 - ADD RCX,0000A540
		Write<uint32>((appBaseAddr + 0x214353 + 3), (enable) ? newOff : off); // dmc3.exe+214353 - 48 8D BE 40A50000 - LEA RDI,[RSI+0000A540]
		Write<uint32>((appBaseAddr + 0x214736 + 3), (enable) ? newOff : off); // dmc3.exe+214736 - 48 8D BE 40A50000 - LEA RDI,[RSI+0000A540]
		Write<uint32>((appBaseAddr + 0x2149B3 + 3), (enable) ? newOff : off); // dmc3.exe+2149B3 - 48 8D BE 40A50000 - LEA RDI,[RSI+0000A540]
		Write<uint32>((appBaseAddr + 0x214A24 + 3), (enable) ? newOff : off); // dmc3.exe+214A24 - 48 81 C1 40A50000 - ADD RCX,0000A540
		// func_1DD480
		Write<uint32>((appBaseAddr + 0x1DD577 + 3), (enable) ? newOff : off); // dmc3.exe+1DD577 - 48 8D 8B 40A50000 - LEA RCX,[RBX+0000A540]
		// func_1DDE40
		Write<uint32>((appBaseAddr + 0x1DDEA2 + 3), (enable) ? newOff : off); // dmc3.exe+1DDEA2 - 48 8D 8B 40A50000 - LEA RCX,[RBX+0000A540]
		// Other
		Write<uint32>((appBaseAddr + 0x2121BC + 3), (enable) ? newOff : off); // dmc3.exe+2121BC - 48 8D 8E 40A50000 - LEA RCX,[RSI+0000A540]
		Write<uint32>((appBaseAddr + 0x21229E + 3), (enable) ? newOff : off); // dmc3.exe+21229E - 48 8D 8E 40A50000 - LEA RCX,[RSI+0000A540]
		Write<uint32>((appBaseAddr + 0x21236C + 3), (enable) ? newOff : off); // dmc3.exe+21236C - 48 8D 8E 40A50000 - LEA RCX,[RSI+0000A540]
		Write<uint32>((appBaseAddr + 0x21244E + 3), (enable) ? newOff : off); // dmc3.exe+21244E - 48 8D 8E 40A50000 - LEA RCX,[RSI+0000A540]
		Write<uint32>((appBaseAddr + 0x212530 + 3), (enable) ? newOff : off); // dmc3.exe+212530 - 48 8D 8E 40A50000 - LEA RCX,[RSI+0000A540]
		Write<uint32>((appBaseAddr + 0x2125FB + 3), (enable) ? newOff : off); // dmc3.exe+2125FB - 48 8D 8E 40A50000 - LEA RCX,[RSI+0000A540]
		Write<uint32>((appBaseAddr + 0x212703 + 3), (enable) ? newOff : off); // dmc3.exe+212703 - 48 8D 8E 40A50000 - LEA RCX,[RSI+0000A540]
		Write<uint32>((appBaseAddr + 0x216737 + 3), (enable) ? newOff : off); // dmc3.exe+216737 - 48 8D 8F 40A50000 - LEA RCX,[RDI+0000A540]
		Write<uint32>((appBaseAddr + 0x2167A7 + 3), (enable) ? newOff : off); // dmc3.exe+2167A7 - 48 8D 8F 40A50000 - LEA RCX,[RDI+0000A540]
		Write<uint32>((appBaseAddr + 0x216817 + 3), (enable) ? newOff : off); // dmc3.exe+216817 - 48 8D 8F 40A50000 - LEA RCX,[RDI+0000A540]
		Write<uint32>((appBaseAddr + 0x216887 + 3), (enable) ? newOff : off); // dmc3.exe+216887 - 48 8D 8F 40A50000 - LEA RCX,[RDI+0000A540]
		Write<uint32>((appBaseAddr + 0x2168F7 + 3), (enable) ? newOff : off); // dmc3.exe+2168F7 - 48 8D 8F 40A50000 - LEA RCX,[RDI+0000A540]
		Write<uint32>((appBaseAddr + 0x216967 + 3), (enable) ? newOff : off); // dmc3.exe+216967 - 48 8D 8F 40A50000 - LEA RCX,[RDI+0000A540]
		Write<uint32>((appBaseAddr + 0x2169D7 + 3), (enable) ? newOff : off); // dmc3.exe+2169D7 - 48 8D 8F 40A50000 - LEA RCX,[RDI+0000A540]
	}
	// 0xAA00
	{
		constexpr auto off = __builtin_offsetof(ActorDataDante, devilSubmodelPhysicsLinkData[0][0]) ;
		constexpr auto newOff = __builtin_offsetof(ActorDataDante, newDevilSubmodelPhysicsLinkData[0][0]) ;
		static_assert(off == 0xAA00);
		// Update Actor Dante
		Write<uint32>((appBaseAddr + 0x2137AA + 3), (enable) ? newOff : off); // dmc3.exe+2137AA - 48 8D 96 00AA0000 - LEA RDX,[RSI+0000AA00]
		Write<uint32>((appBaseAddr + 0x213BAA + 3), (enable) ? newOff : off); // dmc3.exe+213BAA - 48 8D 96 00AA0000 - LEA RDX,[RSI+0000AA00]
		Write<uint32>((appBaseAddr + 0x213E8C + 3), (enable) ? newOff : off); // dmc3.exe+213E8C - 48 8D 96 00AA0000 - LEA RDX,[RSI+0000AA00]
		Write<uint32>((appBaseAddr + 0x21439E + 3), (enable) ? newOff : off); // dmc3.exe+21439E - 48 8D 96 00AA0000 - LEA RDX,[RSI+0000AA00]
		Write<uint32>((appBaseAddr + 0x21477E + 3), (enable) ? newOff : off); // dmc3.exe+21477E - 48 8D 96 00AA0000 - LEA RDX,[RSI+0000AA00]
		Write<uint32>((appBaseAddr + 0x214A50 + 3), (enable) ? newOff : off); // dmc3.exe+214A50 - 48 8D 96 00AA0000 - LEA RDX,[RSI+0000AA00]
		// func_1DD480
		Write<uint32>((appBaseAddr + 0x1DD59B + 3), (enable) ? newOff : off); // dmc3.exe+1DD59B - 48 8D 8B 00AA0000 - LEA RCX,[RBX+0000AA00]
		// func_1DDE40
		Write<uint32>((appBaseAddr + 0x1DDE83 + 3), (enable) ? newOff : off); // dmc3.exe+1DDE83 - 48 81 C1 00AA0000 - ADD RCX,0000AA00
	}
	// 0xAAC0
	{
		constexpr auto off = (__builtin_offsetof(ActorDataDante, devilSubmodelPhysicsLinkData[0][0]) + 0xC0);
		constexpr auto newOff = (__builtin_offsetof(ActorDataDante, newDevilSubmodelPhysicsLinkData[0][0]) + 0xC0);
		static_assert(off == 0xAAC0);
		// Update Actor Dante
		Write<uint32>((appBaseAddr + 0x213832 + 3), (enable) ? newOff : off); // dmc3.exe+213832 - 48 8D 96 C0AA0000 - LEA RDX,[RSI+0000AAC0]
		Write<uint32>((appBaseAddr + 0x213C36 + 3), (enable) ? newOff : off); // dmc3.exe+213C36 - 48 8D 96 C0AA0000 - LEA RDX,[RSI+0000AAC0]
		Write<uint32>((appBaseAddr + 0x213EED + 3), (enable) ? newOff : off); // dmc3.exe+213EED - 48 8D 96 C0AA0000 - LEA RDX,[RSI+0000AAC0]
		Write<uint32>((appBaseAddr + 0x21442A + 3), (enable) ? newOff : off); // dmc3.exe+21442A - 48 8D 96 C0AA0000 - LEA RDX,[RSI+0000AAC0]
		Write<uint32>((appBaseAddr + 0x21480A + 3), (enable) ? newOff : off); // dmc3.exe+21480A - 48 8D 96 C0AA0000 - LEA RDX,[RSI+0000AAC0]
		Write<uint32>((appBaseAddr + 0x214AB5 + 3), (enable) ? newOff : off); // dmc3.exe+214AB5 - 48 8D 96 C0AA0000 - LEA RDX,[RSI+0000AAC0]
	}
}

void ToggleModelCountAdjustments(bool enable)
{
	LogFunctionHelper(__FUNCTION__, enable) ;

	// Model Data
	{
		constexpr uint32 count = 3;
		constexpr uint32 newCount = 6;
		// Create
		Write<uint32>((appBaseAddr + 0x1DDB6A + 2), (enable) ? newCount : count); // dmc3.exe+1DDB6A - 41 B8 03000000 - mov r8d,00000003
		// Free
		Write<uint32>((appBaseAddr + 0x1DE42D + 2), (enable) ? newCount : count); // dmc3.exe+1DE42D - 41 B8 03000000 - mov r8d,00000003
		Write<uint32>((appBaseAddr + 0x1DE771 + 1), (enable) ? newCount : count); // dmc3.exe+1DE771 - BD 03000000 - mov ebp,00000003
	}

	// Model Physics Metadata Pool
	{
		constexpr uint32 count = (4 * 24);
		constexpr uint32 newCount = (7 * 24);
		// Create Actor Dante
		Write<uint32>((appBaseAddr + 0x1DEC63 + 2), (enable) ? newCount : count); // dmc3.exe+1DEC63 - 41 B9 60000000 - mov r9d,00000060
		// Create Actor Bob
		Write<uint32>((appBaseAddr + 0x1DEB4A + 2), (enable) ? newCount : count); // dmc3.exe+1DEB4A - 41 B9 60000000 - MOV R9D,00000060
		// Create Actor Lady
		Write<uint32>((appBaseAddr + 0x1DEA4E + 2), (enable) ? newCount : count); // dmc3.exe+1DEA4E - 41 B9 60000000 - MOV R9D,00000060
		// Create Actor Vergil
		Write<uint32>((appBaseAddr + 0x1DE935 + 2), (enable) ? newCount : count); // dmc3.exe+1DE935 - 41 B9 60000000 - MOV R9D,00000060
		// Free
		// Handled together with Model Allocation Data.
	}

	// Model Allocation Data
	{
		constexpr uint32 count = 209;
		constexpr uint32 newCount = 512;
		// Create Actor
		Write<uint32>((appBaseAddr + 0x1DDB95 + 2), (enable) ? newCount : count); // dmc3.exe+1DDB95 - 41 B8 D1000000 - mov r8d,000000D1
		// Create Actor Dante
		Write<uint32>((appBaseAddr + 0x1DD172 + 1), (enable) ? newCount : count); // dmc3.exe+1DD172 - B8 D1000000 - mov eax,000000D1
		// Create Actor Bob
		Write<uint32>((appBaseAddr + 0x1DD3E2 + 1), (enable) ? newCount : count); // dmc3.exe+1DD3E2 - B8 D1000000 - MOV EAX,000000D1
		// Create Actor Lady
		Write<uint32>((appBaseAddr + 0x1DD242 + 1), (enable) ? newCount : count); // dmc3.exe+1DD242 - B8 D1000000 - MOV EAX,000000D1
		// Create Actor Vergil
		Write<uint32>((appBaseAddr + 0x1DD312 + 1), (enable) ? newCount : count); // dmc3.exe+1DD312 - B8 D1000000 - MOV EAX,000000D1
		// Free
		Write<uint32>((appBaseAddr + 0x1DE40E + 2), (enable) ? newCount : count); // dmc3.exe+1DE40E - 41 B8 D1000000 - mov r8d,000000D1
	}

	// Recovery Data
	{
		constexpr int8 count = -(static_cast<int8>(sizeof(RecoveryData) - 3));
		constexpr int8 newCount = -(static_cast<int8>(sizeof(RecoveryData) - 6));
		// Create
		Write<int8>((appBaseAddr + 0x1DDC28 + 3), (enable) ? newCount : count); // dmc3.exe+1DDC28 - 44 8D 42 93 - lea r8d,[rdx-6D]
		// Free
		Write<int8>((appBaseAddr + 0x1DE3C0 + 3), (enable) ? newCount : count); // dmc3.exe+1DE3C0 - 44 8D 42 93 - lea r8d,[rdx-6D]
	}

	// Body Part Data
	{
		constexpr uint32 count = (3 * 2);
		constexpr uint32 newCount = (6 * 2);
		// Create
		Write<uint8>((appBaseAddr + 0x1DDD82 + 3), (enable) ? static_cast<uint8>(newCount) : static_cast<uint8>(count)); // dmc3.exe+1DDD82 - 45 8D 47 06 - lea r8d,[r15+06]
		// Free
		Write<uint32>((appBaseAddr + 0x1DE307 + 2), (enable) ? newCount : count); // dmc3.exe+1DE307 - 41 B8 06000000 - mov r8d,00000006
	}

	// Submodel Data
	{
		constexpr uint32 count = (1 + (2 * 2));
		constexpr uint32 newCount = (1 + (5 * 2));
		// Create
		Write<uint32>((appBaseAddr + 0x1DD4F1 + 2), (enable) ? newCount : count); // dmc3.exe+1DD4F1 - 41 B8 05000000 - mov r8d,00000005
		// Free
		Write<uint32>((appBaseAddr + 0x1DDF31 + 2), (enable) ? newCount : count); // dmc3.exe+1DDF31 - 41 B8 05000000 - mov r8d,00000005
		Write<uint8>((appBaseAddr + 0x211FBD + 2), (enable) ? static_cast<uint8>(newCount) : static_cast<uint8>(count)); // dmc3.exe+211FBD - 83 FE 05 - cmp esi,05
	}

	// Model Shadow Data
	{
		constexpr uint32 count = 3;
		constexpr uint32 newCount = 6;
		// Create
		Write<uint32>((appBaseAddr + 0x1DD51C + 2), (enable) ? newCount : count); // dmc3.exe+1DD51C - 41 B8 03000000 - mov r8d,00000003
		// Free
		Write<uint32>((appBaseAddr + 0x1DDF12 + 2), (enable) ? newCount : count); // dmc3.exe+1DDF12 - 41 B8 03000000 - mov r8d,00000003
		Write<uint8>((appBaseAddr + 0x21200E + 2), (enable) ? static_cast<uint8>(newCount) : static_cast<uint8>(count)); // dmc3.exe+21200E - 83 FF 03 - cmp edi,03
	}

	// Submodel Shadow Data
	{
		constexpr uint32 count = (1 + (2 * 2));
		constexpr uint32 newCount = (1 + (5 * 2));
		// Create
		Write<uint32>((appBaseAddr + 0x1DD540 + 2), (enable) ? newCount : count); // dmc3.exe+1DD540 - 41 B8 05000000 - mov r8d,00000005
		// Free
		Write<uint32>((appBaseAddr + 0x1DDEF3 + 2), (enable) ? newCount : count); // dmc3.exe+1DDEF3 - 41 B8 05000000 - mov r8d,00000005
	}

	// Submodel Physics Metadata Pool
	{
		constexpr uint32 count = 39;
		constexpr uint32 newCount = 39;
		// Create
		Write<uint32>((appBaseAddr + 0x1DEC9D + 2), (enable) ? newCount : count); // dmc3.exe+1DEC9D - 41 B9 27000000 - mov r9d,00000027
		// Free
		// Handled together with Model Allocation Data.
	}

	// Submodel Physics Data
	{
		constexpr uint32 count = 1;
		constexpr uint32 newCount = 1;
		// Create
		Write<uint32>((appBaseAddr + 0x1DD56B + 2), (enable) ? newCount : count); // dmc3.exe+1DD56B - 41 B8 01000000 - mov r8d,00000001
		// Free
		Write<uint32>((appBaseAddr + 0x1DDED4 + 2), (enable) ? newCount : count); // dmc3.exe+1DDED4 - 41 B8 01000000 - mov r8d,00000001
	}

	// Devil Model Physics Metadata Pool
	{
		constexpr uint32 count = (2 * 36);
		constexpr uint32 newCount = (5 * 36);
		// Create
		Write<uint32>((appBaseAddr + 0x1DEC80 + 2), (enable) ? newCount : count); // dmc3.exe+1DEC80 - 41 B9 48000000 - mov r9d,00000048
		// Free
		// Handled together with Model Allocation Data.
	}

	// Devil Submodel Physics Data
	{
		constexpr uint32 count = (2 * 2);
		constexpr uint32 newCount = (5 * 2);
		// Create
		Write<uint32>((appBaseAddr + 0x1DD58F + 2), (enable) ? newCount : count); // dmc3.exe+1DD58F - 41 B8 04000000 - mov r8d,00000004
		// Free
		Write<uint32>((appBaseAddr + 0x1DDEB5 + 2), (enable) ? newCount : count); // dmc3.exe+1DDEB5 - 41 B8 04000000 - mov r8d,00000004
	}

	// Devil Submodel Physics Link Data
	{
		constexpr uint32 count = (2 * 2 * 4);
		constexpr uint32 newCount = (5 * 2 * 4);
		// Create
		Write<uint32>((appBaseAddr + 0x1DD5BA + 2), (enable) ? newCount : count); // dmc3.exe+1DD5BA - 41 B8 10000000 - mov r8d,00000010
		// Free
		Write<uint32>((appBaseAddr + 0x1DDE96 + 2), (enable) ? newCount : count); // dmc3.exe+1DDE96 - 41 B8 10000000 - mov r8d,00000010
	}
}

void ToggleWeaponCountAdjustments(bool enable)
{
	LogFunctionHelper(__FUNCTION__, enable) ;

	constexpr uint8 count = 5;
	constexpr uint8 newCount = 10;

	Write<uint8>((appBaseAddr + 0x1D91EC + 2), (enable) ? newCount : count); // dmc3.exe+1D91EC - 83 F9 05 - cmp ecx,05
	Write<uint8>((appBaseAddr + 0x1E02B2 + 2), (enable) ? newCount : count); // dmc3.exe+1E02B2 - 83 F9 05 - cmp ecx,05
	Write<uint8>((appBaseAddr + 0x1EAE1E + 2), (enable) ? newCount : count); // dmc3.exe+1EAE1E - 83 F9 05 - cmp ecx,05
	Write<uint8>((appBaseAddr + 0x1F59BD + 2), (enable) ? newCount : count); // dmc3.exe+1F59BD - 83 F9 05 - cmp ecx,05
	Write<uint8>((appBaseAddr + 0x1FACAB + 2), (enable) ? newCount : count); // dmc3.exe+1FACAB - 83 F8 05 - cmp eax,05
	Write<uint8>((appBaseAddr + 0x1FAD0B + 2), (enable) ? newCount : count); // dmc3.exe+1FAD0B - 83 F8 05 - cmp eax,05
	Write<uint8>((appBaseAddr + 0x1FAD4B + 2), (enable) ? newCount : count); // dmc3.exe+1FAD4B - 83 F8 05 - cmp eax,05
	Write<uint8>((appBaseAddr + 0x1FD14F + 3), (enable) ? newCount : count); // dmc3.exe+1FD14F - 41 83 FA 05 - cmp r10d,05
	Write<uint8>((appBaseAddr + 0x1FD180 + 3), (enable) ? newCount : count); // dmc3.exe+1FD180 - 41 83 F9 05 - cmp r9d,05
	Write<uint8>((appBaseAddr + 0x1FD1DB + 2), (enable) ? newCount : count); // dmc3.exe+1FD1DB - 83 F8 05 - cmp eax,05
	Write<uint8>((appBaseAddr + 0x1FD65D + 2), (enable) ? newCount : count); // dmc3.exe+1FD65D - 83 F8 05 - cmp eax,05
	Write<uint8>((appBaseAddr + 0x20617E + 2), (enable) ? newCount : count); // dmc3.exe+20617E - 83 F9 05 - cmp ecx,05
	Write<uint8>((appBaseAddr + 0x20619E + 2), (enable) ? newCount : count); // dmc3.exe+20619E - 83 F9 05 - cmp ecx,05
	Write<uint8>((appBaseAddr + 0x2063AC + 2), (enable) ? newCount : count); // dmc3.exe+2063AC - 83 F9 05 - cmp ecx,05
	Write<uint8>((appBaseAddr + 0x20651C + 2), (enable) ? newCount : count); // dmc3.exe+20651C - 83 F9 05 - cmp ecx,05
	Write<uint8>((appBaseAddr + 0x2086F1 + 2), (enable) ? newCount : count); // dmc3.exe+2086F1 - 83 F9 05 - cmp ecx,05
	Write<uint8>((appBaseAddr + 0x20E30E + 2), (enable) ? newCount : count); // dmc3.exe+20E30E - 83 F9 05 - cmp ecx,05
	Write<uint8>((appBaseAddr + 0x20E66E + 2), (enable) ? newCount : count); // dmc3.exe+20E66E - 83 F9 05 - cmp ecx,05
	Write<uint8>((appBaseAddr + 0x20E71F + 2), (enable) ? newCount : count); // dmc3.exe+20E71F - 83 F9 05 - cmp ecx,05
	Write<uint8>((appBaseAddr + 0x210A2E + 2), (enable) ? newCount : count); // dmc3.exe+210A2E - 83 F9 05 - cmp ecx,05
	Write<uint8>((appBaseAddr + 0x210C0C + 2), (enable) ? newCount : count); // dmc3.exe+210C0C - 83 FF 05 - cmp edi,05
	Write<uint8>((appBaseAddr + 0x210C50 + 2), (enable) ? newCount : count); // dmc3.exe+210C50 - 83 F9 05 - cmp ecx,05
	Write<uint8>((appBaseAddr + 0x2113DD + 2), (enable) ? newCount : count); // dmc3.exe+2113DD - 83 FF 05 - cmp edi,05
	Write<uint8>((appBaseAddr + 0x2114CC + 2), (enable) ? newCount : count); // dmc3.exe+2114CC - 83 FF 05 - cmp edi,05
	Write<uint8>((appBaseAddr + 0x2115EC + 2), (enable) ? newCount : count); // dmc3.exe+2115EC - 83 FF 05 - cmp edi,05
	Write<uint8>((appBaseAddr + 0x21168E + 2), (enable) ? newCount : count); // dmc3.exe+21168E - 83 F9 05 - cmp ecx,05
	Write<uint8>((appBaseAddr + 0x21172F + 2), (enable) ? newCount : count); // dmc3.exe+21172F - 83 FF 05 - cmp edi,05
	Write<uint8>((appBaseAddr + 0x21178E + 2), (enable) ? newCount : count); // dmc3.exe+21178E - 83 F9 05 - cmp ecx,05
	Write<uint32>((appBaseAddr + 0x215602 + 1), (enable) ? static_cast<uint32>(newCount) : static_cast<uint32>(count)); // dmc3.exe+215602 - BA 05000000 - mov edx,00000005
	Write<uint8>((appBaseAddr + 0x215657 + 2), (enable) ? newCount : count); // dmc3.exe+215657 - 8D 4A 05 - lea ecx,[rdx+05]
	Write<uint8>((appBaseAddr + 0x21570E + 2), (enable) ? newCount : count); // dmc3.exe+21570E - 83 F9 05 - cmp ecx,05
	Write<uint8>((appBaseAddr + 0x2158BE + 2), (enable) ? newCount : count); // dmc3.exe+2158BE - 83 F9 05 - cmp ecx,05
	Write<uint8>((appBaseAddr + 0x21597E + 2), (enable) ? newCount : count); // dmc3.exe+21597E - 83 F9 05 - cmp ecx,05
	Write<uint8>((appBaseAddr + 0x2159EE + 2), (enable) ? newCount : count); // dmc3.exe+2159EE - 83 F9 05 - cmp ecx,05
	Write<uint8>((appBaseAddr + 0x215BDE + 2), (enable) ? newCount : count); // dmc3.exe+215BDE - 83 F9 05 - cmp ecx,05
	Write<uint8>((appBaseAddr + 0x215E8E + 2), (enable) ? newCount : count); // dmc3.exe+215E8E - 83 F9 05 - cmp ecx,05
	Write<uint8>((appBaseAddr + 0x215EAE + 2), (enable) ? newCount : count); // dmc3.exe+215EAE - 83 F9 05 - cmp ecx,05
	Write<uint8>((appBaseAddr + 0x216E4E + 2), (enable) ? newCount : count); // dmc3.exe+216E4E - 83 F9 05 - cmp ecx,05
	Write<uint8>((appBaseAddr + 0x217022 + 2), (enable) ? newCount : count); // dmc3.exe+217022 - 83 F9 05 - cmp ecx,05
	Write<uint8>((appBaseAddr + 0x2171F2 + 2), (enable) ? newCount : count); // dmc3.exe+2171F2 - 83 F9 05 - cmp ecx,05
	Write<uint8>((appBaseAddr + 0x217372 + 2), (enable) ? newCount : count); // dmc3.exe+217372 - 83 F9 05 - cmp ecx,05
	Write<uint8>((appBaseAddr + 0x21747F + 2), (enable) ? newCount : count); // dmc3.exe+21747F - 83 F9 05 - cmp ecx,05
	Write<uint8>((appBaseAddr + 0x2181A2 + 2), (enable) ? newCount : count); // dmc3.exe+2181A2 - 83 F9 05 - cmp ecx,05
	Write<uint8>((appBaseAddr + 0x218322 + 2), (enable) ? newCount : count); // dmc3.exe+218322 - 83 F9 05 - cmp ecx,05
	Write<uint8>((appBaseAddr + 0x2183F1 + 2), (enable) ? newCount : count); // dmc3.exe+2183F1 - 83 F9 05 - cmp ecx,05
	Write<uint8>((appBaseAddr + 0x21842E + 2), (enable) ? newCount : count); // dmc3.exe+21842E - 83 F9 05 - cmp ecx,05
	Write<uint8>((appBaseAddr + 0x218462 + 2), (enable) ? newCount : count); // dmc3.exe+218462 - 83 F9 05 - cmp ecx,05
	Write<uint8>((appBaseAddr + 0x2184BE + 2), (enable) ? newCount : count); // dmc3.exe+2184BE - 83 F9 05 - cmp ecx,05
	Write<uint8>((appBaseAddr + 0x2184FE + 2), (enable) ? newCount : count); // dmc3.exe+2184FE - 83 F9 05 - cmp ecx,05
	Write<uint8>((appBaseAddr + 0x21853E + 2), (enable) ? newCount : count); // dmc3.exe+21853E - 83 F9 05 - cmp ecx,05
	Write<uint8>((appBaseAddr + 0x21A46E + 2), (enable) ? newCount : count); // dmc3.exe+21A46E - 83 F9 05 - cmp ecx,05
	Write<uint8>((appBaseAddr + 0x21A4BE + 2), (enable) ? newCount : count); // dmc3.exe+21A4BE - 83 F9 05 - cmp ecx,05
	Write<uint8>((appBaseAddr + 0x21B800 + 2), (enable) ? newCount : count); // dmc3.exe+21B800 - 83 F9 05 - cmp ecx,05
	Write<uint8>((appBaseAddr + 0x21B8CE + 2), (enable) ? newCount : count); // dmc3.exe+21B8CE - 83 F9 05 - cmp ecx,05
	Write<uint8>((appBaseAddr + 0x21B8FE + 2), (enable) ? newCount : count); // dmc3.exe+21B8FE - 83 F9 05 - cmp ecx,05
	Write<uint8>((appBaseAddr + 0x21BBBC + 2), (enable) ? newCount : count); // dmc3.exe+21BBBC - 83 F9 05 - cmp ecx,05
	Write<uint8>((appBaseAddr + 0x21BBF0 + 2), (enable) ? newCount : count); // dmc3.exe+21BBF0 - 83 F9 05 - cmp ecx,05
	Write<uint8>((appBaseAddr + 0x21C0AE + 2), (enable) ? newCount : count); // dmc3.exe+21C0AE - 83 F9 05 - cmp ecx,05
	Write<uint8>((appBaseAddr + 0x21C3DE + 2), (enable) ? newCount : count); // dmc3.exe+21C3DE - 83 F9 05 - cmp ecx,05
	Write<uint8>((appBaseAddr + 0x21C40E + 2), (enable) ? newCount : count); // dmc3.exe+21C40E - 83 F9 05 - cmp ecx,05
	Write<uint8>((appBaseAddr + 0x21C6AF + 2), (enable) ? newCount : count); // dmc3.exe+21C6AF - 83 F9 05 - cmp ecx,05
	Write<uint8>((appBaseAddr + 0x21C751 + 2), (enable) ? newCount : count); // dmc3.exe+21C751 - 83 F9 05 - cmp ecx,05
	Write<uint8>((appBaseAddr + 0x21C84E + 2), (enable) ? newCount : count); // dmc3.exe+21C84E - 83 F9 05 - cmp ecx,05
	Write<uint8>((appBaseAddr + 0x21D0E0 + 2), (enable) ? newCount : count); // dmc3.exe+21D0E0 - 83 F9 05 - cmp ecx,05
	Write<uint8>((appBaseAddr + 0x21D10E + 2), (enable) ? newCount : count); // dmc3.exe+21D10E - 83 F9 05 - cmp ecx,05
	Write<uint8>((appBaseAddr + 0x21E910 + 2), (enable) ? newCount : count); // dmc3.exe+21E910 - 83 F9 05 - cmp ecx,05
	Write<uint8>((appBaseAddr + 0x21E93E + 2), (enable) ? newCount : count); // dmc3.exe+21E93E - 83 F9 05 - cmp ecx,05
	Write<uint8>((appBaseAddr + 0x21F232 + 2), (enable) ? newCount : count); // dmc3.exe+21F232 - 83 FF 05 - cmp edi,05
	Write<uint8>((appBaseAddr + 0x21F260 + 2), (enable) ? newCount : count); // dmc3.exe+21F260 - 83 F9 05 - cmp ecx,05
	Write<uint32>((appBaseAddr + 0x2228FF + 1), (enable) ? static_cast<uint32>(newCount) : static_cast<uint32>(count)); // dmc3.exe+2228FF - BA 05000000 - mov edx,00000005
	Write<uint8>((appBaseAddr + 0x2229AE + 2), (enable) ? newCount : count); // dmc3.exe+2229AE - 83 F9 05 - cmp ecx,05
	Write<uint8>((appBaseAddr + 0x222B52 + 2), (enable) ? newCount : count); // dmc3.exe+222B52 - 83 F9 05 - cmp ecx,05
	Write<uint8>((appBaseAddr + 0x222E9E + 2), (enable) ? newCount : count); // dmc3.exe+222E9E - 83 FE 05 - cmp esi,05
	Write<uint8>((appBaseAddr + 0x222F40 + 2), (enable) ? newCount : count); // dmc3.exe+222F40 - 83 F9 05 - cmp ecx,05
}








void ToggleFixDevilAura(bool enable)
{
	LogFunctionHelper(__FUNCTION__, enable) ;

	static bool run = false;

	{
		auto addr     = (appBaseAddr + 0x8F898);
		auto jumpAddr = (appBaseAddr + 0x8F89E);
		constexpr uint32 size = 6;
		/*
		dmc3.exe+8F898 - 8B 91 A83E0000 - mov edx,[rcx+00003EA8]
		dmc3.exe+8F89E - 85 D2          - test edx,edx
		*/

		static Function func = {};

		constexpr byte8 sect0[] =
		{
			0x50 ,
			0x48, 0x8B, 0xCF ,
			0xE8, 0x00, 0x00, 0x00, 0x00 ,
			0x48, 0x8B, 0xC8 ,
			0x58 ,
		};

		if (!run)
		{
			backupHelper.Save(addr, size);
			func = CreateFunction(0, jumpAddr, false, true, (sizeof(sect0) + size));
			CopyMemory(func.sect0, sect0, sizeof(sect0));
			CopyMemory((func.sect0 + sizeof(sect0)), addr, size, MemoryFlags_VirtualProtectSource);
			WriteCall((func.sect0 + 4), GetActorBaseAddressByEffectData);
		}

		if (enable)
		{
			WriteJump(addr, func.addr, (size - 5));
		}
		else
		{
			backupHelper.Restore(addr);
		}
	}

	{
		auto addr     = (appBaseAddr + 0x90B21);
		auto jumpAddr = (appBaseAddr + 0x90B26);
		constexpr uint32 size = 5;
		/*
		dmc3.exe+90B21 - BB 01000000 - mov ebx,00000001
		dmc3.exe+90B26 - 8B D3       - mov edx,ebx
		*/

		static Function func = {};

		constexpr byte8 sect0[] =
		{
			0x50 ,
			0x48, 0x8B, 0xCF ,
			0xE8, 0x00, 0x00, 0x00, 0x00 ,
			0x48, 0x8B, 0xC8 ,
			0x58 ,
		};

		if (!run)
		{
			backupHelper.Save(addr, size);
			func = CreateFunction(0, jumpAddr, false, true, (sizeof(sect0) + size));
			CopyMemory(func.sect0, sect0, sizeof(sect0));
			CopyMemory((func.sect0 + sizeof(sect0)), addr, size, MemoryFlags_VirtualProtectSource);
			WriteCall((func.sect0 + 4), GetActorBaseAddressByEffectData);
		}

		if (enable)
		{
			WriteJump(addr, func.addr, (size - 5));
		}
		else
		{
			backupHelper.Restore(addr);
		}
	}

	run = true;
}







void ToggleEffectRelocations(bool enable)
{
	LogFunctionHelper(__FUNCTION__, enable) ;

	static bool run = false;

	{
		auto addr     = (appBaseAddr + 0x8DC1C);
		auto jumpAddr = (appBaseAddr + 0x8DC23);
		constexpr uint32 size = 7;
		/*
		dmc3.exe+8DC1C - 8B 84 96 C02DC900 - MOV EAX,[RSI+RDX*4+00C92DC0]
		dmc3.exe+8DC23
		*/

		static Function func = {};

		constexpr byte8 sect0[] =
		{
			0x51 ,
			0x48, 0x8B, 0xCB ,
			0xE8, 0x00, 0x00, 0x00, 0x00 ,
			0x59 ,
			0x8B, 0x84, 0x90, 0x00, 0x00, 0x00, 0x00, // mov eax,[rax+rdx*4+0000B8C0]
		};

		if (!run)
		{
			backupHelper.Save(addr, size);
			func = CreateFunction(0, jumpAddr, false, false, sizeof(sect0));
			CopyMemory(func.sect0, sect0, sizeof(sect0));
			WriteCall((func.sect0 + 4), GetActorBaseAddressByEffectData);
			*reinterpret_cast<uint32 *>(func.sect0 + 0xD) = __builtin_offsetof(ActorData, newEffectIndices[0]) ;
		}

		if (enable)
		{
			WriteJump(addr, func.addr, (size - 5));
		}
		else
		{
			backupHelper.Restore(addr);
		}
	}
	{
		auto addr     = (appBaseAddr + 0x8DC41);
		auto jumpAddr = (appBaseAddr + 0x8DC48);
		constexpr uint32 size = 7;
		/*
		dmc3.exe+8DC41 - 31 84 96 C02DC900 - XOR [RSI+RDX*4+00C92DC0],EAX
		dmc3.exe+8DC48
		*/

		static Function func = {};

		constexpr byte8 sect0[] =
		{
			0x51 ,
			0x50 ,
			0x48, 0x8B, 0xCB ,
			0xE8, 0x00, 0x00, 0x00, 0x00 ,
			0x48, 0x8B, 0xC8 ,
			0x58 ,
			0x31, 0x84, 0x91, 0x00, 0x00, 0x00, 0x00, // xor [rcx+rdx*4+0000B8C0],eax
			0x59 ,
		};

		if (!run)
		{
			backupHelper.Save(addr, size);
			func = CreateFunction(0, jumpAddr, false, false, sizeof(sect0));
			CopyMemory(func.sect0, sect0, sizeof(sect0));
			WriteCall((func.sect0 + 5), GetActorBaseAddressByEffectData);
			*reinterpret_cast<uint32 *>(func.sect0 + 0x11) = __builtin_offsetof(ActorData, newEffectIndices[0]) ;
		}

		if (enable)
		{
			WriteJump(addr, func.addr, (size - 5));
		}
		else
		{
			backupHelper.Restore(addr);
		}
	}
	{
		auto addr     = (appBaseAddr + 0x8F9C5);
		auto jumpAddr = (appBaseAddr + 0x8F9CD);
		constexpr uint32 size = 8;
		/*
		dmc3.exe+8F9C5 - 41 8B 84 94 C02DC900 - MOV EAX,[R12+RDX*4+00C92DC0]
		dmc3.exe+8F9CD
		*/

		static Function func = {};

		constexpr byte8 sect0[] =
		{
			0x51 ,
			0x48, 0x8B, 0xCF ,
			0xE8, 0x00, 0x00, 0x00, 0x00 ,
			0x59 ,
			0x8B, 0x84, 0x90, 0x00, 0x00, 0x00, 0x00, // mov eax,[rax+rdx*4+0000B8C0]
		};

		if (!run)
		{
			backupHelper.Save(addr, size);
			func = CreateFunction(0, jumpAddr, false, false, sizeof(sect0));
			CopyMemory(func.sect0, sect0, sizeof(sect0));
			WriteCall((func.sect0 + 4), GetActorBaseAddressByEffectData);
			*reinterpret_cast<uint32 *>(func.sect0 + 0xD) = __builtin_offsetof(ActorData, newEffectIndices[0]) ;
		}

		if (enable)
		{
			WriteJump(addr, func.addr, (size - 5));
		}
		else
		{
			backupHelper.Restore(addr);
		}
	}
	{
		auto addr     = (appBaseAddr + 0x8F9EE);
		auto jumpAddr = (appBaseAddr + 0x8F9F6);
		constexpr uint32 size = 8;
		/*
		dmc3.exe+8F9EE - 41 8B 84 94 C02DC900 - MOV EAX,[R12+RDX*4+00C92DC0]
		dmc3.exe+8F9F6
		*/

		static Function func = {};

		constexpr byte8 sect0[] =
		{
			0x51 ,
			0x48, 0x8B, 0xCF ,
			0xE8, 0x00, 0x00, 0x00, 0x00 ,
			0x59 ,
			0x8B, 0x84, 0x90, 0x00, 0x00, 0x00, 0x00, // mov eax,[rax+rdx*4+0000B8C0]
		};

		if (!run)
		{
			backupHelper.Save(addr, size);
			func = CreateFunction(0, jumpAddr, false, false, sizeof(sect0));
			CopyMemory(func.sect0, sect0, sizeof(sect0));
			WriteCall((func.sect0 + 4), GetActorBaseAddressByEffectData);
			*reinterpret_cast<uint32 *>(func.sect0 + 0xD) = __builtin_offsetof(ActorData, newEffectIndices[0]) ;
		}

		if (enable)
		{
			WriteJump(addr, func.addr, (size - 5));
		}
		else
		{
			backupHelper.Restore(addr);
		}
	}
	{
		auto addr     = (appBaseAddr + 0x8FA18);
		auto jumpAddr = (appBaseAddr + 0x8FA20);
		constexpr uint32 size = 8;
		/*
		dmc3.exe+8FA18 - 41 31 9C 94 C02DC900 - XOR [R12+RDX*4+00C92DC0],EBX
		dmc3.exe+8FA20
		*/

		static Function func = {};

		constexpr byte8 sect0[] =
		{
			0x51 ,
			0x50 ,
			0x48, 0x8B, 0xCF ,
			0xE8, 0x00, 0x00, 0x00, 0x00 ,
			0x48, 0x8B, 0xC8 ,
			0x58 ,
			0x31, 0x9C, 0x91, 0x00, 0x00, 0x00, 0x00, // xor [rcx+rdx*4+0000B8C0],ebx
			0x59 ,
		};

		if (!run)
		{
			backupHelper.Save(addr, size);
			func = CreateFunction(0, jumpAddr, false, false, sizeof(sect0));
			CopyMemory(func.sect0, sect0, sizeof(sect0));
			WriteCall((func.sect0 + 5), GetActorBaseAddressByEffectData);
			*reinterpret_cast<uint32 *>(func.sect0 + 0x11) = __builtin_offsetof(ActorData, newEffectIndices[0]) ;
		}

		if (enable)
		{
			WriteJump(addr, func.addr, (size - 5));
		}
		else
		{
			backupHelper.Restore(addr);
		}
	}
	{
		auto addr     = (appBaseAddr + 0x8FBA1);
		auto jumpAddr = (appBaseAddr + 0x8FBA9);
		constexpr uint32 size = 8;
		/*
		dmc3.exe+8FBA1 - 41 8B 84 94 C02DC900 - MOV EAX,[R12+RDX*4+00C92DC0]
		dmc3.exe+8FBA9
		*/

		static Function func = {};

		constexpr byte8 sect0[] =
		{
			0x51 ,
			0x48, 0x8B, 0xCF ,
			0xE8, 0x00, 0x00, 0x00, 0x00 ,
			0x59 ,
			0x8B, 0x84, 0x90, 0x00, 0x00, 0x00, 0x00, // mov eax,[rax+rdx*4+0000B8C0]
		};

		if (!run)
		{
			backupHelper.Save(addr, size);
			func = CreateFunction(0, jumpAddr, false, false, sizeof(sect0));
			CopyMemory(func.sect0, sect0, sizeof(sect0));
			WriteCall((func.sect0 + 4), GetActorBaseAddressByEffectData);
			*reinterpret_cast<uint32 *>(func.sect0 + 0xD) = __builtin_offsetof(ActorData, newEffectIndices[0]) ;
		}

		if (enable)
		{
			WriteJump(addr, func.addr, (size - 5));
		}
		else
		{
			backupHelper.Restore(addr);
		}
	}
	{
		auto addr     = (appBaseAddr + 0x8FBCA);
		auto jumpAddr = (appBaseAddr + 0x8FBD2);
		constexpr uint32 size = 8;
		/*
		dmc3.exe+8FBCA - 41 8B 84 94 C02DC900 - MOV EAX,[R12+RDX*4+00C92DC0]
		dmc3.exe+8FBD2
		*/

		static Function func = {};

		constexpr byte8 sect0[] =
		{
			0x51 ,
			0x48, 0x8B, 0xCF ,
			0xE8, 0x00, 0x00, 0x00, 0x00 ,
			0x59 ,
			0x8B, 0x84, 0x90, 0x00, 0x00, 0x00, 0x00, // mov eax,[rax+rdx*4+0000B8C0]
		};

		if (!run)
		{
			backupHelper.Save(addr, size);
			func = CreateFunction(0, jumpAddr, false, false, sizeof(sect0));
			CopyMemory(func.sect0, sect0, sizeof(sect0));
			WriteCall((func.sect0 + 4), GetActorBaseAddressByEffectData);
			*reinterpret_cast<uint32 *>(func.sect0 + 0xD) = __builtin_offsetof(ActorData, newEffectIndices[0]) ;
		}

		if (enable)
		{
			WriteJump(addr, func.addr, (size - 5));
		}
		else
		{
			backupHelper.Restore(addr);
		}
	}
	{
		auto addr     = (appBaseAddr + 0x8FBF4);
		auto jumpAddr = (appBaseAddr + 0x8FBFC);
		constexpr uint32 size = 8;
		/*
		dmc3.exe+8FBF4 - 41 31 9C 94 C02DC900 - XOR [R12+RDX*4+00C92DC0],EBX
		dmc3.exe+8FBFC
		*/

		static Function func = {};

		constexpr byte8 sect0[] =
		{
			0x51 ,
			0x50 ,
			0x48, 0x8B, 0xCF ,
			0xE8, 0x00, 0x00, 0x00, 0x00 ,
			0x48, 0x8B, 0xC8 ,
			0x58 ,
			0x31, 0x9C, 0x91, 0x00, 0x00, 0x00, 0x00, // xor [rcx+rdx*4+0000B8C0],ebx
			0x59 ,
		};

		if (!run)
		{
			backupHelper.Save(addr, size);
			func = CreateFunction(0, jumpAddr, false, false, sizeof(sect0));
			CopyMemory(func.sect0, sect0, sizeof(sect0));
			WriteCall((func.sect0 + 5), GetActorBaseAddressByEffectData);
			*reinterpret_cast<uint32 *>(func.sect0 + 0x11) = __builtin_offsetof(ActorData, newEffectIndices[0]) ;
		}

		if (enable)
		{
			WriteJump(addr, func.addr, (size - 5));
		}
		else
		{
			backupHelper.Restore(addr);
		}
	}
	{
		auto addr     = (appBaseAddr + 0x8FD14);
		auto jumpAddr = (appBaseAddr + 0x8FD1C);
		constexpr uint32 size = 8;
		/*
		dmc3.exe+8FD14 - 41 8B 84 94 C02DC900 - MOV EAX,[R12+RDX*4+00C92DC0]
		dmc3.exe+8FD1C
		*/

		static Function func = {};

		constexpr byte8 sect0[] =
		{
			0x51 ,
			0x48, 0x8B, 0xCF ,
			0xE8, 0x00, 0x00, 0x00, 0x00 ,
			0x59 ,
			0x8B, 0x84, 0x90, 0x00, 0x00, 0x00, 0x00, // mov eax,[rax+rdx*4+0000B8C0]
		};

		if (!run)
		{
			backupHelper.Save(addr, size);
			func = CreateFunction(0, jumpAddr, false, false, sizeof(sect0));
			CopyMemory(func.sect0, sect0, sizeof(sect0));
			WriteCall((func.sect0 + 4), GetActorBaseAddressByEffectData);
			*reinterpret_cast<uint32 *>(func.sect0 + 0xD) = __builtin_offsetof(ActorData, newEffectIndices[0]) ;
		}

		if (enable)
		{
			WriteJump(addr, func.addr, (size - 5));
		}
		else
		{
			backupHelper.Restore(addr);
		}
	}
	{
		auto addr     = (appBaseAddr + 0x8FDB6);
		auto jumpAddr = (appBaseAddr + 0x8FDBE);
		constexpr uint32 size = 8;
		/*
		dmc3.exe+8FDB6 - 41 8B 84 94 C02DC900 - MOV EAX,[R12+RDX*4+00C92DC0]
		dmc3.exe+8FDBE
		*/

		static Function func = {};

		constexpr byte8 sect0[] =
		{
			0x51 ,
			0x48, 0x8B, 0xCF ,
			0xE8, 0x00, 0x00, 0x00, 0x00 ,
			0x59 ,
			0x8B, 0x84, 0x90, 0x00, 0x00, 0x00, 0x00, // mov eax,[rax+rdx*4+0000B8C0]
		};

		if (!run)
		{
			backupHelper.Save(addr, size);
			func = CreateFunction(0, jumpAddr, false, false, sizeof(sect0));
			CopyMemory(func.sect0, sect0, sizeof(sect0));
			WriteCall((func.sect0 + 4), GetActorBaseAddressByEffectData);
			*reinterpret_cast<uint32 *>(func.sect0 + 0xD) = __builtin_offsetof(ActorData, newEffectIndices[0]) ;
		}

		if (enable)
		{
			WriteJump(addr, func.addr, (size - 5));
		}
		else
		{
			backupHelper.Restore(addr);
		}
	}
	{
		auto addr     = (appBaseAddr + 0x8FDDC);
		auto jumpAddr = (appBaseAddr + 0x8FDE4);
		constexpr uint32 size = 8;
		/*
		dmc3.exe+8FDDC - 41 31 9C 94 C02DC900 - XOR [R12+RDX*4+00C92DC0],EBX
		dmc3.exe+8FDE4
		*/

		static Function func = {};

		constexpr byte8 sect0[] =
		{
			0x51 ,
			0x50 ,
			0x48, 0x8B, 0xCF ,
			0xE8, 0x00, 0x00, 0x00, 0x00 ,
			0x48, 0x8B, 0xC8 ,
			0x58 ,
			0x31, 0x9C, 0x91, 0x00, 0x00, 0x00, 0x00, // xor [rcx+rdx*4+0000B8C0],ebx
			0x59 ,
		};

		if (!run)
		{
			backupHelper.Save(addr, size);
			func = CreateFunction(0, jumpAddr, false, false, sizeof(sect0));
			CopyMemory(func.sect0, sect0, sizeof(sect0));
			WriteCall((func.sect0 + 5), GetActorBaseAddressByEffectData);
			*reinterpret_cast<uint32 *>(func.sect0 + 0x11) = __builtin_offsetof(ActorData, newEffectIndices[0]) ;
		}

		if (enable)
		{
			WriteJump(addr, func.addr, (size - 5));
		}
		else
		{
			backupHelper.Restore(addr);
		}
	}
	{
		auto addr     = (appBaseAddr + 0x8FEA9);
		auto jumpAddr = (appBaseAddr + 0x8FEB1);
		constexpr uint32 size = 8;
		/*
		dmc3.exe+8FEA9 - 41 8B 84 94 C02DC900 - MOV EAX,[R12+RDX*4+00C92DC0]
		dmc3.exe+8FEB1
		*/

		static Function func = {};

		constexpr byte8 sect0[] =
		{
			0x51 ,
			0x48, 0x8B, 0xCF ,
			0xE8, 0x00, 0x00, 0x00, 0x00 ,
			0x59 ,
			0x8B, 0x84, 0x90, 0x00, 0x00, 0x00, 0x00, // mov eax,[rax+rdx*4+0000B8C0]
		};

		if (!run)
		{
			backupHelper.Save(addr, size);
			func = CreateFunction(0, jumpAddr, false, false, sizeof(sect0));
			CopyMemory(func.sect0, sect0, sizeof(sect0));
			WriteCall((func.sect0 + 4), GetActorBaseAddressByEffectData);
			*reinterpret_cast<uint32 *>(func.sect0 + 0xD) = __builtin_offsetof(ActorData, newEffectIndices[0]) ;
		}

		if (enable)
		{
			WriteJump(addr, func.addr, (size - 5));
		}
		else
		{
			backupHelper.Restore(addr);
		}
	}
	{
		auto addr     = (appBaseAddr + 0x8FECF);
		auto jumpAddr = (appBaseAddr + 0x8FED7);
		constexpr uint32 size = 8;
		/*
		dmc3.exe+8FECF - 41 31 9C 94 C02DC900 - XOR [R12+RDX*4+00C92DC0],EBX
		dmc3.exe+8FED7
		*/

		static Function func = {};

		constexpr byte8 sect0[] =
		{
			0x51 ,
			0x50 ,
			0x48, 0x8B, 0xCF ,
			0xE8, 0x00, 0x00, 0x00, 0x00 ,
			0x48, 0x8B, 0xC8 ,
			0x58 ,
			0x31, 0x9C, 0x91, 0x00, 0x00, 0x00, 0x00, // xor [rcx+rdx*4+0000B8C0],ebx
			0x59 ,
		};

		if (!run)
		{
			backupHelper.Save(addr, size);
			func = CreateFunction(0, jumpAddr, false, false, sizeof(sect0));
			CopyMemory(func.sect0, sect0, sizeof(sect0));
			WriteCall((func.sect0 + 5), GetActorBaseAddressByEffectData);
			*reinterpret_cast<uint32 *>(func.sect0 + 0x11) = __builtin_offsetof(ActorData, newEffectIndices[0]) ;
		}

		if (enable)
		{
			WriteJump(addr, func.addr, (size - 5));
		}
		else
		{
			backupHelper.Restore(addr);
		}
	}
	{
		auto addr     = (appBaseAddr + 0x8FFA0);
		auto jumpAddr = (appBaseAddr + 0x8FFA8);
		constexpr uint32 size = 8;
		/*
		dmc3.exe+8FFA0 - 41 8B 84 94 C02DC900 - MOV EAX,[R12+RDX*4+00C92DC0]
		dmc3.exe+8FFA8
		*/

		static Function func = {};

		constexpr byte8 sect0[] =
		{
			0x51 ,
			0x48, 0x8B, 0xCF ,
			0xE8, 0x00, 0x00, 0x00, 0x00 ,
			0x59 ,
			0x8B, 0x84, 0x90, 0x00, 0x00, 0x00, 0x00, // mov eax,[rax+rdx*4+0000B8C0]
		};

		if (!run)
		{
			backupHelper.Save(addr, size);
			func = CreateFunction(0, jumpAddr, false, false, sizeof(sect0));
			CopyMemory(func.sect0, sect0, sizeof(sect0));
			WriteCall((func.sect0 + 4), GetActorBaseAddressByEffectData);
			*reinterpret_cast<uint32 *>(func.sect0 + 0xD) = __builtin_offsetof(ActorData, newEffectIndices[0]) ;
		}

		if (enable)
		{
			WriteJump(addr, func.addr, (size - 5));
		}
		else
		{
			backupHelper.Restore(addr);
		}
	}
	{
		auto addr     = (appBaseAddr + 0x8FFCA);
		auto jumpAddr = (appBaseAddr + 0x8FFD2);
		constexpr uint32 size = 8;
		/*
		dmc3.exe+8FFCA - 41 31 9C 94 C02DC900 - XOR [R12+RDX*4+00C92DC0],EBX
		dmc3.exe+8FFD2
		*/

		static Function func = {};

		constexpr byte8 sect0[] =
		{
			0x51 ,
			0x50 ,
			0x48, 0x8B, 0xCF ,
			0xE8, 0x00, 0x00, 0x00, 0x00 ,
			0x48, 0x8B, 0xC8 ,
			0x58 ,
			0x31, 0x9C, 0x91, 0x00, 0x00, 0x00, 0x00, // xor [rcx+rdx*4+0000B8C0],ebx
			0x59 ,
		};

		if (!run)
		{
			backupHelper.Save(addr, size);
			func = CreateFunction(0, jumpAddr, false, false, sizeof(sect0));
			CopyMemory(func.sect0, sect0, sizeof(sect0));
			WriteCall((func.sect0 + 5), GetActorBaseAddressByEffectData);
			*reinterpret_cast<uint32 *>(func.sect0 + 0x11) = __builtin_offsetof(ActorData, newEffectIndices[0]) ;
		}

		if (enable)
		{
			WriteJump(addr, func.addr, (size - 5));
		}
		else
		{
			backupHelper.Restore(addr);
		}
	}
	{
		auto addr     = (appBaseAddr + 0x9014C);
		auto jumpAddr = (appBaseAddr + 0x90154);
		constexpr uint32 size = 8;
		/*
		dmc3.exe+9014C - 41 8B 84 94 C02DC900 - MOV EAX,[R12+RDX*4+00C92DC0]
		dmc3.exe+90154
		*/

		static Function func = {};

		constexpr byte8 sect0[] =
		{
			0x51 ,
			0x48, 0x8B, 0xCF ,
			0xE8, 0x00, 0x00, 0x00, 0x00 ,
			0x59 ,
			0x8B, 0x84, 0x90, 0x00, 0x00, 0x00, 0x00, // mov eax,[rax+rdx*4+0000B8C0]
		};

		if (!run)
		{
			backupHelper.Save(addr, size);
			func = CreateFunction(0, jumpAddr, false, false, sizeof(sect0));
			CopyMemory(func.sect0, sect0, sizeof(sect0));
			WriteCall((func.sect0 + 4), GetActorBaseAddressByEffectData);
			*reinterpret_cast<uint32 *>(func.sect0 + 0xD) = __builtin_offsetof(ActorData, newEffectIndices[0]) ;
		}

		if (enable)
		{
			WriteJump(addr, func.addr, (size - 5));
		}
		else
		{
			backupHelper.Restore(addr);
		}
	}
	{
		auto addr     = (appBaseAddr + 0x90172);
		auto jumpAddr = (appBaseAddr + 0x9017A);
		constexpr uint32 size = 8;
		/*
		dmc3.exe+90172 - 41 31 9C 94 C02DC900 - XOR [R12+RDX*4+00C92DC0],EBX
		dmc3.exe+9017A
		*/

		static Function func = {};

		constexpr byte8 sect0[] =
		{
			0x51 ,
			0x50 ,
			0x48, 0x8B, 0xCF ,
			0xE8, 0x00, 0x00, 0x00, 0x00 ,
			0x48, 0x8B, 0xC8 ,
			0x58 ,
			0x31, 0x9C, 0x91, 0x00, 0x00, 0x00, 0x00, // xor [rcx+rdx*4+0000B8C0],ebx
			0x59 ,
		};

		if (!run)
		{
			backupHelper.Save(addr, size);
			func = CreateFunction(0, jumpAddr, false, false, sizeof(sect0));
			CopyMemory(func.sect0, sect0, sizeof(sect0));
			WriteCall((func.sect0 + 5), GetActorBaseAddressByEffectData);
			*reinterpret_cast<uint32 *>(func.sect0 + 0x11) = __builtin_offsetof(ActorData, newEffectIndices[0]) ;
		}

		if (enable)
		{
			WriteJump(addr, func.addr, (size - 5));
		}
		else
		{
			backupHelper.Restore(addr);
		}
	}
	{
		auto addr     = (appBaseAddr + 0x9021F);
		auto jumpAddr = (appBaseAddr + 0x90227);
		constexpr uint32 size = 8;
		/*
		dmc3.exe+9021F - 41 8B 84 94 C02DC900 - MOV EAX,[R12+RDX*4+00C92DC0]
		dmc3.exe+90227
		*/

		static Function func = {};

		constexpr byte8 sect0[] =
		{
			0x51 ,
			0x48, 0x8B, 0xCF ,
			0xE8, 0x00, 0x00, 0x00, 0x00 ,
			0x59 ,
			0x8B, 0x84, 0x90, 0x00, 0x00, 0x00, 0x00, // mov eax,[rax+rdx*4+0000B8C0]
		};

		if (!run)
		{
			backupHelper.Save(addr, size);
			func = CreateFunction(0, jumpAddr, false, false, sizeof(sect0));
			CopyMemory(func.sect0, sect0, sizeof(sect0));
			WriteCall((func.sect0 + 4), GetActorBaseAddressByEffectData);
			*reinterpret_cast<uint32 *>(func.sect0 + 0xD) = __builtin_offsetof(ActorData, newEffectIndices[0]) ;
		}

		if (enable)
		{
			WriteJump(addr, func.addr, (size - 5));
		}
		else
		{
			backupHelper.Restore(addr);
		}
	}
	{
		auto addr     = (appBaseAddr + 0x90245);
		auto jumpAddr = (appBaseAddr + 0x9024D);
		constexpr uint32 size = 8;
		/*
		dmc3.exe+90245 - 41 31 9C 94 C02DC900 - XOR [R12+RDX*4+00C92DC0],EBX
		dmc3.exe+9024D
		*/

		static Function func = {};

		constexpr byte8 sect0[] =
		{
			0x51 ,
			0x50 ,
			0x48, 0x8B, 0xCF ,
			0xE8, 0x00, 0x00, 0x00, 0x00 ,
			0x48, 0x8B, 0xC8 ,
			0x58 ,
			0x31, 0x9C, 0x91, 0x00, 0x00, 0x00, 0x00, // xor [rcx+rdx*4+0000B8C0],ebx
			0x59 ,
		};

		if (!run)
		{
			backupHelper.Save(addr, size);
			func = CreateFunction(0, jumpAddr, false, false, sizeof(sect0));
			CopyMemory(func.sect0, sect0, sizeof(sect0));
			WriteCall((func.sect0 + 5), GetActorBaseAddressByEffectData);
			*reinterpret_cast<uint32 *>(func.sect0 + 0x11) = __builtin_offsetof(ActorData, newEffectIndices[0]) ;
		}

		if (enable)
		{
			WriteJump(addr, func.addr, (size - 5));
		}
		else
		{
			backupHelper.Restore(addr);
		}
	}
	{
		auto addr     = (appBaseAddr + 0x902F2);
		auto jumpAddr = (appBaseAddr + 0x902FA);
		constexpr uint32 size = 8;
		/*
		dmc3.exe+902F2 - 41 8B 84 94 C02DC900 - MOV EAX,[R12+RDX*4+00C92DC0]
		dmc3.exe+902FA
		*/

		static Function func = {};

		constexpr byte8 sect0[] =
		{
			0x51 ,
			0x48, 0x8B, 0xCF ,
			0xE8, 0x00, 0x00, 0x00, 0x00 ,
			0x59 ,
			0x8B, 0x84, 0x90, 0x00, 0x00, 0x00, 0x00, // mov eax,[rax+rdx*4+0000B8C0]
		};

		if (!run)
		{
			backupHelper.Save(addr, size);
			func = CreateFunction(0, jumpAddr, false, false, sizeof(sect0));
			CopyMemory(func.sect0, sect0, sizeof(sect0));
			WriteCall((func.sect0 + 4), GetActorBaseAddressByEffectData);
			*reinterpret_cast<uint32 *>(func.sect0 + 0xD) = __builtin_offsetof(ActorData, newEffectIndices[0]) ;
		}

		if (enable)
		{
			WriteJump(addr, func.addr, (size - 5));
		}
		else
		{
			backupHelper.Restore(addr);
		}
	}
	{
		auto addr     = (appBaseAddr + 0x90318);
		auto jumpAddr = (appBaseAddr + 0x90320);
		constexpr uint32 size = 8;
		/*
		dmc3.exe+90318 - 41 31 9C 94 C02DC900 - XOR [R12+RDX*4+00C92DC0],EBX
		dmc3.exe+90320
		*/

		static Function func = {};

		constexpr byte8 sect0[] =
		{
			0x51 ,
			0x50 ,
			0x48, 0x8B, 0xCF ,
			0xE8, 0x00, 0x00, 0x00, 0x00 ,
			0x48, 0x8B, 0xC8 ,
			0x58 ,
			0x31, 0x9C, 0x91, 0x00, 0x00, 0x00, 0x00, // xor [rcx+rdx*4+0000B8C0],ebx
			0x59 ,
		};

		if (!run)
		{
			backupHelper.Save(addr, size);
			func = CreateFunction(0, jumpAddr, false, false, sizeof(sect0));
			CopyMemory(func.sect0, sect0, sizeof(sect0));
			WriteCall((func.sect0 + 5), GetActorBaseAddressByEffectData);
			*reinterpret_cast<uint32 *>(func.sect0 + 0x11) = __builtin_offsetof(ActorData, newEffectIndices[0]) ;
		}

		if (enable)
		{
			WriteJump(addr, func.addr, (size - 5));
		}
		else
		{
			backupHelper.Restore(addr);
		}
	}
	{
		auto addr     = (appBaseAddr + 0x9044F);
		auto jumpAddr = (appBaseAddr + 0x90457);
		constexpr uint32 size = 8;
		/*
		dmc3.exe+9044F - 41 8B 84 94 C02DC900 - MOV EAX,[R12+RDX*4+00C92DC0]
		dmc3.exe+90457
		*/

		static Function func = {};

		constexpr byte8 sect0[] =
		{
			0x51 ,
			0x48, 0x8B, 0xCF ,
			0xE8, 0x00, 0x00, 0x00, 0x00 ,
			0x59 ,
			0x8B, 0x84, 0x90, 0x00, 0x00, 0x00, 0x00, // mov eax,[rax+rdx*4+0000B8C0]
		};

		if (!run)
		{
			backupHelper.Save(addr, size);
			func = CreateFunction(0, jumpAddr, false, false, sizeof(sect0));
			CopyMemory(func.sect0, sect0, sizeof(sect0));
			WriteCall((func.sect0 + 4), GetActorBaseAddressByEffectData);
			*reinterpret_cast<uint32 *>(func.sect0 + 0xD) = __builtin_offsetof(ActorData, newEffectIndices[0]) ;
		}

		if (enable)
		{
			WriteJump(addr, func.addr, (size - 5));
		}
		else
		{
			backupHelper.Restore(addr);
		}
	}
	{
		auto addr     = (appBaseAddr + 0x9047F);
		auto jumpAddr = (appBaseAddr + 0x90487);
		constexpr uint32 size = 8;
		/*
		dmc3.exe+9047F - 41 31 9C 94 C02DC900 - XOR [R12+RDX*4+00C92DC0],EBX
		dmc3.exe+90487
		*/

		static Function func = {};

		constexpr byte8 sect0[] =
		{
			0x51 ,
			0x50 ,
			0x48, 0x8B, 0xCF ,
			0xE8, 0x00, 0x00, 0x00, 0x00 ,
			0x48, 0x8B, 0xC8 ,
			0x58 ,
			0x31, 0x9C, 0x91, 0x00, 0x00, 0x00, 0x00, // xor [rcx+rdx*4+0000B8C0],ebx
			0x59 ,
		};

		if (!run)
		{
			backupHelper.Save(addr, size);
			func = CreateFunction(0, jumpAddr, false, false, sizeof(sect0));
			CopyMemory(func.sect0, sect0, sizeof(sect0));
			WriteCall((func.sect0 + 5), GetActorBaseAddressByEffectData);
			*reinterpret_cast<uint32 *>(func.sect0 + 0x11) = __builtin_offsetof(ActorData, newEffectIndices[0]) ;
		}

		if (enable)
		{
			WriteJump(addr, func.addr, (size - 5));
		}
		else
		{
			backupHelper.Restore(addr);
		}
	}
	{
		auto addr     = (appBaseAddr + 0x90504);
		auto jumpAddr = (appBaseAddr + 0x9050C);
		constexpr uint32 size = 8;
		/*
		dmc3.exe+90504 - 41 8B 84 94 C02DC900 - MOV EAX,[R12+RDX*4+00C92DC0]
		dmc3.exe+9050C
		*/

		static Function func = {};

		constexpr byte8 sect0[] =
		{
			0x51 ,
			0x48, 0x8B, 0xCF ,
			0xE8, 0x00, 0x00, 0x00, 0x00 ,
			0x59 ,
			0x8B, 0x84, 0x90, 0x00, 0x00, 0x00, 0x00, // mov eax,[rax+rdx*4+0000B8C0]
		};

		if (!run)
		{
			backupHelper.Save(addr, size);
			func = CreateFunction(0, jumpAddr, false, false, sizeof(sect0));
			CopyMemory(func.sect0, sect0, sizeof(sect0));
			WriteCall((func.sect0 + 4), GetActorBaseAddressByEffectData);
			*reinterpret_cast<uint32 *>(func.sect0 + 0xD) = __builtin_offsetof(ActorData, newEffectIndices[0]) ;
		}

		if (enable)
		{
			WriteJump(addr, func.addr, (size - 5));
		}
		else
		{
			backupHelper.Restore(addr);
		}
	}
	{
		auto addr     = (appBaseAddr + 0x90534);
		auto jumpAddr = (appBaseAddr + 0x9053C);
		constexpr uint32 size = 8;
		/*
		dmc3.exe+90534 - 41 31 9C 94 C02DC900 - XOR [R12+RDX*4+00C92DC0],EBX
		dmc3.exe+9053C
		*/

		static Function func = {};

		constexpr byte8 sect0[] =
		{
			0x51 ,
			0x50 ,
			0x48, 0x8B, 0xCF ,
			0xE8, 0x00, 0x00, 0x00, 0x00 ,
			0x48, 0x8B, 0xC8 ,
			0x58 ,
			0x31, 0x9C, 0x91, 0x00, 0x00, 0x00, 0x00, // xor [rcx+rdx*4+0000B8C0],ebx
			0x59 ,
		};

		if (!run)
		{
			backupHelper.Save(addr, size);
			func = CreateFunction(0, jumpAddr, false, false, sizeof(sect0));
			CopyMemory(func.sect0, sect0, sizeof(sect0));
			WriteCall((func.sect0 + 5), GetActorBaseAddressByEffectData);
			*reinterpret_cast<uint32 *>(func.sect0 + 0x11) = __builtin_offsetof(ActorData, newEffectIndices[0]) ;
		}

		if (enable)
		{
			WriteJump(addr, func.addr, (size - 5));
		}
		else
		{
			backupHelper.Restore(addr);
		}
	}
	{
		auto addr     = (appBaseAddr + 0x9065D);
		auto jumpAddr = (appBaseAddr + 0x90665);
		constexpr uint32 size = 8;
		/*
		dmc3.exe+9065D - 41 8B 84 94 C02DC900 - MOV EAX,[R12+RDX*4+00C92DC0]
		dmc3.exe+90665
		*/

		static Function func = {};

		constexpr byte8 sect0[] =
		{
			0x51 ,
			0x48, 0x8B, 0xCF ,
			0xE8, 0x00, 0x00, 0x00, 0x00 ,
			0x59 ,
			0x8B, 0x84, 0x90, 0x00, 0x00, 0x00, 0x00, // mov eax,[rax+rdx*4+0000B8C0]
		};

		if (!run)
		{
			backupHelper.Save(addr, size);
			func = CreateFunction(0, jumpAddr, false, false, sizeof(sect0));
			CopyMemory(func.sect0, sect0, sizeof(sect0));
			WriteCall((func.sect0 + 4), GetActorBaseAddressByEffectData);
			*reinterpret_cast<uint32 *>(func.sect0 + 0xD) = __builtin_offsetof(ActorData, newEffectIndices[0]) ;
		}

		if (enable)
		{
			WriteJump(addr, func.addr, (size - 5));
		}
		else
		{
			backupHelper.Restore(addr);
		}
	}
	{
		auto addr     = (appBaseAddr + 0x90846);
		auto jumpAddr = (appBaseAddr + 0x9084E);
		constexpr uint32 size = 8;
		/*
		dmc3.exe+90846 - 41 8B 84 94 C02DC900 - MOV EAX,[R12+RDX*4+00C92DC0]
		dmc3.exe+9084E
		*/

		static Function func = {};

		constexpr byte8 sect0[] =
		{
			0x51 ,
			0x48, 0x8B, 0xCF ,
			0xE8, 0x00, 0x00, 0x00, 0x00 ,
			0x59 ,
			0x8B, 0x84, 0x90, 0x00, 0x00, 0x00, 0x00, // mov eax,[rax+rdx*4+0000B8C0]
		};

		if (!run)
		{
			backupHelper.Save(addr, size);
			func = CreateFunction(0, jumpAddr, false, false, sizeof(sect0));
			CopyMemory(func.sect0, sect0, sizeof(sect0));
			WriteCall((func.sect0 + 4), GetActorBaseAddressByEffectData);
			*reinterpret_cast<uint32 *>(func.sect0 + 0xD) = __builtin_offsetof(ActorData, newEffectIndices[0]) ;
		}

		if (enable)
		{
			WriteJump(addr, func.addr, (size - 5));
		}
		else
		{
			backupHelper.Restore(addr);
		}
	}
	{
		auto addr     = (appBaseAddr + 0x9086C);
		auto jumpAddr = (appBaseAddr + 0x90874);
		constexpr uint32 size = 8;
		/*
		dmc3.exe+9086C - 41 31 9C 94 C02DC900 - XOR [R12+RDX*4+00C92DC0],EBX
		dmc3.exe+90874
		*/

		static Function func = {};

		constexpr byte8 sect0[] =
		{
			0x51 ,
			0x50 ,
			0x48, 0x8B, 0xCF ,
			0xE8, 0x00, 0x00, 0x00, 0x00 ,
			0x48, 0x8B, 0xC8 ,
			0x58 ,
			0x31, 0x9C, 0x91, 0x00, 0x00, 0x00, 0x00, // xor [rcx+rdx*4+0000B8C0],ebx
			0x59 ,
		};

		if (!run)
		{
			backupHelper.Save(addr, size);
			func = CreateFunction(0, jumpAddr, false, false, sizeof(sect0));
			CopyMemory(func.sect0, sect0, sizeof(sect0));
			WriteCall((func.sect0 + 5), GetActorBaseAddressByEffectData);
			*reinterpret_cast<uint32 *>(func.sect0 + 0x11) = __builtin_offsetof(ActorData, newEffectIndices[0]) ;
		}

		if (enable)
		{
			WriteJump(addr, func.addr, (size - 5));
		}
		else
		{
			backupHelper.Restore(addr);
		}
	}
	{
		auto addr     = (appBaseAddr + 0x909F9);
		auto jumpAddr = (appBaseAddr + 0x90A01);
		constexpr uint32 size = 8;
		/*
		dmc3.exe+909F9 - 41 8B 84 94 C02DC900 - MOV EAX,[R12+RDX*4+00C92DC0]
		dmc3.exe+90A01
		*/

		static Function func = {};

		constexpr byte8 sect0[] =
		{
			0x51 ,
			0x48, 0x8B, 0xCF ,
			0xE8, 0x00, 0x00, 0x00, 0x00 ,
			0x59 ,
			0x8B, 0x84, 0x90, 0x00, 0x00, 0x00, 0x00, // mov eax,[rax+rdx*4+0000B8C0]
		};

		if (!run)
		{
			backupHelper.Save(addr, size);
			func = CreateFunction(0, jumpAddr, false, false, sizeof(sect0));
			CopyMemory(func.sect0, sect0, sizeof(sect0));
			WriteCall((func.sect0 + 4), GetActorBaseAddressByEffectData);
			*reinterpret_cast<uint32 *>(func.sect0 + 0xD) = __builtin_offsetof(ActorData, newEffectIndices[0]) ;
		}

		if (enable)
		{
			WriteJump(addr, func.addr, (size - 5));
		}
		else
		{
			backupHelper.Restore(addr);
		}
	}
	{
		auto addr     = (appBaseAddr + 0x90A29);
		auto jumpAddr = (appBaseAddr + 0x90A31);
		constexpr uint32 size = 8;
		/*
		dmc3.exe+90A29 - 41 8B 84 94 C02DC900 - MOV EAX,[R12+RDX*4+00C92DC0]
		dmc3.exe+90A31
		*/

		static Function func = {};

		constexpr byte8 sect0[] =
		{
			0x51 ,
			0x48, 0x8B, 0xCF ,
			0xE8, 0x00, 0x00, 0x00, 0x00 ,
			0x59 ,
			0x8B, 0x84, 0x90, 0x00, 0x00, 0x00, 0x00, // mov eax,[rax+rdx*4+0000B8C0]
		};

		if (!run)
		{
			backupHelper.Save(addr, size);
			func = CreateFunction(0, jumpAddr, false, false, sizeof(sect0));
			CopyMemory(func.sect0, sect0, sizeof(sect0));
			WriteCall((func.sect0 + 4), GetActorBaseAddressByEffectData);
			*reinterpret_cast<uint32 *>(func.sect0 + 0xD) = __builtin_offsetof(ActorData, newEffectIndices[0]) ;
		}

		if (enable)
		{
			WriteJump(addr, func.addr, (size - 5));
		}
		else
		{
			backupHelper.Restore(addr);
		}
	}
	{
		auto addr     = (appBaseAddr + 0x90A55);
		auto jumpAddr = (appBaseAddr + 0x90A5D);
		constexpr uint32 size = 8;
		/*
		dmc3.exe+90A55 - 43 31 9C 84 C02DC900 - XOR [R12+R8*4+00C92DC0],EBX
		dmc3.exe+90A5D
		*/

		static Function func = {};

		constexpr byte8 sect0[] =
		{
			0x51 ,
			0x50 ,
			0x48, 0x8B, 0xCF ,
			0xE8, 0x00, 0x00, 0x00, 0x00 ,
			0x48, 0x8B, 0xC8 ,
			0x58 ,
			0x42, 0x31, 0x9C, 0x81, 0x00, 0x00, 0x00, 0x00, // xor [rcx+r8*4+0000B8C0],ebx
			0x59 ,
		};

		if (!run)
		{
			backupHelper.Save(addr, size);
			func = CreateFunction(0, jumpAddr, false, false, sizeof(sect0));
			CopyMemory(func.sect0, sect0, sizeof(sect0));
			WriteCall((func.sect0 + 5), GetActorBaseAddressByEffectData);
			*reinterpret_cast<uint32 *>(func.sect0 + 0x12) = __builtin_offsetof(ActorData, newEffectIndices[0]) ;
		}

		if (enable)
		{
			WriteJump(addr, func.addr, (size - 5));
		}
		else
		{
			backupHelper.Restore(addr);
		}
	}
	{
		auto addr     = (appBaseAddr + 0x90D21);
		auto jumpAddr = (appBaseAddr + 0x90D29);
		constexpr uint32 size = 8;
		/*
		dmc3.exe+90D21 - 41 8B 84 91 C02DC900 - MOV EAX,[R9+RDX*4+00C92DC0]
		dmc3.exe+90D29
		*/

		static Function func = {};

		constexpr byte8 sect0[] =
		{
			0x51 ,
			0x48, 0x8B, 0xCF ,
			0xE8, 0x00, 0x00, 0x00, 0x00 ,
			0x59 ,
			0x8B, 0x84, 0x90, 0x00, 0x00, 0x00, 0x00, // mov eax,[rax+rdx*4+0000B8C0]
		};

		if (!run)
		{
			backupHelper.Save(addr, size);
			func = CreateFunction(0, jumpAddr, false, false, sizeof(sect0));
			CopyMemory(func.sect0, sect0, sizeof(sect0));
			WriteCall((func.sect0 + 4), GetActorBaseAddressByEffectData);
			*reinterpret_cast<uint32 *>(func.sect0 + 0xD) = __builtin_offsetof(ActorData, newEffectIndices[0]) ;
		}

		if (enable)
		{
			WriteJump(addr, func.addr, (size - 5));
		}
		else
		{
			backupHelper.Restore(addr);
		}
	}
	{
		auto addr     = (appBaseAddr + 0x90D4F);
		auto jumpAddr = (appBaseAddr + 0x90D57);
		constexpr uint32 size = 8;
		/*
		dmc3.exe+90D4F - 41 31 84 91 C02DC900 - XOR [R9+RDX*4+00C92DC0],EAX
		dmc3.exe+90D57
		*/

		static Function func = {};

		constexpr byte8 sect0[] =
		{
			0x51 ,
			0x50 ,
			0x48, 0x8B, 0xCF ,
			0xE8, 0x00, 0x00, 0x00, 0x00 ,
			0x48, 0x8B, 0xC8 ,
			0x58 ,
			0x31, 0x84, 0x91, 0x00, 0x00, 0x00, 0x00, // xor [rcx+rdx*4+0000B8C0],eax
			0x59 ,
		};

		if (!run)
		{
			backupHelper.Save(addr, size);
			func = CreateFunction(0, jumpAddr, false, false, sizeof(sect0));
			CopyMemory(func.sect0, sect0, sizeof(sect0));
			WriteCall((func.sect0 + 5), GetActorBaseAddressByEffectData);
			*reinterpret_cast<uint32 *>(func.sect0 + 0x11) = __builtin_offsetof(ActorData, newEffectIndices[0]) ;
		}

		if (enable)
		{
			WriteJump(addr, func.addr, (size - 5));
		}
		else
		{
			backupHelper.Restore(addr);
		}
	}
	{
		auto addr     = (appBaseAddr + 0x90E2D);
		auto jumpAddr = (appBaseAddr + 0x90E35);
		constexpr uint32 size = 8;
		/*
		dmc3.exe+90E2D - 41 8B 84 94 C02DC900 - MOV EAX,[R12+RDX*4+00C92DC0]
		dmc3.exe+90E35
		*/

		static Function func = {};

		constexpr byte8 sect0[] =
		{
			0x51 ,
			0x48, 0x8B, 0xCF ,
			0xE8, 0x00, 0x00, 0x00, 0x00 ,
			0x59 ,
			0x8B, 0x84, 0x90, 0x00, 0x00, 0x00, 0x00, // mov eax,[rax+rdx*4+0000B8C0]
		};

		if (!run)
		{
			backupHelper.Save(addr, size);
			func = CreateFunction(0, jumpAddr, false, false, sizeof(sect0));
			CopyMemory(func.sect0, sect0, sizeof(sect0));
			WriteCall((func.sect0 + 4), GetActorBaseAddressByEffectData);
			*reinterpret_cast<uint32 *>(func.sect0 + 0xD) = __builtin_offsetof(ActorData, newEffectIndices[0]) ;
		}

		if (enable)
		{
			WriteJump(addr, func.addr, (size - 5));
		}
		else
		{
			backupHelper.Restore(addr);
		}
	}
	{
		auto addr     = (appBaseAddr + 0x90E5C);
		auto jumpAddr = (appBaseAddr + 0x90E64);
		constexpr uint32 size = 8;
		/*
		dmc3.exe+90E5C - 41 31 9C 94 C02DC900 - XOR [R12+RDX*4+00C92DC0],EBX
		dmc3.exe+90E64
		*/

		static Function func = {};

		constexpr byte8 sect0[] =
		{
			0x51 ,
			0x50 ,
			0x48, 0x8B, 0xCF ,
			0xE8, 0x00, 0x00, 0x00, 0x00 ,
			0x48, 0x8B, 0xC8 ,
			0x58 ,
			0x31, 0x9C, 0x91, 0x00, 0x00, 0x00, 0x00, // xor [rcx+rdx*4+0000B8C0],ebx
			0x59 ,
		};

		if (!run)
		{
			backupHelper.Save(addr, size);
			func = CreateFunction(0, jumpAddr, false, false, sizeof(sect0));
			CopyMemory(func.sect0, sect0, sizeof(sect0));
			WriteCall((func.sect0 + 5), GetActorBaseAddressByEffectData);
			*reinterpret_cast<uint32 *>(func.sect0 + 0x11) = __builtin_offsetof(ActorData, newEffectIndices[0]) ;
		}

		if (enable)
		{
			WriteJump(addr, func.addr, (size - 5));
		}
		else
		{
			backupHelper.Restore(addr);
		}
	}
	{
		auto addr     = (appBaseAddr + 0x90F3A);
		auto jumpAddr = (appBaseAddr + 0x90F42);
		constexpr uint32 size = 8;
		/*
		dmc3.exe+90F3A - 41 8B 84 94 C02DC900 - MOV EAX,[R12+RDX*4+00C92DC0]
		dmc3.exe+90F42
		*/

		static Function func = {};

		constexpr byte8 sect0[] =
		{
			0x51 ,
			0x48, 0x8B, 0xCF ,
			0xE8, 0x00, 0x00, 0x00, 0x00 ,
			0x59 ,
			0x8B, 0x84, 0x90, 0x00, 0x00, 0x00, 0x00, // mov eax,[rax+rdx*4+0000B8C0]
		};

		if (!run)
		{
			backupHelper.Save(addr, size);
			func = CreateFunction(0, jumpAddr, false, false, sizeof(sect0));
			CopyMemory(func.sect0, sect0, sizeof(sect0));
			WriteCall((func.sect0 + 4), GetActorBaseAddressByEffectData);
			*reinterpret_cast<uint32 *>(func.sect0 + 0xD) = __builtin_offsetof(ActorData, newEffectIndices[0]) ;
		}

		if (enable)
		{
			WriteJump(addr, func.addr, (size - 5));
		}
		else
		{
			backupHelper.Restore(addr);
		}
	}
	{
		auto addr     = (appBaseAddr + 0x90F70);
		auto jumpAddr = (appBaseAddr + 0x90F78);
		constexpr uint32 size = 8;
		/*
		dmc3.exe+90F70 - 41 31 84 94 C02DC900 - XOR [R12+RDX*4+00C92DC0],EAX
		dmc3.exe+90F78
		*/

		static Function func = {};

		constexpr byte8 sect0[] =
		{
			0x51 ,
			0x50 ,
			0x48, 0x8B, 0xCF ,
			0xE8, 0x00, 0x00, 0x00, 0x00 ,
			0x48, 0x8B, 0xC8 ,
			0x58 ,
			0x31, 0x84, 0x91, 0x00, 0x00, 0x00, 0x00, // xor [rcx+rdx*4+0000B8C0],eax
			0x59 ,
		};

		if (!run)
		{
			backupHelper.Save(addr, size);
			func = CreateFunction(0, jumpAddr, false, false, sizeof(sect0));
			CopyMemory(func.sect0, sect0, sizeof(sect0));
			WriteCall((func.sect0 + 5), GetActorBaseAddressByEffectData);
			*reinterpret_cast<uint32 *>(func.sect0 + 0x11) = __builtin_offsetof(ActorData, newEffectIndices[0]) ;
		}

		if (enable)
		{
			WriteJump(addr, func.addr, (size - 5));
		}
		else
		{
			backupHelper.Restore(addr);
		}
	}
	{
		auto addr     = (appBaseAddr + 0x91021);
		auto jumpAddr = (appBaseAddr + 0x91029);
		constexpr uint32 size = 8;
		/*
		dmc3.exe+91021 - 41 8B 84 94 C02DC900 - MOV EAX,[R12+RDX*4+00C92DC0]
		dmc3.exe+91029
		*/

		static Function func = {};

		constexpr byte8 sect0[] =
		{
			0x51 ,
			0x48, 0x8B, 0xCF ,
			0xE8, 0x00, 0x00, 0x00, 0x00 ,
			0x59 ,
			0x8B, 0x84, 0x90, 0x00, 0x00, 0x00, 0x00, // mov eax,[rax+rdx*4+0000B8C0]
		};

		if (!run)
		{
			backupHelper.Save(addr, size);
			func = CreateFunction(0, jumpAddr, false, false, sizeof(sect0));
			CopyMemory(func.sect0, sect0, sizeof(sect0));
			WriteCall((func.sect0 + 4), GetActorBaseAddressByEffectData);
			*reinterpret_cast<uint32 *>(func.sect0 + 0xD) = __builtin_offsetof(ActorData, newEffectIndices[0]) ;
		}

		if (enable)
		{
			WriteJump(addr, func.addr, (size - 5));
		}
		else
		{
			backupHelper.Restore(addr);
		}
	}
	{
		auto addr     = (appBaseAddr + 0x91076);
		auto jumpAddr = (appBaseAddr + 0x9107E);
		constexpr uint32 size = 8;
		/*
		dmc3.exe+91076 - 41 8B 84 94 C02DC900 - MOV EAX,[R12+RDX*4+00C92DC0]
		dmc3.exe+9107E
		*/

		static Function func = {};

		constexpr byte8 sect0[] =
		{
			0x51 ,
			0x48, 0x8B, 0xCF ,
			0xE8, 0x00, 0x00, 0x00, 0x00 ,
			0x59 ,
			0x8B, 0x84, 0x90, 0x00, 0x00, 0x00, 0x00, // mov eax,[rax+rdx*4+0000B8C0]
		};

		if (!run)
		{
			backupHelper.Save(addr, size);
			func = CreateFunction(0, jumpAddr, false, false, sizeof(sect0));
			CopyMemory(func.sect0, sect0, sizeof(sect0));
			WriteCall((func.sect0 + 4), GetActorBaseAddressByEffectData);
			*reinterpret_cast<uint32 *>(func.sect0 + 0xD) = __builtin_offsetof(ActorData, newEffectIndices[0]) ;
		}

		if (enable)
		{
			WriteJump(addr, func.addr, (size - 5));
		}
		else
		{
			backupHelper.Restore(addr);
		}
	}
	{
		auto addr     = (appBaseAddr + 0x910F3);
		auto jumpAddr = (appBaseAddr + 0x910FB);
		constexpr uint32 size = 8;
		/*
		dmc3.exe+910F3 - 41 8B 84 94 C02DC900 - MOV EAX,[R12+RDX*4+00C92DC0]
		dmc3.exe+910FB
		*/

		static Function func = {};

		constexpr byte8 sect0[] =
		{
			0x51 ,
			0x48, 0x8B, 0xCF ,
			0xE8, 0x00, 0x00, 0x00, 0x00 ,
			0x59 ,
			0x8B, 0x84, 0x90, 0x00, 0x00, 0x00, 0x00, // mov eax,[rax+rdx*4+0000B8C0]
		};

		if (!run)
		{
			backupHelper.Save(addr, size);
			func = CreateFunction(0, jumpAddr, false, false, sizeof(sect0));
			CopyMemory(func.sect0, sect0, sizeof(sect0));
			WriteCall((func.sect0 + 4), GetActorBaseAddressByEffectData);
			*reinterpret_cast<uint32 *>(func.sect0 + 0xD) = __builtin_offsetof(ActorData, newEffectIndices[0]) ;
		}

		if (enable)
		{
			WriteJump(addr, func.addr, (size - 5));
		}
		else
		{
			backupHelper.Restore(addr);
		}
	}
	{
		auto addr     = (appBaseAddr + 0x91126);
		auto jumpAddr = (appBaseAddr + 0x9112E);
		constexpr uint32 size = 8;
		/*
		dmc3.exe+91126 - 41 31 9C 94 C02DC900 - XOR [R12+RDX*4+00C92DC0],EBX
		dmc3.exe+9112E
		*/

		static Function func = {};

		constexpr byte8 sect0[] =
		{
			0x51 ,
			0x50 ,
			0x48, 0x8B, 0xCF ,
			0xE8, 0x00, 0x00, 0x00, 0x00 ,
			0x48, 0x8B, 0xC8 ,
			0x58 ,
			0x31, 0x9C, 0x91, 0x00, 0x00, 0x00, 0x00, // xor [rcx+rdx*4+0000B8C0],ebx
			0x59 ,
		};

		if (!run)
		{
			backupHelper.Save(addr, size);
			func = CreateFunction(0, jumpAddr, false, false, sizeof(sect0));
			CopyMemory(func.sect0, sect0, sizeof(sect0));
			WriteCall((func.sect0 + 5), GetActorBaseAddressByEffectData);
			*reinterpret_cast<uint32 *>(func.sect0 + 0x11) = __builtin_offsetof(ActorData, newEffectIndices[0]) ;
		}

		if (enable)
		{
			WriteJump(addr, func.addr, (size - 5));
		}
		else
		{
			backupHelper.Restore(addr);
		}
	}
	{
		auto addr     = (appBaseAddr + 0x911B2);
		auto jumpAddr = (appBaseAddr + 0x911BA);
		constexpr uint32 size = 8;
		/*
		dmc3.exe+911B2 - 41 8B 84 94 C02DC900 - MOV EAX,[R12+RDX*4+00C92DC0]
		dmc3.exe+911BA
		*/

		static Function func = {};

		constexpr byte8 sect0[] =
		{
			0x51 ,
			0x48, 0x8B, 0xCF ,
			0xE8, 0x00, 0x00, 0x00, 0x00 ,
			0x59 ,
			0x8B, 0x84, 0x90, 0x00, 0x00, 0x00, 0x00, // mov eax,[rax+rdx*4+0000B8C0]
		};

		if (!run)
		{
			backupHelper.Save(addr, size);
			func = CreateFunction(0, jumpAddr, false, false, sizeof(sect0));
			CopyMemory(func.sect0, sect0, sizeof(sect0));
			WriteCall((func.sect0 + 4), GetActorBaseAddressByEffectData);
			*reinterpret_cast<uint32 *>(func.sect0 + 0xD) = __builtin_offsetof(ActorData, newEffectIndices[0]) ;
		}

		if (enable)
		{
			WriteJump(addr, func.addr, (size - 5));
		}
		else
		{
			backupHelper.Restore(addr);
		}
	}
	{
		auto addr     = (appBaseAddr + 0x91217);
		auto jumpAddr = (appBaseAddr + 0x9121F);
		constexpr uint32 size = 8;
		/*
		dmc3.exe+91217 - 41 8B 84 94 C02DC900 - MOV EAX,[R12+RDX*4+00C92DC0]
		dmc3.exe+9121F
		*/

		static Function func = {};

		constexpr byte8 sect0[] =
		{
			0x51 ,
			0x48, 0x8B, 0xCF ,
			0xE8, 0x00, 0x00, 0x00, 0x00 ,
			0x59 ,
			0x8B, 0x84, 0x90, 0x00, 0x00, 0x00, 0x00, // mov eax,[rax+rdx*4+0000B8C0]
		};

		if (!run)
		{
			backupHelper.Save(addr, size);
			func = CreateFunction(0, jumpAddr, false, false, sizeof(sect0));
			CopyMemory(func.sect0, sect0, sizeof(sect0));
			WriteCall((func.sect0 + 4), GetActorBaseAddressByEffectData);
			*reinterpret_cast<uint32 *>(func.sect0 + 0xD) = __builtin_offsetof(ActorData, newEffectIndices[0]) ;
		}

		if (enable)
		{
			WriteJump(addr, func.addr, (size - 5));
		}
		else
		{
			backupHelper.Restore(addr);
		}
	}
	{
		auto addr     = (appBaseAddr + 0x91266);
		auto jumpAddr = (appBaseAddr + 0x9126E);
		constexpr uint32 size = 8;
		/*
		dmc3.exe+91266 - 41 8B 84 94 C02DC900 - MOV EAX,[R12+RDX*4+00C92DC0]
		dmc3.exe+9126E
		*/

		static Function func = {};

		constexpr byte8 sect0[] =
		{
			0x51 ,
			0x48, 0x8B, 0xCF ,
			0xE8, 0x00, 0x00, 0x00, 0x00 ,
			0x59 ,
			0x8B, 0x84, 0x90, 0x00, 0x00, 0x00, 0x00, // mov eax,[rax+rdx*4+0000B8C0]
		};

		if (!run)
		{
			backupHelper.Save(addr, size);
			func = CreateFunction(0, jumpAddr, false, false, sizeof(sect0));
			CopyMemory(func.sect0, sect0, sizeof(sect0));
			WriteCall((func.sect0 + 4), GetActorBaseAddressByEffectData);
			*reinterpret_cast<uint32 *>(func.sect0 + 0xD) = __builtin_offsetof(ActorData, newEffectIndices[0]) ;
		}

		if (enable)
		{
			WriteJump(addr, func.addr, (size - 5));
		}
		else
		{
			backupHelper.Restore(addr);
		}
	}
	{
		auto addr     = (appBaseAddr + 0x912D5);
		auto jumpAddr = (appBaseAddr + 0x912DD);
		constexpr uint32 size = 8;
		/*
		dmc3.exe+912D5 - 41 8B 84 94 C02DC900 - MOV EAX,[R12+RDX*4+00C92DC0]
		dmc3.exe+912DD
		*/

		static Function func = {};

		constexpr byte8 sect0[] =
		{
			0x51 ,
			0x48, 0x8B, 0xCF ,
			0xE8, 0x00, 0x00, 0x00, 0x00 ,
			0x59 ,
			0x8B, 0x84, 0x90, 0x00, 0x00, 0x00, 0x00, // mov eax,[rax+rdx*4+0000B8C0]
		};

		if (!run)
		{
			backupHelper.Save(addr, size);
			func = CreateFunction(0, jumpAddr, false, false, sizeof(sect0));
			CopyMemory(func.sect0, sect0, sizeof(sect0));
			WriteCall((func.sect0 + 4), GetActorBaseAddressByEffectData);
			*reinterpret_cast<uint32 *>(func.sect0 + 0xD) = __builtin_offsetof(ActorData, newEffectIndices[0]) ;
		}

		if (enable)
		{
			WriteJump(addr, func.addr, (size - 5));
		}
		else
		{
			backupHelper.Restore(addr);
		}
	}
	{
		auto addr     = (appBaseAddr + 0x912FB);
		auto jumpAddr = (appBaseAddr + 0x91303);
		constexpr uint32 size = 8;
		/*
		dmc3.exe+912FB - 41 31 9C 94 C02DC900 - XOR [R12+RDX*4+00C92DC0],EBX
		dmc3.exe+91303
		*/

		static Function func = {};

		constexpr byte8 sect0[] =
		{
			0x51 ,
			0x50 ,
			0x48, 0x8B, 0xCF ,
			0xE8, 0x00, 0x00, 0x00, 0x00 ,
			0x48, 0x8B, 0xC8 ,
			0x58 ,
			0x31, 0x9C, 0x91, 0x00, 0x00, 0x00, 0x00, // xor [rcx+rdx*4+0000B8C0],ebx
			0x59 ,
		};

		if (!run)
		{
			backupHelper.Save(addr, size);
			func = CreateFunction(0, jumpAddr, false, false, sizeof(sect0));
			CopyMemory(func.sect0, sect0, sizeof(sect0));
			WriteCall((func.sect0 + 5), GetActorBaseAddressByEffectData);
			*reinterpret_cast<uint32 *>(func.sect0 + 0x11) = __builtin_offsetof(ActorData, newEffectIndices[0]) ;
		}

		if (enable)
		{
			WriteJump(addr, func.addr, (size - 5));
		}
		else
		{
			backupHelper.Restore(addr);
		}
	}
	{
		auto addr     = (appBaseAddr + 0x91351);
		auto jumpAddr = (appBaseAddr + 0x91359);
		constexpr uint32 size = 8;
		/*
		dmc3.exe+91351 - 41 8B 84 94 C02DC900 - MOV EAX,[R12+RDX*4+00C92DC0]
		dmc3.exe+91359
		*/

		static Function func = {};

		constexpr byte8 sect0[] =
		{
			0x51 ,
			0x48, 0x8B, 0xCF ,
			0xE8, 0x00, 0x00, 0x00, 0x00 ,
			0x59 ,
			0x8B, 0x84, 0x90, 0x00, 0x00, 0x00, 0x00, // mov eax,[rax+rdx*4+0000B8C0]
		};

		if (!run)
		{
			backupHelper.Save(addr, size);
			func = CreateFunction(0, jumpAddr, false, false, sizeof(sect0));
			CopyMemory(func.sect0, sect0, sizeof(sect0));
			WriteCall((func.sect0 + 4), GetActorBaseAddressByEffectData);
			*reinterpret_cast<uint32 *>(func.sect0 + 0xD) = __builtin_offsetof(ActorData, newEffectIndices[0]) ;
		}

		if (enable)
		{
			WriteJump(addr, func.addr, (size - 5));
		}
		else
		{
			backupHelper.Restore(addr);
		}
	}
	{
		auto addr     = (appBaseAddr + 0x913A0);
		auto jumpAddr = (appBaseAddr + 0x913A8);
		constexpr uint32 size = 8;
		/*
		dmc3.exe+913A0 - 41 8B 84 94 C02DC900 - MOV EAX,[R12+RDX*4+00C92DC0]
		dmc3.exe+913A8
		*/

		static Function func = {};

		constexpr byte8 sect0[] =
		{
			0x51 ,
			0x48, 0x8B, 0xCF ,
			0xE8, 0x00, 0x00, 0x00, 0x00 ,
			0x59 ,
			0x8B, 0x84, 0x90, 0x00, 0x00, 0x00, 0x00, // mov eax,[rax+rdx*4+0000B8C0]
		};

		if (!run)
		{
			backupHelper.Save(addr, size);
			func = CreateFunction(0, jumpAddr, false, false, sizeof(sect0));
			CopyMemory(func.sect0, sect0, sizeof(sect0));
			WriteCall((func.sect0 + 4), GetActorBaseAddressByEffectData);
			*reinterpret_cast<uint32 *>(func.sect0 + 0xD) = __builtin_offsetof(ActorData, newEffectIndices[0]) ;
		}

		if (enable)
		{
			WriteJump(addr, func.addr, (size - 5));
		}
		else
		{
			backupHelper.Restore(addr);
		}
	}
	{
		auto addr     = (appBaseAddr + 0x913EF);
		auto jumpAddr = (appBaseAddr + 0x913F7);
		constexpr uint32 size = 8;
		/*
		dmc3.exe+913EF - 41 8B 84 94 C02DC900 - MOV EAX,[R12+RDX*4+00C92DC0]
		dmc3.exe+913F7
		*/

		static Function func = {};

		constexpr byte8 sect0[] =
		{
			0x51 ,
			0x48, 0x8B, 0xCF ,
			0xE8, 0x00, 0x00, 0x00, 0x00 ,
			0x59 ,
			0x8B, 0x84, 0x90, 0x00, 0x00, 0x00, 0x00, // mov eax,[rax+rdx*4+0000B8C0]
		};

		if (!run)
		{
			backupHelper.Save(addr, size);
			func = CreateFunction(0, jumpAddr, false, false, sizeof(sect0));
			CopyMemory(func.sect0, sect0, sizeof(sect0));
			WriteCall((func.sect0 + 4), GetActorBaseAddressByEffectData);
			*reinterpret_cast<uint32 *>(func.sect0 + 0xD) = __builtin_offsetof(ActorData, newEffectIndices[0]) ;
		}

		if (enable)
		{
			WriteJump(addr, func.addr, (size - 5));
		}
		else
		{
			backupHelper.Restore(addr);
		}
	}
	{
		auto addr     = (appBaseAddr + 0x91457);
		auto jumpAddr = (appBaseAddr + 0x9145F);
		constexpr uint32 size = 8;
		/*
		dmc3.exe+91457 - 41 8B 84 94 C02DC900 - MOV EAX,[R12+RDX*4+00C92DC0]
		dmc3.exe+9145F
		*/

		static Function func = {};

		constexpr byte8 sect0[] =
		{
			0x51 ,
			0x48, 0x8B, 0xCF ,
			0xE8, 0x00, 0x00, 0x00, 0x00 ,
			0x59 ,
			0x8B, 0x84, 0x90, 0x00, 0x00, 0x00, 0x00, // mov eax,[rax+rdx*4+0000B8C0]
		};

		if (!run)
		{
			backupHelper.Save(addr, size);
			func = CreateFunction(0, jumpAddr, false, false, sizeof(sect0));
			CopyMemory(func.sect0, sect0, sizeof(sect0));
			WriteCall((func.sect0 + 4), GetActorBaseAddressByEffectData);
			*reinterpret_cast<uint32 *>(func.sect0 + 0xD) = __builtin_offsetof(ActorData, newEffectIndices[0]) ;
		}

		if (enable)
		{
			WriteJump(addr, func.addr, (size - 5));
		}
		else
		{
			backupHelper.Restore(addr);
		}
	}
	{
		auto addr     = (appBaseAddr + 0x914A0);
		auto jumpAddr = (appBaseAddr + 0x914A8);
		constexpr uint32 size = 8;
		/*
		dmc3.exe+914A0 - 41 8B 84 94 C02DC900 - MOV EAX,[R12+RDX*4+00C92DC0]
		dmc3.exe+914A8
		*/

		static Function func = {};

		constexpr byte8 sect0[] =
		{
			0x51 ,
			0x48, 0x8B, 0xCF ,
			0xE8, 0x00, 0x00, 0x00, 0x00 ,
			0x59 ,
			0x8B, 0x84, 0x90, 0x00, 0x00, 0x00, 0x00, // mov eax,[rax+rdx*4+0000B8C0]
		};

		if (!run)
		{
			backupHelper.Save(addr, size);
			func = CreateFunction(0, jumpAddr, false, false, sizeof(sect0));
			CopyMemory(func.sect0, sect0, sizeof(sect0));
			WriteCall((func.sect0 + 4), GetActorBaseAddressByEffectData);
			*reinterpret_cast<uint32 *>(func.sect0 + 0xD) = __builtin_offsetof(ActorData, newEffectIndices[0]) ;
		}

		if (enable)
		{
			WriteJump(addr, func.addr, (size - 5));
		}
		else
		{
			backupHelper.Restore(addr);
		}
	}
	{
		auto addr     = (appBaseAddr + 0x9150F);
		auto jumpAddr = (appBaseAddr + 0x91517);
		constexpr uint32 size = 8;
		/*
		dmc3.exe+9150F - 41 8B 84 94 C02DC900 - MOV EAX,[R12+RDX*4+00C92DC0]
		dmc3.exe+91517
		*/

		static Function func = {};

		constexpr byte8 sect0[] =
		{
			0x51 ,
			0x48, 0x8B, 0xCF ,
			0xE8, 0x00, 0x00, 0x00, 0x00 ,
			0x59 ,
			0x8B, 0x84, 0x90, 0x00, 0x00, 0x00, 0x00, // mov eax,[rax+rdx*4+0000B8C0]
		};

		if (!run)
		{
			backupHelper.Save(addr, size);
			func = CreateFunction(0, jumpAddr, false, false, sizeof(sect0));
			CopyMemory(func.sect0, sect0, sizeof(sect0));
			WriteCall((func.sect0 + 4), GetActorBaseAddressByEffectData);
			*reinterpret_cast<uint32 *>(func.sect0 + 0xD) = __builtin_offsetof(ActorData, newEffectIndices[0]) ;
		}

		if (enable)
		{
			WriteJump(addr, func.addr, (size - 5));
		}
		else
		{
			backupHelper.Restore(addr);
		}
	}
	{
		auto addr     = (appBaseAddr + 0x91535);
		auto jumpAddr = (appBaseAddr + 0x9153D);
		constexpr uint32 size = 8;
		/*
		dmc3.exe+91535 - 41 31 9C 94 C02DC900 - XOR [R12+RDX*4+00C92DC0],EBX
		dmc3.exe+9153D
		*/

		static Function func = {};

		constexpr byte8 sect0[] =
		{
			0x51 ,
			0x50 ,
			0x48, 0x8B, 0xCF ,
			0xE8, 0x00, 0x00, 0x00, 0x00 ,
			0x48, 0x8B, 0xC8 ,
			0x58 ,
			0x31, 0x9C, 0x91, 0x00, 0x00, 0x00, 0x00, // xor [rcx+rdx*4+0000B8C0],ebx
			0x59 ,
		};

		if (!run)
		{
			backupHelper.Save(addr, size);
			func = CreateFunction(0, jumpAddr, false, false, sizeof(sect0));
			CopyMemory(func.sect0, sect0, sizeof(sect0));
			WriteCall((func.sect0 + 5), GetActorBaseAddressByEffectData);
			*reinterpret_cast<uint32 *>(func.sect0 + 0x11) = __builtin_offsetof(ActorData, newEffectIndices[0]) ;
		}

		if (enable)
		{
			WriteJump(addr, func.addr, (size - 5));
		}
		else
		{
			backupHelper.Restore(addr);
		}
	}
	{
		auto addr     = (appBaseAddr + 0x9159B);
		auto jumpAddr = (appBaseAddr + 0x915A3);
		constexpr uint32 size = 8;
		/*
		dmc3.exe+9159B - 41 8B 84 94 C02DC900 - MOV EAX,[R12+RDX*4+00C92DC0]
		dmc3.exe+915A3
		*/

		static Function func = {};

		constexpr byte8 sect0[] =
		{
			0x51 ,
			0x48, 0x8B, 0xCF ,
			0xE8, 0x00, 0x00, 0x00, 0x00 ,
			0x59 ,
			0x8B, 0x84, 0x90, 0x00, 0x00, 0x00, 0x00, // mov eax,[rax+rdx*4+0000B8C0]
		};

		if (!run)
		{
			backupHelper.Save(addr, size);
			func = CreateFunction(0, jumpAddr, false, false, sizeof(sect0));
			CopyMemory(func.sect0, sect0, sizeof(sect0));
			WriteCall((func.sect0 + 4), GetActorBaseAddressByEffectData);
			*reinterpret_cast<uint32 *>(func.sect0 + 0xD) = __builtin_offsetof(ActorData, newEffectIndices[0]) ;
		}

		if (enable)
		{
			WriteJump(addr, func.addr, (size - 5));
		}
		else
		{
			backupHelper.Restore(addr);
		}
	}
	{
		auto addr     = (appBaseAddr + 0x915E7);
		auto jumpAddr = (appBaseAddr + 0x915EF);
		constexpr uint32 size = 8;
		/*
		dmc3.exe+915E7 - 41 8B 84 94 C02DC900 - MOV EAX,[R12+RDX*4+00C92DC0]
		dmc3.exe+915EF
		*/

		static Function func = {};

		constexpr byte8 sect0[] =
		{
			0x51 ,
			0x48, 0x8B, 0xCF ,
			0xE8, 0x00, 0x00, 0x00, 0x00 ,
			0x59 ,
			0x8B, 0x84, 0x90, 0x00, 0x00, 0x00, 0x00, // mov eax,[rax+rdx*4+0000B8C0]
		};

		if (!run)
		{
			backupHelper.Save(addr, size);
			func = CreateFunction(0, jumpAddr, false, false, sizeof(sect0));
			CopyMemory(func.sect0, sect0, sizeof(sect0));
			WriteCall((func.sect0 + 4), GetActorBaseAddressByEffectData);
			*reinterpret_cast<uint32 *>(func.sect0 + 0xD) = __builtin_offsetof(ActorData, newEffectIndices[0]) ;
		}

		if (enable)
		{
			WriteJump(addr, func.addr, (size - 5));
		}
		else
		{
			backupHelper.Restore(addr);
		}
	}
	{
		auto addr     = (appBaseAddr + 0x9161C);
		auto jumpAddr = (appBaseAddr + 0x91624);
		constexpr uint32 size = 8;
		/*
		dmc3.exe+9161C - 41 8B 84 94 C02DC900 - MOV EAX,[R12+RDX*4+00C92DC0]
		dmc3.exe+91624
		*/

		static Function func = {};

		constexpr byte8 sect0[] =
		{
			0x51 ,
			0x48, 0x8B, 0xCF ,
			0xE8, 0x00, 0x00, 0x00, 0x00 ,
			0x59 ,
			0x8B, 0x84, 0x90, 0x00, 0x00, 0x00, 0x00, // mov eax,[rax+rdx*4+0000B8C0]
		};

		if (!run)
		{
			backupHelper.Save(addr, size);
			func = CreateFunction(0, jumpAddr, false, false, sizeof(sect0));
			CopyMemory(func.sect0, sect0, sizeof(sect0));
			WriteCall((func.sect0 + 4), GetActorBaseAddressByEffectData);
			*reinterpret_cast<uint32 *>(func.sect0 + 0xD) = __builtin_offsetof(ActorData, newEffectIndices[0]) ;
		}

		if (enable)
		{
			WriteJump(addr, func.addr, (size - 5));
		}
		else
		{
			backupHelper.Restore(addr);
		}
	}
	{
		auto addr     = (appBaseAddr + 0x916F6);
		auto jumpAddr = (appBaseAddr + 0x916FE);
		constexpr uint32 size = 8;
		/*
		dmc3.exe+916F6 - 41 8B 84 94 C02DC900 - MOV EAX,[R12+RDX*4+00C92DC0]
		dmc3.exe+916FE
		*/

		static Function func = {};

		constexpr byte8 sect0[] =
		{
			0x51 ,
			0x48, 0x8B, 0xCF ,
			0xE8, 0x00, 0x00, 0x00, 0x00 ,
			0x59 ,
			0x8B, 0x84, 0x90, 0x00, 0x00, 0x00, 0x00, // mov eax,[rax+rdx*4+0000B8C0]
		};

		if (!run)
		{
			backupHelper.Save(addr, size);
			func = CreateFunction(0, jumpAddr, false, false, sizeof(sect0));
			CopyMemory(func.sect0, sect0, sizeof(sect0));
			WriteCall((func.sect0 + 4), GetActorBaseAddressByEffectData);
			*reinterpret_cast<uint32 *>(func.sect0 + 0xD) = __builtin_offsetof(ActorData, newEffectIndices[0]) ;
		}

		if (enable)
		{
			WriteJump(addr, func.addr, (size - 5));
		}
		else
		{
			backupHelper.Restore(addr);
		}
	}
	{
		auto addr     = (appBaseAddr + 0x9171F);
		auto jumpAddr = (appBaseAddr + 0x91727);
		constexpr uint32 size = 8;
		/*
		dmc3.exe+9171F - 41 8B 84 94 C02DC900 - MOV EAX,[R12+RDX*4+00C92DC0]
		dmc3.exe+91727
		*/

		static Function func = {};

		constexpr byte8 sect0[] =
		{
			0x51 ,
			0x48, 0x8B, 0xCF ,
			0xE8, 0x00, 0x00, 0x00, 0x00 ,
			0x59 ,
			0x8B, 0x84, 0x90, 0x00, 0x00, 0x00, 0x00, // mov eax,[rax+rdx*4+0000B8C0]
		};

		if (!run)
		{
			backupHelper.Save(addr, size);
			func = CreateFunction(0, jumpAddr, false, false, sizeof(sect0));
			CopyMemory(func.sect0, sect0, sizeof(sect0));
			WriteCall((func.sect0 + 4), GetActorBaseAddressByEffectData);
			*reinterpret_cast<uint32 *>(func.sect0 + 0xD) = __builtin_offsetof(ActorData, newEffectIndices[0]) ;
		}

		if (enable)
		{
			WriteJump(addr, func.addr, (size - 5));
		}
		else
		{
			backupHelper.Restore(addr);
		}
	}
	{
		auto addr     = (appBaseAddr + 0x9174B);
		auto jumpAddr = (appBaseAddr + 0x91753);
		constexpr uint32 size = 8;
		/*
		dmc3.exe+9174B - 41 31 9C 94 C02DC900 - XOR [R12+RDX*4+00C92DC0],EBX
		dmc3.exe+91753
		*/

		static Function func = {};

		constexpr byte8 sect0[] =
		{
			0x51 ,
			0x50 ,
			0x48, 0x8B, 0xCF ,
			0xE8, 0x00, 0x00, 0x00, 0x00 ,
			0x48, 0x8B, 0xC8 ,
			0x58 ,
			0x31, 0x9C, 0x91, 0x00, 0x00, 0x00, 0x00, // xor [rcx+rdx*4+0000B8C0],ebx
			0x59 ,
		};

		if (!run)
		{
			backupHelper.Save(addr, size);
			func = CreateFunction(0, jumpAddr, false, false, sizeof(sect0));
			CopyMemory(func.sect0, sect0, sizeof(sect0));
			WriteCall((func.sect0 + 5), GetActorBaseAddressByEffectData);
			*reinterpret_cast<uint32 *>(func.sect0 + 0x11) = __builtin_offsetof(ActorData, newEffectIndices[0]) ;
		}

		if (enable)
		{
			WriteJump(addr, func.addr, (size - 5));
		}
		else
		{
			backupHelper.Restore(addr);
		}
	}
	{
		auto addr     = (appBaseAddr + 0x917CF);
		auto jumpAddr = (appBaseAddr + 0x917D7);
		constexpr uint32 size = 8;
		/*
		dmc3.exe+917CF - 41 8B 84 94 C02DC900 - MOV EAX,[R12+RDX*4+00C92DC0]
		dmc3.exe+917D7
		*/

		static Function func = {};

		constexpr byte8 sect0[] =
		{
			0x51 ,
			0x48, 0x8B, 0xCF ,
			0xE8, 0x00, 0x00, 0x00, 0x00 ,
			0x59 ,
			0x8B, 0x84, 0x90, 0x00, 0x00, 0x00, 0x00, // mov eax,[rax+rdx*4+0000B8C0]
		};

		if (!run)
		{
			backupHelper.Save(addr, size);
			func = CreateFunction(0, jumpAddr, false, false, sizeof(sect0));
			CopyMemory(func.sect0, sect0, sizeof(sect0));
			WriteCall((func.sect0 + 4), GetActorBaseAddressByEffectData);
			*reinterpret_cast<uint32 *>(func.sect0 + 0xD) = __builtin_offsetof(ActorData, newEffectIndices[0]) ;
		}

		if (enable)
		{
			WriteJump(addr, func.addr, (size - 5));
		}
		else
		{
			backupHelper.Restore(addr);
		}
	}
	{
		auto addr     = (appBaseAddr + 0x917FB);
		auto jumpAddr = (appBaseAddr + 0x91803);
		constexpr uint32 size = 8;
		/*
		dmc3.exe+917FB - 41 31 9C 94 C02DC900 - XOR [R12+RDX*4+00C92DC0],EBX
		dmc3.exe+91803
		*/

		static Function func = {};

		constexpr byte8 sect0[] =
		{
			0x51 ,
			0x50 ,
			0x48, 0x8B, 0xCF ,
			0xE8, 0x00, 0x00, 0x00, 0x00 ,
			0x48, 0x8B, 0xC8 ,
			0x58 ,
			0x31, 0x9C, 0x91, 0x00, 0x00, 0x00, 0x00, // xor [rcx+rdx*4+0000B8C0],ebx
			0x59 ,
		};

		if (!run)
		{
			backupHelper.Save(addr, size);
			func = CreateFunction(0, jumpAddr, false, false, sizeof(sect0));
			CopyMemory(func.sect0, sect0, sizeof(sect0));
			WriteCall((func.sect0 + 5), GetActorBaseAddressByEffectData);
			*reinterpret_cast<uint32 *>(func.sect0 + 0x11) = __builtin_offsetof(ActorData, newEffectIndices[0]) ;
		}

		if (enable)
		{
			WriteJump(addr, func.addr, (size - 5));
		}
		else
		{
			backupHelper.Restore(addr);
		}
	}
	{
		auto addr     = (appBaseAddr + 0x91848);
		auto jumpAddr = (appBaseAddr + 0x91850);
		constexpr uint32 size = 8;
		/*
		dmc3.exe+91848 - 41 8B 84 94 C02DC900 - MOV EAX,[R12+RDX*4+00C92DC0]
		dmc3.exe+91850
		*/

		static Function func = {};

		constexpr byte8 sect0[] =
		{
			0x51 ,
			0x48, 0x8B, 0xCF ,
			0xE8, 0x00, 0x00, 0x00, 0x00 ,
			0x59 ,
			0x8B, 0x84, 0x90, 0x00, 0x00, 0x00, 0x00, // mov eax,[rax+rdx*4+0000B8C0]
		};

		if (!run)
		{
			backupHelper.Save(addr, size);
			func = CreateFunction(0, jumpAddr, false, false, sizeof(sect0));
			CopyMemory(func.sect0, sect0, sizeof(sect0));
			WriteCall((func.sect0 + 4), GetActorBaseAddressByEffectData);
			*reinterpret_cast<uint32 *>(func.sect0 + 0xD) = __builtin_offsetof(ActorData, newEffectIndices[0]) ;
		}

		if (enable)
		{
			WriteJump(addr, func.addr, (size - 5));
		}
		else
		{
			backupHelper.Restore(addr);
		}
	}
	{
		auto addr     = (appBaseAddr + 0x91874);
		auto jumpAddr = (appBaseAddr + 0x9187C);
		constexpr uint32 size = 8;
		/*
		dmc3.exe+91874 - 41 31 9C 94 C02DC900 - XOR [R12+RDX*4+00C92DC0],EBX
		dmc3.exe+9187C
		*/

		static Function func = {};

		constexpr byte8 sect0[] =
		{
			0x51 ,
			0x50 ,
			0x48, 0x8B, 0xCF ,
			0xE8, 0x00, 0x00, 0x00, 0x00 ,
			0x48, 0x8B, 0xC8 ,
			0x58 ,
			0x31, 0x9C, 0x91, 0x00, 0x00, 0x00, 0x00, // xor [rcx+rdx*4+0000B8C0],ebx
			0x59 ,
		};

		if (!run)
		{
			backupHelper.Save(addr, size);
			func = CreateFunction(0, jumpAddr, false, false, sizeof(sect0));
			CopyMemory(func.sect0, sect0, sizeof(sect0));
			WriteCall((func.sect0 + 5), GetActorBaseAddressByEffectData);
			*reinterpret_cast<uint32 *>(func.sect0 + 0x11) = __builtin_offsetof(ActorData, newEffectIndices[0]) ;
		}

		if (enable)
		{
			WriteJump(addr, func.addr, (size - 5));
		}
		else
		{
			backupHelper.Restore(addr);
		}
	}
	{
		auto addr     = (appBaseAddr + 0x918A7);
		auto jumpAddr = (appBaseAddr + 0x918AF);
		constexpr uint32 size = 8;
		/*
		dmc3.exe+918A7 - 41 8B 84 94 C02DC900 - MOV EAX,[R12+RDX*4+00C92DC0]
		dmc3.exe+918AF
		*/

		static Function func = {};

		constexpr byte8 sect0[] =
		{
			0x51 ,
			0x48, 0x8B, 0xCF ,
			0xE8, 0x00, 0x00, 0x00, 0x00 ,
			0x59 ,
			0x8B, 0x84, 0x90, 0x00, 0x00, 0x00, 0x00, // mov eax,[rax+rdx*4+0000B8C0]
		};

		if (!run)
		{
			backupHelper.Save(addr, size);
			func = CreateFunction(0, jumpAddr, false, false, sizeof(sect0));
			CopyMemory(func.sect0, sect0, sizeof(sect0));
			WriteCall((func.sect0 + 4), GetActorBaseAddressByEffectData);
			*reinterpret_cast<uint32 *>(func.sect0 + 0xD) = __builtin_offsetof(ActorData, newEffectIndices[0]) ;
		}

		if (enable)
		{
			WriteJump(addr, func.addr, (size - 5));
		}
		else
		{
			backupHelper.Restore(addr);
		}
	}
	{
		auto addr     = (appBaseAddr + 0x918D3);
		auto jumpAddr = (appBaseAddr + 0x918DB);
		constexpr uint32 size = 8;
		/*
		dmc3.exe+918D3 - 41 31 9C 94 C02DC900 - XOR [R12+RDX*4+00C92DC0],EBX
		dmc3.exe+918DB
		*/

		static Function func = {};

		constexpr byte8 sect0[] =
		{
			0x51 ,
			0x50 ,
			0x48, 0x8B, 0xCF ,
			0xE8, 0x00, 0x00, 0x00, 0x00 ,
			0x48, 0x8B, 0xC8 ,
			0x58 ,
			0x31, 0x9C, 0x91, 0x00, 0x00, 0x00, 0x00, // xor [rcx+rdx*4+0000B8C0],ebx
			0x59 ,
		};

		if (!run)
		{
			backupHelper.Save(addr, size);
			func = CreateFunction(0, jumpAddr, false, false, sizeof(sect0));
			CopyMemory(func.sect0, sect0, sizeof(sect0));
			WriteCall((func.sect0 + 5), GetActorBaseAddressByEffectData);
			*reinterpret_cast<uint32 *>(func.sect0 + 0x11) = __builtin_offsetof(ActorData, newEffectIndices[0]) ;
		}

		if (enable)
		{
			WriteJump(addr, func.addr, (size - 5));
		}
		else
		{
			backupHelper.Restore(addr);
		}
	}
	{
		auto addr     = (appBaseAddr + 0x9190A);
		auto jumpAddr = (appBaseAddr + 0x91912);
		constexpr uint32 size = 8;
		/*
		dmc3.exe+9190A - 41 8B 84 94 C02DC900 - MOV EAX,[R12+RDX*4+00C92DC0]
		dmc3.exe+91912
		*/

		static Function func = {};

		constexpr byte8 sect0[] =
		{
			0x51 ,
			0x48, 0x8B, 0xCF ,
			0xE8, 0x00, 0x00, 0x00, 0x00 ,
			0x59 ,
			0x8B, 0x84, 0x90, 0x00, 0x00, 0x00, 0x00, // mov eax,[rax+rdx*4+0000B8C0]
		};

		if (!run)
		{
			backupHelper.Save(addr, size);
			func = CreateFunction(0, jumpAddr, false, false, sizeof(sect0));
			CopyMemory(func.sect0, sect0, sizeof(sect0));
			WriteCall((func.sect0 + 4), GetActorBaseAddressByEffectData);
			*reinterpret_cast<uint32 *>(func.sect0 + 0xD) = __builtin_offsetof(ActorData, newEffectIndices[0]) ;
		}

		if (enable)
		{
			WriteJump(addr, func.addr, (size - 5));
		}
		else
		{
			backupHelper.Restore(addr);
		}
	}
	{
		auto addr     = (appBaseAddr + 0x9193C);
		auto jumpAddr = (appBaseAddr + 0x91944);
		constexpr uint32 size = 8;
		/*
		dmc3.exe+9193C - 41 8B 84 94 C02DC900 - MOV EAX,[R12+RDX*4+00C92DC0]
		dmc3.exe+91944
		*/

		static Function func = {};

		constexpr byte8 sect0[] =
		{
			0x51 ,
			0x48, 0x8B, 0xCF ,
			0xE8, 0x00, 0x00, 0x00, 0x00 ,
			0x59 ,
			0x8B, 0x84, 0x90, 0x00, 0x00, 0x00, 0x00, // mov eax,[rax+rdx*4+0000B8C0]
		};

		if (!run)
		{
			backupHelper.Save(addr, size);
			func = CreateFunction(0, jumpAddr, false, false, sizeof(sect0));
			CopyMemory(func.sect0, sect0, sizeof(sect0));
			WriteCall((func.sect0 + 4), GetActorBaseAddressByEffectData);
			*reinterpret_cast<uint32 *>(func.sect0 + 0xD) = __builtin_offsetof(ActorData, newEffectIndices[0]) ;
		}

		if (enable)
		{
			WriteJump(addr, func.addr, (size - 5));
		}
		else
		{
			backupHelper.Restore(addr);
		}
	}
	{
		auto addr     = (appBaseAddr + 0x91995);
		auto jumpAddr = (appBaseAddr + 0x9199D);
		constexpr uint32 size = 8;
		/*
		dmc3.exe+91995 - 41 8B 84 94 C02DC900 - MOV EAX,[R12+RDX*4+00C92DC0]
		dmc3.exe+9199D
		*/

		static Function func = {};

		constexpr byte8 sect0[] =
		{
			0x51 ,
			0x48, 0x8B, 0xCF ,
			0xE8, 0x00, 0x00, 0x00, 0x00 ,
			0x59 ,
			0x8B, 0x84, 0x90, 0x00, 0x00, 0x00, 0x00, // mov eax,[rax+rdx*4+0000B8C0]
		};

		if (!run)
		{
			backupHelper.Save(addr, size);
			func = CreateFunction(0, jumpAddr, false, false, sizeof(sect0));
			CopyMemory(func.sect0, sect0, sizeof(sect0));
			WriteCall((func.sect0 + 4), GetActorBaseAddressByEffectData);
			*reinterpret_cast<uint32 *>(func.sect0 + 0xD) = __builtin_offsetof(ActorData, newEffectIndices[0]) ;
		}

		if (enable)
		{
			WriteJump(addr, func.addr, (size - 5));
		}
		else
		{
			backupHelper.Restore(addr);
		}
	}
	{
		auto addr     = (appBaseAddr + 0x919C5);
		auto jumpAddr = (appBaseAddr + 0x919CD);
		constexpr uint32 size = 8;
		/*
		dmc3.exe+919C5 - 41 31 9C 94 C02DC900 - XOR [R12+RDX*4+00C92DC0],EBX
		dmc3.exe+919CD
		*/

		static Function func = {};

		constexpr byte8 sect0[] =
		{
			0x51 ,
			0x50 ,
			0x48, 0x8B, 0xCF ,
			0xE8, 0x00, 0x00, 0x00, 0x00 ,
			0x48, 0x8B, 0xC8 ,
			0x58 ,
			0x31, 0x9C, 0x91, 0x00, 0x00, 0x00, 0x00, // xor [rcx+rdx*4+0000B8C0],ebx
			0x59 ,
		};

		if (!run)
		{
			backupHelper.Save(addr, size);
			func = CreateFunction(0, jumpAddr, false, false, sizeof(sect0));
			CopyMemory(func.sect0, sect0, sizeof(sect0));
			WriteCall((func.sect0 + 5), GetActorBaseAddressByEffectData);
			*reinterpret_cast<uint32 *>(func.sect0 + 0x11) = __builtin_offsetof(ActorData, newEffectIndices[0]) ;
		}

		if (enable)
		{
			WriteJump(addr, func.addr, (size - 5));
		}
		else
		{
			backupHelper.Restore(addr);
		}
	}
	{
		auto addr     = (appBaseAddr + 0x91AB9);
		auto jumpAddr = (appBaseAddr + 0x91AC1);
		constexpr uint32 size = 8;
		/*
		dmc3.exe+91AB9 - 41 8B 84 94 C02DC900 - MOV EAX,[R12+RDX*4+00C92DC0]
		dmc3.exe+91AC1
		*/

		static Function func = {};

		constexpr byte8 sect0[] =
		{
			0x51 ,
			0x48, 0x8B, 0xCF ,
			0xE8, 0x00, 0x00, 0x00, 0x00 ,
			0x59 ,
			0x8B, 0x84, 0x90, 0x00, 0x00, 0x00, 0x00, // mov eax,[rax+rdx*4+0000B8C0]
		};

		if (!run)
		{
			backupHelper.Save(addr, size);
			func = CreateFunction(0, jumpAddr, false, false, sizeof(sect0));
			CopyMemory(func.sect0, sect0, sizeof(sect0));
			WriteCall((func.sect0 + 4), GetActorBaseAddressByEffectData);
			*reinterpret_cast<uint32 *>(func.sect0 + 0xD) = __builtin_offsetof(ActorData, newEffectIndices[0]) ;
		}

		if (enable)
		{
			WriteJump(addr, func.addr, (size - 5));
		}
		else
		{
			backupHelper.Restore(addr);
		}
	}
	{
		auto addr     = (appBaseAddr + 0x91B05);
		auto jumpAddr = (appBaseAddr + 0x91B0D);
		constexpr uint32 size = 8;
		/*
		dmc3.exe+91B05 - 41 8B 84 94 C02DC900 - MOV EAX,[R12+RDX*4+00C92DC0]
		dmc3.exe+91B0D
		*/

		static Function func = {};

		constexpr byte8 sect0[] =
		{
			0x51 ,
			0x48, 0x8B, 0xCF ,
			0xE8, 0x00, 0x00, 0x00, 0x00 ,
			0x59 ,
			0x8B, 0x84, 0x90, 0x00, 0x00, 0x00, 0x00, // mov eax,[rax+rdx*4+0000B8C0]
		};

		if (!run)
		{
			backupHelper.Save(addr, size);
			func = CreateFunction(0, jumpAddr, false, false, sizeof(sect0));
			CopyMemory(func.sect0, sect0, sizeof(sect0));
			WriteCall((func.sect0 + 4), GetActorBaseAddressByEffectData);
			*reinterpret_cast<uint32 *>(func.sect0 + 0xD) = __builtin_offsetof(ActorData, newEffectIndices[0]) ;
		}

		if (enable)
		{
			WriteJump(addr, func.addr, (size - 5));
		}
		else
		{
			backupHelper.Restore(addr);
		}
	}
	{
		auto addr     = (appBaseAddr + 0x91B50);
		auto jumpAddr = (appBaseAddr + 0x91B58);
		constexpr uint32 size = 8;
		/*
		dmc3.exe+91B50 - 41 8B 84 94 C02DC900 - MOV EAX,[R12+RDX*4+00C92DC0]
		dmc3.exe+91B58
		*/

		static Function func = {};

		constexpr byte8 sect0[] =
		{
			0x51 ,
			0x48, 0x8B, 0xCF ,
			0xE8, 0x00, 0x00, 0x00, 0x00 ,
			0x59 ,
			0x8B, 0x84, 0x90, 0x00, 0x00, 0x00, 0x00, // mov eax,[rax+rdx*4+0000B8C0]
		};

		if (!run)
		{
			backupHelper.Save(addr, size);
			func = CreateFunction(0, jumpAddr, false, false, sizeof(sect0));
			CopyMemory(func.sect0, sect0, sizeof(sect0));
			WriteCall((func.sect0 + 4), GetActorBaseAddressByEffectData);
			*reinterpret_cast<uint32 *>(func.sect0 + 0xD) = __builtin_offsetof(ActorData, newEffectIndices[0]) ;
		}

		if (enable)
		{
			WriteJump(addr, func.addr, (size - 5));
		}
		else
		{
			backupHelper.Restore(addr);
		}
	}
	{
		auto addr     = (appBaseAddr + 0x91B86);
		auto jumpAddr = (appBaseAddr + 0x91B8E);
		constexpr uint32 size = 8;
		/*
		dmc3.exe+91B86 - 41 8B 84 94 C02DC900 - MOV EAX,[R12+RDX*4+00C92DC0]
		dmc3.exe+91B8E
		*/

		static Function func = {};

		constexpr byte8 sect0[] =
		{
			0x51 ,
			0x48, 0x8B, 0xCF ,
			0xE8, 0x00, 0x00, 0x00, 0x00 ,
			0x59 ,
			0x8B, 0x84, 0x90, 0x00, 0x00, 0x00, 0x00, // mov eax,[rax+rdx*4+0000B8C0]
		};

		if (!run)
		{
			backupHelper.Save(addr, size);
			func = CreateFunction(0, jumpAddr, false, false, sizeof(sect0));
			CopyMemory(func.sect0, sect0, sizeof(sect0));
			WriteCall((func.sect0 + 4), GetActorBaseAddressByEffectData);
			*reinterpret_cast<uint32 *>(func.sect0 + 0xD) = __builtin_offsetof(ActorData, newEffectIndices[0]) ;
		}

		if (enable)
		{
			WriteJump(addr, func.addr, (size - 5));
		}
		else
		{
			backupHelper.Restore(addr);
		}
	}
	{
		auto addr     = (appBaseAddr + 0x91C75);
		auto jumpAddr = (appBaseAddr + 0x91C7D);
		constexpr uint32 size = 8;
		/*
		dmc3.exe+91C75 - 41 8B 84 94 C02DC900 - MOV EAX,[R12+RDX*4+00C92DC0]
		dmc3.exe+91C7D
		*/

		static Function func = {};

		constexpr byte8 sect0[] =
		{
			0x51 ,
			0x48, 0x8B, 0xCF ,
			0xE8, 0x00, 0x00, 0x00, 0x00 ,
			0x59 ,
			0x8B, 0x84, 0x90, 0x00, 0x00, 0x00, 0x00, // mov eax,[rax+rdx*4+0000B8C0]
		};

		if (!run)
		{
			backupHelper.Save(addr, size);
			func = CreateFunction(0, jumpAddr, false, false, sizeof(sect0));
			CopyMemory(func.sect0, sect0, sizeof(sect0));
			WriteCall((func.sect0 + 4), GetActorBaseAddressByEffectData);
			*reinterpret_cast<uint32 *>(func.sect0 + 0xD) = __builtin_offsetof(ActorData, newEffectIndices[0]) ;
		}

		if (enable)
		{
			WriteJump(addr, func.addr, (size - 5));
		}
		else
		{
			backupHelper.Restore(addr);
		}
	}
	{
		auto addr     = (appBaseAddr + 0x91D32);
		auto jumpAddr = (appBaseAddr + 0x91D3A);
		constexpr uint32 size = 8;
		/*
		dmc3.exe+91D32 - 41 8B 84 94 C02DC900 - MOV EAX,[R12+RDX*4+00C92DC0]
		dmc3.exe+91D3A
		*/

		static Function func = {};

		constexpr byte8 sect0[] =
		{
			0x51 ,
			0x48, 0x8B, 0xCF ,
			0xE8, 0x00, 0x00, 0x00, 0x00 ,
			0x59 ,
			0x8B, 0x84, 0x90, 0x00, 0x00, 0x00, 0x00, // mov eax,[rax+rdx*4+0000B8C0]
		};

		if (!run)
		{
			backupHelper.Save(addr, size);
			func = CreateFunction(0, jumpAddr, false, false, sizeof(sect0));
			CopyMemory(func.sect0, sect0, sizeof(sect0));
			WriteCall((func.sect0 + 4), GetActorBaseAddressByEffectData);
			*reinterpret_cast<uint32 *>(func.sect0 + 0xD) = __builtin_offsetof(ActorData, newEffectIndices[0]) ;
		}

		if (enable)
		{
			WriteJump(addr, func.addr, (size - 5));
		}
		else
		{
			backupHelper.Restore(addr);
		}
	}
	{
		auto addr     = (appBaseAddr + 0x91DD3);
		auto jumpAddr = (appBaseAddr + 0x91DDB);
		constexpr uint32 size = 8;
		/*
		dmc3.exe+91DD3 - 41 8B 84 94 C02DC900 - MOV EAX,[R12+RDX*4+00C92DC0]
		dmc3.exe+91DDB
		*/

		static Function func = {};

		constexpr byte8 sect0[] =
		{
			0x51 ,
			0x48, 0x8B, 0xCF ,
			0xE8, 0x00, 0x00, 0x00, 0x00 ,
			0x59 ,
			0x8B, 0x84, 0x90, 0x00, 0x00, 0x00, 0x00, // mov eax,[rax+rdx*4+0000B8C0]
		};

		if (!run)
		{
			backupHelper.Save(addr, size);
			func = CreateFunction(0, jumpAddr, false, false, sizeof(sect0));
			CopyMemory(func.sect0, sect0, sizeof(sect0));
			WriteCall((func.sect0 + 4), GetActorBaseAddressByEffectData);
			*reinterpret_cast<uint32 *>(func.sect0 + 0xD) = __builtin_offsetof(ActorData, newEffectIndices[0]) ;
		}

		if (enable)
		{
			WriteJump(addr, func.addr, (size - 5));
		}
		else
		{
			backupHelper.Restore(addr);
		}
	}
	{
		auto addr     = (appBaseAddr + 0x91DF8);
		auto jumpAddr = (appBaseAddr + 0x91E00);
		constexpr uint32 size = 8;
		/*
		dmc3.exe+91DF8 - 41 8B 84 94 C02DC900 - MOV EAX,[R12+RDX*4+00C92DC0]
		dmc3.exe+91E00
		*/

		static Function func = {};

		constexpr byte8 sect0[] =
		{
			0x51 ,
			0x48, 0x8B, 0xCF ,
			0xE8, 0x00, 0x00, 0x00, 0x00 ,
			0x59 ,
			0x8B, 0x84, 0x90, 0x00, 0x00, 0x00, 0x00, // mov eax,[rax+rdx*4+0000B8C0]
		};

		if (!run)
		{
			backupHelper.Save(addr, size);
			func = CreateFunction(0, jumpAddr, false, false, sizeof(sect0));
			CopyMemory(func.sect0, sect0, sizeof(sect0));
			WriteCall((func.sect0 + 4), GetActorBaseAddressByEffectData);
			*reinterpret_cast<uint32 *>(func.sect0 + 0xD) = __builtin_offsetof(ActorData, newEffectIndices[0]) ;
		}

		if (enable)
		{
			WriteJump(addr, func.addr, (size - 5));
		}
		else
		{
			backupHelper.Restore(addr);
		}
	}
	{
		auto addr     = (appBaseAddr + 0x91E24);
		auto jumpAddr = (appBaseAddr + 0x91E2C);
		constexpr uint32 size = 8;
		/*
		dmc3.exe+91E24 - 41 31 9C 94 C02DC900 - XOR [R12+RDX*4+00C92DC0],EBX
		dmc3.exe+91E2C
		*/

		static Function func = {};

		constexpr byte8 sect0[] =
		{
			0x51 ,
			0x50 ,
			0x48, 0x8B, 0xCF ,
			0xE8, 0x00, 0x00, 0x00, 0x00 ,
			0x48, 0x8B, 0xC8 ,
			0x58 ,
			0x31, 0x9C, 0x91, 0x00, 0x00, 0x00, 0x00, // xor [rcx+rdx*4+0000B8C0],ebx
			0x59 ,
		};

		if (!run)
		{
			backupHelper.Save(addr, size);
			func = CreateFunction(0, jumpAddr, false, false, sizeof(sect0));
			CopyMemory(func.sect0, sect0, sizeof(sect0));
			WriteCall((func.sect0 + 5), GetActorBaseAddressByEffectData);
			*reinterpret_cast<uint32 *>(func.sect0 + 0x11) = __builtin_offsetof(ActorData, newEffectIndices[0]) ;
		}

		if (enable)
		{
			WriteJump(addr, func.addr, (size - 5));
		}
		else
		{
			backupHelper.Restore(addr);
		}
	}
	{
		auto addr     = (appBaseAddr + 0x91E73);
		auto jumpAddr = (appBaseAddr + 0x91E7B);
		constexpr uint32 size = 8;
		/*
		dmc3.exe+91E73 - 41 8B 84 94 C02DC900 - MOV EAX,[R12+RDX*4+00C92DC0]
		dmc3.exe+91E7B
		*/

		static Function func = {};

		constexpr byte8 sect0[] =
		{
			0x51 ,
			0x48, 0x8B, 0xCF ,
			0xE8, 0x00, 0x00, 0x00, 0x00 ,
			0x59 ,
			0x8B, 0x84, 0x90, 0x00, 0x00, 0x00, 0x00, // mov eax,[rax+rdx*4+0000B8C0]
		};

		if (!run)
		{
			backupHelper.Save(addr, size);
			func = CreateFunction(0, jumpAddr, false, false, sizeof(sect0));
			CopyMemory(func.sect0, sect0, sizeof(sect0));
			WriteCall((func.sect0 + 4), GetActorBaseAddressByEffectData);
			*reinterpret_cast<uint32 *>(func.sect0 + 0xD) = __builtin_offsetof(ActorData, newEffectIndices[0]) ;
		}

		if (enable)
		{
			WriteJump(addr, func.addr, (size - 5));
		}
		else
		{
			backupHelper.Restore(addr);
		}
	}
	{
		auto addr     = (appBaseAddr + 0x91ED4);
		auto jumpAddr = (appBaseAddr + 0x91EDC);
		constexpr uint32 size = 8;
		/*
		dmc3.exe+91ED4 - 41 8B 84 94 C02DC900 - MOV EAX,[R12+RDX*4+00C92DC0]
		dmc3.exe+91EDC
		*/

		static Function func = {};

		constexpr byte8 sect0[] =
		{
			0x51 ,
			0x48, 0x8B, 0xCF ,
			0xE8, 0x00, 0x00, 0x00, 0x00 ,
			0x59 ,
			0x8B, 0x84, 0x90, 0x00, 0x00, 0x00, 0x00, // mov eax,[rax+rdx*4+0000B8C0]
		};

		if (!run)
		{
			backupHelper.Save(addr, size);
			func = CreateFunction(0, jumpAddr, false, false, sizeof(sect0));
			CopyMemory(func.sect0, sect0, sizeof(sect0));
			WriteCall((func.sect0 + 4), GetActorBaseAddressByEffectData);
			*reinterpret_cast<uint32 *>(func.sect0 + 0xD) = __builtin_offsetof(ActorData, newEffectIndices[0]) ;
		}

		if (enable)
		{
			WriteJump(addr, func.addr, (size - 5));
		}
		else
		{
			backupHelper.Restore(addr);
		}
	}
	{
		auto addr     = (appBaseAddr + 0x91F0F);
		auto jumpAddr = (appBaseAddr + 0x91F17);
		constexpr uint32 size = 8;
		/*
		dmc3.exe+91F0F - 41 8B 84 94 C02DC900 - MOV EAX,[R12+RDX*4+00C92DC0]
		dmc3.exe+91F17
		*/

		static Function func = {};

		constexpr byte8 sect0[] =
		{
			0x51 ,
			0x48, 0x8B, 0xCF ,
			0xE8, 0x00, 0x00, 0x00, 0x00 ,
			0x59 ,
			0x8B, 0x84, 0x90, 0x00, 0x00, 0x00, 0x00, // mov eax,[rax+rdx*4+0000B8C0]
		};

		if (!run)
		{
			backupHelper.Save(addr, size);
			func = CreateFunction(0, jumpAddr, false, false, sizeof(sect0));
			CopyMemory(func.sect0, sect0, sizeof(sect0));
			WriteCall((func.sect0 + 4), GetActorBaseAddressByEffectData);
			*reinterpret_cast<uint32 *>(func.sect0 + 0xD) = __builtin_offsetof(ActorData, newEffectIndices[0]) ;
		}

		if (enable)
		{
			WriteJump(addr, func.addr, (size - 5));
		}
		else
		{
			backupHelper.Restore(addr);
		}
	}
	{
		auto addr     = (appBaseAddr + 0x91F4F);
		auto jumpAddr = (appBaseAddr + 0x91F57);
		constexpr uint32 size = 8;
		/*
		dmc3.exe+91F4F - 41 8B 84 94 C02DC900 - MOV EAX,[R12+RDX*4+00C92DC0]
		dmc3.exe+91F57
		*/

		static Function func = {};

		constexpr byte8 sect0[] =
		{
			0x51 ,
			0x48, 0x8B, 0xCF ,
			0xE8, 0x00, 0x00, 0x00, 0x00 ,
			0x59 ,
			0x8B, 0x84, 0x90, 0x00, 0x00, 0x00, 0x00, // mov eax,[rax+rdx*4+0000B8C0]
		};

		if (!run)
		{
			backupHelper.Save(addr, size);
			func = CreateFunction(0, jumpAddr, false, false, sizeof(sect0));
			CopyMemory(func.sect0, sect0, sizeof(sect0));
			WriteCall((func.sect0 + 4), GetActorBaseAddressByEffectData);
			*reinterpret_cast<uint32 *>(func.sect0 + 0xD) = __builtin_offsetof(ActorData, newEffectIndices[0]) ;
		}

		if (enable)
		{
			WriteJump(addr, func.addr, (size - 5));
		}
		else
		{
			backupHelper.Restore(addr);
		}
	}
	{
		auto addr     = (appBaseAddr + 0x91FA1);
		auto jumpAddr = (appBaseAddr + 0x91FA9);
		constexpr uint32 size = 8;
		/*
		dmc3.exe+91FA1 - 41 8B 84 94 C02DC900 - MOV EAX,[R12+RDX*4+00C92DC0]
		dmc3.exe+91FA9
		*/

		static Function func = {};

		constexpr byte8 sect0[] =
		{
			0x51 ,
			0x48, 0x8B, 0xCF ,
			0xE8, 0x00, 0x00, 0x00, 0x00 ,
			0x59 ,
			0x8B, 0x84, 0x90, 0x00, 0x00, 0x00, 0x00, // mov eax,[rax+rdx*4+0000B8C0]
		};

		if (!run)
		{
			backupHelper.Save(addr, size);
			func = CreateFunction(0, jumpAddr, false, false, sizeof(sect0));
			CopyMemory(func.sect0, sect0, sizeof(sect0));
			WriteCall((func.sect0 + 4), GetActorBaseAddressByEffectData);
			*reinterpret_cast<uint32 *>(func.sect0 + 0xD) = __builtin_offsetof(ActorData, newEffectIndices[0]) ;
		}

		if (enable)
		{
			WriteJump(addr, func.addr, (size - 5));
		}
		else
		{
			backupHelper.Restore(addr);
		}
	}
	{
		auto addr     = (appBaseAddr + 0x91FDF);
		auto jumpAddr = (appBaseAddr + 0x91FE7);
		constexpr uint32 size = 8;
		/*
		dmc3.exe+91FDF - 41 8B 84 94 C02DC900 - MOV EAX,[R12+RDX*4+00C92DC0]
		dmc3.exe+91FE7
		*/

		static Function func = {};

		constexpr byte8 sect0[] =
		{
			0x51 ,
			0x48, 0x8B, 0xCF ,
			0xE8, 0x00, 0x00, 0x00, 0x00 ,
			0x59 ,
			0x8B, 0x84, 0x90, 0x00, 0x00, 0x00, 0x00, // mov eax,[rax+rdx*4+0000B8C0]
		};

		if (!run)
		{
			backupHelper.Save(addr, size);
			func = CreateFunction(0, jumpAddr, false, false, sizeof(sect0));
			CopyMemory(func.sect0, sect0, sizeof(sect0));
			WriteCall((func.sect0 + 4), GetActorBaseAddressByEffectData);
			*reinterpret_cast<uint32 *>(func.sect0 + 0xD) = __builtin_offsetof(ActorData, newEffectIndices[0]) ;
		}

		if (enable)
		{
			WriteJump(addr, func.addr, (size - 5));
		}
		else
		{
			backupHelper.Restore(addr);
		}
	}
	{
		auto addr     = (appBaseAddr + 0x92020);
		auto jumpAddr = (appBaseAddr + 0x92028);
		constexpr uint32 size = 8;
		/*
		dmc3.exe+92020 - 41 8B 84 94 C02DC900 - MOV EAX,[R12+RDX*4+00C92DC0]
		dmc3.exe+92028
		*/

		static Function func = {};

		constexpr byte8 sect0[] =
		{
			0x51 ,
			0x48, 0x8B, 0xCF ,
			0xE8, 0x00, 0x00, 0x00, 0x00 ,
			0x59 ,
			0x8B, 0x84, 0x90, 0x00, 0x00, 0x00, 0x00, // mov eax,[rax+rdx*4+0000B8C0]
		};

		if (!run)
		{
			backupHelper.Save(addr, size);
			func = CreateFunction(0, jumpAddr, false, false, sizeof(sect0));
			CopyMemory(func.sect0, sect0, sizeof(sect0));
			WriteCall((func.sect0 + 4), GetActorBaseAddressByEffectData);
			*reinterpret_cast<uint32 *>(func.sect0 + 0xD) = __builtin_offsetof(ActorData, newEffectIndices[0]) ;
		}

		if (enable)
		{
			WriteJump(addr, func.addr, (size - 5));
		}
		else
		{
			backupHelper.Restore(addr);
		}
	}
	{
		auto addr     = (appBaseAddr + 0x9207E);
		auto jumpAddr = (appBaseAddr + 0x92086);
		constexpr uint32 size = 8;
		/*
		dmc3.exe+9207E - 41 8B 84 94 C02DC900 - MOV EAX,[R12+RDX*4+00C92DC0]
		dmc3.exe+92086
		*/

		static Function func = {};

		constexpr byte8 sect0[] =
		{
			0x51 ,
			0x48, 0x8B, 0xCF ,
			0xE8, 0x00, 0x00, 0x00, 0x00 ,
			0x59 ,
			0x8B, 0x84, 0x90, 0x00, 0x00, 0x00, 0x00, // mov eax,[rax+rdx*4+0000B8C0]
		};

		if (!run)
		{
			backupHelper.Save(addr, size);
			func = CreateFunction(0, jumpAddr, false, false, sizeof(sect0));
			CopyMemory(func.sect0, sect0, sizeof(sect0));
			WriteCall((func.sect0 + 4), GetActorBaseAddressByEffectData);
			*reinterpret_cast<uint32 *>(func.sect0 + 0xD) = __builtin_offsetof(ActorData, newEffectIndices[0]) ;
		}

		if (enable)
		{
			WriteJump(addr, func.addr, (size - 5));
		}
		else
		{
			backupHelper.Restore(addr);
		}
	}
	{
		auto addr     = (appBaseAddr + 0x920C9);
		auto jumpAddr = (appBaseAddr + 0x920D1);
		constexpr uint32 size = 8;
		/*
		dmc3.exe+920C9 - 41 8B 84 94 C02DC900 - MOV EAX,[R12+RDX*4+00C92DC0]
		dmc3.exe+920D1
		*/

		static Function func = {};

		constexpr byte8 sect0[] =
		{
			0x51 ,
			0x48, 0x8B, 0xCF ,
			0xE8, 0x00, 0x00, 0x00, 0x00 ,
			0x59 ,
			0x8B, 0x84, 0x90, 0x00, 0x00, 0x00, 0x00, // mov eax,[rax+rdx*4+0000B8C0]
		};

		if (!run)
		{
			backupHelper.Save(addr, size);
			func = CreateFunction(0, jumpAddr, false, false, sizeof(sect0));
			CopyMemory(func.sect0, sect0, sizeof(sect0));
			WriteCall((func.sect0 + 4), GetActorBaseAddressByEffectData);
			*reinterpret_cast<uint32 *>(func.sect0 + 0xD) = __builtin_offsetof(ActorData, newEffectIndices[0]) ;
		}

		if (enable)
		{
			WriteJump(addr, func.addr, (size - 5));
		}
		else
		{
			backupHelper.Restore(addr);
		}
	}
	{
		auto addr     = (appBaseAddr + 0x920FE);
		auto jumpAddr = (appBaseAddr + 0x92106);
		constexpr uint32 size = 8;
		/*
		dmc3.exe+920FE - 41 8B 84 94 C02DC900 - MOV EAX,[R12+RDX*4+00C92DC0]
		dmc3.exe+92106
		*/

		static Function func = {};

		constexpr byte8 sect0[] =
		{
			0x51 ,
			0x48, 0x8B, 0xCF ,
			0xE8, 0x00, 0x00, 0x00, 0x00 ,
			0x59 ,
			0x8B, 0x84, 0x90, 0x00, 0x00, 0x00, 0x00, // mov eax,[rax+rdx*4+0000B8C0]
		};

		if (!run)
		{
			backupHelper.Save(addr, size);
			func = CreateFunction(0, jumpAddr, false, false, sizeof(sect0));
			CopyMemory(func.sect0, sect0, sizeof(sect0));
			WriteCall((func.sect0 + 4), GetActorBaseAddressByEffectData);
			*reinterpret_cast<uint32 *>(func.sect0 + 0xD) = __builtin_offsetof(ActorData, newEffectIndices[0]) ;
		}

		if (enable)
		{
			WriteJump(addr, func.addr, (size - 5));
		}
		else
		{
			backupHelper.Restore(addr);
		}
	}
	{
		auto addr     = (appBaseAddr + 0x9218A);
		auto jumpAddr = (appBaseAddr + 0x92192);
		constexpr uint32 size = 8;
		/*
		dmc3.exe+9218A - 41 8B 84 94 C02DC900 - MOV EAX,[R12+RDX*4+00C92DC0]
		dmc3.exe+92192
		*/

		static Function func = {};

		constexpr byte8 sect0[] =
		{
			0x51 ,
			0x48, 0x8B, 0xCF ,
			0xE8, 0x00, 0x00, 0x00, 0x00 ,
			0x59 ,
			0x8B, 0x84, 0x90, 0x00, 0x00, 0x00, 0x00, // mov eax,[rax+rdx*4+0000B8C0]
		};

		if (!run)
		{
			backupHelper.Save(addr, size);
			func = CreateFunction(0, jumpAddr, false, false, sizeof(sect0));
			CopyMemory(func.sect0, sect0, sizeof(sect0));
			WriteCall((func.sect0 + 4), GetActorBaseAddressByEffectData);
			*reinterpret_cast<uint32 *>(func.sect0 + 0xD) = __builtin_offsetof(ActorData, newEffectIndices[0]) ;
		}

		if (enable)
		{
			WriteJump(addr, func.addr, (size - 5));
		}
		else
		{
			backupHelper.Restore(addr);
		}
	}
	{
		auto addr     = (appBaseAddr + 0x921EC);
		auto jumpAddr = (appBaseAddr + 0x921F4);
		constexpr uint32 size = 8;
		/*
		dmc3.exe+921EC - 41 8B 84 94 C02DC900 - MOV EAX,[R12+RDX*4+00C92DC0]
		dmc3.exe+921F4
		*/

		static Function func = {};

		constexpr byte8 sect0[] =
		{
			0x51 ,
			0x48, 0x8B, 0xCF ,
			0xE8, 0x00, 0x00, 0x00, 0x00 ,
			0x59 ,
			0x8B, 0x84, 0x90, 0x00, 0x00, 0x00, 0x00, // mov eax,[rax+rdx*4+0000B8C0]
		};

		if (!run)
		{
			backupHelper.Save(addr, size);
			func = CreateFunction(0, jumpAddr, false, false, sizeof(sect0));
			CopyMemory(func.sect0, sect0, sizeof(sect0));
			WriteCall((func.sect0 + 4), GetActorBaseAddressByEffectData);
			*reinterpret_cast<uint32 *>(func.sect0 + 0xD) = __builtin_offsetof(ActorData, newEffectIndices[0]) ;
		}

		if (enable)
		{
			WriteJump(addr, func.addr, (size - 5));
		}
		else
		{
			backupHelper.Restore(addr);
		}
	}
	{
		auto addr     = (appBaseAddr + 0x92215);
		auto jumpAddr = (appBaseAddr + 0x9221D);
		constexpr uint32 size = 8;
		/*
		dmc3.exe+92215 - 41 8B 84 94 C02DC900 - MOV EAX,[R12+RDX*4+00C92DC0]
		dmc3.exe+9221D
		*/

		static Function func = {};

		constexpr byte8 sect0[] =
		{
			0x51 ,
			0x48, 0x8B, 0xCF ,
			0xE8, 0x00, 0x00, 0x00, 0x00 ,
			0x59 ,
			0x8B, 0x84, 0x90, 0x00, 0x00, 0x00, 0x00, // mov eax,[rax+rdx*4+0000B8C0]
		};

		if (!run)
		{
			backupHelper.Save(addr, size);
			func = CreateFunction(0, jumpAddr, false, false, sizeof(sect0));
			CopyMemory(func.sect0, sect0, sizeof(sect0));
			WriteCall((func.sect0 + 4), GetActorBaseAddressByEffectData);
			*reinterpret_cast<uint32 *>(func.sect0 + 0xD) = __builtin_offsetof(ActorData, newEffectIndices[0]) ;
		}

		if (enable)
		{
			WriteJump(addr, func.addr, (size - 5));
		}
		else
		{
			backupHelper.Restore(addr);
		}
	}
	{
		auto addr     = (appBaseAddr + 0x92245);
		auto jumpAddr = (appBaseAddr + 0x9224D);
		constexpr uint32 size = 8;
		/*
		dmc3.exe+92245 - 41 31 9C 94 C02DC900 - XOR [R12+RDX*4+00C92DC0],EBX
		dmc3.exe+9224D
		*/

		static Function func = {};

		constexpr byte8 sect0[] =
		{
			0x51 ,
			0x50 ,
			0x48, 0x8B, 0xCF ,
			0xE8, 0x00, 0x00, 0x00, 0x00 ,
			0x48, 0x8B, 0xC8 ,
			0x58 ,
			0x31, 0x9C, 0x91, 0x00, 0x00, 0x00, 0x00, // xor [rcx+rdx*4+0000B8C0],ebx
			0x59 ,
		};

		if (!run)
		{
			backupHelper.Save(addr, size);
			func = CreateFunction(0, jumpAddr, false, false, sizeof(sect0));
			CopyMemory(func.sect0, sect0, sizeof(sect0));
			WriteCall((func.sect0 + 5), GetActorBaseAddressByEffectData);
			*reinterpret_cast<uint32 *>(func.sect0 + 0x11) = __builtin_offsetof(ActorData, newEffectIndices[0]) ;
		}

		if (enable)
		{
			WriteJump(addr, func.addr, (size - 5));
		}
		else
		{
			backupHelper.Restore(addr);
		}
	}
	{
		auto addr     = (appBaseAddr + 0x9232F);
		auto jumpAddr = (appBaseAddr + 0x92337);
		constexpr uint32 size = 8;
		/*
		dmc3.exe+9232F - 41 8B 84 94 C02DC900 - MOV EAX,[R12+RDX*4+00C92DC0]
		dmc3.exe+92337
		*/

		static Function func = {};

		constexpr byte8 sect0[] =
		{
			0x51 ,
			0x48, 0x8B, 0xCF ,
			0xE8, 0x00, 0x00, 0x00, 0x00 ,
			0x59 ,
			0x8B, 0x84, 0x90, 0x00, 0x00, 0x00, 0x00, // mov eax,[rax+rdx*4+0000B8C0]
		};

		if (!run)
		{
			backupHelper.Save(addr, size);
			func = CreateFunction(0, jumpAddr, false, false, sizeof(sect0));
			CopyMemory(func.sect0, sect0, sizeof(sect0));
			WriteCall((func.sect0 + 4), GetActorBaseAddressByEffectData);
			*reinterpret_cast<uint32 *>(func.sect0 + 0xD) = __builtin_offsetof(ActorData, newEffectIndices[0]) ;
		}

		if (enable)
		{
			WriteJump(addr, func.addr, (size - 5));
		}
		else
		{
			backupHelper.Restore(addr);
		}
	}
	{
		auto addr     = (appBaseAddr + 0x92370);
		auto jumpAddr = (appBaseAddr + 0x92378);
		constexpr uint32 size = 8;
		/*
		dmc3.exe+92370 - 41 8B 84 94 C02DC900 - MOV EAX,[R12+RDX*4+00C92DC0]
		dmc3.exe+92378
		*/

		static Function func = {};

		constexpr byte8 sect0[] =
		{
			0x51 ,
			0x48, 0x8B, 0xCF ,
			0xE8, 0x00, 0x00, 0x00, 0x00 ,
			0x59 ,
			0x8B, 0x84, 0x90, 0x00, 0x00, 0x00, 0x00, // mov eax,[rax+rdx*4+0000B8C0]
		};

		if (!run)
		{
			backupHelper.Save(addr, size);
			func = CreateFunction(0, jumpAddr, false, false, sizeof(sect0));
			CopyMemory(func.sect0, sect0, sizeof(sect0));
			WriteCall((func.sect0 + 4), GetActorBaseAddressByEffectData);
			*reinterpret_cast<uint32 *>(func.sect0 + 0xD) = __builtin_offsetof(ActorData, newEffectIndices[0]) ;
		}

		if (enable)
		{
			WriteJump(addr, func.addr, (size - 5));
		}
		else
		{
			backupHelper.Restore(addr);
		}
	}
	{
		auto addr     = (appBaseAddr + 0x923B1);
		auto jumpAddr = (appBaseAddr + 0x923B9);
		constexpr uint32 size = 8;
		/*
		dmc3.exe+923B1 - 41 8B 84 94 C02DC900 - MOV EAX,[R12+RDX*4+00C92DC0]
		dmc3.exe+923B9
		*/

		static Function func = {};

		constexpr byte8 sect0[] =
		{
			0x51 ,
			0x48, 0x8B, 0xCF ,
			0xE8, 0x00, 0x00, 0x00, 0x00 ,
			0x59 ,
			0x8B, 0x84, 0x90, 0x00, 0x00, 0x00, 0x00, // mov eax,[rax+rdx*4+0000B8C0]
		};

		if (!run)
		{
			backupHelper.Save(addr, size);
			func = CreateFunction(0, jumpAddr, false, false, sizeof(sect0));
			CopyMemory(func.sect0, sect0, sizeof(sect0));
			WriteCall((func.sect0 + 4), GetActorBaseAddressByEffectData);
			*reinterpret_cast<uint32 *>(func.sect0 + 0xD) = __builtin_offsetof(ActorData, newEffectIndices[0]) ;
		}

		if (enable)
		{
			WriteJump(addr, func.addr, (size - 5));
		}
		else
		{
			backupHelper.Restore(addr);
		}
	}
	{
		auto addr     = (appBaseAddr + 0x923F2);
		auto jumpAddr = (appBaseAddr + 0x923FA);
		constexpr uint32 size = 8;
		/*
		dmc3.exe+923F2 - 41 8B 84 94 C02DC900 - MOV EAX,[R12+RDX*4+00C92DC0]
		dmc3.exe+923FA
		*/

		static Function func = {};

		constexpr byte8 sect0[] =
		{
			0x51 ,
			0x48, 0x8B, 0xCF ,
			0xE8, 0x00, 0x00, 0x00, 0x00 ,
			0x59 ,
			0x8B, 0x84, 0x90, 0x00, 0x00, 0x00, 0x00, // mov eax,[rax+rdx*4+0000B8C0]
		};

		if (!run)
		{
			backupHelper.Save(addr, size);
			func = CreateFunction(0, jumpAddr, false, false, sizeof(sect0));
			CopyMemory(func.sect0, sect0, sizeof(sect0));
			WriteCall((func.sect0 + 4), GetActorBaseAddressByEffectData);
			*reinterpret_cast<uint32 *>(func.sect0 + 0xD) = __builtin_offsetof(ActorData, newEffectIndices[0]) ;
		}

		if (enable)
		{
			WriteJump(addr, func.addr, (size - 5));
		}
		else
		{
			backupHelper.Restore(addr);
		}
	}
	{
		auto addr     = (appBaseAddr + 0x9244D);
		auto jumpAddr = (appBaseAddr + 0x92455);
		constexpr uint32 size = 8;
		/*
		dmc3.exe+9244D - 41 8B 84 94 C02DC900 - MOV EAX,[R12+RDX*4+00C92DC0]
		dmc3.exe+92455
		*/

		static Function func = {};

		constexpr byte8 sect0[] =
		{
			0x51 ,
			0x48, 0x8B, 0xCF ,
			0xE8, 0x00, 0x00, 0x00, 0x00 ,
			0x59 ,
			0x8B, 0x84, 0x90, 0x00, 0x00, 0x00, 0x00, // mov eax,[rax+rdx*4+0000B8C0]
		};

		if (!run)
		{
			backupHelper.Save(addr, size);
			func = CreateFunction(0, jumpAddr, false, false, sizeof(sect0));
			CopyMemory(func.sect0, sect0, sizeof(sect0));
			WriteCall((func.sect0 + 4), GetActorBaseAddressByEffectData);
			*reinterpret_cast<uint32 *>(func.sect0 + 0xD) = __builtin_offsetof(ActorData, newEffectIndices[0]) ;
		}

		if (enable)
		{
			WriteJump(addr, func.addr, (size - 5));
		}
		else
		{
			backupHelper.Restore(addr);
		}
	}
	{
		auto addr     = (appBaseAddr + 0x9247D);
		auto jumpAddr = (appBaseAddr + 0x92485);
		constexpr uint32 size = 8;
		/*
		dmc3.exe+9247D - 41 31 9C 94 C02DC900 - XOR [R12+RDX*4+00C92DC0],EBX
		dmc3.exe+92485
		*/

		static Function func = {};

		constexpr byte8 sect0[] =
		{
			0x51 ,
			0x50 ,
			0x48, 0x8B, 0xCF ,
			0xE8, 0x00, 0x00, 0x00, 0x00 ,
			0x48, 0x8B, 0xC8 ,
			0x58 ,
			0x31, 0x9C, 0x91, 0x00, 0x00, 0x00, 0x00, // xor [rcx+rdx*4+0000B8C0],ebx
			0x59 ,
		};

		if (!run)
		{
			backupHelper.Save(addr, size);
			func = CreateFunction(0, jumpAddr, false, false, sizeof(sect0));
			CopyMemory(func.sect0, sect0, sizeof(sect0));
			WriteCall((func.sect0 + 5), GetActorBaseAddressByEffectData);
			*reinterpret_cast<uint32 *>(func.sect0 + 0x11) = __builtin_offsetof(ActorData, newEffectIndices[0]) ;
		}

		if (enable)
		{
			WriteJump(addr, func.addr, (size - 5));
		}
		else
		{
			backupHelper.Restore(addr);
		}
	}
	{
		auto addr     = (appBaseAddr + 0x92598);
		auto jumpAddr = (appBaseAddr + 0x925A0);
		constexpr uint32 size = 8;
		/*
		dmc3.exe+92598 - 41 8B 84 94 C02DC900 - MOV EAX,[R12+RDX*4+00C92DC0]
		dmc3.exe+925A0
		*/

		static Function func = {};

		constexpr byte8 sect0[] =
		{
			0x51 ,
			0x48, 0x8B, 0xCF ,
			0xE8, 0x00, 0x00, 0x00, 0x00 ,
			0x59 ,
			0x8B, 0x84, 0x90, 0x00, 0x00, 0x00, 0x00, // mov eax,[rax+rdx*4+0000B8C0]
		};

		if (!run)
		{
			backupHelper.Save(addr, size);
			func = CreateFunction(0, jumpAddr, false, false, sizeof(sect0));
			CopyMemory(func.sect0, sect0, sizeof(sect0));
			WriteCall((func.sect0 + 4), GetActorBaseAddressByEffectData);
			*reinterpret_cast<uint32 *>(func.sect0 + 0xD) = __builtin_offsetof(ActorData, newEffectIndices[0]) ;
		}

		if (enable)
		{
			WriteJump(addr, func.addr, (size - 5));
		}
		else
		{
			backupHelper.Restore(addr);
		}
	}
	{
		auto addr     = (appBaseAddr + 0x925D9);
		auto jumpAddr = (appBaseAddr + 0x925E1);
		constexpr uint32 size = 8;
		/*
		dmc3.exe+925D9 - 41 8B 84 94 C02DC900 - MOV EAX,[R12+RDX*4+00C92DC0]
		dmc3.exe+925E1
		*/

		static Function func = {};

		constexpr byte8 sect0[] =
		{
			0x51 ,
			0x48, 0x8B, 0xCF ,
			0xE8, 0x00, 0x00, 0x00, 0x00 ,
			0x59 ,
			0x8B, 0x84, 0x90, 0x00, 0x00, 0x00, 0x00, // mov eax,[rax+rdx*4+0000B8C0]
		};

		if (!run)
		{
			backupHelper.Save(addr, size);
			func = CreateFunction(0, jumpAddr, false, false, sizeof(sect0));
			CopyMemory(func.sect0, sect0, sizeof(sect0));
			WriteCall((func.sect0 + 4), GetActorBaseAddressByEffectData);
			*reinterpret_cast<uint32 *>(func.sect0 + 0xD) = __builtin_offsetof(ActorData, newEffectIndices[0]) ;
		}

		if (enable)
		{
			WriteJump(addr, func.addr, (size - 5));
		}
		else
		{
			backupHelper.Restore(addr);
		}
	}
	{
		auto addr     = (appBaseAddr + 0x9261A);
		auto jumpAddr = (appBaseAddr + 0x92622);
		constexpr uint32 size = 8;
		/*
		dmc3.exe+9261A - 41 8B 84 94 C02DC900 - MOV EAX,[R12+RDX*4+00C92DC0]
		dmc3.exe+92622
		*/

		static Function func = {};

		constexpr byte8 sect0[] =
		{
			0x51 ,
			0x48, 0x8B, 0xCF ,
			0xE8, 0x00, 0x00, 0x00, 0x00 ,
			0x59 ,
			0x8B, 0x84, 0x90, 0x00, 0x00, 0x00, 0x00, // mov eax,[rax+rdx*4+0000B8C0]
		};

		if (!run)
		{
			backupHelper.Save(addr, size);
			func = CreateFunction(0, jumpAddr, false, false, sizeof(sect0));
			CopyMemory(func.sect0, sect0, sizeof(sect0));
			WriteCall((func.sect0 + 4), GetActorBaseAddressByEffectData);
			*reinterpret_cast<uint32 *>(func.sect0 + 0xD) = __builtin_offsetof(ActorData, newEffectIndices[0]) ;
		}

		if (enable)
		{
			WriteJump(addr, func.addr, (size - 5));
		}
		else
		{
			backupHelper.Restore(addr);
		}
	}
	{
		auto addr     = (appBaseAddr + 0x92671);
		auto jumpAddr = (appBaseAddr + 0x92679);
		constexpr uint32 size = 8;
		/*
		dmc3.exe+92671 - 41 8B 84 94 C02DC900 - MOV EAX,[R12+RDX*4+00C92DC0]
		dmc3.exe+92679
		*/

		static Function func = {};

		constexpr byte8 sect0[] =
		{
			0x51 ,
			0x48, 0x8B, 0xCF ,
			0xE8, 0x00, 0x00, 0x00, 0x00 ,
			0x59 ,
			0x8B, 0x84, 0x90, 0x00, 0x00, 0x00, 0x00, // mov eax,[rax+rdx*4+0000B8C0]
		};

		if (!run)
		{
			backupHelper.Save(addr, size);
			func = CreateFunction(0, jumpAddr, false, false, sizeof(sect0));
			CopyMemory(func.sect0, sect0, sizeof(sect0));
			WriteCall((func.sect0 + 4), GetActorBaseAddressByEffectData);
			*reinterpret_cast<uint32 *>(func.sect0 + 0xD) = __builtin_offsetof(ActorData, newEffectIndices[0]) ;
		}

		if (enable)
		{
			WriteJump(addr, func.addr, (size - 5));
		}
		else
		{
			backupHelper.Restore(addr);
		}
	}
	{
		auto addr     = (appBaseAddr + 0x926B2);
		auto jumpAddr = (appBaseAddr + 0x926BA);
		constexpr uint32 size = 8;
		/*
		dmc3.exe+926B2 - 41 8B 84 94 C02DC900 - MOV EAX,[R12+RDX*4+00C92DC0]
		dmc3.exe+926BA
		*/

		static Function func = {};

		constexpr byte8 sect0[] =
		{
			0x51 ,
			0x48, 0x8B, 0xCF ,
			0xE8, 0x00, 0x00, 0x00, 0x00 ,
			0x59 ,
			0x8B, 0x84, 0x90, 0x00, 0x00, 0x00, 0x00, // mov eax,[rax+rdx*4+0000B8C0]
		};

		if (!run)
		{
			backupHelper.Save(addr, size);
			func = CreateFunction(0, jumpAddr, false, false, sizeof(sect0));
			CopyMemory(func.sect0, sect0, sizeof(sect0));
			WriteCall((func.sect0 + 4), GetActorBaseAddressByEffectData);
			*reinterpret_cast<uint32 *>(func.sect0 + 0xD) = __builtin_offsetof(ActorData, newEffectIndices[0]) ;
		}

		if (enable)
		{
			WriteJump(addr, func.addr, (size - 5));
		}
		else
		{
			backupHelper.Restore(addr);
		}
	}
	{
		auto addr     = (appBaseAddr + 0x9271F);
		auto jumpAddr = (appBaseAddr + 0x92727);
		constexpr uint32 size = 8;
		/*
		dmc3.exe+9271F - 41 8B 84 94 C02DC900 - MOV EAX,[R12+RDX*4+00C92DC0]
		dmc3.exe+92727
		*/

		static Function func = {};

		constexpr byte8 sect0[] =
		{
			0x51 ,
			0x48, 0x8B, 0xCF ,
			0xE8, 0x00, 0x00, 0x00, 0x00 ,
			0x59 ,
			0x8B, 0x84, 0x90, 0x00, 0x00, 0x00, 0x00, // mov eax,[rax+rdx*4+0000B8C0]
		};

		if (!run)
		{
			backupHelper.Save(addr, size);
			func = CreateFunction(0, jumpAddr, false, false, sizeof(sect0));
			CopyMemory(func.sect0, sect0, sizeof(sect0));
			WriteCall((func.sect0 + 4), GetActorBaseAddressByEffectData);
			*reinterpret_cast<uint32 *>(func.sect0 + 0xD) = __builtin_offsetof(ActorData, newEffectIndices[0]) ;
		}

		if (enable)
		{
			WriteJump(addr, func.addr, (size - 5));
		}
		else
		{
			backupHelper.Restore(addr);
		}
	}
	{
		auto addr     = (appBaseAddr + 0x92760);
		auto jumpAddr = (appBaseAddr + 0x92768);
		constexpr uint32 size = 8;
		/*
		dmc3.exe+92760 - 41 8B 84 94 C02DC900 - MOV EAX,[R12+RDX*4+00C92DC0]
		dmc3.exe+92768
		*/

		static Function func = {};

		constexpr byte8 sect0[] =
		{
			0x51 ,
			0x48, 0x8B, 0xCF ,
			0xE8, 0x00, 0x00, 0x00, 0x00 ,
			0x59 ,
			0x8B, 0x84, 0x90, 0x00, 0x00, 0x00, 0x00, // mov eax,[rax+rdx*4+0000B8C0]
		};

		if (!run)
		{
			backupHelper.Save(addr, size);
			func = CreateFunction(0, jumpAddr, false, false, sizeof(sect0));
			CopyMemory(func.sect0, sect0, sizeof(sect0));
			WriteCall((func.sect0 + 4), GetActorBaseAddressByEffectData);
			*reinterpret_cast<uint32 *>(func.sect0 + 0xD) = __builtin_offsetof(ActorData, newEffectIndices[0]) ;
		}

		if (enable)
		{
			WriteJump(addr, func.addr, (size - 5));
		}
		else
		{
			backupHelper.Restore(addr);
		}
	}
	{
		auto addr     = (appBaseAddr + 0x9278C);
		auto jumpAddr = (appBaseAddr + 0x92794);
		constexpr uint32 size = 8;
		/*
		dmc3.exe+9278C - 41 31 9C 94 C02DC900 - XOR [R12+RDX*4+00C92DC0],EBX
		dmc3.exe+92794
		*/

		static Function func = {};

		constexpr byte8 sect0[] =
		{
			0x51 ,
			0x50 ,
			0x48, 0x8B, 0xCF ,
			0xE8, 0x00, 0x00, 0x00, 0x00 ,
			0x48, 0x8B, 0xC8 ,
			0x58 ,
			0x31, 0x9C, 0x91, 0x00, 0x00, 0x00, 0x00, // xor [rcx+rdx*4+0000B8C0],ebx
			0x59 ,
		};

		if (!run)
		{
			backupHelper.Save(addr, size);
			func = CreateFunction(0, jumpAddr, false, false, sizeof(sect0));
			CopyMemory(func.sect0, sect0, sizeof(sect0));
			WriteCall((func.sect0 + 5), GetActorBaseAddressByEffectData);
			*reinterpret_cast<uint32 *>(func.sect0 + 0x11) = __builtin_offsetof(ActorData, newEffectIndices[0]) ;
		}

		if (enable)
		{
			WriteJump(addr, func.addr, (size - 5));
		}
		else
		{
			backupHelper.Restore(addr);
		}
	}
	{
		auto addr     = (appBaseAddr + 0x927CD);
		auto jumpAddr = (appBaseAddr + 0x927D5);
		constexpr uint32 size = 8;
		/*
		dmc3.exe+927CD - 41 8B 84 94 C02DC900 - MOV EAX,[R12+RDX*4+00C92DC0]
		dmc3.exe+927D5
		*/

		static Function func = {};

		constexpr byte8 sect0[] =
		{
			0x51 ,
			0x48, 0x8B, 0xCF ,
			0xE8, 0x00, 0x00, 0x00, 0x00 ,
			0x59 ,
			0x8B, 0x84, 0x90, 0x00, 0x00, 0x00, 0x00, // mov eax,[rax+rdx*4+0000B8C0]
		};

		if (!run)
		{
			backupHelper.Save(addr, size);
			func = CreateFunction(0, jumpAddr, false, false, sizeof(sect0));
			CopyMemory(func.sect0, sect0, sizeof(sect0));
			WriteCall((func.sect0 + 4), GetActorBaseAddressByEffectData);
			*reinterpret_cast<uint32 *>(func.sect0 + 0xD) = __builtin_offsetof(ActorData, newEffectIndices[0]) ;
		}

		if (enable)
		{
			WriteJump(addr, func.addr, (size - 5));
		}
		else
		{
			backupHelper.Restore(addr);
		}
	}
	{
		auto addr     = (appBaseAddr + 0x92802);
		auto jumpAddr = (appBaseAddr + 0x9280A);
		constexpr uint32 size = 8;
		/*
		dmc3.exe+92802 - 41 8B 84 94 C02DC900 - MOV EAX,[R12+RDX*4+00C92DC0]
		dmc3.exe+9280A
		*/

		static Function func = {};

		constexpr byte8 sect0[] =
		{
			0x51 ,
			0x48, 0x8B, 0xCF ,
			0xE8, 0x00, 0x00, 0x00, 0x00 ,
			0x59 ,
			0x8B, 0x84, 0x90, 0x00, 0x00, 0x00, 0x00, // mov eax,[rax+rdx*4+0000B8C0]
		};

		if (!run)
		{
			backupHelper.Save(addr, size);
			func = CreateFunction(0, jumpAddr, false, false, sizeof(sect0));
			CopyMemory(func.sect0, sect0, sizeof(sect0));
			WriteCall((func.sect0 + 4), GetActorBaseAddressByEffectData);
			*reinterpret_cast<uint32 *>(func.sect0 + 0xD) = __builtin_offsetof(ActorData, newEffectIndices[0]) ;
		}

		if (enable)
		{
			WriteJump(addr, func.addr, (size - 5));
		}
		else
		{
			backupHelper.Restore(addr);
		}
	}
	{
		auto addr     = (appBaseAddr + 0x9286D);
		auto jumpAddr = (appBaseAddr + 0x92875);
		constexpr uint32 size = 8;
		/*
		dmc3.exe+9286D - 41 31 9C 94 C02DC900 - XOR [R12+RDX*4+00C92DC0],EBX
		dmc3.exe+92875
		*/

		static Function func = {};

		constexpr byte8 sect0[] =
		{
			0x51 ,
			0x50 ,
			0x48, 0x8B, 0xCF ,
			0xE8, 0x00, 0x00, 0x00, 0x00 ,
			0x48, 0x8B, 0xC8 ,
			0x58 ,
			0x31, 0x9C, 0x91, 0x00, 0x00, 0x00, 0x00, // xor [rcx+rdx*4+0000B8C0],ebx
			0x59 ,
		};

		if (!run)
		{
			backupHelper.Save(addr, size);
			func = CreateFunction(0, jumpAddr, false, false, sizeof(sect0));
			CopyMemory(func.sect0, sect0, sizeof(sect0));
			WriteCall((func.sect0 + 5), GetActorBaseAddressByEffectData);
			*reinterpret_cast<uint32 *>(func.sect0 + 0x11) = __builtin_offsetof(ActorData, newEffectIndices[0]) ;
		}

		if (enable)
		{
			WriteJump(addr, func.addr, (size - 5));
		}
		else
		{
			backupHelper.Restore(addr);
		}
	}
	{
		auto addr     = (appBaseAddr + 0x9288F);
		auto jumpAddr = (appBaseAddr + 0x92897);
		constexpr uint32 size = 8;
		/*
		dmc3.exe+9288F - 41 8B 84 94 C02DC900 - MOV EAX,[R12+RDX*4+00C92DC0]
		dmc3.exe+92897
		*/

		static Function func = {};

		constexpr byte8 sect0[] =
		{
			0x51 ,
			0x48, 0x8B, 0xCF ,
			0xE8, 0x00, 0x00, 0x00, 0x00 ,
			0x59 ,
			0x8B, 0x84, 0x90, 0x00, 0x00, 0x00, 0x00, // mov eax,[rax+rdx*4+0000B8C0]
		};

		if (!run)
		{
			backupHelper.Save(addr, size);
			func = CreateFunction(0, jumpAddr, false, false, sizeof(sect0));
			CopyMemory(func.sect0, sect0, sizeof(sect0));
			WriteCall((func.sect0 + 4), GetActorBaseAddressByEffectData);
			*reinterpret_cast<uint32 *>(func.sect0 + 0xD) = __builtin_offsetof(ActorData, newEffectIndices[0]) ;
		}

		if (enable)
		{
			WriteJump(addr, func.addr, (size - 5));
		}
		else
		{
			backupHelper.Restore(addr);
		}
	}
	{
		auto addr     = (appBaseAddr + 0x928D8);
		auto jumpAddr = (appBaseAddr + 0x928E0);
		constexpr uint32 size = 8;
		/*
		dmc3.exe+928D8 - 41 8B 84 94 C02DC900 - MOV EAX,[R12+RDX*4+00C92DC0]
		dmc3.exe+928E0
		*/

		static Function func = {};

		constexpr byte8 sect0[] =
		{
			0x51 ,
			0x48, 0x8B, 0xCF ,
			0xE8, 0x00, 0x00, 0x00, 0x00 ,
			0x59 ,
			0x8B, 0x84, 0x90, 0x00, 0x00, 0x00, 0x00, // mov eax,[rax+rdx*4+0000B8C0]
		};

		if (!run)
		{
			backupHelper.Save(addr, size);
			func = CreateFunction(0, jumpAddr, false, false, sizeof(sect0));
			CopyMemory(func.sect0, sect0, sizeof(sect0));
			WriteCall((func.sect0 + 4), GetActorBaseAddressByEffectData);
			*reinterpret_cast<uint32 *>(func.sect0 + 0xD) = __builtin_offsetof(ActorData, newEffectIndices[0]) ;
		}

		if (enable)
		{
			WriteJump(addr, func.addr, (size - 5));
		}
		else
		{
			backupHelper.Restore(addr);
		}
	}
	{
		auto addr     = (appBaseAddr + 0x9290D);
		auto jumpAddr = (appBaseAddr + 0x92915);
		constexpr uint32 size = 8;
		/*
		dmc3.exe+9290D - 41 8B 84 94 C02DC900 - MOV EAX,[R12+RDX*4+00C92DC0]
		dmc3.exe+92915
		*/

		static Function func = {};

		constexpr byte8 sect0[] =
		{
			0x51 ,
			0x48, 0x8B, 0xCF ,
			0xE8, 0x00, 0x00, 0x00, 0x00 ,
			0x59 ,
			0x8B, 0x84, 0x90, 0x00, 0x00, 0x00, 0x00, // mov eax,[rax+rdx*4+0000B8C0]
		};

		if (!run)
		{
			backupHelper.Save(addr, size);
			func = CreateFunction(0, jumpAddr, false, false, sizeof(sect0));
			CopyMemory(func.sect0, sect0, sizeof(sect0));
			WriteCall((func.sect0 + 4), GetActorBaseAddressByEffectData);
			*reinterpret_cast<uint32 *>(func.sect0 + 0xD) = __builtin_offsetof(ActorData, newEffectIndices[0]) ;
		}

		if (enable)
		{
			WriteJump(addr, func.addr, (size - 5));
		}
		else
		{
			backupHelper.Restore(addr);
		}
	}
	{
		auto addr     = (appBaseAddr + 0x92933);
		auto jumpAddr = (appBaseAddr + 0x9293B);
		constexpr uint32 size = 8;
		/*
		dmc3.exe+92933 - 41 31 9C 94 C02DC900 - XOR [R12+RDX*4+00C92DC0],EBX
		dmc3.exe+9293B
		*/

		static Function func = {};

		constexpr byte8 sect0[] =
		{
			0x51 ,
			0x50 ,
			0x48, 0x8B, 0xCF ,
			0xE8, 0x00, 0x00, 0x00, 0x00 ,
			0x48, 0x8B, 0xC8 ,
			0x58 ,
			0x31, 0x9C, 0x91, 0x00, 0x00, 0x00, 0x00, // xor [rcx+rdx*4+0000B8C0],ebx
			0x59 ,
		};

		if (!run)
		{
			backupHelper.Save(addr, size);
			func = CreateFunction(0, jumpAddr, false, false, sizeof(sect0));
			CopyMemory(func.sect0, sect0, sizeof(sect0));
			WriteCall((func.sect0 + 5), GetActorBaseAddressByEffectData);
			*reinterpret_cast<uint32 *>(func.sect0 + 0x11) = __builtin_offsetof(ActorData, newEffectIndices[0]) ;
		}

		if (enable)
		{
			WriteJump(addr, func.addr, (size - 5));
		}
		else
		{
			backupHelper.Restore(addr);
		}
	}
	{
		auto addr     = (appBaseAddr + 0x8DC62);
		auto jumpAddr = (appBaseAddr + 0x8DC69);
		constexpr uint32 size = 7;
		/*
		dmc3.exe+8DC62 - 8B 84 96 D82DC900 - MOV EAX,[RSI+RDX*4+00C92DD8]
		dmc3.exe+8DC69
		*/

		static Function func = {};

		constexpr byte8 sect0[] =
		{
			0x51 ,
			0x48, 0x8B, 0xCB ,
			0xE8, 0x00, 0x00, 0x00, 0x00 ,
			0x59 ,
			0x8B, 0x84, 0x90, 0x00, 0x00, 0x00, 0x00, // mov eax,[rax+rdx*4+0000B8C0]
		};

		if (!run)
		{
			backupHelper.Save(addr, size);
			func = CreateFunction(0, jumpAddr, false, false, sizeof(sect0));
			CopyMemory(func.sect0, sect0, sizeof(sect0));
			WriteCall((func.sect0 + 4), GetActorBaseAddressByEffectData);
			*reinterpret_cast<uint32 *>(func.sect0 + 0xD) = __builtin_offsetof(ActorData, newEffectIndices[6]) ;
		}

		if (enable)
		{
			WriteJump(addr, func.addr, (size - 5));
		}
		else
		{
			backupHelper.Restore(addr);
		}
	}
	{
		auto addr     = (appBaseAddr + 0x8DC87);
		auto jumpAddr = (appBaseAddr + 0x8DC8E);
		constexpr uint32 size = 7;
		/*
		dmc3.exe+8DC87 - 31 84 96 D82DC900 - XOR [RSI+RDX*4+00C92DD8],EAX
		dmc3.exe+8DC8E
		*/

		static Function func = {};

		constexpr byte8 sect0[] =
		{
			0x51 ,
			0x50 ,
			0x48, 0x8B, 0xCB ,
			0xE8, 0x00, 0x00, 0x00, 0x00 ,
			0x48, 0x8B, 0xC8 ,
			0x58 ,
			0x31, 0x84, 0x91, 0x00, 0x00, 0x00, 0x00, // xor [rcx+rdx*4+0000B8C0],eax
			0x59 ,
		};

		if (!run)
		{
			backupHelper.Save(addr, size);
			func = CreateFunction(0, jumpAddr, false, false, sizeof(sect0));
			CopyMemory(func.sect0, sect0, sizeof(sect0));
			WriteCall((func.sect0 + 5), GetActorBaseAddressByEffectData);
			*reinterpret_cast<uint32 *>(func.sect0 + 0x11) = __builtin_offsetof(ActorData, newEffectIndices[6]) ;
		}

		if (enable)
		{
			WriteJump(addr, func.addr, (size - 5));
		}
		else
		{
			backupHelper.Restore(addr);
		}
	}
	{
		auto addr     = (appBaseAddr + 0x8F7EF);
		auto jumpAddr = (appBaseAddr + 0x8F7F7);
		constexpr uint32 size = 8;
		/*
		dmc3.exe+8F7EF - 41 8B 84 94 D82DC900 - MOV EAX,[R12+RDX*4+00C92DD8]
		dmc3.exe+8F7F7
		*/

		static Function func = {};

		constexpr byte8 sect0[] =
		{
			0x51 ,
			0x48, 0x8B, 0xCF ,
			0xE8, 0x00, 0x00, 0x00, 0x00 ,
			0x59 ,
			0x8B, 0x84, 0x90, 0x00, 0x00, 0x00, 0x00, // mov eax,[rax+rdx*4+0000B8C0]
		};

		if (!run)
		{
			backupHelper.Save(addr, size);
			func = CreateFunction(0, jumpAddr, false, false, sizeof(sect0));
			CopyMemory(func.sect0, sect0, sizeof(sect0));
			WriteCall((func.sect0 + 4), GetActorBaseAddressByEffectData);
			*reinterpret_cast<uint32 *>(func.sect0 + 0xD) = __builtin_offsetof(ActorData, newEffectIndices[6]) ;
		}

		if (enable)
		{
			WriteJump(addr, func.addr, (size - 5));
		}
		else
		{
			backupHelper.Restore(addr);
		}
	}
	{
		auto addr     = (appBaseAddr + 0x8F815);
		auto jumpAddr = (appBaseAddr + 0x8F81D);
		constexpr uint32 size = 8;
		/*
		dmc3.exe+8F815 - 41 31 9C 94 D82DC900 - XOR [R12+RDX*4+00C92DD8],EBX
		dmc3.exe+8F81D
		*/

		static Function func = {};

		constexpr byte8 sect0[] =
		{
			0x51 ,
			0x50 ,
			0x48, 0x8B, 0xCF ,
			0xE8, 0x00, 0x00, 0x00, 0x00 ,
			0x48, 0x8B, 0xC8 ,
			0x58 ,
			0x31, 0x9C, 0x91, 0x00, 0x00, 0x00, 0x00, // xor [rcx+rdx*4+0000B8C0],ebx
			0x59 ,
		};

		if (!run)
		{
			backupHelper.Save(addr, size);
			func = CreateFunction(0, jumpAddr, false, false, sizeof(sect0));
			CopyMemory(func.sect0, sect0, sizeof(sect0));
			WriteCall((func.sect0 + 5), GetActorBaseAddressByEffectData);
			*reinterpret_cast<uint32 *>(func.sect0 + 0x11) = __builtin_offsetof(ActorData, newEffectIndices[6]) ;
		}

		if (enable)
		{
			WriteJump(addr, func.addr, (size - 5));
		}
		else
		{
			backupHelper.Restore(addr);
		}
	}
	{
		auto addr = (appBaseAddr + 0x1E0B1F);
		constexpr uint32 size = 10;
		/*
		dmc3.exe+1E0B1F - 81 0D 9722AB00 00000080 - OR [7FF6784E2DC0],80000000
		dmc3.exe+1E0B29
		*/

		constexpr byte8 sect0[] =
		{
			0x81, 0x8B, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, // or [rbx+0000B8C0],80000000
		};
		static_assert(sizeof(sect0) == size);

		if (!run)
		{
			backupHelper.Save(addr, size);
		}

		if (enable)
		{
			protectionHelper.Push(addr, size);
			CopyMemory(addr, sect0, sizeof(sect0));
			*reinterpret_cast<uint32 *>(addr + 2) = __builtin_offsetof(ActorData, newEffectIndices[0]) ;
			protectionHelper.Pop();
		}
		else
		{
			backupHelper.Restore(addr);
		}
	}
	{
		auto addr = (appBaseAddr + 0x1EE0ED);
		constexpr uint32 size = 10;
		/*
		dmc3.exe+1EE0ED - 81 0D C94CAA00 00000080 - OR [7FF6784E2DC0],80000000
		dmc3.exe+1EE0F7
		*/

		constexpr byte8 sect0[] =
		{
			0x81, 0x8B, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, // or [rbx+0000B8C0],80000000
		};
		static_assert(sizeof(sect0) == size);

		if (!run)
		{
			backupHelper.Save(addr, size);
		}

		if (enable)
		{
			protectionHelper.Push(addr, size);
			CopyMemory(addr, sect0, sizeof(sect0));
			*reinterpret_cast<uint32 *>(addr + 2) = __builtin_offsetof(ActorData, newEffectIndices[0]) ;
			protectionHelper.Pop();
		}
		else
		{
			backupHelper.Restore(addr);
		}
	}
	{
		auto addr = (appBaseAddr + 0x1F1712);
		constexpr uint32 size = 10;
		/*
		dmc3.exe+1F1712 - 81 0D A416AA00 00000010 - OR [7FF6784E2DC0],10000000
		dmc3.exe+1F171C
		*/

		constexpr byte8 sect0[] =
		{
			0x81, 0x8B, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, // or [rbx+0000B8C0],10000000
		};
		static_assert(sizeof(sect0) == size);

		if (!run)
		{
			backupHelper.Save(addr, size);
		}

		if (enable)
		{
			protectionHelper.Push(addr, size);
			CopyMemory(addr, sect0, sizeof(sect0));
			*reinterpret_cast<uint32 *>(addr + 2) = __builtin_offsetof(ActorData, newEffectIndices[0]) ;
			protectionHelper.Pop();
		}
		else
		{
			backupHelper.Restore(addr);
		}
	}
	{
		auto addr = (appBaseAddr + 0x1F2C26);
		constexpr uint32 size = 10;
		/*
		dmc3.exe+1F2C26 - 81 0D 9001AA00 00000080 - OR [7FF6784E2DC0],80000000
		dmc3.exe+1F2C30
		*/

		constexpr byte8 sect0[] =
		{
			0x81, 0x8B, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, // or [rbx+0000B8C0],80000000
		};
		static_assert(sizeof(sect0) == size);

		if (!run)
		{
			backupHelper.Save(addr, size);
		}

		if (enable)
		{
			protectionHelper.Push(addr, size);
			CopyMemory(addr, sect0, sizeof(sect0));
			*reinterpret_cast<uint32 *>(addr + 2) = __builtin_offsetof(ActorData, newEffectIndices[0]) ;
			protectionHelper.Pop();
		}
		else
		{
			backupHelper.Restore(addr);
		}
	}
	{
		auto addr = (appBaseAddr + 0x1F2D56);
		constexpr uint32 size = 10;
		/*
		dmc3.exe+1F2D56 - 81 0D 6000AA00 00000080 - OR [7FF6784E2DC0],80000000
		dmc3.exe+1F2D60
		*/

		constexpr byte8 sect0[] =
		{
			0x81, 0x8B, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, // or [rbx+0000B8C0],80000000
		};
		static_assert(sizeof(sect0) == size);

		if (!run)
		{
			backupHelper.Save(addr, size);
		}

		if (enable)
		{
			protectionHelper.Push(addr, size);
			CopyMemory(addr, sect0, sizeof(sect0));
			*reinterpret_cast<uint32 *>(addr + 2) = __builtin_offsetof(ActorData, newEffectIndices[0]) ;
			protectionHelper.Pop();
		}
		else
		{
			backupHelper.Restore(addr);
		}
	}
	{
		auto addr = (appBaseAddr + 0x1F31CC);
		constexpr uint32 size = 10;
		/*
		dmc3.exe+1F31CC - 81 0D EAFBA900 00000080 - OR [7FF6784E2DC0],80000000
		dmc3.exe+1F31D6
		*/

		constexpr byte8 sect0[] =
		{
			0x81, 0x8B, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, // or [rbx+0000B8C0],80000000
		};
		static_assert(sizeof(sect0) == size);

		if (!run)
		{
			backupHelper.Save(addr, size);
		}

		if (enable)
		{
			protectionHelper.Push(addr, size);
			CopyMemory(addr, sect0, sizeof(sect0));
			*reinterpret_cast<uint32 *>(addr + 2) = __builtin_offsetof(ActorData, newEffectIndices[0]) ;
			protectionHelper.Pop();
		}
		else
		{
			backupHelper.Restore(addr);
		}
	}
	{
		auto addr = (appBaseAddr + 0x1F57D0);
		constexpr uint32 size = 10;
		/*
		dmc3.exe+1F57D0 - 81 0D E6D5A900 00000020 - OR [7FF6784E2DC0],20000000
		dmc3.exe+1F57DA
		*/

		constexpr byte8 sect0[] =
		{
			0x81, 0x8E, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x20, // or [rsi+0000B8C0],20000000
		};
		static_assert(sizeof(sect0) == size);

		if (!run)
		{
			backupHelper.Save(addr, size);
		}

		if (enable)
		{
			protectionHelper.Push(addr, size);
			CopyMemory(addr, sect0, sizeof(sect0));
			*reinterpret_cast<uint32 *>(addr + 2) = __builtin_offsetof(ActorData, newEffectIndices[0]) ;
			protectionHelper.Pop();
		}
		else
		{
			backupHelper.Restore(addr);
		}
	}
	{
		auto addr = (appBaseAddr + 0x1F5E47);
		constexpr uint32 size = 10;
		/*
		dmc3.exe+1F5E47 - 81 0D 6FCFA900 00000020 - OR [7FF6784E2DC0],20000000
		dmc3.exe+1F5E51
		*/

		constexpr byte8 sect0[] =
		{
			0x81, 0x8E, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x20, // or [rsi+0000B8C0],20000000
		};
		static_assert(sizeof(sect0) == size);

		if (!run)
		{
			backupHelper.Save(addr, size);
		}

		if (enable)
		{
			protectionHelper.Push(addr, size);
			CopyMemory(addr, sect0, sizeof(sect0));
			*reinterpret_cast<uint32 *>(addr + 2) = __builtin_offsetof(ActorData, newEffectIndices[0]) ;
			protectionHelper.Pop();
		}
		else
		{
			backupHelper.Restore(addr);
		}
	}
	{
		auto addr = (appBaseAddr + 0x1F6C21);
		constexpr uint32 size = 10;
		/*
		dmc3.exe+1F6C21 - 81 0D 95C1A900 00000010 - OR [7FF6784E2DC0],10000000
		dmc3.exe+1F6C2B
		*/

		constexpr byte8 sect0[] =
		{
			0x81, 0x8B, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, // or [rbx+0000B8C0],10000000
		};
		static_assert(sizeof(sect0) == size);

		if (!run)
		{
			backupHelper.Save(addr, size);
		}

		if (enable)
		{
			protectionHelper.Push(addr, size);
			CopyMemory(addr, sect0, sizeof(sect0));
			*reinterpret_cast<uint32 *>(addr + 2) = __builtin_offsetof(ActorData, newEffectIndices[0]) ;
			protectionHelper.Pop();
		}
		else
		{
			backupHelper.Restore(addr);
		}
	}
	{
		auto addr = (appBaseAddr + 0x20115E);
		constexpr uint32 size = 10;
		/*
		dmc3.exe+20115E - 81 0D 581CA900 00400000 - OR [7FF6784E2DC0],00004000
		dmc3.exe+201168
		*/

		constexpr byte8 sect0[] =
		{
			0x81, 0x8B, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x00, 0x00, // or [rbx+0000B8C0],00004000
		};
		static_assert(sizeof(sect0) == size);

		if (!run)
		{
			backupHelper.Save(addr, size);
		}

		if (enable)
		{
			protectionHelper.Push(addr, size);
			CopyMemory(addr, sect0, sizeof(sect0));
			*reinterpret_cast<uint32 *>(addr + 2) = __builtin_offsetof(ActorData, newEffectIndices[0]) ;
			protectionHelper.Pop();
		}
		else
		{
			backupHelper.Restore(addr);
		}
	}
	{
		auto addr = (appBaseAddr + 0x205846);
		constexpr uint32 size = 10;
		/*
		dmc3.exe+205846 - 81 0D 70D5A800 00100000 - OR [7FF6784E2DC0],00001000
		dmc3.exe+205850
		*/

		constexpr byte8 sect0[] =
		{
			0x81, 0x8F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0x00, 0x00, // or [rdi+0000B8C0],00001000
		};
		static_assert(sizeof(sect0) == size);

		if (!run)
		{
			backupHelper.Save(addr, size);
		}

		if (enable)
		{
			protectionHelper.Push(addr, size);
			CopyMemory(addr, sect0, sizeof(sect0));
			*reinterpret_cast<uint32 *>(addr + 2) = __builtin_offsetof(ActorData, newEffectIndices[0]) ;
			protectionHelper.Pop();
		}
		else
		{
			backupHelper.Restore(addr);
		}
	}
	{
		auto addr = (appBaseAddr + 0x2058FE);
		constexpr uint32 size = 10;
		/*
		dmc3.exe+2058FE - 81 0D B8D4A800 00100000 - OR [7FF6784E2DC0],00001000
		dmc3.exe+205908
		*/

		constexpr byte8 sect0[] =
		{
			0x81, 0x8F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0x00, 0x00, // or [rdi+0000B8C0],00001000
		};
		static_assert(sizeof(sect0) == size);

		if (!run)
		{
			backupHelper.Save(addr, size);
		}

		if (enable)
		{
			protectionHelper.Push(addr, size);
			CopyMemory(addr, sect0, sizeof(sect0));
			*reinterpret_cast<uint32 *>(addr + 2) = __builtin_offsetof(ActorData, newEffectIndices[0]) ;
			protectionHelper.Pop();
		}
		else
		{
			backupHelper.Restore(addr);
		}
	}
	{
		auto addr = (appBaseAddr + 0x205AC7);
		constexpr uint32 size = 10;
		/*
		dmc3.exe+205AC7 - 81 0D EFD2A800 00200000 - OR [7FF6784E2DC0],00002000
		dmc3.exe+205AD1
		*/

		constexpr byte8 sect0[] =
		{
			0x81, 0x8F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x20, 0x00, 0x00, // or [rdi+0000B8C0],00002000
		};
		static_assert(sizeof(sect0) == size);

		if (!run)
		{
			backupHelper.Save(addr, size);
		}

		if (enable)
		{
			protectionHelper.Push(addr, size);
			CopyMemory(addr, sect0, sizeof(sect0));
			*reinterpret_cast<uint32 *>(addr + 2) = __builtin_offsetof(ActorData, newEffectIndices[0]) ;
			protectionHelper.Pop();
		}
		else
		{
			backupHelper.Restore(addr);
		}
	}
	{
		auto addr = (appBaseAddr + 0x2091BD);
		constexpr uint32 size = 10;
		/*
		dmc3.exe+2091BD - 81 0D F99BA800 00080000 - OR [7FF6784E2DC0],00000800
		dmc3.exe+2091C7
		*/

		constexpr byte8 sect0[] =
		{
			0x81, 0x8F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, // or [rdi+0000B8C0],00000800
		};
		static_assert(sizeof(sect0) == size);

		if (!run)
		{
			backupHelper.Save(addr, size);
		}

		if (enable)
		{
			protectionHelper.Push(addr, size);
			CopyMemory(addr, sect0, sizeof(sect0));
			*reinterpret_cast<uint32 *>(addr + 2) = __builtin_offsetof(ActorData, newEffectIndices[0]) ;
			protectionHelper.Pop();
		}
		else
		{
			backupHelper.Restore(addr);
		}
	}
	{
		auto addr = (appBaseAddr + 0x2092A7);
		constexpr uint32 size = 10;
		/*
		dmc3.exe+2092A7 - 81 0D 0F9BA800 00080000 - OR [7FF6784E2DC0],00000800
		dmc3.exe+2092B1
		*/

		constexpr byte8 sect0[] =
		{
			0x81, 0x8F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, // or [rdi+0000B8C0],00000800
		};
		static_assert(sizeof(sect0) == size);

		if (!run)
		{
			backupHelper.Save(addr, size);
		}

		if (enable)
		{
			protectionHelper.Push(addr, size);
			CopyMemory(addr, sect0, sizeof(sect0));
			*reinterpret_cast<uint32 *>(addr + 2) = __builtin_offsetof(ActorData, newEffectIndices[0]) ;
			protectionHelper.Pop();
		}
		else
		{
			backupHelper.Restore(addr);
		}
	}
	{
		auto addr = (appBaseAddr + 0x20A29A);
		constexpr uint32 size = 10;
		/*
		dmc3.exe+20A29A - 81 0D 1C8BA800 00000400 - OR [7FF6784E2DC0],00040000
		dmc3.exe+20A2A4
		*/

		constexpr byte8 sect0[] =
		{
			0x81, 0x8B, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x04, 0x00, // or [rbx+0000B8C0],00040000
		};
		static_assert(sizeof(sect0) == size);

		if (!run)
		{
			backupHelper.Save(addr, size);
		}

		if (enable)
		{
			protectionHelper.Push(addr, size);
			CopyMemory(addr, sect0, sizeof(sect0));
			*reinterpret_cast<uint32 *>(addr + 2) = __builtin_offsetof(ActorData, newEffectIndices[0]) ;
			protectionHelper.Pop();
		}
		else
		{
			backupHelper.Restore(addr);
		}
	}
	{
		auto addr = (appBaseAddr + 0x20AA0E);
		constexpr uint32 size = 10;
		/*
		dmc3.exe+20AA0E - 81 0D A883A800 00000400 - OR [7FF6784E2DC0],00040000
		dmc3.exe+20AA18
		*/

		constexpr byte8 sect0[] =
		{
			0x81, 0x8F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x04, 0x00, // or [rdi+0000B8C0],00040000
		};
		static_assert(sizeof(sect0) == size);

		if (!run)
		{
			backupHelper.Save(addr, size);
		}

		if (enable)
		{
			protectionHelper.Push(addr, size);
			CopyMemory(addr, sect0, sizeof(sect0));
			*reinterpret_cast<uint32 *>(addr + 2) = __builtin_offsetof(ActorData, newEffectIndices[0]) ;
			protectionHelper.Pop();
		}
		else
		{
			backupHelper.Restore(addr);
		}
	}
	{
		auto addr = (appBaseAddr + 0x20AC23);
		constexpr uint32 size = 10;
		/*
		dmc3.exe+20AC23 - 81 0D 9381A800 00000400 - OR [7FF6784E2DC0],00040000
		dmc3.exe+20AC2D
		*/

		constexpr byte8 sect0[] =
		{
			0x81, 0x8F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x04, 0x00, // or [rdi+0000B8C0],00040000
		};
		static_assert(sizeof(sect0) == size);

		if (!run)
		{
			backupHelper.Save(addr, size);
		}

		if (enable)
		{
			protectionHelper.Push(addr, size);
			CopyMemory(addr, sect0, sizeof(sect0));
			*reinterpret_cast<uint32 *>(addr + 2) = __builtin_offsetof(ActorData, newEffectIndices[0]) ;
			protectionHelper.Pop();
		}
		else
		{
			backupHelper.Restore(addr);
		}
	}
	{
		auto addr = (appBaseAddr + 0x20ACAD);
		constexpr uint32 size = 10;
		/*
		dmc3.exe+20ACAD - 81 0D 0981A800 00000400 - OR [7FF6784E2DC0],00040000
		dmc3.exe+20ACB7
		*/

		constexpr byte8 sect0[] =
		{
			0x81, 0x8F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x04, 0x00, // or [rdi+0000B8C0],00040000
		};
		static_assert(sizeof(sect0) == size);

		if (!run)
		{
			backupHelper.Save(addr, size);
		}

		if (enable)
		{
			protectionHelper.Push(addr, size);
			CopyMemory(addr, sect0, sizeof(sect0));
			*reinterpret_cast<uint32 *>(addr + 2) = __builtin_offsetof(ActorData, newEffectIndices[0]) ;
			protectionHelper.Pop();
		}
		else
		{
			backupHelper.Restore(addr);
		}
	}
	{
		auto addr = (appBaseAddr + 0x20B34B);
		constexpr uint32 size = 10;
		/*
		dmc3.exe+20B34B - 81 0D 6B7AA800 00800000 - OR [7FF6784E2DC0],00008000
		dmc3.exe+20B355
		*/

		constexpr byte8 sect0[] =
		{
			0x81, 0x8B, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x00, 0x00, // or [rbx+0000B8C0],00008000
		};
		static_assert(sizeof(sect0) == size);

		if (!run)
		{
			backupHelper.Save(addr, size);
		}

		if (enable)
		{
			protectionHelper.Push(addr, size);
			CopyMemory(addr, sect0, sizeof(sect0));
			*reinterpret_cast<uint32 *>(addr + 2) = __builtin_offsetof(ActorData, newEffectIndices[0]) ;
			protectionHelper.Pop();
		}
		else
		{
			backupHelper.Restore(addr);
		}
	}
	{
		auto addr = (appBaseAddr + 0x20B84C);
		constexpr uint32 size = 10;
		/*
		dmc3.exe+20B84C - 81 0D 6A75A800 00800000 - OR [7FF6784E2DC0],00008000
		dmc3.exe+20B856
		*/

		constexpr byte8 sect0[] =
		{
			0x81, 0x8B, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x00, 0x00, // or [rbx+0000B8C0],00008000
		};
		static_assert(sizeof(sect0) == size);

		if (!run)
		{
			backupHelper.Save(addr, size);
		}

		if (enable)
		{
			protectionHelper.Push(addr, size);
			CopyMemory(addr, sect0, sizeof(sect0));
			*reinterpret_cast<uint32 *>(addr + 2) = __builtin_offsetof(ActorData, newEffectIndices[0]) ;
			protectionHelper.Pop();
		}
		else
		{
			backupHelper.Restore(addr);
		}
	}
	{
		auto addr = (appBaseAddr + 0x20E921);
		constexpr uint32 size = 10;
		/*
		dmc3.exe+20E921 - 81 0D 9544A800 00000008 - OR [7FF6784E2DC0],08000000
		dmc3.exe+20E92B
		*/

		constexpr byte8 sect0[] =
		{
			0x81, 0x8F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x08, // or [rdi+0000B8C0],08000000
		};
		static_assert(sizeof(sect0) == size);

		if (!run)
		{
			backupHelper.Save(addr, size);
		}

		if (enable)
		{
			protectionHelper.Push(addr, size);
			CopyMemory(addr, sect0, sizeof(sect0));
			*reinterpret_cast<uint32 *>(addr + 2) = __builtin_offsetof(ActorData, newEffectIndices[0]) ;
			protectionHelper.Pop();
		}
		else
		{
			backupHelper.Restore(addr);
		}
	}
	{
		auto addr = (appBaseAddr + 0x20F09E);
		constexpr uint32 size = 10;
		/*
		dmc3.exe+20F09E - 81 0D 183DA800 00000008 - OR [7FF6784E2DC0],08000000
		dmc3.exe+20F0A8
		*/

		constexpr byte8 sect0[] =
		{
			0x81, 0x8F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x08, // or [rdi+0000B8C0],08000000
		};
		static_assert(sizeof(sect0) == size);

		if (!run)
		{
			backupHelper.Save(addr, size);
		}

		if (enable)
		{
			protectionHelper.Push(addr, size);
			CopyMemory(addr, sect0, sizeof(sect0));
			*reinterpret_cast<uint32 *>(addr + 2) = __builtin_offsetof(ActorData, newEffectIndices[0]) ;
			protectionHelper.Pop();
		}
		else
		{
			backupHelper.Restore(addr);
		}
	}
	{
		auto addr = (appBaseAddr + 0x20FBEE);
		constexpr uint32 size = 10;
		/*
		dmc3.exe+20FBEE - 81 0D C831A800 00400000 - OR [7FF6784E2DC0],00004000
		dmc3.exe+20FBF8
		*/

		constexpr byte8 sect0[] =
		{
			0x81, 0x8B, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x00, 0x00, // or [rbx+0000B8C0],00004000
		};
		static_assert(sizeof(sect0) == size);

		if (!run)
		{
			backupHelper.Save(addr, size);
		}

		if (enable)
		{
			protectionHelper.Push(addr, size);
			CopyMemory(addr, sect0, sizeof(sect0));
			*reinterpret_cast<uint32 *>(addr + 2) = __builtin_offsetof(ActorData, newEffectIndices[0]) ;
			protectionHelper.Pop();
		}
		else
		{
			backupHelper.Restore(addr);
		}
	}
	{
		auto addr = (appBaseAddr + 0x20FEAC);
		constexpr uint32 size = 10;
		/*
		dmc3.exe+20FEAC - 81 0D 0A2FA800 00000200 - OR [7FF6784E2DC0],00020000
		dmc3.exe+20FEB6
		*/

		constexpr byte8 sect0[] =
		{
			0x81, 0x8B, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x00, // or [rbx+0000B8C0],00020000
		};
		static_assert(sizeof(sect0) == size);

		if (!run)
		{
			backupHelper.Save(addr, size);
		}

		if (enable)
		{
			protectionHelper.Push(addr, size);
			CopyMemory(addr, sect0, sizeof(sect0));
			*reinterpret_cast<uint32 *>(addr + 2) = __builtin_offsetof(ActorData, newEffectIndices[0]) ;
			protectionHelper.Pop();
		}
		else
		{
			backupHelper.Restore(addr);
		}
	}
	{
		auto addr = (appBaseAddr + 0x2107BE);
		constexpr uint32 size = 10;
		/*
		dmc3.exe+2107BE - 81 0D F825A800 00040000 - OR [7FF6784E2DC0],00000400
		dmc3.exe+2107C8
		*/

		constexpr byte8 sect0[] =
		{
			0x81, 0x8B, 0x00, 0x00, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, // or [rbx+0000B8C0],00000400
		};
		static_assert(sizeof(sect0) == size);

		if (!run)
		{
			backupHelper.Save(addr, size);
		}

		if (enable)
		{
			protectionHelper.Push(addr, size);
			CopyMemory(addr, sect0, sizeof(sect0));
			*reinterpret_cast<uint32 *>(addr + 2) = __builtin_offsetof(ActorData, newEffectIndices[0]) ;
			protectionHelper.Pop();
		}
		else
		{
			backupHelper.Restore(addr);
		}
	}
	{
		auto addr = (appBaseAddr + 0x210881);
		constexpr uint32 size = 10;
		/*
		dmc3.exe+210881 - 81 0D 3525A800 00040000 - OR [7FF6784E2DC0],00000400
		dmc3.exe+21088B
		*/

		constexpr byte8 sect0[] =
		{
			0x81, 0x8B, 0x00, 0x00, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, // or [rbx+0000B8C0],00000400
		};
		static_assert(sizeof(sect0) == size);

		if (!run)
		{
			backupHelper.Save(addr, size);
		}

		if (enable)
		{
			protectionHelper.Push(addr, size);
			CopyMemory(addr, sect0, sizeof(sect0));
			*reinterpret_cast<uint32 *>(addr + 2) = __builtin_offsetof(ActorData, newEffectIndices[0]) ;
			protectionHelper.Pop();
		}
		else
		{
			backupHelper.Restore(addr);
		}
	}
	{
		auto addr = (appBaseAddr + 0x211937);
		constexpr uint32 size = 10;
		/*
		dmc3.exe+211937 - 81 0D 7F14A800 00040000 - OR [7FF6784E2DC0],00000400
		dmc3.exe+211941
		*/

		constexpr byte8 sect0[] =
		{
			0x81, 0x8B, 0x00, 0x00, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, // or [rbx+0000B8C0],00000400
		};
		static_assert(sizeof(sect0) == size);

		if (!run)
		{
			backupHelper.Save(addr, size);
		}

		if (enable)
		{
			protectionHelper.Push(addr, size);
			CopyMemory(addr, sect0, sizeof(sect0));
			*reinterpret_cast<uint32 *>(addr + 2) = __builtin_offsetof(ActorData, newEffectIndices[0]) ;
			protectionHelper.Pop();
		}
		else
		{
			backupHelper.Restore(addr);
		}
	}
	{
		auto addr = (appBaseAddr + 0x211A99);
		constexpr uint32 size = 10;
		/*
		dmc3.exe+211A99 - 81 0D 1D13A800 00040000 - OR [7FF6784E2DC0],00000400
		dmc3.exe+211AA3
		*/

		constexpr byte8 sect0[] =
		{
			0x81, 0x8B, 0x00, 0x00, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, // or [rbx+0000B8C0],00000400
		};
		static_assert(sizeof(sect0) == size);

		if (!run)
		{
			backupHelper.Save(addr, size);
		}

		if (enable)
		{
			protectionHelper.Push(addr, size);
			CopyMemory(addr, sect0, sizeof(sect0));
			*reinterpret_cast<uint32 *>(addr + 2) = __builtin_offsetof(ActorData, newEffectIndices[0]) ;
			protectionHelper.Pop();
		}
		else
		{
			backupHelper.Restore(addr);
		}
	}
	{
		auto addr = (appBaseAddr + 0x215D50);
		constexpr uint32 size = 10;
		/*
		dmc3.exe+215D50 - 81 0D 66D0A700 00000040 - OR [7FF6784E2DC0],40000000
		dmc3.exe+215D5A
		*/

		constexpr byte8 sect0[] =
		{
			0x81, 0x8F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, // or [rdi+0000B8C0],40000000
		};
		static_assert(sizeof(sect0) == size);

		if (!run)
		{
			backupHelper.Save(addr, size);
		}

		if (enable)
		{
			protectionHelper.Push(addr, size);
			CopyMemory(addr, sect0, sizeof(sect0));
			*reinterpret_cast<uint32 *>(addr + 2) = __builtin_offsetof(ActorData, newEffectIndices[0]) ;
			protectionHelper.Pop();
		}
		else
		{
			backupHelper.Restore(addr);
		}
	}
	{
		auto addr = (appBaseAddr + 0x215F9C);
		constexpr uint32 size = 10;
		/*
		dmc3.exe+215F9C - 81 0D 1ACEA700 00000040 - OR [7FF6784E2DC0],40000000
		dmc3.exe+215FA6
		*/

		constexpr byte8 sect0[] =
		{
			0x81, 0x8F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, // or [rdi+0000B8C0],40000000
		};
		static_assert(sizeof(sect0) == size);

		if (!run)
		{
			backupHelper.Save(addr, size);
		}

		if (enable)
		{
			protectionHelper.Push(addr, size);
			CopyMemory(addr, sect0, sizeof(sect0));
			*reinterpret_cast<uint32 *>(addr + 2) = __builtin_offsetof(ActorData, newEffectIndices[0]) ;
			protectionHelper.Pop();
		}
		else
		{
			backupHelper.Restore(addr);
		}
	}
	{
		auto addr = (appBaseAddr + 0x21622B);
		constexpr uint32 size = 10;
		/*
		dmc3.exe+21622B - 81 0D 8BCBA700 0000E001 - OR [7FF6784E2DC0],01E00000
		dmc3.exe+216235
		*/

		constexpr byte8 sect0[] =
		{
			0x81, 0x8F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xE0, 0x01, // or [rdi+0000B8C0],01E00000
		};
		static_assert(sizeof(sect0) == size);

		if (!run)
		{
			backupHelper.Save(addr, size);
		}

		if (enable)
		{
			protectionHelper.Push(addr, size);
			CopyMemory(addr, sect0, sizeof(sect0));
			*reinterpret_cast<uint32 *>(addr + 2) = __builtin_offsetof(ActorData, newEffectIndices[0]) ;
			protectionHelper.Pop();
		}
		else
		{
			backupHelper.Restore(addr);
		}
	}
	{
		auto addr = (appBaseAddr + 0x216434);
		constexpr uint32 size = 10;
		/*
		dmc3.exe+216434 - 81 0D 82C9A700 00000006 - OR [7FF6784E2DC0],06000000
		dmc3.exe+21643E
		*/

		constexpr byte8 sect0[] =
		{
			0x81, 0x8F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x06, // or [rdi+0000B8C0],06000000
		};
		static_assert(sizeof(sect0) == size);

		if (!run)
		{
			backupHelper.Save(addr, size);
		}

		if (enable)
		{
			protectionHelper.Push(addr, size);
			CopyMemory(addr, sect0, sizeof(sect0));
			*reinterpret_cast<uint32 *>(addr + 2) = __builtin_offsetof(ActorData, newEffectIndices[0]) ;
			protectionHelper.Pop();
		}
		else
		{
			backupHelper.Restore(addr);
		}
	}
	{
		auto addr = (appBaseAddr + 0x1E14C4);
		constexpr uint32 size = 10;
		/*
		dmc3.exe+1E14C4 - 81 0D F618AB00 00000008 - OR [7FF6784E2DC4],08000000
		dmc3.exe+1E14CE
		*/

		constexpr byte8 sect0[] =
		{
			0x81, 0x8B, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x08, // or [rbx+0000B8C0],08000000
		};
		static_assert(sizeof(sect0) == size);

		if (!run)
		{
			backupHelper.Save(addr, size);
		}

		if (enable)
		{
			protectionHelper.Push(addr, size);
			CopyMemory(addr, sect0, sizeof(sect0));
			*reinterpret_cast<uint32 *>(addr + 2) = __builtin_offsetof(ActorData, newEffectIndices[1]) ;
			protectionHelper.Pop();
		}
		else
		{
			backupHelper.Restore(addr);
		}
	}
	{
		auto addr = (appBaseAddr + 0x1F7CD2);
		constexpr uint32 size = 10;
		/*
		dmc3.exe+1F7CD2 - 81 0D E8B0A900 00000008 - OR [7FF6784E2DC4],08000000
		dmc3.exe+1F7CDC
		*/

		constexpr byte8 sect0[] =
		{
			0x81, 0x8B, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x08, // or [rbx+0000B8C0],08000000
		};
		static_assert(sizeof(sect0) == size);

		if (!run)
		{
			backupHelper.Save(addr, size);
		}

		if (enable)
		{
			protectionHelper.Push(addr, size);
			CopyMemory(addr, sect0, sizeof(sect0));
			*reinterpret_cast<uint32 *>(addr + 2) = __builtin_offsetof(ActorData, newEffectIndices[1]) ;
			protectionHelper.Pop();
		}
		else
		{
			backupHelper.Restore(addr);
		}
	}
	{
		auto addr = (appBaseAddr + 0x1F950C);
		constexpr uint32 size = 6;
		/*
		dmc3.exe+1F950C - 8B 05 B298A900 - MOV EAX,[7FF6784E2DC4]
		dmc3.exe+1F9512
		*/

		constexpr byte8 sect0[] =
		{
			0x8B, 0x83, 0x00, 0x00, 0x00, 0x00, // mov eax,[rbx+0000B8C0]
		};
		static_assert(sizeof(sect0) == size);

		if (!run)
		{
			backupHelper.Save(addr, size);
		}

		if (enable)
		{
			protectionHelper.Push(addr, size);
			CopyMemory(addr, sect0, sizeof(sect0));
			*reinterpret_cast<uint32 *>(addr + 2) = __builtin_offsetof(ActorData, newEffectIndices[1]) ;
			protectionHelper.Pop();
		}
		else
		{
			backupHelper.Restore(addr);
		}
	}
	{
		auto addr = (appBaseAddr + 0x1F9526);
		constexpr uint32 size = 6;
		/*
		dmc3.exe+1F9526 - 89 05 9898A900 - MOV [7FF6784E2DC4],EAX
		dmc3.exe+1F952C
		*/

		constexpr byte8 sect0[] =
		{
			0x89, 0x83, 0x00, 0x00, 0x00, 0x00, // mov [rbx+0000B8C0],eax
		};
		static_assert(sizeof(sect0) == size);

		if (!run)
		{
			backupHelper.Save(addr, size);
		}

		if (enable)
		{
			protectionHelper.Push(addr, size);
			CopyMemory(addr, sect0, sizeof(sect0));
			*reinterpret_cast<uint32 *>(addr + 2) = __builtin_offsetof(ActorData, newEffectIndices[1]) ;
			protectionHelper.Pop();
		}
		else
		{
			backupHelper.Restore(addr);
		}
	}
	{
		auto addr = (appBaseAddr + 0x1F9542);
		constexpr uint32 size = 6;
		/*
		dmc3.exe+1F9542 - 8B 05 7C98A900 - MOV EAX,[7FF6784E2DC4]
		dmc3.exe+1F9548
		*/

		constexpr byte8 sect0[] =
		{
			0x8B, 0x83, 0x00, 0x00, 0x00, 0x00, // mov eax,[rbx+0000B8C0]
		};
		static_assert(sizeof(sect0) == size);

		if (!run)
		{
			backupHelper.Save(addr, size);
		}

		if (enable)
		{
			protectionHelper.Push(addr, size);
			CopyMemory(addr, sect0, sizeof(sect0));
			*reinterpret_cast<uint32 *>(addr + 2) = __builtin_offsetof(ActorData, newEffectIndices[1]) ;
			protectionHelper.Pop();
		}
		else
		{
			backupHelper.Restore(addr);
		}
	}
	{
		auto addr = (appBaseAddr + 0x1F956C);
		constexpr uint32 size = 6;
		/*
		dmc3.exe+1F956C - 89 05 5298A900 - MOV [7FF6784E2DC4],EAX
		dmc3.exe+1F9572
		*/

		constexpr byte8 sect0[] =
		{
			0x89, 0x83, 0x00, 0x00, 0x00, 0x00, // mov [rbx+0000B8C0],eax
		};
		static_assert(sizeof(sect0) == size);

		if (!run)
		{
			backupHelper.Save(addr, size);
		}

		if (enable)
		{
			protectionHelper.Push(addr, size);
			CopyMemory(addr, sect0, sizeof(sect0));
			*reinterpret_cast<uint32 *>(addr + 2) = __builtin_offsetof(ActorData, newEffectIndices[1]) ;
			protectionHelper.Pop();
		}
		else
		{
			backupHelper.Restore(addr);
		}
	}
	{
		auto addr = (appBaseAddr + 0x201513);
		constexpr uint32 size = 10;
		/*
		dmc3.exe+201513 - 81 0D A718A900 00001000 - OR [7FF6784E2DC4],00100000
		dmc3.exe+20151D
		*/

		constexpr byte8 sect0[] =
		{
			0x81, 0x8B, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0x00, // or [rbx+0000B8C0],00100000
		};
		static_assert(sizeof(sect0) == size);

		if (!run)
		{
			backupHelper.Save(addr, size);
		}

		if (enable)
		{
			protectionHelper.Push(addr, size);
			CopyMemory(addr, sect0, sizeof(sect0));
			*reinterpret_cast<uint32 *>(addr + 2) = __builtin_offsetof(ActorData, newEffectIndices[1]) ;
			protectionHelper.Pop();
		}
		else
		{
			backupHelper.Restore(addr);
		}
	}
	{
		auto addr = (appBaseAddr + 0x20222C);
		constexpr uint32 size = 10;
		/*
		dmc3.exe+20222C - 81 0D 8E0BA900 00800000 - OR [7FF6784E2DC4],00008000
		dmc3.exe+202236
		*/

		constexpr byte8 sect0[] =
		{
			0x81, 0x8B, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x00, 0x00, // or [rbx+0000B8C0],00008000
		};
		static_assert(sizeof(sect0) == size);

		if (!run)
		{
			backupHelper.Save(addr, size);
		}

		if (enable)
		{
			protectionHelper.Push(addr, size);
			CopyMemory(addr, sect0, sizeof(sect0));
			*reinterpret_cast<uint32 *>(addr + 2) = __builtin_offsetof(ActorData, newEffectIndices[1]) ;
			protectionHelper.Pop();
		}
		else
		{
			backupHelper.Restore(addr);
		}
	}
	{
		auto addr = (appBaseAddr + 0x2022EB);
		constexpr uint32 size = 10;
		/*
		dmc3.exe+2022EB - 81 0D CF0AA900 00800000 - OR [7FF6784E2DC4],00008000
		dmc3.exe+2022F5
		*/

		constexpr byte8 sect0[] =
		{
			0x81, 0x8B, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x00, 0x00, // or [rbx+0000B8C0],00008000
		};
		static_assert(sizeof(sect0) == size);

		if (!run)
		{
			backupHelper.Save(addr, size);
		}

		if (enable)
		{
			protectionHelper.Push(addr, size);
			CopyMemory(addr, sect0, sizeof(sect0));
			*reinterpret_cast<uint32 *>(addr + 2) = __builtin_offsetof(ActorData, newEffectIndices[1]) ;
			protectionHelper.Pop();
		}
		else
		{
			backupHelper.Restore(addr);
		}
	}
	{
		auto addr = (appBaseAddr + 0x2023AA);
		constexpr uint32 size = 10;
		/*
		dmc3.exe+2023AA - 81 0D 100AA900 00800000 - OR [7FF6784E2DC4],00008000
		dmc3.exe+2023B4
		*/

		constexpr byte8 sect0[] =
		{
			0x81, 0x8B, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x00, 0x00, // or [rbx+0000B8C0],00008000
		};
		static_assert(sizeof(sect0) == size);

		if (!run)
		{
			backupHelper.Save(addr, size);
		}

		if (enable)
		{
			protectionHelper.Push(addr, size);
			CopyMemory(addr, sect0, sizeof(sect0));
			*reinterpret_cast<uint32 *>(addr + 2) = __builtin_offsetof(ActorData, newEffectIndices[1]) ;
			protectionHelper.Pop();
		}
		else
		{
			backupHelper.Restore(addr);
		}
	}
	{
		auto addr = (appBaseAddr + 0x202517);
		constexpr uint32 size = 10;
		/*
		dmc3.exe+202517 - 81 0D A308A900 00000100 - OR [7FF6784E2DC4],00010000
		dmc3.exe+202521
		*/

		constexpr byte8 sect0[] =
		{
			0x81, 0x8B, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, // or [rbx+0000B8C0],00010000
		};
		static_assert(sizeof(sect0) == size);

		if (!run)
		{
			backupHelper.Save(addr, size);
		}

		if (enable)
		{
			protectionHelper.Push(addr, size);
			CopyMemory(addr, sect0, sizeof(sect0));
			*reinterpret_cast<uint32 *>(addr + 2) = __builtin_offsetof(ActorData, newEffectIndices[1]) ;
			protectionHelper.Pop();
		}
		else
		{
			backupHelper.Restore(addr);
		}
	}
	{
		auto addr = (appBaseAddr + 0x2025DA);
		constexpr uint32 size = 10;
		/*
		dmc3.exe+2025DA - 81 0D E007A900 00000100 - OR [7FF6784E2DC4],00010000
		dmc3.exe+2025E4
		*/

		constexpr byte8 sect0[] =
		{
			0x81, 0x8B, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, // or [rbx+0000B8C0],00010000
		};
		static_assert(sizeof(sect0) == size);

		if (!run)
		{
			backupHelper.Save(addr, size);
		}

		if (enable)
		{
			protectionHelper.Push(addr, size);
			CopyMemory(addr, sect0, sizeof(sect0));
			*reinterpret_cast<uint32 *>(addr + 2) = __builtin_offsetof(ActorData, newEffectIndices[1]) ;
			protectionHelper.Pop();
		}
		else
		{
			backupHelper.Restore(addr);
		}
	}
	{
		auto addr = (appBaseAddr + 0x2029E3);
		constexpr uint32 size = 10;
		/*
		dmc3.exe+2029E3 - 81 0D D703A900 00000800 - OR [7FF6784E2DC4],00080000
		dmc3.exe+2029ED
		*/

		constexpr byte8 sect0[] =
		{
			0x81, 0x8B, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x08, 0x00, // or [rbx+0000B8C0],00080000
		};
		static_assert(sizeof(sect0) == size);

		if (!run)
		{
			backupHelper.Save(addr, size);
		}

		if (enable)
		{
			protectionHelper.Push(addr, size);
			CopyMemory(addr, sect0, sizeof(sect0));
			*reinterpret_cast<uint32 *>(addr + 2) = __builtin_offsetof(ActorData, newEffectIndices[1]) ;
			protectionHelper.Pop();
		}
		else
		{
			backupHelper.Restore(addr);
		}
	}
	{
		auto addr = (appBaseAddr + 0x202AEC);
		constexpr uint32 size = 10;
		/*
		dmc3.exe+202AEC - 81 0D CE02A900 00000800 - OR [7FF6784E2DC4],00080000
		dmc3.exe+202AF6
		*/

		constexpr byte8 sect0[] =
		{
			0x81, 0x8B, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x08, 0x00, // or [rbx+0000B8C0],00080000
		};
		static_assert(sizeof(sect0) == size);

		if (!run)
		{
			backupHelper.Save(addr, size);
		}

		if (enable)
		{
			protectionHelper.Push(addr, size);
			CopyMemory(addr, sect0, sizeof(sect0));
			*reinterpret_cast<uint32 *>(addr + 2) = __builtin_offsetof(ActorData, newEffectIndices[1]) ;
			protectionHelper.Pop();
		}
		else
		{
			backupHelper.Restore(addr);
		}
	}
	{
		auto addr = (appBaseAddr + 0x20302B);
		constexpr uint32 size = 10;
		/*
		dmc3.exe+20302B - 81 0D 8FFDA800 00000010 - OR [7FF6784E2DC4],10000000
		dmc3.exe+203035
		*/

		constexpr byte8 sect0[] =
		{
			0x81, 0x8B, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, // or [rbx+0000B8C0],10000000
		};
		static_assert(sizeof(sect0) == size);

		if (!run)
		{
			backupHelper.Save(addr, size);
		}

		if (enable)
		{
			protectionHelper.Push(addr, size);
			CopyMemory(addr, sect0, sizeof(sect0));
			*reinterpret_cast<uint32 *>(addr + 2) = __builtin_offsetof(ActorData, newEffectIndices[1]) ;
			protectionHelper.Pop();
		}
		else
		{
			backupHelper.Restore(addr);
		}
	}
	{
		auto addr = (appBaseAddr + 0x20364D);
		constexpr uint32 size = 10;
		/*
		dmc3.exe+20364D - 81 0D 6DF7A800 00002000 - OR [7FF6784E2DC4],00200000
		dmc3.exe+203657
		*/

		constexpr byte8 sect0[] =
		{
			0x81, 0x8B, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x20, 0x00, // or [rbx+0000B8C0],00200000
		};
		static_assert(sizeof(sect0) == size);

		if (!run)
		{
			backupHelper.Save(addr, size);
		}

		if (enable)
		{
			protectionHelper.Push(addr, size);
			CopyMemory(addr, sect0, sizeof(sect0));
			*reinterpret_cast<uint32 *>(addr + 2) = __builtin_offsetof(ActorData, newEffectIndices[1]) ;
			protectionHelper.Pop();
		}
		else
		{
			backupHelper.Restore(addr);
		}
	}
	{
		auto addr = (appBaseAddr + 0x204320);
		constexpr uint32 size = 10;
		/*
		dmc3.exe+204320 - 81 0D 9AEAA800 00008000 - OR [7FF6784E2DC4],00800000
		dmc3.exe+20432A
		*/

		constexpr byte8 sect0[] =
		{
			0x81, 0x8B, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x00, // or [rbx+0000B8C0],00800000
		};
		static_assert(sizeof(sect0) == size);

		if (!run)
		{
			backupHelper.Save(addr, size);
		}

		if (enable)
		{
			protectionHelper.Push(addr, size);
			CopyMemory(addr, sect0, sizeof(sect0));
			*reinterpret_cast<uint32 *>(addr + 2) = __builtin_offsetof(ActorData, newEffectIndices[1]) ;
			protectionHelper.Pop();
		}
		else
		{
			backupHelper.Restore(addr);
		}
	}
	{
		auto addr = (appBaseAddr + 0x20436C);
		constexpr uint32 size = 10;
		/*
		dmc3.exe+20436C - 81 0D 4EEAA800 00004000 - OR [7FF6784E2DC4],00400000
		dmc3.exe+204376
		*/

		constexpr byte8 sect0[] =
		{
			0x81, 0x8B, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x00, // or [rbx+0000B8C0],00400000
		};
		static_assert(sizeof(sect0) == size);

		if (!run)
		{
			backupHelper.Save(addr, size);
		}

		if (enable)
		{
			protectionHelper.Push(addr, size);
			CopyMemory(addr, sect0, sizeof(sect0));
			*reinterpret_cast<uint32 *>(addr + 2) = __builtin_offsetof(ActorData, newEffectIndices[1]) ;
			protectionHelper.Pop();
		}
		else
		{
			backupHelper.Restore(addr);
		}
	}
	{
		auto addr = (appBaseAddr + 0x20441E);
		constexpr uint32 size = 10;
		/*
		dmc3.exe+20441E - 81 0D 9CE9A800 00004000 - OR [7FF6784E2DC4],00400000
		dmc3.exe+204428
		*/

		constexpr byte8 sect0[] =
		{
			0x81, 0x8B, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x00, // or [rbx+0000B8C0],00400000
		};
		static_assert(sizeof(sect0) == size);

		if (!run)
		{
			backupHelper.Save(addr, size);
		}

		if (enable)
		{
			protectionHelper.Push(addr, size);
			CopyMemory(addr, sect0, sizeof(sect0));
			*reinterpret_cast<uint32 *>(addr + 2) = __builtin_offsetof(ActorData, newEffectIndices[1]) ;
			protectionHelper.Pop();
		}
		else
		{
			backupHelper.Restore(addr);
		}
	}
	{
		auto addr = (appBaseAddr + 0x204840);
		constexpr uint32 size = 10;
		/*
		dmc3.exe+204840 - 81 0D 7AE5A800 00000200 - OR [7FF6784E2DC4],00020000
		dmc3.exe+20484A
		*/

		constexpr byte8 sect0[] =
		{
			0x81, 0x8B, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x00, // or [rbx+0000B8C0],00020000
		};
		static_assert(sizeof(sect0) == size);

		if (!run)
		{
			backupHelper.Save(addr, size);
		}

		if (enable)
		{
			protectionHelper.Push(addr, size);
			CopyMemory(addr, sect0, sizeof(sect0));
			*reinterpret_cast<uint32 *>(addr + 2) = __builtin_offsetof(ActorData, newEffectIndices[1]) ;
			protectionHelper.Pop();
		}
		else
		{
			backupHelper.Restore(addr);
		}
	}
	{
		auto addr = (appBaseAddr + 0x209E7B);
		constexpr uint32 size = 10;
		/*
		dmc3.exe+209E7B - 81 0D 3F8FA800 00040000 - OR [7FF6784E2DC4],00000400
		dmc3.exe+209E85
		*/

		constexpr byte8 sect0[] =
		{
			0x81, 0x8B, 0x00, 0x00, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, // or [rbx+0000B8C0],00000400
		};
		static_assert(sizeof(sect0) == size);

		if (!run)
		{
			backupHelper.Save(addr, size);
		}

		if (enable)
		{
			protectionHelper.Push(addr, size);
			CopyMemory(addr, sect0, sizeof(sect0));
			*reinterpret_cast<uint32 *>(addr + 2) = __builtin_offsetof(ActorData, newEffectIndices[1]) ;
			protectionHelper.Pop();
		}
		else
		{
			backupHelper.Restore(addr);
		}
	}
	{
		auto addr = (appBaseAddr + 0x209F1D);
		constexpr uint32 size = 10;
		/*
		dmc3.exe+209F1D - 81 0D 9D8EA800 00040000 - OR [7FF6784E2DC4],00000400
		dmc3.exe+209F27
		*/

		constexpr byte8 sect0[] =
		{
			0x81, 0x8B, 0x00, 0x00, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, // or [rbx+0000B8C0],00000400
		};
		static_assert(sizeof(sect0) == size);

		if (!run)
		{
			backupHelper.Save(addr, size);
		}

		if (enable)
		{
			protectionHelper.Push(addr, size);
			CopyMemory(addr, sect0, sizeof(sect0));
			*reinterpret_cast<uint32 *>(addr + 2) = __builtin_offsetof(ActorData, newEffectIndices[1]) ;
			protectionHelper.Pop();
		}
		else
		{
			backupHelper.Restore(addr);
		}
	}
	{
		auto addr = (appBaseAddr + 0x20A195);
		constexpr uint32 size = 10;
		/*
		dmc3.exe+20A195 - 81 0D 258CA800 00000080 - OR [7FF6784E2DC4],80000000
		dmc3.exe+20A19F
		*/

		constexpr byte8 sect0[] =
		{
			0x81, 0x8B, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, // or [rbx+0000B8C0],80000000
		};
		static_assert(sizeof(sect0) == size);

		if (!run)
		{
			backupHelper.Save(addr, size);
		}

		if (enable)
		{
			protectionHelper.Push(addr, size);
			CopyMemory(addr, sect0, sizeof(sect0));
			*reinterpret_cast<uint32 *>(addr + 2) = __builtin_offsetof(ActorData, newEffectIndices[1]) ;
			protectionHelper.Pop();
		}
		else
		{
			backupHelper.Restore(addr);
		}
	}
	{
		auto addr = (appBaseAddr + 0x20A2A4);
		constexpr uint32 size = 10;
		/*
		dmc3.exe+20A2A4 - 81 0D 168BA800 00000001 - OR [7FF6784E2DC4],01000000
		dmc3.exe+20A2AE
		*/

		constexpr byte8 sect0[] =
		{
			0x81, 0x8B, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, // or [rbx+0000B8C0],01000000
		};
		static_assert(sizeof(sect0) == size);

		if (!run)
		{
			backupHelper.Save(addr, size);
		}

		if (enable)
		{
			protectionHelper.Push(addr, size);
			CopyMemory(addr, sect0, sizeof(sect0));
			*reinterpret_cast<uint32 *>(addr + 2) = __builtin_offsetof(ActorData, newEffectIndices[1]) ;
			protectionHelper.Pop();
		}
		else
		{
			backupHelper.Restore(addr);
		}
	}
	{
		auto addr = (appBaseAddr + 0x20A5B3);
		constexpr uint32 size = 10;
		/*
		dmc3.exe+20A5B3 - 81 0D 0788A800 00100000 - OR [7FF6784E2DC4],00001000
		dmc3.exe+20A5BD
		*/

		constexpr byte8 sect0[] =
		{
			0x81, 0x8B, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0x00, 0x00, // or [rbx+0000B8C0],00001000
		};
		static_assert(sizeof(sect0) == size);

		if (!run)
		{
			backupHelper.Save(addr, size);
		}

		if (enable)
		{
			protectionHelper.Push(addr, size);
			CopyMemory(addr, sect0, sizeof(sect0));
			*reinterpret_cast<uint32 *>(addr + 2) = __builtin_offsetof(ActorData, newEffectIndices[1]) ;
			protectionHelper.Pop();
		}
		else
		{
			backupHelper.Restore(addr);
		}
	}
	{
		auto addr = (appBaseAddr + 0x20A601);
		constexpr uint32 size = 10;
		/*
		dmc3.exe+20A601 - 81 0D B987A800 00080000 - OR [7FF6784E2DC4],00000800
		dmc3.exe+20A60B
		*/

		constexpr byte8 sect0[] =
		{
			0x81, 0x8B, 0x00, 0x00, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, // or [rbx+0000B8C0],00000800
		};
		static_assert(sizeof(sect0) == size);

		if (!run)
		{
			backupHelper.Save(addr, size);
		}

		if (enable)
		{
			protectionHelper.Push(addr, size);
			CopyMemory(addr, sect0, sizeof(sect0));
			*reinterpret_cast<uint32 *>(addr + 2) = __builtin_offsetof(ActorData, newEffectIndices[1]) ;
			protectionHelper.Pop();
		}
		else
		{
			backupHelper.Restore(addr);
		}
	}
	{
		auto addr = (appBaseAddr + 0x20A740);
		constexpr uint32 size = 10;
		/*
		dmc3.exe+20A740 - 81 0D 7A86A800 00080000 - OR [7FF6784E2DC4],00000800
		dmc3.exe+20A74A
		*/

		constexpr byte8 sect0[] =
		{
			0x81, 0x8B, 0x00, 0x00, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, // or [rbx+0000B8C0],00000800
		};
		static_assert(sizeof(sect0) == size);

		if (!run)
		{
			backupHelper.Save(addr, size);
		}

		if (enable)
		{
			protectionHelper.Push(addr, size);
			CopyMemory(addr, sect0, sizeof(sect0));
			*reinterpret_cast<uint32 *>(addr + 2) = __builtin_offsetof(ActorData, newEffectIndices[1]) ;
			protectionHelper.Pop();
		}
		else
		{
			backupHelper.Restore(addr);
		}
	}
	{
		auto addr = (appBaseAddr + 0x20AED5);
		constexpr uint32 size = 10;
		/*
		dmc3.exe+20AED5 - 81 0D E57EA800 00000400 - OR [7FF6784E2DC4],00040000
		dmc3.exe+20AEDF
		*/

		constexpr byte8 sect0[] =
		{
			0x81, 0x8B, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x04, 0x00, // or [rbx+0000B8C0],00040000
		};
		static_assert(sizeof(sect0) == size);

		if (!run)
		{
			backupHelper.Save(addr, size);
		}

		if (enable)
		{
			protectionHelper.Push(addr, size);
			CopyMemory(addr, sect0, sizeof(sect0));
			*reinterpret_cast<uint32 *>(addr + 2) = __builtin_offsetof(ActorData, newEffectIndices[1]) ;
			protectionHelper.Pop();
		}
		else
		{
			backupHelper.Restore(addr);
		}
	}
	{
		auto addr = (appBaseAddr + 0x20AF98);
		constexpr uint32 size = 10;
		/*
		dmc3.exe+20AF98 - 81 0D 227EA800 00000400 - OR [7FF6784E2DC4],00040000
		dmc3.exe+20AFA2
		*/

		constexpr byte8 sect0[] =
		{
			0x81, 0x8B, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x04, 0x00, // or [rbx+0000B8C0],00040000
		};
		static_assert(sizeof(sect0) == size);

		if (!run)
		{
			backupHelper.Save(addr, size);
		}

		if (enable)
		{
			protectionHelper.Push(addr, size);
			CopyMemory(addr, sect0, sizeof(sect0));
			*reinterpret_cast<uint32 *>(addr + 2) = __builtin_offsetof(ActorData, newEffectIndices[1]) ;
			protectionHelper.Pop();
		}
		else
		{
			backupHelper.Restore(addr);
		}
	}
	{
		auto addr = (appBaseAddr + 0x20B0A2);
		constexpr uint32 size = 10;
		/*
		dmc3.exe+20B0A2 - 81 0D 187DA800 00000002 - OR [7FF6784E2DC4],02000000
		dmc3.exe+20B0AC
		*/

		constexpr byte8 sect0[] =
		{
			0x81, 0x8B, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, // or [rbx+0000B8C0],02000000
		};
		static_assert(sizeof(sect0) == size);

		if (!run)
		{
			backupHelper.Save(addr, size);
		}

		if (enable)
		{
			protectionHelper.Push(addr, size);
			CopyMemory(addr, sect0, sizeof(sect0));
			*reinterpret_cast<uint32 *>(addr + 2) = __builtin_offsetof(ActorData, newEffectIndices[1]) ;
			protectionHelper.Pop();
		}
		else
		{
			backupHelper.Restore(addr);
		}
	}
	{
		auto addr = (appBaseAddr + 0x20B33F);
		constexpr uint32 size = 10;
		/*
		dmc3.exe+20B33F - 81 0D 7B7AA800 00000020 - OR [7FF6784E2DC4],20000000
		dmc3.exe+20B349
		*/

		constexpr byte8 sect0[] =
		{
			0x81, 0x8B, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x20, // or [rbx+0000B8C0],20000000
		};
		static_assert(sizeof(sect0) == size);

		if (!run)
		{
			backupHelper.Save(addr, size);
		}

		if (enable)
		{
			protectionHelper.Push(addr, size);
			CopyMemory(addr, sect0, sizeof(sect0));
			*reinterpret_cast<uint32 *>(addr + 2) = __builtin_offsetof(ActorData, newEffectIndices[1]) ;
			protectionHelper.Pop();
		}
		else
		{
			backupHelper.Restore(addr);
		}
	}
	{
		auto addr = (appBaseAddr + 0x20B83F);
		constexpr uint32 size = 10;
		/*
		dmc3.exe+20B83F - 81 0D 7B75A800 00000020 - OR [7FF6784E2DC4],20000000
		dmc3.exe+20B849
		*/

		constexpr byte8 sect0[] =
		{
			0x81, 0x8B, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x20, // or [rbx+0000B8C0],20000000
		};
		static_assert(sizeof(sect0) == size);

		if (!run)
		{
			backupHelper.Save(addr, size);
		}

		if (enable)
		{
			protectionHelper.Push(addr, size);
			CopyMemory(addr, sect0, sizeof(sect0));
			*reinterpret_cast<uint32 *>(addr + 2) = __builtin_offsetof(ActorData, newEffectIndices[1]) ;
			protectionHelper.Pop();
		}
		else
		{
			backupHelper.Restore(addr);
		}
	}
	{
		auto addr = (appBaseAddr + 0x20C73F);
		constexpr uint32 size = 10;
		/*
		dmc3.exe+20C73F - 81 0D 7B66A800 00000004 - OR [7FF6784E2DC4],04000000
		dmc3.exe+20C749
		*/

		constexpr byte8 sect0[] =
		{
			0x81, 0x8F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x04, // or [rdi+0000B8C0],04000000
		};
		static_assert(sizeof(sect0) == size);

		if (!run)
		{
			backupHelper.Save(addr, size);
		}

		if (enable)
		{
			protectionHelper.Push(addr, size);
			CopyMemory(addr, sect0, sizeof(sect0));
			*reinterpret_cast<uint32 *>(addr + 2) = __builtin_offsetof(ActorData, newEffectIndices[1]) ;
			protectionHelper.Pop();
		}
		else
		{
			backupHelper.Restore(addr);
		}
	}
	{
		auto addr = (appBaseAddr + 0x20E10D);
		constexpr uint32 size = 10;
		/*
		dmc3.exe+20E10D - 81 0D AD4CA800 00020000 - OR [7FF6784E2DC4],00000200
		dmc3.exe+20E117
		*/

		constexpr byte8 sect0[] =
		{
			0x81, 0x8B, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, // or [rbx+0000B8C0],00000200
		};
		static_assert(sizeof(sect0) == size);

		if (!run)
		{
			backupHelper.Save(addr, size);
		}

		if (enable)
		{
			protectionHelper.Push(addr, size);
			CopyMemory(addr, sect0, sizeof(sect0));
			*reinterpret_cast<uint32 *>(addr + 2) = __builtin_offsetof(ActorData, newEffectIndices[1]) ;
			protectionHelper.Pop();
		}
		else
		{
			backupHelper.Restore(addr);
		}
	}
	{
		auto addr = (appBaseAddr + 0x20F253);
		constexpr uint32 size = 10;
		/*
		dmc3.exe+20F253 - 81 0D 673BA800 00000040 - OR [7FF6784E2DC4],40000000
		dmc3.exe+20F25D
		*/

		constexpr byte8 sect0[] =
		{
			0x81, 0x8F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, // or [rdi+0000B8C0],40000000
		};
		static_assert(sizeof(sect0) == size);

		if (!run)
		{
			backupHelper.Save(addr, size);
		}

		if (enable)
		{
			protectionHelper.Push(addr, size);
			CopyMemory(addr, sect0, sizeof(sect0));
			*reinterpret_cast<uint32 *>(addr + 2) = __builtin_offsetof(ActorData, newEffectIndices[1]) ;
			protectionHelper.Pop();
		}
		else
		{
			backupHelper.Restore(addr);
		}
	}
	{
		auto addr = (appBaseAddr + 0x20F30A);
		constexpr uint32 size = 10;
		/*
		dmc3.exe+20F30A - 81 0D B03AA800 00000040 - OR [7FF6784E2DC4],40000000
		dmc3.exe+20F314
		*/

		constexpr byte8 sect0[] =
		{
			0x81, 0x8F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, // or [rdi+0000B8C0],40000000
		};
		static_assert(sizeof(sect0) == size);

		if (!run)
		{
			backupHelper.Save(addr, size);
		}

		if (enable)
		{
			protectionHelper.Push(addr, size);
			CopyMemory(addr, sect0, sizeof(sect0));
			*reinterpret_cast<uint32 *>(addr + 2) = __builtin_offsetof(ActorData, newEffectIndices[1]) ;
			protectionHelper.Pop();
		}
		else
		{
			backupHelper.Restore(addr);
		}
	}
	{
		auto addr = (appBaseAddr + 0x2100E0);
		constexpr uint32 size = 7;
		/*
		dmc3.exe+2100E0 - 83 0D DD2CA800 20 - OR DWORD PTR [7FF6784E2DC4],20
		dmc3.exe+2100E7
		*/

		constexpr byte8 sect0[] =
		{
			0x83, 0x8F, 0x00, 0x00, 0x00, 0x00, 0x20, // or dword ptr [rdi+0000B8C0],20
		};
		static_assert(sizeof(sect0) == size);

		if (!run)
		{
			backupHelper.Save(addr, size);
		}

		if (enable)
		{
			protectionHelper.Push(addr, size);
			CopyMemory(addr, sect0, sizeof(sect0));
			*reinterpret_cast<uint32 *>(addr + 2) = __builtin_offsetof(ActorData, newEffectIndices[1]) ;
			protectionHelper.Pop();
		}
		else
		{
			backupHelper.Restore(addr);
		}
	}
	{
		auto addr = (appBaseAddr + 0x8CBF0);
		constexpr uint32 size = 10;
		/*
		dmc3.exe+8CBF0 - 81 0D CE61C000 00004000 - OR [7FF6784E2DC8],00400000
		dmc3.exe+8CBFA
		*/

		constexpr byte8 sect0[] =
		{
			0x81, 0x8B, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x00, // or [rbx+0000B8C0],00400000
		};
		static_assert(sizeof(sect0) == size);

		if (!run)
		{
			backupHelper.Save(addr, size);
		}

		if (enable)
		{
			protectionHelper.Push(addr, size);
			CopyMemory(addr, sect0, sizeof(sect0));
			*reinterpret_cast<uint32 *>(addr + 2) = __builtin_offsetof(ActorData, newEffectIndices[2]) ;
			protectionHelper.Pop();
		}
		else
		{
			backupHelper.Restore(addr);
		}
	}
	{
		auto addr = (appBaseAddr + 0x8CC7B);
		constexpr uint32 size = 10;
		/*
		dmc3.exe+8CC7B - 81 0D 4361C000 00008000 - OR [7FF6784E2DC8],00800000
		dmc3.exe+8CC85
		*/

		constexpr byte8 sect0[] =
		{
			0x81, 0x8B, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x00, // or [rbx+0000B8C0],00800000
		};
		static_assert(sizeof(sect0) == size);

		if (!run)
		{
			backupHelper.Save(addr, size);
		}

		if (enable)
		{
			protectionHelper.Push(addr, size);
			CopyMemory(addr, sect0, sizeof(sect0));
			*reinterpret_cast<uint32 *>(addr + 2) = __builtin_offsetof(ActorData, newEffectIndices[2]) ;
			protectionHelper.Pop();
		}
		else
		{
			backupHelper.Restore(addr);
		}
	}
	{
		auto addr = (appBaseAddr + 0x8CC8E);
		constexpr uint32 size = 10;
		/*
		dmc3.exe+8CC8E - 81 0D 3061C000 00008000 - OR [7FF6784E2DC8],00800000
		dmc3.exe+8CC98
		*/

		constexpr byte8 sect0[] =
		{
			0x81, 0x8B, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x00, // or [rbx+0000B8C0],00800000
		};
		static_assert(sizeof(sect0) == size);

		if (!run)
		{
			backupHelper.Save(addr, size);
		}

		if (enable)
		{
			protectionHelper.Push(addr, size);
			CopyMemory(addr, sect0, sizeof(sect0));
			*reinterpret_cast<uint32 *>(addr + 2) = __builtin_offsetof(ActorData, newEffectIndices[2]) ;
			protectionHelper.Pop();
		}
		else
		{
			backupHelper.Restore(addr);
		}
	}
	{
		auto addr = (appBaseAddr + 0x1F9512);
		constexpr uint32 size = 6;
		/*
		dmc3.exe+1F9512 - 8B 0D B098A900 - MOV ECX,[7FF6784E2DC8]
		dmc3.exe+1F9518
		*/

		constexpr byte8 sect0[] =
		{
			0x8B, 0x8B, 0x00, 0x00, 0x00, 0x00, // mov ecx,[rbx+0000B8C0]
		};
		static_assert(sizeof(sect0) == size);

		if (!run)
		{
			backupHelper.Save(addr, size);
		}

		if (enable)
		{
			protectionHelper.Push(addr, size);
			CopyMemory(addr, sect0, sizeof(sect0));
			*reinterpret_cast<uint32 *>(addr + 2) = __builtin_offsetof(ActorData, newEffectIndices[2]) ;
			protectionHelper.Pop();
		}
		else
		{
			backupHelper.Restore(addr);
		}
	}
	{
		auto addr = (appBaseAddr + 0x1F9536);
		constexpr uint32 size = 6;
		/*
		dmc3.exe+1F9536 - 89 0D 8C98A900 - MOV [7FF6784E2DC8],ECX
		dmc3.exe+1F953C
		*/

		constexpr byte8 sect0[] =
		{
			0x89, 0x8B, 0x00, 0x00, 0x00, 0x00, // mov [rbx+0000B8C0],ecx
		};
		static_assert(sizeof(sect0) == size);

		if (!run)
		{
			backupHelper.Save(addr, size);
		}

		if (enable)
		{
			protectionHelper.Push(addr, size);
			CopyMemory(addr, sect0, sizeof(sect0));
			*reinterpret_cast<uint32 *>(addr + 2) = __builtin_offsetof(ActorData, newEffectIndices[2]) ;
			protectionHelper.Pop();
		}
		else
		{
			backupHelper.Restore(addr);
		}
	}
	{
		auto addr = (appBaseAddr + 0x1F9548);
		constexpr uint32 size = 6;
		/*
		dmc3.exe+1F9548 - 8B 0D 7A98A900 - MOV ECX,[7FF6784E2DC8]
		dmc3.exe+1F954E
		*/

		constexpr byte8 sect0[] =
		{
			0x8B, 0x8B, 0x00, 0x00, 0x00, 0x00, // mov ecx,[rbx+0000B8C0]
		};
		static_assert(sizeof(sect0) == size);

		if (!run)
		{
			backupHelper.Save(addr, size);
		}

		if (enable)
		{
			protectionHelper.Push(addr, size);
			CopyMemory(addr, sect0, sizeof(sect0));
			*reinterpret_cast<uint32 *>(addr + 2) = __builtin_offsetof(ActorData, newEffectIndices[2]) ;
			protectionHelper.Pop();
		}
		else
		{
			backupHelper.Restore(addr);
		}
	}
	{
		auto addr = (appBaseAddr + 0x1F9572);
		constexpr uint32 size = 6;
		/*
		dmc3.exe+1F9572 - 89 0D 5098A900 - MOV [7FF6784E2DC8],ECX
		dmc3.exe+1F9578
		*/

		constexpr byte8 sect0[] =
		{
			0x89, 0x8B, 0x00, 0x00, 0x00, 0x00, // mov [rbx+0000B8C0],ecx
		};
		static_assert(sizeof(sect0) == size);

		if (!run)
		{
			backupHelper.Save(addr, size);
		}

		if (enable)
		{
			protectionHelper.Push(addr, size);
			CopyMemory(addr, sect0, sizeof(sect0));
			*reinterpret_cast<uint32 *>(addr + 2) = __builtin_offsetof(ActorData, newEffectIndices[2]) ;
			protectionHelper.Pop();
		}
		else
		{
			backupHelper.Restore(addr);
		}
	}
	{
		auto addr = (appBaseAddr + 0x1FED7B);
		constexpr uint32 size = 6;
		/*
		dmc3.exe+1FED7B - 8B 15 4740A900 - MOV EDX,[7FF6784E2DC8]
		dmc3.exe+1FED81
		*/

		constexpr byte8 sect0[] =
		{
			0x8B, 0x93, 0x00, 0x00, 0x00, 0x00, // mov edx,[rbx+0000B8C0]
		};
		static_assert(sizeof(sect0) == size);

		if (!run)
		{
			backupHelper.Save(addr, size);
		}

		if (enable)
		{
			protectionHelper.Push(addr, size);
			CopyMemory(addr, sect0, sizeof(sect0));
			*reinterpret_cast<uint32 *>(addr + 2) = __builtin_offsetof(ActorData, newEffectIndices[2]) ;
			protectionHelper.Pop();
		}
		else
		{
			backupHelper.Restore(addr);
		}
	}
	{
		auto addr = (appBaseAddr + 0x1FED93);
		constexpr uint32 size = 6;
		/*
		dmc3.exe+1FED93 - 89 15 2F40A900 - MOV [7FF6784E2DC8],EDX
		dmc3.exe+1FED99
		*/

		constexpr byte8 sect0[] =
		{
			0x89, 0x93, 0x00, 0x00, 0x00, 0x00, // mov [rbx+0000B8C0],edx
		};
		static_assert(sizeof(sect0) == size);

		if (!run)
		{
			backupHelper.Save(addr, size);
		}

		if (enable)
		{
			protectionHelper.Push(addr, size);
			CopyMemory(addr, sect0, sizeof(sect0));
			*reinterpret_cast<uint32 *>(addr + 2) = __builtin_offsetof(ActorData, newEffectIndices[2]) ;
			protectionHelper.Pop();
		}
		else
		{
			backupHelper.Restore(addr);
		}
	}
	{
		auto addr = (appBaseAddr + 0x1FFE52);
		constexpr uint32 size = 10;
		/*
		dmc3.exe+1FFE52 - 81 0D 6C2FA900 00020000 - OR [7FF6784E2DC8],00000200
		dmc3.exe+1FFE5C
		*/

		constexpr byte8 sect0[] =
		{
			0x81, 0x8B, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, // or [rbx+0000B8C0],00000200
		};
		static_assert(sizeof(sect0) == size);

		if (!run)
		{
			backupHelper.Save(addr, size);
		}

		if (enable)
		{
			protectionHelper.Push(addr, size);
			CopyMemory(addr, sect0, sizeof(sect0));
			*reinterpret_cast<uint32 *>(addr + 2) = __builtin_offsetof(ActorData, newEffectIndices[2]) ;
			protectionHelper.Pop();
		}
		else
		{
			backupHelper.Restore(addr);
		}
	}
	{
		auto addr = (appBaseAddr + 0x20181D);
		constexpr uint32 size = 10;
		/*
		dmc3.exe+20181D - 81 0D A115A900 00000001 - OR [7FF6784E2DC8],01000000
		dmc3.exe+201827
		*/

		constexpr byte8 sect0[] =
		{
			0x81, 0x8F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, // or [rdi+0000B8C0],01000000
		};
		static_assert(sizeof(sect0) == size);

		if (!run)
		{
			backupHelper.Save(addr, size);
		}

		if (enable)
		{
			protectionHelper.Push(addr, size);
			CopyMemory(addr, sect0, sizeof(sect0));
			*reinterpret_cast<uint32 *>(addr + 2) = __builtin_offsetof(ActorData, newEffectIndices[2]) ;
			protectionHelper.Pop();
		}
		else
		{
			backupHelper.Restore(addr);
		}
	}
	{
		auto addr = (appBaseAddr + 0x2019DF);
		constexpr uint32 size = 10;
		/*
		dmc3.exe+2019DF - 81 0D DF13A900 00000001 - OR [7FF6784E2DC8],01000000
		dmc3.exe+2019E9
		*/

		constexpr byte8 sect0[] =
		{
			0x81, 0x8F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, // or [rdi+0000B8C0],01000000
		};
		static_assert(sizeof(sect0) == size);

		if (!run)
		{
			backupHelper.Save(addr, size);
		}

		if (enable)
		{
			protectionHelper.Push(addr, size);
			CopyMemory(addr, sect0, sizeof(sect0));
			*reinterpret_cast<uint32 *>(addr + 2) = __builtin_offsetof(ActorData, newEffectIndices[2]) ;
			protectionHelper.Pop();
		}
		else
		{
			backupHelper.Restore(addr);
		}
	}
	{
		auto addr = (appBaseAddr + 0x203F83);
		constexpr uint32 size = 10;
		/*
		dmc3.exe+203F83 - 81 0D 3BEEA800 00002000 - OR [7FF6784E2DC8],00200000
		dmc3.exe+203F8D
		*/

		constexpr byte8 sect0[] =
		{
			0x81, 0x8B, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x20, 0x00, // or [rbx+0000B8C0],00200000
		};
		static_assert(sizeof(sect0) == size);

		if (!run)
		{
			backupHelper.Save(addr, size);
		}

		if (enable)
		{
			protectionHelper.Push(addr, size);
			CopyMemory(addr, sect0, sizeof(sect0));
			*reinterpret_cast<uint32 *>(addr + 2) = __builtin_offsetof(ActorData, newEffectIndices[2]) ;
			protectionHelper.Pop();
		}
		else
		{
			backupHelper.Restore(addr);
		}
	}
	{
		auto addr = (appBaseAddr + 0x209A16);
		constexpr uint32 size = 10;
		/*
		dmc3.exe+209A16 - 81 0D A893A800 00040000 - OR [7FF6784E2DC8],00000400
		dmc3.exe+209A20
		*/

		constexpr byte8 sect0[] =
		{
			0x81, 0x8B, 0x00, 0x00, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, // or [rbx+0000B8C0],00000400
		};
		static_assert(sizeof(sect0) == size);

		if (!run)
		{
			backupHelper.Save(addr, size);
		}

		if (enable)
		{
			protectionHelper.Push(addr, size);
			CopyMemory(addr, sect0, sizeof(sect0));
			*reinterpret_cast<uint32 *>(addr + 2) = __builtin_offsetof(ActorData, newEffectIndices[2]) ;
			protectionHelper.Pop();
		}
		else
		{
			backupHelper.Restore(addr);
		}
	}
	{
		auto addr = (appBaseAddr + 0x209C11);
		constexpr uint32 size = 10;
		/*
		dmc3.exe+209C11 - 81 0D AD91A800 00001000 - OR [7FF6784E2DC8],00100000
		dmc3.exe+209C1B
		*/

		constexpr byte8 sect0[] =
		{
			0x81, 0x8B, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0x00, // or [rbx+0000B8C0],00100000
		};
		static_assert(sizeof(sect0) == size);

		if (!run)
		{
			backupHelper.Save(addr, size);
		}

		if (enable)
		{
			protectionHelper.Push(addr, size);
			CopyMemory(addr, sect0, sizeof(sect0));
			*reinterpret_cast<uint32 *>(addr + 2) = __builtin_offsetof(ActorData, newEffectIndices[2]) ;
			protectionHelper.Pop();
		}
		else
		{
			backupHelper.Restore(addr);
		}
	}
	{
		auto addr = (appBaseAddr + 0x20A019);
		constexpr uint32 size = 10;
		/*
		dmc3.exe+20A019 - 81 0D A58DA800 00000002 - OR [7FF6784E2DC8],02000000
		dmc3.exe+20A023
		*/

		constexpr byte8 sect0[] =
		{
			0x81, 0x8B, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, // or [rbx+0000B8C0],02000000
		};
		static_assert(sizeof(sect0) == size);

		if (!run)
		{
			backupHelper.Save(addr, size);
		}

		if (enable)
		{
			protectionHelper.Push(addr, size);
			CopyMemory(addr, sect0, sizeof(sect0));
			*reinterpret_cast<uint32 *>(addr + 2) = __builtin_offsetof(ActorData, newEffectIndices[2]) ;
			protectionHelper.Pop();
		}
		else
		{
			backupHelper.Restore(addr);
		}
	}
	{
		auto addr = (appBaseAddr + 0x20D73D);
		constexpr uint32 size = 10;
		/*
		dmc3.exe+20D73D - 81 0D 8156A800 00000800 - OR [7FF6784E2DC8],00080000
		dmc3.exe+20D747
		*/

		constexpr byte8 sect0[] =
		{
			0x81, 0x8F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x08, 0x00, // or [rdi+0000B8C0],00080000
		};
		static_assert(sizeof(sect0) == size);

		if (!run)
		{
			backupHelper.Save(addr, size);
		}

		if (enable)
		{
			protectionHelper.Push(addr, size);
			CopyMemory(addr, sect0, sizeof(sect0));
			*reinterpret_cast<uint32 *>(addr + 2) = __builtin_offsetof(ActorData, newEffectIndices[2]) ;
			protectionHelper.Pop();
		}
		else
		{
			backupHelper.Restore(addr);
		}
	}
	{
		auto addr = (appBaseAddr + 0x20D858);
		constexpr uint32 size = 10;
		/*
		dmc3.exe+20D858 - 81 0D 6655A800 00000800 - OR [7FF6784E2DC8],00080000
		dmc3.exe+20D862
		*/

		constexpr byte8 sect0[] =
		{
			0x81, 0x8B, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x08, 0x00, // or [rbx+0000B8C0],00080000
		};
		static_assert(sizeof(sect0) == size);

		if (!run)
		{
			backupHelper.Save(addr, size);
		}

		if (enable)
		{
			protectionHelper.Push(addr, size);
			CopyMemory(addr, sect0, sizeof(sect0));
			*reinterpret_cast<uint32 *>(addr + 2) = __builtin_offsetof(ActorData, newEffectIndices[2]) ;
			protectionHelper.Pop();
		}
		else
		{
			backupHelper.Restore(addr);
		}
	}
	{
		auto addr = (appBaseAddr + 0x224C96);
		constexpr uint32 size = 10;
		/*
		dmc3.exe+224C96 - 81 0D 28E1A600 00080000 - OR [7FF6784E2DC8],00000800
		dmc3.exe+224CA0
		*/

		constexpr byte8 sect0[] =
		{
			0x81, 0x8B, 0x00, 0x00, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, // or [rbx+0000B8C0],00000800
		};
		static_assert(sizeof(sect0) == size);

		if (!run)
		{
			backupHelper.Save(addr, size);
		}

		if (enable)
		{
			protectionHelper.Push(addr, size);
			CopyMemory(addr, sect0, sizeof(sect0));
			*reinterpret_cast<uint32 *>(addr + 2) = __builtin_offsetof(ActorData, newEffectIndices[2]) ;
			protectionHelper.Pop();
		}
		else
		{
			backupHelper.Restore(addr);
		}
	}
	{
		auto addr = (appBaseAddr + 0x224CE7);
		constexpr uint32 size = 10;
		/*
		dmc3.exe+224CE7 - 81 0D D7E0A600 00400000 - OR [7FF6784E2DC8],00004000
		dmc3.exe+224CF1
		*/

		constexpr byte8 sect0[] =
		{
			0x81, 0x8B, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x00, 0x00, // or [rbx+0000B8C0],00004000
		};
		static_assert(sizeof(sect0) == size);

		if (!run)
		{
			backupHelper.Save(addr, size);
		}

		if (enable)
		{
			protectionHelper.Push(addr, size);
			CopyMemory(addr, sect0, sizeof(sect0));
			*reinterpret_cast<uint32 *>(addr + 2) = __builtin_offsetof(ActorData, newEffectIndices[2]) ;
			protectionHelper.Pop();
		}
		else
		{
			backupHelper.Restore(addr);
		}
	}
	{
		auto addr = (appBaseAddr + 0x224DE6);
		constexpr uint32 size = 10;
		/*
		dmc3.exe+224DE6 - 81 0D D8DFA600 00080000 - OR [7FF6784E2DC8],00000800
		dmc3.exe+224DF0
		*/

		constexpr byte8 sect0[] =
		{
			0x81, 0x8B, 0x00, 0x00, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, // or [rbx+0000B8C0],00000800
		};
		static_assert(sizeof(sect0) == size);

		if (!run)
		{
			backupHelper.Save(addr, size);
		}

		if (enable)
		{
			protectionHelper.Push(addr, size);
			CopyMemory(addr, sect0, sizeof(sect0));
			*reinterpret_cast<uint32 *>(addr + 2) = __builtin_offsetof(ActorData, newEffectIndices[2]) ;
			protectionHelper.Pop();
		}
		else
		{
			backupHelper.Restore(addr);
		}
	}
	{
		auto addr = (appBaseAddr + 0x224E37);
		constexpr uint32 size = 10;
		/*
		dmc3.exe+224E37 - 81 0D 87DFA600 00800000 - OR [7FF6784E2DC8],00008000
		dmc3.exe+224E41
		*/

		constexpr byte8 sect0[] =
		{
			0x81, 0x8B, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x00, 0x00, // or [rbx+0000B8C0],00008000
		};
		static_assert(sizeof(sect0) == size);

		if (!run)
		{
			backupHelper.Save(addr, size);
		}

		if (enable)
		{
			protectionHelper.Push(addr, size);
			CopyMemory(addr, sect0, sizeof(sect0));
			*reinterpret_cast<uint32 *>(addr + 2) = __builtin_offsetof(ActorData, newEffectIndices[2]) ;
			protectionHelper.Pop();
		}
		else
		{
			backupHelper.Restore(addr);
		}
	}
	{
		auto addr = (appBaseAddr + 0x224F36);
		constexpr uint32 size = 10;
		/*
		dmc3.exe+224F36 - 81 0D 88DEA600 00080000 - OR [7FF6784E2DC8],00000800
		dmc3.exe+224F40
		*/

		constexpr byte8 sect0[] =
		{
			0x81, 0x8B, 0x00, 0x00, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, // or [rbx+0000B8C0],00000800
		};
		static_assert(sizeof(sect0) == size);

		if (!run)
		{
			backupHelper.Save(addr, size);
		}

		if (enable)
		{
			protectionHelper.Push(addr, size);
			CopyMemory(addr, sect0, sizeof(sect0));
			*reinterpret_cast<uint32 *>(addr + 2) = __builtin_offsetof(ActorData, newEffectIndices[2]) ;
			protectionHelper.Pop();
		}
		else
		{
			backupHelper.Restore(addr);
		}
	}
	{
		auto addr = (appBaseAddr + 0x224F87);
		constexpr uint32 size = 10;
		/*
		dmc3.exe+224F87 - 81 0D 37DEA600 00000100 - OR [7FF6784E2DC8],00010000
		dmc3.exe+224F91
		*/

		constexpr byte8 sect0[] =
		{
			0x81, 0x8B, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, // or [rbx+0000B8C0],00010000
		};
		static_assert(sizeof(sect0) == size);

		if (!run)
		{
			backupHelper.Save(addr, size);
		}

		if (enable)
		{
			protectionHelper.Push(addr, size);
			CopyMemory(addr, sect0, sizeof(sect0));
			*reinterpret_cast<uint32 *>(addr + 2) = __builtin_offsetof(ActorData, newEffectIndices[2]) ;
			protectionHelper.Pop();
		}
		else
		{
			backupHelper.Restore(addr);
		}
	}
	{
		auto addr = (appBaseAddr + 0x225142);
		constexpr uint32 size = 10;
		/*
		dmc3.exe+225142 - 81 0D 7CDCA600 00200000 - OR [7FF6784E2DC8],00002000
		dmc3.exe+22514C
		*/

		constexpr byte8 sect0[] =
		{
			0x81, 0x8B, 0x00, 0x00, 0x00, 0x00, 0x00, 0x20, 0x00, 0x00, // or [rbx+0000B8C0],00002000
		};
		static_assert(sizeof(sect0) == size);

		if (!run)
		{
			backupHelper.Save(addr, size);
		}

		if (enable)
		{
			protectionHelper.Push(addr, size);
			CopyMemory(addr, sect0, sizeof(sect0));
			*reinterpret_cast<uint32 *>(addr + 2) = __builtin_offsetof(ActorData, newEffectIndices[2]) ;
			protectionHelper.Pop();
		}
		else
		{
			backupHelper.Restore(addr);
		}
	}
	{
		auto addr = (appBaseAddr + 0x2253F3);
		constexpr uint32 size = 10;
		/*
		dmc3.exe+2253F3 - 81 0D CBD9A600 00080000 - OR [7FF6784E2DC8],00000800
		dmc3.exe+2253FD
		*/

		constexpr byte8 sect0[] =
		{
			0x81, 0x8B, 0x00, 0x00, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, // or [rbx+0000B8C0],00000800
		};
		static_assert(sizeof(sect0) == size);

		if (!run)
		{
			backupHelper.Save(addr, size);
		}

		if (enable)
		{
			protectionHelper.Push(addr, size);
			CopyMemory(addr, sect0, sizeof(sect0));
			*reinterpret_cast<uint32 *>(addr + 2) = __builtin_offsetof(ActorData, newEffectIndices[2]) ;
			protectionHelper.Pop();
		}
		else
		{
			backupHelper.Restore(addr);
		}
	}
	{
		auto addr = (appBaseAddr + 0x225440);
		constexpr uint32 size = 10;
		/*
		dmc3.exe+225440 - 81 0D 7ED9A600 00000100 - OR [7FF6784E2DC8],00010000
		dmc3.exe+22544A
		*/

		constexpr byte8 sect0[] =
		{
			0x81, 0x8B, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, // or [rbx+0000B8C0],00010000
		};
		static_assert(sizeof(sect0) == size);

		if (!run)
		{
			backupHelper.Save(addr, size);
		}

		if (enable)
		{
			protectionHelper.Push(addr, size);
			CopyMemory(addr, sect0, sizeof(sect0));
			*reinterpret_cast<uint32 *>(addr + 2) = __builtin_offsetof(ActorData, newEffectIndices[2]) ;
			protectionHelper.Pop();
		}
		else
		{
			backupHelper.Restore(addr);
		}
	}
	{
		auto addr = (appBaseAddr + 0x2254AC);
		constexpr uint32 size = 10;
		/*
		dmc3.exe+2254AC - 81 0D 12D9A600 00800000 - OR [7FF6784E2DC8],00008000
		dmc3.exe+2254B6
		*/

		constexpr byte8 sect0[] =
		{
			0x81, 0x8B, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x00, 0x00, // or [rbx+0000B8C0],00008000
		};
		static_assert(sizeof(sect0) == size);

		if (!run)
		{
			backupHelper.Save(addr, size);
		}

		if (enable)
		{
			protectionHelper.Push(addr, size);
			CopyMemory(addr, sect0, sizeof(sect0));
			*reinterpret_cast<uint32 *>(addr + 2) = __builtin_offsetof(ActorData, newEffectIndices[2]) ;
			protectionHelper.Pop();
		}
		else
		{
			backupHelper.Restore(addr);
		}
	}
	{
		auto addr = (appBaseAddr + 0x2255A3);
		constexpr uint32 size = 10;
		/*
		dmc3.exe+2255A3 - 81 0D 1BD8A600 00100200 - OR [7FF6784E2DC8],00021000
		dmc3.exe+2255AD
		*/

		constexpr byte8 sect0[] =
		{
			0x81, 0x8B, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0x02, 0x00, // or [rbx+0000B8C0],00021000
		};
		static_assert(sizeof(sect0) == size);

		if (!run)
		{
			backupHelper.Save(addr, size);
		}

		if (enable)
		{
			protectionHelper.Push(addr, size);
			CopyMemory(addr, sect0, sizeof(sect0));
			*reinterpret_cast<uint32 *>(addr + 2) = __builtin_offsetof(ActorData, newEffectIndices[2]) ;
			protectionHelper.Pop();
		}
		else
		{
			backupHelper.Restore(addr);
		}
	}
	{
		auto addr = (appBaseAddr + 0x8CC05);
		constexpr uint32 size = 10;
		/*
		dmc3.exe+8CC05 - 81 0D BD61C000 00000040 - OR [7FF6784E2DCC],40000000
		dmc3.exe+8CC0F
		*/

		constexpr byte8 sect0[] =
		{
			0x81, 0x8B, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, // or [rbx+0000B8C0],40000000
		};
		static_assert(sizeof(sect0) == size);

		if (!run)
		{
			backupHelper.Save(addr, size);
		}

		if (enable)
		{
			protectionHelper.Push(addr, size);
			CopyMemory(addr, sect0, sizeof(sect0));
			*reinterpret_cast<uint32 *>(addr + 2) = __builtin_offsetof(ActorData, newEffectIndices[3]) ;
			protectionHelper.Pop();
		}
		else
		{
			backupHelper.Restore(addr);
		}
	}
	{
		auto addr = (appBaseAddr + 0x1E0B2B);
		constexpr uint32 size = 10;
		/*
		dmc3.exe+1E0B2B - 81 0D 9722AB00 00000200 - OR [7FF6784E2DCC],00020000
		dmc3.exe+1E0B35
		*/

		constexpr byte8 sect0[] =
		{
			0x81, 0x8B, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x00, // or [rbx+0000B8C0],00020000
		};
		static_assert(sizeof(sect0) == size);

		if (!run)
		{
			backupHelper.Save(addr, size);
		}

		if (enable)
		{
			protectionHelper.Push(addr, size);
			CopyMemory(addr, sect0, sizeof(sect0));
			*reinterpret_cast<uint32 *>(addr + 2) = __builtin_offsetof(ActorData, newEffectIndices[3]) ;
			protectionHelper.Pop();
		}
		else
		{
			backupHelper.Restore(addr);
		}
	}
	{
		auto addr = (appBaseAddr + 0x1EE0F9);
		constexpr uint32 size = 10;
		/*
		dmc3.exe+1EE0F9 - 81 0D C94CAA00 00000200 - OR [7FF6784E2DCC],00020000
		dmc3.exe+1EE103
		*/

		constexpr byte8 sect0[] =
		{
			0x81, 0x8B, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x00, // or [rbx+0000B8C0],00020000
		};
		static_assert(sizeof(sect0) == size);

		if (!run)
		{
			backupHelper.Save(addr, size);
		}

		if (enable)
		{
			protectionHelper.Push(addr, size);
			CopyMemory(addr, sect0, sizeof(sect0));
			*reinterpret_cast<uint32 *>(addr + 2) = __builtin_offsetof(ActorData, newEffectIndices[3]) ;
			protectionHelper.Pop();
		}
		else
		{
			backupHelper.Restore(addr);
		}
	}
	{
		auto addr = (appBaseAddr + 0x1F1721);
		constexpr uint32 size = 10;
		/*
		dmc3.exe+1F1721 - 81 0D A116AA00 00200000 - OR [7FF6784E2DCC],00002000
		dmc3.exe+1F172B
		*/

		constexpr byte8 sect0[] =
		{
			0x81, 0x8B, 0x00, 0x00, 0x00, 0x00, 0x00, 0x20, 0x00, 0x00, // or [rbx+0000B8C0],00002000
		};
		static_assert(sizeof(sect0) == size);

		if (!run)
		{
			backupHelper.Save(addr, size);
		}

		if (enable)
		{
			protectionHelper.Push(addr, size);
			CopyMemory(addr, sect0, sizeof(sect0));
			*reinterpret_cast<uint32 *>(addr + 2) = __builtin_offsetof(ActorData, newEffectIndices[3]) ;
			protectionHelper.Pop();
		}
		else
		{
			backupHelper.Restore(addr);
		}
	}
	{
		auto addr = (appBaseAddr + 0x1F2C44);
		constexpr uint32 size = 10;
		/*
		dmc3.exe+1F2C44 - 81 0D 7E01AA00 00000200 - OR [7FF6784E2DCC],00020000
		dmc3.exe+1F2C4E
		*/

		constexpr byte8 sect0[] =
		{
			0x81, 0x8B, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x00, // or [rbx+0000B8C0],00020000
		};
		static_assert(sizeof(sect0) == size);

		if (!run)
		{
			backupHelper.Save(addr, size);
		}

		if (enable)
		{
			protectionHelper.Push(addr, size);
			CopyMemory(addr, sect0, sizeof(sect0));
			*reinterpret_cast<uint32 *>(addr + 2) = __builtin_offsetof(ActorData, newEffectIndices[3]) ;
			protectionHelper.Pop();
		}
		else
		{
			backupHelper.Restore(addr);
		}
	}
	{
		auto addr = (appBaseAddr + 0x1F2D6C);
		constexpr uint32 size = 10;
		/*
		dmc3.exe+1F2D6C - 81 0D 5600AA00 00000200 - OR [7FF6784E2DCC],00020000
		dmc3.exe+1F2D76
		*/

		constexpr byte8 sect0[] =
		{
			0x81, 0x8B, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x00, // or [rbx+0000B8C0],00020000
		};
		static_assert(sizeof(sect0) == size);

		if (!run)
		{
			backupHelper.Save(addr, size);
		}

		if (enable)
		{
			protectionHelper.Push(addr, size);
			CopyMemory(addr, sect0, sizeof(sect0));
			*reinterpret_cast<uint32 *>(addr + 2) = __builtin_offsetof(ActorData, newEffectIndices[3]) ;
			protectionHelper.Pop();
		}
		else
		{
			backupHelper.Restore(addr);
		}
	}
	{
		auto addr = (appBaseAddr + 0x1F31D8);
		constexpr uint32 size = 10;
		/*
		dmc3.exe+1F31D8 - 81 0D EAFBA900 00000200 - OR [7FF6784E2DCC],00020000
		dmc3.exe+1F31E2
		*/

		constexpr byte8 sect0[] =
		{
			0x81, 0x8B, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x00, // or [rbx+0000B8C0],00020000
		};
		static_assert(sizeof(sect0) == size);

		if (!run)
		{
			backupHelper.Save(addr, size);
		}

		if (enable)
		{
			protectionHelper.Push(addr, size);
			CopyMemory(addr, sect0, sizeof(sect0));
			*reinterpret_cast<uint32 *>(addr + 2) = __builtin_offsetof(ActorData, newEffectIndices[3]) ;
			protectionHelper.Pop();
		}
		else
		{
			backupHelper.Restore(addr);
		}
	}
	{
		auto addr = (appBaseAddr + 0x1F57DC);
		constexpr uint32 size = 10;
		/*
		dmc3.exe+1F57DC - 81 0D E6D5A900 00800000 - OR [7FF6784E2DCC],00008000
		dmc3.exe+1F57E6
		*/

		constexpr byte8 sect0[] =
		{
			0x81, 0x8E, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x00, 0x00, // or [rsi+0000B8C0],00008000
		};
		static_assert(sizeof(sect0) == size);

		if (!run)
		{
			backupHelper.Save(addr, size);
		}

		if (enable)
		{
			protectionHelper.Push(addr, size);
			CopyMemory(addr, sect0, sizeof(sect0));
			*reinterpret_cast<uint32 *>(addr + 2) = __builtin_offsetof(ActorData, newEffectIndices[3]) ;
			protectionHelper.Pop();
		}
		else
		{
			backupHelper.Restore(addr);
		}
	}
	{
		auto addr = (appBaseAddr + 0x1F5E53);
		constexpr uint32 size = 10;
		/*
		dmc3.exe+1F5E53 - 81 0D 6FCFA900 00800000 - OR [7FF6784E2DCC],00008000
		dmc3.exe+1F5E5D
		*/

		constexpr byte8 sect0[] =
		{
			0x81, 0x8E, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x00, 0x00, // or [rsi+0000B8C0],00008000
		};
		static_assert(sizeof(sect0) == size);

		if (!run)
		{
			backupHelper.Save(addr, size);
		}

		if (enable)
		{
			protectionHelper.Push(addr, size);
			CopyMemory(addr, sect0, sizeof(sect0));
			*reinterpret_cast<uint32 *>(addr + 2) = __builtin_offsetof(ActorData, newEffectIndices[3]) ;
			protectionHelper.Pop();
		}
		else
		{
			backupHelper.Restore(addr);
		}
	}
	{
		auto addr = (appBaseAddr + 0x1FFE6B);
		constexpr uint32 size = 10;
		/*
		dmc3.exe+1FFE6B - 81 0D 572FA900 00000010 - OR [7FF6784E2DCC],10000000
		dmc3.exe+1FFE75
		*/

		constexpr byte8 sect0[] =
		{
			0x81, 0x8B, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, // or [rbx+0000B8C0],10000000
		};
		static_assert(sizeof(sect0) == size);

		if (!run)
		{
			backupHelper.Save(addr, size);
		}

		if (enable)
		{
			protectionHelper.Push(addr, size);
			CopyMemory(addr, sect0, sizeof(sect0));
			*reinterpret_cast<uint32 *>(addr + 2) = __builtin_offsetof(ActorData, newEffectIndices[3]) ;
			protectionHelper.Pop();
		}
		else
		{
			backupHelper.Restore(addr);
		}
	}
	{
		auto addr = (appBaseAddr + 0x20116D);
		constexpr uint32 size = 7;
		/*
		dmc3.exe+20116D - 83 0D 581CA900 10 - OR DWORD PTR [7FF6784E2DCC],10
		dmc3.exe+201174
		*/

		constexpr byte8 sect0[] =
		{
			0x83, 0x8B, 0x00, 0x00, 0x00, 0x00, 0x10, // or dword ptr [rbx+0000B8C0],10
		};
		static_assert(sizeof(sect0) == size);

		if (!run)
		{
			backupHelper.Save(addr, size);
		}

		if (enable)
		{
			protectionHelper.Push(addr, size);
			CopyMemory(addr, sect0, sizeof(sect0));
			*reinterpret_cast<uint32 *>(addr + 2) = __builtin_offsetof(ActorData, newEffectIndices[3]) ;
			protectionHelper.Pop();
		}
		else
		{
			backupHelper.Restore(addr);
		}
	}
	{
		auto addr = (appBaseAddr + 0x20151F);
		constexpr uint32 size = 10;
		/*
		dmc3.exe+20151F - 81 0D A318A900 00008000 - OR [7FF6784E2DCC],00800000
		dmc3.exe+201529
		*/

		constexpr byte8 sect0[] =
		{
			0x81, 0x8B, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x00, // or [rbx+0000B8C0],00800000
		};
		static_assert(sizeof(sect0) == size);

		if (!run)
		{
			backupHelper.Save(addr, size);
		}

		if (enable)
		{
			protectionHelper.Push(addr, size);
			CopyMemory(addr, sect0, sizeof(sect0));
			*reinterpret_cast<uint32 *>(addr + 2) = __builtin_offsetof(ActorData, newEffectIndices[3]) ;
			protectionHelper.Pop();
		}
		else
		{
			backupHelper.Restore(addr);
		}
	}
	{
		auto addr = (appBaseAddr + 0x201836);
		constexpr uint32 size = 10;
		/*
		dmc3.exe+201836 - 81 0D 8C15A900 00000080 - OR [7FF6784E2DCC],80000000
		dmc3.exe+201840
		*/

		constexpr byte8 sect0[] =
		{
			0x81, 0x8F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, // or [rdi+0000B8C0],80000000
		};
		static_assert(sizeof(sect0) == size);

		if (!run)
		{
			backupHelper.Save(addr, size);
		}

		if (enable)
		{
			protectionHelper.Push(addr, size);
			CopyMemory(addr, sect0, sizeof(sect0));
			*reinterpret_cast<uint32 *>(addr + 2) = __builtin_offsetof(ActorData, newEffectIndices[3]) ;
			protectionHelper.Pop();
		}
		else
		{
			backupHelper.Restore(addr);
		}
	}
	{
		auto addr = (appBaseAddr + 0x2019EE);
		constexpr uint32 size = 10;
		/*
		dmc3.exe+2019EE - 81 0D D413A900 00000080 - OR [7FF6784E2DCC],80000000
		dmc3.exe+2019F8
		*/

		constexpr byte8 sect0[] =
		{
			0x81, 0x8F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, // or [rdi+0000B8C0],80000000
		};
		static_assert(sizeof(sect0) == size);

		if (!run)
		{
			backupHelper.Save(addr, size);
		}

		if (enable)
		{
			protectionHelper.Push(addr, size);
			CopyMemory(addr, sect0, sizeof(sect0));
			*reinterpret_cast<uint32 *>(addr + 2) = __builtin_offsetof(ActorData, newEffectIndices[3]) ;
			protectionHelper.Pop();
		}
		else
		{
			backupHelper.Restore(addr);
		}
	}
	{
		auto addr = (appBaseAddr + 0x20224A);
		constexpr uint32 size = 10;
		/*
		dmc3.exe+20224A - 81 0D 780BA900 00000800 - OR [7FF6784E2DCC],00080000
		dmc3.exe+202254
		*/

		constexpr byte8 sect0[] =
		{
			0x81, 0x8B, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x08, 0x00, // or [rbx+0000B8C0],00080000
		};
		static_assert(sizeof(sect0) == size);

		if (!run)
		{
			backupHelper.Save(addr, size);
		}

		if (enable)
		{
			protectionHelper.Push(addr, size);
			CopyMemory(addr, sect0, sizeof(sect0));
			*reinterpret_cast<uint32 *>(addr + 2) = __builtin_offsetof(ActorData, newEffectIndices[3]) ;
			protectionHelper.Pop();
		}
		else
		{
			backupHelper.Restore(addr);
		}
	}
	{
		auto addr = (appBaseAddr + 0x2022F7);
		constexpr uint32 size = 10;
		/*
		dmc3.exe+2022F7 - 81 0D CB0AA900 00000800 - OR [7FF6784E2DCC],00080000
		dmc3.exe+202301
		*/

		constexpr byte8 sect0[] =
		{
			0x81, 0x8B, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x08, 0x00, // or [rbx+0000B8C0],00080000
		};
		static_assert(sizeof(sect0) == size);

		if (!run)
		{
			backupHelper.Save(addr, size);
		}

		if (enable)
		{
			protectionHelper.Push(addr, size);
			CopyMemory(addr, sect0, sizeof(sect0));
			*reinterpret_cast<uint32 *>(addr + 2) = __builtin_offsetof(ActorData, newEffectIndices[3]) ;
			protectionHelper.Pop();
		}
		else
		{
			backupHelper.Restore(addr);
		}
	}
	{
		auto addr = (appBaseAddr + 0x2023C6);
		constexpr uint32 size = 10;
		/*
		dmc3.exe+2023C6 - 81 0D FC09A900 00000800 - OR [7FF6784E2DCC],00080000
		dmc3.exe+2023D0
		*/

		constexpr byte8 sect0[] =
		{
			0x81, 0x8B, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x08, 0x00, // or [rbx+0000B8C0],00080000
		};
		static_assert(sizeof(sect0) == size);

		if (!run)
		{
			backupHelper.Save(addr, size);
		}

		if (enable)
		{
			protectionHelper.Push(addr, size);
			CopyMemory(addr, sect0, sizeof(sect0));
			*reinterpret_cast<uint32 *>(addr + 2) = __builtin_offsetof(ActorData, newEffectIndices[3]) ;
			protectionHelper.Pop();
		}
		else
		{
			backupHelper.Restore(addr);
		}
	}
	{
		auto addr = (appBaseAddr + 0x202523);
		constexpr uint32 size = 10;
		/*
		dmc3.exe+202523 - 81 0D 9F08A900 00001000 - OR [7FF6784E2DCC],00100000
		dmc3.exe+20252D
		*/

		constexpr byte8 sect0[] =
		{
			0x81, 0x8B, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0x00, // or [rbx+0000B8C0],00100000
		};
		static_assert(sizeof(sect0) == size);

		if (!run)
		{
			backupHelper.Save(addr, size);
		}

		if (enable)
		{
			protectionHelper.Push(addr, size);
			CopyMemory(addr, sect0, sizeof(sect0));
			*reinterpret_cast<uint32 *>(addr + 2) = __builtin_offsetof(ActorData, newEffectIndices[3]) ;
			protectionHelper.Pop();
		}
		else
		{
			backupHelper.Restore(addr);
		}
	}
	{
		auto addr = (appBaseAddr + 0x2025E6);
		constexpr uint32 size = 10;
		/*
		dmc3.exe+2025E6 - 81 0D DC07A900 00001000 - OR [7FF6784E2DCC],00100000
		dmc3.exe+2025F0
		*/

		constexpr byte8 sect0[] =
		{
			0x81, 0x8B, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0x00, // or [rbx+0000B8C0],00100000
		};
		static_assert(sizeof(sect0) == size);

		if (!run)
		{
			backupHelper.Save(addr, size);
		}

		if (enable)
		{
			protectionHelper.Push(addr, size);
			CopyMemory(addr, sect0, sizeof(sect0));
			*reinterpret_cast<uint32 *>(addr + 2) = __builtin_offsetof(ActorData, newEffectIndices[3]) ;
			protectionHelper.Pop();
		}
		else
		{
			backupHelper.Restore(addr);
		}
	}
	{
		auto addr = (appBaseAddr + 0x2029FF);
		constexpr uint32 size = 10;
		/*
		dmc3.exe+2029FF - 81 0D C303A900 00004000 - OR [7FF6784E2DCC],00400000
		dmc3.exe+202A09
		*/

		constexpr byte8 sect0[] =
		{
			0x81, 0x8B, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x00, // or [rbx+0000B8C0],00400000
		};
		static_assert(sizeof(sect0) == size);

		if (!run)
		{
			backupHelper.Save(addr, size);
		}

		if (enable)
		{
			protectionHelper.Push(addr, size);
			CopyMemory(addr, sect0, sizeof(sect0));
			*reinterpret_cast<uint32 *>(addr + 2) = __builtin_offsetof(ActorData, newEffectIndices[3]) ;
			protectionHelper.Pop();
		}
		else
		{
			backupHelper.Restore(addr);
		}
	}
	{
		auto addr = (appBaseAddr + 0x202AF8);
		constexpr uint32 size = 10;
		/*
		dmc3.exe+202AF8 - 81 0D CA02A900 00004000 - OR [7FF6784E2DCC],00400000
		dmc3.exe+202B02
		*/

		constexpr byte8 sect0[] =
		{
			0x81, 0x8B, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x00, // or [rbx+0000B8C0],00400000
		};
		static_assert(sizeof(sect0) == size);

		if (!run)
		{
			backupHelper.Save(addr, size);
		}

		if (enable)
		{
			protectionHelper.Push(addr, size);
			CopyMemory(addr, sect0, sizeof(sect0));
			*reinterpret_cast<uint32 *>(addr + 2) = __builtin_offsetof(ActorData, newEffectIndices[3]) ;
			protectionHelper.Pop();
		}
		else
		{
			backupHelper.Restore(addr);
		}
	}
	{
		auto addr = (appBaseAddr + 0x203041);
		constexpr uint32 size = 10;
		/*
		dmc3.exe+203041 - 81 0D 81FDA800 00000008 - OR [7FF6784E2DCC],08000000
		dmc3.exe+20304B
		*/

		constexpr byte8 sect0[] =
		{
			0x81, 0x8B, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x08, // or [rbx+0000B8C0],08000000
		};
		static_assert(sizeof(sect0) == size);

		if (!run)
		{
			backupHelper.Save(addr, size);
		}

		if (enable)
		{
			protectionHelper.Push(addr, size);
			CopyMemory(addr, sect0, sizeof(sect0));
			*reinterpret_cast<uint32 *>(addr + 2) = __builtin_offsetof(ActorData, newEffectIndices[3]) ;
			protectionHelper.Pop();
		}
		else
		{
			backupHelper.Restore(addr);
		}
	}
	{
		auto addr = (appBaseAddr + 0x20366E);
		constexpr uint32 size = 10;
		/*
		dmc3.exe+20366E - 81 0D 54F7A800 00000001 - OR [7FF6784E2DCC],01000000
		dmc3.exe+203678
		*/

		constexpr byte8 sect0[] =
		{
			0x81, 0x8B, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, // or [rbx+0000B8C0],01000000
		};
		static_assert(sizeof(sect0) == size);

		if (!run)
		{
			backupHelper.Save(addr, size);
		}

		if (enable)
		{
			protectionHelper.Push(addr, size);
			CopyMemory(addr, sect0, sizeof(sect0));
			*reinterpret_cast<uint32 *>(addr + 2) = __builtin_offsetof(ActorData, newEffectIndices[3]) ;
			protectionHelper.Pop();
		}
		else
		{
			backupHelper.Restore(addr);
		}
	}
	{
		auto addr = (appBaseAddr + 0x203F8F);
		constexpr uint32 size = 10;
		/*
		dmc3.exe+203F8F - 81 0D 33EEA800 00000020 - OR [7FF6784E2DCC],20000000
		dmc3.exe+203F99
		*/

		constexpr byte8 sect0[] =
		{
			0x81, 0x8B, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x20, // or [rbx+0000B8C0],20000000
		};
		static_assert(sizeof(sect0) == size);

		if (!run)
		{
			backupHelper.Save(addr, size);
		}

		if (enable)
		{
			protectionHelper.Push(addr, size);
			CopyMemory(addr, sect0, sizeof(sect0));
			*reinterpret_cast<uint32 *>(addr + 2) = __builtin_offsetof(ActorData, newEffectIndices[3]) ;
			protectionHelper.Pop();
		}
		else
		{
			backupHelper.Restore(addr);
		}
	}
	{
		auto addr = (appBaseAddr + 0x204335);
		constexpr uint32 size = 10;
		/*
		dmc3.exe+204335 - 81 0D 8DEAA800 00000004 - OR [7FF6784E2DCC],04000000
		dmc3.exe+20433F
		*/

		constexpr byte8 sect0[] =
		{
			0x81, 0x8B, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x04, // or [rbx+0000B8C0],04000000
		};
		static_assert(sizeof(sect0) == size);

		if (!run)
		{
			backupHelper.Save(addr, size);
		}

		if (enable)
		{
			protectionHelper.Push(addr, size);
			CopyMemory(addr, sect0, sizeof(sect0));
			*reinterpret_cast<uint32 *>(addr + 2) = __builtin_offsetof(ActorData, newEffectIndices[3]) ;
			protectionHelper.Pop();
		}
		else
		{
			backupHelper.Restore(addr);
		}
	}
	{
		auto addr = (appBaseAddr + 0x204388);
		constexpr uint32 size = 10;
		/*
		dmc3.exe+204388 - 81 0D 3AEAA800 00000002 - OR [7FF6784E2DCC],02000000
		dmc3.exe+204392
		*/

		constexpr byte8 sect0[] =
		{
			0x81, 0x8B, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, // or [rbx+0000B8C0],02000000
		};
		static_assert(sizeof(sect0) == size);

		if (!run)
		{
			backupHelper.Save(addr, size);
		}

		if (enable)
		{
			protectionHelper.Push(addr, size);
			CopyMemory(addr, sect0, sizeof(sect0));
			*reinterpret_cast<uint32 *>(addr + 2) = __builtin_offsetof(ActorData, newEffectIndices[3]) ;
			protectionHelper.Pop();
		}
		else
		{
			backupHelper.Restore(addr);
		}
	}
	{
		auto addr = (appBaseAddr + 0x20442A);
		constexpr uint32 size = 10;
		/*
		dmc3.exe+20442A - 81 0D 98E9A800 00000002 - OR [7FF6784E2DCC],02000000
		dmc3.exe+204434
		*/

		constexpr byte8 sect0[] =
		{
			0x81, 0x8B, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, // or [rbx+0000B8C0],02000000
		};
		static_assert(sizeof(sect0) == size);

		if (!run)
		{
			backupHelper.Save(addr, size);
		}

		if (enable)
		{
			protectionHelper.Push(addr, size);
			CopyMemory(addr, sect0, sizeof(sect0));
			*reinterpret_cast<uint32 *>(addr + 2) = __builtin_offsetof(ActorData, newEffectIndices[3]) ;
			protectionHelper.Pop();
		}
		else
		{
			backupHelper.Restore(addr);
		}
	}
	{
		auto addr = (appBaseAddr + 0x20484C);
		constexpr uint32 size = 10;
		/*
		dmc3.exe+20484C - 81 0D 76E5A800 00002000 - OR [7FF6784E2DCC],00200000
		dmc3.exe+204856
		*/

		constexpr byte8 sect0[] =
		{
			0x81, 0x8B, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x20, 0x00, // or [rbx+0000B8C0],00200000
		};
		static_assert(sizeof(sect0) == size);

		if (!run)
		{
			backupHelper.Save(addr, size);
		}

		if (enable)
		{
			protectionHelper.Push(addr, size);
			CopyMemory(addr, sect0, sizeof(sect0));
			*reinterpret_cast<uint32 *>(addr + 2) = __builtin_offsetof(ActorData, newEffectIndices[3]) ;
			protectionHelper.Pop();
		}
		else
		{
			backupHelper.Restore(addr);
		}
	}
	{
		auto addr = (appBaseAddr + 0x205864);
		constexpr uint32 size = 7;
		/*
		dmc3.exe+205864 - 83 0D 61D5A800 04 - OR DWORD PTR [7FF6784E2DCC],04
		dmc3.exe+20586B
		*/

		constexpr byte8 sect0[] =
		{
			0x83, 0x8F, 0x00, 0x00, 0x00, 0x00, 0x04, // or dword ptr [rdi+0000B8C0],04
		};
		static_assert(sizeof(sect0) == size);

		if (!run)
		{
			backupHelper.Save(addr, size);
		}

		if (enable)
		{
			protectionHelper.Push(addr, size);
			CopyMemory(addr, sect0, sizeof(sect0));
			*reinterpret_cast<uint32 *>(addr + 2) = __builtin_offsetof(ActorData, newEffectIndices[3]) ;
			protectionHelper.Pop();
		}
		else
		{
			backupHelper.Restore(addr);
		}
	}
	{
		auto addr = (appBaseAddr + 0x205913);
		constexpr uint32 size = 7;
		/*
		dmc3.exe+205913 - 83 0D B2D4A800 04 - OR DWORD PTR [7FF6784E2DCC],04
		dmc3.exe+20591A
		*/

		constexpr byte8 sect0[] =
		{
			0x83, 0x8F, 0x00, 0x00, 0x00, 0x00, 0x04, // or dword ptr [rdi+0000B8C0],04
		};
		static_assert(sizeof(sect0) == size);

		if (!run)
		{
			backupHelper.Save(addr, size);
		}

		if (enable)
		{
			protectionHelper.Push(addr, size);
			CopyMemory(addr, sect0, sizeof(sect0));
			*reinterpret_cast<uint32 *>(addr + 2) = __builtin_offsetof(ActorData, newEffectIndices[3]) ;
			protectionHelper.Pop();
		}
		else
		{
			backupHelper.Restore(addr);
		}
	}
	{
		auto addr = (appBaseAddr + 0x205AD3);
		constexpr uint32 size = 7;
		/*
		dmc3.exe+205AD3 - 83 0D F2D2A800 08 - OR DWORD PTR [7FF6784E2DCC],08
		dmc3.exe+205ADA
		*/

		constexpr byte8 sect0[] =
		{
			0x83, 0x8F, 0x00, 0x00, 0x00, 0x00, 0x08, // or dword ptr [rdi+0000B8C0],08
		};
		static_assert(sizeof(sect0) == size);

		if (!run)
		{
			backupHelper.Save(addr, size);
		}

		if (enable)
		{
			protectionHelper.Push(addr, size);
			CopyMemory(addr, sect0, sizeof(sect0));
			*reinterpret_cast<uint32 *>(addr + 2) = __builtin_offsetof(ActorData, newEffectIndices[3]) ;
			protectionHelper.Pop();
		}
		else
		{
			backupHelper.Restore(addr);
		}
	}
	{
		auto addr = (appBaseAddr + 0x2091E0);
		constexpr uint32 size = 7;
		/*
		dmc3.exe+2091E0 - 83 0D E59BA800 02 - OR DWORD PTR [7FF6784E2DCC],02
		dmc3.exe+2091E7
		*/

		constexpr byte8 sect0[] =
		{
			0x83, 0x8F, 0x00, 0x00, 0x00, 0x00, 0x02, // or dword ptr [rdi+0000B8C0],02
		};
		static_assert(sizeof(sect0) == size);

		if (!run)
		{
			backupHelper.Save(addr, size);
		}

		if (enable)
		{
			protectionHelper.Push(addr, size);
			CopyMemory(addr, sect0, sizeof(sect0));
			*reinterpret_cast<uint32 *>(addr + 2) = __builtin_offsetof(ActorData, newEffectIndices[3]) ;
			protectionHelper.Pop();
		}
		else
		{
			backupHelper.Restore(addr);
		}
	}
	{
		auto addr = (appBaseAddr + 0x2092B6);
		constexpr uint32 size = 7;
		/*
		dmc3.exe+2092B6 - 83 0D 0F9BA800 02 - OR DWORD PTR [7FF6784E2DCC],02
		dmc3.exe+2092BD
		*/

		constexpr byte8 sect0[] =
		{
			0x83, 0x8F, 0x00, 0x00, 0x00, 0x00, 0x02, // or dword ptr [rdi+0000B8C0],02
		};
		static_assert(sizeof(sect0) == size);

		if (!run)
		{
			backupHelper.Save(addr, size);
		}

		if (enable)
		{
			protectionHelper.Push(addr, size);
			CopyMemory(addr, sect0, sizeof(sect0));
			*reinterpret_cast<uint32 *>(addr + 2) = __builtin_offsetof(ActorData, newEffectIndices[3]) ;
			protectionHelper.Pop();
		}
		else
		{
			backupHelper.Restore(addr);
		}
	}
	{
		auto addr = (appBaseAddr + 0x20FBFD);
		constexpr uint32 size = 7;
		/*
		dmc3.exe+20FBFD - 83 0D C831A800 10 - OR DWORD PTR [7FF6784E2DCC],10
		dmc3.exe+20FC04
		*/

		constexpr byte8 sect0[] =
		{
			0x83, 0x8B, 0x00, 0x00, 0x00, 0x00, 0x10, // or dword ptr [rbx+0000B8C0],10
		};
		static_assert(sizeof(sect0) == size);

		if (!run)
		{
			backupHelper.Save(addr, size);
		}

		if (enable)
		{
			protectionHelper.Push(addr, size);
			CopyMemory(addr, sect0, sizeof(sect0));
			*reinterpret_cast<uint32 *>(addr + 2) = __builtin_offsetof(ActorData, newEffectIndices[3]) ;
			protectionHelper.Pop();
		}
		else
		{
			backupHelper.Restore(addr);
		}
	}
	{
		auto addr = (appBaseAddr + 0x211950);
		constexpr uint32 size = 7;
		/*
		dmc3.exe+211950 - 83 0D 7514A800 01 - OR DWORD PTR [7FF6784E2DCC],01
		dmc3.exe+211957
		*/

		constexpr byte8 sect0[] =
		{
			0x83, 0x8B, 0x00, 0x00, 0x00, 0x00, 0x01, // or dword ptr [rbx+0000B8C0],01
		};
		static_assert(sizeof(sect0) == size);

		if (!run)
		{
			backupHelper.Save(addr, size);
		}

		if (enable)
		{
			protectionHelper.Push(addr, size);
			CopyMemory(addr, sect0, sizeof(sect0));
			*reinterpret_cast<uint32 *>(addr + 2) = __builtin_offsetof(ActorData, newEffectIndices[3]) ;
			protectionHelper.Pop();
		}
		else
		{
			backupHelper.Restore(addr);
		}
	}
	{
		auto addr = (appBaseAddr + 0x211AA5);
		constexpr uint32 size = 7;
		/*
		dmc3.exe+211AA5 - 83 0D 2013A800 01 - OR DWORD PTR [7FF6784E2DCC],01
		dmc3.exe+211AAC
		*/

		constexpr byte8 sect0[] =
		{
			0x83, 0x8B, 0x00, 0x00, 0x00, 0x00, 0x01, // or dword ptr [rbx+0000B8C0],01
		};
		static_assert(sizeof(sect0) == size);

		if (!run)
		{
			backupHelper.Save(addr, size);
		}

		if (enable)
		{
			protectionHelper.Push(addr, size);
			CopyMemory(addr, sect0, sizeof(sect0));
			*reinterpret_cast<uint32 *>(addr + 2) = __builtin_offsetof(ActorData, newEffectIndices[3]) ;
			protectionHelper.Pop();
		}
		else
		{
			backupHelper.Restore(addr);
		}
	}
	{
		auto addr = (appBaseAddr + 0x215D66);
		constexpr uint32 size = 10;
		/*
		dmc3.exe+215D66 - 81 0D 5CD0A700 00000100 - OR [7FF6784E2DCC],00010000
		dmc3.exe+215D70
		*/

		constexpr byte8 sect0[] =
		{
			0x81, 0x8F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, // or [rdi+0000B8C0],00010000
		};
		static_assert(sizeof(sect0) == size);

		if (!run)
		{
			backupHelper.Save(addr, size);
		}

		if (enable)
		{
			protectionHelper.Push(addr, size);
			CopyMemory(addr, sect0, sizeof(sect0));
			*reinterpret_cast<uint32 *>(addr + 2) = __builtin_offsetof(ActorData, newEffectIndices[3]) ;
			protectionHelper.Pop();
		}
		else
		{
			backupHelper.Restore(addr);
		}
	}
	{
		auto addr = (appBaseAddr + 0x21605D);
		constexpr uint32 size = 10;
		/*
		dmc3.exe+21605D - 81 0D 65CDA700 00000100 - OR [7FF6784E2DCC],00010000
		dmc3.exe+216067
		*/

		constexpr byte8 sect0[] =
		{
			0x81, 0x8F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, // or [rdi+0000B8C0],00010000
		};
		static_assert(sizeof(sect0) == size);

		if (!run)
		{
			backupHelper.Save(addr, size);
		}

		if (enable)
		{
			protectionHelper.Push(addr, size);
			CopyMemory(addr, sect0, sizeof(sect0));
			*reinterpret_cast<uint32 *>(addr + 2) = __builtin_offsetof(ActorData, newEffectIndices[3]) ;
			protectionHelper.Pop();
		}
		else
		{
			backupHelper.Restore(addr);
		}
	}
	{
		auto addr = (appBaseAddr + 0x21630D);
		constexpr uint32 size = 10;
		/*
		dmc3.exe+21630D - 81 0D B5CAA700 80070000 - OR [7FF6784E2DCC],00000780
		dmc3.exe+216317
		*/

		constexpr byte8 sect0[] =
		{
			0x81, 0x8F, 0x00, 0x00, 0x00, 0x00, 0x80, 0x07, 0x00, 0x00, // or [rdi+0000B8C0],00000780
		};
		static_assert(sizeof(sect0) == size);

		if (!run)
		{
			backupHelper.Save(addr, size);
		}

		if (enable)
		{
			protectionHelper.Push(addr, size);
			CopyMemory(addr, sect0, sizeof(sect0));
			*reinterpret_cast<uint32 *>(addr + 2) = __builtin_offsetof(ActorData, newEffectIndices[3]) ;
			protectionHelper.Pop();
		}
		else
		{
			backupHelper.Restore(addr);
		}
	}
	{
		auto addr = (appBaseAddr + 0x2164AF);
		constexpr uint32 size = 10;
		/*
		dmc3.exe+2164AF - 81 0D 13C9A700 00180000 - OR [7FF6784E2DCC],00001800
		dmc3.exe+2164B9
		*/

		constexpr byte8 sect0[] =
		{
			0x81, 0x8F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x18, 0x00, 0x00, // or [rdi+0000B8C0],00001800
		};
		static_assert(sizeof(sect0) == size);

		if (!run)
		{
			backupHelper.Save(addr, size);
		}

		if (enable)
		{
			protectionHelper.Push(addr, size);
			CopyMemory(addr, sect0, sizeof(sect0));
			*reinterpret_cast<uint32 *>(addr + 2) = __builtin_offsetof(ActorData, newEffectIndices[3]) ;
			protectionHelper.Pop();
		}
		else
		{
			backupHelper.Restore(addr);
		}
	}
	{
		auto addr = (appBaseAddr + 0x21B696);
		constexpr uint32 size = 10;
		/*
		dmc3.exe+21B696 - 81 0D 3077A700 00020000 - OR [7FF6784E2DD0],00000200
		dmc3.exe+21B6A0
		*/

		constexpr byte8 sect0[] =
		{
			0x81, 0x8B, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, // or [rbx+0000B8C0],00000200
		};
		static_assert(sizeof(sect0) == size);

		if (!run)
		{
			backupHelper.Save(addr, size);
		}

		if (enable)
		{
			protectionHelper.Push(addr, size);
			CopyMemory(addr, sect0, sizeof(sect0));
			*reinterpret_cast<uint32 *>(addr + 2) = __builtin_offsetof(ActorData, newEffectIndices[4]) ;
			protectionHelper.Pop();
		}
		else
		{
			backupHelper.Restore(addr);
		}
	}
	{
		auto addr = (appBaseAddr + 0x21B85A);
		constexpr uint32 size = 7;
		/*
		dmc3.exe+21B85A - 83 0D 6F75A700 40 - OR DWORD PTR [7FF6784E2DD0],40
		dmc3.exe+21B861
		*/

		constexpr byte8 sect0[] =
		{
			0x83, 0x8B, 0x00, 0x00, 0x00, 0x00, 0x40, // or dword ptr [rbx+0000B8C0],40
		};
		static_assert(sizeof(sect0) == size);

		if (!run)
		{
			backupHelper.Save(addr, size);
		}

		if (enable)
		{
			protectionHelper.Push(addr, size);
			CopyMemory(addr, sect0, sizeof(sect0));
			*reinterpret_cast<uint32 *>(addr + 2) = __builtin_offsetof(ActorData, newEffectIndices[4]) ;
			protectionHelper.Pop();
		}
		else
		{
			backupHelper.Restore(addr);
		}
	}
	{
		auto addr = (appBaseAddr + 0x21BB16);
		constexpr uint32 size = 10;
		/*
		dmc3.exe+21BB16 - 81 0D B072A700 00000002 - OR [7FF6784E2DD0],02000000
		dmc3.exe+21BB20
		*/

		constexpr byte8 sect0[] =
		{
			0x81, 0x8B, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, // or [rbx+0000B8C0],02000000
		};
		static_assert(sizeof(sect0) == size);

		if (!run)
		{
			backupHelper.Save(addr, size);
		}

		if (enable)
		{
			protectionHelper.Push(addr, size);
			CopyMemory(addr, sect0, sizeof(sect0));
			*reinterpret_cast<uint32 *>(addr + 2) = __builtin_offsetof(ActorData, newEffectIndices[4]) ;
			protectionHelper.Pop();
		}
		else
		{
			backupHelper.Restore(addr);
		}
	}
	{
		auto addr = (appBaseAddr + 0x21BB40);
		constexpr uint32 size = 10;
		/*
		dmc3.exe+21BB40 - 81 0D 8672A700 00000002 - OR [7FF6784E2DD0],02000000
		dmc3.exe+21BB4A
		*/

		constexpr byte8 sect0[] =
		{
			0x81, 0x8B, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, // or [rbx+0000B8C0],02000000
		};
		static_assert(sizeof(sect0) == size);

		if (!run)
		{
			backupHelper.Save(addr, size);
		}

		if (enable)
		{
			protectionHelper.Push(addr, size);
			CopyMemory(addr, sect0, sizeof(sect0));
			*reinterpret_cast<uint32 *>(addr + 2) = __builtin_offsetof(ActorData, newEffectIndices[4]) ;
			protectionHelper.Pop();
		}
		else
		{
			backupHelper.Restore(addr);
		}
	}
	{
		auto addr = (appBaseAddr + 0x21BEE2);
		constexpr uint32 size = 10;
		/*
		dmc3.exe+21BEE2 - 81 0D E46EA700 00000001 - OR [7FF6784E2DD0],01000000
		dmc3.exe+21BEEC
		*/

		constexpr byte8 sect0[] =
		{
			0x81, 0x8B, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, // or [rbx+0000B8C0],01000000
		};
		static_assert(sizeof(sect0) == size);

		if (!run)
		{
			backupHelper.Save(addr, size);
		}

		if (enable)
		{
			protectionHelper.Push(addr, size);
			CopyMemory(addr, sect0, sizeof(sect0));
			*reinterpret_cast<uint32 *>(addr + 2) = __builtin_offsetof(ActorData, newEffectIndices[4]) ;
			protectionHelper.Pop();
		}
		else
		{
			backupHelper.Restore(addr);
		}
	}
	{
		auto addr = (appBaseAddr + 0x21BF11);
		constexpr uint32 size = 10;
		/*
		dmc3.exe+21BF11 - 81 0D B56EA700 00000001 - OR [7FF6784E2DD0],01000000
		dmc3.exe+21BF1B
		*/

		constexpr byte8 sect0[] =
		{
			0x81, 0x8B, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, // or [rbx+0000B8C0],01000000
		};
		static_assert(sizeof(sect0) == size);

		if (!run)
		{
			backupHelper.Save(addr, size);
		}

		if (enable)
		{
			protectionHelper.Push(addr, size);
			CopyMemory(addr, sect0, sizeof(sect0));
			*reinterpret_cast<uint32 *>(addr + 2) = __builtin_offsetof(ActorData, newEffectIndices[4]) ;
			protectionHelper.Pop();
		}
		else
		{
			backupHelper.Restore(addr);
		}
	}
	{
		auto addr = (appBaseAddr + 0x21C1C6);
		constexpr uint32 size = 10;
		/*
		dmc3.exe+21C1C6 - 81 0D 006CA700 00020000 - OR [7FF6784E2DD0],00000200
		dmc3.exe+21C1D0
		*/

		constexpr byte8 sect0[] =
		{
			0x81, 0x8B, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, // or [rbx+0000B8C0],00000200
		};
		static_assert(sizeof(sect0) == size);

		if (!run)
		{
			backupHelper.Save(addr, size);
		}

		if (enable)
		{
			protectionHelper.Push(addr, size);
			CopyMemory(addr, sect0, sizeof(sect0));
			*reinterpret_cast<uint32 *>(addr + 2) = __builtin_offsetof(ActorData, newEffectIndices[4]) ;
			protectionHelper.Pop();
		}
		else
		{
			backupHelper.Restore(addr);
		}
	}
	{
		auto addr = (appBaseAddr + 0x21C34A);
		constexpr uint32 size = 10;
		/*
		dmc3.exe+21C34A - 81 0D 7C6AA700 80000000 - OR [7FF6784E2DD0],00000080
		dmc3.exe+21C354
		*/

		constexpr byte8 sect0[] =
		{
			0x81, 0x8B, 0x00, 0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 0x00, // or [rbx+0000B8C0],00000080
		};
		static_assert(sizeof(sect0) == size);

		if (!run)
		{
			backupHelper.Save(addr, size);
		}

		if (enable)
		{
			protectionHelper.Push(addr, size);
			CopyMemory(addr, sect0, sizeof(sect0));
			*reinterpret_cast<uint32 *>(addr + 2) = __builtin_offsetof(ActorData, newEffectIndices[4]) ;
			protectionHelper.Pop();
		}
		else
		{
			backupHelper.Restore(addr);
		}
	}
	{
		auto addr = (appBaseAddr + 0x21C57A);
		constexpr uint32 size = 10;
		/*
		dmc3.exe+21C57A - 81 0D 4C68A700 00020000 - OR [7FF6784E2DD0],00000200
		dmc3.exe+21C584
		*/

		constexpr byte8 sect0[] =
		{
			0x81, 0x8B, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, // or [rbx+0000B8C0],00000200
		};
		static_assert(sizeof(sect0) == size);

		if (!run)
		{
			backupHelper.Save(addr, size);
		}

		if (enable)
		{
			protectionHelper.Push(addr, size);
			CopyMemory(addr, sect0, sizeof(sect0));
			*reinterpret_cast<uint32 *>(addr + 2) = __builtin_offsetof(ActorData, newEffectIndices[4]) ;
			protectionHelper.Pop();
		}
		else
		{
			backupHelper.Restore(addr);
		}
	}
	{
		auto addr = (appBaseAddr + 0x21C703);
		constexpr uint32 size = 10;
		/*
		dmc3.exe+21C703 - 81 0D C366A700 00010000 - OR [7FF6784E2DD0],00000100
		dmc3.exe+21C70D
		*/

		constexpr byte8 sect0[] =
		{
			0x81, 0x8B, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, // or [rbx+0000B8C0],00000100
		};
		static_assert(sizeof(sect0) == size);

		if (!run)
		{
			backupHelper.Save(addr, size);
		}

		if (enable)
		{
			protectionHelper.Push(addr, size);
			CopyMemory(addr, sect0, sizeof(sect0));
			*reinterpret_cast<uint32 *>(addr + 2) = __builtin_offsetof(ActorData, newEffectIndices[4]) ;
			protectionHelper.Pop();
		}
		else
		{
			backupHelper.Restore(addr);
		}
	}
	{
		auto addr = (appBaseAddr + 0x21D04D);
		constexpr uint32 size = 10;
		/*
		dmc3.exe+21D04D - 81 0D 795DA700 000C0000 - OR [7FF6784E2DD0],00000C00
		dmc3.exe+21D057
		*/

		constexpr byte8 sect0[] =
		{
			0x81, 0x8F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0C, 0x00, 0x00, // or [rdi+0000B8C0],00000C00
		};
		static_assert(sizeof(sect0) == size);

		if (!run)
		{
			backupHelper.Save(addr, size);
		}

		if (enable)
		{
			protectionHelper.Push(addr, size);
			CopyMemory(addr, sect0, sizeof(sect0));
			*reinterpret_cast<uint32 *>(addr + 2) = __builtin_offsetof(ActorData, newEffectIndices[4]) ;
			protectionHelper.Pop();
		}
		else
		{
			backupHelper.Restore(addr);
		}
	}
	{
		auto addr = (appBaseAddr + 0x21D228);
		constexpr uint32 size = 10;
		/*
		dmc3.exe+21D228 - 81 0D 9E5BA700 00000200 - OR [7FF6784E2DD0],00020000
		dmc3.exe+21D232
		*/

		constexpr byte8 sect0[] =
		{
			0x81, 0x8F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x00, // or [rdi+0000B8C0],00020000
		};
		static_assert(sizeof(sect0) == size);

		if (!run)
		{
			backupHelper.Save(addr, size);
		}

		if (enable)
		{
			protectionHelper.Push(addr, size);
			CopyMemory(addr, sect0, sizeof(sect0));
			*reinterpret_cast<uint32 *>(addr + 2) = __builtin_offsetof(ActorData, newEffectIndices[4]) ;
			protectionHelper.Pop();
		}
		else
		{
			backupHelper.Restore(addr);
		}
	}
	{
		auto addr = (appBaseAddr + 0x21DA15);
		constexpr uint32 size = 6;
		/*
		dmc3.exe+21DA15 - 8B 0D B553A700 - MOV ECX,[7FF6784E2DD0]
		dmc3.exe+21DA1B
		*/

		constexpr byte8 sect0[] =
		{
			0x8B, 0x8B, 0x00, 0x00, 0x00, 0x00, // mov ecx,[rbx+0000B8C0]
		};
		static_assert(sizeof(sect0) == size);

		if (!run)
		{
			backupHelper.Save(addr, size);
		}

		if (enable)
		{
			protectionHelper.Push(addr, size);
			CopyMemory(addr, sect0, sizeof(sect0));
			*reinterpret_cast<uint32 *>(addr + 2) = __builtin_offsetof(ActorData, newEffectIndices[4]) ;
			protectionHelper.Pop();
		}
		else
		{
			backupHelper.Restore(addr);
		}
	}
	{
		auto addr = (appBaseAddr + 0x21DA2F);
		constexpr uint32 size = 6;
		/*
		dmc3.exe+21DA2F - 89 0D 9B53A700 - MOV [7FF6784E2DD0],ECX
		dmc3.exe+21DA35
		*/

		constexpr byte8 sect0[] =
		{
			0x89, 0x8B, 0x00, 0x00, 0x00, 0x00, // mov [rbx+0000B8C0],ecx
		};
		static_assert(sizeof(sect0) == size);

		if (!run)
		{
			backupHelper.Save(addr, size);
		}

		if (enable)
		{
			protectionHelper.Push(addr, size);
			CopyMemory(addr, sect0, sizeof(sect0));
			*reinterpret_cast<uint32 *>(addr + 2) = __builtin_offsetof(ActorData, newEffectIndices[4]) ;
			protectionHelper.Pop();
		}
		else
		{
			backupHelper.Restore(addr);
		}
	}
	{
		auto addr = (appBaseAddr + 0x21DEBE);
		constexpr uint32 size = 10;
		/*
		dmc3.exe+21DEBE - 81 0D 084FA700 00000004 - OR [7FF6784E2DD0],04000000
		dmc3.exe+21DEC8
		*/

		constexpr byte8 sect0[] =
		{
			0x81, 0x8B, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x04, // or [rbx+0000B8C0],04000000
		};
		static_assert(sizeof(sect0) == size);

		if (!run)
		{
			backupHelper.Save(addr, size);
		}

		if (enable)
		{
			protectionHelper.Push(addr, size);
			CopyMemory(addr, sect0, sizeof(sect0));
			*reinterpret_cast<uint32 *>(addr + 2) = __builtin_offsetof(ActorData, newEffectIndices[4]) ;
			protectionHelper.Pop();
		}
		else
		{
			backupHelper.Restore(addr);
		}
	}
	{
		auto addr = (appBaseAddr + 0x21E885);
		constexpr uint32 size = 10;
		/*
		dmc3.exe+21E885 - 81 0D 4145A700 00100000 - OR [7FF6784E2DD0],00001000
		dmc3.exe+21E88F
		*/

		constexpr byte8 sect0[] =
		{
			0x81, 0x8B, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0x00, 0x00, // or [rbx+0000B8C0],00001000
		};
		static_assert(sizeof(sect0) == size);

		if (!run)
		{
			backupHelper.Save(addr, size);
		}

		if (enable)
		{
			protectionHelper.Push(addr, size);
			CopyMemory(addr, sect0, sizeof(sect0));
			*reinterpret_cast<uint32 *>(addr + 2) = __builtin_offsetof(ActorData, newEffectIndices[4]) ;
			protectionHelper.Pop();
		}
		else
		{
			backupHelper.Restore(addr);
		}
	}
	{
		auto addr = (appBaseAddr + 0x21F56D);
		constexpr uint32 size = 10;
		/*
		dmc3.exe+21F56D - 81 0D 5938A700 00000200 - OR [7FF6784E2DD0],00020000
		dmc3.exe+21F577
		*/

		constexpr byte8 sect0[] =
		{
			0x81, 0x8F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x00, // or [rdi+0000B8C0],00020000
		};
		static_assert(sizeof(sect0) == size);

		if (!run)
		{
			backupHelper.Save(addr, size);
		}

		if (enable)
		{
			protectionHelper.Push(addr, size);
			CopyMemory(addr, sect0, sizeof(sect0));
			*reinterpret_cast<uint32 *>(addr + 2) = __builtin_offsetof(ActorData, newEffectIndices[4]) ;
			protectionHelper.Pop();
		}
		else
		{
			backupHelper.Restore(addr);
		}
	}
	{
		auto addr = (appBaseAddr + 0x21F61A);
		constexpr uint32 size = 10;
		/*
		dmc3.exe+21F61A - 81 0D AC37A700 00000200 - OR [7FF6784E2DD0],00020000
		dmc3.exe+21F624
		*/

		constexpr byte8 sect0[] =
		{
			0x81, 0x8F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x00, // or [rdi+0000B8C0],00020000
		};
		static_assert(sizeof(sect0) == size);

		if (!run)
		{
			backupHelper.Save(addr, size);
		}

		if (enable)
		{
			protectionHelper.Push(addr, size);
			CopyMemory(addr, sect0, sizeof(sect0));
			*reinterpret_cast<uint32 *>(addr + 2) = __builtin_offsetof(ActorData, newEffectIndices[4]) ;
			protectionHelper.Pop();
		}
		else
		{
			backupHelper.Restore(addr);
		}
	}
	{
		auto addr = (appBaseAddr + 0x21FBF2);
		constexpr uint32 size = 10;
		/*
		dmc3.exe+21FBF2 - 81 0D D431A700 00000020 - OR [7FF6784E2DD0],20000000
		dmc3.exe+21FBFC
		*/

		constexpr byte8 sect0[] =
		{
			0x81, 0x8B, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x20, // or [rbx+0000B8C0],20000000
		};
		static_assert(sizeof(sect0) == size);

		if (!run)
		{
			backupHelper.Save(addr, size);
		}

		if (enable)
		{
			protectionHelper.Push(addr, size);
			CopyMemory(addr, sect0, sizeof(sect0));
			*reinterpret_cast<uint32 *>(addr + 2) = __builtin_offsetof(ActorData, newEffectIndices[4]) ;
			protectionHelper.Pop();
		}
		else
		{
			backupHelper.Restore(addr);
		}
	}
	{
		auto addr = (appBaseAddr + 0x1F952C);
		constexpr uint32 size = 10;
		/*
		dmc3.exe+1F952C - 81 0D 9E98A900 00060000 - OR [7FF6784E2DD4],00000600
		dmc3.exe+1F9536
		*/

		constexpr byte8 sect0[] =
		{
			0x81, 0x8B, 0x00, 0x00, 0x00, 0x00, 0x00, 0x06, 0x00, 0x00, // or [rbx+0000B8C0],00000600
		};
		static_assert(sizeof(sect0) == size);

		if (!run)
		{
			backupHelper.Save(addr, size);
		}

		if (enable)
		{
			protectionHelper.Push(addr, size);
			CopyMemory(addr, sect0, sizeof(sect0));
			*reinterpret_cast<uint32 *>(addr + 2) = __builtin_offsetof(ActorData, newEffectIndices[5]) ;
			protectionHelper.Pop();
		}
		else
		{
			backupHelper.Restore(addr);
		}
	}
	{
		auto addr = (appBaseAddr + 0x21AED9);
		constexpr uint32 size = 10;
		/*
		dmc3.exe+21AED9 - 81 0D F17EA700 00400000 - OR [7FF6784E2DD4],00004000
		dmc3.exe+21AEE3
		*/

		constexpr byte8 sect0[] =
		{
			0x81, 0x8F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x00, 0x00, // or [rdi+0000B8C0],00004000
		};
		static_assert(sizeof(sect0) == size);

		if (!run)
		{
			backupHelper.Save(addr, size);
		}

		if (enable)
		{
			protectionHelper.Push(addr, size);
			CopyMemory(addr, sect0, sizeof(sect0));
			*reinterpret_cast<uint32 *>(addr + 2) = __builtin_offsetof(ActorData, newEffectIndices[5]) ;
			protectionHelper.Pop();
		}
		else
		{
			backupHelper.Restore(addr);
		}
	}
	{
		auto addr = (appBaseAddr + 0x21B13A);
		constexpr uint32 size = 10;
		/*
		dmc3.exe+21B13A - 81 0D 907CA700 00010000 - OR [7FF6784E2DD4],00000100
		dmc3.exe+21B144
		*/

		constexpr byte8 sect0[] =
		{
			0x81, 0x8B, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, // or [rbx+0000B8C0],00000100
		};
		static_assert(sizeof(sect0) == size);

		if (!run)
		{
			backupHelper.Save(addr, size);
		}

		if (enable)
		{
			protectionHelper.Push(addr, size);
			CopyMemory(addr, sect0, sizeof(sect0));
			*reinterpret_cast<uint32 *>(addr + 2) = __builtin_offsetof(ActorData, newEffectIndices[5]) ;
			protectionHelper.Pop();
		}
		else
		{
			backupHelper.Restore(addr);
		}
	}
	{
		auto addr = (appBaseAddr + 0x21EB8A);
		constexpr uint32 size = 10;
		/*
		dmc3.exe+21EB8A - 81 0D 4042A700 00080000 - OR [7FF6784E2DD4],00000800
		dmc3.exe+21EB94
		*/

		constexpr byte8 sect0[] =
		{
			0x81, 0x8F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, // or [rdi+0000B8C0],00000800
		};
		static_assert(sizeof(sect0) == size);

		if (!run)
		{
			backupHelper.Save(addr, size);
		}

		if (enable)
		{
			protectionHelper.Push(addr, size);
			CopyMemory(addr, sect0, sizeof(sect0));
			*reinterpret_cast<uint32 *>(addr + 2) = __builtin_offsetof(ActorData, newEffectIndices[5]) ;
			protectionHelper.Pop();
		}
		else
		{
			backupHelper.Restore(addr);
		}
	}
	{
		auto addr = (appBaseAddr + 0x21EC17);
		constexpr uint32 size = 10;
		/*
		dmc3.exe+21EC17 - 81 0D B341A700 00080000 - OR [7FF6784E2DD4],00000800
		dmc3.exe+21EC21
		*/

		constexpr byte8 sect0[] =
		{
			0x81, 0x8F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, // or [rdi+0000B8C0],00000800
		};
		static_assert(sizeof(sect0) == size);

		if (!run)
		{
			backupHelper.Save(addr, size);
		}

		if (enable)
		{
			protectionHelper.Push(addr, size);
			CopyMemory(addr, sect0, sizeof(sect0));
			*reinterpret_cast<uint32 *>(addr + 2) = __builtin_offsetof(ActorData, newEffectIndices[5]) ;
			protectionHelper.Pop();
		}
		else
		{
			backupHelper.Restore(addr);
		}
	}
	{
		auto addr = (appBaseAddr + 0x21EDBB);
		constexpr uint32 size = 10;
		/*
		dmc3.exe+21EDBB - 81 0D 0F40A700 00100000 - OR [7FF6784E2DD4],00001000
		dmc3.exe+21EDC5
		*/

		constexpr byte8 sect0[] =
		{
			0x81, 0x8F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0x00, 0x00, // or [rdi+0000B8C0],00001000
		};
		static_assert(sizeof(sect0) == size);

		if (!run)
		{
			backupHelper.Save(addr, size);
		}

		if (enable)
		{
			protectionHelper.Push(addr, size);
			CopyMemory(addr, sect0, sizeof(sect0));
			*reinterpret_cast<uint32 *>(addr + 2) = __builtin_offsetof(ActorData, newEffectIndices[5]) ;
			protectionHelper.Pop();
		}
		else
		{
			backupHelper.Restore(addr);
		}
	}
	{
		auto addr = (appBaseAddr + 0x21F865);
		constexpr uint32 size = 6;
		/*
		dmc3.exe+21F865 - 09 05 6935A700 - OR [7FF6784E2DD4],EAX
		dmc3.exe+21F86B
		*/

		constexpr byte8 sect0[] =
		{
			0x09, 0x83, 0x00, 0x00, 0x00, 0x00, // or [rbx+0000B8C0],eax
		};
		static_assert(sizeof(sect0) == size);

		if (!run)
		{
			backupHelper.Save(addr, size);
		}

		if (enable)
		{
			protectionHelper.Push(addr, size);
			CopyMemory(addr, sect0, sizeof(sect0));
			*reinterpret_cast<uint32 *>(addr + 2) = __builtin_offsetof(ActorData, newEffectIndices[5]) ;
			protectionHelper.Pop();
		}
		else
		{
			backupHelper.Restore(addr);
		}
	}
	{
		auto addr = (appBaseAddr + 0x21F955);
		constexpr uint32 size = 7;
		/*
		dmc3.exe+21F955 - 83 0D 7834A700 08 - OR DWORD PTR [7FF6784E2DD4],08
		dmc3.exe+21F95C
		*/

		constexpr byte8 sect0[] =
		{
			0x83, 0x8B, 0x00, 0x00, 0x00, 0x00, 0x08, // or dword ptr [rbx+0000B8C0],08
		};
		static_assert(sizeof(sect0) == size);

		if (!run)
		{
			backupHelper.Save(addr, size);
		}

		if (enable)
		{
			protectionHelper.Push(addr, size);
			CopyMemory(addr, sect0, sizeof(sect0));
			*reinterpret_cast<uint32 *>(addr + 2) = __builtin_offsetof(ActorData, newEffectIndices[5]) ;
			protectionHelper.Pop();
		}
		else
		{
			backupHelper.Restore(addr);
		}
	}
	{
		auto addr = (appBaseAddr + 0x21FA45);
		constexpr uint32 size = 7;
		/*
		dmc3.exe+21FA45 - 83 0D 8833A700 10 - OR DWORD PTR [7FF6784E2DD4],10
		dmc3.exe+21FA4C
		*/

		constexpr byte8 sect0[] =
		{
			0x83, 0x8B, 0x00, 0x00, 0x00, 0x00, 0x10, // or dword ptr [rbx+0000B8C0],10
		};
		static_assert(sizeof(sect0) == size);

		if (!run)
		{
			backupHelper.Save(addr, size);
		}

		if (enable)
		{
			protectionHelper.Push(addr, size);
			CopyMemory(addr, sect0, sizeof(sect0));
			*reinterpret_cast<uint32 *>(addr + 2) = __builtin_offsetof(ActorData, newEffectIndices[5]) ;
			protectionHelper.Pop();
		}
		else
		{
			backupHelper.Restore(addr);
		}
	}
	{
		auto addr = (appBaseAddr + 0x21FF82);
		constexpr uint32 size = 7;
		/*
		dmc3.exe+21FF82 - 83 0D 4B2EA700 02 - OR DWORD PTR [7FF6784E2DD4],02
		dmc3.exe+21FF89
		*/

		constexpr byte8 sect0[] =
		{
			0x83, 0x8B, 0x00, 0x00, 0x00, 0x00, 0x02, // or dword ptr [rbx+0000B8C0],02
		};
		static_assert(sizeof(sect0) == size);

		if (!run)
		{
			backupHelper.Save(addr, size);
		}

		if (enable)
		{
			protectionHelper.Push(addr, size);
			CopyMemory(addr, sect0, sizeof(sect0));
			*reinterpret_cast<uint32 *>(addr + 2) = __builtin_offsetof(ActorData, newEffectIndices[5]) ;
			protectionHelper.Pop();
		}
		else
		{
			backupHelper.Restore(addr);
		}
	}
	{
		auto addr = (appBaseAddr + 0x2201E4);
		constexpr uint32 size = 7;
		/*
		dmc3.exe+2201E4 - 83 0D E92BA700 20 - OR DWORD PTR [7FF6784E2DD4],20
		dmc3.exe+2201EB
		*/

		constexpr byte8 sect0[] =
		{
			0x83, 0x8B, 0x00, 0x00, 0x00, 0x00, 0x20, // or dword ptr [rbx+0000B8C0],20
		};
		static_assert(sizeof(sect0) == size);

		if (!run)
		{
			backupHelper.Save(addr, size);
		}

		if (enable)
		{
			protectionHelper.Push(addr, size);
			CopyMemory(addr, sect0, sizeof(sect0));
			*reinterpret_cast<uint32 *>(addr + 2) = __builtin_offsetof(ActorData, newEffectIndices[5]) ;
			protectionHelper.Pop();
		}
		else
		{
			backupHelper.Restore(addr);
		}
	}
	{
		auto addr = (appBaseAddr + 0x1FDEE2);
		constexpr uint32 size = 10;
		/*
		dmc3.exe+1FDEE2 - 81 0D EC4EA900 00001800 - OR [7FF6784E2DD8],00180000
		dmc3.exe+1FDEEC
		*/

		constexpr byte8 sect0[] =
		{
			0x81, 0x8B, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x18, 0x00, // or [rbx+0000B8C0],00180000
		};
		static_assert(sizeof(sect0) == size);

		if (!run)
		{
			backupHelper.Save(addr, size);
		}

		if (enable)
		{
			protectionHelper.Push(addr, size);
			CopyMemory(addr, sect0, sizeof(sect0));
			*reinterpret_cast<uint32 *>(addr + 2) = __builtin_offsetof(ActorData, newEffectIndices[6]) ;
			protectionHelper.Pop();
		}
		else
		{
			backupHelper.Restore(addr);
		}
	}
	{
		auto addr = (appBaseAddr + 0x215854);
		constexpr uint32 size = 10;
		/*
		dmc3.exe+215854 - 81 0D 7AD5A700 00001800 - OR [7FF6784E2DD8],00180000
		dmc3.exe+21585E
		*/

		constexpr byte8 sect0[] =
		{
			0x81, 0x8F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x18, 0x00, // or [rdi+0000B8C0],00180000
		};
		static_assert(sizeof(sect0) == size);

		if (!run)
		{
			backupHelper.Save(addr, size);
		}

		if (enable)
		{
			protectionHelper.Push(addr, size);
			CopyMemory(addr, sect0, sizeof(sect0));
			*reinterpret_cast<uint32 *>(addr + 2) = __builtin_offsetof(ActorData, newEffectIndices[6]) ;
			protectionHelper.Pop();
		}
		else
		{
			backupHelper.Restore(addr);
		}
	}
	{
		auto addr = (appBaseAddr + 0x215A73);
		constexpr uint32 size = 10;
		/*
		dmc3.exe+215A73 - 81 0D 5BD3A700 00001800 - OR [7FF6784E2DD8],00180000
		dmc3.exe+215A7D
		*/

		constexpr byte8 sect0[] =
		{
			0x81, 0x8F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x18, 0x00, // or [rdi+0000B8C0],00180000
		};
		static_assert(sizeof(sect0) == size);

		if (!run)
		{
			backupHelper.Save(addr, size);
		}

		if (enable)
		{
			protectionHelper.Push(addr, size);
			CopyMemory(addr, sect0, sizeof(sect0));
			*reinterpret_cast<uint32 *>(addr + 2) = __builtin_offsetof(ActorData, newEffectIndices[6]) ;
			protectionHelper.Pop();
		}
		else
		{
			backupHelper.Restore(addr);
		}
	}
	{
		auto addr = (appBaseAddr + 0x1F9590);
		constexpr uint32 size = 6;
		/*
		dmc3.exe+1F9590 - 8B 05 4698A900 - MOV EAX,[7FF6784E2DDC]
		dmc3.exe+1F9596
		*/

		constexpr byte8 sect0[] =
		{
			0x8B, 0x83, 0x00, 0x00, 0x00, 0x00, // mov eax,[rbx+0000B8C0]
		};
		static_assert(sizeof(sect0) == size);

		if (!run)
		{
			backupHelper.Save(addr, size);
		}

		if (enable)
		{
			protectionHelper.Push(addr, size);
			CopyMemory(addr, sect0, sizeof(sect0));
			*reinterpret_cast<uint32 *>(addr + 2) = __builtin_offsetof(ActorData, newEffectIndices[7]) ;
			protectionHelper.Pop();
		}
		else
		{
			backupHelper.Restore(addr);
		}
	}
	{
		auto addr = (appBaseAddr + 0x1F95AA);
		constexpr uint32 size = 6;
		/*
		dmc3.exe+1F95AA - 89 05 2C98A900 - MOV [7FF6784E2DDC],EAX
		dmc3.exe+1F95B0
		*/

		constexpr byte8 sect0[] =
		{
			0x89, 0x83, 0x00, 0x00, 0x00, 0x00, // mov [rbx+0000B8C0],eax
		};
		static_assert(sizeof(sect0) == size);

		if (!run)
		{
			backupHelper.Save(addr, size);
		}

		if (enable)
		{
			protectionHelper.Push(addr, size);
			CopyMemory(addr, sect0, sizeof(sect0));
			*reinterpret_cast<uint32 *>(addr + 2) = __builtin_offsetof(ActorData, newEffectIndices[7]) ;
			protectionHelper.Pop();
		}
		else
		{
			backupHelper.Restore(addr);
		}
	}
	{
		auto addr = (appBaseAddr + 0x1F95C6);
		constexpr uint32 size = 6;
		/*
		dmc3.exe+1F95C6 - 8B 05 1098A900 - MOV EAX,[7FF6784E2DDC]
		dmc3.exe+1F95CC
		*/

		constexpr byte8 sect0[] =
		{
			0x8B, 0x83, 0x00, 0x00, 0x00, 0x00, // mov eax,[rbx+0000B8C0]
		};
		static_assert(sizeof(sect0) == size);

		if (!run)
		{
			backupHelper.Save(addr, size);
		}

		if (enable)
		{
			protectionHelper.Push(addr, size);
			CopyMemory(addr, sect0, sizeof(sect0));
			*reinterpret_cast<uint32 *>(addr + 2) = __builtin_offsetof(ActorData, newEffectIndices[7]) ;
			protectionHelper.Pop();
		}
		else
		{
			backupHelper.Restore(addr);
		}
	}
	{
		auto addr = (appBaseAddr + 0x1F95F0);
		constexpr uint32 size = 6;
		/*
		dmc3.exe+1F95F0 - 89 05 E697A900 - MOV [7FF6784E2DDC],EAX
		dmc3.exe+1F95F6
		*/

		constexpr byte8 sect0[] =
		{
			0x89, 0x83, 0x00, 0x00, 0x00, 0x00, // mov [rbx+0000B8C0],eax
		};
		static_assert(sizeof(sect0) == size);

		if (!run)
		{
			backupHelper.Save(addr, size);
		}

		if (enable)
		{
			protectionHelper.Push(addr, size);
			CopyMemory(addr, sect0, sizeof(sect0));
			*reinterpret_cast<uint32 *>(addr + 2) = __builtin_offsetof(ActorData, newEffectIndices[7]) ;
			protectionHelper.Pop();
		}
		else
		{
			backupHelper.Restore(addr);
		}
	}
	{
		auto addr = (appBaseAddr + 0x1F9596);
		constexpr uint32 size = 6;
		/*
		dmc3.exe+1F9596 - 8B 0D 4498A900 - MOV ECX,[7FF6784E2DE0]
		dmc3.exe+1F959C
		*/

		constexpr byte8 sect0[] =
		{
			0x8B, 0x8B, 0x00, 0x00, 0x00, 0x00, // mov ecx,[rbx+0000B8C0]
		};
		static_assert(sizeof(sect0) == size);

		if (!run)
		{
			backupHelper.Save(addr, size);
		}

		if (enable)
		{
			protectionHelper.Push(addr, size);
			CopyMemory(addr, sect0, sizeof(sect0));
			*reinterpret_cast<uint32 *>(addr + 2) = __builtin_offsetof(ActorData, newEffectIndices[8]) ;
			protectionHelper.Pop();
		}
		else
		{
			backupHelper.Restore(addr);
		}
	}
	{
		auto addr = (appBaseAddr + 0x1F95BA);
		constexpr uint32 size = 6;
		/*
		dmc3.exe+1F95BA - 89 0D 2098A900 - MOV [7FF6784E2DE0],ECX
		dmc3.exe+1F95C0
		*/

		constexpr byte8 sect0[] =
		{
			0x89, 0x8B, 0x00, 0x00, 0x00, 0x00, // mov [rbx+0000B8C0],ecx
		};
		static_assert(sizeof(sect0) == size);

		if (!run)
		{
			backupHelper.Save(addr, size);
		}

		if (enable)
		{
			protectionHelper.Push(addr, size);
			CopyMemory(addr, sect0, sizeof(sect0));
			*reinterpret_cast<uint32 *>(addr + 2) = __builtin_offsetof(ActorData, newEffectIndices[8]) ;
			protectionHelper.Pop();
		}
		else
		{
			backupHelper.Restore(addr);
		}
	}
	{
		auto addr = (appBaseAddr + 0x1F95CC);
		constexpr uint32 size = 6;
		/*
		dmc3.exe+1F95CC - 8B 0D 0E98A900 - MOV ECX,[7FF6784E2DE0]
		dmc3.exe+1F95D2
		*/

		constexpr byte8 sect0[] =
		{
			0x8B, 0x8B, 0x00, 0x00, 0x00, 0x00, // mov ecx,[rbx+0000B8C0]
		};
		static_assert(sizeof(sect0) == size);

		if (!run)
		{
			backupHelper.Save(addr, size);
		}

		if (enable)
		{
			protectionHelper.Push(addr, size);
			CopyMemory(addr, sect0, sizeof(sect0));
			*reinterpret_cast<uint32 *>(addr + 2) = __builtin_offsetof(ActorData, newEffectIndices[8]) ;
			protectionHelper.Pop();
		}
		else
		{
			backupHelper.Restore(addr);
		}
	}
	{
		auto addr = (appBaseAddr + 0x1F95F6);
		constexpr uint32 size = 6;
		/*
		dmc3.exe+1F95F6 - 89 0D E497A900 - MOV [7FF6784E2DE0],ECX
		dmc3.exe+1F95FC
		*/

		constexpr byte8 sect0[] =
		{
			0x89, 0x8B, 0x00, 0x00, 0x00, 0x00, // mov [rbx+0000B8C0],ecx
		};
		static_assert(sizeof(sect0) == size);

		if (!run)
		{
			backupHelper.Save(addr, size);
		}

		if (enable)
		{
			protectionHelper.Push(addr, size);
			CopyMemory(addr, sect0, sizeof(sect0));
			*reinterpret_cast<uint32 *>(addr + 2) = __builtin_offsetof(ActorData, newEffectIndices[8]) ;
			protectionHelper.Pop();
		}
		else
		{
			backupHelper.Restore(addr);
		}
	}
	{
		auto addr = (appBaseAddr + 0x1FDEF8);
		constexpr uint32 size = 7;
		/*
		dmc3.exe+1FDEF8 - 83 0D E54EA900 60 - OR DWORD PTR [7FF6784E2DE4],60
		dmc3.exe+1FDEFF
		*/

		constexpr byte8 sect0[] =
		{
			0x83, 0x8B, 0x00, 0x00, 0x00, 0x00, 0x60, // or dword ptr [rbx+0000B8C0],60
		};
		static_assert(sizeof(sect0) == size);

		if (!run)
		{
			backupHelper.Save(addr, size);
		}

		if (enable)
		{
			protectionHelper.Push(addr, size);
			CopyMemory(addr, sect0, sizeof(sect0));
			*reinterpret_cast<uint32 *>(addr + 2) = __builtin_offsetof(ActorData, newEffectIndices[9]) ;
			protectionHelper.Pop();
		}
		else
		{
			backupHelper.Restore(addr);
		}
	}
	{
		auto addr = (appBaseAddr + 0x21586A);
		constexpr uint32 size = 7;
		/*
		dmc3.exe+21586A - 83 0D 73D5A700 60 - OR DWORD PTR [7FF6784E2DE4],60
		dmc3.exe+215871
		*/

		constexpr byte8 sect0[] =
		{
			0x83, 0x8F, 0x00, 0x00, 0x00, 0x00, 0x60, // or dword ptr [rdi+0000B8C0],60
		};
		static_assert(sizeof(sect0) == size);

		if (!run)
		{
			backupHelper.Save(addr, size);
		}

		if (enable)
		{
			protectionHelper.Push(addr, size);
			CopyMemory(addr, sect0, sizeof(sect0));
			*reinterpret_cast<uint32 *>(addr + 2) = __builtin_offsetof(ActorData, newEffectIndices[9]) ;
			protectionHelper.Pop();
		}
		else
		{
			backupHelper.Restore(addr);
		}
	}
	{
		auto addr = (appBaseAddr + 0x215A7F);
		constexpr uint32 size = 7;
		/*
		dmc3.exe+215A7F - 83 0D 5ED3A700 60 - OR DWORD PTR [7FF6784E2DE4],60
		dmc3.exe+215A86
		*/

		constexpr byte8 sect0[] =
		{
			0x83, 0x8F, 0x00, 0x00, 0x00, 0x00, 0x60, // or dword ptr [rdi+0000B8C0],60
		};
		static_assert(sizeof(sect0) == size);

		if (!run)
		{
			backupHelper.Save(addr, size);
		}

		if (enable)
		{
			protectionHelper.Push(addr, size);
			CopyMemory(addr, sect0, sizeof(sect0));
			*reinterpret_cast<uint32 *>(addr + 2) = __builtin_offsetof(ActorData, newEffectIndices[9]) ;
			protectionHelper.Pop();
		}
		else
		{
			backupHelper.Restore(addr);
		}
	}
	{
		auto addr = (appBaseAddr + 0x1F95B0);
		constexpr uint32 size = 10;
		/*
		dmc3.exe+1F95B0 - 81 0D 3298A900 00060000 - OR [7FF6784E2DEC],00000600
		dmc3.exe+1F95BA
		*/

		constexpr byte8 sect0[] =
		{
			0x81, 0x8B, 0x00, 0x00, 0x00, 0x00, 0x00, 0x06, 0x00, 0x00, // or [rbx+0000B8C0],00000600
		};
		static_assert(sizeof(sect0) == size);

		if (!run)
		{
			backupHelper.Save(addr, size);
		}

		if (enable)
		{
			protectionHelper.Push(addr, size);
			CopyMemory(addr, sect0, sizeof(sect0));
			*reinterpret_cast<uint32 *>(addr + 2) = __builtin_offsetof(ActorData, newEffectIndices[11]) ;
			protectionHelper.Pop();
		}
		else
		{
			backupHelper.Restore(addr);
		}
	}
	{
		auto addr = (appBaseAddr + 0x219B4E);
		constexpr uint32 size = 10;
		/*
		dmc3.exe+219B4E - 81 0D 9492A700 00800000 - OR [7FF6784E2DEC],00008000
		dmc3.exe+219B58
		*/

		constexpr byte8 sect0[] =
		{
			0x81, 0x8B, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x00, 0x00, // or [rbx+0000B8C0],00008000
		};
		static_assert(sizeof(sect0) == size);

		if (!run)
		{
			backupHelper.Save(addr, size);
		}

		if (enable)
		{
			protectionHelper.Push(addr, size);
			CopyMemory(addr, sect0, sizeof(sect0));
			*reinterpret_cast<uint32 *>(addr + 2) = __builtin_offsetof(ActorData, newEffectIndices[11]) ;
			protectionHelper.Pop();
		}
		else
		{
			backupHelper.Restore(addr);
		}
	}
	{
		auto addr = (appBaseAddr + 0x219B95);
		constexpr uint32 size = 10;
		/*
		dmc3.exe+219B95 - 81 0D 4D92A700 00000100 - OR [7FF6784E2DEC],00010000
		dmc3.exe+219B9F
		*/

		constexpr byte8 sect0[] =
		{
			0x81, 0x8B, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, // or [rbx+0000B8C0],00010000
		};
		static_assert(sizeof(sect0) == size);

		if (!run)
		{
			backupHelper.Save(addr, size);
		}

		if (enable)
		{
			protectionHelper.Push(addr, size);
			CopyMemory(addr, sect0, sizeof(sect0));
			*reinterpret_cast<uint32 *>(addr + 2) = __builtin_offsetof(ActorData, newEffectIndices[11]) ;
			protectionHelper.Pop();
		}
		else
		{
			backupHelper.Restore(addr);
		}
	}
	{
		auto addr = (appBaseAddr + 0x219BD8);
		constexpr uint32 size = 10;
		/*
		dmc3.exe+219BD8 - 81 0D 0A92A700 00000200 - OR [7FF6784E2DEC],00020000
		dmc3.exe+219BE2
		*/

		constexpr byte8 sect0[] =
		{
			0x81, 0x8B, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x00, // or [rbx+0000B8C0],00020000
		};
		static_assert(sizeof(sect0) == size);

		if (!run)
		{
			backupHelper.Save(addr, size);
		}

		if (enable)
		{
			protectionHelper.Push(addr, size);
			CopyMemory(addr, sect0, sizeof(sect0));
			*reinterpret_cast<uint32 *>(addr + 2) = __builtin_offsetof(ActorData, newEffectIndices[11]) ;
			protectionHelper.Pop();
		}
		else
		{
			backupHelper.Restore(addr);
		}
	}
	{
		auto addr = (appBaseAddr + 0x21CD33);
		constexpr uint32 size = 10;
		/*
		dmc3.exe+21CD33 - 81 0D AF60A700 00000100 - OR [7FF6784E2DEC],00010000
		dmc3.exe+21CD3D
		*/

		constexpr byte8 sect0[] =
		{
			0x81, 0x8B, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, // or [rbx+0000B8C0],00010000
		};
		static_assert(sizeof(sect0) == size);

		if (!run)
		{
			backupHelper.Save(addr, size);
		}

		if (enable)
		{
			protectionHelper.Push(addr, size);
			CopyMemory(addr, sect0, sizeof(sect0));
			*reinterpret_cast<uint32 *>(addr + 2) = __builtin_offsetof(ActorData, newEffectIndices[11]) ;
			protectionHelper.Pop();
		}
		else
		{
			backupHelper.Restore(addr);
		}
	}
	{
		auto addr = (appBaseAddr + 0x21F3F1);
		constexpr uint32 size = 10;
		/*
		dmc3.exe+21F3F1 - 81 0D F139A700 00000200 - OR [7FF6784E2DEC],00020000
		dmc3.exe+21F3FB
		*/

		constexpr byte8 sect0[] =
		{
			0x81, 0x8B, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x00, // or [rbx+0000B8C0],00020000
		};
		static_assert(sizeof(sect0) == size);

		if (!run)
		{
			backupHelper.Save(addr, size);
		}

		if (enable)
		{
			protectionHelper.Push(addr, size);
			CopyMemory(addr, sect0, sizeof(sect0));
			*reinterpret_cast<uint32 *>(addr + 2) = __builtin_offsetof(ActorData, newEffectIndices[11]) ;
			protectionHelper.Pop();
		}
		else
		{
			backupHelper.Restore(addr);
		}
	}
	{
		auto addr = (appBaseAddr + 0x21FFA1);
		constexpr uint32 size = 7;
		/*
		dmc3.exe+21FFA1 - 83 0D 442EA700 20 - OR DWORD PTR [7FF6784E2DEC],20
		dmc3.exe+21FFA8
		*/

		constexpr byte8 sect0[] =
		{
			0x83, 0x8B, 0x00, 0x00, 0x00, 0x00, 0x20, // or dword ptr [rbx+0000B8C0],20
		};
		static_assert(sizeof(sect0) == size);

		if (!run)
		{
			backupHelper.Save(addr, size);
		}

		if (enable)
		{
			protectionHelper.Push(addr, size);
			CopyMemory(addr, sect0, sizeof(sect0));
			*reinterpret_cast<uint32 *>(addr + 2) = __builtin_offsetof(ActorData, newEffectIndices[11]) ;
			protectionHelper.Pop();
		}
		else
		{
			backupHelper.Restore(addr);
		}
	}
	{
		auto addr = (appBaseAddr + 0x2201EB);
		constexpr uint32 size = 10;
		/*
		dmc3.exe+2201EB - 81 0D F72BA700 00800000 - OR [7FF6784E2DEC],00008000
		dmc3.exe+2201F5
		*/

		constexpr byte8 sect0[] =
		{
			0x81, 0x8B, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x00, 0x00, // or [rbx+0000B8C0],00008000
		};
		static_assert(sizeof(sect0) == size);

		if (!run)
		{
			backupHelper.Save(addr, size);
		}

		if (enable)
		{
			protectionHelper.Push(addr, size);
			CopyMemory(addr, sect0, sizeof(sect0));
			*reinterpret_cast<uint32 *>(addr + 2) = __builtin_offsetof(ActorData, newEffectIndices[11]) ;
			protectionHelper.Pop();
		}
		else
		{
			backupHelper.Restore(addr);
		}
	}
	{
		auto addr = (appBaseAddr + 0x222BEF);
		constexpr uint32 size = 10;
		/*
		dmc3.exe+222BEF - 81 0D F301A700 00800000 - OR [7FF6784E2DEC],00008000
		dmc3.exe+222BF9
		*/

		constexpr byte8 sect0[] =
		{
			0x81, 0x8F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x00, 0x00, // or [rdi+0000B8C0],00008000
		};
		static_assert(sizeof(sect0) == size);

		if (!run)
		{
			backupHelper.Save(addr, size);
		}

		if (enable)
		{
			protectionHelper.Push(addr, size);
			CopyMemory(addr, sect0, sizeof(sect0));
			*reinterpret_cast<uint32 *>(addr + 2) = __builtin_offsetof(ActorData, newEffectIndices[11]) ;
			protectionHelper.Pop();
		}
		else
		{
			backupHelper.Restore(addr);
		}
	}
	{
		auto addr = (appBaseAddr + 0x222C8A);
		constexpr uint32 size = 10;
		/*
		dmc3.exe+222C8A - 81 0D 5801A700 00800000 - OR [7FF6784E2DEC],00008000
		dmc3.exe+222C94
		*/

		constexpr byte8 sect0[] =
		{
			0x81, 0x8F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x00, 0x00, // or [rdi+0000B8C0],00008000
		};
		static_assert(sizeof(sect0) == size);

		if (!run)
		{
			backupHelper.Save(addr, size);
		}

		if (enable)
		{
			protectionHelper.Push(addr, size);
			CopyMemory(addr, sect0, sizeof(sect0));
			*reinterpret_cast<uint32 *>(addr + 2) = __builtin_offsetof(ActorData, newEffectIndices[11]) ;
			protectionHelper.Pop();
		}
		else
		{
			backupHelper.Restore(addr);
		}
	}
	{
		auto addr = (appBaseAddr + 0x222D66);
		constexpr uint32 size = 10;
		/*
		dmc3.exe+222D66 - 81 0D 7C00A700 00000100 - OR [7FF6784E2DEC],00010000
		dmc3.exe+222D70
		*/

		constexpr byte8 sect0[] =
		{
			0x81, 0x8F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, // or [rdi+0000B8C0],00010000
		};
		static_assert(sizeof(sect0) == size);

		if (!run)
		{
			backupHelper.Save(addr, size);
		}

		if (enable)
		{
			protectionHelper.Push(addr, size);
			CopyMemory(addr, sect0, sizeof(sect0));
			*reinterpret_cast<uint32 *>(addr + 2) = __builtin_offsetof(ActorData, newEffectIndices[11]) ;
			protectionHelper.Pop();
		}
		else
		{
			backupHelper.Restore(addr);
		}
	}
	{
		auto addr = (appBaseAddr + 0x222E0E);
		constexpr uint32 size = 10;
		/*
		dmc3.exe+222E0E - 81 0D D4FFA600 00000100 - OR [7FF6784E2DEC],00010000
		dmc3.exe+222E18
		*/

		constexpr byte8 sect0[] =
		{
			0x81, 0x8F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, // or [rdi+0000B8C0],00010000
		};
		static_assert(sizeof(sect0) == size);

		if (!run)
		{
			backupHelper.Save(addr, size);
		}

		if (enable)
		{
			protectionHelper.Push(addr, size);
			CopyMemory(addr, sect0, sizeof(sect0));
			*reinterpret_cast<uint32 *>(addr + 2) = __builtin_offsetof(ActorData, newEffectIndices[11]) ;
			protectionHelper.Pop();
		}
		else
		{
			backupHelper.Restore(addr);
		}
	}
	{
		auto addr = (appBaseAddr + 0x222EB9);
		constexpr uint32 size = 10;
		/*
		dmc3.exe+222EB9 - 81 0D 29FFA600 00000200 - OR [7FF6784E2DEC],00020000
		dmc3.exe+222EC3
		*/

		constexpr byte8 sect0[] =
		{
			0x81, 0x8F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x00, // or [rdi+0000B8C0],00020000
		};
		static_assert(sizeof(sect0) == size);

		if (!run)
		{
			backupHelper.Save(addr, size);
		}

		if (enable)
		{
			protectionHelper.Push(addr, size);
			CopyMemory(addr, sect0, sizeof(sect0));
			*reinterpret_cast<uint32 *>(addr + 2) = __builtin_offsetof(ActorData, newEffectIndices[11]) ;
			protectionHelper.Pop();
		}
		else
		{
			backupHelper.Restore(addr);
		}
	}
	{
		auto addr = (appBaseAddr + 0x222F1A);
		constexpr uint32 size = 10;
		/*
		dmc3.exe+222F1A - 81 0D C8FEA600 00000200 - OR [7FF6784E2DEC],00020000
		dmc3.exe+222F24
		*/

		constexpr byte8 sect0[] =
		{
			0x81, 0x8F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x00, // or [rdi+0000B8C0],00020000
		};
		static_assert(sizeof(sect0) == size);

		if (!run)
		{
			backupHelper.Save(addr, size);
		}

		if (enable)
		{
			protectionHelper.Push(addr, size);
			CopyMemory(addr, sect0, sizeof(sect0));
			*reinterpret_cast<uint32 *>(addr + 2) = __builtin_offsetof(ActorData, newEffectIndices[11]) ;
			protectionHelper.Pop();
		}
		else
		{
			backupHelper.Restore(addr);
		}
	}
	{
		auto addr = (appBaseAddr + 0x222FDC);
		constexpr uint32 size = 10;
		/*
		dmc3.exe+222FDC - 81 0D 06FEA600 00000200 - OR [7FF6784E2DEC],00020000
		dmc3.exe+222FE6
		*/

		constexpr byte8 sect0[] =
		{
			0x81, 0x8F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x00, // or [rdi+0000B8C0],00020000
		};
		static_assert(sizeof(sect0) == size);

		if (!run)
		{
			backupHelper.Save(addr, size);
		}

		if (enable)
		{
			protectionHelper.Push(addr, size);
			CopyMemory(addr, sect0, sizeof(sect0));
			*reinterpret_cast<uint32 *>(addr + 2) = __builtin_offsetof(ActorData, newEffectIndices[11]) ;
			protectionHelper.Pop();
		}
		else
		{
			backupHelper.Restore(addr);
		}
	}
	{
		auto addr = (appBaseAddr + 0x22D175);
		constexpr uint32 size = 10;
		/*
		dmc3.exe+22D175 - 81 0D 6D5CA600 00000800 - OR [7FF6784E2DEC],00080000
		dmc3.exe+22D17F
		*/

		constexpr byte8 sect0[] =
		{
			0x81, 0x8F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x08, 0x00, // or [rdi+0000B8C0],00080000
		};
		static_assert(sizeof(sect0) == size);

		if (!run)
		{
			backupHelper.Save(addr, size);
		}

		if (enable)
		{
			protectionHelper.Push(addr, size);
			CopyMemory(addr, sect0, sizeof(sect0));
			*reinterpret_cast<uint32 *>(addr + 2) = __builtin_offsetof(ActorData, newEffectIndices[11]) ;
			protectionHelper.Pop();
		}
		else
		{
			backupHelper.Restore(addr);
		}
	}
	{
		auto addr = (appBaseAddr + 0x22D32B);
		constexpr uint32 size = 10;
		/*
		dmc3.exe+22D32B - 81 0D B75AA600 00000800 - OR [7FF6784E2DEC],00080000
		dmc3.exe+22D335
		*/

		constexpr byte8 sect0[] =
		{
			0x81, 0x8B, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x08, 0x00, // or [rbx+0000B8C0],00080000
		};
		static_assert(sizeof(sect0) == size);

		if (!run)
		{
			backupHelper.Save(addr, size);
		}

		if (enable)
		{
			protectionHelper.Push(addr, size);
			CopyMemory(addr, sect0, sizeof(sect0));
			*reinterpret_cast<uint32 *>(addr + 2) = __builtin_offsetof(ActorData, newEffectIndices[11]) ;
			protectionHelper.Pop();
		}
		else
		{
			backupHelper.Restore(addr);
		}
	}
	{
		auto addr = (appBaseAddr + 0x22D406);
		constexpr uint32 size = 10;
		/*
		dmc3.exe+22D406 - 81 0D DC59A600 00000800 - OR [7FF6784E2DEC],00080000
		dmc3.exe+22D410
		*/

		constexpr byte8 sect0[] =
		{
			0x81, 0x8B, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x08, 0x00, // or [rbx+0000B8C0],00080000
		};
		static_assert(sizeof(sect0) == size);

		if (!run)
		{
			backupHelper.Save(addr, size);
		}

		if (enable)
		{
			protectionHelper.Push(addr, size);
			CopyMemory(addr, sect0, sizeof(sect0));
			*reinterpret_cast<uint32 *>(addr + 2) = __builtin_offsetof(ActorData, newEffectIndices[11]) ;
			protectionHelper.Pop();
		}
		else
		{
			backupHelper.Restore(addr);
		}
	}

	run = true;
}

#pragma endregion

#pragma region Mobility

bool MobilityFunction
(
	ActorData & actorData,
	uint8 & var,
	uint8(&array)[2]
)
{
	uint8 index = (actorData.devil) ? 1 : 0;

	if (var >= array[index])
	{
		return false;
	}

	var++;

	return true;
}

bool AirHike(ActorData & actorData)
{
	if (actorData.character != CHAR_DANTE)
	{
		return false;
	}

	return MobilityFunction
	(
		actorData,
		actorData.newAirHikeCount,
		activeConfig.airHikeCount
	);
}

bool KickJump(ActorData & actorData)
{
	return MobilityFunction
	(
		actorData,
		actorData.newKickJumpCount,
		activeConfig.kickJumpCount
	);
}

bool WallHike(ActorData & actorData)
{
	return MobilityFunction
	(
		actorData,
		actorData.newWallHikeCount,
		activeConfig.wallHikeCount
	);
}

template <uint32 event>
uint32 MobilityFunction
(
	ActorData & actorData,
	uint8 action,
	uint8 & var,
	uint8(&array)[2]
)
{
	uint8 index = (actorData.devil) ? 1 : 0;

	// Required, because there is no reset when hitting the floor.
	if constexpr (event != ACTOR_EVENT_DANTE_DASH)
	{
		if (actorData.state & STATE_ON_FLOOR)
		{
			var = 0;
		}
	}

	if (var >= array[index])
	{
		return 0;
	}

	var++;

	actorData.lastAction = actorData.action;
	actorData.action = action;

	return event;
}

auto Dash
(
	ActorData & actorData,
	uint8 action
)
{
	return MobilityFunction<ACTOR_EVENT_DANTE_DASH>
	(
		actorData,
		action,
		actorData.newDashCount,
		activeConfig.dashCount
	);
}

auto SkyStar
(
	ActorData & actorData,
	uint8 action
)
{
	return MobilityFunction<ACTOR_EVENT_DANTE_SKY_STAR>
	(
		actorData,
		action,
		actorData.newSkyStarCount,
		activeConfig.skyStarCount
	);
}

auto AirTrickDante
(
	ActorData & actorData,
	uint8 action
)
{
	actorData.var_3E10[26] = (actorData.state & STATE_ON_FLOOR) ? 1 : 0;

	return MobilityFunction<ACTOR_EVENT_DANTE_AIR_TRICK>
	(
		actorData,
		action,
		actorData.newAirTrickCount,
		activeConfig.airTrickCountDante
	);
}

auto AirTrickVergil
(
	ActorData & actorData,
	uint8 action
)
{
	return MobilityFunction<ACTOR_EVENT_VERGIL_AIR_TRICK>
	(
		actorData,
		action,
		actorData.newAirTrickCount,
		activeConfig.airTrickCountVergil
	);
}

auto TrickUp
(
	ActorData & actorData,
	uint8 action
)
{
	return MobilityFunction<ACTOR_EVENT_VERGIL_TRICK_UP>
	(
		actorData,
		action,
		actorData.newTrickUpCount,
		activeConfig.trickUpCount
	);
}

auto TrickDown
(
	ActorData & actorData,
	uint8 action
)
{
	return MobilityFunction<ACTOR_EVENT_VERGIL_TRICK_DOWN>
	(
		actorData,
		action,
		actorData.newTrickDownCount,
		activeConfig.trickDownCount
	);
}

void ResetDash(ActorData & actorData)
{
	if constexpr (false )
	{
		LogFunctionHelper(__FUNCTION__, actorData.operator byte8 *()) ;
	}

	actorData.newDashCount = 0;
}

void ResetSkyStar(ActorData & actorData)
{
	if constexpr (false )
	{
		LogFunctionHelper(__FUNCTION__, actorData.operator byte8 *()) ;
	}

	actorData.newAirHikeCount    = 0;
	actorData.newKickJumpCount   = 0;
	actorData.newWallHikeCount   = 0;
	actorData.newDashCount       = 0;
	actorData.newSkyStarCount    = 0;
	actorData.newAirTrickCount   = 0;
	actorData.newTrickUpCount    = 0;
	actorData.newTrickDownCount  = 0;
	actorData.newAirStingerCount = 0;

	if (actorData.state & STATE_ON_FLOOR)
	{
		switch (actorData.character)
		{
			case CHAR_DANTE:
			{
				switch (actorData.eventData[0].event)
				{
					case ACTOR_EVENT_DANTE_AIR_TRICK:
					{
						actorData.newAirTrickCount = 1;

						break;
					}
				}

				break;
			}
			case CHAR_VERGIL:
			{
				switch (actorData.eventData[0].event)
				{
					case ACTOR_EVENT_VERGIL_AIR_TRICK:
					{
						actorData.newAirTrickCount = 1;

						break;
					}
					case ACTOR_EVENT_VERGIL_TRICK_UP:
					{
						actorData.newTrickUpCount = 1;

						break;
					}
					case ACTOR_EVENT_VERGIL_TRICK_DOWN:
					{
						actorData.newTrickDownCount = 1;

						break;
					}
				}

				break;
			}
		}
	}
}

void ToggleMobility(bool enable)
{
	LogFunctionHelper(__FUNCTION__) ;

	static bool run = false;

	// Air Hike
	{
		WriteAddress((appBaseAddr + 0x1E9AB0), (enable) ? (appBaseAddr + 0x1E9AB6) : (appBaseAddr + 0x1E9B3A), 6);
		/*
		dmc3.exe+1E9AB0 - 0F8E 84000000  - jng dmc3.exe+1E9B3A
		dmc3.exe+1E9AB6 - 48 89 7C 24 30 - mov [rsp+30],rdi
		*/
	}
	{
		auto addr     = (appBaseAddr + 0x1E9B4E);
		auto jumpAddr = (appBaseAddr + 0x1E9B53);
		/*
		dmc3.exe+1E9B4E - BA 02000000 - mov edx,00000002
		dmc3.exe+1E9B53 - 48 8B CB    - mov rcx,rbx
		*/

		static Function func = {};

		constexpr byte8 sect1[] =
		{
			0x48, 0x8B, 0xCB ,
		};
		constexpr byte8 sect2[] =
		{
			0x84, 0xC0,                         // test al,al
			0x0F, 0x84, 0x00, 0x00, 0x00, 0x00, // je dmc3.exe+1E9B3A
		};
		constexpr uint32 size0 = 5;
		constexpr uint32 size1 = sizeof(sect1);
		constexpr uint32 size2 = sizeof(sect2);

		if (!run)
		{
			func = CreateFunction(AirHike, jumpAddr, true, false, size0, size1, size2);
			CopyMemory(func.sect0, addr, size0, MemoryFlags_VirtualProtectSource);
			CopyMemory(func.sect1, sect1, size1);
			CopyMemory(func.sect2, sect2, size2);
			WriteAddress((func.sect2 + 2), (appBaseAddr + 0x1E9B3A), 6);
			backupHelper.Save(addr, size0);
		}

		if (enable)
		{
			WriteJump(addr, func.addr, (size0 - 5));
		}
		else
		{
			backupHelper.Restore(addr);
		}
	}

	// Kick Jump
	{
		WriteAddress((appBaseAddr + 0x1EA231), (enable) ? (appBaseAddr + 0x1EA233) : (appBaseAddr + 0x1EA222), 2);
		/*
		dmc3.exe+1EA231 - 7E EF          - jle dmc3.exe+1EA222
		dmc3.exe+1EA233 - 48 89 7C 24 48 - mov [rsp+48],rdi
		*/
	}
	{
		auto addr     = (appBaseAddr + 0x1EA384);
		auto jumpAddr = (appBaseAddr + 0x1EA389);
		/*
		dmc3.exe+1EA384 - BA 03000000       - mov edx,00000003
		dmc3.exe+1EA389 - C6 83 093F0000 04 - mov byte ptr [rbx+00003F09],04
		*/

		static Function func = {};

		constexpr byte8 sect1[] =
		{
			0x48, 0x8B, 0xCB ,
		};
		constexpr byte8 sect2[] =
		{
			0x84, 0xC0,                         // test al,al
			0x0F, 0x84, 0x00, 0x00, 0x00, 0x00, // je dmc3.exe+1EA3DF
		};
		constexpr uint32 size0 = 5;
		constexpr uint32 size1 = sizeof(sect1);
		constexpr uint32 size2 = sizeof(sect2);

		if (!run)
		{
			func = CreateFunction(KickJump, jumpAddr, true, false, size0, size1, size2);
			CopyMemory(func.sect0, addr, size0, MemoryFlags_VirtualProtectSource);
			CopyMemory(func.sect1, sect1, size1);
			CopyMemory(func.sect2, sect2, size2);
			WriteAddress((func.sect2 + 2), (appBaseAddr + 0x1EA3DF), 6);
			backupHelper.Save(addr, size0);
		}

		if (enable)
		{
			WriteJump(addr, func.addr, (size0 - 5));
		}
		else
		{
			backupHelper.Restore(addr);
		}
	}

	// Wall Hike
	{
		WriteAddress((appBaseAddr + 0x1E6084), (enable) ? (appBaseAddr + 0x1E608A) : (appBaseAddr + 0x1E62B5), 6);
		/*
		dmc3.exe+1E6084 - 0F8E 2B020000     - jng dmc3.exe+1E62B5
		dmc3.exe+1E608A - 48 8B 83 E83D0000 - mov rax,[rbx+00003DE8]
		*/
	}
	{
		auto addr     = (appBaseAddr + 0x1E6549);
		auto jumpAddr = (appBaseAddr + 0x1E654E);
		/*
		dmc3.exe+1E6549 - E8 F2A1FFFF - call dmc3.exe+1E0740
		dmc3.exe+1E654E - B0 01       - mov al,01
		*/

		static Function func = {};

		constexpr byte8 sect2[] =
		{
			0x84, 0xC0,                         // test al,al
			0x0F, 0x84, 0x00, 0x00, 0x00, 0x00, // je dmc3.exe+1E64A9
			0xE8, 0x00, 0x00, 0x00, 0x00,       // call dmc3.exe+1E0740
		};
		constexpr uint32 size0 = 5;
		constexpr uint32 size2 = sizeof(sect2);

		if (!run)
		{
			func = CreateFunction(WallHike, jumpAddr, true, false, 0, 0, size2);
			CopyMemory(func.sect2, sect2, size2);
			WriteAddress((func.sect2 + 2), (appBaseAddr + 0x1E64A9), 6);
			WriteCall((func.sect2 + 8), (appBaseAddr + 0x1E0740));
			backupHelper.Save(addr, size0);
		}

		if (enable)
		{
			WriteJump(addr, func.addr);
		}
		else
		{
			backupHelper.Restore(addr);
		}
	}

	auto CreateMobilityFunction = [](void * funcAddr)
	{
		auto jumpAddr = (appBaseAddr + 0x1E666D);

		constexpr byte8 sect1[] =
		{
			0x48, 0x8B, 0xCB, // mov rcx,rbx
			0x8A, 0x57, 0x08, // mov dl,[rdi+08]
		};
		constexpr byte8 sect2[] =
		{
			0x85, 0xC0,                         // test eax,eax
			0x0F, 0x84, 0x00, 0x00, 0x00, 0x00, // je dmc3.exe+1E64A9
			0x8B, 0xD0,                         // mov edx,eax
		};
		constexpr uint32 size1 = sizeof(sect1);
		constexpr uint32 size2 = sizeof(sect2);
		auto func = CreateFunction(funcAddr, jumpAddr, true, false, 0, size1, size2);
		CopyMemory(func.sect1, sect1, size1);
		CopyMemory(func.sect2, sect2, size2);
		WriteAddress((func.sect2 + 2), (appBaseAddr + 0x1E64A9), 6);

		return func;
	};

	// Dash
	{
		auto addr = (appBaseAddr + 0x1E66CB);
		/*
		dmc3.exe+1E66CB - 8B 8B 58630000 - mov ecx,[rbx+00006358]
		dmc3.exe+1E66D1 - 85 C9          - test ecx,ecx
		*/

		static Function func = {};

		constexpr uint32 size0 = 6;

		if (!run)
		{
			func = CreateMobilityFunction(Dash);
			backupHelper.Save(addr, size0);
		}

		if (enable)
		{
			WriteJump(addr, func.addr, (size0 - 5));
		}
		else
		{
			backupHelper.Restore(addr);
		}
	}

	// Sky Star
	{
		auto addr = (appBaseAddr + 0x1E6689);
		/*
		dmc3.exe+1E6689 - 83 BB 58630000 01 - cmp dword ptr [rbx+00006358],01
		dmc3.exe+1E6690 - 0F8C 13FEFFFF     - jl dmc3.exe+1E64A9
		*/

		static Function func = {};

		constexpr uint32 size0 = 7;

		if (!run)
		{
			func = CreateMobilityFunction(SkyStar);
			backupHelper.Save(addr, size0);
		}

		if (enable)
		{
			WriteJump(addr, func.addr, (size0 - 5));
		}
		else
		{
			backupHelper.Restore(addr);
		}
	}

	// Air Trick Dante
	{
		auto addr = (appBaseAddr + 0x1E6612);
		/*
		dmc3.exe+1E6612 - 83 BB 58630000 02 - cmp dword ptr [rbx+00006358],02
		dmc3.exe+1E6619 - 0F85 8AFEFFFF     - jne dmc3.exe+1E64A9
		*/

		static Function func = {};

		constexpr uint32 size0 = 7;

		if (!run)
		{
			func = CreateMobilityFunction(AirTrickDante);
			backupHelper.Save(addr, size0);
		}

		if (enable)
		{
			WriteJump(addr, func.addr, (size0 - 5));
		}
		else
		{
			backupHelper.Restore(addr);
		}
	}

	// Air Trick Vergil
	{
		auto addr = (appBaseAddr + 0x1E6842);
		/*
		dmc3.exe+1E6842 - 8B 83 643E0000 - mov eax,[rbx+00003E64]
		dmc3.exe+1E6848 - A8 01          - test al,01
		*/

		static Function func = {};

		constexpr uint32 size0 = 6;

		if (!run)
		{
			func = CreateMobilityFunction(AirTrickVergil);
			backupHelper.Save(addr, size0);
		}

		if (enable)
		{
			WriteJump(addr, func.addr, (size0 - 5));
		}
		else
		{
			backupHelper.Restore(addr);
		}
	}

	// Trick Up
	{
		auto addr = (appBaseAddr + 0x1E67D5);
		/*
		dmc3.exe+1E67D5 - 83 BB 58630000 01 - cmp dword ptr [rbx+00006358],01
		dmc3.exe+1E67DC - 0F8C C7FCFFFF     - jl dmc3.exe+1E64A9
		*/

		static Function func = {};

		constexpr uint32 size0 = 7;

		if (!run)
		{
			func = CreateMobilityFunction(TrickUp);
			backupHelper.Save(addr, size0);
		}

		if (enable)
		{
			WriteJump(addr, func.addr, (size0 - 5));
		}
		else
		{
			backupHelper.Restore(addr);
		}
	}

	// Trick Down
	{
		auto addr = (appBaseAddr + 0x1E6768);
		/*
		dmc3.exe+1E6768 - 83 BB 58630000 02 - cmp dword ptr [rbx+00006358],02
		dmc3.exe+1E676F - 0F85 34FDFFFF     - jne dmc3.exe+1E64A9
		*/

		static Function func = {};

		constexpr uint32 size0 = 7;

		if (!run)
		{
			func = CreateMobilityFunction(TrickDown);
			backupHelper.Save(addr, size0);
		}

		if (enable)
		{
			WriteJump(addr, func.addr, (size0 - 5));
		}
		else
		{
			backupHelper.Restore(addr);
		}
	}

	// Reset Dash
	{
		auto addr     = (appBaseAddr + 0x1E0AFE);
		auto jumpAddr = (appBaseAddr + 0x1E0B05);
		/*
		dmc3.exe+1E0AFE - 40 88 BB 5C630000 - mov [rbx+0000635C],dil
		dmc3.exe+1E0B05 - 8B 83 003E0000    - mov eax,[rbx+00003E00]
		*/

		static Function func = {};

		constexpr byte8 sect1[] =
		{
			0x48, 0x8B, 0xCB ,
		};
		constexpr uint32 size0 = 7;
		constexpr uint32 size1 = sizeof(sect1);

		if (!run)
		{
			func = CreateFunction(ResetDash, jumpAddr, true, true, size0, size1);
			CopyMemory(func.sect0, addr, size0, MemoryFlags_VirtualProtectSource);
			CopyMemory(func.sect1, sect1, size1);
			backupHelper.Save(addr, size0);
		}

		if (enable)
		{
			WriteJump(addr, func.addr, (size0 - 5));
		}
		else
		{
			backupHelper.Restore(addr);
		}
	}
	{
		auto addr     = (appBaseAddr + 0x1F8059);
		auto jumpAddr = (appBaseAddr + 0x1F8060);
		/*
		dmc3.exe+1F8059 - 40 88 BB 5C630000 - mov [rbx+0000635C],dil
		dmc3.exe+1F8060 - C6 83 153F0000 04 - mov byte ptr [rbx+00003F15],04
		*/

		static Function func = {};

		constexpr byte8 sect1[] =
		{
			0x48, 0x8B, 0xCB ,
		};
		constexpr uint32 size0 = 7;
		constexpr uint32 size1 = sizeof(sect1);

		if (!run)
		{
			func = CreateFunction(ResetDash, jumpAddr, true, true, size0, size1);
			CopyMemory(func.sect0, addr, size0, MemoryFlags_VirtualProtectSource);
			CopyMemory(func.sect1, sect1, size1);
			backupHelper.Save(addr, size0);
		}

		if (enable)
		{
			WriteJump(addr, func.addr, (size0 - 5));
		}
		else
		{
			backupHelper.Restore(addr);
		}
	}
	{
		auto addr     = (appBaseAddr + 0x1F8383);
		auto jumpAddr = (appBaseAddr + 0x1F838A);
		/*
		dmc3.exe+1F8383 - 40 88 BB 5C630000 - mov [rbx+0000635C],dil
		dmc3.exe+1F838A - 48 89 BB C43E0000 - mov [rbx+00003EC4],rdi
		*/

		static Function func = {};

		constexpr byte8 sect1[] =
		{
			0x48, 0x8B, 0xCB ,
		};
		constexpr uint32 size0 = 7;
		constexpr uint32 size1 = sizeof(sect1);

		if (!run)
		{
			func = CreateFunction(ResetDash, jumpAddr, true, true, size0, size1);
			CopyMemory(func.sect0, addr, size0, MemoryFlags_VirtualProtectSource);
			CopyMemory(func.sect1, sect1, size1);
			backupHelper.Save(addr, size0);
		}

		if (enable)
		{
			WriteJump(addr, func.addr, (size0 - 5));
		}
		else
		{
			backupHelper.Restore(addr);
		}
	}

	// Reset Sky Star
	{
		auto addr     = (appBaseAddr + 0x1DFEAE);
		auto jumpAddr = (appBaseAddr + 0x1DFEB4);
		/*
		dmc3.exe+1DFEAE - 88 8B 5D630000 - mov [rbx+0000635D],cl
		dmc3.exe+1DFEB4 - 89 AB 74630000 - mov [rbx+00006374],ebp
		*/

		static Function func = {};

		constexpr byte8 sect1[] =
		{
			0x48, 0x8B, 0xCB ,
		};
		constexpr uint32 size0 = 6;
		constexpr uint32 size1 = sizeof(sect1);

		if (!run)
		{
			func = CreateFunction(ResetSkyStar, jumpAddr, true, true, size0, size1);
			CopyMemory(func.sect0, addr, size0, MemoryFlags_VirtualProtectSource);
			CopyMemory(func.sect1, sect1, size1);
			backupHelper.Save(addr, size0);
		}

		if (enable)
		{
			WriteJump(addr, func.addr, (size0 - 5));
		}
		else
		{
			backupHelper.Restore(addr);
		}
	}
	{
		auto addr     = (appBaseAddr + 0x1DFFB6);
		auto jumpAddr = (appBaseAddr + 0x1DFFBC);
		/*
		dmc3.exe+1DFFB6 - 88 8B 5D630000    - mov [rbx+0000635D],cl
		dmc3.exe+1DFFBC - 40 88 AB AE3F0000 - mov [rbx+00003FAE],bpl
		*/

		static Function func = {};

		constexpr byte8 sect1[] =
		{
			0x48, 0x8B, 0xCB ,
		};
		constexpr uint32 size0 = 6;
		constexpr uint32 size1 = sizeof(sect1);

		if (!run)
		{
			func = CreateFunction(ResetSkyStar, jumpAddr, true, true, size0, size1);
			CopyMemory(func.sect0, addr, size0, MemoryFlags_VirtualProtectSource);
			CopyMemory(func.sect1, sect1, size1);
			backupHelper.Save(addr, size0);
		}

		if (enable)
		{
			WriteJump(addr, func.addr, (size0 - 5));
		}
		else
		{
			backupHelper.Restore(addr);
		}
	}
	{
		auto addr     = (appBaseAddr + 0x1E07A2);
		auto jumpAddr = (appBaseAddr + 0x1E07A9);
		/*
		dmc3.exe+1E07A2 - 41 88 89 5D630000 - mov [r9+0000635D],cl
		dmc3.exe+1E07A9 - EB 06             - jmp dmc3.exe+1E07B1
		*/

		static Function func = {};

		constexpr byte8 sect1[] =
		{
			0x49, 0x8B, 0xC9 ,
		};
		constexpr uint32 size0 = 7;
		constexpr uint32 size1 = sizeof(sect1);

		if (!run)
		{
			func = CreateFunction(ResetSkyStar, jumpAddr, true, true, size0, size1);
			CopyMemory(func.sect0, addr, size0, MemoryFlags_VirtualProtectSource);
			CopyMemory(func.sect1, sect1, size1);
			backupHelper.Save(addr, size0);
		}

		if (enable)
		{
			WriteJump(addr, func.addr, (size0 - 5));
		}
		else
		{
			backupHelper.Restore(addr);
		}
	}
	{
		auto addr     = (appBaseAddr + 0x1E0D81);
		auto jumpAddr = (appBaseAddr + 0x1E0D87);
		/*
		dmc3.exe+1E0D81 - 88 8B 5D630000 - mov [rbx+0000635D],cl
		dmc3.exe+1E0D87 - 39 7B 78       - cmp [rbx+78],edi
		*/

		static Function func = {};

		constexpr byte8 sect1[] =
		{
			0x48, 0x8B, 0xCB ,
		};
		constexpr uint32 size0 = 6;
		constexpr uint32 size1 = sizeof(sect1);

		if (!run)
		{
			func = CreateFunction(ResetSkyStar, jumpAddr, true, true, size0, size1);
			CopyMemory(func.sect0, addr, size0, MemoryFlags_VirtualProtectSource);
			CopyMemory(func.sect1, sect1, size1);
			backupHelper.Save(addr, size0);
		}

		if (enable)
		{
			WriteJump(addr, func.addr, (size0 - 5));
		}
		else
		{
			backupHelper.Restore(addr);
		}
	}
	{
		auto addr     = (appBaseAddr + 0x1E0F64);
		auto jumpAddr = (appBaseAddr + 0x1E0F6B);
		/*
		dmc3.exe+1E0F64 - 41 88 88 5D630000 - mov [r8+0000635D],cl
		dmc3.exe+1E0F6B - EB 5E             - jmp dmc3.exe+1E0FCB
		*/

		static Function func = {};

		constexpr byte8 sect1[] =
		{
			0x49, 0x8B, 0xC8 ,
		};
		constexpr uint32 size0 = 7;
		constexpr uint32 size1 = sizeof(sect1);

		if (!run)
		{
			func = CreateFunction(ResetSkyStar, jumpAddr, true, true, size0, size1);
			CopyMemory(func.sect0, addr, size0, MemoryFlags_VirtualProtectSource);
			CopyMemory(func.sect1, sect1, size1);
			backupHelper.Save(addr, size0);
		}

		if (enable)
		{
			WriteJump(addr, func.addr, (size0 - 5));
		}
		else
		{
			backupHelper.Restore(addr);
		}
	}
	{
		auto addr     = (appBaseAddr + 0x1E0FBD);
		auto jumpAddr = (appBaseAddr + 0x1E0FC4);
		/*
		dmc3.exe+1E0FBD - 41 88 88 5D630000 - mov [r8+0000635D],cl
		dmc3.exe+1E0FC4 - 41 FE 88 133F0000 - dec [r8+00003F13]
		*/

		static Function func = {};

		constexpr byte8 sect1[] =
		{
			0x49, 0x8B, 0xC8 ,
		};
		constexpr uint32 size0 = 7;
		constexpr uint32 size1 = sizeof(sect1);

		if (!run)
		{
			func = CreateFunction(ResetSkyStar, jumpAddr, true, true, size0, size1);
			CopyMemory(func.sect0, addr, size0, MemoryFlags_VirtualProtectSource);
			CopyMemory(func.sect1, sect1, size1);
			backupHelper.Save(addr, size0);
		}

		if (enable)
		{
			WriteJump(addr, func.addr, (size0 - 5));
		}
		else
		{
			backupHelper.Restore(addr);
		}
	}
	{
		auto addr     = (appBaseAddr + 0x1E16D2);
		auto jumpAddr = (appBaseAddr + 0x1E16D8);
		/*
		dmc3.exe+1E16D2 - 88 8B 5D630000 - mov [rbx+0000635D],cl
		dmc3.exe+1E16D8 - 39 7B 78       - cmp [rbx+78],edi
		*/

		static Function func = {};

		constexpr byte8 sect1[] =
		{
			0x48, 0x8B, 0xCB ,
		};
		constexpr uint32 size0 = 6;
		constexpr uint32 size1 = sizeof(sect1);

		if (!run)
		{
			func = CreateFunction(ResetSkyStar, jumpAddr, true, true, size0, size1);
			CopyMemory(func.sect0, addr, size0, MemoryFlags_VirtualProtectSource);
			CopyMemory(func.sect1, sect1, size1);
			backupHelper.Save(addr, size0);
		}

		if (enable)
		{
			WriteJump(addr, func.addr, (size0 - 5));
		}
		else
		{
			backupHelper.Restore(addr);
		}
	}

	run = true;
}







void PlayQuicksilverMotion
(
	byte8 * actorBaseAddr,
	uint32 archiveIndex,
	uint32 fileIndex
)
{
	if (!actorBaseAddr)
	{
		return;
	}
	auto & actorData = *reinterpret_cast<ActorData *>(actorBaseAddr);

	auto PlayMotion = [&]()
	{
		func_1EFB90
		(
			actorBaseAddr,
			archiveIndex,
			fileIndex,
			-1.0f,
			-1,
			2,
			5
		);
	};

	if (actorData.character == CHAR_VERGIL)
	{
		auto & motionArchive = actorData.motionArchives[3];
		auto lastMotionArchive = motionArchive;

		motionArchive = File_staticFiles[pl000_00_25];

		PlayMotion();

		motionArchive = lastMotionArchive;
	}
	else
	{
		PlayMotion();
	}
}








































#pragma endregion

#pragma region Magic Points Depletion Values

float32 * magicPointsDepletionValueQuicksilverDest  = 0;
float32 * magicPointsDepletionValueDoppelgangerDest = 0;
float32 * magicPointsDepletionValueDevilDest        = 0;

void InitMagicPointsDepletionValues()
{
	LogFunctionHelper(__FUNCTION__) ;

	auto dest = HighAlloc(12);
	if (!dest)
	{
		Log("HighAlloc failed.");

		return;
	}

	magicPointsDepletionValueQuicksilverDest  = reinterpret_cast<float32 *>(dest + 0);
	magicPointsDepletionValueDoppelgangerDest = reinterpret_cast<float32 *>(dest + 4);
	magicPointsDepletionValueDevilDest        = reinterpret_cast<float32 *>(dest + 8);

	// Quicksilver
	{
		auto dest = (appBaseAddr + 0x1F8A40);

		constexpr byte8 buffer[] =
		{
			0xF3, 0x0F, 0x59, 0x0D, 0x00, 0x00, 0x00, 0x00, // mulss xmm1,[]
		};
		CopyMemory(dest, buffer, sizeof(buffer), MemoryFlags_VirtualProtectDestination);

		WriteAddress(dest, magicPointsDepletionValueQuicksilverDest, 8);
		/*
		dmc3.exe+1F8A40 - F3 0F59 88 70010000 - mulss xmm1,[rax+00000170]
		dmc3.exe+1F8A48 - E8 238DFEFF         - call dmc3.exe+1E1770
		*/
	}

	// Doppelganger
	{
		auto dest = (appBaseAddr + 0x1F89D1);

		constexpr byte8 buffer[] =
		{
			0xF3, 0x0F, 0x59, 0x0D, 0x00, 0x00, 0x00, 0x00, // mulss xmm1,[]
		};
		CopyMemory(dest, buffer, sizeof(buffer), MemoryFlags_VirtualProtectDestination);

		WriteAddress(dest, magicPointsDepletionValueDoppelgangerDest, 8);
		/*
		dmc3.exe+1F89D1 - F3 0F59 88 74010000 - mulss xmm1,[rax+00000174]
		dmc3.exe+1F89D9 - E8 928DFEFF         - call dmc3.exe+1E1770
		*/
	}

	// Devil
	{
		auto dest = (appBaseAddr + 0x1F8B49);

		constexpr byte8 buffer[] =
		{
			0xF3, 0x0F, 0x59, 0x0D, 0x00, 0x00, 0x00, 0x00, // mulss xmm1,[]
		};
		CopyMemory(dest, buffer, sizeof(buffer), MemoryFlags_VirtualProtectDestination);

		WriteAddress(dest, magicPointsDepletionValueDevilDest, 8);
		/*
		dmc3.exe+1F8B49 - F3 0F59 88 78010000 - mulss xmm1,[rax+00000178]
		dmc3.exe+1F8B51 - E8 1A8CFEFF         - call dmc3.exe+1E1770
		*/
	}
}

export void UpdateMagicPointsDepletionValues()
{
	LogFunctionHelper(__FUNCTION__) ;

	*magicPointsDepletionValueQuicksilverDest  = activeConfig.MagicPointsDepletionValues.quicksilver;
	*magicPointsDepletionValueDoppelgangerDest = activeConfig.MagicPointsDepletionValues.doppelganger;
	*magicPointsDepletionValueDevilDest        = activeConfig.MagicPointsDepletionValues.devil;
}

#pragma endregion

#pragma region Color

// @Todo: Rename to SetXColor.

void SetColorAirHike
(
	ActorDataDante & actorData,
	byte8 * dest
)
{
	uint8 meleeWeaponIndex = static_cast<uint8>(actorData.meleeWeaponIndex);
	if (meleeWeaponIndex >= MELEE_WEAPON_COUNT_DANTE)
	{
		meleeWeaponIndex = 0;
	}

	memcpy(dest, activeConfig.Color.airHike[meleeWeaponIndex], 4);
}

void SetColorAura
(
	ActorData & actorData,
	byte8 * dest
)
{
	uint8 character = static_cast<uint8>(actorData.character);

	switch (character)
	{
		case CHAR_DANTE:
		{
			auto & actorData2 = *reinterpret_cast<ActorDataDante *>(&actorData);

			if (actorData2.sparda)
			{
				memcpy(dest, activeConfig.Color.Aura.sparda, 4);
			}
			else
			{
				uint8 meleeWeaponIndex = static_cast<uint8>(actorData2.meleeWeaponIndex);
				if (meleeWeaponIndex >= MELEE_WEAPON_COUNT_DANTE)
				{
					meleeWeaponIndex = 0;
				}

				memcpy(dest, activeConfig.Color.Aura.dante[meleeWeaponIndex], 4);
			}
			break;
		}
		case CHAR_VERGIL:
		{
			auto & actorData2 = *reinterpret_cast<ActorDataVergil *>(&actorData);

			if (actorData2.neroAngelo)
			{
				memcpy(dest, activeConfig.Color.Aura.neroAngelo, 4);
			}
			else
			{
				uint8 activeMeleeWeaponIndex = static_cast<uint8>(actorData2.activeMeleeWeaponIndex);
				if (activeMeleeWeaponIndex >= MELEE_WEAPON_COUNT_VERGIL)
				{
					activeMeleeWeaponIndex = 0;
				}

				memcpy(dest, activeConfig.Color.Aura.vergil[activeMeleeWeaponIndex], 4);
			}
			break;
		}
	}
}

// @Todo: Toggle.
void InitColor()
{
	LogFunctionHelper(__FUNCTION__) ;

	// Air Hike
	{
		constexpr byte8 sect1[] =
		{
			0x48, 0x8B, 0xCB ,
		};
		auto func = CreateFunction(SetColorAirHike, 0, true, true, 0, sizeof(sect1));
		memcpy(func.sect1, sect1, sizeof(sect1));
		WriteCall((appBaseAddr + 0x1F66DD), func.addr);
		/*
		dmc3.exe+1F66DD - E8 1E66E9FF - call dmc3.exe+8CD00
		*/
	}

	// Trickster Sky Star
	{
		constexpr byte8 sect0[] =
		{
			0x48, 0xBF, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // mov rdi
			0x8B, 0x3F,                                                 // mov edi,[rdi]
			0x89, 0xB8, 0xE0, 0x00, 0x00, 0x00,                         // mov [rax+000000E0],edi
		};
		auto func = CreateFunction(0, (appBaseAddr + 0x8E340), false, true, sizeof(sect0));
		memcpy(func.sect0, sect0, sizeof(sect0));
		*reinterpret_cast<uint8 **>(func.sect0 + 2) = activeConfig.Color.Trickster.skyStar;
		WriteJump((appBaseAddr + 0x8E330), func.addr, 4);
		/*
		dmc3.exe+8E330 - 66 C7 80 E0000000 FF00  - mov word ptr [rax+000000E0],00FF
		dmc3.exe+8E340 - C7 80 DC000000 02000000 - mov [rax+000000DC],00000002
		*/
	}

	// Royalguard Ultimate Start
	{
		constexpr byte8 sect0[] =
		{
			0x48, 0xB9, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // mov rcx
			0x8B, 0x09,                                                 // mov ecx,[rcx]
			0x89, 0x88, 0xE0, 0x00, 0x00, 0x00,                         // mov [rax+000000E0],ecx
		};
		auto func = CreateFunction(0, (appBaseAddr + 0x8E84C), false, true, sizeof(sect0));
		memcpy(func.sect0, sect0, sizeof(sect0));
		*reinterpret_cast<uint8 **>(func.sect0 + 2) = activeConfig.Color.Royalguard.ultimate;
		WriteJump((appBaseAddr + 0x8E83C), func.addr, 4);
		/*
		dmc3.exe+8E83C - 66 C7 80 E0000000 8F70  - mov word ptr [rax+000000E0],708F
		dmc3.exe+8E84C - C7 80 DC000000 02000000 - mov [rax+000000DC],00000002
		*/
	}

	// Royalguard Ultimate End
	{
		constexpr byte8 sect0[] =
		{
			0x48, 0xB9, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // mov rcx
			0x8B, 0x09,                                                 // mov ecx,[rcx]
			0x89, 0x88, 0xE0, 0x00, 0x00, 0x00,                         // mov [rax+000000E0],ecx
		};
		auto func = CreateFunction(0, (appBaseAddr + 0x91154), false, true, sizeof(sect0));
		memcpy(func.sect0, sect0, sizeof(sect0));
		*reinterpret_cast<uint8 **>(func.sect0 + 2) = activeConfig.Color.Royalguard.ultimate;
		WriteJump((appBaseAddr + 0x91144), func.addr, 4);
		/*
		dmc3.exe+91144 - 66 C7 80 E0000000 8F70  - mov word ptr [rax+000000E0],708F
		dmc3.exe+91154 - C7 80 DC000000 02000000 - mov [rax+000000DC],00000002
		*/
	}

	// Doppelganger Clone
	{
		constexpr byte8 sect0[] =
		{
			0x48, 0xBE, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // mov rsi
			0x8B, 0x36,                                                 // mov esi,[rsi]
			0x89, 0xB7, 0x28, 0x3A, 0x00, 0x00,                         // mov [rdi+00003A28],esi
		};
		auto func = CreateFunction(0, (appBaseAddr + 0x1FCD7D), false, true, sizeof(sect0));
		memcpy(func.sect0, sect0, sizeof(sect0));
		*reinterpret_cast<uint8 **>(func.sect0 + 2) = activeConfig.Color.Doppelganger.clone;
		WriteJump((appBaseAddr + 0x1FCD73), func.addr, 5);
		/*
		dmc3.exe+1FCD73 - C7 87 283A0000 10101030 - mov [rdi+00003A28],30101010
		dmc3.exe+1FCD7D - 89 87 243A0000          - mov [rdi+00003A24],eax
		*/
	}








	static bool run = false;






	// // Aura Start
	// {
	// 	constexpr byte8 sect0[] =
	// 	{
	// 		0xBA, 0x01, 0x00, 0x00, 0x00, // mov edx,00000001
	// 	};
	// 	constexpr byte8 sect1[] =
	// 	{
	// 		mov_rcx_rbx,
	// 		call,
	// 		mov_rcx_rax,
	// 		0x48, 0x8D, 0x55, 0xA7, // lea rdx,[rbp-59]
	// 	};
	// 	auto func = CreateFunction(SetColorAura, (appBaseAddr + 0x8E457), true, true, sizeof(sect0), sizeof(sect1));
	// 	memcpy(func.sect0, sect0, sizeof(sect0));
	// 	memcpy(func.sect1, sect1, sizeof(sect1));
	// 	WriteCall((func.sect1 + 3), GetActorBaseAddressByEffectData);
	// 	WriteJump((appBaseAddr + 0x8E452), func.addr);
	// 	/*
	// 	dmc3.exe+8E452 - BA 01000000 - mov edx,00000001
	// 	dmc3.exe+8E457 - E8 34C61600 - call dmc3.exe+1FAA90
	// 	*/
	// }

	constexpr bool enable = true;



	// Devil Aura Start
	{
		auto addr     = (appBaseAddr + 0x8E452);
		auto jumpAddr = (appBaseAddr + 0x8E457);
		constexpr uint32 size = 5;
		/*
		dmc3.exe+8E452 - BA 01000000 - mov edx,00000001
		dmc3.exe+8E457 - E8 34C61600 - call dmc3.exe+1FAA90
		*/

		static Function func = {};

		constexpr byte8 sect0[] =
		{
			0x48, 0x8D, 0x45, 0xA7, // lea rax,[rbp-59]
		};
		constexpr byte8 sect1[] =
		{
			0x48, 0x8B, 0xD0 ,
			0x48, 0x8B, 0xCB ,
			0xE8, 0x00, 0x00, 0x00, 0x00 ,
			0x48, 0x8B, 0xC8 ,
		};

		if (!run)
		{
			backupHelper.Save(addr, size);
			func = CreateFunction(SetColorAura, jumpAddr, true, true, sizeof(sect0), sizeof(sect1), size);
			CopyMemory(func.sect0, sect0, sizeof(sect0));
			CopyMemory(func.sect1, sect1, sizeof(sect1));
			CopyMemory(func.sect2, addr, size, MemoryFlags_VirtualProtectSource);
			WriteCall((func.sect1 + 6), GetActorBaseAddressByEffectData);
		}

		if (enable)
		{
			WriteJump(addr, func.addr, (size - 5));
		}
		else
		{
			backupHelper.Restore(addr);
		}
	}








	// Devil Aura Loop
	{
		auto addr     = (appBaseAddr + 0x90C9D);
		auto jumpAddr = (appBaseAddr + 0x90CA4);
		constexpr uint32 size = 7;
		/*
		dmc3.exe+90C9D - 0FB6 8F D4000000 - movzx ecx,byte ptr [rdi+000000D4]
		dmc3.exe+90CA4 - 85 C9            - test ecx,ecx
		*/

		static Function func = {};

		constexpr byte8 sect0[] =
		{
			0x48, 0x8D, 0x44, 0x24, 0x30, // lea rax,[rsp+30]
		};
		constexpr byte8 sect1[] =
		{
			0x48, 0x8B, 0xD0 ,
			0x48, 0x8B, 0xCF ,
			0xE8, 0x00, 0x00, 0x00, 0x00 ,
			0x48, 0x8B, 0xC8 ,
		};

		if (!run)
		{
			backupHelper.Save(addr, size);
			func = CreateFunction(SetColorAura, jumpAddr, true, true, sizeof(sect0), sizeof(sect1), size);
			CopyMemory(func.sect0, sect0, sizeof(sect0));
			CopyMemory(func.sect1, sect1, sizeof(sect1));
			CopyMemory(func.sect2, addr, size, MemoryFlags_VirtualProtectSource);
			WriteCall((func.sect1 + 6), GetActorBaseAddressByEffectData);
		}

		if (enable)
		{
			WriteJump(addr, func.addr, (size - 5));
		}
		else
		{
			backupHelper.Restore(addr);
		}
	}






	// // Aura Loop
	// {
	// 	constexpr byte8 sect0[] =
	// 	{
	// 		0x48, 0x8B, 0x06, // mov rax,[rsi]
	// 		0x48, 0x85, 0xC0, // test rax,rax
	// 	};
	// 	constexpr byte8 sect1[] =
	// 	{
	// 		mov_rcx_rdi,
	// 		call,
	// 		mov_rcx_rax,
	// 		0x48, 0x8D, 0x54, 0x24, 0x30, // lea rdx,[rsp+30]
	// 	};

	// 	auto func = CreateFunction(SetColorAura, (appBaseAddr + 0x90C69), true, true, sizeof(sect0), sizeof(sect1));
	// 	memcpy(func.sect0, sect0, sizeof(sect0));
	// 	memcpy(func.sect1, sect1, sizeof(sect1));
	// 	WriteCall((func.sect1 + 3), GetActorBaseAddressByEffectData);
	// 	WriteJump((appBaseAddr + 0x90C63), func.addr, 1);
	// 	/*
	// 	dmc3.exe+90C63 - 48 8B 06 - mov rax,[rsi]
	// 	dmc3.exe+90C66 - 48 85 C0 - test rax,rax
	// 	dmc3.exe+90C69 - 74 32    - je dmc3.exe+90C9D
	// 	*/
	// }

	// Aura Vergil Fix
	SetMemory((appBaseAddr + 0x90C32), 0x90, 4, MemoryFlags_VirtualProtectDestination);
	/*
	dmc3.exe+90C32 - 44 0FB6 EB - movzx r13d,bl
	*/


	run = true;



}

#pragma endregion

#pragma region Speed

byte8 * UpdateActorSpeedAddr = 0;

// @Todo: Quicksilver enemy speed.
// @Todo: Check turbo modifier.
// @Todo: Add quicksilver check.
// Geryon turns Quicksilver forcefully off.
// When hit by Geryon's Time Lag, Quicksilver is turned off.
// So we can easily check against quicksilver flag.





void UpdateActorSpeed(byte8 * baseAddr)
{
	if (!baseAddr)
	{
		return;
	}

	for (uint32 index = 0; index < Actor_actorBaseAddr.count; index++)
	{
		auto actorBaseAddr = Actor_actorBaseAddr[index];if (!actorBaseAddr){ continue;}auto & actorData = *reinterpret_cast<ActorData *>(actorBaseAddr) ;
		//IntroduceActorData(actorBaseAddr, actorData, index, continue);
		// auto actorBaseAddr = Actor_actorBaseAddr[index];
		// if (actorBaseAddr != baseAddr)
		// {
		// 	continue;
		// }
		// auto & actorData = *reinterpret_cast<ActorData *>(actorBaseAddr);

		auto value = (GetTurbo()) ? activeConfig.Speed.turbo : activeConfig.Speed.main;

		if (g_quicksilver)
		{
			switch (actorData.speedMode)
			{
				case 2:
				{
					value *= activeConfig.Speed.quicksilverActor;

					goto LoopContinue;
				}
			}
		}
		else
		{
			switch (actorData.speedMode)
			{
				case 1:
				{
					value = 0;

					goto LoopContinue;
				}
				case 2:
				{
					value *= 0.2f;

					goto LoopContinue;
				}
			}
		}

		if (!actorData.devil)
		{
			value *= activeConfig.Speed.human;
		}
		else
		{
			switch (actorData.character)
			{
				case CHAR_DANTE:
				{
					auto devilIndex = actorData.meleeWeaponIndex;
					if (devilIndex > 4)
					{
						devilIndex = 0;
					}

					if (actorData.sparda)
					{
						devilIndex = DEVIL_SPEED_DANTE_SPARDA;
					}

					value *= activeConfig.Speed.devilDante[devilIndex];

					break;
				}
				case CHAR_VERGIL:
				{
					auto devilIndex = actorData.queuedMeleeWeaponIndex;
					if (devilIndex > 2)
					{
						devilIndex = 0;
					}

					if (actorData.neroAngelo)
					{
						if (devilIndex > 1)
						{
							devilIndex = 0;
						}

						devilIndex += 3;
					}

					value *= activeConfig.Speed.devilVergil[devilIndex];

					break;
				}
			}
		}

		LoopContinue:;

		actorData.speed = value;
	}
}

void InitSpeed()
{
	LogFunctionHelper(__FUNCTION__) ;

	{
		constexpr byte8 sect0[] =
		{
			0xF3, 0x0F, 0x11, 0x43, 0x14, // movss [rbx+14],xmm0
		};
		constexpr byte8 sect1[] =
		{
			0x48, 0x8B, 0xCB ,
		};
		auto func = CreateFunction(UpdateActorSpeed, (appBaseAddr + 0x3261D2), true, true, sizeof(sect0), sizeof(sect1));
		memcpy(func.sect0, sect0, sizeof(sect0));
		memcpy(func.sect1, sect1, sizeof(sect1));
		UpdateActorSpeedAddr = func.addr;
		/*
		dmc3.exe+3261CD - F3 0F11 43 14 - movss [rbx+14],xmm0
		dmc3.exe+3261D2 - 48 83 C4 20   - add rsp,20
		*/
	}
}

void ToggleSpeed(bool enable)
{
	LogFunctionHelper(__FUNCTION__, enable) ;

	// Devil Speed Values Dante
	{
		auto items = reinterpret_cast<float *>(appBaseAddr + 0x58B0B8);

		if (enable)
		{
			for (uint8 itemIndex = 0; itemIndex < countof(activeConfig.Speed.devilDante); itemIndex++)
			{
				auto & item = items[itemIndex];

				Write<float>(&item, 1.0f);
			}
		}
		else
		{
			CopyMemory(items, defaultConfig.Speed.devilDante, sizeof(defaultConfig.Speed.devilDante), MemoryFlags_VirtualProtectDestination);
		}
		/*
		dmc3.exe+1F8C24 - F3 41 0F10 84 8C B8B05800 - MOVSS XMM0,[R12+RCX*4+0058B0B8]
		*/
	}

	// Devil Speed Values Vergil
	{
		auto items = reinterpret_cast<float *>(appBaseAddr + 0x58B0D8);

		if (enable)
		{
			for (uint8 itemIndex = 0; itemIndex < countof(activeConfig.Speed.devilVergil); itemIndex++)
			{
				auto & item = items[itemIndex];

				Write<float>(&item, 1.0f);
			}
		}
		else
		{
			CopyMemory(items, defaultConfig.Speed.devilVergil, sizeof(defaultConfig.Speed.devilVergil), MemoryFlags_VirtualProtectDestination);
		}
		/*
		dmc3.exe+1F8C48 - F3 41 0F10 84 8C D8B05800 - MOVSS XMM0,[R12+RCX*4+0058B0D8]
		dmc3.exe+1F8C5B - F3 41 0F10 84 84 D8B05800 - MOVSS XMM0,[R12+RAX*4+0058B0D8]
		*/
	}

	// Update Actor Speed
	{
		auto dest = (appBaseAddr + 0x3261CD);
		if (enable)
		{
			WriteJump(dest, UpdateActorSpeedAddr);
		}
		else
		{
			constexpr byte8 buffer[] =
			{
				0xF3, 0x0F, 0x11, 0x43, 0x14, // movss [rbx+14],xmm0
			};
			CopyMemory(dest, buffer, sizeof(buffer), MemoryFlags_VirtualProtectDestination);
		}
		/*
		dmc3.exe+3261CD - F3 0F11 43 14 - movss [rbx+14],xmm0
		dmc3.exe+3261D2 - 48 83 C4 20   - add rsp,20
		*/
	}
}




#pragma endregion

#pragma region Sound

inline void UpdateGlobalCharacterCostume(byte8 * actorBaseAddr)
{
	if (!actorBaseAddr)
	{
		return;
	}
	auto & actorData = *reinterpret_cast<ActorData *>(actorBaseAddr);

	g_character = static_cast<uint8>(actorData.character);
	g_costume = actorData.costume;
}

template <typename T>
void UpdateGlobalCharacterCostumeByData(byte8 * dataAddr)
{
	if (!dataAddr)
	{
		return;
	}

	byte8 * actorBaseAddr = 0;

	if constexpr (TypeMatch<T, BodyPartData>::value)
	{
		auto & bodyPartData = *reinterpret_cast<BodyPartData *>(dataAddr);

		actorBaseAddr = (reinterpret_cast<byte8 *>(bodyPartData.motionArchives) - __builtin_offsetof(ActorData, motionArchives) );
	}
	else if constexpr (TypeMatch<T, SummonedSwordsData>::value)
	{
		auto & summonedSwordsData = *reinterpret_cast<SummonedSwordsData *>(dataAddr);

		actorBaseAddr = summonedSwordsData.actorBaseAddr;
	}

	UpdateGlobalCharacterCostume(actorBaseAddr);
}

void ToggleSound(bool enable)
{
	static bool run = false;

	// Taunt & Style
	{
		auto addr     = (appBaseAddr + 0x59DFB);
		auto jumpAddr = (appBaseAddr + 0x59E00);
		constexpr uint32 size = 5;
		/*
		dmc3.exe+59DFB - E8 20F52D00       - call dmc3.exe+339320
		dmc3.exe+59E00 - C6 83 08010000 01 - mov byte ptr [rbx+00000108],01
		*/

		static Function func = {};

		constexpr byte8 sect1[] =
		{
			0x48, 0x8B, 0xCB ,
		};

		if (!run)
		{
			backupHelper.Save(addr, size);
			func = CreateFunction(UpdateGlobalCharacterCostumeByData<BodyPartData>, jumpAddr, true, true, 0, sizeof(sect1), size);
			CopyMemory(func.sect1, sect1, sizeof(sect1));
			CopyMemory(func.sect2, addr, size, MemoryFlags_VirtualProtectSource);
			WriteCall(func.sect2, (appBaseAddr + 0x339320));
		}

		if (enable)
		{
			WriteJump(addr, func.addr, (size - 5));
		}
		else
		{
			backupHelper.Restore(addr);
		}
	}

	// Melee Weapon
	{
		auto addr     = (appBaseAddr + 0x59E3B);
		auto jumpAddr = (appBaseAddr + 0x59E40);
		constexpr uint32 size = 5;
		/*
		dmc3.exe+59E3B - E8 F0FA2D00       - call dmc3.exe+339930
		dmc3.exe+59E40 - C6 83 09010000 01 - mov byte ptr [rbx+00000109],01
		*/

		static Function func = {};

		constexpr byte8 sect1[] =
		{
			0x48, 0x8B, 0xCB ,
		};

		if (!run)
		{
			backupHelper.Save(addr, size);
			func = CreateFunction(UpdateGlobalCharacterCostumeByData<BodyPartData>, jumpAddr, true, true, 0, sizeof(sect1), size);
			CopyMemory(func.sect1, sect1, sizeof(sect1));
			CopyMemory(func.sect2, addr, size, MemoryFlags_VirtualProtectSource);
			WriteCall(func.sect2, (appBaseAddr + 0x339930));
		}

		if (enable)
		{
			WriteJump(addr, func.addr, (size - 5));
		}
		else
		{
			backupHelper.Restore(addr);
		}
	}

	// Ebony & Ivory
	{
		auto addr     = (appBaseAddr + 0x216CC3);
		auto jumpAddr = (appBaseAddr + 0x216CC8);
		constexpr uint32 size = 5;
		/*
		dmc3.exe+216CC3 - E8 682C1200 - call dmc3.exe+339930
		dmc3.exe+216CC8 - 83 FB 09    - cmp ebx,09
		*/

		static Function func = {};

		constexpr byte8 sect1[] =
		{
			0x48, 0x8B, 0xCF ,
		};

		if (!run)
		{
			backupHelper.Save(addr, size);
			func = CreateFunction(UpdateGlobalCharacterCostume, jumpAddr, true, true, 0, sizeof(sect1), size);
			CopyMemory(func.sect1, sect1, sizeof(sect1));
			CopyMemory(func.sect2, addr, size, MemoryFlags_VirtualProtectSource);
			WriteCall(func.sect2, (appBaseAddr + 0x339930));
		}

		if (enable)
		{
			WriteJump(addr, func.addr, (size - 5));
		}
		else
		{
			backupHelper.Restore(addr);
		}
	}

	// Shotgun
	{
		auto addr     = (appBaseAddr + 0x218212);
		auto jumpAddr = (appBaseAddr + 0x218217);
		constexpr uint32 size = 5;
		/*
		dmc3.exe+218212 - E8 19171200 - call dmc3.exe+339930
		dmc3.exe+218217 - 40 0FB6 C6  - movzx eax,sil
		*/

		static Function func = {};

		constexpr byte8 sect1[] =
		{
			0x48, 0x8B, 0xCB ,
		};

		if (!run)
		{
			backupHelper.Save(addr, size);
			func = CreateFunction(UpdateGlobalCharacterCostume, jumpAddr, true, true, 0, sizeof(sect1), size);
			CopyMemory(func.sect1, sect1, sizeof(sect1));
			CopyMemory(func.sect2, addr, size, MemoryFlags_VirtualProtectSource);
			WriteCall(func.sect2, (appBaseAddr + 0x339930));
		}

		if (enable)
		{
			WriteJump(addr, func.addr, (size - 5));
		}
		else
		{
			backupHelper.Restore(addr);
		}
	}

	// Artemis
	{
		auto addr     = (appBaseAddr + 0x216042);
		auto jumpAddr = (appBaseAddr + 0x216047);
		constexpr uint32 size = 5;
		/*
		dmc3.exe+216042 - E8 E9381200    - call dmc3.exe+339930
		dmc3.exe+216047 - FE 87 7EB80000 - inc byte ptr [rdi+0000B87E]
		*/

		static Function func = {};

		constexpr byte8 sect1[] =
		{
			0x48, 0x8B, 0xCF ,
		};

		if (!run)
		{
			backupHelper.Save(addr, size);
			func = CreateFunction(UpdateGlobalCharacterCostume, jumpAddr, true, true, 0, sizeof(sect1), size);
			CopyMemory(func.sect1, sect1, sizeof(sect1));
			CopyMemory(func.sect2, addr, size, MemoryFlags_VirtualProtectSource);
			WriteCall(func.sect2, (appBaseAddr + 0x339930));
		}

		if (enable)
		{
			WriteJump(addr, func.addr, (size - 5));
		}
		else
		{
			backupHelper.Restore(addr);
		}
	}

	// Spiral
	{
		auto addr     = (appBaseAddr + 0x20877F);
		auto jumpAddr = (appBaseAddr + 0x208784);
		constexpr uint32 size = 5;
		/*
		dmc3.exe+20877F - E8 AC111300    - call dmc3.exe+339930
		dmc3.exe+208784 - FE 83 153E0000 - inc byte ptr [rbx+00003E15]
		*/

		static Function func = {};

		constexpr byte8 sect1[] =
		{
			0x48, 0x8B, 0xCB ,
		};

		if (!run)
		{
			backupHelper.Save(addr, size);
			func = CreateFunction(UpdateGlobalCharacterCostume, jumpAddr, true, true, 0, sizeof(sect1), size);
			CopyMemory(func.sect1, sect1, sizeof(sect1));
			CopyMemory(func.sect2, addr, size, MemoryFlags_VirtualProtectSource);
			WriteCall(func.sect2, (appBaseAddr + 0x339930));
		}

		if (enable)
		{
			WriteJump(addr, func.addr, (size - 5));
		}
		else
		{
			backupHelper.Restore(addr);
		}
	}

	// Kalina Ann
	{
		auto addr     = (appBaseAddr + 0x206212);
		auto jumpAddr = (appBaseAddr + 0x206217);
		constexpr uint32 size = 5;
		/*
		dmc3.exe+206212 - E8 19371300    - call dmc3.exe+339930
		dmc3.exe+206217 - FE 83 153E0000 - inc byte ptr [rbx+00003E15]
		*/

		static Function func = {};

		constexpr byte8 sect1[] =
		{
			0x48, 0x8B, 0xCB ,
		};

		if (!run)
		{
			backupHelper.Save(addr, size);
			func = CreateFunction(UpdateGlobalCharacterCostume, jumpAddr, true, true, 0, sizeof(sect1), size);
			CopyMemory(func.sect1, sect1, sizeof(sect1));
			CopyMemory(func.sect2, addr, size, MemoryFlags_VirtualProtectSource);
			WriteCall(func.sect2, (appBaseAddr + 0x339930));
		}

		if (enable)
		{
			WriteJump(addr, func.addr, (size - 5));
		}
		else
		{
			backupHelper.Restore(addr);
		}
	}

	// Summoned Swords
	{
		auto addr     = (appBaseAddr + 0x1DBA94);
		auto jumpAddr = (appBaseAddr + 0x1DBA99);
		constexpr uint32 size = 5;
		/*
		dmc3.exe+1DBA94 - E8 97DE1500      - call dmc3.exe+339930
		dmc3.exe+1DBA99 - 0FB6 8B F20D0000 - movzx ecx,byte ptr [rbx+00000DF2]
		*/

		static Function func = {};

		constexpr byte8 sect1[] =
		{
			0x48, 0x8B, 0xCB ,
		};

		if (!run)
		{
			backupHelper.Save(addr, size);
			func = CreateFunction(UpdateGlobalCharacterCostumeByData<SummonedSwordsData>, jumpAddr, true, true, 0, sizeof(sect1), size);
			CopyMemory(func.sect1, sect1, sizeof(sect1));
			CopyMemory(func.sect2, addr, size, MemoryFlags_VirtualProtectSource);
			WriteCall(func.sect2, (appBaseAddr + 0x339930));
		}

		if (enable)
		{
			WriteJump(addr, func.addr, (size - 5));
		}
		else
		{
			backupHelper.Restore(addr);
		}
	}

	run = true;
}

#pragma endregion

























// @Todo: Recheck and move to Toggle.
void ToggleMainActorFixes(bool enable)
{
	LogFunctionHelper(__FUNCTION__, enable) ;


	// Disable Doppelganger rotation update during camera angle update.
	Write<byte8>((appBaseAddr + 0x55F6F), (enable) ? 0xEB : 0x75);
	/*
	dmc3.exe+55F6F - 75 10       - jne dmc3.exe+55F81
	dmc3.exe+55F71 - 48 8B 49 20 - mov rcx,[rcx+20]
	*/


	static bool run = false;

	run = true;

	{
		auto dest = (appBaseAddr + 0x1F83D7);
		if (enable)
		{
			SetMemory(dest, 0x90, 18, MemoryFlags_VirtualProtectDestination);
			constexpr byte8 buffer[] =
			{
				0x40, 0x38, 0xB7, 0x62, 0x63, 0x00, 0x00, // cmp [rdi+00006362],sil
			};
			CopyMemory(dest, buffer, sizeof(buffer), MemoryFlags_VirtualProtectDestination);
		}
		else
		{
			constexpr byte8 buffer[] =
			{
				0x48, 0x8B, 0x0D, 0x4A, 0x8A, 0xA9, 0x00, // mov rcx,[dmc3.exe+C90E28]
				0x48, 0x8B, 0x41, 0x18,                   // mov rax,[rcx+18]
				0x40, 0x38, 0xB0, 0x62, 0x63, 0x00, 0x00, // cmp [rax+00006362],sil
			};
			CopyMemory(dest, buffer, sizeof(buffer), MemoryFlags_VirtualProtectDestination);
		}
		/*
		dmc3.exe+1F83D7 - 48 8B 0D 4A8AA900 - mov rcx,[dmc3.exe+C90E28]
		dmc3.exe+1F83DE - 48 8B 41 18       - mov rax,[rcx+18]
		dmc3.exe+1F83E2 - 40 38 B0 62630000 - cmp [rax+00006362],sil
		dmc3.exe+1F83E9 - 75 0E             - jne dmc3.exe+1F83F9
		*/
	}

	Write<uint32>((appBaseAddr + 0x1F5FC6 + 2), (enable) ? __builtin_offsetof(ActorData, newIsClone) : __builtin_offsetof(ActorData, isClone) );
	/*
	dmc3.exe+1F5FC6 - 83 B9 C8CA0100 01 - cmp dword ptr [rcx+0001CAC8],01
	dmc3.exe+1F5FCD - 48 8B D9          - mov rbx,rcx
	*/
}

void ToggleStyleFixes(bool enable)
{
	// Disable Menu Controller
	Write<bool>((appBaseAddr + 0x23B110 + 1), (enable) ? false : true); // dmc3.exe+23B110 - B0 01 - mov al,01
	Write<bool>((appBaseAddr + 0x23B15D + 1), (enable) ? false : true); // dmc3.exe+23B15D - B0 01 - mov al,01
	Write<bool>((appBaseAddr + 0x23B1A1 + 1), (enable) ? false : true); // dmc3.exe+23B1A1 - B0 01 - mov al,01
	Write<bool>((appBaseAddr + 0x23B1E5 + 1), (enable) ? false : true); // dmc3.exe+23B1E5 - B0 01 - mov al,01

	// Force Style Updates
	{
		WriteAddress((appBaseAddr + 0x1F87BB), (enable) ? (appBaseAddr + 0x1F87DC) : (appBaseAddr + 0x1F8AC6), 6); // dmc3.exe+1F87BB - 0F84 05030000 - je dmc3.exe+1F8AC6
		WriteAddress((appBaseAddr + 0x1F87C4), (enable) ? (appBaseAddr + 0x1F87DC) : (appBaseAddr + 0x1F8AAC), 6); // dmc3.exe+1F87C4 - 0F84 E2020000 - je dmc3.exe+1F8AAC
		WriteAddress((appBaseAddr + 0x1F87CD), (enable) ? (appBaseAddr + 0x1F87DC) : (appBaseAddr + 0x1F8A00), 6); // dmc3.exe+1F87CD - 0F84 2D020000 - je dmc3.exe+1F8A00
		WriteAddress((appBaseAddr + 0x1F87D6), (enable) ? (appBaseAddr + 0x1F87DC) : (appBaseAddr + 0x1F8AF8), 6); // dmc3.exe+1F87D6 - 0F85 1C030000 - jne dmc3.exe+1F8AF8
		// Doppelganger
		WriteAddress((appBaseAddr + 0x1F880B), (enable) ? (appBaseAddr + 0x1F8A00) : (appBaseAddr + 0x1F8AF8), 6); // dmc3.exe+1F880B - 0F85 E7020000 - jne dmc3.exe+1F8AF8
		WriteAddress((appBaseAddr + 0x1F8852), (enable) ? (appBaseAddr + 0x1F8A00) : (appBaseAddr + 0x1F8AF8), 6); // dmc3.exe+1F8852 - 0F85 A0020000 - jne dmc3.exe+1F8AF8
		WriteAddress((appBaseAddr + 0x1F8862), (enable) ? (appBaseAddr + 0x1F8A00) : (appBaseAddr + 0x1F8AF8), 5); // dmc3.exe+1F8862 - E9 91020000   - jmp dmc3.exe+1F8AF8
		WriteAddress((appBaseAddr + 0x1F886E), (enable) ? (appBaseAddr + 0x1F8A00) : (appBaseAddr + 0x1F8AF8), 6); // dmc3.exe+1F886E - 0F84 84020000 - je dmc3.exe+1F8AF8
		WriteAddress((appBaseAddr + 0x1F89E1), (enable) ? (appBaseAddr + 0x1F8A00) : (appBaseAddr + 0x1F8AF8), 6); // dmc3.exe+1F89E1 - 0F82 11010000 - jb dmc3.exe+1F8AF8
		WriteAddress((appBaseAddr + 0x1F89FB), (enable) ? (appBaseAddr + 0x1F8A00) : (appBaseAddr + 0x1F8AF8), 5); // dmc3.exe+1F89FB - E9 F8000000   - jmp dmc3.exe+1F8AF8
		// Quicksilver
		WriteAddress((appBaseAddr + 0x1F8A07), (enable) ? (appBaseAddr + 0x1F8AAC) : (appBaseAddr + 0x1F8AF8), 6); // dmc3.exe+1F8A07 - 0F85 EB000000 - jne dmc3.exe+1F8AF8
		WriteAddress((appBaseAddr + 0x1F8A7D), (enable) ? (appBaseAddr + 0x1F8AAC) : (appBaseAddr + 0x1F8AF8), 2); // dmc3.exe+1F8A7D - 72 79         - jb dmc3.exe+1F8AF8
		WriteAddress((appBaseAddr + 0x1F8AAA), (enable) ? (appBaseAddr + 0x1F8AAC) : (appBaseAddr + 0x1F8AF8), 2); // dmc3.exe+1F8AAA - EB 4C         - jmp dmc3.exe+1F8AF8
		// Royalguard
		WriteAddress((appBaseAddr + 0x1F8AC4), (enable) ? (appBaseAddr + 0x1F8AC6) : (appBaseAddr + 0x1F8AF8), 2); // dmc3.exe+1F8AC4 - EB 32 - jmp dmc3.exe+1F8AF8
	}

	// Gunslinger Fixes
	{
		// Allow Charging
		WriteAddress((appBaseAddr + 0x21607C), (enable) ? (appBaseAddr + 0x216082) : (appBaseAddr + 0x216572), 6);
		/*
		dmc3.exe+21606F - 83 BF 38630000 01 - cmp dword ptr [rdi+00006338],01
		dmc3.exe+21607C - 0F85 F0040000     - jne dmc3.exe+216572
		dmc3.exe+216082 - 83 BF 943E0000 02 - cmp dword ptr [rdi+00003E94],02
		*/

		// Allow Charged Shot
		WriteAddress((appBaseAddr + 0x1E6AAD), (enable) ? (appBaseAddr + 0x1E6AB3) : (appBaseAddr + 0x1E64A9), 6);
		/*
		dmc3.exe+1E6AA7 - 3B 83 38630000 - cmp eax,[rbx+00006338]
		dmc3.exe+1E6AAD - 0F85 F6F9FFFF  - jne dmc3.exe+1E64A9
		dmc3.exe+1E6AB3 - 83 7B 78 00    - cmp dword ptr [rbx+78],00
		*/

		// Allow Wild Stomp
		Write<byte8>((appBaseAddr + 0x1E7F5F), (enable) ? 0xEB : 0x74);
		/*
		dmc3.exe+1E7F55 - 83 B9 38630000 01 - cmp dword ptr [rcx+00006338],01
		dmc3.exe+1E7F5F - 74 15             - je dmc3.exe+1E7F76
		*/
	}

	// Disable Dante Check
	Write<byte8>((appBaseAddr + 0x1E8F98), (enable) ? 0xEB : 0x74);
	/*
	dmc3.exe+1E8F98 - 74 0D - je dmc3.exe+1E8FA7
	dmc3.exe+1E8F9A - 32 C0 - xor al,al
	*/
}










bool DevilButtonCheck(ActorData & actorData)
{
	auto & playerData = GetPlayerData(actorData);

	bool condition = (actorData.buttons[0] & playerData.button);

	if (actorData.newEntityIndex == ENTITY_MAIN)
	{
		if (condition)
		{
			return false;
		}
	}
	else
	{
		if (!condition)
		{
			return false;
		}
	}

	return true;
}

// @Todo: Update.
void ActivateDevil(ActorData & actorData)
{
	switch (actorData.character)
	{
		case CHAR_DANTE:
		{
			auto & actorData2 = *reinterpret_cast<ActorDataDante *>(&actorData);
			UpdateForm(actorData2);
			break;
		}
		case CHAR_VERGIL:
		{
			auto & actorData2 = *reinterpret_cast<ActorDataVergil *>(&actorData);
			UpdateForm(actorData2);
			break;
		}
	}

	func_1F94D0(actorData, DEVIL_FLUX_START);
}

void DeactivateDevil(ActorData & actorData)
{
	switch (actorData.character)
	{
		case CHAR_DANTE:
		{
			auto & actorData2 = *reinterpret_cast<ActorDataDante *>(&actorData);
			UpdateForm(actorData2);
			break;
		}
		case CHAR_VERGIL:
		{
			auto & actorData2 = *reinterpret_cast<ActorDataVergil *>(&actorData);
			UpdateForm(actorData2);
			break;
		}
	}

	func_1F94D0(actorData, DEVIL_FLUX_END);
}








void UpdateColorMatrices(ActorData & actorData)
{
	if (actorData.visibility != 0)
	{
		actorData.visibility = (g_quicksilver) ? 2 : 1;
	}

	uint16 value = (g_quicksilver) ? 128 : 0;

	{
		auto dest = reinterpret_cast<byte8 *>(&actorData.newModelData[0]);

		*reinterpret_cast<uint16 *>(dest + 0x80 + 0x214) = value;
	}

	if (actorData.character == CHAR_BOB)
	{
		auto dest = reinterpret_cast<byte8 *>(&actorData);

		*reinterpret_cast<uint16 *>(dest + 0x13E10 + 0x214) = value;
	}

	for (uint8 weaponIndex = 0; weaponIndex < WEAPON_COUNT; weaponIndex++)
	{
		auto & weapon = actorData.newWeapons[weaponIndex];
		if (weapon >= MAX_WEAPON)
		{
			continue;
		}

		auto weaponDataAddr = actorData.newWeaponDataAddr[weaponIndex];
		if (!weaponDataAddr)
		{
			continue;
		}

		auto dest = reinterpret_cast<byte8 *>(weaponDataAddr);

		constexpr uint32 offs[MAX_WEAPON] =
		{
			0x280,
			0x880,
			0x340,
			0x300,
			0x3C0,
			0,
			0x280,
			0x400,
			0x200,
			0x280,
			0,
			0,
			0x3C0,
			0x280,
			0,
		};

		auto off = offs[weapon];

		switch (weapon)
		{
			case WEAPON_EBONY_IVORY:
			{
				*reinterpret_cast<uint16 *>(dest + 0x200 + 0x214) = value;
				*reinterpret_cast<uint16 *>(dest + 0x980 + 0x214) = value;

				break;
			}
			case WEAPON_YAMATO_VERGIL:
			case WEAPON_YAMATO_BOB:
			{
				*reinterpret_cast<uint16 *>(dest + 0xF00  + 0x214) = value;
				*reinterpret_cast<uint16 *>(dest + 0x1680 + 0x214) = value;

				break;
			}
			default:
			{
				*reinterpret_cast<uint16 *>(dest + off + 0x214) = value;

				break;
			}
		}
	}
}

inline void QuicksilverFunction
(
	byte8 * actorBaseAddr,
	bool enable
)
{
	if (!actorBaseAddr)
	{
		return;
	}
	else if (actorBaseAddr != Actor_actorBaseAddr[2])
	{
		return;
	}

	g_quicksilver = enable;

	for (uint32 index = 0; index < Actor_actorBaseAddr.count; index++)
	{
		auto actorBaseAddr2 = Actor_actorBaseAddr[index];if (!actorBaseAddr2){ continue;}auto & actorData2 = *reinterpret_cast<ActorData *>(actorBaseAddr2) ;

		UpdateColorMatrices(actorData2);
	}
}

void ActivateQuicksilver(byte8 * actorBaseAddr)
{
	if constexpr (false )
	{
		LogFunctionHelper(__FUNCTION__, actorBaseAddr) ;
	}

	QuicksilverFunction
	(
		actorBaseAddr,
		true
	);
}

void DeactivateQuicksilver(byte8 * actorBaseAddr)
{
	if constexpr (false )
	{
		LogFunctionHelper(__FUNCTION__, actorBaseAddr) ;
	}

	QuicksilverFunction
	(
		actorBaseAddr,
		false
	);
}

void ActivateDoppelganger(ActorData & actorData)
{
	LogFunctionHelper(__FUNCTION__, actorData.operator byte8 *()) ;

	if (!actorData.cloneActorBaseAddr)
	{
		return;
	}
	auto & cloneActorData = *reinterpret_cast<ActorData *>(actorData.cloneActorBaseAddr);

	memset(actorData.var_6438, 0, (actorData.var_6440 * 46));
	/*
	dmc3.exe+1E9222 - 33 D2             - xor edx,edx
	dmc3.exe+1E92A3 - 48 63 87 40640000 - movsxd rax,dword ptr [rdi+00006440]
	dmc3.exe+1E92AA - 48 8B 8F 38640000 - mov rcx,[rdi+00006438]
	dmc3.exe+1E92B1 - 4C 6B C0 2E       - imul r8,rax,2E
	dmc3.exe+1E92B5 - E8 30D91500       - call dmc3.exe+346BEA
	*/

	actorData.cloneRate = 0;

	func_1EAE60(actorData, 0);
	/*
	dmc3.exe+1E92D7 - 33 D2       - xor edx,edx
	dmc3.exe+1E92D9 - 48 8B CF    - mov rcx,rdi
	dmc3.exe+1E92DC - E8 7F1B0000 - call dmc3.exe+1EAE60
	*/

	ToggleActor(cloneActorData, true);
}

void DeactivateDoppelganger(ActorData & actorData)
{
	LogFunctionHelper(__FUNCTION__, actorData.operator byte8 *()) ;

	if (!actorData.cloneActorBaseAddr)
	{
		return;
	}
	auto & cloneActorData = *reinterpret_cast<ActorData *>(actorData.cloneActorBaseAddr);

	func_1EAE60(actorData, 1);
	/*
	dmc3.exe+1E9339 - B2 01       - mov dl,01
	dmc3.exe+1E9351 - 48 8B CF    - mov rcx,rdi
	dmc3.exe+1E9354 - E8 071B0000 - call dmc3.exe+1EAE60
	*/

	if (cloneActorData.devil)
	{
		cloneActorData.devil = false;

		DeactivateDevil(cloneActorData);
	}

	ToggleActor(cloneActorData, false);

	EndMotion(cloneActorData);
}



























bool EbonyIvoryRainStormCheck(ActorData & actorData)
{
	if (actorData.buttons[0] & GetBinding(BINDING_STYLE_ACTION))
	{
		return true;
	}

	return false;
}




bool DotShadowCheck(byte8 * dest)
{
	if (!dest)
	{
		return false;
	}

	switch (activeConfig.dotShadow)
	{
		case DOT_SHADOW_DISABLE:
		{
			return true;
		}
		case DOT_SHADOW_DISABLE_ACTOR_ONLY:
		{
			auto baseAddr = *reinterpret_cast<byte8 **>(dest + 0xC0);
			if (!baseAddr)
			{
				break;
			}

			for (uint32 index = 0; index < Actor_actorBaseAddr.count; index++)
			{
				if (baseAddr == Actor_actorBaseAddr[index])
				{
					return true;
				}
			}

			break;
		}
	}

	return false;
}




void ResetActorMode()
{
	LogFunctionHelper(__FUNCTION__) ;

	for (uint32 index = 0; index < Actor_actorBaseAddr.count; index++)
	{
		auto actorBaseAddr = Actor_actorBaseAddr[index];if (!actorBaseAddr){ continue;}auto & actorData = *reinterpret_cast<ActorData *>(actorBaseAddr) ;
		//IntroduceActorData(actorBaseAddr, actorData, index, continue);
		// auto baseAddr = Actor_actorBaseAddr[index];
		// if (!baseAddr)
		// {
		// 	continue;
		// }
		// auto & actorData = *reinterpret_cast<ActorData *>(baseAddr);

		actorData.mode = ACTOR_MODE_DEFAULT;
		actorData.devil = false;

		// @Todo: Recheck.
		actorData.eventData[1].event = 36;

		DeactivateDevil(actorData);
	}
}





bool CollisionCheck(byte8 * collisionDataAddr)
{
	auto baseAddr = (collisionDataAddr - __builtin_offsetof(ActorData, collisionData) );

	for (uint32 index = 0; index < Actor_actorBaseAddr.count; index++)
	{
		//IntroduceActorData(actorBaseAddr, actorData, index, continue);
		// auto actorBaseAddr = Actor_actorBaseAddr[index];
		// if (!actorBaseAddr)
		// {
		// 	continue;
		// }
		auto actorBaseAddr = Actor_actorBaseAddr[index];if (!actorBaseAddr){ continue;}auto & actorData = *reinterpret_cast<ActorData *>(actorBaseAddr) ;

		if (actorBaseAddr != baseAddr)
		{
			continue;
		}
		// auto & actorData = *reinterpret_cast<ActorData *>(actorBaseAddr);

		return !actorData.newEnableCollision;
	}

	return false;
}



void ResetVisibility(ActorData & actorData)
{
	if (actorData.visibility != 0)
	{
		actorData.visibility = (g_quicksilver) ? 2 : 1;
	}
}



// void MagicPointsRunOut(ActorData & actorData)
// {
// 	LogFunction(actorData.operator byte8 *());

// 	Log("doppelganger %u", actorData.doppelganger);

// 	auto cloneActorBaseAddr = actorData.cloneBaseAddr;
// 	if (!cloneActorBaseAddr)
// 	{
// 		return;
// 	}
// 	auto & cloneActorData = *reinterpret_cast<ActorData *>(cloneActorBaseAddr);

// 	Log("doppelganger %u", cloneActorData.doppelganger);

// 	ToggleInput(cloneActorData, false);






// }





byte8  * UpdateModelDanteAddr               = 0;
byte8  * UpdateModelVergilAddr              = 0;
uint32 * modelPhysicsMetadataPoolOff        = 0;
byte8  * CoatUpdateDanteAddr                = 0;
byte8  * CoatUpdateVergilAddr               = 0;
byte8  * PositionUpdateEbonyIvoryAddr       = 0;
byte8  * PositionUpdateArtemisAddr          = 0;
byte8  * WeaponSwitchControllerDanteAddr    = 0;
byte8  * WeaponSwitchControllerVergilAddr   = 0;
byte8  * ActivateQuicksilverAddr            = 0;
byte8  * DeactivateQuicksilverAddr[2]       = {};


byte8  * ActivateDoppelgangerAddr           = 0;
byte8  * DeactivateDoppelgangerAddr[2] = {};



byte8  * DevilButtonCheckAddr         = 0;
byte8  * ActivateDevilAddr                  = 0;
byte8  * DeactivateDevilAddr                = 0;
byte8  * InputUpdateAddr[16]                = {};
byte8  * EbonyIvoryRainStormCheckAddr       = 0;
//byte8  * SummonedSwordsQuicksilverCheckAddr = 0;
byte8  * DotShadowCheckAddr                 = 0;
byte8 * ResetActorModeAddr                  = 0;
byte8 * CollisionCheckAddr                  = 0;
byte8 * ResetVisibilityAddr[2]              = {};

byte8 * EnableVisibilityCheckAddr[2] = {};


byte8 * PlayQuicksilverMotionAddr[2] = {};


// byte8 * MagicPointsRunOutAddr = 0;



export void Actor_Init()
{
	LogFunctionHelper(__FUNCTION__) ;

	static bool run = false;

	// Get Actor Base Address By Effect Data
	{
		static Function func = {};

		constexpr byte8 sect0[] =
		{
			0x48, 0x8B, 0x81, 0xC0, 0x00, 0x00, 0x00, // mov rax,[rcx+000000C0]
			0x48, 0x85, 0xC0,                         // test rax,rax
			0x75, 0x0B,                               // jne short
			0x48, 0x8B, 0x05, 0x00, 0x00, 0x00, 0x00, // mov rax,[dmc3.exe+C90E28]
			0x48, 0x8B, 0x40, 0x18,                   // mov rax,[rax+18]
			0xC3,                                     // ret
		};

		if (!run)
		{
			func = CreateFunction(0, 0, false, false, sizeof(sect0), 0, 0, 0, 0, true);
			CopyMemory(func.sect0, sect0, sizeof(sect0));
			WriteAddress((func.sect0 + 0xC), (appBaseAddr + 0xC90E28), 7);
			GetActorBaseAddressByEffectData = reinterpret_cast<GetActorBaseAddressByEffectData_t>(func.addr);
		}
	}







	//InitGetActorBaseAddressByEffectData();
	InitRegisterWeapon();
	InitIsWeaponReady();
	//InitMobility();
	InitColor();
	InitSpeed();

	if (!Actor_actorBaseAddr.Init(512))
	{
		Log("Actor_actorBaseAddr.Init failed.");
		return;
	}

	// Model Physics Metadata Pool Offsets
	{
		auto & off = modelPhysicsMetadataPoolOff;

		off = reinterpret_cast<uint32 *>(HighAlloc(64));
		if (!off)
		{
			Log("HighAlloc failed.");
			return;
		}

		for (uint32 index = 0; index < 7; index++)
		{
			off[index] = (index * 24);
		}
	}

	// Update Model Dante
	{
		auto func = CreateFunction(UpdateModel<ActorDataDante>);
		UpdateModelDanteAddr = func.addr;
	}

	// Update Model Vergil
	{
		auto func = CreateFunction(UpdateModel<ActorDataVergil>);
		UpdateModelVergilAddr = func.addr;
	}

	// Coat Update Dante
	{
		constexpr byte8 sect0[] =
		{
			0x80, 0xBE, 0x00, 0x00, 0x00, 0x00, 0x01, // cmp byte ptr [rsi+0000B8C0],01
			0x75, 0x12,                               // jne short
			0x80, 0xBE, 0x00, 0x00, 0x00, 0x00, 0x00, // cmp byte ptr [rsi+0000B8C0],02
			0x75, 0x09,                               // jne short
			0x48, 0x8B, 0x96, 0x00, 0x00, 0x00, 0x00, // mov rdx,[rsi+000018A8]
			0xEB, 0x07,                               // jmp short
			0x48, 0x8B, 0x96, 0x00, 0x00, 0x00, 0x00, // mov rdx,[rsi+00001898]
		};
		auto func = CreateFunction(0, (appBaseAddr + 0x2120CB), false, true, sizeof(sect0));
		memcpy(func.sect0, sect0, sizeof(sect0));
		*reinterpret_cast<uint32 *>(func.sect0 + 2) = __builtin_offsetof(ActorData, newForceFiles) ;
		*reinterpret_cast<uint32 *>(func.sect0 + 0xB) = __builtin_offsetof(ActorData, newForceFilesCharacter) ;
		*reinterpret_cast<uint8 *>(func.sect0 + 0xF) = CHAR_LADY;
		*reinterpret_cast<uint32 *>(func.sect0 + 0x15) = __builtin_offsetof(ActorData, newModelPhysicsMetadataPool[0][5]) ;
		*reinterpret_cast<uint32 *>(func.sect0 + 0x1E) = __builtin_offsetof(ActorData, newModelPhysicsMetadataPool[0][3]) ;
		CoatUpdateDanteAddr = func.addr;
		/*
		dmc3.exe+2120C4 - 48 8B 96 98180000 - mov rdx,[rsi+00001898]
		dmc3.exe+2120CB - 48 8D 8E 40750000 - lea rcx,[rsi+00007540]
		*/
	}

	// Coat Update Vergil
	{
		constexpr byte8 sect0[] =
		{
			0x80, 0xBE, 0xC0, 0xB8, 0x00, 0x00, 0x01, // cmp byte ptr [rsi+0000B8C0],01
			0x75, 0x12,                               // jne short
			0x80, 0xBE, 0x00, 0x00, 0x00, 0x00, 0x00, // cmp byte ptr [rsi+0000B8C0],02
			0x75, 0x09,                               // jne short
			0x48, 0x8B, 0x96, 0x00, 0x00, 0x00, 0x00, // mov rdx,[rsi+000018A8]
			0xEB, 0x07,                               // jmp short
			0x48, 0x8B, 0x96, 0x00, 0x00, 0x00, 0x00, // mov rdx,[rsi+00001898]
		};
		auto func = CreateFunction(0, (appBaseAddr + 0x22050D), false, true, sizeof(sect0));
		memcpy(func.sect0, sect0, sizeof(sect0));
		*reinterpret_cast<uint32 *>(func.sect0 + 2) = __builtin_offsetof(ActorData, newForceFiles) ;
		*reinterpret_cast<uint32 *>(func.sect0 + 0xB) = __builtin_offsetof(ActorData, newForceFilesCharacter) ;
		*reinterpret_cast<uint8 *>(func.sect0 + 0xF) = CHAR_LADY;
		*reinterpret_cast<uint32 *>(func.sect0 + 0x15) = __builtin_offsetof(ActorData, newModelPhysicsMetadataPool[0][5]) ;
		*reinterpret_cast<uint32 *>(func.sect0 + 0x1E) = __builtin_offsetof(ActorData, newModelPhysicsMetadataPool[0][3]) ;
		CoatUpdateVergilAddr = func.addr;
		/*
		dmc3.exe+220506 - 48 8B 96 98180000 - mov rdx,[rsi+00001898]
		dmc3.exe+22050D - 48 8D 8E 40750000 - lea rcx,[rsi+00007540]
		*/
	}

	// Position Update Ebony & Ivory
	{
		constexpr byte8 sect0[] =
		{
			0x0F, 0xB6, 0x90, 0x9E, 0x3E, 0x00, 0x00, // movzx edx,byte ptr [rax+00003E9E]
			0x80, 0xB8, 0x00, 0x00, 0x00, 0x00, 0x01, // cmp byte ptr [rax+0000B8C0],01
			0x0F, 0x84, 0x00, 0x00, 0x00, 0x00,       // je dmc3.exe+22B7E2
		};
		auto func = CreateFunction(0, (appBaseAddr + 0x22B616), false, true, sizeof(sect0));
		memcpy(func.sect0, sect0, sizeof(sect0));
		*reinterpret_cast<uint32 *>(func.sect0 + 9) = __builtin_offsetof(ActorData, newForceFiles) ;
		WriteAddress((func.sect0 + 0xE), (appBaseAddr + 0x22B7E2), 6);
		PositionUpdateEbonyIvoryAddr = func.addr;
		/*
		dmc3.exe+22B60F - 0FB6 90 9E3E0000 - movzx edx,byte ptr [rax+00003E9E]
		dmc3.exe+22B616 - 8D 42 FD         - lea eax,[rdx-03]
		*/
	}

	// Position Update Artemis
	{
		constexpr byte8 sect0[] =
		{
			0x0F, 0xB6, 0x82, 0x9E, 0x3E, 0x00, 0x00, // movzx eax,byte ptr [rdx+00003E9E]
			0x80, 0xBA, 0x00, 0x00, 0x00, 0x00, 0x01, // cmp byte ptr [rdx+0000B8C0],01
			0x0F, 0x84, 0x00, 0x00, 0x00, 0x00,       // je dmc3.exe+22EC65
		};
		auto func = CreateFunction(0, (appBaseAddr + 0x22EC2E), false, true, sizeof(sect0));
		memcpy(func.sect0, sect0, sizeof(sect0));
		*reinterpret_cast<uint32 *>(func.sect0 + 9) = __builtin_offsetof(ActorData, newForceFiles) ;
		WriteAddress((func.sect0 + 0xE), (appBaseAddr + 0x22EC65), 6);
		PositionUpdateArtemisAddr = func.addr;
		/*
		dmc3.exe+22EC27 - 0FB6 82 9E3E0000 - movzx eax,byte ptr [rdx+00003E9E]
		dmc3.exe+22EC2E - 3C 07            - cmp al,07
		*/
	}

	// Weapon Switch Controller Dante
	{
		auto func = CreateFunction(WeaponSwitchController<ActorDataDante>, 0, true, false);
		WeaponSwitchControllerDanteAddr = func.addr;
	}

	// Weapon Switch Controller Vergil
	{
		auto func = CreateFunction(WeaponSwitchController<ActorDataVergil>, 0, true, false);
		WeaponSwitchControllerVergilAddr = func.addr;
	}

	// Activate Quicksilver
	{
		constexpr byte8 sect0[] =
		{
			0xC6, 0x87, 0x61, 0x63, 0x00, 0x00, 0x01, // mov byte ptr [rdi+00006361],01
		};
		constexpr byte8 sect1[] =
		{
			0x48, 0x8B, 0xCF ,
		};
		auto func = CreateFunction(ActivateQuicksilver, (appBaseAddr + 0x1E94B1), true, true, sizeof(sect0), sizeof(sect1));
		memcpy(func.sect0, sect0, sizeof(sect0));
		memcpy(func.sect1, sect1, sizeof(sect1));
		ActivateQuicksilverAddr = func.addr;
		/*
		dmc3.exe+1E94AA - C6 87 61630000 01       - mov byte ptr [rdi+00006361],01
		dmc3.exe+1E94B1 - C7 87 40630000 02000000 - mov [rdi+00006340],00000002
		*/
	}

	// Deactivate Quicksilver
	{
		constexpr byte8 sect0[] =
		{
			0x40, 0x88, 0xB7, 0x61, 0x63, 0x00, 0x00, // mov [rdi+00006361],sil
		};
		constexpr byte8 sect1[] =
		{
			0x48, 0x8B, 0xCF ,
		};
		auto func = CreateFunction(DeactivateQuicksilver, (appBaseAddr + 0x1E9558), true, true, sizeof(sect0), sizeof(sect1));
		memcpy(func.sect0, sect0, sizeof(sect0));
		memcpy(func.sect1, sect1, sizeof(sect1));
		DeactivateQuicksilverAddr[0] = func.addr;
		/*
		dmc3.exe+1E9551 - 40 88 B7 61630000 - mov [rdi+00006361],sil
		dmc3.exe+1E9558 - 89 B7 40630000    - mov [rdi+00006340],esi
		*/
	}
	{
		constexpr byte8 sect0[] =
		{
			0xC6, 0x81, 0x61, 0x63, 0x00, 0x00, 0x00, // mov byte ptr [rcx+00006361],00
		};
		auto func = CreateFunction(DeactivateQuicksilver, (appBaseAddr + 0x1EAC20), true, true, sizeof(sect0));
		memcpy(func.sect0, sect0, sizeof(sect0));
		DeactivateQuicksilverAddr[1] = func.addr;
		/*
		dmc3.exe+1EAC19 - C6 81 61630000 00       - mov byte ptr [rcx+00006361],00
		dmc3.exe+1EAC20 - C7 81 40630000 00000000 - mov [rcx+00006340],00000000
		*/
	}





	// Activate Doppelganger
	{
		constexpr byte8 sect0[] =
		{
			0xC7, 0x87, 0x54, 0x64, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, // mov [rdi+00006454],00000001
		};
		constexpr byte8 sect1[] =
		{
			0x48, 0x8B, 0xCF ,
		};
		auto func = CreateFunction(ActivateDoppelganger, (appBaseAddr + 0x1E930E), true, true, sizeof(sect0), sizeof(sect1));
		memcpy(func.sect0, sect0, sizeof(sect0));
		memcpy(func.sect1, sect1, sizeof(sect1));
		ActivateDoppelgangerAddr = func.addr;
		/*
		dmc3.exe+1E9235 - C7 87 54640000 01000000 - mov [rdi+00006454],00000001
		dmc3.exe+1E923F - 8B 88 EC010000          - mov ecx,[rax+000001EC]
		dmc3.exe+1E930E - B0 01                   - mov al,01
		*/
	}

	// Deactivate Doppelganger
	{
		constexpr byte8 sect0[] =
		{
			0xC7, 0x87, 0x54, 0x64, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, // mov [rdi+00006454],00000002
		};
		constexpr byte8 sect1[] =
		{
			0x48, 0x8B, 0xCF ,
		};
		auto func = CreateFunction(DeactivateDoppelganger, (appBaseAddr + 0x1E930E), true, true, sizeof(sect0), sizeof(sect1));
		memcpy(func.sect0, sect0, sizeof(sect0));
		memcpy(func.sect1, sect1, sizeof(sect1));
		DeactivateDoppelgangerAddr[0] = func.addr;
		/*
		dmc3.exe+1E933B - C7 87 54640000 02000000 - mov [rdi+00006454],00000002
		dmc3.exe+1E9345 - 8B 88 EC010000          - mov ecx,[rax+000001EC]
		dmc3.exe+1E930E - B0 01                   - mov al,01
		*/
	}
	{
		constexpr byte8 sect0[] =
		{
			0xC7, 0x87, 0x54, 0x64, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, // mov [rdi+00006454],00000002
		};
		constexpr byte8 sect1[] =
		{
			0x48, 0x8B, 0xCF ,
		};
		auto func = CreateFunction(DeactivateDoppelganger, (appBaseAddr + 0x1F8A00), true, true, sizeof(sect0), sizeof(sect1));
		memcpy(func.sect0, sect0, sizeof(sect0));
		memcpy(func.sect1, sect1, sizeof(sect1));
		DeactivateDoppelgangerAddr[1] = func.addr;
		/*
		dmc3.exe+1F89E9 - C7 87 54640000 02000000 - mov [rdi+00006454],00000002
		dmc3.exe+1F89F3 - 48 8B CF                - mov rcx,rdi
		dmc3.exe+1F8A00 - 80 BF 61630000 01       - cmp byte ptr [rdi+00006361],01
		*/
	}




























	// Devil Button Check
	{
		constexpr byte8 sect1[] =
		{
			0x48, 0x8B, 0xCF ,
		};
		constexpr byte8 sect2[] =
		{
			0x84, 0xC0,                               // test al,al
			0x0F, 0x84, 0x00, 0x00, 0x00, 0x00,       // je dmc3.exe+1E7926
			0x40, 0x38, 0xB7, 0x9B, 0x3E, 0x00, 0x00, // cmp [rdi+00003E9B],sil
		};
		auto func = CreateFunction(DevilButtonCheck, (appBaseAddr + 0x1E77E3), true, false, 0, sizeof(sect1), sizeof(sect2));
		memcpy(func.sect1, sect1, sizeof(sect1));
		memcpy(func.sect2, sect2, sizeof(sect2));
		WriteAddress((func.sect2 + 2), (appBaseAddr + 0x1E7926), 6);
		DevilButtonCheckAddr = func.addr;
		/*
		dmc3.exe+1E77DC - 40 38 B7 9B3E0000 - cmp [rdi+00003E9B],sil
		dmc3.exe+1E77E3 - 0F85 D4000000     - jne dmc3.exe+1E78BD
		dmc3.exe+1E7926 - 0F28 74 24 50     - movaps xmm6,[rsp+50]
		*/
	}


















	// Activate Devil
	{
		auto func = CreateFunction(ActivateDevil);
		ActivateDevilAddr = func.addr;
	}

	// Deactivate Devil
	{
		auto func = CreateFunction(DeactivateDevil);
		DeactivateDevilAddr = func.addr;
	}

	// Input Updates
	{
		constexpr byte8 sect0[] =
		{
			0x0F, 0xB6, 0x93, 0x00, 0x00, 0x00, 0x00, // movzx edx,byte ptr [rbx+0000B8C0]
			0xE8, 0x00, 0x00, 0x00, 0x00,             // call dmc3.exe+32CC70
			0x66, 0x23, 0x83, 0x00, 0x00, 0x00, 0x00, // and ax,[rbx+0000B8C0]
		};
		auto func = CreateFunction(0, (appBaseAddr + 0x1EBD32), false, true, sizeof(sect0));
		memcpy(func.sect0, sect0, sizeof(sect0));
		*reinterpret_cast<uint32 *>(func.sect0 + 3) = __builtin_offsetof(ActorData, newGamepad) ;
		WriteCall((func.sect0 + 7), (appBaseAddr + 0x32CC70));
		*reinterpret_cast<uint32 *>(func.sect0 + 0xF) = __builtin_offsetof(ActorData, newButtonMask) ;
		InputUpdateAddr[0] = func.addr;
		/*
		dmc3.exe+1EBD2D - E8 3E0F1400 - call dmc3.exe+32CC70
		dmc3.exe+1EBD32 - 33 D2       - xor edx,edx
		*/
	}
	{
		constexpr byte8 sect0[] =
		{
			0x0F, 0xB6, 0x93, 0x00, 0x00, 0x00, 0x00, // movzx edx,byte ptr [rbx+0000B8C0]
			0xE8, 0x00, 0x00, 0x00, 0x00,             // call dmc3.exe+32CC80
			0x66, 0x23, 0x83, 0x00, 0x00, 0x00, 0x00, // and ax,[rbx+0000B8C0]
		};
		auto func = CreateFunction(0, (appBaseAddr + 0x1EBD47), false, true, sizeof(sect0));
		memcpy(func.sect0, sect0, sizeof(sect0));
		*reinterpret_cast<uint32 *>(func.sect0 + 3) = __builtin_offsetof(ActorData, newGamepad) ;
		WriteCall((func.sect0 + 7), (appBaseAddr + 0x32CC80));
		*reinterpret_cast<uint32 *>(func.sect0 + 0xF) = __builtin_offsetof(ActorData, newButtonMask) ;
		InputUpdateAddr[1] = func.addr;
		/*
		dmc3.exe+1EBD42 - E8 390F1400      - call dmc3.exe+32CC80
		dmc3.exe+1EBD47 - 0FB7 93 E0740000 - movzx edx,word ptr [rbx+000074E0]
		*/
	}
	{
		constexpr byte8 sect0[] =
		{
			0x66, 0x23, 0x8B, 0x00, 0x00, 0x00, 0x00, //and cx,[rbx+0000B8C0]
			0x66, 0x89, 0x8B, 0xE4, 0x74, 0x00, 0x00, //mov [rbx+000074E4],cx
		};
		auto func = CreateFunction(0, (appBaseAddr + 0x1EBD6B), false, true, sizeof(sect0));
		memcpy(func.sect0, sect0, sizeof(sect0));
		*reinterpret_cast<uint32 *>(func.sect0 + 3) = __builtin_offsetof(ActorData, newButtonMask) ;
		InputUpdateAddr[2] = func.addr;
		/*
		dmc3.exe+1EBD64 - 66 89 8B E4740000 - mov [rbx+000074E4],cx
		dmc3.exe+1EBD6B - 66 23 D0          - and dx,ax
		*/
	}
	{
		constexpr byte8 sect0[] =
		{
			0x66, 0x23, 0x93, 0x00, 0x00, 0x00, 0x00, //and dx,[rbx+0000B8C0]
			0x66, 0x89, 0x93, 0xE6, 0x74, 0x00, 0x00, //mov [rbx+000074E6],dx
		};
		auto func = CreateFunction(0, (appBaseAddr + 0x1EBD7C), false, true, sizeof(sect0));
		memcpy(func.sect0, sect0, sizeof(sect0));
		*reinterpret_cast<uint32 *>(func.sect0 + 3) = __builtin_offsetof(ActorData, newButtonMask) ;
		InputUpdateAddr[3] = func.addr;
		/*
		dmc3.exe+1EBD75 - 66 89 93 E6740000 - mov [rbx+000074E6],dx
		dmc3.exe+1EBD7C - 33 D2             - xor edx,edx
		*/
	}
	{
		constexpr byte8 sect0[] =
		{
			0x0F, 0xB6, 0x93, 0x00, 0x00, 0x00, 0x00, // movzx edx,byte ptr [rbx+0000B8C0]
			0xE8, 0x00, 0x00, 0x00, 0x00,             // call dmc3.exe+32CC10
			0x80, 0xBB, 0x00, 0x00, 0x00, 0x00, 0x01, // cmp byte ptr [rbx+0000B8C0],01
			0x74, 0x03,                               // je short
			0x66, 0x31, 0xC0,                         // xor ax,ax
		};
		auto func = CreateFunction(0, (appBaseAddr + 0x1EBD83), false, true, sizeof(sect0));
		memcpy(func.sect0, sect0, sizeof(sect0));
		*reinterpret_cast<uint32 *>(func.sect0 + 3) = __builtin_offsetof(ActorData, newGamepad) ;
		WriteCall((func.sect0 + 7), (appBaseAddr + 0x32CC10));
		*reinterpret_cast<uint32 *>(func.sect0 + 0xE) = __builtin_offsetof(ActorData, newEnableRightStick) ;
		InputUpdateAddr[4] = func.addr;
		/*
		dmc3.exe+1EBD7E - E8 8D0E1400 - call dmc3.exe+32CC10
		dmc3.exe+1EBD83 - 33 D2       - xor edx,edx
		*/
	}
	{
		constexpr byte8 sect0[] =
		{
			0x0F, 0xB6, 0x93, 0x00, 0x00, 0x00, 0x00, // movzx edx,byte ptr [rbx+0000B8C0]
			0xE8, 0x00, 0x00, 0x00, 0x00,             // call dmc3.exe+32CC10
			0x80, 0xBB, 0x00, 0x00, 0x00, 0x00, 0x01, // cmp byte ptr [rbx+0000B8C0],01
			0x74, 0x03,                               // je short
			0x66, 0x31, 0xC0,                         // xor ax,ax
		};
		auto func = CreateFunction(0, (appBaseAddr + 0x1EBD9C), false, true, sizeof(sect0));
		memcpy(func.sect0, sect0, sizeof(sect0));
		*reinterpret_cast<uint32 *>(func.sect0 + 3) = __builtin_offsetof(ActorData, newGamepad) ;
		WriteCall((func.sect0 + 7), (appBaseAddr + 0x32CC10));
		*reinterpret_cast<uint32 *>(func.sect0 + 0xE) = __builtin_offsetof(ActorData, newEnableLeftStick) ;
		InputUpdateAddr[5] = func.addr;
		/*
		dmc3.exe+1EBD97 - E8 740E1400 - call dmc3.exe+32CC10
		dmc3.exe+1EBD9C - 45 33 C0    - xor r8d,r8d
		*/
	}
	{
		constexpr byte8 sect0[] =
		{
			0x0F, 0xB6, 0x93, 0x00, 0x00, 0x00, 0x00, // movzx edx,byte ptr [rbx+0000B8C0]
			0xE8, 0x00, 0x00, 0x00, 0x00,             // call dmc3.exe+32CC50
			0x80, 0xBB, 0x00, 0x00, 0x00, 0x00, 0x01, // cmp byte ptr [rbx+0000B8C0],01
			0x74, 0x03,                               // je short
			0x66, 0x31, 0xC0,                         // xor ax,ax
		};
		auto func = CreateFunction(0, (appBaseAddr + 0x1EBDB4), false, true, sizeof(sect0));
		memcpy(func.sect0, sect0, sizeof(sect0));
		*reinterpret_cast<uint32 *>(func.sect0 + 3) = __builtin_offsetof(ActorData, newGamepad) ;
		WriteCall((func.sect0 + 7), (appBaseAddr + 0x32CC50));
		*reinterpret_cast<uint32 *>(func.sect0 + 0xE) = __builtin_offsetof(ActorData, newEnableRightStick) ;
		InputUpdateAddr[6] = func.addr;
		/*
		dmc3.exe+1EBDAF - E8 9C0E1400 - call dmc3.exe+32CC50
		dmc3.exe+1EBDB4 - 33 D2       - xor edx,edx
		*/
	}
	{
		constexpr byte8 sect0[] =
		{
			0x0F, 0xB6, 0x93, 0x00, 0x00, 0x00, 0x00, // movzx edx,byte ptr [rbx+0000B8C0]
			0xE8, 0x00, 0x00, 0x00, 0x00,             // call dmc3.exe+32CC50
			0x80, 0xBB, 0x00, 0x00, 0x00, 0x00, 0x01, // cmp byte ptr [rbx+0000B8C0],01
			0x74, 0x03,                               // je short
			0x66, 0x31, 0xC0,                         // xor ax,ax
		};
		auto func = CreateFunction(0, (appBaseAddr + 0x1EBE9D), false, true, sizeof(sect0));
		memcpy(func.sect0, sect0, sizeof(sect0));
		*reinterpret_cast<uint32 *>(func.sect0 + 3) = __builtin_offsetof(ActorData, newGamepad) ;
		WriteCall((func.sect0 + 7), (appBaseAddr + 0x32CC50));
		*reinterpret_cast<uint32 *>(func.sect0 + 0xE) = __builtin_offsetof(ActorData, newEnableLeftStick) ;
		InputUpdateAddr[7] = func.addr;
		/*
		dmc3.exe+1EBE98 - E8 B30D1400       - call dmc3.exe+32CC50
		dmc3.exe+1EBE9D - 66 89 83 0A750000 - mov [rbx+0000750A],ax
		*/
	}
	{
		constexpr byte8 sect0[] =
		{
			0xE8, 0x00, 0x00, 0x00, 0x00, // call dmc3.exe+2ACD0
			0x44, 0x8B, 0xC7,             // mov r8d,edi
		};
		auto func = CreateFunction(0, (appBaseAddr + 0x2AFC6), false, true, sizeof(sect0));
		memcpy(func.sect0, sect0, sizeof(sect0));
		WriteCall(func.sect0, (appBaseAddr + 0x2ACD0));
		InputUpdateAddr[8] = func.addr;
		/*
		dmc3.exe+2AFA5 - E8 26FDFFFF - call dmc3.exe+2ACD0
		dmc3.exe+2AFC6 - 49 6B C8 2C - imul rcx,r8,2C
		*/
	}



	// Ebony & Ivory Rain Storm Check
	{
		constexpr byte8 sect1[] =
		{
			0x48, 0x8B, 0xCB ,
		};
		constexpr byte8 sect2[] =
		{
			0x84, 0xC0,                         // test al,al
			0x0F, 0x84, 0x00, 0x00, 0x00, 0x00, // je dmc3.exe+20CC14
		};
		auto func = CreateFunction(EbonyIvoryRainStormCheck, (appBaseAddr + 0x20CC20), true, false, 0, sizeof(sect1), sizeof(sect2));
		memcpy(func.sect1, sect1, sizeof(sect1));
		memcpy(func.sect2, sect2, sizeof(sect2));
		WriteAddress((func.sect2 + 2), (appBaseAddr + 0x20CC14), 6);
		EbonyIvoryRainStormCheckAddr = func.addr;
		/*
		dmc3.exe+20CC0F - 0FA3 C1             - bt ecx,eax
		dmc3.exe+20CC12 - 72 0C               - jb dmc3.exe+20CC20
		dmc3.exe+20CC14 - BF 01000000         - mov edi,00000001
		dmc3.exe+20CC20 - F3 0F10 83 383E0000 - movss xmm0,[rbx+00003E38]
		*/
	}

	// Dot Shadow Check
	{
		constexpr byte8 sect2[] =
		{
			0x84, 0xC0,             // test al,al
			0x74, 0x01,             // je short
			0xC3,                   // ret
			0x40, 0x53,             // push rbx
			0x48, 0x83, 0xEC, 0x20, // sub rsp,20
		};
		auto func = CreateFunction(DotShadowCheck, (appBaseAddr + 0x93D66), true, false, 0, 0, sizeof(sect2));
		memcpy(func.sect2, sect2, sizeof(sect2));
		DotShadowCheckAddr = func.addr;
		/*
		dmc3.exe+93D60 - 40 53       - push rbx
		dmc3.exe+93D62 - 48 83 EC 20 - sub rsp,20
		dmc3.exe+93D66 - 48 8B D9    - mov rbx,rcx
		*/
	}

	// Reset Actor Mode
	{
		constexpr byte8 sect0[] =
		{
			0x48, 0x8B, 0x5C, 0x24, 0x50, // mov rbx,[rsp+50]
		};
		auto func = CreateFunction(ResetActorMode, (appBaseAddr + 0x1E14E6), true, true, sizeof(sect0));
		memcpy(func.sect0, sect0, sizeof(sect0));
		ResetActorModeAddr = func.addr;
		/*
		dmc3.exe+1E14E1 - 48 8B 5C 24 50 - mov rbx,[rsp+50]
		dmc3.exe+1E14E6 - 48 83 C4 40    - add rsp,40
		*/
	}






	// Collision Check
	{
		constexpr byte8 sect2[] =
		{
			0x84, 0xC0,                   // test al,al
			0x74, 0x01,                   // je short
			0xC3,                         // ret
			0x48, 0x89, 0x5C, 0x24, 0x08, // mov [rsp+08],rbx
		};
		auto func = CreateFunction(CollisionCheck, (appBaseAddr + 0x5C325), true, false, 0, 0, sizeof(sect2));
		memcpy(func.sect2, sect2, sizeof(sect2));
		CollisionCheckAddr = func.addr;
		/*
		dmc3.exe+5C320 - 48 89 5C 24 08 - mov [rsp+08],rbx
		dmc3.exe+5C325 - 48 89 74 24 10 - mov [rsp+10],rsi
		*/
	}





	// Reset Visibility Air Trick Dante
	{
		constexpr byte8 sect0[] =
		{
			0x89, 0x8F, 0x20, 0x01, 0x00, 0x00, // mov [rdi+00000120],ecx
		};
		constexpr byte8 sect1[] =
		{
			0x48, 0x8B, 0xCF ,
		};
		auto func = CreateFunction(ResetVisibility, (appBaseAddr + 0x1F1F32), true, true, sizeof(sect0), sizeof(sect1));
		memcpy(func.sect0, sect0, sizeof(sect0));
		memcpy(func.sect1, sect1, sizeof(sect1));
		ResetVisibilityAddr[0] = func.addr;
		/*
		dmc3.exe+1F1F2C - 89 8F 20010000 - mov [rdi+00000120],ecx
		dmc3.exe+1F1F32 - 48 8B CF       - mov rcx,rdi
		*/
	}

	// Reset Visibility Air Trick Vergil, Trick Up & Trick Down
	{
		constexpr byte8 sect0[] =
		{
			0x89, 0xBB, 0x20, 0x01, 0x00, 0x00, // mov [rbx+00000120],edi
		};
		constexpr byte8 sect1[] =
		{
			0x48, 0x8B, 0xCB ,
		};
		auto func = CreateFunction(ResetVisibility, (appBaseAddr + 0x1F0724), true, true, sizeof(sect0), sizeof(sect1));
		memcpy(func.sect0, sect0, sizeof(sect0));
		memcpy(func.sect1, sect1, sizeof(sect1));
		ResetVisibilityAddr[1] = func.addr;
		/*
		dmc3.exe+1F071E - 89 BB 20010000    - mov [rbx+00000120],edi
		dmc3.exe+1F0724 - 66 39 BB 1A3E0000 - cmp [rbx+00003E1A],di
		*/
	}









	// Enable Visibility Check
	{
		constexpr byte8 sect0[] =
		{
			0x48, 0x8B, 0xD9,                         // mov rbx,rcx
			0x80, 0xB9, 0x00, 0x00, 0x00, 0x00, 0x01, // cmp byte ptr [rcx+0000B8C0],01
			0x0F, 0x85, 0x00, 0x00, 0x00, 0x00,       // jne dmc3.exe+1DFD56
			0x83, 0xB9, 0x20, 0x01, 0x00, 0x00, 0x00, // cmp dword ptr [rcx+00000120],00
			0x0F, 0x84, 0x00, 0x00, 0x00, 0x00,       // je dmc3.exe+1DFD56
		};
		auto func = CreateFunction(0, (appBaseAddr + 0x1DFD22), false, true, sizeof(sect0));
		memcpy(func.sect0, sect0, sizeof(sect0));
		*reinterpret_cast<uint32 *>(func.sect0 + 5) = __builtin_offsetof(ActorData, newEnableVisibility) ;
		WriteAddress((func.sect0 + 0xA), (appBaseAddr + 0x1DFD56), 6);
		WriteAddress((func.sect0 + 0x17), (appBaseAddr + 0x1DFD56), 6);
		EnableVisibilityCheckAddr[0] = func.addr;
		/*
		dmc3.exe+1DFD16 - 83 B9 20010000 00 - cmp dword ptr [rcx+00000120],00
		dmc3.exe+1DFD1D - 48 8B D9          - mov rbx,rcx
		dmc3.exe+1DFD20 - 74 34             - je dmc3.exe+1DFD56
		dmc3.exe+1DFD22 - 48 63 81 6C3E0000 - movsxd rax,dword ptr [rcx+00003E6C]
		*/
	}
	{
		constexpr byte8 sect0[] =
		{
			0x80, 0xB8, 0x00, 0x00, 0x00, 0x00, 0x01, // cmp byte ptr [rax+0000B8C0],01
			0x0F, 0x85, 0x00, 0x00, 0x00, 0x00,       // jne dmc3.exe+1FDE7F
			0x83, 0xB8, 0x20, 0x01, 0x00, 0x00, 0x00, // cmp dword ptr [rax+00000120],00
			0x0F, 0x84, 0x00, 0x00, 0x00, 0x00,       // je dmc3.exe+1FDE7F
		};
		auto func = CreateFunction(0, (appBaseAddr + 0x1FDE29), false, true, sizeof(sect0));
		memcpy(func.sect0, sect0, sizeof(sect0));
		*reinterpret_cast<uint32 *>(func.sect0 + 2) = __builtin_offsetof(ActorData, newEnableVisibility) ;
		WriteAddress((func.sect0 + 7), (appBaseAddr + 0x1FDE7F), 6);
		WriteAddress((func.sect0 + 0x14), (appBaseAddr + 0x1FDE7F), 6);
		EnableVisibilityCheckAddr[1] = func.addr;
		/*
		dmc3.exe+1FDE20 - 83 B8 20010000 00 - cmp dword ptr [rax+00000120],00
		dmc3.exe+1FDE27 - 74 56             - je dmc3.exe+1FDE7F
		dmc3.exe+1FDE29 - 48 89 5C 24 30    - mov [rsp+30],rbx
		*/
	}




	// Play Quicksilver Motion
	{
		auto func = CreateFunction(PlayQuicksilverMotion, (appBaseAddr + 0x1F63B7));
		PlayQuicksilverMotionAddr[0] = func.addr;
		/*
		dmc3.exe+1F63B2 - E8 D997FFFF - call dmc3.exe+1EFB90
		dmc3.exe+1F63B7 - BA 01000000 - mov edx,00000001
		*/
	}
	{
		auto func = CreateFunction(PlayQuicksilverMotion, (appBaseAddr + 0x1F63DB));
		PlayQuicksilverMotionAddr[1] = func.addr;
		/*
		dmc3.exe+1F63D6 - E8 B597FFFF    - call dmc3.exe+1EFB90
		dmc3.exe+1F63DB - FE 83 103E0000 - inc byte ptr [rbx+00003E10]
		*/
	}





	// // Magic Points Run Out
	// {
	// 	constexpr byte8 sect0[] =
	// 	{
	// 		0xC7, 0x81, 0xB8, 0x3E, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // mov [rcx+00003EB8],00000000
	// 	};
	// 	auto func = CreateFunction(MagicPointsRunOut, (appBaseAddr + 0x1E1860), true, true, sizeof(sect0));
	// 	memcpy(func.sect0, sect0, sizeof(sect0));
	// 	MagicPointsRunOutAddr = func.addr;
	// 	/*
	// 	dmc3.exe+1E1856 - C7 81 B83E0000 00000000 - mov [rcx+00003EB8],00000000
	// 	dmc3.exe+1E1860 - F3 0F10 81 B83E0000     - movss xmm0,[rcx+00003EB8]
	// 	*/
	// }



















	// // Summoned Swords Quicksilver Check
	// {
	// 	constexpr byte8 sect0[] =
	// 	{
	// 		0x48, 0xB8, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // mov rax
	// 		0x8A, 0x00,                                                 // mov al,[rax]
	// 		0x84, 0xC0,                                                 // test al,al
	// 		0x75, 0x05,                                                 // jne short
	// 		0xF3, 0x0F, 0x5C, 0x43, 0x14,                               // subss xmm0,[rbx+14]
	// 	};
	// 	auto func = CreateFunction(0, (appBaseAddr + 0x1DB8FD), false, true, sizeof(sect0));
	// 	memcpy(func.sect0, sect0, sizeof(sect0));
	// 	*reinterpret_cast<bool **>(func.sect0 + 2) = &g_quicksilver;
	// 	SummonedSwordsQuicksilverCheckAddr = func.addr;
	// 	/*
	// 	dmc3.exe+1DB8F8 - F3 0F5C 43 14 - subss xmm0,[rbx+14]
	// 	dmc3.exe+1DB8FD - 0F2F F0       - comiss xmm6,xmm0
	// 	*/
	// }


	run = true;
}

// @Todo: Remove.
export void Actor_MiniToggle(bool enable)
{
	LogFunctionHelper(__FUNCTION__, enable) ;

	// Actor Data Size
	{
		constexpr uint32 size = (128 * 1024);
		// Dante
		Write<uint32>((appBaseAddr + 0x1DEBE1 + 1), (enable) ? size : ACTOR_DATA_SIZE_DANTE); // dmc3.exe+1DEBE1 - BA C0B80000 - mov edx,0000B8C0
		// Bob
		Write<uint32>((appBaseAddr + 0x1DEAC8 + 1), (enable) ? size : ACTOR_DATA_SIZE_BOB); // dmc3.exe+1DEAC8 - BA 80B60000 - mov edx,0000B680
		// Lady
		Write<uint32>((appBaseAddr + 0x1DE9CC + 1), (enable) ? size : ACTOR_DATA_SIZE_LADY); // dmc3.exe+1DE9CC - BA 80820000 - mov edx,00008280
		// Vergil
		Write<uint32>((appBaseAddr + 0x1DE8B3 + 1), (enable) ? size : ACTOR_DATA_SIZE_VERGIL); // dmc3.exe+1DE8B3 - BA C0B80000 - mov edx,0000B8C0
	}

	ToggleRelocations           (enable);
	ToggleModelCountAdjustments (enable);
	ToggleWeaponCountAdjustments(enable);

	// Update Model Dante
	{
		auto dest = (appBaseAddr + 0x212CB3);
		if (enable)
		{
			WriteCall(dest, UpdateModelDanteAddr);
		}
		else
		{
			WriteCall(dest, (appBaseAddr + 0x214D50));
		}
		/*
		dmc3.exe+212CB3 - E8 98200000       - call dmc3.exe+214D50
		dmc3.exe+212CB8 - 48 8D 86 A0380000 - lea rax,[rsi+000038A0]
		*/
	}
}




export void Actor_Toggle(bool enable)
{
	LogFunctionHelper(__FUNCTION__, enable) ;





	ToggleRelocations           (enable);
	ToggleModelCountAdjustments (enable);
	ToggleWeaponCountAdjustments(enable);



	ToggleEffectRelocations(enable);




	ToggleMainActorFixes        (enable);
	ToggleStyleFixes            (enable);
	ToggleIsWeaponReady         (enable);
	ToggleMobility              (enable);
	ToggleSpeed                 (enable);




	ToggleFixWeaponShadows(enable);

	ToggleFixDevilAura(enable);








	// Actor Data Size
	{
		constexpr uint32 size = (128 * 1024);
		// Dante
		Write<uint32>((appBaseAddr + 0x1DEBE1 + 1), (enable) ? size : ACTOR_DATA_SIZE_DANTE); // dmc3.exe+1DEBE1 - BA C0B80000 - mov edx,0000B8C0
		// Bob
		Write<uint32>((appBaseAddr + 0x1DEAC8 + 1), (enable) ? size : ACTOR_DATA_SIZE_BOB); // dmc3.exe+1DEAC8 - BA 80B60000 - mov edx,0000B680
		// Lady
		Write<uint32>((appBaseAddr + 0x1DE9CC + 1), (enable) ? size : ACTOR_DATA_SIZE_LADY); // dmc3.exe+1DE9CC - BA 80820000 - mov edx,00008280
		// Vergil
		Write<uint32>((appBaseAddr + 0x1DE8B3 + 1), (enable) ? size : ACTOR_DATA_SIZE_VERGIL); // dmc3.exe+1DE8B3 - BA C0B80000 - mov edx,0000B8C0
	}

	// Model Physics Metadata Pool Offsets
	{
		auto off = reinterpret_cast<byte8 *>(modelPhysicsMetadataPoolOff);
		auto defaultOff = (appBaseAddr + 0x4E0328);
		WriteAddress((appBaseAddr + 0x1FA60B), (enable) ? off : defaultOff, 7); // dmc3.exe+1FA60B - 48 8D 0D 165D2E00 - lea rcx,[dmc3.exe+4E0328]
		WriteAddress((appBaseAddr + 0x1FAA57), (enable) ? off : defaultOff, 7); // dmc3.exe+1FAA57 - 48 8D 0D CA582E00 - lea rcx,[dmc3.exe+4E0328]
		WriteAddress((appBaseAddr + 0x1FAA77), (enable) ? off : defaultOff, 7); // dmc3.exe+1FAA77 - 48 8D 15 AA582E00 - lea rdx,[dmc3.exe+4E0328]
		WriteAddress((appBaseAddr + 0x1FAA97), (enable) ? off : defaultOff, 7); // dmc3.exe+1FAA97 - 4C 8D 05 8A582E00 - lea r8,[dmc3.exe+4E0328]
		WriteAddress((appBaseAddr + 0x1FB031), (enable) ? off : defaultOff, 7); // dmc3.exe+1FB031 - 48 8D 3D F0522E00 - lea rdi,[dmc3.exe+4E0328]
		WriteAddress((appBaseAddr + 0x1FBAC4), (enable) ? off : defaultOff, 7); // dmc3.exe+1FBAC4 - 48 8D 3D 5D482E00 - lea rdi,[dmc3.exe+4E0328]
	}

	// Update Model Dante
	{
		auto dest = (appBaseAddr + 0x212CB3);
		if (enable)
		{
			WriteCall(dest, UpdateModelDanteAddr);
		}
		else
		{
			WriteCall(dest, (appBaseAddr + 0x214D50));
		}
		/*
		dmc3.exe+212CB3 - E8 98200000       - call dmc3.exe+214D50
		dmc3.exe+212CB8 - 48 8D 86 A0380000 - lea rax,[rsi+000038A0]
		*/
	}

	// Update Model Vergil
	{
		auto dest = (appBaseAddr + 0x220A30);
		if (enable)
		{
			WriteCall(dest, UpdateModelVergilAddr);
		}
		else
		{
			WriteCall(dest, (appBaseAddr + 0x221FE0));
		}
		/*
		dmc3.exe+220A30 - E8 AB150000          - call dmc3.exe+221FE0
		dmc3.exe+220A35 - 49 8D 84 24 A0380000 - lea rax,[r12+000038A0]
		*/
	}

	// Update Model Partitions Dante
	{
		auto dest = (appBaseAddr + 0x215577);
		if (enable)
		{
			SetMemory(dest, 0x90, 5, MemoryFlags_VirtualProtectDestination);
		}
		else
		{
			WriteCall(dest, (appBaseAddr + 0x2169F0));
		}
		/*
		dmc3.exe+215577 - E8 74140000       - call dmc3.exe+2169F0
		dmc3.exe+21557C - 48 81 C7 40750000 - add rdi,00007540
		*/
	}

	// Update Model Partitions Vergil
	{
		auto dest = (appBaseAddr + 0x22285C);
		if (enable)
		{
			SetMemory(dest, 0x90, 5, MemoryFlags_VirtualProtectDestination);
		}
		else
		{
			WriteCall(dest, (appBaseAddr + 0x223420));
		}
		/*
		dmc3.exe+22285C - E8 BF0B0000       - call dmc3.exe+223420
		dmc3.exe+222861 - 48 8D B7 40750000 - lea rsi,[rdi+00007540]
		*/
	}

	// Coat Update Dante
	{
		auto dest = (appBaseAddr + 0x2120C4);
		if (enable)
		{
			WriteJump(dest, CoatUpdateDanteAddr, 2);
		}
		else
		{
			constexpr byte8 buffer[] =
			{
				0x48, 0x8B, 0x96, 0x98, 0x18, 0x00, 0x00, // mov rdx,[rsi+00001898]
			};
			CopyMemory(dest, buffer, sizeof(buffer), MemoryFlags_VirtualProtectDestination);
		}
		/*
		dmc3.exe+2120C4 - 48 8B 96 98180000 - mov rdx,[rsi+00001898]
		dmc3.exe+2120CB - 48 8D 8E 40750000 - lea rcx,[rsi+00007540]
		*/
	}

	// Coat Update Vergil
	{
		auto dest = (appBaseAddr + 0x220506);
		if (enable)
		{
			WriteJump(dest, CoatUpdateVergilAddr, 2);
		}
		else
		{
			constexpr byte8 buffer[] =
			{
				0x48, 0x8B, 0x96, 0x98, 0x18, 0x00, 0x00, // mov rdx,[rsi+00001898]
			};
			CopyMemory(dest, buffer, sizeof(buffer), MemoryFlags_VirtualProtectDestination);
		}
		/*
		dmc3.exe+220506 - 48 8B 96 98180000 - mov rdx,[rsi+00001898]
		dmc3.exe+22050D - 48 8D 8E 40750000 - lea rcx,[rsi+00007540]
		*/
	}

	// Devil Coat Update Ignore Range Check
	{
		WriteAddress((appBaseAddr + 0x218982), (enable) ? (appBaseAddr + 0x218988) : (appBaseAddr + 0x218F81), 6);
		/*
		dmc3.exe+218982 - 0F87 F9050000     - ja dmc3.exe+218F81
		dmc3.exe+218988 - 83 BF 183A0000 01 - cmp dword ptr [rdi+00003A18],01
		*/
	}

	// Position Update Ebony & Ivory
	{
		auto dest = (appBaseAddr + 0x22B60F);
		if (enable)
		{
			WriteJump(dest, PositionUpdateEbonyIvoryAddr, 2);
		}
		else
		{
			constexpr byte8 buffer[] =
			{
				0x0F, 0xB6, 0x90, 0x9E, 0x3E, 0x00, 0x00, // movzx edx,byte ptr [rax+00003E9E]
			};
			CopyMemory(dest, buffer, sizeof(buffer), MemoryFlags_VirtualProtectDestination);
		}
		/*
		dmc3.exe+22B60F - 0FB6 90 9E3E0000 - movzx edx,byte ptr [rax+00003E9E]
		dmc3.exe+22B616 - 8D 42 FD         - lea eax,[rdx-03]
		*/
	}

	// Position Update Artemis
	{
		auto dest = (appBaseAddr + 0x22EC27);
		if (enable)
		{
			WriteJump(dest, PositionUpdateArtemisAddr, 2);
		}
		else
		{
			constexpr byte8 buffer[] =
			{
				0x0F, 0xB6, 0x82, 0x9E, 0x3E, 0x00, 0x00, // movzx eax,byte ptr [rdx+00003E9E]
			};
			CopyMemory(dest, buffer, sizeof(buffer), MemoryFlags_VirtualProtectDestination);
		}
		/*
		dmc3.exe+22EC27 - 0FB6 82 9E3E0000 - movzx eax,byte ptr [rdx+00003E9E]
		dmc3.exe+22EC2E - 3C 07            - cmp al,07
		*/
	}

	// Weapon Switch Controller Dante
	{
		auto dest = (appBaseAddr + 0x1E25EB);
		if (enable)
		{
			WriteCall(dest, WeaponSwitchControllerDanteAddr);
		}
		else
		{
			WriteCall(dest, (appBaseAddr + 0x1EA8E0));
		}
		/*
		dmc3.exe+1E25EB - E8 F0820000 - call dmc3.exe+1EA8E0
		dmc3.exe+1E25F0 - 48 8B CB    - mov rcx,rbx
		*/
	}

	// Weapon Switch Controller Vergil
	{
		auto dest = (appBaseAddr + 0x1E25E1);
		if (enable)
		{
			WriteCall(dest, WeaponSwitchControllerVergilAddr);
		}
		else
		{
			WriteCall(dest, (appBaseAddr + 0x1E6DD0));
		}
		/*
		dmc3.exe+1E25E1 - E8 EA470000 - call dmc3.exe+1E6DD0
		dmc3.exe+1E25E6 - EB 08       - jmp dmc3.exe+1E25F0
		*/
	}

	// Activate Quicksilver
	{
		auto dest = (appBaseAddr + 0x1E94AA);
		if (enable)
		{
			WriteJump(dest, ActivateQuicksilverAddr, 2);
		}
		else
		{
			constexpr byte8 buffer[] =
			{
				0xC6, 0x87, 0x61, 0x63, 0x00, 0x00, 0x01, // mov byte ptr [rdi+00006361],01
			};
			CopyMemory(dest, buffer, sizeof(buffer), MemoryFlags_VirtualProtectDestination);
		}
		/*
		dmc3.exe+1E94AA - C6 87 61630000 01       - mov byte ptr [rdi+00006361],01
		dmc3.exe+1E94B1 - C7 87 40630000 02000000 - mov [rdi+00006340],00000002
		*/
	}

	// Deactivate Quicksilver
	{
		auto dest = (appBaseAddr + 0x1E9551);
		if (enable)
		{
			WriteJump(dest, DeactivateQuicksilverAddr[0], 2);
		}
		else
		{
			constexpr byte8 buffer[] =
			{
				0x40, 0x88, 0xB7, 0x61, 0x63, 0x00, 0x00, // mov [rdi+00006361],sil
			};
			CopyMemory(dest, buffer, sizeof(buffer), MemoryFlags_VirtualProtectDestination);
		}
		/*
		dmc3.exe+1E9551 - 40 88 B7 61630000 - mov [rdi+00006361],sil
		dmc3.exe+1E9558 - 89 B7 40630000    - mov [rdi+00006340],esi
		*/
	}
	{
		auto dest = (appBaseAddr + 0x1EAC19);
		if (enable)
		{
			WriteJump(dest, DeactivateQuicksilverAddr[1], 2);
		}
		else
		{
			constexpr byte8 buffer[] =
			{
				0xC6, 0x81, 0x61, 0x63, 0x00, 0x00, 0x00, // mov byte ptr [rcx+00006361],00
			};
			CopyMemory(dest, buffer, sizeof(buffer), MemoryFlags_VirtualProtectDestination);
		}
		/*
		dmc3.exe+1EAC19 - C6 81 61630000 00       - mov byte ptr [rcx+00006361],00
		dmc3.exe+1EAC20 - C7 81 40630000 00000000 - mov [rcx+00006340],00000000
		*/
	}







	// Activate Doppelganger
	{
		auto dest = (appBaseAddr + 0x1E9235);
		if (enable)
		{
			WriteJump(dest, ActivateDoppelgangerAddr, 5);
		}
		else
		{
			constexpr byte8 buffer[] =
			{
				0xC7, 0x87, 0x54, 0x64, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, // mov [rdi+00006454],00000001
			};
			CopyMemory(dest, buffer, sizeof(buffer), MemoryFlags_VirtualProtectDestination);
		}
		/*
		dmc3.exe+1E9235 - C7 87 54640000 01000000 - mov [rdi+00006454],00000001
		dmc3.exe+1E923F - 8B 88 EC010000          - mov ecx,[rax+000001EC]
		dmc3.exe+1E930E - B0 01                   - mov al,01
		*/
	}

	// Deactivate Doppelganger
	{
		auto dest = (appBaseAddr + 0x1E933B);
		if (enable)
		{
			WriteJump(dest, DeactivateDoppelgangerAddr[0], 5);
		}
		else
		{
			constexpr byte8 buffer[] =
			{
				0xC7, 0x87, 0x54, 0x64, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, // mov [rdi+00006454],00000002
			};
			CopyMemory(dest, buffer, sizeof(buffer), MemoryFlags_VirtualProtectDestination);
		}
		/*
		dmc3.exe+1E933B - C7 87 54640000 02000000 - mov [rdi+00006454],00000002
		dmc3.exe+1E9345 - 8B 88 EC010000          - mov ecx,[rax+000001EC]
		dmc3.exe+1E930E - B0 01                   - mov al,01
		*/
	}
	{
		auto dest = (appBaseAddr + 0x1F89E9);
		if (enable)
		{
			WriteJump(dest, DeactivateDoppelgangerAddr[1], 5);
		}
		else
		{
			constexpr byte8 buffer[] =
			{
				0xC7, 0x87, 0x54, 0x64, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, // mov [rdi+00006454],00000002
			};
			CopyMemory(dest, buffer, sizeof(buffer), MemoryFlags_VirtualProtectDestination);
		}
		/*
		dmc3.exe+1F89E9 - C7 87 54640000 02000000 - mov [rdi+00006454],00000002
		dmc3.exe+1F89F3 - 48 8B CF                - mov rcx,rdi
		dmc3.exe+1F8A00 - 80 BF 61630000 01       - cmp byte ptr [rdi+00006361],01
		*/
	}

















	// Disable Doppelganger Rate Controller
	{
		Write<byte8>((appBaseAddr + 0x1E25C8), (enable) ? 0xEB : 0x75);
		/*
		dmc3.exe+1E25C1 - 80 BB 62630000 01 - cmp byte ptr [rbx+00006362],01
		dmc3.exe+1E25C8 - 75 08             - jne dmc3.exe+1E25D2
		*/
	}

	// Devil Doppelganger Check
	{
		Write<byte8>((appBaseAddr + 0x1E7775), (enable) ? 0xEB : 0x75);
		/*
		dmc3.exe+1E776E - 80 BF 62630000 01 - cmp byte ptr [rdi+00006362],01
		dmc3.exe+1E7775 - 75 0E             - jne dmc3.exe+1E7785
		*/
	}
	{
		auto dest = (appBaseAddr + 0x1E77DC);
		if (enable)
		{
			WriteJump(dest, DevilButtonCheckAddr, 2);
		}
		else
		{
			constexpr byte8 buffer[] =
			{
				0x40, 0x38, 0xB7, 0x9B, 0x3E, 0x00, 0x00, // cmp [rdi+00003E9B],sil
			};
			CopyMemory(dest, buffer, sizeof(buffer), MemoryFlags_VirtualProtectDestination);
		}
		/*
		dmc3.exe+1E77DC - 40 38 B7 9B3E0000 - cmp [rdi+00003E9B],sil
		dmc3.exe+1E77E3 - 0F85 D4000000     - jne dmc3.exe+1E78BD
		*/
	}

	// Activate Devil
	{
		auto dest = (appBaseAddr + 0x1E78A5);
		if (enable)
		{
			SetMemory(dest, 0x90, 5, MemoryFlags_VirtualProtectDestination);
		}
		else
		{
			WriteCall(dest, (appBaseAddr + 0x1F92C0));
		}
		/*
		dmc3.exe+1E78A5 - E8 161A0100 - call dmc3.exe+1F92C0
		dmc3.exe+1E78AA - B2 01       - mov dl,01
		*/
	}
	{
		auto dest = (appBaseAddr + 0x1E78AF);
		if (enable)
		{
			WriteCall(dest, ActivateDevilAddr);
		}
		else
		{
			WriteCall(dest, (appBaseAddr + 0x1F94D0));
		}
		/*
		dmc3.exe+1E78AF - E8 1C1C0100       - call dmc3.exe+1F94D0
		dmc3.exe+1E78B4 - C6 87 AE3E0000 01 - mov byte ptr [rdi+00003EAE],01
		*/
	}

	// Deactivate Devil
	{
		auto dest = (appBaseAddr + 0x1E78C9);
		if (enable)
		{
			SetMemory(dest, 0x90, 5, MemoryFlags_VirtualProtectDestination);
		}
		else
		{
			WriteCall(dest, (appBaseAddr + 0x1F92C0));
		}
		/*
		dmc3.exe+1E78C9 - E8 F2190100       - call dmc3.exe+1F92C0
		dmc3.exe+1E78CE - 48 8B 87 E83D0000 - mov rax,[rdi+00003DE8]
		*/
	}
	{
		auto dest = (appBaseAddr + 0x1E78E6);
		if (enable)
		{
			WriteCall(dest, DeactivateDevilAddr);
		}
		else
		{
			WriteCall(dest, (appBaseAddr + 0x1F94D0));
		}
		/*
		dmc3.exe+1E78E6 - E8 E51B0100 - call dmc3.exe+1F94D0
		dmc3.exe+1E78EB - BA 01000000 - mov edx,00000001
		*/
	}

	// Input Updates
	{
		// Disable Actor Id Check
		WriteAddress((appBaseAddr + 0x1EBD1E), (enable) ? (appBaseAddr + 0x1EBD24) : (appBaseAddr + 0x1EBDBF), 6);
		/*
		dmc3.exe+1EBD1E - 0F85 9B000000 - jne dmc3.exe+1EBDBF
		dmc3.exe+1EBD24 - 33 D2         - xor edx,edx
		*/
	}
	{
		auto dest = (appBaseAddr + 0x1EBD2D);
		if (enable)
		{
			WriteJump(dest, InputUpdateAddr[0]);
		}
		else
		{
			WriteCall(dest, (appBaseAddr + 0x32CC70));
		}
		/*
		dmc3.exe+1EBD2D - E8 3E0F1400 - call dmc3.exe+32CC70
		dmc3.exe+1EBD32 - 33 D2       - xor edx,edx
		*/
	}
	{
		auto dest = (appBaseAddr + 0x1EBD42);
		if (enable)
		{
			WriteJump(dest, InputUpdateAddr[1]);
		}
		else
		{
			WriteCall(dest, (appBaseAddr + 0x32CC80));
		}
		/*
		dmc3.exe+1EBD42 - E8 390F1400      - call dmc3.exe+32CC80
		dmc3.exe+1EBD47 - 0FB7 93 E0740000 - movzx edx,word ptr [rbx+000074E0]
		*/
	}
	{
		auto dest = (appBaseAddr + 0x1EBD64);
		if (enable)
		{
			WriteJump(dest, InputUpdateAddr[2], 2);
		}
		else
		{
			constexpr byte8 buffer[] =
			{
				0x66, 0x89, 0x8B, 0xE4, 0x74, 0x00, 0x00, // mov [rbx+000074E4],cx
			};
			CopyMemory(dest, buffer, sizeof(buffer), MemoryFlags_VirtualProtectDestination);
		}
		/*
		dmc3.exe+1EBD64 - 66 89 8B E4740000 - mov [rbx+000074E4],cx
		dmc3.exe+1EBD6B - 66 23 D0          - and dx,ax
		*/
	}
	{
		auto dest = (appBaseAddr + 0x1EBD75);
		if (enable)
		{
			WriteJump(dest, InputUpdateAddr[3], 2);
		}
		else
		{
			constexpr byte8 buffer[] =
			{
				0x66, 0x89, 0x93, 0xE6, 0x74, 0x00, 0x00, // mov [rbx+000074E6],dx
			};
			CopyMemory(dest, buffer, sizeof(buffer), MemoryFlags_VirtualProtectDestination);
		}
		/*
		dmc3.exe+1EBD75 - 66 89 93 E6740000 - mov [rbx+000074E6],dx
		dmc3.exe+1EBD7C - 33 D2             - xor edx,edx
		*/
	}
	{
		auto dest = (appBaseAddr + 0x1EBD7E);
		if (enable)
		{
			WriteJump(dest, InputUpdateAddr[4]);
		}
		else
		{
			WriteCall(dest, (appBaseAddr + 0x32CC10));
		}
		/*
		dmc3.exe+1EBD7E - E8 8D0E1400 - call dmc3.exe+32CC10
		dmc3.exe+1EBD83 - 33 D2       - xor edx,edx
		*/
	}
	{
		auto dest = (appBaseAddr + 0x1EBD97);
		if (enable)
		{
			WriteJump(dest, InputUpdateAddr[5]);
		}
		else
		{
			WriteCall(dest, (appBaseAddr + 0x32CC10));
		}
		/*
		dmc3.exe+1EBD97 - E8 740E1400 - call dmc3.exe+32CC10
		dmc3.exe+1EBD9C - 45 33 C0    - xor r8d,r8d
		*/
	}
	{
		auto dest = (appBaseAddr + 0x1EBDAF);
		if (enable)
		{
			WriteJump(dest, InputUpdateAddr[6]);
		}
		else
		{
			WriteCall(dest, (appBaseAddr + 0x32CC50));
		}
		/*
		dmc3.exe+1EBDAF - E8 9C0E1400 - call dmc3.exe+32CC50
		dmc3.exe+1EBDB4 - 33 D2       - xor edx,edx
		*/
	}
	{
		auto dest = (appBaseAddr + 0x1EBE98);
		if (enable)
		{
			WriteJump(dest, InputUpdateAddr[7]);
		}
		else
		{
			WriteCall(dest, (appBaseAddr + 0x32CC50));
		}
		/*
		dmc3.exe+1EBE98 - E8 B30D1400       - call dmc3.exe+32CC50
		dmc3.exe+1EBE9D - 66 89 83 0A750000 - mov [rbx+0000750A],ax
		*/
	}

	// @Todo: Review.
	WriteAddress((appBaseAddr + 0x32D0AA), (enable) ? (appBaseAddr + 0x32D0B0) : (appBaseAddr + 0x32D346), 6);
	/*
	dmc3.exe+32D0AA - 0F85 96020000  - jne dmc3.exe+32D346
	dmc3.exe+32D0B0 - 4C 8D 44 24 38 - lea r8,[rsp+38]
	*/

	Write<uint8>((appBaseAddr + 0x2AF8F + 2), (enable) ? 3 : 1); // @Todo: MAX_PLAYER.
	/*
	dmc3.exe+2AF8F - 83 F9 01 - cmp ecx,01
	dmc3.exe+2AF92 - 76 11    - jna dmc3.exe+2AFA5
	*/

	{
		auto dest = (appBaseAddr + 0x2AFA5);
		if (enable)
		{
			WriteJump(dest, InputUpdateAddr[8]);
		}
		else
		{
			WriteCall(dest, (appBaseAddr + 0x2ACD0));
		}
		/*
		dmc3.exe+2AFA5 - E8 26FDFFFF - call dmc3.exe+2ACD0
		dmc3.exe+2AFC6 - 49 6B C8 2C - imul rcx,r8,2C
		*/
	}

	Write<byte32>((appBaseAddr + 0x32CFB6 + 3), (enable) ? 0x63C : 0x624);
	/*
	dmc3.exe+32CFB6 - 48 81 FE 24060000 - cmp rsi,00000624
	dmc3.exe+32CFBD - 0F8C 7DFEFFFF     - jl dmc3.exe+32CE40
	*/

	// // Update Collision Data
	// {
	// 	auto dest = (appBaseAddr + 0x1EEFFC);
	// 	if (enable)
	// 	{
	// 		WriteJump(dest, UpdateCollisionDataAddr);
	// 	}
	// 	else
	// 	{
	// 		WriteCall(dest, (appBaseAddr + 0x5C260));
	// 	}
	// 	/*
	// 	dmc3.exe+1EEFFC - E8 5FD2E6FF       - call dmc3.exe+5C260
	// 	dmc3.exe+1EF001 - 83 BE 943E0000 03 - cmp dword ptr [rsi+00003E94],03
	// 	*/
	// }

	// @Todo: Review.
	// Reset Lock-On
	{
		auto dest = (appBaseAddr + 0x1F8401);
		if (enable)
		{
			SetMemory(dest, 0x90, 7, MemoryFlags_VirtualProtectDestination);
			constexpr byte8 buffer[] =
			{
				0x48, 0x8B, 0xCF ,
			};
			CopyMemory(dest, buffer, sizeof(buffer), MemoryFlags_VirtualProtectDestination);
		}
		else
		{
			constexpr byte8 buffer[] =
			{
				0x0F, 0xB6, 0x97, 0x18, 0x01, 0x00, 0x00, // movzx edx,byte ptr [rdi+00000118]
			};
			CopyMemory(dest, buffer, sizeof(buffer), MemoryFlags_VirtualProtectDestination);
		}
		/*
		dmc3.exe+1F8401 - 0FB6 97 18010000 - movzx edx,byte ptr [rdi+00000118]
		dmc3.exe+1F8408 - E8 5321FCFF      - call dmc3.exe+1BA560
		*/
	}
	{
		auto dest = (appBaseAddr + 0x1F90BD);
		if (enable)
		{
			SetMemory(dest, 0x90, 14, MemoryFlags_VirtualProtectDestination);
			constexpr byte8 buffer[] =
			{
				0x48, 0x8B, 0xCF ,
			};
			CopyMemory(dest, buffer, sizeof(buffer), MemoryFlags_VirtualProtectDestination);
		}
		else
		{
			constexpr byte8 buffer[] =
			{
				0x0F, 0xB6, 0x97, 0x18, 0x01, 0x00, 0x00, // movzx edx,byte ptr [rdi+00000118]
				0x48, 0x8B, 0x0D, 0x5D, 0x7D, 0xA9, 0x00, // mov rcx,[dmc3.exe+C90E28]
			};
			CopyMemory(dest, buffer, sizeof(buffer), MemoryFlags_VirtualProtectDestination);
		}
		/*
		dmc3.exe+1F90BD - 0FB6 97 18010000  - movzx edx,byte ptr [rdi+00000118]
		dmc3.exe+1F90C4 - 48 8B 0D 5D7DA900 - mov rcx,[dmc3.exe+C90E28]
		*/
	}
	{
		auto dest = (appBaseAddr + 0x1BA560);
		if (enable)
		{
			SetMemory(dest, 0x90, 3, MemoryFlags_VirtualProtectDestination);
		}
		else
		{
			constexpr byte8 buffer[] =
			{
				0x48, 0x63, 0xC2, // movsxd rax,edx
			};
			CopyMemory(dest, buffer, sizeof(buffer), MemoryFlags_VirtualProtectDestination);
		}
		/*
		dmc3.exe+1BA560 - 48 63 C2       - movsxd rax,edx
		dmc3.exe+1BA563 - 41 B9 FF000000 - mov r9d,000000FF
		*/
	}
	{
		auto dest = (appBaseAddr + 0x1BA569);
		if (enable)
		{
			SetMemory(dest, 0x90, 9, MemoryFlags_VirtualProtectDestination);
			constexpr byte8 buffer[] =
			{
				0x4C, 0x8B, 0xC1, // mov r8,rcx
			};
			CopyMemory(dest, buffer, sizeof(buffer), MemoryFlags_VirtualProtectDestination);
		}
		else
		{
			constexpr byte8 buffer[] =
			{
				0x4C, 0x8B, 0x44, 0xC1, 0x18, // mov r8,[rcx+rax*8+18]
				0x4C, 0x8D, 0x14, 0xC1,       // lea r10,[rcx+rax*8]
			};
			CopyMemory(dest, buffer, sizeof(buffer), MemoryFlags_VirtualProtectDestination);
		}
		/*
		dmc3.exe+1BA569 - 4C 8B 44 C1 18 - mov r8,[rcx+rax*8+18]
		dmc3.exe+1BA56E - 4C 8D 14 C1    - lea r10,[rcx+rax*8]
		*/
	}
	{
		auto dest = (appBaseAddr + 0x1BA5C5);
		if (enable)
		{
			SetMemory(dest, 0x90, 11, MemoryFlags_VirtualProtectDestination);
			constexpr byte8 buffer[] =
			{
				0x45, 0x89, 0x98, 0x40, 0x20, 0x00, 0x00, // mov [r8+00002040],r11d
			};
			CopyMemory(dest, buffer, sizeof(buffer), MemoryFlags_VirtualProtectDestination);
		}
		else
		{
			constexpr byte8 buffer[] =
			{
				0x49, 0x8B, 0x42, 0x18,                   // mov rax,[r10+18]
				0x44, 0x89, 0x98, 0x08, 0x62, 0x00, 0x00, // mov [rax+00006208],r11d
			};
			CopyMemory(dest, buffer, sizeof(buffer), MemoryFlags_VirtualProtectDestination);
		}
		/*
		dmc3.exe+1BA5C5 - 49 8B 42 18       - mov rax,[r10+18]
		dmc3.exe+1BA5C9 - 44 89 98 08620000 - mov [rax+00006208],r11d
		*/
	}

	// // Disable Reset Visibility
	// {
	// 	auto dest = (appBaseAddr + 0x1F8AEE);
	// 	if (enable)
	// 	{
	// 		SetMemory(dest, 0x90, 10, MemoryFlags_VirtualProtectDestination);
	// 	}
	// 	else
	// 	{
	// 		constexpr byte8 buffer[] =
	// 		{
	// 			0xC7, 0x87, 0x20, 0x01, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, // mov [rdi+00000120],00000001
	// 		};
	// 		CopyMemory(dest, buffer, sizeof(buffer), MemoryFlags_VirtualProtectDestination);
	// 	}
	// 	/*
	// 	dmc3.exe+1F8AEE - C7 87 20010000 01000000 - mov [rdi+00000120],00000001
	// 	dmc3.exe+1F8AF8 - 80 BF 9B3E0000 01       - cmp byte ptr [rdi+00003E9B],01
	// 	*/
	// }
	// {
	// 	auto dest = (appBaseAddr + 0x1F7CBA);
	// 	if (enable)
	// 	{
	// 		SetMemory(dest, 0x90, 10, MemoryFlags_VirtualProtectDestination);
	// 	}
	// 	else
	// 	{
	// 		constexpr byte8 buffer[] =
	// 		{
	// 			0xC7, 0x83, 0x20, 0x01, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, // mov [rbx+00000120],00000001
	// 		};
	// 		CopyMemory(dest, buffer, sizeof(buffer), MemoryFlags_VirtualProtectDestination);
	// 	}
	// 	/*
	// 	dmc3.exe+1F7CBA - C7 83 20010000 01000000 - mov [rbx+00000120],00000001
	// 	dmc3.exe+1F7CC4 - E8 474E0000             - call dmc3.exe+1FCB10
	// 	*/
	// }
	// {
	// 	auto dest = (appBaseAddr + 0x1DFC7F);
	// 	if (enable)
	// 	{
	// 		SetMemory(dest, 0x90, 6, MemoryFlags_VirtualProtectDestination);
	// 	}
	// 	else
	// 	{
	// 		constexpr byte8 buffer[] =
	// 		{
	// 			0x89, 0x81, 0x20, 0x01, 0x00, 0x00, // mov [rcx+00000120],eax
	// 		};
	// 		CopyMemory(dest, buffer, sizeof(buffer), MemoryFlags_VirtualProtectDestination);
	// 	}
	// 	/*
	// 	dmc3.exe+1DFC7F - 89 81 20010000    - mov [rcx+00000120],eax
	// 	dmc3.exe+1DFC85 - 48 89 81 583E0000 - mov [rcx+00003E58],rax
	// 	*/
	// }
	// {
	// 	auto dest = (appBaseAddr + 0x1FCA43);
	// 	if (enable)
	// 	{
	// 		SetMemory(dest, 0x90, 6, MemoryFlags_VirtualProtectDestination);
	// 	}
	// 	else
	// 	{
	// 		constexpr byte8 buffer[] =
	// 		{
	// 			0x89, 0x91, 0x20, 0x01, 0x00, 0x00, // mov [rcx+00000120],edx
	// 		};
	// 		CopyMemory(dest, buffer, sizeof(buffer), MemoryFlags_VirtualProtectDestination);
	// 	}
	// 	/*
	// 	dmc3.exe+1FCA43 - 89 91 20010000 - mov [rcx+00000120],edx
	// 	dmc3.exe+1FCA49 - 8B EA          - mov ebp,edx
	// 	*/
	// }

	// Force Update Summoned Swords
	{
		WriteAddress((appBaseAddr + 0x1DAF30), (enable) ? (appBaseAddr + 0x1DAF36) : (appBaseAddr + 0x1DB099), 6);
		/*
		dmc3.exe+1DAF30 - 0F84 63010000     - je dmc3.exe+1DB099
		dmc3.exe+1DAF36 - C6 81 E80D0000 00 - mov byte ptr [rcx+00000DE8],00
		*/
	}

	// Dot Shadow Check
	{
		auto dest = (appBaseAddr + 0x93D60);
		if (enable)
		{
			WriteJump(dest, DotShadowCheckAddr, 1);
		}
		else
		{
			constexpr byte8 buffer[] =
			{
				0x40, 0x53,             // push rbx
				0x48, 0x83, 0xEC, 0x20, // sub rsp,20
			};
			CopyMemory(dest, buffer, sizeof(buffer), MemoryFlags_VirtualProtectDestination);
		}
		/*
		dmc3.exe+93D60 - 40 53       - push rbx
		dmc3.exe+93D62 - 48 83 EC 20 - sub rsp,20
		dmc3.exe+93D66 - 48 8B D9    - mov rbx,rcx
		*/
	}

	// Reset Actor Mode
	{
		auto dest = (appBaseAddr + 0x1E14E1);
		if (enable)
		{
			WriteJump(dest, ResetActorModeAddr);
		}
		else
		{
			constexpr byte8 buffer[] =
			{
				0x48, 0x8B, 0x5C, 0x24, 0x50, // mov rbx,[rsp+50]
			};
			CopyMemory(dest, buffer, sizeof(buffer), MemoryFlags_VirtualProtectDestination);
		}
		/*
		dmc3.exe+1E14E1 - 48 8B 5C 24 50 - mov rbx,[rsp+50]
		dmc3.exe+1E14E6 - 48 83 C4 40    - add rsp,40
		*/
	}

	// // Disable Actor Data Copy Check
	// {
	// 	auto dest = (appBaseAddr + 0x2198D0);
	// 	if (enable)
	// 	{
	// 		WriteJump(dest, DisableActorDataCopyCheckAddr, 2);
	// 	}
	// 	else
	// 	{
	// 		constexpr byte8 buffer[] =
	// 		{
	// 			0x0F, 0xB6, 0x81, 0x98, 0x64, 0x00, 0x00, // movzx eax,byte ptr [rcx+00006498]
	// 		};
	// 		CopyMemory(dest, buffer, sizeof(buffer), MemoryFlags_VirtualProtectDestination);
	// 	}
	// 	/*
	// 	dmc3.exe+2198D0 - 0FB6 81 98640000 - movzx eax,byte ptr [rcx+00006498]
	// 	dmc3.exe+2198D7 - 45 33 C0         - xor r8d,r8d
	// 	*/
	// }

	// Collision Check
	{
		auto dest = (appBaseAddr + 0x5C320);
		if (enable)
		{
			WriteJump(dest, CollisionCheckAddr);
		}
		else
		{
			constexpr byte8 buffer[] =
			{
				0x48, 0x89, 0x5C, 0x24, 0x08, // mov [rsp+08],rbx
			};
			CopyMemory(dest, buffer, sizeof(buffer), MemoryFlags_VirtualProtectDestination);
		}
		/*
		dmc3.exe+5C320 - 48 89 5C 24 08 - mov [rsp+08],rbx
		dmc3.exe+5C325 - 48 89 74 24 10 - mov [rsp+10],rsi
		*/
	}

	// // Quicksilver Check
	// {
	// 	auto dest = (appBaseAddr + 0x1F8A00);
	// 	if (enable)
	// 	{
	// 		WriteJump(dest, QuicksilverCheckAddr, 2);
	// 	}
	// 	else
	// 	{
	// 		constexpr byte8 buffer[] =
	// 		{
	// 			0x80, 0xBF, 0x61, 0x63, 0x00, 0x00, 0x01, // cmp byte ptr [rdi+00006361],01
	// 		};
	// 		CopyMemory(dest, buffer, sizeof(buffer), MemoryFlags_VirtualProtectDestination);
	// 	}
	// 	/*
	// 	dmc3.exe+1F8A00 - 80 BF 61630000 01 - cmp byte ptr [rdi+00006361],01
	// 	dmc3.exe+1F8A07 - 0F85 9F000000     - jne dmc3.exe+1F8AAC
	// 	*/
	// }






	// Reset Visibility Air Trick Dante
	{
		auto dest = (appBaseAddr + 0x1F1F2C);
		if (enable)
		{
			WriteJump(dest, ResetVisibilityAddr[0], 1);
		}
		else
		{
			constexpr byte8 buffer[] =
			{
				0x89, 0x8F, 0x20, 0x01, 0x00, 0x00, // mov [rdi+00000120],ecx
			};
			CopyMemory(dest, buffer, sizeof(buffer), MemoryFlags_VirtualProtectDestination);
		}
		/*
		dmc3.exe+1F1F2C - 89 8F 20010000 - mov [rdi+00000120],ecx
		dmc3.exe+1F1F32 - 48 8B CF       - mov rcx,rdi
		*/
	}

	// Reset Visibility Air Trick Vergil, Trick Up & Trick Down
	{
		auto dest = (appBaseAddr + 0x1F071E);
		if (enable)
		{
			WriteJump(dest, ResetVisibilityAddr[1], 1);
		}
		else
		{
			constexpr byte8 buffer[] =
			{
				0x89, 0xBB, 0x20, 0x01, 0x00, 0x00, // mov [rbx+00000120],edi
			};
			CopyMemory(dest, buffer, sizeof(buffer), MemoryFlags_VirtualProtectDestination);
		}
		/*
		dmc3.exe+1F071E - 89 BB 20010000    - mov [rbx+00000120],edi
		dmc3.exe+1F0724 - 66 39 BB 1A3E0000 - cmp [rbx+00003E1A],di
		*/
	}





	// Enable Visibility Check
	{
		auto dest = (appBaseAddr + 0x1DFD16);
		if (enable)
		{
			WriteJump(dest, EnableVisibilityCheckAddr[0], 2);
		}
		else
		{
			constexpr byte8 buffer[] =
			{
				0x83, 0xB9, 0x20, 0x01, 0x00, 0x00, 0x00, // cmp dword ptr [rcx+00000120],00
			};
			CopyMemory(dest, buffer, sizeof(buffer), MemoryFlags_VirtualProtectDestination);
		}
		/*
		dmc3.exe+1DFD16 - 83 B9 20010000 00 - cmp dword ptr [rcx+00000120],00
		dmc3.exe+1DFD1D - 48 8B D9          - mov rbx,rcx
		dmc3.exe+1DFD20 - 74 34             - je dmc3.exe+1DFD56
		dmc3.exe+1DFD22 - 48 63 81 6C3E0000 - movsxd rax,dword ptr [rcx+00003E6C]
		*/
	}
	{
		auto dest = (appBaseAddr + 0x1FDE20);
		if (enable)
		{
			WriteJump(dest, EnableVisibilityCheckAddr[1], 2);
		}
		else
		{
			constexpr byte8 buffer[] =
			{
				0x83, 0xB8, 0x20, 0x01, 0x00, 0x00, 0x00, // cmp dword ptr [rax+00000120],00
			};
			CopyMemory(dest, buffer, sizeof(buffer), MemoryFlags_VirtualProtectDestination);
		}
		/*
		dmc3.exe+1FDE20 - 83 B8 20010000 00 - cmp dword ptr [rax+00000120],00
		dmc3.exe+1FDE27 - 74 56             - je dmc3.exe+1FDE7F
		dmc3.exe+1FDE29 - 48 89 5C 24 30    - mov [rsp+30],rbx
		*/
	}



	// Play Quicksilver Motion
	{
		auto dest = (appBaseAddr + 0x1F63B2);
		if (enable)
		{
			WriteJump(dest, PlayQuicksilverMotionAddr[0]);
		}
		else
		{
			WriteCall(dest, (appBaseAddr + 0x1EFB90));
		}
		/*
		dmc3.exe+1F63B2 - E8 D997FFFF - call dmc3.exe+1EFB90
		dmc3.exe+1F63B7 - BA 01000000 - mov edx,00000001
		*/
	}
	{
		auto dest = (appBaseAddr + 0x1F63D6);
		if (enable)
		{
			WriteJump(dest, PlayQuicksilverMotionAddr[1]);
		}
		else
		{
			WriteCall(dest, (appBaseAddr + 0x1EFB90));
		}
		/*
		dmc3.exe+1F63D6 - E8 B597FFFF    - call dmc3.exe+1EFB90
		dmc3.exe+1F63DB - FE 83 103E0000 - inc byte ptr [rbx+00003E10]
		*/
	}




	// // Magic Points Run Out
	// {
	// 	auto dest = (appBaseAddr + 0x1E1856);
	// 	if (enable)
	// 	{
	// 		WriteJump(dest, MagicPointsRunOutAddr, 5);
	// 	}
	// 	else
	// 	{
	// 		constexpr byte8 buffer[] =
	// 		{
	// 			0xC7, 0x81, 0xB8, 0x3E, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // mov [rcx+00003EB8],00000000
	// 		};
	// 		CopyMemory(dest, buffer, sizeof(buffer), MemoryFlags_VirtualProtectDestination);
	// 	}
	// 	/*
	// 	dmc3.exe+1E1856 - C7 81 B83E0000 00000000 - mov [rcx+00003EB8],00000000
	// 	dmc3.exe+1E1860 - F3 0F10 81 B83E0000     - movss xmm0,[rcx+00003EB8]
	// 	*/
	// }




	// Disable Set Style Data
	{
		auto dest = (appBaseAddr + 0x2BAA90);
		if (enable)
		{
			SetMemory(dest, 0x90, 7, MemoryFlags_VirtualProtectDestination);
		}
		else
		{
			constexpr byte8 buffer[] =
			{
				0x48, 0x89, 0x91, 0x10, 0x3D, 0x00, 0x00, // mov [rcx+00003D10],rdx
			};
			CopyMemory(dest, buffer, sizeof(buffer), MemoryFlags_VirtualProtectDestination);
		}
		/*
		dmc3.exe+2BAA90 - 48 89 91 103D0000 - mov [rcx+00003D10],rdx
		dmc3.exe+2BAA97 - C3                - ret 
		*/
	}




	ToggleSound(enable);








}

export void ToggleAirHikeCoreAbility(bool enable)
{
	LogFunctionHelper(__FUNCTION__, enable) ;

	Write<byte8>((appBaseAddr + 0x1E9B0E), (enable) ? 0xEB : 0x74);
	/*
	dmc3.exe+1E9B0E - 74 32    - je dmc3.exe+1E9B42
	dmc3.exe+1E9B10 - 80 F9 02 - cmp cl,02
	*/
}

export void ToggleRebellionInfiniteSwordPierce(bool enable)
{
	LogFunctionHelper(__FUNCTION__, enable) ;

	{
		auto dest = (appBaseAddr + 0x1CC9A4);
		if (enable)
		{
			SetMemory(dest, 0x90, 5, MemoryFlags_VirtualProtectDestination);
		}
		else
		{
			constexpr byte8 buffer[] =
			{
				0xF3, 0x0F, 0x5C, 0x4B, 0x14, // subss xmm1,[rbx+14]
			};
			CopyMemory(dest, buffer, sizeof(buffer), MemoryFlags_VirtualProtectDestination);
		}
		/*
		dmc3.exe+1CC9A4 - F3 0F5C 4B 14 - subss xmm1,[rbx+14]
		dmc3.exe+1CC9A9 - 0F2F C1       - comiss xmm0,xmm1
		*/
	}
	{
		auto dest = (appBaseAddr + 0x1CDA1B);
		if (enable)
		{
			SetMemory(dest, 0x90, 4, MemoryFlags_VirtualProtectDestination);
		}
		else
		{
			constexpr byte8 buffer[] =
			{
				0xF3, 0x0F, 0x5C, 0xC1, // subss xmm0,xmm1
			};
			CopyMemory(dest, buffer, sizeof(buffer), MemoryFlags_VirtualProtectDestination);
		}
		/*
		dmc3.exe+1CDA1B - F3 0F5C C1             - subss xmm0,xmm1
		dmc3.exe+1CDA1F - 44 0F29 9C 24 A0000000 - movaps [rsp+000000A0],xmm11
		*/
	}
	{
		auto dest = (appBaseAddr + 0x1CDD64);
		if (enable)
		{
			SetMemory(dest, 0x90, 5, MemoryFlags_VirtualProtectDestination);
		}
		else
		{
			constexpr byte8 buffer[] =
			{
				0xF3, 0x0F, 0x5C, 0x4B, 0x14, // subss xmm1,[rbx+14]
			};
			CopyMemory(dest, buffer, sizeof(buffer), MemoryFlags_VirtualProtectDestination);
		}
		/*
		dmc3.exe+1CDD64 - F3 0F5C 4B 14 - subss xmm1,[rbx+14]
		dmc3.exe+1CDD69 - 0F2F C1       - comiss xmm0,xmm1
		*/
	}
	{
		auto dest = (appBaseAddr + 0x1CDDCE);
		if (enable)
		{
			SetMemory(dest, 0x90, 4, MemoryFlags_VirtualProtectDestination);
		}
		else
		{
			constexpr byte8 buffer[] =
			{
				0xF3, 0x0F, 0x5C, 0xCA, // subss xmm1,xmm2
			};
			CopyMemory(dest, buffer, sizeof(buffer), MemoryFlags_VirtualProtectDestination);
		}
		/*
		dmc3.exe+1CDDCE - F3 0F5C CA - subss xmm1,xmm2
		dmc3.exe+1CDDD2 - 0F2F C1    - comiss xmm0,xmm1
		*/
	}
	{
		auto dest = (appBaseAddr + 0x21562E);
		if (enable)
		{
			SetMemory(dest, 0x90, 5, MemoryFlags_VirtualProtectDestination);
		}
		else
		{
			constexpr byte8 buffer[] =
			{
				0xF3, 0x0F, 0x5C, 0x47, 0x14, // subss xmm0,[rdi+14]
			};
			CopyMemory(dest, buffer, sizeof(buffer), MemoryFlags_VirtualProtectDestination);
		}
		/*
		dmc3.exe+21562E - F3 0F5C 47 14 - subss xmm0,[rdi+14]
		dmc3.exe+215633 - 0F2F F0       - comiss xmm6,xmm0
		*/
	}
}

export void ToggleYamatoForceEdgeInfiniteRoundTrip(bool enable)
{
	LogFunctionHelper(__FUNCTION__, enable) ;

	{
		auto dest = (appBaseAddr + 0x1D86DD);
		if (enable)
		{
			SetMemory(dest, 0x90, 5, MemoryFlags_VirtualProtectDestination);
		}
		else
		{
			constexpr byte8 buffer[] =
			{
				0xF3, 0x0F, 0x5C, 0x47, 0x14, // subss xmm0,[rdi+14]
			};
			CopyMemory(dest, buffer, sizeof(buffer), MemoryFlags_VirtualProtectDestination);
		}
		/*
		dmc3.exe+1D86DD - F3 0F5C 47 14 - subss xmm0,[rdi+14]
		dmc3.exe+1D86E2 - 0F2F F0       - comiss xmm6,xmm0
		*/
	}
	{
		auto dest = (appBaseAddr + 0x222921);
		if (enable)
		{
			SetMemory(dest, 0x90, 5, MemoryFlags_VirtualProtectDestination);
		}
		else
		{
			constexpr byte8 buffer[] =
			{
				0xF3, 0x0F, 0x5C, 0x47, 0x14, // subss xmm0,[rdi+14]
			};
			CopyMemory(dest, buffer, sizeof(buffer), MemoryFlags_VirtualProtectDestination);
		}
		/*
		dmc3.exe+222921 - F3 0F5C 47 14 - subss xmm0,[rdi+14]
		dmc3.exe+222926 - 0F2F F0       - comiss xmm6,xmm0
		*/
	}
}

export void ToggleEbonyIvoryFoursomeTime(bool enable)
{
	LogFunctionHelper(__FUNCTION__, enable) ;

	WriteAddress((appBaseAddr + 0x1E24F6), (enable) ? (appBaseAddr + 0x1E24FC) : (appBaseAddr + 0x1E259C), 6);
	/*
	dmc3.exe+1E24F6 - 0F85 A0000000  - jne dmc3.exe+1E259C
	dmc3.exe+1E24FC - 48 89 7C 24 30 - mov [rsp+30],rdi
	*/

	WriteAddress((appBaseAddr + 0x20D188), (enable) ? (appBaseAddr + 0x20D18A) : (appBaseAddr + 0x20D1AB), 2);
	/*
	dmc3.exe+20D188 - 75 21               - jne dmc3.exe+20D1AB
	dmc3.exe+20D18A - F3 0F10 83 2C690000 - movss xmm0,[rbx+0000692C]
	*/
}

export void ToggleEbonyIvoryInfiniteRainStorm(bool enable)
{
	LogFunctionHelper(__FUNCTION__, enable) ;

	auto dest = (appBaseAddr + 0x20CC0F);
	if (enable)
	{
		WriteJump(dest, EbonyIvoryRainStormCheckAddr);
	}
	else
	{
		constexpr byte8 buffer[] =
		{
			0x0F, 0xA3, 0xC1, // bt ecx,eax
			0x72, 0x0C,       // jb dmc3.exe+20CC20
		};
		CopyMemory(dest, buffer, sizeof(buffer), MemoryFlags_VirtualProtectDestination);
	}
	/*
	dmc3.exe+20CC0F - 0FA3 C1             - bt ecx,eax
	dmc3.exe+20CC12 - 72 0C               - jb dmc3.exe+20CC20
	dmc3.exe+20CC14 - BF 01000000         - mov edi,00000001
	dmc3.exe+20CC20 - F3 0F10 83 383E0000 - movss xmm0,[rbx+00003E38]
	*/
}

export void ToggleArtemisSwapNormalShotAndMultiLock(bool enable)
{
	LogFunctionHelper(__FUNCTION__, enable) ;

	{
		auto dest = (appBaseAddr + 0x215C78);
		if (enable)
		{
			constexpr byte8 buffer[] =
			{
				0xC6, 0x87, 0x80, 0xB8, 0x00, 0x00, 0x01, // mov byte ptr [rdi+0000B880],01
			};
			CopyMemory(dest, buffer, sizeof(buffer), MemoryFlags_VirtualProtectDestination);
		}
		else
		{
			constexpr byte8 buffer[] =
			{
				0x44, 0x88, 0xB7, 0x80, 0xB8, 0x00, 0x00, // mov [rdi+0000B880],r14l
			};
			CopyMemory(dest, buffer, sizeof(buffer), MemoryFlags_VirtualProtectDestination);
		}
		/*
		dmc3.exe+215C78 - 44 88 B7 80B80000 - mov [rdi+0000B880],r14l
		dmc3.exe+215C7F - 83 F8 02          - cmp eax,02
		*/
	}

	Write<uint8>((appBaseAddr + 0x215CD4 + 6), (enable) ? 0 : 1);
	/*
	dmc3.exe+215CD4 - C6 87 80B80000 01 - mov byte ptr [rdi+0000B880],01
	dmc3.exe+215CDB - 44 0F28 C7        - movaps xmm8,xmm7
	*/
}

export void ToggleArtemisInstantFullCharge(bool enable)
{
	LogFunctionHelper(__FUNCTION__, enable) ;

	WriteAddress((appBaseAddr + 0x215E42), (enable) ? (appBaseAddr + 0x215E48) : (appBaseAddr + 0x215F78), 6);
	/*
	dmc3.exe+215E42 - 0F82 30010000 - jb dmc3.exe+215F78
	dmc3.exe+215E48 - 0F2F C1       - comiss xmm0,xmm1
	*/
}

export void UpdateCrazyComboLevelMultiplier()
{
	LogFunctionHelper(__FUNCTION__) ;

	Write<uint8>((appBaseAddr + 0x5898DE), activeConfig.crazyComboLevelMultiplier);
	Write<uint8>((appBaseAddr + 0x58999E), activeConfig.crazyComboLevelMultiplier);
	Write<uint8>((appBaseAddr + 0x589A5E), activeConfig.crazyComboLevelMultiplier);
}

export void ToggleChronoSwords(bool enable)
{
	LogFunctionHelper(__FUNCTION__, enable) ;

	static bool run = false;

	{
		auto addr     = (appBaseAddr + 0x1DB8F8);
		auto jumpAddr = (appBaseAddr + 0x1DB8FD);
		constexpr uint32 size = 5;
		/*
		dmc3.exe+1DB8F8 - F3 0F5C 43 14 - subss xmm0,[rbx+14]
		dmc3.exe+1DB8FD - 0F2F F0       - comiss xmm6,xmm0
		*/

		static Function func = {};

		constexpr byte8 sect0[] =
		{
			0x48, 0xB8, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // mov rax
			0x8A, 0x00,                                                 // mov al,[rax]
			0x84, 0xC0,                                                 // test al,al
			0x0F, 0x85, 0x00, 0x00, 0x00, 0x00,                         // jne dmc3.exe+1DB8FD
		};

		if (!run)
		{
			backupHelper.Save(addr, size);
			func = CreateFunction(0, jumpAddr, false, true, (sizeof(sect0) + size));
			CopyMemory(func.sect0, sect0, sizeof(sect0));
			*reinterpret_cast<bool **>(func.sect0 + 2) = &g_quicksilver;
			WriteAddress((func.sect0 + 0xE), (appBaseAddr + 0x1DB8FD), 6);
			CopyMemory((func.sect0 + sizeof(sect0)), addr, size, MemoryFlags_VirtualProtectSource);
		}

		if (enable)
		{
			WriteJump(addr, func.addr, (size - 5));
		}
		else
		{
			backupHelper.Restore(addr);
		}
	}

	run = true;
}

#pragma region Events

// @Todo: Add event tag.

export void Actor_CreateMainActor(byte8 * actorBaseAddr)
{
	if (!activeConfig.Actor.enable)
	{
		return;
	}

	LogFunctionHelper(__FUNCTION__, actorBaseAddr) ;

	Actor_actorBaseAddr.Clear();

	File_dynamicFiles.Clear();

	Actor_actorBaseAddr[0] = actorBaseAddr;
	Actor_actorBaseAddr.count = 2;


	// if (!actorBaseAddr)
	// {
	// 	return;
	// }
	// auto & actorData = *reinterpret_cast<ActorData *>(actorBaseAddr);

	// actorData.shadow = 0;
	// actorData.lastShadow = 0;



}

export void Actor_CreateCloneActor(byte8 * actorBaseAddr)
{
	if (!activeConfig.Actor.enable)
	{
		return;
	}

	LogFunctionHelper(__FUNCTION__, actorBaseAddr) ;

	Actor_actorBaseAddr[1] = actorBaseAddr;


	// if (!actorBaseAddr)
	// {
	// 	return;
	// }
	// auto & actorData = *reinterpret_cast<ActorData *>(actorBaseAddr);

	// actorData.shadow = 0;
	// actorData.lastShadow = 0;



}

export void Actor_Customize()
{
	if (!activeConfig.Actor.enable)
	{
		return;
	}

	LogFunctionHelper(__FUNCTION__) ;

	SetMainActor(0);
}

export void Actor_Delete()
{
	if (!activeConfig.Actor.enable)
	{
		return;
	}

	LogFunctionHelper(__FUNCTION__) ;

	SetMainActor(0);

	Actor_actorBaseAddr.Clear();

	File_dynamicFiles.Clear();
}


export void Actor_EventContinue()
{
	LogFunctionHelper(__FUNCTION__) ;

	SetMainActor(0);
}





export void Actor_InGameCutsceneStart()
{
	LogFunctionHelper(__FUNCTION__) ;

	for (uint32 index = 2; index < Actor_actorBaseAddr.count; index++)
	{
		auto actorBaseAddr = Actor_actorBaseAddr[index];if (!actorBaseAddr){ continue;}auto & actorData = *reinterpret_cast<ActorData *>(actorBaseAddr) ;
		auto actorBaseAddr2 = Actor_actorBaseAddr[0];if (!actorBaseAddr2){ continue;}auto & actorData2 = *reinterpret_cast<ActorData *>(actorBaseAddr2) ;

		auto & playerData = GetPlayerData(actorData);

		if
		(
			(actorData.newPlayerIndex == 0) &&
			(actorData.newCharacterIndex == playerData.activeCharacterIndex) &&
			(actorData.newEntityIndex == ENTITY_MAIN)
		)
		{
			actorData.motionArchives[MOTION_GROUP_IN_GAME_CUTSCENE] = actorData2.motionArchives[MOTION_GROUP_IN_GAME_CUTSCENE];

			Log("doppelganger %u", actorData.doppelganger);

			if (actorData.doppelganger)
			{
				actorData.cloneStatus = CLONE_STATUS_DECOMMISSION;

				DeactivateDoppelganger(actorData);
			}

			break;
		}
	}

	// ToggleActor(0, true);
	// ToggleActor(1, false);

	// for_each(uint32, index, 2, Actor_actorBaseAddr.count)
	// {
	// 	ToggleActor(index, false);
	// }

	// SetMainActor(0);
}

export void Actor_InGameCutsceneEnd()
{
	LogFunctionHelper(__FUNCTION__) ;

	constexpr uint8 playerIndex = 0;

	auto & playerData = GetPlayerData(playerIndex);

	for (uint32 index = 2; index < Actor_actorBaseAddr.count; index++)
	{
		auto actorBaseAddr = Actor_actorBaseAddr[index];if (!actorBaseAddr){ continue;}auto & actorData = *reinterpret_cast<ActorData *>(actorBaseAddr) ;

		auto & characterData = GetCharacterData(actorData);

		if
		(
			(actorData.newPlayerIndex == playerIndex) &&
			(actorData.newCharacterIndex == playerData.activeCharacterIndex) &&
			(actorData.newEntityIndex == ENTITY_MAIN)
		)
		{
			HUD_UpdateStyleIcon
			(
				GetStyle(actorData),
				characterData.character
			);

			break;
		}
	}
}




bool IsBob()
{
	auto & sessionData = *reinterpret_cast<SessionData *>(appBaseAddr + 0xC8F250) ;
	auto pool_22028 = *reinterpret_cast<byte8 ***>(appBaseAddr + 0xC90E10);if (!pool_22028){ return false;}if (!pool_22028[8]){ return false;}auto & eventData = *reinterpret_cast<EventData *>(pool_22028[8]) ;
	auto actorBaseAddr = Actor_actorBaseAddr[1];if (!actorBaseAddr){ return false;}auto & actorData = *reinterpret_cast<ActorData *>(actorBaseAddr) ;

	if
	(
		(sessionData.mission != 19) ||
		(eventData.room != 421) ||
		(actorData.character != CHAR_BOB)
	)
	{
		return false;
	}

	return true;
}




export void Actor_MainLoopOnce()
{
	if (!activeConfig.Actor.enable)
	{
		return;
	}

	LogFunctionHelper(__FUNCTION__) ;

	SpawnActors();

	// if (!InCutscene())
	// {
	// 	Actor_InGameCutsceneEnd();
	// }



	ToggleActor(0, false);
	ToggleActor(1, false);

	// for_each(uint32, index, 2, Actor_actorBaseAddr.count)
	// {
	// 	IntroduceActorData(actorBaseAddr, actorData, Actor_actorBaseAddr[index], continue);

	// 	CommissionActor(actorData);
	// }

	[&]()
	{
		if (!IsBob())
		{
			return;
		}

		auto actorBaseAddr = Actor_actorBaseAddr[1];if (!actorBaseAddr){ return;}auto & actorData = *reinterpret_cast<ActorData *>(actorBaseAddr) ;

		actorData.doppelganger = true;

		ToggleActor(actorData, true);

		Log("Toggled Bob.");
	}();
}

export void Actor_ActorLoop(byte8 * actorBaseAddr)
{
	if (!activeConfig.Actor.enable)
	{
		return;
	}

	if (!actorBaseAddr)
	{
		return;
	}
	auto & actorData = *reinterpret_cast<ActorData *>(actorBaseAddr);

	if (!actorData.newActorLoopRun)
	{
		actorData.newActorLoopRun = true;

		LogFunctionHelper(__FUNCTION__, actorBaseAddr) ;
	}

	if (InCutscene())
	{
		return;
	}
	else if
	(
		(actorBaseAddr == Actor_actorBaseAddr[0]) ||
		(actorBaseAddr == Actor_actorBaseAddr[1])
	)
	{
		if (actorBaseAddr == Actor_actorBaseAddr[1])
		{
			if (IsBob())
			{
				return;
			}
		}

		auto actorBaseAddr2 = Actor_actorBaseAddr[2];if (!actorBaseAddr2){ return;}auto & actorData2 = *reinterpret_cast<ActorData *>(actorBaseAddr2) ;

		CopyState
		(
			actorData2,
			actorData
		);

		return;
	}

	UpdateModelPartitions(actorData);

	if (actorData.character == CHAR_VERGIL)
	{
		IsMeleeWeaponReadyVergilFix(actorData);
	}
}

#pragma endregion

#pragma region Scenes

export void Actor_SceneMain()
{
	LogFunctionHelper(__FUNCTION__) ;

	Actor_Toggle(activeConfig.Actor.enable);
}

export void Actor_SceneMissionSelect()
{
	LogFunctionHelper(__FUNCTION__) ;

	Actor_Toggle(activeConfig.Actor.enable);
}

export void Actor_SceneMissionStart()
{
	LogFunctionHelper(__FUNCTION__) ;

	for (uint8 playerIndex = 0; playerIndex < PLAYER_COUNT; playerIndex++)
	{
		auto & playerData = GetPlayerData(playerIndex);

		playerData.activeCharacterIndex = playerData.lastCharacterIndex = playerData.characterIndex = 0;

		for (uint8 characterIndex = 0; characterIndex < CHARACTER_COUNT; characterIndex++) {
		for (uint8 entityIndex = 0; entityIndex < ENTITY_COUNT; entityIndex++)
		{
			auto & characterData = GetCharacterData
			(
				playerIndex,
				characterIndex,
				entityIndex
			);

			memset
			(
				characterData.styleIndices,
				0,
				sizeof(characterData.styleIndices)
			);

			characterData.styleButtonIndex  = 0;
			characterData.meleeWeaponIndex  = 0;
			characterData.rangedWeaponIndex = 0;
		}}
	}
}

#pragma endregion



